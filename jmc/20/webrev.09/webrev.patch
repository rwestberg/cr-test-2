diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Attribute.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Attribute.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Attribute.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent;
+
+public interface Attribute {
+	String getName();
+
+	String getFieldName();
+
+	String getDescription();
+
+	String getContentType();
+
+	String getRelationKey();
+
+	String getConverterClassName();
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Field.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Field.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Field.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent;
+
+import org.openjdk.jmc.agent.util.expression.ExpressionResolver;
+import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;
+import org.openjdk.jmc.agent.util.expression.ReferenceChain;
+import org.openjdk.jmc.agent.util.TypeUtils;
+
+public class Field implements Attribute {
+
+	private final String name;
+	private final String expression;
+	private final String fieldName;
+	private final String description;
+	private final String contentType;
+	private final String relationKey;
+	private final String converterClassName;
+
+	private Class<?> resolvingCaller;
+	private ReferenceChain referenceChain;
+
+	public Field(String name, String expression, String description, String contentType, String relationKey,
+			String converterClassName) {
+		this.name = name;
+		this.expression = expression;
+		this.description = description;
+		this.contentType = contentType;
+		this.relationKey = relationKey;
+		this.converterClassName = converterClassName;
+		this.fieldName = "field" + TypeUtils.deriveIdentifierPart(name);
+	}
+
+	@Override
+	public String getName() {
+		return this.name;
+	}
+
+	public String getExpression() {
+		return expression;
+	}
+
+	@Override
+	public String getFieldName() {
+		return this.fieldName;
+	}
+
+	@Override
+	public String getDescription() {
+		return this.description;
+	}
+
+	@Override
+	public String getContentType() {
+		return this.contentType;
+	}
+
+	@Override
+	public String getRelationKey() {
+		return this.relationKey;
+	}
+
+	@Override
+	public String getConverterClassName() {
+		return this.converterClassName;
+	}
+
+	public ReferenceChain resolveReferenceChain(Class<?> callerClass) throws IllegalSyntaxException {
+		if (!callerClass.equals(resolvingCaller)) {
+			resolvingCaller = callerClass;
+			referenceChain = ExpressionResolver.solve(callerClass, expression);
+		}
+
+		return referenceChain;
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -35,11 +35,11 @@
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 /**
  * Metadata for a parameter to be logged by the agent.
  */
-public final class Parameter {
+public final class Parameter implements Attribute {
 	public static final int INDEX_INVALID = -1;
 
 	private final int index;
 	private final String name;
 	private final String fieldName;
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -35,20 +35,24 @@
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 /**
  * Metadata for a return value to be logged by the agent.
  */
-public final class ReturnValue {
+public final class ReturnValue implements Attribute {
 	private final String name;
 	private final String fieldName;
 	private final String description;
 	private final String contentType;
+	private final String relationKey;
+	private final String converterClassName;
 
-	public ReturnValue(String name, String description, String contentType) {
+	public ReturnValue(String name, String description, String contentType, String relationKey, String converterClassName) {
 		this.name = name == null ? "Return Value" : name;
 		this.description = description;
 		this.contentType = contentType;
+		this.relationKey = relationKey;
+		this.converterClassName = converterClassName;
 		this.fieldName = "field" + TypeUtils.deriveIdentifierPart(this.name); //$NON-NLS-1$
 	}
 
 	public String getName() {
 		return name;
@@ -60,10 +64,20 @@
 
 	public String getContentType() {
 		return contentType;
 	}
 
+	@Override
+	public String getRelationKey() {
+		return relationKey;
+	}
+
+	@Override
+	public String getConverterClassName() {
+		return converterClassName;
+	}
+
 	public String getFieldName() {
 		return fieldName;
 	}
 
 }
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -103,12 +103,12 @@
 	 * @param parameters
 	 *            the parameters to include (see {@link Parameter}).
 	 * @return the instantiated {@link TransformDescriptor}.
 	 */
 	public static TransformDescriptor create(
-		String id, String internalName, Method method, Map<String, String> values, List<Parameter> parameters, ReturnValue returnValue) {
-		return new JFRTransformDescriptor(id, internalName, method, values, parameters, returnValue);
+		String id, String internalName, Method method, Map<String, String> values, List<Parameter> parameters, ReturnValue returnValue, List<Field> fields) {
+		return new JFRTransformDescriptor(id, internalName, method, values, parameters, returnValue, fields);
 	}
 
 	@Override
 	public String toString() {
 		return String.format("TransformDescriptor [method:%s]", method.toString()); //$NON-NLS-1$
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Transformer.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Transformer.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Transformer.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Transformer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -45,10 +45,11 @@
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.jfr.VersionResolver;
 import org.openjdk.jmc.agent.jfr.VersionResolver.JFRVersion;
 import org.openjdk.jmc.agent.jfr.impl.JFRClassVisitor;
 import org.openjdk.jmc.agent.jfrnext.impl.JFRNextClassVisitor;
+import org.openjdk.jmc.agent.util.InspectionClassLoader;
 
 public class Transformer implements ClassFileTransformer {
 	private TransformRegistry registry;
 
 	public Transformer(TransformRegistry registry) {
@@ -60,45 +61,54 @@
 		ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
 		byte[] classfileBuffer) throws IllegalClassFormatException {
 		if (!registry.hasPendingTransforms(className)) {
 			return registry.isRevertIntrumentation() ? classfileBuffer : null;
 		}
-		return doTransforms(registry.getTransformData(className), classfileBuffer, loader, protectionDomain);
+
+		// We need a class instance for reflective inspection, so create a InspectionClassLoader if the class if not yet 
+		// loaded.
+		return doTransforms(registry.getTransformData(className), classfileBuffer, loader, classBeingRedefined,
+				protectionDomain, classBeingRedefined != null ? null : new InspectionClassLoader(loader));
 	}
 
 	private byte[] doTransforms(
 		List<TransformDescriptor> transformDataList, byte[] classfileBuffer, ClassLoader definingClassLoader,
-		ProtectionDomain protectionDomain) {
+			Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+			InspectionClassLoader inspectionClassLoader) {
 		for (TransformDescriptor td : transformDataList) {
 			if (td.isPendingTransforms()) {
 				// FIXME: Optimization, should do all transforms to one class in one go, instead of creating one class writer per transform.
-				classfileBuffer = doTransform(td, classfileBuffer, definingClassLoader, protectionDomain);
+				classfileBuffer = doTransform(td, classfileBuffer, definingClassLoader, classBeingRedefined,
+						protectionDomain, inspectionClassLoader);
 				td.setPendingTransforms(false);
 			}
 		}
 		return classfileBuffer;
 	}
 
 	private byte[] doTransform(
-		TransformDescriptor td, byte[] classfileBuffer, ClassLoader definingClassLoader,
-		ProtectionDomain protectionDomain) {
-		return doJFRLogging((JFRTransformDescriptor) td, classfileBuffer, definingClassLoader, protectionDomain);
+		TransformDescriptor td, byte[] classfileBuffer, ClassLoader definingClassLoader, Class<?> classBeingRedefined,
+			ProtectionDomain protectionDomain, InspectionClassLoader inspectionClassLoader) {
+		return doJFRLogging((JFRTransformDescriptor) td, classfileBuffer, definingClassLoader, classBeingRedefined,
+				protectionDomain, inspectionClassLoader);
 	}
 
 	private byte[] doJFRLogging(
-		JFRTransformDescriptor td, byte[] classfileBuffer, ClassLoader definingClassLoader,
-		ProtectionDomain protectionDomain) {
+		JFRTransformDescriptor td, byte[] classfileBuffer, ClassLoader definingClassLoader, Class<?> classBeingRedefined,
+			ProtectionDomain protectionDomain, InspectionClassLoader inspectionClassLoader) {
 		if (VersionResolver.getAvailableJFRVersion() == JFRVersion.NONE) {
 			Logger.getLogger(getClass().getName()).log(Level.SEVERE,
 					"Could not find JFR classes. Failed to instrument " + td.getMethod().toString()); //$NON-NLS-1$
 			return classfileBuffer;
 		}
 		try {
 			ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
-			ClassVisitor visitor = VersionResolver.getAvailableJFRVersion() == JFRVersion.JFRNEXT
-					? new JFRNextClassVisitor(classWriter, td, definingClassLoader, protectionDomain)
-					: new JFRClassVisitor(classWriter, td, definingClassLoader, protectionDomain);
+			ClassVisitor visitor = VersionResolver.getAvailableJFRVersion() == JFRVersion.JFRNEXT ?
+					new JFRNextClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined, protectionDomain,
+							inspectionClassLoader) :
+					new JFRClassVisitor(classWriter, td, definingClassLoader, classBeingRedefined, protectionDomain,
+							inspectionClassLoader); 
 			ClassReader reader = new ClassReader(classfileBuffer);
 			reader.accept(visitor, 0);
 			return classWriter.toByteArray();
 		} catch (Throwable t) {
 			Logger.getLogger(getClass().getName()).log(Level.SEVERE,
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -51,16 +51,19 @@
 import org.openjdk.jmc.agent.Method;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.TransformDescriptor;
 import org.openjdk.jmc.agent.TransformRegistry;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
+import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class DefaultTransformRegistry implements TransformRegistry {
 	private static final String XML_ATTRIBUTE_NAME_ID = "id"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_NAME_EVENT = "event"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_METHOD_NAME = "method"; //$NON-NLS-1$
+	private static final String XML_ELEMENT_FIELD_NAME = "field"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_PARAMETER_NAME = "parameter"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_RETURN_VALUE_NAME = "returnvalue"; //$NON-NLS-1$
 
 	// Global override section
 	private static final String XML_ELEMENT_CONFIGURATION = "config"; //$NON-NLS-1$
@@ -147,19 +150,24 @@
 		XMLStreamReader streamReader, HashMap<String, String> globalDefaults) throws XMLStreamException {
 		String id = streamReader.getAttributeValue("", XML_ATTRIBUTE_NAME_ID); //$NON-NLS-1$
 		streamReader.next();
 		Map<String, String> values = new HashMap<>();
 		List<Parameter> parameters = new LinkedList<>();
+		List<Field> fields = new LinkedList<>();
 		Method method = null;
 		ReturnValue[] returnValue = new ReturnValue[1];
 		while (streamReader.hasNext()) {
 			if (streamReader.isStartElement()) {
 				String name = streamReader.getName().getLocalPart();
 				if (XML_ELEMENT_METHOD_NAME.equals(name)) {
 					method = parseMethod(streamReader, parameters, returnValue);
 					continue;
 				}
+				if (XML_ELEMENT_FIELD_NAME.equals(name)) {
+					fields.add(parseField(streamReader));
+					continue;
+				}
 				streamReader.next();
 				if (streamReader.hasText()) {
 					String value = streamReader.getText();
 					if (value != null) {
 						value = value.trim();
@@ -173,11 +181,11 @@
 				}
 			}
 			streamReader.next();
 		}
 		transfer(globalDefaults, values);
-		return TransformDescriptor.create(id, getInternalName(values.get("class")), method, values, parameters, returnValue[0]); //$NON-NLS-1$
+		return TransformDescriptor.create(id, TypeUtils.getInternalName(values.get("class")), method, values, parameters, returnValue[0], fields); //$NON-NLS-1$
 	}
 
 	private static void transfer(HashMap<String, String> globalDefaults, Map<String, String> values) {
 		for (Entry<String, String> entry : globalDefaults.entrySet()) {
 			if (!values.containsKey(entry.getKey())) {
@@ -241,11 +249,11 @@
 						description = value;
 					} else if ("contenttype".equals(key)) { //$NON-NLS-1$
 						contentType = value;
 					} else if ("relationkey".equals(key)) { //$NON-NLS-1$
 						relationKey = value;
-					} else if ("converter".equals(key)) {
+					} else if ("converter".equals(key)) { //$NON-NLS-1$
 						converterClassName = value;
 					}
 				}
 			} else if (streamReader.isEndElement()) {
 				if (XML_ELEMENT_PARAMETER_NAME.equals(streamReader.getName().getLocalPart())) {
@@ -255,15 +263,18 @@
 			streamReader.next();
 		}
 		return new Parameter(index, name, description, contentType, relationKey, converterClassName);
 	}
 
-	private static ReturnValue parseReturnValue(XMLStreamReader streamReader) throws XMLStreamException {
+	private static Field parseField(XMLStreamReader streamReader) throws XMLStreamException {
 		streamReader.next();
 		String name = null;
+		String expression = null;
 		String description = null;
 		String contentType = null;
+		String relationKey = null;
+		String converterClassName = null;
 
 		while (streamReader.hasNext()) {
 			if (streamReader.isStartElement()) {
 				String key = streamReader.getName().getLocalPart();
 				streamReader.next();
@@ -272,28 +283,69 @@
 					if (value != null) {
 						value = value.trim();
 					}
 					if ("name".equals(key)) { //$NON-NLS-1$
 						name = value;
+					} else if ("expression".equals(key)) {
+						expression = value;
 					} else if ("description".equals(key)) { //$NON-NLS-1$
 						description = value;
 					} else if ("contenttype".equals(key)) { //$NON-NLS-1$
 						contentType = value;
+					} else if ("relationkey".equals(key)) { //$NON-NLS-1$
+						relationKey = value;
+					} else if ("converter".equals(key)) { //$NON-NLS-1$
+						converterClassName = value;
 					}
 				}
 			} else if (streamReader.isEndElement()) {
-				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(streamReader.getName().getLocalPart())) {
+				if (XML_ELEMENT_FIELD_NAME.equals(streamReader.getName().getLocalPart())) {
 					break;
 				}
 			}
 			streamReader.next();
 		}
-		return new ReturnValue(name, description, contentType);
+		return new Field(name, expression, description, contentType, relationKey, converterClassName);
 	}
 
-	private static String getInternalName(String className) {
-		return className.replace('.', '/');
+	private static ReturnValue parseReturnValue(XMLStreamReader streamReader) throws XMLStreamException {
+		streamReader.next();
+		String name = null;
+		String description = null;
+		String contentType = null;
+		String relationKey = null;
+		String converterClassName = null;
+
+		while (streamReader.hasNext()) {
+			if (streamReader.isStartElement()) {
+				String key = streamReader.getName().getLocalPart();
+				streamReader.next();
+				if (streamReader.hasText()) {
+					String value = streamReader.getText();
+					if (value != null) {
+						value = value.trim();
+					}
+					if ("name".equals(key)) { //$NON-NLS-1$
+						name = value;
+					} else if ("description".equals(key)) { //$NON-NLS-1$
+						description = value;
+					} else if ("contenttype".equals(key)) { //$NON-NLS-1$
+						contentType = value;
+					} else if ("relationkey".equals(key)) { //$NON-NLS-1$
+						relationKey = value;
+					} else if ("converter".equals(key)) { //$NON-NLS-1$
+						converterClassName = value;
+					}
+				}
+			} else if (streamReader.isEndElement()) {
+				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(streamReader.getName().getLocalPart())) {
+					break;
+				}
+			}
+			streamReader.next();
+		}
+		return new ReturnValue(name, description, contentType, relationKey, converterClassName);
 	}
 
 	private static Method parseMethod(XMLStreamReader streamReader, List<Parameter> parameters, ReturnValue[] returnValue)
 			throws XMLStreamException {
 		streamReader.next();
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -36,10 +36,11 @@
 import java.util.Map;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import org.objectweb.asm.Type;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.Method;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.TransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
@@ -60,13 +61,14 @@
 	private final boolean useRethrow;
 	private final boolean allowToString;
 	private final boolean allowConverter;
 	private final List<Parameter> parameters;
 	private final ReturnValue returnValue;
+	private final List<Field> fields;
 
 	public JFRTransformDescriptor(String id, String className, Method method,
-			Map<String, String> transformationAttributes, List<Parameter> parameters, ReturnValue returnValue) {
+			Map<String, String> transformationAttributes, List<Parameter> parameters, ReturnValue returnValue, List<Field> fields) {
 		super(id, className, method, transformationAttributes);
 		classPrefix = initializeClassPrefix();
 		eventName = initializeEventName();
 		eventClassName = initializeEventClassName();
 		eventPath = initializeEventPath();
@@ -74,10 +76,11 @@
 		recordStackTrace = getBoolean(ATTRIBUTE_STACK_TRACE, true);
 		useRethrow = getBoolean(ATTRIBUTE_RETHROW, false);
 		allowToString = getBoolean(ATTRIBUTE_ALLOW_TO_STRING, false);
 		allowConverter = getBoolean(ATTRIBUTE_ALLOW_CONVERTER, false);
 		this.parameters = parameters;
+		this.fields = fields;
 		this.returnValue = returnValue;
 	}
 
 	public String getEventClassName() {
 		return eventClassName;
@@ -176,10 +179,14 @@
 
 	public List<Parameter> getParameters() {
 		return parameters;
 	}
 
+	public List<Field> getFields() {
+		return fields;
+	}
+
 	public ReturnValue getReturnValue() {
 		return returnValue;
 	}
 
 	public boolean isAllowedFieldType(Type type) {
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRClassVisitor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRClassVisitor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRClassVisitor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRClassVisitor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,31 +39,43 @@
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.openjdk.jmc.agent.Agent;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
+import org.openjdk.jmc.agent.util.InspectionClassLoader;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class JFRClassVisitor extends ClassVisitor implements Opcodes {
 	private final JFRTransformDescriptor transformDescriptor;
 	private final ClassLoader definingClassLoader;
+	private final Class<?> inspectionClass;
 	private final ProtectionDomain protectionDomain;
 
 	public JFRClassVisitor(ClassWriter cv, JFRTransformDescriptor descriptor, ClassLoader definingLoader,
-			ProtectionDomain protectionDomain) {
+			Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+			InspectionClassLoader inspectionClassLoader) {
 		super(Opcodes.ASM5, cv);
 		this.transformDescriptor = descriptor;
 		this.definingClassLoader = definingLoader;
 		this.protectionDomain = protectionDomain;
+
+		try {
+			this.inspectionClass =
+					classBeingRedefined != null || descriptor.getFields().isEmpty() ? classBeingRedefined :
+							inspectionClassLoader
+									.loadClass(TypeUtils.getCanonicalName(transformDescriptor.getClassName()));
+		} catch (ClassNotFoundException e) {
+			throw new IllegalStateException(e); // This should not happen
+		}
 	}
 
 	@Override
 	public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
 		MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
 		if (name.equals(transformDescriptor.getMethod().getName())
 				&& desc.equals(transformDescriptor.getMethod().getSignature())) {
-			return new JFRMethodAdvisor(transformDescriptor, Opcodes.ASM5, mv, access, name, desc);
+			return new JFRMethodAdvisor(transformDescriptor, inspectionClass, Opcodes.ASM5, mv, access, name, desc);
 		}
 		return mv;
 	}
 
 	@Override
@@ -77,11 +89,11 @@
 		}
 		super.visitEnd();
 	}
 
 	private Class<?> generateEventClass() throws Exception {
-		byte[] eventClass = JFREventClassGenerator.generateEventClass(transformDescriptor);
+		byte[] eventClass = JFREventClassGenerator.generateEventClass(transformDescriptor, inspectionClass);
 		return TypeUtils.defineClass(transformDescriptor.getEventClassName(), eventClass, 0, eventClass.length,
 				definingClassLoader, protectionDomain);
 	}
 
 }
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,14 +39,17 @@
 import org.objectweb.asm.FieldVisitor;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
+import org.openjdk.jmc.agent.Attribute;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
+import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;
 
 public class JFREventClassGenerator {
 	private static final String CLASS_NAME_INSTANT_EVENT = "com/oracle/jrockit/jfr/InstantEvent"; //$NON-NLS-1$
 	private static final String CLASS_NAME_DURATION_EVENT = "com/oracle/jrockit/jfr/DurationEvent"; //$NON-NLS-1$
 	private static final String CLASS_NAME_TIMED_EVENT = "com/oracle/jrockit/jfr/TimedEvent"; //$NON-NLS-1$
@@ -58,62 +61,66 @@
 	 *            the transform descriptor describing the transform.
 	 * @return returns the byte code for the generated class.
 	 * @throws Exception
 	 *             if the event class could not be generated.
 	 */
-	public static byte[] generateEventClass(JFRTransformDescriptor td) throws Exception {
+	public static byte[] generateEventClass(JFRTransformDescriptor td, Class<?> classBeingRedefined) throws Exception {
 		ClassWriter cw = new ClassWriter(0);
 		// TODO: Add support for different locations
 		cw.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, td.getEventClassName(), null,
 				getEventTypeName(JFREventType.TIMED), null);
 
 		cw.visitSource(TypeUtils.getNamePart(td.getEventClassName()) + TypeUtils.JAVA_FILE_EXTENSION, null);
 
 		String parameterizedClassName = TypeUtils.parameterize(td.getEventClassName());
 		generateClassAnnotations(cw, td);
 		generateTokenField(cw);
-		generateAttributeFields(cw, td);
+		generateAttributeFields(cw, td, classBeingRedefined);
 		generateClinit(cw, td.getEventClassName(), parameterizedClassName);
 		generateInit(cw, td.getEventClassName(), parameterizedClassName);
 		cw.visitEnd();
 
 		return cw.toByteArray();
 	}
 
-	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td) {
+	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td, Class<?> classBeingRedefined) throws IllegalSyntaxException {
 		Type[] args = Type.getArgumentTypes(td.getMethod().getSignature());
 		for (Parameter param : td.getParameters()) {
 			createField(cw, td, param, args[param.getIndex()]);
 		}
 		if (td.getReturnValue() != null) {
 			createField(cw, td, Type.getReturnType(td.getMethod().getSignature()));
 		}
+
+		for (Field field : td.getFields()) {
+			createField(cw, td, field, field.resolveReferenceChain(classBeingRedefined).getType());
+		}
 	}
 
-	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Parameter param, Type type) {
+	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Attribute attribute, Type type) {
 		if (!td.isAllowedFieldType(type)) {
 			Logger.getLogger(JFREventClassGenerator.class.getName())
-					.warning("Skipped generating field in event class for parameter " + param + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
+					.warning("Skipped generating field in event class for parameter " + attribute + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
 							+ " because of configuration settings!"); //$NON-NLS-1$
 			return;
 		}
 
 		String fieldType = getFieldType(type);
 
-		FieldVisitor fv = cw.visitField(Opcodes.ACC_PUBLIC, param.getFieldName(), fieldType, null, null);
+		FieldVisitor fv = cw.visitField(Opcodes.ACC_PUBLIC, attribute.getFieldName(), fieldType, null, null);
 		AnnotationVisitor av = fv.visitAnnotation("Lcom/oracle/jrockit/jfr/ValueDefinition;", true); //$NON-NLS-1$
-		if (param.getName() != null) {
-			av.visit("name", param.getName()); //$NON-NLS-1$
+		if (attribute.getName() != null) {
+			av.visit("name", attribute.getName()); //$NON-NLS-1$
 		}
-		if (param.getDescription() != null) {
-			av.visit("description", param.getDescription()); //$NON-NLS-1$
+		if (attribute.getDescription() != null) {
+			av.visit("description", attribute.getDescription()); //$NON-NLS-1$
 		}
-		if (param.getContentType() != null) {
-			av.visitEnum("contentType", "Lcom/oracle/jrockit/jfr/ContentType;", param.getContentType()); //$NON-NLS-1$ //$NON-NLS-2$
+		if (attribute.getContentType() != null) {
+			av.visitEnum("contentType", "Lcom/oracle/jrockit/jfr/ContentType;", attribute.getContentType()); //$NON-NLS-1$ //$NON-NLS-2$
 		}
-		if (param.getRelationKey() != null) {
-			av.visit("relationKey", param.getRelationKey()); //$NON-NLS-1$
+		if (attribute.getRelationKey() != null) {
+			av.visit("relationKey", attribute.getRelationKey()); //$NON-NLS-1$
 		}
 		av.visitEnd();
 		fv.visitEnd();
 	}
 
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -35,36 +35,47 @@
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.commons.AdviceAdapter;
+import org.openjdk.jmc.agent.Attribute;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
+import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;
+import org.openjdk.jmc.agent.util.expression.ReferenceChain;
+import org.openjdk.jmc.agent.util.expression.ReferenceChainElement;
+
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * Code emitter for JFR distributed with pre-JDK 9 releases. Probably works with JRockit too. ;)
  */
 public class JFRMethodAdvisor extends AdviceAdapter {
 	private static final String THROWABLE_BINARY_NAME = "java/lang/Throwable"; //$NON-NLS-1$
 
 	private final JFRTransformDescriptor transformDescriptor;
+	private final Class<?> inspectionClass;
 	private final Type[] argumentTypesRef;
 	private final Type returnTypeRef;
 	private final Type eventType;
 	private int eventLocal = -1;
 
 	private Label tryBegin = new Label();
 	private Label tryEnd = new Label();
 
 	private boolean shouldInstrumentThrow;
 
-	protected JFRMethodAdvisor(JFRTransformDescriptor transformDescriptor, int api, MethodVisitor mv, int access,
-			String name, String desc) {
+	protected JFRMethodAdvisor(JFRTransformDescriptor transformDescriptor, Class<?> inspectionClass, int api, 
+			MethodVisitor mv, int access, String name, String desc) {
 		super(api, mv, access, name, desc);
 		this.transformDescriptor = transformDescriptor;
+		this.inspectionClass = inspectionClass;
 		// These are not accessible from the super type (made private), so must save an extra reference. :/
 		this.argumentTypesRef = Type.getArgumentTypes(desc);
 		this.returnTypeRef = Type.getReturnType(desc);
 		this.eventType = Type.getObjectType(transformDescriptor.getEventClassName());
 
@@ -96,46 +107,126 @@
 		super.visitEnd();
     }
 
 	@Override
 	protected void onMethodEnter() {
-		createEvent();
+		try {
+			createEvent();
+		} catch (IllegalSyntaxException e) {
+			throw new RuntimeException(e);
+		}
 	}
 
-	private void createEvent() {
+	private void createEvent() throws IllegalSyntaxException {
 		mv.visitTypeInsn(NEW, transformDescriptor.getEventClassName());
 		mv.visitInsn(DUP);
 		mv.visitInsn(DUP);
 		mv.visitMethodInsn(INVOKESPECIAL, transformDescriptor.getEventClassName(), "<init>", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		for (Parameter param : transformDescriptor.getParameters()) {
 			Type argumentType = argumentTypesRef[param.getIndex()];
 			if (transformDescriptor.isAllowedFieldType(argumentType)) {
 				mv.visitInsn(DUP);
 				loadArg(param.getIndex());
-				writeParameter(param, argumentType);
+				writeAttribute(param, argumentType);
+			}
+		}
+
+		for (Field field : transformDescriptor.getFields()) {
+			ReferenceChain refChain = field.resolveReferenceChain(inspectionClass).normalize();
+
+			if (!refChain.isStatic() && Modifier.isStatic(getAccess())) {
+				throw new IllegalSyntaxException("Illegal non-static reference from a static context: " + field.getExpression());
+			}
+
+			if (transformDescriptor.isAllowedFieldType(refChain.getType())) {
+				mv.visitInsn(DUP);
+				loadField(refChain);
+				writeAttribute(field, refChain.getType());
 			}
 		}
 
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "begin", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		eventLocal = newLocal(eventType);
 		mv.visitVarInsn(ASTORE, eventLocal);
 	}
 
-	private void writeParameter(Parameter param, Type type) {
-		if (TypeUtils.shouldStringify(type)) {
-			TypeUtils.stringify(mv);
-			type = TypeUtils.STRING_TYPE;
+	private void loadField(ReferenceChain refChain) {
+		Type type = refChain.getType();
+		boolean isStatic = Modifier.isStatic(getAccess());
+		Label nullCase = new Label();
+		Label continueCase = new Label();
+		List<Object> localVarVerifications = new ArrayList<>();
+		if (!isStatic) {
+			localVarVerifications.add(Type.getInternalName(inspectionClass)); // "this"
 		}
-		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
+		for (Type argType : argumentTypesRef) {
+			localVarVerifications.add(TypeUtils.getFrameVerificationType(argType));
+		}
+
+		// Assumes the reference chain is normalized already. See ReferenceChain.normalize()
+		List<ReferenceChainElement> refs = refChain.getReferences();
+		for (int i = 0; i < refs.size(); i++) {
+			ReferenceChainElement ref = refs.get(i);
+
+			if (ref instanceof ReferenceChainElement.ThisReference) {
+				mv.visitVarInsn(ALOAD, 0); // load "this"
+				continue;
+			}
+
+			if (ref instanceof ReferenceChainElement.FieldReference) {
+				mv.visitFieldInsn(ref.isStatic() ? GETSTATIC : GETFIELD, ref.getMemberingType().getInternalName(),
+						((ReferenceChainElement.FieldReference) ref).getName(),
+						ref.getReferencedType().getDescriptor());
+
+				// null check for field references
+				if (i < refs.size() - 1) { // Skip null check for final reference. Null is acceptable here
+					mv.visitInsn(DUP);
+					mv.visitJumpInsn(IFNULL, nullCase);
+				}
+
+				continue;
+			}
+
+			if (ref instanceof ReferenceChainElement.QualifiedThisReference) {
+				int suffix = ((ReferenceChainElement.QualifiedThisReference) ref).getDepth();
+				Class<?> c = ref.getMemberingClass();
+				while (!ref.getReferencedClass().equals(c)) {
+					mv.visitFieldInsn(GETFIELD, Type.getType(c).getInternalName(), "this$" + (suffix--),
+							Type.getType(c.getEnclosingClass()).getDescriptor());
+					c = c.getEnclosingClass();
+				}
+
+				continue;
+			}
+
+			throw new UnsupportedOperationException("Unsupported reference chain element type");
+		}
+
+		// loaded a value, jump to writing attribute
+		mv.visitJumpInsn(GOTO, continueCase);
+
+		// null reference on path, load zero value
+		mv.visitLabel(nullCase);
+		mv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,
+				new Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),
+						Type.getInternalName(Object.class)});
+		mv.visitInsn(POP);
+		mv.visitInsn(TypeUtils.getConstZeroOpcode(type));
+
+		// must verify frame for jump targets
+		mv.visitLabel(continueCase);
+		mv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,
+				new Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),
+						TypeUtils.getFrameVerificationType(type)});
 	}
 
-	private void writeReturnValue(ReturnValue returnValue, Type type) {
+	private void writeAttribute(Attribute param, Type type) {
 		if (TypeUtils.shouldStringify(type)) {
 			TypeUtils.stringify(mv);
 			type = TypeUtils.STRING_TYPE;
 		}
-		putField(Type.getObjectType(transformDescriptor.getEventClassName()), returnValue.getFieldName(), type);
+		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
 	}
 
 	@Override
 	protected void onMethodExit(int opcode) {
 		if (opcode == ATHROW && !shouldInstrumentThrow) {
@@ -160,11 +251,11 @@
 			dup2();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			dupX2();
 			pop();
 		}
-		writeReturnValue(returnValue, returnTypeRef);
+		writeAttribute(returnValue, returnTypeRef);
 	}
 
 	private void commitEvent() {
 		mv.visitVarInsn(ALOAD, eventLocal);
 		mv.visitInsn(DUP);
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextClassVisitor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextClassVisitor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextClassVisitor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextClassVisitor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -40,31 +40,43 @@
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
+import org.openjdk.jmc.agent.util.InspectionClassLoader;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class JFRNextClassVisitor extends ClassVisitor {
 	private final JFRTransformDescriptor transformDescriptor;
 	private final ClassLoader definingClassLoader;
+	private final Class<?> inspectionClass;
 	private final ProtectionDomain protectionDomain;
 
 	public JFRNextClassVisitor(ClassWriter cv, JFRTransformDescriptor descriptor, ClassLoader definingLoader,
-			ProtectionDomain protectionDomain) {
+			Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
+			InspectionClassLoader inspectionClassLoader) {
 		super(Opcodes.ASM5, cv);
 		this.transformDescriptor = descriptor;
 		this.definingClassLoader = definingLoader;
 		this.protectionDomain = protectionDomain;
+
+		try {
+			this.inspectionClass =
+					classBeingRedefined != null || descriptor.getFields().isEmpty() ? classBeingRedefined :
+							inspectionClassLoader
+									.loadClass(TypeUtils.getCanonicalName(transformDescriptor.getClassName()));
+		} catch (ClassNotFoundException e) {
+			throw new IllegalStateException(e); // This should not happen
+		}
 	}
 
 	@Override
 	public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
 		MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
 		if (name.equals(transformDescriptor.getMethod().getName())
 				&& desc.equals(transformDescriptor.getMethod().getSignature())) {
-			return new JFRNextMethodAdvisor(transformDescriptor, Opcodes.ASM5, mv, access, name, desc);
+			return new JFRNextMethodAdvisor(transformDescriptor, inspectionClass, Opcodes.ASM5, mv, access, name, desc);
 		}
 		return mv;
 	}
 
 	@Override
@@ -85,13 +97,13 @@
 		registerMethod.invoke(null, generateEventClass);
 	}
 
 	private Class<?> generateEventClass() throws Exception {
 		try {
-			return Class.forName(transformDescriptor.getEventClassName().replace('/', '.'));
+			return Class.forName(TypeUtils.getCanonicalName(transformDescriptor.getEventClassName()));
 		} catch (ClassNotFoundException e) {
-			byte[] eventClass = JFRNextEventClassGenerator.generateEventClass(transformDescriptor);
+			byte[] eventClass = JFRNextEventClassGenerator.generateEventClass(transformDescriptor, inspectionClass);
 			return TypeUtils.defineClass(transformDescriptor.getEventClassName(), eventClass, 0, eventClass.length,
 					definingClassLoader, protectionDomain);
 		}
 	}
 }
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -40,69 +40,76 @@
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.openjdk.jmc.agent.Agent;
+import org.openjdk.jmc.agent.Attribute;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
+import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;
 
 public class JFRNextEventClassGenerator {
 	private static final String CLASS_EVENT = "jdk/jfr/Event"; //$NON-NLS-1$
 
-	public static byte[] generateEventClass(JFRTransformDescriptor td) throws Exception {
+	public static byte[] generateEventClass(JFRTransformDescriptor td, Class<?> classBeingRedefined) throws Exception {
 		ClassWriter cw = new ClassWriter(0);
 		// FIXME: Perhaps switch to Opcodes V9 when there is one.
 		cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, td.getEventClassName(), null, CLASS_EVENT, null);
 
 		cw.visitSource(TypeUtils.getNamePart(td.getEventClassName()) + TypeUtils.JAVA_FILE_EXTENSION, null);
 
 		String parameterizedClassName = TypeUtils.parameterize(td.getEventClassName());
 		generateClassAnnotations(cw, td);
-		generateAttributeFields(cw, td);
+		generateAttributeFields(cw, td, classBeingRedefined);
 		generateInit(cw, td.getEventClassName(), parameterizedClassName);
 		cw.visitEnd();
 		return cw.toByteArray();
 	}
 
-	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td) {
+	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td, Class<?> classBeingRedefined) throws IllegalSyntaxException {
 		Type[] args = Type.getArgumentTypes(td.getMethod().getSignature());
 		for (Parameter param : td.getParameters()) {
 			createField(cw, td, param, args[param.getIndex()]);
 		}
 		if (td.getReturnValue() != null) {
 			createField(cw, td, Type.getReturnType(td.getMethod().getSignature()));
 		}
+
+		for (Field field : td.getFields()) {
+			createField(cw, td, field, field.resolveReferenceChain(classBeingRedefined).getType());
+		}
 	}
 
-	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Parameter param, Type type) {
+	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Attribute attribute, Type type) {
 		if (!td.isAllowedFieldType(type)) {
 			Logger.getLogger(JFRNextEventClassGenerator.class.getName())
-					.warning("Skipped generating field in event class for parameter " + param + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
+					.warning("Skipped generating field in event class for attribute " + attribute + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
 							+ " because of configuration settings!"); //$NON-NLS-1$
 			return;
 		}
 
 		String fieldType = getFieldType(type);
 
-		FieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, param.getFieldName(), fieldType, null, null);
+		FieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, attribute.getFieldName(), fieldType, null, null);
 
 		// Name
 		AnnotationVisitor av = fv.visitAnnotation("Ljdk/jfr/Label;", true);
-		av.visit("value", param.getName());
+		av.visit("value", attribute.getName());
 		av.visitEnd();
 
 		// Description
 		av = fv.visitAnnotation("Ljdk/jfr/Description;", true);
-		av.visit("value", param.getDescription());
+		av.visit("value", attribute.getDescription());
 		av.visitEnd();
 
 		// "ContentType"
 		// We support the old JDK 7 style content types transparently.
 		// We also support user defined content types and a single string value annotation parameter to the annotation.
-		String contentTypeAnnotation = getContentTypeAnnotation(param.getContentType());
+		String contentTypeAnnotation = getContentTypeAnnotation(attribute.getContentType());
 		if (contentTypeAnnotation != null) {
 			String[] contentTypeAnnotationInfo = contentTypeAnnotation.split(";");
 			av = fv.visitAnnotation(contentTypeAnnotationInfo[0] + ";", true);
 			if (contentTypeAnnotationInfo.length > 1) {
 				av.visit("value", contentTypeAnnotationInfo[1]);
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -35,36 +35,47 @@
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.commons.AdviceAdapter;
+import org.openjdk.jmc.agent.Field;
+import org.openjdk.jmc.agent.Attribute;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
+import org.openjdk.jmc.agent.util.expression.ReferenceChainElement;
+import org.openjdk.jmc.agent.util.expression.IllegalSyntaxException;
+import org.openjdk.jmc.agent.util.expression.ReferenceChain;
+
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * Code emitter for JFR next, i.e. the version of JFR distributed with JDK 9 and later.
  */
 public class JFRNextMethodAdvisor extends AdviceAdapter {
 	private static final String THROWABLE_BINARY_NAME = "java/lang/Throwable"; //$NON-NLS-1$
 
 	private final JFRTransformDescriptor transformDescriptor;
+	private final Class<?> inspectionClass;
 	private final Type[] argumentTypesRef;
 	private final Type returnTypeRef;
 	private final Type eventType;
 	private int eventLocal = -1;
 
 	private Label tryBegin = new Label();
 	private Label tryEnd = new Label();
 
 	private boolean shouldInstrumentThrow;
 
-	protected JFRNextMethodAdvisor(JFRTransformDescriptor transformDescriptor, int api, MethodVisitor mv, int access,
-			String name, String desc) {
+	protected JFRNextMethodAdvisor(JFRTransformDescriptor transformDescriptor, Class<?> inspectionClass, int api, 
+			MethodVisitor mv, int access, String name, String desc) {
 		super(api, mv, access, name, desc);
 		this.transformDescriptor = transformDescriptor;
+		this.inspectionClass = inspectionClass;
 		// These are not accessible from the super type (made private), so must save an extra reference. :/
 		this.argumentTypesRef = Type.getArgumentTypes(desc);
 		this.returnTypeRef = Type.getReturnType(desc);
 		this.eventType = Type.getObjectType(transformDescriptor.getEventClassName());
 
@@ -96,46 +107,126 @@
 		super.visitEnd();
 	}
 
 	@Override
 	protected void onMethodEnter() {
-		createEvent();
+		try {
+			createEvent();
+		} catch (IllegalSyntaxException e) {
+			throw new RuntimeException(e);
+		}
 	}
 
-	private void createEvent() {
+	private void createEvent() throws IllegalSyntaxException {
 		mv.visitTypeInsn(NEW, transformDescriptor.getEventClassName());
 		mv.visitInsn(DUP);
 		mv.visitInsn(DUP);
 		mv.visitMethodInsn(INVOKESPECIAL, transformDescriptor.getEventClassName(), "<init>", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		for (Parameter param : transformDescriptor.getParameters()) {
 			Type argumentType = argumentTypesRef[param.getIndex()];
 			if (transformDescriptor.isAllowedFieldType(argumentType)) {
 				mv.visitInsn(DUP);
 				loadArg(param.getIndex());
-				writeParameter(param, argumentType);
+				writeAttribute(param, argumentType);
+			}
+		}
+
+		for (Field field : transformDescriptor.getFields()) {
+			ReferenceChain refChain = field.resolveReferenceChain(inspectionClass).normalize();
+
+			if (!refChain.isStatic() && Modifier.isStatic(getAccess())) {
+				throw new IllegalSyntaxException("Illegal non-static reference from a static context: " + field.getExpression());
+			}
+
+			if (transformDescriptor.isAllowedFieldType(refChain.getType())) {
+				mv.visitInsn(DUP);
+				loadField(refChain);
+				writeAttribute(field, refChain.getType());
 			}
 		}
 
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "begin", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		eventLocal = newLocal(eventType);
 		mv.visitVarInsn(ASTORE, eventLocal);
 	}
 
-	private void writeParameter(Parameter param, Type type) {
-		if (TypeUtils.shouldStringify(type)) {
-			TypeUtils.stringify(mv);
-			type = TypeUtils.STRING_TYPE;
+	private void loadField(ReferenceChain refChain) {
+		Type type = refChain.getType();
+		boolean isStatic = Modifier.isStatic(getAccess());
+		Label nullCase = new Label();
+		Label continueCase = new Label();
+		List<Object> localVarVerifications = new ArrayList<>();
+		if (!isStatic) {
+			localVarVerifications.add(Type.getInternalName(inspectionClass)); // "this"
 		}
-		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
-	}
+		for (Type argType : argumentTypesRef) {
+			localVarVerifications.add(TypeUtils.getFrameVerificationType(argType));
+		}
+
+		// Assumes the reference chain is normalized already. See ReferenceChain.normalize()
+		List<ReferenceChainElement> refs = refChain.getReferences();
+		for (int i = 0; i < refs.size(); i++) {
+			ReferenceChainElement ref = refs.get(i);
 
-	private void writeReturnValue(ReturnValue returnValue, Type type) {
+			if (ref instanceof ReferenceChainElement.ThisReference) {
+				mv.visitVarInsn(ALOAD, 0); // load "this"
+				continue;
+			}
+
+			if (ref instanceof ReferenceChainElement.FieldReference) {
+				mv.visitFieldInsn(ref.isStatic() ? GETSTATIC : GETFIELD, ref.getMemberingType().getInternalName(),
+						((ReferenceChainElement.FieldReference) ref).getName(),
+						ref.getReferencedType().getDescriptor());
+
+				// null check for field references
+				if (i < refs.size() - 1) { // Skip null check for final reference. Null is acceptable here
+					mv.visitInsn(DUP);
+					mv.visitJumpInsn(IFNULL, nullCase);
+				}
+
+				continue;
+			}
+
+			if (ref instanceof ReferenceChainElement.QualifiedThisReference) {
+				int suffix = ((ReferenceChainElement.QualifiedThisReference) ref).getDepth();
+				Class<?> c = ref.getMemberingClass();
+				while (!ref.getReferencedClass().equals(c)) {
+					mv.visitFieldInsn(GETFIELD, Type.getType(c).getInternalName(), "this$" + (suffix--),
+							Type.getType(c.getEnclosingClass()).getDescriptor());
+					c = c.getEnclosingClass();
+				}
+
+				continue;
+			}
+
+			throw new UnsupportedOperationException("Unsupported reference chain element type");
+		}
+
+		// loaded a value, jump to writing attribute
+		mv.visitJumpInsn(GOTO, continueCase);
+
+		// null reference on path, load zero value
+		mv.visitLabel(nullCase);
+		mv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,
+				new Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),
+						Type.getInternalName(Object.class)});
+		mv.visitInsn(POP);
+		mv.visitInsn(TypeUtils.getConstZeroOpcode(type));
+
+		// must verify frame for jump targets
+		mv.visitLabel(continueCase);
+		mv.visitFrame(F_NEW, localVarVerifications.size(), localVarVerifications.toArray(), 4,
+				new Object[] {eventType.getInternalName(), eventType.getInternalName(), eventType.getInternalName(),
+						TypeUtils.getFrameVerificationType(type)});
+	}
+	
+	private void writeAttribute(Attribute param, Type type) {
 		if (TypeUtils.shouldStringify(type)) {
 			TypeUtils.stringify(mv);
 			type = TypeUtils.STRING_TYPE;
 		}
-		putField(Type.getObjectType(transformDescriptor.getEventClassName()), returnValue.getFieldName(), type);
+		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
 	}
 
 	@Override
 	protected void onMethodExit(int opcode) {
 		if (opcode == ATHROW && !shouldInstrumentThrow) {
@@ -160,11 +251,11 @@
 			dup2();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			dupX2();
 			pop();
 		}
-		writeReturnValue(returnValue, returnTypeRef);
+		writeAttribute(returnValue, returnTypeRef);
 	}
 
 	private void commitEvent() {
 		mv.visitVarInsn(ALOAD, eventLocal);
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "commit", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java
@@ -0,0 +1,342 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * Helper methods for checking accessibility, implied as modifiers, from various contexts.
+ */
+public final class AccessUtils {
+	private AccessUtils() {
+		throw new UnsupportedOperationException("Toolkit!"); //$NON-NLS-1$
+	}
+
+	/**
+	 * Like Class.getDeclaredField, but also gets fields declared by ancestors and interfaces.
+	 * 
+	 * @param clazz the class to lookup from
+	 * @param name the name of the field
+	 * @return the {@code Field} object for the specified field in this class
+	 * @throws NoSuchFieldException if a field with the specified name is not found.
+	 */
+	public static Field getFieldOnHierarchy(Class<?> clazz, String name) throws NoSuchFieldException {
+		Queue<Class<?>> q = new LinkedList<>();
+		q.add(clazz);
+
+		while (!q.isEmpty()) {
+			Class<?> targetClass = q.remove();
+			try {
+				return targetClass.getDeclaredField(name);
+			} catch (NoSuchFieldException e) {
+				// ignore
+			}
+
+			q.addAll(Arrays.asList(targetClass.getInterfaces()));
+			Class<?> superClass = targetClass.getSuperclass();
+			if (superClass != null) {
+				q.add(targetClass.getSuperclass());
+			}
+		}
+
+		throw new NoSuchFieldException(String.format("cannot find field %s in class %s", name, clazz.getName()));
+	}
+
+	/**
+	 * Checks whether a field can be accessed from a caller context.
+	 * 
+	 * @param targetClass the class being referenced
+	 * @param field the field being accessed
+	 * @param currentClass the caller class
+	 * @return whether the field is accessible from given context
+	 */
+	public static boolean isAccessible(Class<?> targetClass, Field field, Class<?> currentClass) {
+		int modifiers = field.getModifiers();
+
+		Class<?> memberClass = field.getDeclaringClass();
+		if (Modifier.isStatic(modifiers)) {
+			targetClass = null;
+		}
+
+		return verifyMemberAccess(targetClass, memberClass, currentClass, modifiers);
+	}
+
+	/**
+	 * Checks whether the field/method/inner class modifier allows access from a caller context
+	 * 
+	 * @param targetClass the class being referenced
+	 * @param memberClass the class declaring the field/method/inner class
+	 * @param currentClass the caller class
+	 * @param modifiers member access modifiers in bit flags as a integer
+	 * @return
+	 */
+	public static boolean verifyMemberAccess(Class<?> targetClass, Class<?> memberClass, Class<?> currentClass, 
+			int modifiers) {
+		if (currentClass == memberClass) {
+			return true;
+		}
+
+		if (!verifyModuleAccess(memberClass, currentClass)) {
+			return false;
+		}
+
+		boolean gotIsSameClassPackage = false;
+		boolean isSameClassPackage = false;
+
+		if (!Modifier.isPublic(getClassAccessFlags(memberClass))) {
+			isSameClassPackage = isSameClassPackage(currentClass, memberClass);
+			gotIsSameClassPackage = true;
+			if (!isSameClassPackage) {
+				return false;
+			}
+		}
+
+		// At this point we know that currentClass can access memberClass.
+
+		if (Modifier.isPublic(modifiers)) {
+			return true;
+		}
+
+		// Check for nestmate access if member is private
+		if (Modifier.isPrivate(modifiers)) {
+			// Note: targetClass may be outside the nest, but that is okay
+			//       as long as memberClass is in the nest.
+			if (areNestMates(currentClass, memberClass)) {
+				return true;
+			}
+		}
+
+		boolean successSoFar = false;
+
+		if (Modifier.isProtected(modifiers)) {
+			// See if currentClass is a subclass of memberClass
+			if (isSubclassOf(currentClass, memberClass)) {
+				successSoFar = true;
+			}
+		}
+
+		if (!successSoFar && !Modifier.isPrivate(modifiers)) {
+			if (!gotIsSameClassPackage) {
+				isSameClassPackage = isSameClassPackage(currentClass, memberClass);
+				gotIsSameClassPackage = true;
+			}
+
+			if (isSameClassPackage) {
+				successSoFar = true;
+			}
+		}
+
+		if (!successSoFar) {
+			return false;
+		}
+
+		// Additional test for protected instance members
+		// and protected constructors: JLS 6.6.2
+		if (targetClass != null && Modifier.isProtected(modifiers) && targetClass != currentClass) {
+			if (!gotIsSameClassPackage) {
+				isSameClassPackage = isSameClassPackage(currentClass, memberClass);
+			}
+			if (!isSameClassPackage) {
+				return isSubclassOf(targetClass, currentClass);
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Check whether the module has the class exported for the caller to access.
+	 * 
+	 * For Pre-9 Java runtime, this function always returns <code>true</code>.
+	 * 
+	 * @param targetClass the class being accessed
+	 * @param callerClass the caller class
+	 * @return whether the class is accessible
+	 */
+	public static boolean verifyModuleAccess(Class<?> targetClass, Class<?> callerClass) {
+		String version = System.getProperty("java.version");
+		if (Integer.parseInt(version.substring(0, version.indexOf("."))) < 9) {
+			return true; // There is no module for pre-java 9
+		}
+
+		Object targetModule;
+		Object callerModule;
+		try {
+			Method getModuleMethod = Class.class.getDeclaredMethod("getModule");
+			targetModule = getModuleMethod.invoke(targetClass);
+			callerModule = getModuleMethod.invoke(callerClass);
+		} catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+			throw new RuntimeException(e); // this should not happen
+		}
+
+		if (targetModule == callerModule) {
+			return true;
+		}
+
+		String pkg = getPackageName(targetClass);
+		try {
+			Method isExportedMethod = targetModule.getClass()
+					.getDeclaredMethod("isExported", String.class, Class.forName("java.lang.Module"));
+			return (boolean) isExportedMethod.invoke(targetModule, pkg, callerModule);
+		} catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+			throw new RuntimeException(e); // this should not happen
+		}
+	}
+
+	/**
+	 * polyfill for <code>Class.getPackageName(Class<?>)</code> for pre-9 Java.
+	 * 
+	 * @param clazz the class to lookup the package name against
+	 * @return the name of the package containing the class
+	 */
+	public static String getPackageName(Class<?> clazz) {
+		return clazz.getPackage().getName();
+		
+	}
+
+	/**
+	 * Polyfill for <code>Reflection.getClassAccessFlags(Class<?>)</code> as 
+	 * <code>jdk.internal.reflect.Reflection</code> is not exported.
+	 * 
+	 * @param c the class being inspected
+	 * @return the access flags written to the class file
+	 */
+	public static int getClassAccessFlags(Class<?> c) {
+		return c.getModifiers();
+	}
+
+	/**
+	 * Check whether the two classes exist in the same package
+	 * 
+	 * @param lhs the first class
+	 * @param rhs the second class
+	 * @return whether the given classes exist in the same package
+	 */
+	public static boolean isSameClassPackage(Class<?> lhs, Class<?> rhs) {
+		if (lhs.getClassLoader() != rhs.getClassLoader())
+			return false;
+		return getPackageName(lhs).equals(getPackageName(rhs));
+	}
+
+	/**
+	 * Check whether a class is a subclass of the other
+	 * 
+	 * @param queryClass the subclass
+	 * @param ofClass the superclass
+	 * @return whether it's a subclass-superclass relationship
+	 */
+	public static boolean isSubclassOf(Class<?> queryClass, Class<?> ofClass) {
+		while (queryClass != null) {
+			if (queryClass == ofClass) {
+				return true;
+			}
+			queryClass = queryClass.getSuperclass();
+		}
+		return false;
+	}
+
+	/**
+	 * Polyfill Class.getNestMembers() for pre-11 runtime. 
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for 
+	 * validating access.
+	 * 
+	 * @param clazz the class to inspect against
+	 * @return an array of all nest members
+	 */
+	public static Class<?>[] getNestMembers(Class<?> clazz) {
+		List<Class<?>> classes = new ArrayList<>();
+		classes.add(getNestHost(clazz));
+		int i = 0;
+		while (i < classes.size()) {
+			classes.addAll(Arrays.asList(classes.get(i).getDeclaredClasses()));
+			i++;
+		}
+
+		return classes.toArray(new Class[0]);
+	}
+
+	/**
+	 * Polyfill Class.isNestMateOf() for pre-11 runtime.
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for
+	 * validating access.
+	 * 
+	 * @param lhs the first class
+	 * @param rhs the second class
+	 * @return whether the given classes are nestmates
+	 */
+	public static boolean areNestMates(Class<?> lhs, Class<?> rhs) {
+		return getNestHost(lhs).equals(getNestHost(rhs));
+	}
+
+	/**
+	 * Polyfill Class.getNestHost() for pre-11 runtime.
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for
+	 * validating access.
+	 * 
+	 * @param clazz the class the inspect against
+	 * @return the nesthost of the class
+	 */
+	public static Class<?> getNestHost(Class<?> clazz) {
+		// array types, primitive types, and void belong to the nests consisting only of theme, and are the nest hosts.
+		if (clazz.isArray()) {
+			return clazz;
+		}
+
+		if (clazz.isPrimitive()) {
+			return clazz;
+		}
+
+		if (Void.class.equals(clazz)) {
+			return clazz;
+		}
+
+		while (true) {
+			if (clazz.getEnclosingClass() == null) {
+				return clazz;
+			}
+
+			clazz = clazz.getEnclosingClass();
+		}
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * One-time use loader for reflective class inspection. Don't keep static reference to one of these.
+ */
+public class InspectionClassLoader extends ClassLoader {
+
+	public InspectionClassLoader(ClassLoader parent) {
+		super(parent);
+	}
+
+	@Override
+	public Class<?> loadClass(String name) throws ClassNotFoundException {
+		if (name.startsWith("java.")) {
+			return getParent().loadClass(name);
+		}
+
+		try {
+			return loadClass(name, true);
+		} catch (ClassNotFoundException e) {
+			return getParent().loadClass(name);
+		}
+	}
+
+	@Override
+	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+		Class<?> clazz = findLoadedClass(name);
+		if (clazz != null) {
+			return clazz;
+		}
+
+		clazz = findClass(name);
+
+		if (resolve) {
+			resolveClass(clazz);
+		}
+
+		return clazz;
+	}
+
+	@Override
+	protected Class<?> findClass(String name) throws ClassNotFoundException {
+		InputStream is = getParent().getResourceAsStream(TypeUtils.getInternalName(name) + ".class");
+		if (is == null) {
+			throw new ClassNotFoundException(name);
+		}
+
+		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+		int nRead;
+		byte[] data = new byte[1024]; // 1024 is chosen arbitrarily
+		try {
+			while ((nRead = is.read(data, 0, data.length)) != -1) {
+				buffer.write(data, 0, nRead);
+				buffer.flush();
+			}
+		} catch (IOException e) {
+			throw new RuntimeException(e);
+		}
+
+		byte[] bytes = buffer.toByteArray();
+		return defineClass(name, bytes, 0, bytes.length);
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -118,17 +118,18 @@
 		}
 		return String.valueOf(o);
 	}
 
 	public static Class<?> defineClass(
-		String eventClassName, byte[] eventClass, int i, int length, ClassLoader definingClassLoader,
-		ProtectionDomain protectionDomain) {
+			String eventClassName, byte[] eventClass, int i, int length, ClassLoader definingClassLoader,
+			ProtectionDomain protectionDomain) {
 		try {
-			return (Class<?>) UNSAFE_DEFINE_CLASS_METHOD.invoke(UNSAFE, eventClassName, eventClass, i, length,
-					definingClassLoader, protectionDomain);
+			return (Class<?>) UNSAFE_DEFINE_CLASS_METHOD
+					.invoke(UNSAFE, eventClassName, eventClass, i, length, definingClassLoader, protectionDomain);
 		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-			Agent.getLogger().log(Level.SEVERE, "Failed to dynamically define the class " + eventClassName, e); //$NON-NLS-1$
+			Agent.getLogger()
+					.log(Level.SEVERE, "Failed to dynamically define the class " + eventClassName, e); //$NON-NLS-1$
 		}
 		return null;
 	}
 
 	/**
@@ -225,18 +226,105 @@
 	}
 
 	/**
 	 * Transforms a FQN in internal form, so that it can be used in e.g. formal descriptors.
 	 *
-	 * @param className
-	 *            the fully qualified class name in internal form.
+	 * @param className the fully qualified class name in internal form.
 	 * @return the transformed class name.
 	 */
 	public static String parameterize(String className) {
 		return "L" + className + ";"; //$NON-NLS-1$ //$NON-NLS-2$
 	}
 
+	/**
+	 * Converts a canonical class name into the internal form (binary name).
+	 * 
+	 * eg. <code>com.company.project</code> converts into <code>com/company/project</code>
+	 * 
+	 * @param className the canonical class name
+	 * @return the internal form
+	 */
+	public static String getInternalName(String className) {
+		return className.replace('.', '/');
+	}
+
+	/**
+	 * Converts a internal class name (binary name) into the canonical form.
+	 *
+	 * ie. <code>com/company/project</code> converts into <code>com.company.project</code> 
+	 * 
+	 * @param binaryName the internal class name
+	 * @return in canonical form
+	 */
+	public static String getCanonicalName(String binaryName) {
+		return binaryName.replace('/', '.');
+	}
+
+	/**
+	 * Returns the constant loading instruction that pushes a zero value of the given type onto the operand stack. A 
+	 * null reference is pushed if the given type is an object or an array.
+	 * 
+	 * @param type the type of the operand
+	 * @return the instruction
+	 */
+	public static int getConstZeroOpcode(Type type) {
+		switch (type.getSort()) {
+		case Type.BOOLEAN:
+		case Type.BYTE:
+		case Type.CHAR:
+		case Type.SHORT:
+		case Type.INT:
+			return Opcodes.ICONST_0;
+		case Type.FLOAT:
+			return Opcodes.FCONST_0;
+		case Type.LONG:
+			return Opcodes.LCONST_0;
+		case Type.DOUBLE:
+			return Opcodes.DCONST_0;
+		case Type.ARRAY:
+		case Type.OBJECT:
+			return Opcodes.ACONST_NULL;
+		case Type.METHOD:
+		case Type.VOID:
+			throw new UnsupportedOperationException();
+		default:
+			throw new AssertionError();
+		}
+	}
+
+	/**
+	 * Returns a array element for ASM's <code>MethodVisitor.visitFrame()</code> method used for frame verification of 
+	 * a given type.
+	 * 
+	 * @param type the type of the element on the operand stack or in the local variable table
+	 * @return a array element for <code>MethodVisitor.visitFrame()</code>'s parameter
+	 */
+	public static Object getFrameVerificationType(Type type) {
+		switch (type.getSort()) {
+		case Type.BOOLEAN:
+		case Type.BYTE:
+		case Type.CHAR:
+		case Type.SHORT:
+		case Type.INT:
+			return Opcodes.INTEGER;
+		case Type.FLOAT:
+			return Opcodes.FLOAT;
+		case Type.LONG:
+			return Opcodes.LONG;
+		case Type.DOUBLE:
+			return Opcodes.DOUBLE;
+		case Type.ARRAY:
+		case Type.OBJECT:
+			return type.getInternalName();
+		case Type.METHOD:
+		case Type.VOID:
+			throw new UnsupportedOperationException();
+		default:
+			throw new AssertionError();
+		}
+	}
+
 	/**
 	 * Type agnostic array toString() which also handles primitive arrays.
 	 */
 	private static String toString(Object o, int length) {
 		int iMax = length - 1;
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ExpressionResolver.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ExpressionResolver.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ExpressionResolver.java
@@ -0,0 +1,720 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util.expression;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.openjdk.jmc.agent.util.AccessUtils;
+
+/* 
+	Expression // a subset of Java primary expression (without array accesses)
+		-> this
+		 | TypeName . this
+		 | FieldAccess
+
+	TypeName
+		-> TypeIdentifier
+		 | PackageOrTypeName . TypeIdentifier
+
+	PackageOrTypeName
+		-> identifier
+		| PackageOrTypeName . identifier
+
+	TypeIdentifier
+		 -> identifier
+
+	FieldAccess
+		-> Expression . identifier
+		 | super . identifier
+		 | TypeName . super . identifier
+		 | FieldName
+
+	FieldName
+		 -> identifier
+
+	identifier // terminal symbols
+		 -> [A-z_]+[A-z0-9_]*
+	*/
+public class ExpressionResolver {
+	private final Class<?> caller;
+	private final String expression;
+
+	private List<String> tokens = null;
+	private Iterator<String> iterator = null;
+	private ReferenceChain referenceChain = null;
+
+	private ExpressionResolver(Class<?> caller, String expression) {
+		this.caller = caller;
+		this.expression = expression;
+	}
+
+	public static ReferenceChain solve(Class<?> caller, String expression) throws IllegalSyntaxException {
+		ExpressionResolver resolver = new ExpressionResolver(caller, expression);
+		resolver.tokens = new LinkedList<>(Arrays.asList(expression.split("\\.")));
+		resolver.iterator = resolver.tokens.iterator();
+		resolver.referenceChain = new ReferenceChain(caller);
+
+		resolver.enterStartState();
+
+		return resolver.referenceChain;
+	}
+
+	private void enterStartState() throws IllegalSyntaxException {
+		if (!iterator.hasNext()) {
+			enterIllegalState("Unexpected end of input: expects 'this', 'super', a field name, a class name, a package name, or a package name fragment");
+		}
+
+		String token = iterator.next(); // first identifier
+
+		// "this"
+		if (tryEnterThisState(caller, token)) {
+			return;
+		}
+
+		// "super"
+		if (tryEnterSuperState(caller, token)) {
+			return;
+		}
+
+		// local/inherited field reference
+		if (tryEnterFieldReferenceState(caller, token, false)) { // assuming accessing from a non-static context 
+			return;
+		}
+
+		// nested field reference
+		if (tryEntryNestedFieldReferenceState(token)) { // static class? 
+			return;
+		}
+
+		// outer class reference
+		if (tryEnterOuterClassState(token)) {
+			return;
+		}
+
+		// inner class reference
+		if (tryEnterInnerClassState(caller, token)) {
+			return;
+		}
+
+		// CallerClass
+		if (tryEnterSameClassState(token)) {
+			return;
+		}
+
+		// ClassWithInTheSamePackage
+		if (tryEnterClassState(token)) {
+			return;
+		}
+
+		// com.full.qualified.pkg.ClassName
+		if (tryEnterPackageState(expression)) {
+			return;
+		}
+
+		// partially.qualified.pkg.ClassName
+		if (tryEnterPackageState(caller.getPackage(), expression)) {
+			return;
+		}
+
+		// eg. Object => java.lang.Object, Integer => java.lang.Integer
+		if (tryEnterPackageState(Package.getPackage("java.lang"), expression)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterThisState(Class<?> enclosingClass, String thisLiteral) throws IllegalSyntaxException {
+		if (!"this".equals(thisLiteral)) {
+			return false;
+		}
+
+		enterThisState(enclosingClass);
+		return true;
+	}
+
+	// "^this" or "Qualified.this" expression (casting to an enclosing class)
+	private void enterThisState(Class<?> enclosingClass) throws IllegalSyntaxException {
+		// cast to outer class instance only when accessing non-static fields
+		referenceChain.append(new ReferenceChainElement.ThisReference(caller));
+		if (!caller.equals(enclosingClass)) {
+			try {
+				referenceChain.append(new ReferenceChainElement.QualifiedThisReference(caller, enclosingClass));
+			} catch (IllegalArgumentException e) {
+				enterIllegalState(e);
+			}
+		}
+
+		if (!iterator.hasNext()) { // accepted state
+			return;
+		}
+		String token = iterator.next();
+
+		// this.prop
+		if (tryEnterFieldReferenceState(enclosingClass, token, false)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterSuperState(Class<?> targetClass, String superLiteral) throws IllegalSyntaxException {
+		if (!"super".equals(superLiteral)) {
+			return false;
+		}
+
+		enterSuperState(targetClass);
+		return true;
+	}
+
+	// "^super" or "Qualified.super" expression
+	private void enterSuperState(Class<?> enclosingClass) throws IllegalSyntaxException {
+		referenceChain.append(new ReferenceChainElement.ThisReference(caller));
+		if (!caller.equals(enclosingClass)) {
+			try {
+				referenceChain.append(new ReferenceChainElement.QualifiedThisReference(caller, enclosingClass));
+			} catch (IllegalArgumentException e) {
+				enterIllegalState(e);
+			}
+		}
+
+		Class<?> superClass = enclosingClass.getSuperclass();
+		if (superClass == null) { // almost would never happen, java.lang classes are not transformable
+			enterIllegalState(String.format("'%s' has no super class", enclosingClass.getName()));
+		}
+
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("unexpected end of input");
+		}
+		String token = iterator.next();
+
+		// super.prop
+		if (tryEnterFieldReferenceState(superClass, token, false)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterFieldReferenceState(Class<?> memberingClass, String fieldName, boolean fromStaticContext)
+			throws IllegalSyntaxException {
+		try {
+			Field field = AccessUtils.getFieldOnHierarchy(memberingClass, fieldName);
+			enterFieldReferenceState(memberingClass, field, fromStaticContext);
+			return true;
+		} catch (NoSuchFieldException e) {
+			return false;
+		}
+	}
+
+	private void enterFieldReferenceState(Class<?> memberingClass, Field field, boolean fromStaticContext)
+			throws IllegalSyntaxException {
+		if (fromStaticContext && !Modifier.isStatic(field.getModifiers())) {
+			enterIllegalState(
+					String.format("Non-static field '%s' cannot be referenced from a static context", field.getName()));
+		}
+
+		if (!AccessUtils.isAccessible(memberingClass, field, caller)) {
+			String access;
+			if (Modifier.isPrivate(field.getModifiers())) {
+				access = "private";
+			} else if (Modifier.isProtected(field.getModifiers())) {
+				access = "protected";
+			} else {
+				access = "package-private";
+			}
+
+			enterIllegalState(String.format("'%s' has %s access in '%s'", field.getName(), access,
+					field.getDeclaringClass().getName()));
+		}
+
+		if (!caller.equals(memberingClass) && Modifier.isPrivate(field.getModifiers()) && AccessUtils
+				.areNestMates(caller, memberingClass)) {
+			enterIllegalState(
+					new UnsupportedOperationException("Private member access between nestmates is not supported"));
+		}
+
+		referenceChain.append(new ReferenceChainElement.FieldReference(memberingClass, field));
+
+		if (!iterator.hasNext()) { // accepted state
+			return;
+		}
+		String token = iterator.next();
+
+		// prop.prop2
+		if (tryEnterFieldReferenceState(field.getType(), token, false)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEntryNestedFieldReferenceState(String fieldName) throws IllegalSyntaxException {
+		Class<?> enclosing = caller.getEnclosingClass();
+		while (enclosing != null) {
+			try {
+				Field field = AccessUtils.getFieldOnHierarchy(enclosing, fieldName);
+				enterNestedFieldReferenceState(enclosing, field);
+				return true;
+			} catch (NoSuchFieldException e) {
+				enclosing = enclosing.getEnclosingClass();
+			}
+		}
+
+		return false;
+	}
+
+	private void enterNestedFieldReferenceState(Class<?> enclosingClass, Field field) throws IllegalSyntaxException {
+		if (!Modifier.isStatic(field.getModifiers())) {
+			Class<?> c = caller.getEnclosingClass(); // the inner class is always static if it has a static method
+			// check there is no static class in between, before reaching the enclosing class
+			while (!c.equals(enclosingClass)) {
+				if (Modifier.isStatic(c.getModifiers())) {
+					enterIllegalState(String.format("Non-static field '%s' cannot be referenced from a static context",
+							field.getName()));
+				}
+				c = c.getEnclosingClass();
+			}
+		}
+
+		// this is syntactically allowed, but we don't support it for now
+		if (Modifier.isPrivate(field.getModifiers())) {
+			enterIllegalState(
+					new UnsupportedOperationException("Private member access between nestmates is not supported"));
+		}
+
+		if (!Modifier.isStatic(field.getModifiers())) {
+			// cast to outer class instance only when accessing non-static fields
+			referenceChain.append(new ReferenceChainElement.ThisReference(caller));
+			try {
+				referenceChain.append(new ReferenceChainElement.QualifiedThisReference(caller, enclosingClass));
+			} catch (IllegalArgumentException e) {
+				enterIllegalState(e);
+			}
+		}
+
+		referenceChain.append(new ReferenceChainElement.FieldReference(enclosingClass, field));
+
+		if (!iterator.hasNext()) { // accepted state
+			return;
+		}
+		String token = iterator.next();
+
+		// nestedProp.prop
+		if (tryEnterFieldReferenceState(field.getType(), token, false)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterOuterClassState(String simpleClassName) throws IllegalSyntaxException {
+		Class<?> enclosing = caller.getEnclosingClass();
+		while (enclosing != null) {
+			if (enclosing.getSimpleName().equals(simpleClassName)) {
+				enterOuterClassState(enclosing);
+				return true;
+			}
+
+			enclosing = enclosing.getEnclosingClass();
+		}
+
+		return false;
+	}
+
+	private boolean tryEnterOuterClassState(Package pkg, String className) throws IllegalSyntaxException {
+		String fqcn = pkg.getName().isEmpty() ? className : pkg.getName() + "." + className;
+		try {
+			Class<?> clazz = caller.getClassLoader().loadClass(fqcn);
+			Class<?> enclosing = caller.getEnclosingClass();
+			while (enclosing != null) {
+				if (enclosing.equals(clazz)) {
+					enterOuterClassState(enclosing);
+					return true;
+				}
+
+				enclosing = enclosing.getEnclosingClass();
+			}
+		} catch (ClassNotFoundException e) {
+			// no op
+		}
+
+		return false;
+	}
+
+	private boolean tryEnterOuterClassState(Class<?> currentClass, String simpleClassName)
+			throws IllegalSyntaxException {
+		Class<?> clazz = null;
+		for (Class<?> c : currentClass.getDeclaredClasses()) {
+			if (c.getSimpleName().equals(simpleClassName)) {
+				clazz = c;
+				break;
+			}
+		}
+
+		Class<?> enclosing = caller.getEnclosingClass();
+		while (enclosing != null) {
+			if (enclosing.equals(clazz)) {
+				enterOuterClassState(enclosing);
+				return true;
+			}
+
+			enclosing = enclosing.getEnclosingClass();
+		}
+
+		return false;
+	}
+
+	private void enterOuterClassState(Class<?> targetClass) throws IllegalSyntaxException {
+		// static context
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState(
+					"Unexpected end of input: expects 'this', 'super', a static field name, or an inner class name");
+		}
+		String token = iterator.next();
+
+		// OuterClass.this
+		if (tryEnterThisState(targetClass, token)) {
+			return;
+		}
+
+		// OuterClass.super
+		if (tryEnterSuperState(targetClass, token)) {
+			return;
+		}
+
+		// OuterClass.STATIC_PROP
+		if (tryEnterFieldReferenceState(targetClass, token, true)) {
+			return;
+		}
+
+		// OuterClass.ThisClass
+		if (tryEnterSameClassState(targetClass, token)) {
+			return;
+		}
+
+		// OuterMostClass.OuterClass
+		if (tryEnterOuterClassState(targetClass, token)) {
+			return;
+		}
+
+		// OuterClass.OtherClass
+		if (tryEnterNestMateClass(targetClass, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterInnerClassState(Class<?> currentClass, String simpleClassName)
+			throws IllegalSyntaxException {
+		for (Class<?> innerClass : currentClass.getDeclaredClasses()) {
+			if (innerClass.getSimpleName().equals(simpleClassName)) {
+				enterInnerClassState(innerClass);
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	private void enterInnerClassState(Class<?> targetClass) throws IllegalSyntaxException {
+		// static context
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("Unexpected end of input: expects a static field name or an inner class name");
+		}
+		String token = iterator.next();
+
+		// InnerClass.STATIC_PROP
+		if (tryEnterFieldReferenceState(targetClass, token, true)) {
+			return;
+		}
+
+		// InnerClass.InnerMoreClass
+		if (tryEnterInnerClassState(targetClass, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	// target class is not a inner or outer class of the caller class, but is a classmate
+	private boolean tryEnterNestMateClass(Class<?> currentClass, String simpleClassName) throws IllegalSyntaxException {
+		Class<?> clazz = null;
+		for (Class<?> c : currentClass.getDeclaredClasses()) {
+			if (c.getSimpleName().equals(simpleClassName)) {
+				clazz = c;
+				break;
+			}
+		}
+
+		if (clazz == null) {
+			return false;
+		}
+
+		if (!AccessUtils.areNestMates(clazz, caller)) {
+			return false;
+		}
+
+		// check caller is not an outer class of clazz  
+		Class<?> enclosing = clazz;
+		while (enclosing != null) {
+			if (caller.equals(enclosing)) {
+				return false;
+			}
+			enclosing = enclosing.getEnclosingClass();
+		}
+
+		// check clazz if not an outer class of caller
+		enclosing = caller;
+		while (enclosing != null) {
+			if (clazz.equals(enclosing)) {
+				return false;
+			}
+			enclosing = enclosing.getEnclosingClass();
+		}
+
+		enterNestMateClass(clazz);
+		return true;
+	}
+
+	private void enterNestMateClass(Class<?> targetClass) throws IllegalSyntaxException {
+		// static context
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("Unexpected end of input: expects a static field name or an inner class name");
+		}
+		String token = iterator.next();
+
+		// NestMateClass.STATIC_PROP
+		if (tryEnterFieldReferenceState(targetClass, token, false)) {
+			return;
+		}
+
+		// NestMateClass.NestMatesInnerClass
+		if (tryEnterNestMateClass(targetClass, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterSameClassState(String simpleClassName) throws IllegalSyntaxException {
+		if (caller.getSimpleName().equals(simpleClassName)) {
+			enterSameClassState();
+			return true;
+		}
+
+		return false;
+	}
+
+	private boolean tryEnterSameClassState(Package pkg, String simpleClassName) throws IllegalSyntaxException {
+		String fqcn = pkg.getName().isEmpty() ? simpleClassName : pkg.getName() + "." + simpleClassName;
+		if (caller.getName().equals(fqcn)) {
+			enterSameClassState();
+			return true;
+		}
+
+		return false;
+	}
+
+	private boolean tryEnterSameClassState(Class<?> currentClass, String simpleClassName)
+			throws IllegalSyntaxException {
+		Class<?> clazz = null;
+		for (Class<?> c : currentClass.getDeclaredClasses()) {
+			if (c.getSimpleName().equals(simpleClassName)) {
+				clazz = c;
+				break;
+			}
+		}
+
+		if (caller.equals(clazz)) {
+			enterSameClassState();
+			return true;
+		}
+
+		return false;
+	}
+
+	private void enterSameClassState() throws IllegalSyntaxException {
+		// static context
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("Unexpected end of input: expects a static field name or an inner class name");
+		}
+		String token = iterator.next();
+
+		// CallerClass.this => this
+		if (tryEnterThisState(caller, token)) {
+			return;
+		}
+
+		// CallerClass.super => super
+		if (tryEnterSuperState(caller, token)) {
+			return;
+		}
+
+		// CallerClass.STATIC_PROP
+		if (tryEnterFieldReferenceState(caller, token, true)) {
+			return;
+		}
+
+		if (tryEnterInnerClassState(caller, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private boolean tryEnterClassState(String simpleClassName) throws IllegalSyntaxException {
+		return tryEnterClassState(caller.getPackage(), simpleClassName);
+	}
+
+	private boolean tryEnterClassState(Class<?> currentClass, String simpleClassName) throws IllegalSyntaxException {
+		for (Class<?> c : currentClass.getDeclaredClasses()) {
+			if (c.getSimpleName().equals(simpleClassName)) {
+				enterClassState(c);
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	private boolean tryEnterClassState(Package pkg, String simpleClassName) throws IllegalSyntaxException {
+		String fqcn = pkg.getName().isEmpty() ? simpleClassName : pkg.getName() + "." + simpleClassName;
+
+		try {
+			Class<?> c = caller.getClassLoader().loadClass(fqcn);
+			enterClassState(c);
+			return true;
+		} catch (ClassNotFoundException e) {
+			return false;
+		}
+	}
+
+	private void enterClassState(Class<?> targetClass) throws IllegalSyntaxException {
+		// static context
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("Unexpected end of input: expects a static field name or an inner class name");
+		}
+		String token = iterator.next();
+
+		// ClassName.STATIC_PROP
+		if (tryEnterFieldReferenceState(targetClass, token, true)) {
+			return;
+		}
+
+		// ClassName.InnerClass
+		if (tryEnterClassState(targetClass, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	// Full qualified package named prefixed expression
+	private boolean tryEnterPackageState(String fqpnPrefixedExpression) throws IllegalSyntaxException {
+		// ClassLoader.getPackage(String) or ClassLoader.getPackages() is not reliable when no class from that package is yet loaded
+		int stop = 0;
+		Class<?> clazz = null;
+		while (stop < fqpnPrefixedExpression.length()) {
+			stop = fqpnPrefixedExpression.indexOf('.', stop + 1);
+			if (stop == -1) {
+				break;
+			}
+
+			String fqcn = fqpnPrefixedExpression.substring(0, stop);
+			try {
+				clazz = caller.getClassLoader().loadClass(fqcn);
+				break;
+			} catch (ClassNotFoundException e) {
+				// no op
+			}
+		}
+
+		if (clazz == null) {
+			return false;
+		}
+
+		Package pkg = clazz.getPackage();
+
+		tokens = new LinkedList<>(Arrays.asList(fqpnPrefixedExpression.split("\\.")));
+		iterator = tokens.iterator();
+		int length = pkg.getName().split("\\.").length;
+		for (int i = 0; i < length; i++) {
+			iterator.next();
+		}
+
+		enterPackageState(pkg);
+		return true;
+	}
+
+	// Partially qualified package named prefixed expression
+	private boolean tryEnterPackageState(Package pkg, String pqpnPrefixedExpression) throws IllegalSyntaxException {
+		String pkgPrefix = pkg.getName().isEmpty() ? "" : pkg.getName() + ".";
+		return tryEnterPackageState(pkgPrefix + pqpnPrefixedExpression);
+	}
+
+	private void enterPackageState(Package pkg) throws IllegalSyntaxException {
+		if (!iterator.hasNext()) { // rejected state
+			enterIllegalState("Unexpected end of input: expects a class name");
+		}
+		String token = iterator.next();
+
+		if (tryEnterSameClassState(pkg, token)) {
+			return;
+		}
+
+		if (tryEnterOuterClassState(pkg, token)) {
+			return;
+		}
+
+		if (tryEnterClassState(pkg, token)) {
+			return;
+		}
+
+		enterIllegalState(String.format("Unrecognized symbol '%s'", token));
+	}
+
+	private void enterIllegalState(String msg) throws IllegalSyntaxException {
+		throw new IllegalSyntaxException(msg);
+	}
+
+	private void enterIllegalState(Throwable throwable) throws IllegalSyntaxException {
+		throw new IllegalSyntaxException(throwable);
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/IllegalSyntaxException.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/IllegalSyntaxException.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/IllegalSyntaxException.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util.expression;
+
+public class IllegalSyntaxException extends Exception {
+	public IllegalSyntaxException() {
+		super();
+	}
+
+	public IllegalSyntaxException(String message) {
+		super(message);
+	}
+
+	public IllegalSyntaxException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
+	public IllegalSyntaxException(Throwable cause) {
+		super(cause);
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util.expression;
+
+import org.objectweb.asm.Type;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A ReferenceChain instance presents a field reference expression.
+ * 
+ * eg. <code>OuterClass.this.field.STATIC_FIELD</code> is a reference chain consisting elements: a qualified-this 
+ * reference and two field reference (<code>field</code> and <code>STATIC_FIELD</code>).
+ * 
+ */
+public final class ReferenceChain {
+	private final Class<?> callerClass;
+	private final List<ReferenceChainElement> references;
+
+	/**
+	 * @param callerClass the caller class making this reference
+	 */
+	public ReferenceChain(Class<?> callerClass) {
+		this.callerClass = callerClass;
+		this.references = new LinkedList<>();
+	}
+
+	/**
+	 * @return the caller class making this reference
+	 */
+	public Class<?> getCallerClass() {
+		return callerClass;
+	}
+
+	/**
+	 * @return all elements on the reference chain
+	 */
+	public List<ReferenceChainElement> getReferences() {
+		return references;
+	}
+
+	/**
+	 * Reduces the reference chain to prepend "this" or qualified-this references if necessary, and short-circuits on
+	 * static references
+	 * 
+	 * @return the normalized reference chain
+	 */
+	public ReferenceChain normalize() {
+		List<ReferenceChainElement> oldRefs = getReferences();
+		List<ReferenceChainElement> newRefs = new LinkedList<>();
+
+		// Take shortcuts on static references
+		for (ReferenceChainElement ref : oldRefs) {
+			if (ref.isStatic()) {
+				newRefs.clear();
+			}
+
+			newRefs.add(ref);
+		}
+
+		// Don't reduce static final references to constants. The value could be different, or even stochastic, if 
+		// loaded via different class loaders. (eg. logic in static initializers)
+
+		// prepend "this" if starts with non-static field reference
+		if (newRefs.isEmpty()) {
+			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // implicit "this"
+		} else if (newRefs.get(0) instanceof ReferenceChainElement.FieldReference && !newRefs.get(0).isStatic()) {
+			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // prop => this.prop
+		}
+
+		ReferenceChain ret = new ReferenceChain(callerClass);
+		ret.references.addAll(newRefs);
+		return ret;
+	}
+
+	/**
+	 * @return the type of the last reference element
+	 */
+	public Type getType() {
+		if (references.isEmpty()) {
+			return Type.getType(callerClass);
+		}
+		return references.get(references.size() - 1).getReferencedType();
+	}
+
+	/**
+	 * Appends a ReferenceChainElement to the chain
+	 * @param ref ReferenceChainElement to be appended
+	 */
+	public void append(ReferenceChainElement ref) {
+		references.add(ref);
+	}
+
+	/**
+	 * @return whether the reference is valid from a static context
+	 */
+	public boolean isStatic() {
+		if (references.isEmpty()) {
+			return false;
+		}
+
+		return references.get(0).isStatic();
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChainElement.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChainElement.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChainElement.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent.util.expression;
+
+import org.objectweb.asm.Type;
+import org.openjdk.jmc.agent.util.AccessUtils;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Objects;
+
+public interface ReferenceChainElement {
+	// class/interface which the reference is from
+	Class<?> getMemberingClass();
+
+	// class/interface which the reference is to
+	Class<?> getReferencedClass();
+
+	// the type of the class/interface which the reference is from 
+	Type getMemberingType();
+
+	// the type of the class/interface which the reference is to
+	Type getReferencedType();
+
+
+	// if this reference is static
+	boolean isStatic();
+
+	class FieldReference implements ReferenceChainElement {
+		private final Class<?> memberingClass;
+		private final Field field;
+
+		public FieldReference(Class<?> memberingClass, Field field) {
+			this.memberingClass = memberingClass;
+			this.field = field;
+
+			try {
+				AccessUtils.getFieldOnHierarchy(memberingClass, field.getName());
+			} catch (NoSuchFieldException e) {
+				throw new IllegalArgumentException(
+						String.format("'%s' is not a field of '%s'", field.getName(), memberingClass.getName()));
+			}
+		}
+
+		@Override
+		public Class<?> getMemberingClass() {
+			return memberingClass;
+		}
+
+		@Override
+		public Class<?> getReferencedClass() {
+			return field.getType();
+		}
+
+		@Override
+		public Type getMemberingType() {
+			return Type.getType(getMemberingClass());
+		}
+
+		@Override
+		public Type getReferencedType() {
+			return Type.getType(getReferencedClass());
+		}
+
+		@Override
+		public boolean isStatic() {
+			return Modifier.isStatic(field.getModifiers());
+		}
+
+		@Override
+		public String toString() {
+			return String.format("%s.%s:%s", getMemberingClass().getName(), getName(), getReferencedClass().getName());
+		}
+
+		public Field getField() {
+			return field;
+		}
+
+		public String getName() {
+			return getField().getName();
+		}
+	}
+
+	class ThisReference implements ReferenceChainElement {
+		private final Class<?> clazz;
+
+		public ThisReference(Class<?> clazz) {
+			this.clazz = clazz;
+
+			Objects.requireNonNull(clazz, "Class is not nullable");
+		}
+
+		@Override
+		public Class<?> getMemberingClass() {
+			return clazz;
+		}
+
+		@Override
+		public Class<?> getReferencedClass() {
+			return clazz;
+		}
+
+		@Override
+		public Type getMemberingType() {
+			return Type.getType(getMemberingClass());
+		}
+
+		@Override
+		public Type getReferencedType() {
+			return Type.getType(getReferencedClass());
+		}
+
+		@Override
+		public boolean isStatic() {
+			return false;
+		}
+
+		@Override
+		public String toString() {
+			return "this";
+		}
+	}
+
+	class QualifiedThisReference implements ReferenceChainElement {
+		private final Class<?> innerClass;
+		private final Class<?> enclosingClass;
+		private final int depth;
+
+		public QualifiedThisReference(Class<?> innerClass, Class<?> enclosingClass) {
+			this.innerClass = innerClass;
+			this.enclosingClass = enclosingClass;
+
+			Class<?> c = innerClass;
+			int d = 0; // depth of inner class nesting, used for this$i reference to enclosing classes
+			while (!enclosingClass.equals(c.getEnclosingClass())) {
+				Class<?> enclosing = c.getEnclosingClass();
+				if (enclosing == null) {
+					throw new IllegalArgumentException(
+							String.format("%s is not an enclosing class of %s", enclosingClass.getName(),
+									innerClass.getName()));
+				}
+
+				d++;
+				c = enclosing;
+			}
+
+			this.depth = d;
+		}
+
+		@Override
+		public Class<?> getMemberingClass() {
+			return innerClass;
+		}
+
+		@Override
+		public Class<?> getReferencedClass() {
+			return enclosingClass;
+		}
+
+		@Override
+		public Type getMemberingType() {
+			return Type.getType(getMemberingClass());
+		}
+
+		@Override
+		public Type getReferencedType() {
+			return Type.getType(getReferencedClass());
+		}
+
+		@Override
+		public boolean isStatic() {
+			return false;
+		}
+
+		@Override
+		public String toString() {
+			return String.format("%s.this", getReferencedClass().getName());
+		}
+
+		public int getDepth() {
+			return depth;
+		}
+	}
+}
diff a/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/InstrumentMe.java b/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/InstrumentMe.java
--- a/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/InstrumentMe.java
+++ b/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/InstrumentMe.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,10 +39,29 @@
 import java.util.List;
 
 import org.openjdk.jmc.agent.test.util.TestToolkit;
 
 public class InstrumentMe {
+	public static final String STATIC_STRING_FIELD = "org.openjdk.jmc.agent.test.InstrumentMe.STATIC_STRING_FIELD";
+	public static final MyPojo STATIC_OBJECT_FIELD = new MyPojo();
+	public static final MyPojo STATIC_NULL_FIELD = null;
+
+	public final String instanceStringField = "org.openjdk.jmc.agent.test.InstrumentMe.instanceStringField";
+
+	public static class MyPojo { 
+		public String instanceStringField = "org.openjdk.jmc.agent.test.InstrumentMe.MyPojo.instanceStringField";
+		public static String STATIC_STRING_FIELD = "org.openjdk.jmc.agent.test.InstrumentMe.MyPojo.STATIC_STRING_FIELD";
+	}
+	
+	public class MyInnerClass extends InstrumentMe{
+		private final String innerClassField = "org.openjdk.jmc.agent.test.InstrumentMe.MyInnerClass.innerClassField";
+
+		public void instrumentationPoint() {
+			// no op
+		}
+	}
+
 	public static void main(String[] args) throws InterruptedException, IOException {
 		Thread runner = new Thread(new Runner(), "InstrumentMe Runner");
 		runner.setDaemon(true);
 		System.out.println("Press <enter> at any time to quit");
 		System.out.println("Now starting looping through the instrumentation examples");
@@ -90,10 +109,12 @@
 		try {
 			instance.printInstanceHelloWorldJFR10();
 		} catch (RuntimeException e) {
 			System.out.println("#IJFR10. Caught a RuntimeException: " + e.getMessage());
 		}
+		instance.printInstanceHelloWorldJFR11();
+		instance.printInstanceHelloWorldJFR12();
 	}
 
 	private static void runStatic() throws InterruptedException {
 		System.out.println("Running static versions..."); //$NON-NLS-1$
 		printHelloWorld1();
@@ -109,22 +130,25 @@
 		printHelloWorldJFR6();
 		printHelloWorldJFR7();
 		try {
 			printHelloWorldJFR8();
 		} catch (RuntimeException e) {
-			System.out.println("#IJFR8. Caught a RuntimeException: " + e.getMessage());
+			System.out.println("#SJFR8. Caught a RuntimeException: " + e.getMessage());
 		}
 		try {
 			printHelloWorldJFR9();
 		} catch (RuntimeException e) {
-			System.out.println("#IJFR9. Caught a RuntimeException: " + e.getMessage());
+			System.out.println("#SJFR9. Caught a RuntimeException: " + e.getMessage());
 		}
 		try {
 			printHelloWorldJFR10();
 		} catch (RuntimeException e) {
-			System.out.println("#IJFR10. Caught a RuntimeException: " + e.getMessage());
+			System.out.println("#SJFR10. Caught a RuntimeException: " + e.getMessage());
 		}
+		printHelloWorldJFR11();
+		printHelloWorldJFR12();
+		printHelloWorldJFR13();
 	}
 
 	private static Collection<Gurka> createGurkList() {
 		List<Gurka> gurkList = new ArrayList<>();
 		for (int i = 0; i < TestToolkit.RND.nextInt(4) + 1; i++) {
@@ -202,33 +226,48 @@
 			// intentionally empty
 		}
 	}
 
 	public static void printHelloWorldJFR8() throws InterruptedException {
-		System.out.println("#IJFR8. About to throw a RuntimeException"); //$NON-NLS-1$
+		System.out.println("#SJFR8. About to throw a RuntimeException"); //$NON-NLS-1$
 		Thread.sleep(1000);
 		(new ArrayList<>()).get(1);
 	}
 
 	public static void printHelloWorldJFR9() throws InterruptedException {
-		System.out.println("#IJFR9. About to throw a RuntimeException"); //$NON-NLS-1$
+		System.out.println("#SJFR9. About to throw a RuntimeException"); //$NON-NLS-1$
 		Thread.sleep(1000);
 		(new ArrayList<>()).get(1);
 	}
 
 	public static void printHelloWorldJFR10() throws InterruptedException {
-		System.out.println("#IJFR10. About to throw a RuntimeException"); //$NON-NLS-1$
+		System.out.println("#SJFR10. About to throw a RuntimeException"); //$NON-NLS-1$
 		Thread.sleep(1000);
 
 		try {
 			(new ArrayList<>()).get(1);
 		} catch (RuntimeException e) {
-			System.out.println("#IJFR10. Caught a RuntimeException: " + e.getMessage()); //$NON-NLS-1$
+			System.out.println("#SJFR10. Caught a RuntimeException: " + e.getMessage()); //$NON-NLS-1$
 			throw e;
 		}
 	}
 
+	public static void printHelloWorldJFR11() throws InterruptedException {
+		System.out.println("#SJFR11. Capturing static field 'STATIC_STRING_FIELD'"); //$NON-NLS-1$
+		Thread.sleep(1000);
+	}
+
+	public static void printHelloWorldJFR12() throws InterruptedException {
+		System.out.println("#SJFR12. Capturing 'STATIC_OBJECT_FIELD.STATIC_STRING_FIELD' and 'STATIC_OBJECT_FIELD.instanceStringField'"); //$NON-NLS-1$
+		Thread.sleep(1000);
+	}
+
+	public static void printHelloWorldJFR13() throws InterruptedException {
+		System.out.println("#SJFR13. Capturing 'STATIC_NULL_FIELD.STATIC_STRING_FIELD' and 'STATIC_NULL_FIELD.instanceStringField'"); //$NON-NLS-1$
+		Thread.sleep(1000);
+	}
+
 	public void printInstanceHelloWorld1() throws InterruptedException {
 		System.out.println("#I1. Hello World!"); //$NON-NLS-1$
 		Thread.sleep(1000);
 	}
 
@@ -318,6 +357,16 @@
 		} catch (RuntimeException e) {
 			System.out.println("#IJFR10. Caught a RuntimeException: " + e.getMessage()); //$NON-NLS-1$
 			throw e;
 		}
 	}
+
+	public void printInstanceHelloWorldJFR11() throws InterruptedException {
+		System.out.println("#IJFR11. Capturing instance field 'instanceStringField'"); //$NON-NLS-1$
+		Thread.sleep(1000);
+	}
+	
+	public void printInstanceHelloWorldJFR12() throws InterruptedException {
+		System.out.println("#IJFR12. Capturing fields from nested class 'InstrumentMe.MyInnerClass'"); //$NON-NLS-1$
+		new MyInnerClass().instrumentationPoint();
+	}
 }
diff a/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/TestDefineEventProbes.java b/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/TestDefineEventProbes.java
--- a/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/TestDefineEventProbes.java
+++ b/core/org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/TestDefineEventProbes.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -49,10 +49,11 @@
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.commons.AdviceAdapter;
+import org.openjdk.jmc.agent.Field;
 import org.openjdk.jmc.agent.Method;
 import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.jfrnext.impl.JFRNextEventClassGenerator;
@@ -116,17 +117,17 @@
 		assertFalse(exceptionThrown);
 	}
 
 	private void injectFailingEvent() throws Exception {
 		Method method = new Method(METHOD_NAME, METHOD_DESCRIPTOR);
-		Map<String, String> attributes = new HashMap<String, String>();
+		Map<String, String> attributes = new HashMap<>();
 		attributes.put("path", EVENT_PATH);
 		attributes.put("name", EVENT_NAME);
 		attributes.put("description", EVENT_DESCRIPTION);
-		ReturnValue retVal = new ReturnValue(null, "", null);
-		JFRTransformDescriptor eventTd = new JFRTransformDescriptor(EVENT_ID,
-				EVENT_CLASS_NAME.replace(".", "/"), method, attributes, new ArrayList<Parameter>(), retVal);
+		ReturnValue retVal = new ReturnValue(null, "", null, null, null);
+		JFRTransformDescriptor eventTd = new JFRTransformDescriptor(EVENT_ID, TypeUtils.getInternalName(EVENT_CLASS_NAME),
+				method, attributes, new ArrayList<Parameter>(), retVal, new ArrayList<Field>());
 
 		ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
 		ClassVisitor classVisitor = new ClassVisitor(Opcodes.ASM5, classWriter) {
 			@Override
 			public MethodVisitor visitMethod(int access, String name, String desc, String signature,
@@ -148,11 +149,11 @@
 					}
 				};
 			}
 		};
 
-		byte[] eventClass = JFRNextEventClassGenerator.generateEventClass(eventTd);
+		byte[] eventClass = JFRNextEventClassGenerator.generateEventClass(eventTd, InstrumentMe.class);
 		ClassReader reader = new ClassReader(eventClass);
 		reader.accept(classVisitor, 0);
 		byte[] modifiedEvent = classWriter.toByteArray();
 
 		TypeUtils.defineClass(eventTd.getEventClassName(), modifiedEvent, 0, modifiedEvent.length,
diff a/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml b/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
--- a/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
+++ b/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--   
-   Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
    
    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    
    The contents of this file are subject to the terms of either the Universal Permissive License 
    v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -84,10 +84,78 @@
 				</returnvalue>
 			</method>
 			<!-- location {ENTRY, EXIT, WRAP}-->
 			<location>WRAP</location>
 		</event>
+		<event id="demo.jfr.test11">
+			<name>JFR Hello World Event 11 %TEST_NAME%</name>
+			<description>Defined in the xml file and added by the agent. Should record the value of static reference 'STATIC_STRING_FIELD'</description>
+			<path>demo/jfrhelloworldevent11</path>
+			<stacktrace>true</stacktrace>
+			<class>org.openjdk.jmc.agent.test.InstrumentMe</class>
+			<method>
+				<name>printHelloWorldJFR11</name>
+				<descriptor>()V</descriptor>
+			</method>
+			<field>
+				<name>'STATIC_STRING_FIELD'</name>
+				<description>Capturing static field with simple field name</description>
+				<expression>STATIC_STRING_FIELD</expression>
+			</field>
+			<field>
+				<name>'InstrumentMe.STATIC_STRING_FIELD'</name>
+				<description>Capturing static field with class name prefixed field name</description>
+				<expression>InstrumentMe.STATIC_STRING_FIELD</expression>
+			</field>
+			<field>
+				<name>'org.openjdk.jmc.agent.test.InstrumentMe.STATIC_STRING_FIELD'</name>
+				<description>Capturing static field with full qualified class prefixed name</description>
+				<expression>org.openjdk.jmc.agent.test.InstrumentMe.STATIC_STRING_FIELD</expression>
+			</field>
+		</event>
+		<event id="demo.jfr.test12">
+			<name>JFR Hello World Event 12 %TEST_NAME%</name>
+			<description>Defined in the xml file and added by the agent. Should record the values of 'STATIC_OBJECT_FIELD.STATIC_STRING_FIELD' and 'STATIC_OBJECT_FIELD.instanceStringField'</description>
+			<path>demo/jfrhelloworldevent12</path>
+			<stacktrace>true</stacktrace>
+			<class>org.openjdk.jmc.agent.test.InstrumentMe</class>
+			<method>
+				<name>printHelloWorldJFR12</name>
+				<descriptor>()V</descriptor>
+			</method>
+			<field>
+				<name>'STATIC_OBJECT_FIELD.STATIC_STRING_FIELD'</name>
+				<description>Capturing static field on a object reference</description>
+				<expression>STATIC_OBJECT_FIELD.STATIC_STRING_FIELD</expression>
+			</field>
+			<field>
+				<name>'STATIC_OBJECT_FIELD.instanceStringField'</name>
+				<description>Capturing non-static field on a object reference</description>
+				<expression>STATIC_OBJECT_FIELD.instanceStringField</expression>
+			</field>
+		</event>
+		<event id="demo.jfr.test13">
+			<name>JFR Hello World Event 13 %TEST_NAME%</name>
+			<description>Defined in the xml file and added by the agent. Should record the values of static 'STATIC_NULL_FIELD.STATIC_STRING_FIELD' and 'STATIC_NULL_FIELD.instanceStringField'</description>
+			<path>demo/jfrhelloworldevent13</path>
+			<stacktrace>true</stacktrace>
+			<class>org.openjdk.jmc.agent.test.InstrumentMe</class>
+			<method>
+				<name>printHelloWorldJFR11</name>
+				<descriptor>()V</descriptor>
+			</method>
+			<field>
+				<name>'STATIC_NULL_FIELD.STATIC_STRING_FIELD'</name>
+				<description>Capturing static field on a null object reference</description>
+				<expression>STATIC_NULL_FIELD.STATIC_STRING_FIELD</expression>
+			</field>
+			<field>
+				<name>'STATIC_NULL_FIELD.instanceStringField'</name>
+				<description>Capturing non-static field on a null object reference</description>
+				<expression>STATIC_NULL_FIELD.instanceStringField</expression>
+			</field>
+		</event>
 		<event id="demo.jfr.testI1">
 			<name>JFR Hello World Instance Event 1 %TEST_NAME%</name>
 			<description>Defined in the xml file and added by the agent.</description>
 			<path>demo/jfrhelloworldeventI1</path>
 			<stacktrace>true</stacktrace>
@@ -235,7 +303,81 @@
 				<name>printInstanceHelloWorldJFR10</name>
 				<descriptor>()V</descriptor>
 			</method>
 			<rethrow>true</rethrow>
 		</event>
+		<event id="demo.jfr.testI11">
+			<name>JFR Hello World Instance Event 11 %TEST_NAME%</name>
+			<description>Defined in the xml file and added by the agent. Should record the value of instance reference 'instanceStringField'</description>
+			<path>demo/jfrhelloworldeventI11</path>
+			<stacktrace>true</stacktrace>
+			<class>org.openjdk.jmc.agent.test.InstrumentMe</class>
+			<method>
+				<name>printInstanceHelloWorldJFR11</name>
+				<descriptor>()V</descriptor>
+			</method>
+			<field>
+				<name>'instanceStringField'</name>
+				<description>Capturing instance field with simple field name</description>
+				<expression>instanceStringField</expression>
+			</field>
+			<field>
+				<name>'this.instanceStringField'</name>
+				<description>Capturing instance field with "this" prefixed field name</description>
+				<expression>this.instanceStringField</expression>
+			</field>
+			<field>
+				<name>'InstrumentMe.this.instanceStringField'</name>
+				<description>Capturing instance field with qualified "this" prefixed field name</description>
+				<expression>InstrumentMe.this.instanceStringField</expression>
+			</field>
+		</event>
+		<event id="demo.jfr.testI12">
+			<name>JFR Hello World Instance Event 12 %TEST_NAME%</name>
+			<description>Defined in the xml file and added by the agent. Should record the values of various references</description>
+			<path>demo/jfrhelloworldeventI12</path>
+			<stacktrace>true</stacktrace>
+			<class>org.openjdk.jmc.agent.test.InstrumentMe$MyInnerClass</class>
+			<method>
+				<name>instrumentationPoint</name>
+				<descriptor>()V</descriptor>
+			</method>
+			<field>
+				<name>'innerClassField'</name>
+				<description>Capturing inner class field with simple field name</description>
+				<expression>innerClassField</expression>
+			</field>
+			<field>
+				<name>'this.innerClassField'</name>
+				<description>Capturing inner class field with "this" prefixed field name</description>
+				<expression>this.innerClassField</expression>
+			</field>
+
+			<field>
+				<name>'instanceStringField'</name>
+				<description>Capturing outer class field with simple field name</description>
+				<expression>instanceStringField</expression>
+			</field>
+			<field>
+				<name>'InstrumentMe.this.instanceStringField'</name>
+				<description>Capturing outer class field with qualified "this" prefixed field name</description>
+				<expression>InstrumentMe.this.instanceStringField</expression>
+			</field>
+			<field>
+				<name>'super.instanceStringField'</name>
+				<description>Capturing super class field with "super" prefixed field name</description>
+				<expression>super.instanceStringField</expression>
+			</field>
+
+			<field>
+				<name>'STATIC_STRING_FIELD'</name>
+				<description>Capturing outer class field with simple field name</description>
+				<expression>STATIC_STRING_FIELD</expression>
+			</field>
+			<field>
+				<name>'InstrumentMe.STATIC_STRING_FIELD'</name>
+				<description>Capturing outer class field with class name prefixed field name</description>
+				<expression>InstrumentMe.STATIC_STRING_FIELD</expression>
+			</field>
+		</event>
 	</events>
 </jfragent>
