<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/resources/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/messages.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #
  2 #  Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3 #
  4 #  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5 #
  6 #  The contents of this file are subject to the terms of either the Universal Permissive License
  7 #  v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8 #
  9 #  or the following license:
 10 #
 11 #  Redistribution and use in source and binary forms, with or without modification, are permitted
 12 #  provided that the following conditions are met:
 13 #
 14 #  1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15 #  and the following disclaimer.
 16 #
 17 #  2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18 #  conditions and the following disclaimer in the documentation and/or other materials provided with
 19 #  the distribution.
 20 #
 21 #  3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22 #  endorse or promote products derived from this software without specific prior written permission.
 23 #
 24 #  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25 #  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26 #  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27 #  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28 #  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29 #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31 #  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 #
 33 Preference_SHORT_RECORDING=Short recording limit
 34 Preference_SHORT_RECORDING_LONG=Minimum length of a recording to be considered useful for rules to work on.
 35 
 36 AllocationByClassRule_RULE_NAME=Allocated Classes
 37 # {0} is a class name
 38 AllocationByClassRule_TEXT_MESSAGE=The most allocated type is likely &#39;&#39;{0}&#39;&#39;, most commonly allocated by: {1}
 39 AllocationByThreadRule_RULE_NAME=Threads Allocating
 40 # {0} is a thread name
 41 AllocationByThreadRule_TEXT_MESSAGE=The most allocations were likely done by thread &#39;&#39;{0}&#39;&#39; at: {1}
 42 AllocationRuleFactory_TEXT_CLASS_INFO_LONG=Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.
 43 AllocationRuleFactory_TEXT_THREAD_INFO_LONG=Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.
 44 ApplicationHaltsRule_HALTS_INFO_LIMIT=Application halts info limit
 45 ApplicationHaltsRule_HALTS_INFO_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger an info notice
 46 ApplicationHaltsRule_HALTS_WARNING_LIMIT=Application halts warning limit
 47 ApplicationHaltsRule_HALTS_WARNING_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger a warning
 48 ApplicationHaltsRule_HALTS_WINDOW_SIZE=Application halts time window size
 49 ApplicationHaltsRule_HALTS_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
 50 # {0} is a concatenated string of event type ids
 51 ApplicationHaltsRule_EXTRA_EVENT_TYPES=Enabling the following event types would improve the accuracy of this rule: {0}
 52 ApplicationHaltsRule_RULE_NAME=Application Halts
 53 ApplicationHaltsRule_RULE_TEXT=Application efficiency was affected by halts
 54 # {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
 55 ApplicationHaltsRule_RULE_TEXT_LONG=The highest ratio of application halts to execution time was {0} % for {1} at {2}. {3} % of the halts were for reasons other than GC.&lt;p&gt;The halts ratio for the entire recording was {4} %. {5} % of the total halts were for reasons other than GC.&lt;/p&gt;
 56 ApplicationHaltsRule_RULE_TEXT_RECOMMENDATION=Application halts are often caused by garbage collections, but can also be caused by excessive thread dumps or heap dumps. Investigate the VM Operation information and possibly the safepoint specific information.
 57 ApplicationHaltsRule_RULE_TEXT_OK=Application efficiency was not highly affected by halts.
 58 
 59 AutoboxingRule_RULE_NAME=Primitive To Object Conversion
 60 AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT=Primitive to object conversion allocation ratio info limit
 61 AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT_DESC=The ratio between allocation caused by primitive to object conversion compared to the total allocation needed to trigger an info notice.
 62 AutoboxingRule_AUTOBOXING_RATIO_WARNING_LIMIT=Primitive to object conversion allocation ratio warning limit
 63 AutoboxingRule_AUTOBOXING_RATIO_WARNING_LIMIT_DESC=The ratio between allocation caused by primitive to object conversion compared to the total allocation needed to trigger a warning.
 64 AutoboxingRule_RESULT_NO_AUTOBOXING=No allocation was caused by conversion from primitive types to the corresponding object types.
 65 # {0} is a type name
 66 AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE=The most common object type that primitives are converted into is &#39;&#39;{0}&#39;&#39;.
 67 # {0} is a type name, {1} is a size in bytes, {2} is a method reference string
 68 AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE_LONG=The most common object type that primitives are converted into is &#39;&#39;{0}&#39;&#39;, which causes {1} to be allocated. The most common call site is &#39;&#39;{2}&#39;&#39;.
 69 AutoboxingRule_RESULT_AUTOBOXING_RATIO={0} % of the total allocation ({1}) is caused by conversion from primitive types to object types.
 70 AutoboxingRule_RESULT_LONG=Conversion from primitives to the corresponding object types can either be done explicitly, or be caused by autoboxing. If a considerable amount of the total allocation is caused by such conversions, consider changing the application source code to avoid this behavior. Look at the allocation stack traces to see which parts of the code to change. This rule finds the calls to the valueOf method for any of the eight object types that have primitive counterparts.
 71 BiasedLockingRevocationRule_CONFIG_FILTERED_CLASSES=Filtered Classes
 72 BiasedLockingRevocationRule_CONFIG_FILTERED_CLASSES_LONG=A comma separated list of the class names not to report
 73 BiasedLockingRevocationRule_CONFIG_WARNING_LIMIT=Revocation warning limit
 74 BiasedLockingRevocationRule_CONFIG_WARNING_LIMIT_LONG=The number of revocations at which to start warning
 75 BiasedLockingRevocationRule_NAME=Biased Locking Revocation
 76 BiasedLockingRevocationRule_TEXT_OK=No classes were disabled from participating in biased locking
 77 BiasedLockingRevocationRule_TEXT_REVOKED_CLASSES_FOUND=Fully revoked classes found.
 78 BiasedLockingRevocationRule_TEXT_REVOKED_CLASSES_FOUND_LONG=The following classes were disabled from using biased locking:
 79 BiasedLockingRevocationRule_TEXT_REVOKE_LIMIT_CLASSES_FOUND=Instances of classes were revoked more times than the user configured limit.
 80 # {0} is the user configured revocation limit
 81 BiasedLockingRevocationRule_TEXT_REVOKE_LIMIT_CLASSES_FOUND_LONG=The following instances of classes were revoked more than the user configured limit for this rule (limit={0}, not including disabled classes):
 82 # {0} is the classes that were filtered out from the result.
 83 BiasedLockingRevocationRule_TEXT_EPILOGUE=&lt;p&gt;Biased locking is a technique used by the JVM to decrease the cost of uncontended locking to near lock free performance. A thread can bias a lock object to itself, making subsequent locking by the same thread very inexpensive. If the lock starts being used by other threads, the bias can either be revoked, rebiased towards the other thread, or revoked from being biased again for the rest of the runtime of the JVM.&lt;/p&gt;&lt;p&gt;Having a lot of revoked classes need not be a problem, but can provide opportunities for optimizations, tuning and design improvements. For example, if you have a lot of contention during the startup of your application, the revocation costs may be significant, and you may want to delay the enablement of biased locking using the &#39;&#39;-XX:BiasedLockingStartupDelay=&amp;lt;time in ms&amp;gt;&#39;&#39; flag. For applications that heavily depend on contended locking, and cannot be redesigned, it may be beneficial to turn off biased locking altogether (&#39;&#39;-XX:-UseBiasedLocking&#39;&#39;). For benchmarking, you may want to set &#39;&#39;-XX:BiasedLockingStartupDelay&#39;&#39; to zero.&lt;p&gt;&lt;p&gt;The following classes were filtered out: {0}&lt;/p&gt;
 84 BiasedLockingRevocationPauseRule_CONFIG_WARNING_LIMIT=Biased locking warning limit time
 85 BiasedLockingRevocationPauseRule_CONFIG_WARNING_LIMIT_LONG=The total time spent on revoking biased locks needed to trigger a warning
 86 BiasedLockingRevocationPauseRule_RULE_NAME=Biased Locking Revocation Pauses
 87 BiasedLockingRevocationPauseRule_TEXT_INFO_LONG=To avoid this, either turn off biased Locking (&#39;-XX:-UseBiasedLocking&#39;) or, if this occurs during startup, delay the use of biased Locking (&#39;-XX:BiasedLockingStartupDelay&#39;).
 88 # {0} is a time period
 89 BiasedLockingRevocationPauseRule_TEXT_MESSAGE=The total time spent revoking biased locks was {0}.
 90 BiasedLockingRevocationPauseRule_TEXT_OK=No revocation of biased locks found.
 91 BufferLostRuleFactory_CONFIG_WARN_LIMIT=Buffer lost limit
 92 BufferLostRuleFactory_CONFIG_WARN_LIMIT_LONG=The number of lost buffer events needed to trigger a warning
 93 BufferLostRuleFactory_RULE_NAME=Lost Flight Recorder Buffers
 94 BufferLostRuleFactory_RULE_TEXT_OK=No Flight Recorder buffers were lost during the recording.
 95 # {0} is a number, {1} is a size in bytes
 96 BufferLostRuleFactory_TEXT_INFO={0} Flight Recorder event buffer(s) with a total size of {1} were lost.
 97 # {0} is a number, {1} is a size in bytes, {2} is a time stamp
 98 BufferLostRuleFactory_TEXT_INFO_LONG={0} Flight Recorder event buffer(s) were lost. The total size of the lost data was {1}, with the first lost buffer occurring at {2}. Buffers with events are dropped when there is an abnormally high pressure on the Flight Recorder. Avoid this by reducing the number of events recorded, especially for event types with high event rates and/or large payloads.
 99 ClassLeakingRule_CONFIG_WARNING_LIMIT=Warning limit
100 ClassLeakingRule_CONFIG_WARNING_LIMIT_LONG=Number of loads of a class to issue a warning.
101 ClassLeakingRule_NAME=Class Leak
102 ClassLeakingRule_TEXT_OK=No classes with identical names have been loaded more times than the limit.
103 # {0} is the class, {1} is the number of time it was loaded
104 ClassLeakingRule_TEXT_WARN=The difference between the number of times a class has been loaded and the number it has been unloaded, has exceeded the user specified limit. Most loaded: {0} ({1})
105 # {0} is the number of classes exceeding the limit
106 ClassLeakingRule_TEXT_WARN_LONG=Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak.&lt;p&gt;Top {0} loaded classes:&lt;/p&gt;
107 ClassLoadingRule_CONFIG_DURATION_LIMIT=Classloading duration limit
108 ClassLoadingRule_CONFIG_DURATION_LIMIT_LONG=The shortest classloading duration that should trigger a warning
109 ClassLoadingRule_CONFIG_RATIO_LIMIT=Classloading ratio limit
110 ClassLoadingRule_CONFIG_RATIO_LIMIT_LONG=The minimum ratio between time spent in classloading and the total duration of the recording
111 ClassLoadingRuleFactory_RULE_NAME=Class Loading Pressure
112 ClassLoadingRuleFactory_RULE_TEXT_OK=No significant time was spent loading new classes during this recording.
113 ClassLoadingRuleFactory_TEXT_INFO={0} was spent loading {1} new classes during this recording.
114 ClassLoadingRuleFactory_TEXT_INFO_LONG={0} was spent loading {1} new classes during this recording. The longest class loading event took {2}.&lt;p&gt;If the recording occurred during the warm-up phase of the application, this is to be expected. If not, it might be good to check why these classes were being loaded.
115 CodeCacheRuleFactory_DEFAULT_LONG_DESCRIPTION=If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. To avoid this, either increase the size of the code cache (&#39;-XX:ReservedCodeCacheSize&#39;) or increase the compilation threshold (&#39;-XX:CompileThreshold&#39;).
116 CodeCacheRuleFactory_JDK8_TEXT_WARN=The code cache was around {0} free during the recording. This could potentially become an issue.
117 CodeCacheRuleFactory_RULE_NAME=Code Cache
118 CodeCacheRuleFactory_BLOG_REFERENCE=See &lt;a href=&quot;https://blogs.oracle.com/poonam/why-do-i-get-message-codecache-is-full-compiler-has-been-disabled&quot;&gt;this blog post&lt;/a&gt; for a longer discussion on the code cache.
119 CodeCacheRuleFactory_SIZE_INFO_LIMIT=Code cache occupancy info limit
120 CodeCacheRuleFactory_SIZE_INFO_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return an Info result
121 CodeCacheRuleFactory_SIZE_WARN_LIMIT=Code cache occupancy warning limit
122 CodeCacheRuleFactory_SIZE_WARN_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return a Warning result
123 CodeCacheRuleFactory_TEXT_OK=No problems with the code cache were detected in the recording.
124 CodeCacheRuleFactory_TEXT_WARN=The code cache was filled during this recording.
125 CodeCacheRuleFactory_TEXT_WARN_LONG=This can happen if you have a lot of code in your application or if the code cache is too small. If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. Increase the size of the code cache with &#39;-XX:ReservedCodeCacheSize&#39;, for example &#39;-XX:ReservedCodeCacheSize=128M&#39;.
126 CodeCacheRuleFactory_WARN_LONG_DESCRIPTION=This causes the code cache to be swept more frequently, with even higher occupancy causing more frequent sweeps.
127 CodeCacheRuleFactory_WARN_SEGMENTED_HEAP_SHORT_DESCRIPTION=The {0} code heap reached more than 50 % occupancy during the recording.
128 CodeCacheRuleFactory_WARN_SEGMENTED_HEAPS_SHORT_DESCRIPTION=The {0} code heaps reached more than 50 % occupancy during the recording.
129 CompareCpuRule_RULE_NAME=Competing CPU Ratio Usage
130 CompareCpuRule_TEXT_INFO_LONG=The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.
131 CompareCpuRule_TEXT_TOO_FEW_SAMPLES=Not enough samples available to calculate result.
132 # {0} is a time period, {1} is a time stamp, {2} is a percentage
133 CompareCpuRule_TEXT_MESSAGE=An average CPU load of {2} was caused by other processes for {0} at {1}.
134 CompareCpuRule_INFO_LIMIT=Competing CPU Ratio usage info limit
135 CompareCpuRule_INFO_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger an info notice
136 CompareCpuRule_WARNING_LIMIT=Competing CPU Ratio usage warning limit
137 CompareCpuRule_WARNING_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger a warning
138 CompressedOopsRuleFactory_RULE_NAME=Compressed Oops
139 CompressedOopsRuleFactory_TEXT_INFO=The Java Heap Size is below 32 GB and Compressed Oops is turned off.
140 CompressedOopsRuleFactory_TEXT_INFO_LONG=Not using Compressed Ordinary Object Pointers when the heap size is below 32 GB wastes memory and will lead to unnecessary cache pressure. Use the JVM argument &#39;-XX:+UseCompressedOops&#39; to enable this feature.
141 CompressedOopsRuleFactory_TEXT_OK=The settings for Compressed Oops were OK.
142 ConcurrentFailedRuleFactory_TEXT_WARN=There occurred Concurrent Mode failures during certain garbage collections.
143 ConcurrentFailedRuleFactory_TEXT_WARN_LONG=Concurrent Mode failures means that the Garbage Collector hasn&#39;t been able to keep up with the Java Program. Try lowering the value of &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html&quot;&gt;-XX:InitiatingHeapOccupancyPercent&lt;/a&gt;.
144 ContextSwitchRule_AGGR_MAX_BLOCKS=Max Blocks
145 ContextSwitchRule_CONFIG_WARNING_LIMIT=Context switch rate warning limit
146 ContextSwitchRule_CONFIG_WARNING_LIMIT_LONG=The context switch rate (switches/second) needed to trigger a warning
147 ContextSwitchRuleFactory_RULE_NAME=Context Switches
148 ContextSwitchRuleFactory_TEXT_INFO=The program causes many context switches during the recording.
149 ContextSwitchRuleFactory_TEXT_INFO_LONG=The program context switched a lot and many threads waited on the same monitor. Consider using fewer threads, or decreasing lock contention by other means.
150 ContextSwitchRuleFactory_TEXT_OK=The program did not context switch excessively during the recording.
151 DMSIncidentRule_AGGR_INCIDENTS_COUNT=DMS Incidents
152 DMSIncidentRule_AGGR_INCIDENTS_COUNT_DESC=The number of DMS incidents
153 DMSIncidentRule_CONFIG_WARNING_LIMIT=DMS incident warning limit
154 DMSIncidentRule_CONFIG_WARNING_LIMIT_LONG=The number of DMS incidents needed to trigger a warning
155 DMSIncidentRuleFactory_RULE_NAME=DMS Incidents
156 DMSIncidentRuleFactory_TEXT_OK=No DMS Incidents were reported in the recording.
157 DMSIncidentRuleFactory_TEXT_WARN=There were reported DMS incidents.
158 # {0} is a number
159 DMSIncidentRuleFactory_TEXT_WARN_LONG=There are {0} reported DMS (Dynamic Monitoring Service) incidents.
160 DeprecatedGcRuleFactory_TEXT_WARN_PERMGEN_LONG=PermGen was removed in JDK 8, since Java users should not need to know up front how much memory to reserve for class metadata etc. Just like in the JRockit and J9 JVMs, native memory is now used for class metadata, and it will dynamically grow as needed. The equivalent of java.lang.OutOfMemoryError: PermGen will be much harder to provoke. To influence when to start attempting to reclaim metaspace memory, check out the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html&quot;&gt;MaxMetaspaceSize flag&lt;/a&gt;.
161 DumpReason_RULE_NAME=Exceptional Dump Reason
162 DumpReasonRule_TEXT_OK=This recording was not dumped for an exceptional reason.
163 DumpReasonRule_TEXT_INFO=This recording was dumped for an exceptional reason.
164 DumpReasonRule_TEXT_LONG_CRASH=Recording was dumped due to a JVM crash. Some events are likely missing from the end of the recording.
165 DumpReasonRule_TEXT_LONG_OOM=Recording was dumped due to an out of memory. Some events are likely missing from the end of the recording.
166 DumpReasonRule_TEXT_LONG_COREDUMP=Recording was extracted from a core dump.
167 DumpReasonRule_TEXT_INFO_UNKNOWN=This recording was dumped for an unknown, likely not exceptional, reason.
168 DumpReasonRule_TEXT_LONG_UNKNOWN=Recording was dumped for reason: {0}.
169 DumpReasonRule_CRASH_SCORE=Crash score
170 DumpReasonRule_CRASH_SCORE_LONG=Score for recording dumped due to crash
171 DumpReasonRule_OOM_SCORE=OOM score
172 DumpReasonRule_OOM_SCORE_LONG=Score for recording dumped due to out of memory
173 DumpReasonRule_COREDUMP_SCORE=Core dump score
174 DumpReasonRule_COREDUMP_SCORE_LONG=Score for recording extracted from core dump
175 DuplicateFlagsRuleFactory_RULE_NAME=Duplicated Flags
176 DuplicateFlagsRuleFactory_TEXT_OK=There were no duplicate JVM flags on the command line.
177 DuplicateFlagsRuleFactory_TEXT_WARN_SINGULAR=One JVM flag was duplicated.
178 # {0} is a number
179 DuplicateFlagsRuleFactory_TEXT_WARN=There were {0} JVM duplicated flags.
180 # {0} is an HTML list of duplicated JVM flags
181 DuplicateFlagsRuleFactory_TEXT_WARN_LONG=Duplicated JVM flags may be caused by multiple layers of scripts used when launching the application. Having duplicate flags is dangerous as changing one of the flags in one of the scripts may not have the intended effect. This can be especially dangerous for security related system properties. Try to find all the places where the flag is defined and keep only one. The following flags were duplicated: {0}
182 ErrorRule_CONFIG_INFO_LIMIT=Error rate info limit
183 ErrorRule_CONFIG_INFO_LIMIT_LONG=The number of error events per minute needed to trigger an info notice
184 ErrorRule_CONFIG_WARN_LIMIT=Error rate warning limit
185 ErrorRule_CONFIG_WARN_LIMIT_LONG=The number of error events per minute needed to trigger a warning
186 ErrorRule_CONFIG_EXCLUDED_ERRORS=Excluded error classes
187 ErrorRule_CONFIG_EXCLUDED_ERRORS_LONG=Regular expression describing which error classes to exclude, for example (com.sun.el.parser.ELParser\\$LookaheadSuccess|java.lang.NoSuchMethodError)
188 ErrorRule_CONFIG_WINDOW_SIZE=Sliding window size
189 ErrorRule_CONFIG_WINDOW_SIZE_LONG=The size of the sliding window used to find periods with many errors per minute.
190 ErrorRule_RULE_NAME=Thrown Errors
191 ErrorRule_TEXT_OK=The program did not generate any Errors.
192 # {0} is a number, {1} is a time range
193 ErrorRule_TEXT_WARN=The program generated an average of {0} errors per minute during {1}.
194 # {0} is a number, {1} is a time range, {2} is a number, {3} is an error class name, {4} is a number
195 ErrorRule_TEXT_WARN_LONG=The program generated an average of {0} errors per minute during {1}. {2} errors were thrown in total.&lt;p&gt;The most common error was &#39;&#39;{3}&#39;&#39;, which was thrown {4} times.&lt;p&gt;Investigate the thrown errors to see if they can be avoided. Errors indicate that something went wrong with the code execution and should never be used for flow control.
196 # {0} is a regexp exclude string, {1} is a number
197 ErrorRule_TEXT_WARN_EXCLUDED_INFO=The following regular expression was used to exclude {1} errors from this rule: &#39;&#39;{0}&#39;&#39;.
198 ExceptionRule_CONFIG_INFO_LIMIT=Exception rate info limit
199 ExceptionRule_CONFIG_INFO_LIMIT_LONG=The number of thrown exceptions per second needed to trigger an info notice
200 ExceptionRule_CONFIG_WARN_LIMIT=Exception rate warning limit
201 ExceptionRule_CONFIG_WARN_LIMIT_LONG=The number of thrown exceptions per second needed to trigger a warning
202 ExceptionRule_RULE_NAME=Thrown Exceptions
203 ExceptionRule_TEXT_INFO_LONG=Throwing exceptions is more expensive than normal code execution, which means that they should only be used for exceptional situations. Investigate the thrown exceptions to see if any of them can be avoided with a non-exceptional control flow.
204 # {0} is a time period, {1} is a time stamp, {2} is a number
205 ExceptionRule_TEXT_MESSAGE=The program generated {2} exceptions per second for {0} at {1}.
206 FatalErrorRule_RULE_NAME=Fatal Errors
207 FatalErrorRule_TEXT_OK=The JVM shut down in a normal way.
208 FatalErrorRule_TEXT_INFO=The JVM shut down due to there being no remaining non-daemon Java threads.
209 FatalErrorRule_TEXT_WARN=The JVM shut down due to a fatal error. This indicates that the program terminated in an abnormal way and should be investigated.
210 FasttimeRule_TEXT_WARN=This Flight Recording was made with a JVM with a bug in the Fast Time conversion.
211 FasttimeRule_TEXT_WARN_LONG=The timestamps in this recording are unreliable and may not represent the actual data properly or it may cause problems for JMC. Upgrade to Java 7u60 or later to resolve this issue.
212 FewSampledThreadsRule_AGGR_SAMPLES_PER_THREAD=Samples per thread
213 FewSampledThreadsRule_AGGR_SAMPLES_PER_THREAD_DESC=Samples per thread
214 # {0} is a percentage, {1} a time period, {2} a timestamp.
215 FewSampledThreadsRule_APPLICATION_IDLE=The application seems to be idle. JVM CPU usage was {0} % for {1} at {2}.
216 FewSampledThreadsRule_APPLICATION_IDLE_LONG=This may be caused by application latencies, see information from other rules, or it could be that the application is not doing anything.
217 FewSampledThreadsRule_CPU_WINDOW_SIZE=CPU window size
218 FewSampledThreadsRule_CPU_WINDOW_SIZE_LONG=Sliding window size used when calculating CPU usage.
219 FewSampledThreadsRule_MIN_CPU_RATIO=Min used CPU ratio
220 FewSampledThreadsRule_MIN_CPU_RATIO_LONG=The minimum used CPU ratio to consider this application not being idle.
221 FewSampledThreadsRule_MIN_SAMPLE_COUNT=Min total sample count
222 FewSampledThreadsRule_MIN_SAMPLE_COUNT_LONG=Minimum number of samples in recording for this rule to be applicable.
223 FewSampledThreadsRule_MIN_SAMPLE_COUNT_PER_THREAD=Min sample count per thread
224 FewSampledThreadsRule_MIN_SAMPLE_COUNT_PER_THREAD_LONG=Minimum number of samples in a thread to consider the thread as sampled.
225 FewSampledThreadsRule_SAMPLED_THREADS_RATIO_WARNING_LIMIT=Sampled threads ratio limit
226 FewSampledThreadsRule_SAMPLED_THREADS_RATIO_WARNING_LIMIT_LONG=Ratio between sampled threads and hardware threads needed to trigger a warning.
227 FewSampledThreadsRule_TEXT_OK=There were no problems with the amount of sampled threads.
228 FewSampledThreadsRule_TEXT_OK_LONG=There are more sampled threads than the amount of hardware threads. This indicates that the application has enough parallelism for the available hardware.
229 # {0} and {1} are numbers
230 FewSampledThreadsRule_TEXT_NOT_ENOUGH_SAMPLES=There are only {0} method profiling samples in the recording. This rule needs at least {1} samples to be useful.
231 FewSampledThreadsRule_RULE_NAME=Parallel Threads
232 FewSampledThreadsRule_TEXT_INFO=There are fewer sampled threads than the total number of hardware threads (cores).
233 # {0} is a count, {1} is a count, {2} is a count
234 FewSampledThreadsRule_TEXT_INFO_LONG={1} threads with at least {0} method samples were found, but the machine has {2} hardware threads (cores). The application might benefit from a higher level of parallelism. This could also be caused by threads doing something else than running Java code, for example running native code or spending time in the JVM internals.
235 FileReadRule_CONFIG_WARNING_LIMIT=File read duration warning limit
236 FileReadRule_CONFIG_WARNING_LIMIT_LONG=The shortest file read duration that should trigger a warning
237 FileReadRuleFactory_RULE_NAME=File Read Peak Duration
238 # {0} is a time period
239 FileReadRuleFactory_TEXT_OK=No long file read pauses were found in this recording (the longest was {0}).
240 FileReadRuleFactory_TEXT_NO_EVENTS=There are no file read events in this recording.
241 # {0} is a time period
242 FileReadRuleFactory_TEXT_WARN=There are long file read pauses in this recording (the longest is {0}).
243 # {0} is a time period, {1} is a time stamp, {2} is a size in bytes
244 FileReadRuleFactory_TEXT_WARN_LONG=The longest recorded file read took {0} to read {2} from {1}.
245 FileWriteRule_CONFIG_WARNING_LIMIT=File write duration warning limit
246 FileWriteRule_CONFIG_WARNING_LIMIT_LONG=The shortest file write duration that should trigger a warning
247 FileWriteRuleFactory_RULE_NAME=File Write Peak Duration
248 # {0} is a time period
249 FileWriteRuleFactory_TEXT_OK=No long file write pauses were found in this recording (the longest was {0}).
250 FileWriteRuleFactory_TEXT_NO_EVENTS=There are no file write events in this recording.
251 # {0} is a time period
252 FileWriteRuleFactory_TEXT_WARN=There are long file write pauses in this recording (the longest is {0}).
253 # {0} is a time period, {1} is a time stamp, {2} is a size in bytes
254 FileWriteRuleFactory_TEXT_WARN_LONG=The longest recorded file write took {0} to write {2} to {1}.
255 FlightRecordingSupportRule_RULE_NAME=Flight Recording Support
256 FlightRecordingSupportRule_TEXT_OK=The JVM version used for this recording has full Flight Recorder support.
257 FlightRecordingSupportRule_EA_TEXT_WARN_SHORT=The recording is from an early access build.
258 FlightRecordingSupportRule_EA_TEXT_WARN_LONG=This recording is from an early access build of the JRE ({0}). The automated analysis is not supported, and you may see errors when attempting to analyze the recording.
259 FlightRecordingSupportRule_NO_JVM_VERSION_EVENTS_TEXT=There were no VM information events with JVM version information recorded. Please turn on JVM information events to use this rule.
260 FlightRecordingSupportRule_UNSUPPORTED_TEXT_WARN_SHORT=The recording is from an unsupported JRE version.
261 FlightRecordingSupportRule_UNSUPPORTED_TEXT_WARN_LONG=This recording is from a runtime with JRE version {0}, before JDK Flight Recorder was fully supported in HotSpot. Versions before 7u40 only have partial support for flight recordings. The automated analysis is not supported, and you may see errors when attempting to analyze this recording.
262 
263 FullGcRule_RULE_NAME=G1/CMS Full Collection
264 FullGcRule_OTHER_COLLECTOR_IN_USE=This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.
265 FullGcRule_FULL_GC_OCCURRED_TITLE=Full GC detected.
266 FullGcRule_FULL_GC_OCCURRED_DESC=At least one Full, Stop-The-World Garbage Collection occurred during this recording. For the CMS and G1 collectors, Full GC events are a strong negative performance indicator. Tunable GC parameters can be used to allow the collector to operate in concurrent mode, avoiding Stop-The-World pauses and increasing GC and application performance.
267 FullGcRule_NO_FULL_GC_OCCURRED=No Stop-the-World, Full GC events detected.
268 
269 GcFreedRatioRule_RULE_NAME=GC Freed Ratio
270 GcFreedRatioRule_GC_FREED_RATIO_INFO_LIMIT=Memory freed per second compared to liveset size info limit
271 GcFreedRatioRule_GC_FREED_RATIO_INFO_LIMIT_DESC=Ratio between the amount of memory freed by garbage collections per second compared to the liveset needed to trigger an info notice.
272 GcFreedRatioRule_WINDOW_SIZE=Time window size
273 GcFreedRatioRule_WINDOW_SIZE_DESC=The time window size to use when evaluating the rule.
274 GcFreedRatioRule_FEW_GCS_LIMIT=Too few garbage collections limit
275 GcFreedRatioRule_FEW_GCS_LIMIT_DESC=Minimum number of garbage collections for rule calculations to be relevant.
276 # {0} is a count, # {1} is a count
277 GcFreedRatioRule_RESULT_FEW_GCS=Only {0} heap summary events were found, this rule requires at least {1} events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.
278 GcFreedRatioRule_RESULT_OK=This is likely a reasonable amount.
279 GcFreedRatioRule_RESULT_NOT_OK=This may be excessive.
280 # {0} is a number
281 GcFreedRatioRule_RESULT_SHORT_DESCRIPTION=The ratio between memory freed by garbage collections per second and liveset is {0}.
282 # {0} is a memory amount, {1} is a timespan, {2} is a timestamp, {3} is a number, {4} is a memory amount
283 GcFreedRatioRule_RESULT_LONG_DESCRIPTION={0} per second was freed by garbage collections for {1} at {2}. This is {3} times the average liveset which was {4}.
284 GcFreedRatioRule_RESULT_MORE_INFO=If the garbage collector can free a lot of memory, it may be because the application allocates a lot of short lived objects. Investigate the allocation stack traces to see which code paths cause the most allocations, and see if they can be reduced.
285 
286 GcPauseRatioRule_INFO_LIMIT=GC pause ratio info limit
287 GcPauseRatioRule_INFO_LIMIT_DESC=Ratio between GC pauses and execution time within a time window needed to trigger an info notice
288 GcPauseRatioRule_WARNING_LIMIT=GC pause ratio warning limit
289 GcPauseRatioRule_WARNING_LIMIT_DESC=Ratio between GC pauses and execution time within a time window needed to trigger a warning
290 GcPauseRatioRule_WINDOW_SIZE=GC pause time window size
291 GcPauseRatioRule_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
292 GcPauseRatioRule_RULE_NAME=GC Pauses
293 GcPauseRatioRule_RULE_TEXT=Application efficiency was affected by GC pauses.
294 # {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
295 GcPauseRatioRule_RULE_TEXT_LONG=The highest ratio between garbage collection pauses and execution time was {0} % for {1} at {2}. The garbage collection pause ratio of the entire recording was {3} %.
296 GcPauseRatioRule_RULE_TEXT_RECOMMENDATION=Pause times may be reduced by increasing the heap size or by trying to reduce allocation.
297 GcPauseRatioRule_RULE_TEXT_OK=Application efficiency was not highly affected by GC pauses.
298 
299 GcLockerRule_CONFIG_WARNING_LIMIT=GC locker ratio limit
300 GcLockerRule_CONFIG_WARNING_LIMIT_LONG=Warning limit ratio between number of garbage collections caused by GC locker and total garbage collections
301 GcLockerRule_TEXT_NA=No GC information events found.
302 GcLockerRuleFactory_RULE_NAME=GCs Caused by GC Locker
303 # {0} is a percentage
304 GcLockerRuleFactory_TEXT_INFO={0} of the garbage collections were affected by GC Locker.
305 GcLockerRuleFactory_TEXT_INFO_LONG=Garbage collections affected by GC Locker indicates that the runtime ran JNI code (using JNI Get*Critical) to (possibly) gain direct access to a string or an array. Some garbage collectors will need the object to be released before being able to proceed. If this becomes a big problem, either avoid relying on (JNI) code requiring this behavior or switch to a garbage collection algorithm which handles this more graciously (for example pinning the object or pinning the memory region wherein it is located).
306 GcLockerRuleFactory_TEXT_OK=No GCs were affected by the GC Locker.
307 GcStallRule_RULE_NAME=GC Stall
308 GcStallRule_TEXT_OK=No indications that the garbage collector could not keep up with the workload were detected.
309 General_CONFIG_CLASS_LIMIT=Class limit
310 General_CONFIG_CLASS_LIMIT_LONG=The maximum number of classes exceeding the Warning Limit to report.
311 General_NO_STACK_TRACE_AVAILABLE=&lt;p&gt;&amp;lt;No stack trace available&amp;gt;&lt;/p&gt;
312 General_RULE_REQUIRES_EVENTS_FROM_ONE_OF_MANY=This rule requires events to be available from one of the following event types: {0}.
313 General_TEXT_COULD_NOT_DETERMINE_JAVA_VERSION=The Java version could not be determined.
314 General_UNKNOWN_ADDRESS=&lt;Unknown Address&gt;
315 General_UNKNOWN_FILE_NAME=&lt;Unknown File&gt;
316 HeapContentRule_AGGR_CLASS_SCORE=Class Score
317 HeapContentRuleFactory_RULE_NAME=Heap Content
318 HeapContentRuleFactory_TEXT_INFO=Most of the heap was used by only a few classes.
319 HeapContentRuleFactory_TEXT_INFO_LONG=If the heap usage needs to be reduced, then this would be a good place to start.
320 HeapContentRuleFactory_TEXT_OK=No problems were found with the heap content.
321 HeapInspectionGcRuleFactory_RULE_NAME=GCs Caused by Heap Inspection
322 # {0} is a number
323 HeapInspectionGcRuleFactory_TEXT_INFO=The JVM performed {0} heap inspection garbage collections.
324 HeapInspectionGcRuleFactory_TEXT_INFO_LONG=Performing heap inspection garbage collections may be a problem since they usually take a lot of time.
325 HeapInspectionGcRuleFactory_TEXT_INFO_LONG_JFR=Some of these inspections were caused by the &#39;Object Count&#39; JFR event. It triggers a full garbage collection at the beginning and end of every recording where that event is enabled. If recordings are only made on demand or not too often, then these garbage collections are usually not a problem since the resulting pauses are not part of the normal application behavior. If recordings are collected often, for example by automatic scripts, or if the application is sensitive to pauses, then it might become an issue. In that case you can consider disabling the &#39;Object Count&#39; event.
326 HeapInspectionGcRuleFactory_TEXT_OK=The JVM did not perform any heap inspection GCs.
327 HeapInspectionGcRuleFactory_TEXT_OK_LONG=The JVM did not perform any heap inspection GCs. This is good since they usually take a lot of time.
328 HeapInspectionRule_CONFIG_WARNING_LIMIT=Heap inspection GC limit
329 HeapInspectionRule_CONFIG_WARNING_LIMIT_LONG=Warning limit ratio between number of heap inspection garbage collections and total garbage collections
330 HighGcRuleFactory_RULE_NAME=GC Pressure
331 # {0} is a time period, {1} is a time stamp, {2} is a percentage
332 HighGcRuleFactory_TEXT_INFO=The JVM was paused for {2} of the {0} at {1}.
333 HighGcRuleFactory_TEXT_INFO_LONG=The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.
334 HighGcRuleFactory_TEXT_OK=The runtime did not spend much time performing garbage collections.
335 HighJvmCpuRule_AGGR_MAX_ENDTIME=Max End Time
336 HighJvmCpuRule_AGGR_MIN_ENDTIME=Min End Time
337 HighJvmCpuRule_CONFIG_CPU_INFO_LIMIT=JVM CPU usage info limit
338 HighJvmCpuRule_CONFIG_CPU_INFO_LIMIT_LONG=The amount of CPU used by the JVM needed to trigger an info notice
339 HighJvmCpuRule_CONFIG_MIN_CPU_LIMIT_LONG=Minimum CPU load period to trigger a warning
340 HighJvmCpuRule_CONFIG_MIN_CPULOAD=Minimum CPU load period
341 HighJvmCpuRule_CONFIG_SAMPLE_LIMIT=Missing sample limit
342 HighJvmCpuRule_CONFIG_SAMPLE_LIMIT_LONG=Minimum missing samples to trigger a warning
343 HighJvmCpuRule_FEW_SAMPLES=This recording contains few profiling samples even though the CPU load is high.
344 HighJvmCpuRule_FEW_SAMPLES_LONG=The profiling data is thus likely not relevant. This might be because the application is running a lot JNI code or that the JVM is spending a lot of time in GC, class loading, JIT compilation etc.
345 HighJvmCpuRule_LONG_CPU_LOAD_PERIOD=This recording has a high sampling period for &#39;CPU Load&#39; events.
346 # {0} is a time period
347 HighJvmCpuRule_LONG_CPU_LOAD_PERIOD_LONG=The sampling period for the &#39;&#39;CPU Load&#39;&#39; events was set to {0}, which is too high for CPU load related rules to work.
348 HighJvmCpuRule_RULE_NAME=High JVM CPU Load
349 HighJvmCpuRule_TEXT_OK=The JVM does not seem to cause a lot of CPU load.
350 HighJvmCpuRule_TEXT_WARN=The JVM loads the CPU a lot.
351 HotMethodsRuleFactory_NOT_ENOUGH_SAMPLES=Could not extract enough execution samples to calculate a score. Try generating more samples, either by increasing the load on your application, lowering the sample period, or extending the recording time.
352 # {0} is a method name, {1} is a percentage, {2} is a duration of time
353 HotMethodsRuleFactory_TEXT_INFO=The most sampled method was {0}, with {1} of the maximum possible samples for {2}, and {3} of the actual samples.
354 # {0} is a list of method names with a percentage and a timespan, {1} is the hottest stack trace
355 HotMethodsRuleFactory_TEXT_INFO_LONG=The methods that used the most CPU are: {0}&lt;p&gt;Consider optimizing their code.&lt;p&gt; The most common stack trace was: {1}
356 HotMethodsRuleFactory_TEXT_OK=No methods where optimization would be particularly efficient could be detected.
357 IgnoreUnrecognizedVMOptionsRuleFactory_TEXT_INFO=The JVM ignored unrecognized VM options.
358 IgnoreUnrecognizedVMOptionsRuleFactory_TEXT_INFO_LONG=The recording was performed on a JVM that ignored unrecognized VM options, which means that no checking was done on the presence of invalid VM flags. This means that there may be some VM behavior that you think is configured but which is not. This can be because the running VM does not support it, or because the option is misspelled. Unless it is necessary, avoid the &#39;-XX:+IgnoreUnrecognizedVMOptions&#39; command line option.
359 # {0} is an object type with a field name, {1} is a number, {2} is another object type with a field name
360 IncreasingLiveSetRule_LOADED_CLASSES_PERCENT=Classes Loaded
361 IncreasingLiveSetRule_LOADED_CLASSES_PERCENT_DESC=The percentage of loaded classes which indicates that the warm up phase has completed. The rule ignores allocations made before this amount of classes have been loaded.
362 IncreasingLiveSetRule_TEXT_INFO_BALANCED=There is no particular class that seems to be leaking more than any other.
363 IncreasingLiveSetRule_TEXT_INFO_LONG=Perform a dump with the &#39;Trace Paths to GC Roots&#39; option enabled to enable a more detailed analysis of the potential memory leak.
364 # {0} is a timestamp
365 IncreasingLiveSetRule_TEXT_INFO_NO_CANDIDATES=Did not find any memory leaks. This may be because all potential candidates are below the configured thresholds. It may also be a false positive due to long-lived allocations occurring after {0}, which is when the rule assumed the application would not allocate large long-lived objects anymore.
366 IncreasingLiveSetRule_TEXT_INFO_UNBALANCED=There are some classes that seem to leak more than other classes.
367 IncreasingLiveSetRule_TEXT_OK=No memory leaks were detected.
368 IncreasingLiveSetRule_RELEVANCE_THRESHOLD=Leak Candidate Relevance Threshold
369 IncreasingLiveSetRule_RELEVANCE_THRESHOLD_DESC=The calculated relevance threshold to use when determining whether or not a live object is to be considered a memory leak.
370 IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD=Young Collection Threshold
371 IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD_DESC=The minimum number of young collections needed in order to evaluate a live set trend.
372 IncreasingLiveSetRule_CANDIDATE_REFERRED_BY=The candidate is referenced by this chain.
373 IncreasingLiveSetRule_ELLIPSIS=...
374 # {0} is a number
375 IncreasingLiveSetRule_LEAK_CANDIDATES=An analysis of the reference tree found {0} leak candidates.
376 IncreasingLiveSetRuleFactory_RULE_NAME=Heap Live Set Trend
377 # {0} is a number denoted in Mebibytes per second
378 IncreasingLiveSetRuleFactory_TEXT_INFO=The live set on the heap seems to increase with a speed of about {0} per second during the recording.
379 IncreasingLiveSetRuleFactory_TEXT_INFO_LONG=This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began {0} after the JVM was started. More information can be gathered by using the &#39;Old Object Sample&#39; event, if available.
380 IncreasingMetaspaceLiveSetRuleFactory_RULE_NAME=Metaspace Live Set Trend
381 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO=The class data seems to increase constantly in the metaspace during the recording.
382 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO_LONG=This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.
383 IncreasingMetaspaceLiveSetRuleFactory_TEXT_OK=The class data does not seem to increase during the recording.
384 JavaBlocking_RULE_NAME=Java Blocking
385 JavaBlockingRule_AGGR_BALANCE_BY_INSTANCE=By Instance
386 JavaBlockingRule_AGGR_BALANCE_BY_THREAD=By Thread
387 JavaBlockingRule_CONFIG_EXCLUDED_THREADS=Java blocked excluded thread names
388 JavaBlockingRule_CONFIG_EXCLUDED_THREADS_LONG=Regular expression describing which thread names to exclude, for example &#39;(.*weblogic\\.socket\\.Muxer.*|MyExcludedThreadName)&#39;
389 # {0} is a regexp exclude string
390 JavaBlockingRule_TEXT_EXCLUDED_THREADS=The following regular expression was used to exclude threads from this rule: &#39;&#39;{0}&#39;&#39;
391 # {0} is a time period
392 JavaBlockingRule_TEXT_INFO=Threads in the application were blocked on locks for a total of {0}.
393 JavaBlockingRule_TEXT_MESSAGE=No excessive problems with lock contention found.
394 # {0} is a class name, {1} is a number, {2} is a time period
395 JavaBlockingRule_TEXT_MOST_BLOCKED_CLASS=The most blocking monitor class was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.
396 # {0} is a thread name, {1} is a number, {2} is a time period
397 JavaBlockingRule_TEXT_MOST_BLOCKED_THREAD=The most blocking thread was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.
398 JavaBlockingRule_TEXT_OK=No problems with lock contention were found.
399 LongGcPauseRuleFactory_RULE_NAME=GC Pause Peak Duration
400 # {0} is a time period
401 LongGcPauseRuleFactory_TEXT_INFO=The longest GC pause was {0}.
402 LongGcPauseRuleFactory_TEXT_INFO_G1=You may want to use the G1 garbage collector which is built to reduce garbage collector pauses. To enable G1, add &#39;-XX:+UseG1GC&#39; to the command line.
403 # {0} is a size in bytes, {1} is a size in bytes
404 LongGcPauseRuleFactory_TEXT_INFO_MX=The application ran with a live set of {0} and a heap size of {1}. Decreasing the heap size may decrease the garbage collection pause times.
405 LongGcPauseRuleFactory_TEXT_INFO_REFERENCES=Processing reference objects was a considerable part of the garbage collector pauses. You may be able to decrease this by reducing the amount of references or by enabling parallel reference processing with &#39;-XX:+ParallelRefProcEnabled&#39;.
406 LongGcPauseRuleFactory_TEXT_OK=The application did not cause any long GC pause times.
407 LongGcPauseRule_CONFIG_INFO_LIMIT=GC pause warning limit
408 LongGcPauseRule_CONFIG_INFO_LIMIT_LONG=The GC pause time needed to trigger a warning
409 LowOnPhysicalMemoryFactory_RULE_NAME=Free Physical Memory
410 # {0} is a percentage
411 LowOnPhysicalMemoryFactory_TEXT_INFO=The maximum amount of used memory was {0} of the physical memory available.
412 # {0} is a size in bytes, {1} is a percentage, {2} is a size in bytes
413 LowOnPhysicalMemoryFactory_TEXT_INFO_LONG=The maximum amount of memory used was {0}. This is {1} of the {2} of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.
414 LowOnPhysicalMemoryFactory_TEXT_OK=The system did not run low on physical memory during this recording.
415 ManagementAgentRule_TEXT_INFO=Management agent settings (port, authentication and/or SSL) were changed during runtime.
416 ManagementAgentRule_TEXT_INFO_LONG=Management agent settings (port, authentication and/or SSL) were changed during runtime, this is not likely to have had any effect, but could be useful to investigate.
417 ManagmentAgentRuleFactory_RULE_NAME=Discouraged Management Agent Settings
418 ManagmentAgentRuleFactory_TEXT_INFO_SSL_DISABLED=Insecure management agent settings: SSL disabled.
419 ManagmentAgentRuleFactory_TEXT_INFO_SSL_DISABLED_LONG=The runtime management agent settings were insecure. SSL/TLS was disabled. This is discouraged in production systems, since the traffic will not be secure.
420 ManagmentAgentRuleFactory_TEXT_OK=No problems were found with the management agent settings.
421 ManagmentAgentRuleFactory_TEXT_WARN_AUTH_DISABLED=Insecure management agent settings: Password authentication disabled.
422 ManagmentAgentRuleFactory_TEXT_WARN_AUTH_DISABLED_LONG=The runtime management agent settings were insecure. Password authentication was disabled. A remote user who knows (or guesses) the port number and host name will be able to monitor and control the Java application and platform. This is highly discouraged for production systems.
423 ManagmentAgentRuleFactory_TEXT_WARN_BOTH_DISABLED=Insecure management agent settings: Both password authentication and SSL were disabled.
424 ManagmentAgentRuleFactory_TEXT_WARN_BOTH_DISABLED_LONG=The runtime management agent settings were insecure. Both password authentication and SSL were disabled. A remote user who knows (or guesses) the port number and host name will be able to monitor and control the Java application and platform. This is highly discouraged for production systems.
425 ManagmentAgentRuleFactory_TEXT_WARN_CONFIGURE_GUIDE=See the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html&quot;&gt;Java Monitoring and Management Guide&lt;/a&gt; for more information about how to configure the management agent.
426 ManyRunningProcessesRule_RULE_NAME=Competing Processes
427 # {0} is a number, {1} is a time stamp
428 ManyRunningProcessesRule_TEXT_INFO={0} processes were running while this Flight Recording was made.
429 # {0} is a number, {1} is a time stamp
430 ManyRunningProcessesRule_TEXT_INFO_LONG=At {1}, a total of {0} other processes were running on the host machine that this Flight Recording was made on.
431 ManyRunningProcessesRule_TEXT_RECOMMENDATION=If this is a server environment, it may be good to only run other critical processes on that machine.
432 ManyRunningProcessesRule_INFO_LIMIT=Competing processes limit
433 ManyRunningProcessesRule_INFO_LIMIT_LONG=The number of simultaneous processes needed to trigger an info notice
434 MetaspaceOomRuleFactory_RULE_NAME=Metaspace Out of Memory
435 MetaspaceOomRuleFactory_TEXT_OK=The metaspace was not exhausted during this recording.
436 # {0} is a number
437 MetaspaceOomRuleFactory_TEXT_WARN={0} &#39;&#39;Out of Metaspace Memory&#39;&#39; events are present in this recording.
438 MetaspaceOomRuleFactory_TEXT_WARN_LONG=Increase or remove the &#39;-XX:MaxMetaSpaceSize&#39; flag or investigate why classes are not unloaded properly.
439 MethodProfilingDataProvider_AGGR_AGGR_TOP_FRAME_QUOTA=Top Frame Quota
440 MethodProfilingDataProvider_AGGR_AGGR_TOP_FRAME_QUOTA_DESC=The quota between the top frame and the total samples count
441 MethodProfilingDataProvider_AGGR_MAX_ENDTIME=Max End Time
442 MethodProfilingDataProvider_AGGR_MIN_ENDTIME=Min End Time
443 MethodProfilingDataProvider_AGGR_TOP_FRAME_BALANCE=Top Frame Balance
444 MethodProfilingDataProvider_AGGR_TOP_FRAME_BALANCE_DESC=The relative balance between stacktrace top frames
445 MethodProfilingRule_RULE_NAME=Method Profiling
446 MethodProfilingRule_WINDOW_SIZE=Method profiling window size
447 MethodProfilingRule_WINDOW_SIZE_DESC=The size of the sliding window to use for evaluating the method profiling samples in this recording. If the evaluation of this rule takes a long time, consider increasing this parameter. Note an increased window size may reduce the accuracy of the rule.
448 MethodProfilingRule_EXCLUDED_PACKAGES=Packages to exclude from the stack trace
449 MethodProfilingRule_EXCLUDED_PACKAGES_DESC=The packages to exclude when traversing stack traces. Drop all frames matching the pattern until reaching the first frame not belonging to either. Count the first encountered frame instead as the hot one.
450 # {0} is a number, {1} is a number
451 NumberOfGcThreadsRuleFactory_TEXT_INFO=The runtime used {0} GC threads on a machine with {1} CPU cores.
452 NumberOfGcThreadsRuleFactory_TEXT_INFO_LONG=It&#39;s suboptimal to use more GC threads than available cores. Removing the &#39;-XX:ParallelGCThreads&#39; flag will allow the JVM to set the number of GC threads automatically.
453 ObjectStatisticsDataProvider_AGGR_LIVE_SIZE_INCREASE=Live Size Increase
454 ObjectStatisticsDataProvider_AGGR_LIVE_SIZE_INCREASE_DESC=The difference in total size from after the first garbage collection to after the last
455 OptionsCheckRule_CONFIG_ACCEPTED_OPTIONS=Accepted Options
456 OptionsCheckRule_CONFIG_ACCEPTED_OPTIONS_LONG=The -XX (non validated) JVM option names in this comma separated list will not be checked by the rule
457 OptionsCheckRule_RULE_NAME=Command Line Options Check
458 # {0} is a Java version string
459 OptionsCheckRule_TEXT_DEPRECATED=Deprecated in Java {0}.
460 # {0} is a Java version string, {1} is a Java version string
461 OptionsCheckRule_TEXT_DEPRECATED_IGNORED=Deprecated in Java {0} and ignored in Java {1}.
462 # {0} is a Java version string, {1} is a Java version string, {2} is a Java version string
463 OptionsCheckRule_TEXT_DEPRECATED_IGNORED_REMOVED=Deprecated in Java {0}, ignored in Java {1}, and removed in Java {2}.
464 # {0} is a Java version string, {1} is a Java version string
465 OptionsCheckRule_TEXT_DEPRECATED_REMOVED=Deprecated in Java {0} and removed in Java {1}.
466 OptionsCheckRule_TEXT_DEPRECATED_WARNING=Deprecated option flags should be avoided. In some cases they enable legacy code and in other cases they are ignored completely. They will usually be removed in a later Java release.
467 # {0} is a Java version string
468 OptionsCheckRule_TEXT_IGNORED=Ignored in Java {0}.
469 # {0} is a Java version string, {1} is a Java version string
470 OptionsCheckRule_TEXT_IGNORED_REMOVED=Ignored in Java {0} and removed in Java {1}.
471 OptionsCheckRule_TEXT_NA=No events with JVM arguments were recorded.
472 OptionsCheckRule_TEXT_OK=No undocumented, deprecated or non-recommended option flags were detected.
473 OptionsCheckRule_TEXT_UNDOC_DEPR_NOTREC=Undocumented, deprecated and non-recommended option flags were detected.
474 OptionsCheckRule_TEXT_UNDOC_DEPR=Undocumented and deprecated option flags were detected.
475 OptionsCheckRule_TEXT_UNDOC_NOTREC=Undocumented and non-recommended option flags were detected.
476 OptionsCheckRule_TEXT_DEPR_NOTREC=Deprecated and non-recommended option flags were detected.
477 OptionsCheckRule_TEXT_UNDOC=Undocumented option flags were detected.
478 OptionsCheckRule_TEXT_DEPR=Deprecated option flags were detected.
479 OptionsCheckRule_TEXT_NOTREC=Non-recommended option flags were detected.
480 OptionsCheckRule_TEXT_GENERAL_PROBLEM=Option flag problems were detected.
481 OptionsCheckRule_TEXT_OPTION_DEPRECATED=The following option flag is or will be deprecated.
482 OptionsCheckRule_TEXT_OPTION_NOT_DOCUMENTED=The following option flag is not documented.
483 OptionsCheckRule_TEXT_OPTION_NOT_RECOMMENDED=The following option flag is not recommended.
484 OptionsCheckRule_TEXT_OPTIONS_DEPRECATED=The following option flags are or will be deprecated.
485 OptionsCheckRule_TEXT_OPTIONS_NOT_DOCUMENTED=The following option flags are not documented.
486 OptionsCheckRule_TEXT_OPTIONS_NOT_RECOMMENDED=The following option flags are not recommended.
487 # {0} is a Java version string
488 OptionsCheckRule_TEXT_REMOVED=Removed in Java {0}.
489 OptionsCheckRule_TEXT_UNDOCUMENTED_WARNING=Undocumented flags may affect the JVM in ways that are not immediately obvious and may also be removed in future releases without warning.
490 OptionsCheckRule_TEXT_USE_MAXRAMFRACTION=Use MaxRAMFraction instead
491 OverAggressiveRecordingSettingRuleFactory_RULE_NAME=Discouraged Recording Settings
492 OverAggressiveRecordingSettingRuleFactory_RULE_TEXT_OK=No problems were found with the recording settings.
493 OverAggressiveRecordingSettingRuleFactory_TEXT_INFO=These following event types had no threshold: {0}.
494 # {0} is a list of event type names
495 OverAggressiveRecordingSettingRuleFactory_TEXT_INFO_LONG=Event types without threshold can lead to quite a lot of events being generated, possibly translating to higher overhead. If this was not intended, please check the settings in the template for future recordings.
496 ParGcFewThreadsRuleFactory_TEXT_INFO=The JVM ran with a parallel GC but with only one GC thread.
497 ParGcFewThreadsRuleFactory_TEXT_INFO_LONG=The JVM ran with a parallel GC but with only one GC thread. This is not optimal. To change number of GC threads, use the command line flag &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html&quot;&gt;-XX:ParallelGCThreads=X&lt;/a&gt;. When run without the &#39;-XX:ParallelGCThreads&#39; flag, the JVM will use a suitable number of GC threads automatically.
498 ParallelOnSingleCpuRuleFactory_TEXT_INFO=The runtime used a parallel GC on a single-core machine.
499 ParallelOnSingleCpuRuleFactory_TEXT_INFO_LONG=The runtime used a parallel GC on a single-core machine. This is not optimal. Use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html&quot;&gt;Serial Collector&lt;/a&gt; instead, which is optimized for single-core machines.
500 VerifyNoneRule_WLS_TEXT_INFO=The application ran WebLogic Server with bytecode verification disabled.
501 VerifyNoneRule_WLS_TEXT_INFO_LONG=The application ran WebLogic Server with bytecode verification disabled. While not generally recommended, it is considered OK for WLS.
502 VerifyNoneRule_TEXT_INFO=The application ran with bytecode verification disabled.
503 VerifyNoneRule_TEXT_INFO_LONG=The application ran with bytecode verification disabled. Disabling bytecode verification is unsafe and should not be done in a production system. If it is not necessary for the application, then don&#39;t use &#39;-Xverify:none&#39; or &#39;-noverify&#39; on the command line. See the &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/java/ENV04-J.+Do+not+disable+bytecode+verification&quot;&gt;Secure Coding Standard for Java&lt;/a&gt;.
504 VerifyNoneRule_RULE_NAME=Bytecode Verification
505 VerifyNoneRule_TEXT_OK=The application ran with bytecode verification enabled.
506 DebugNonSafepointsRule_RULE_NAME=DebugNonSafepoints
507 DebugNonSafepointsRule_DISABLED_TEXT_INFO=DebugNonSafepoints was explicitly disabled.
508 DebugNonSafepointsRule_NOT_ENABLED_TEXT_INFO=DebugNonSafepoints was not enabled.
509 DebugNonSafepointsRule_NOT_ENABLED_TEXT_INFO_LONG=If DebugNonSafepoints is not enabled, the method profiling data will be less accurate as threads that are not at safepoints will not be correctly sampled. Use the following JVM flags to enable this: &#39;-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints&#39;. There is a slight performance overhead when enabling these flags. For more information see &lt;a href=&quot;http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Thread%20Management|outline&quot;&gt;HotSpot Runtime Overview/Thread Management&lt;/a&gt;.
510 DebugNonSafepointsRule_TEXT_OK=DebugNonSafepoints was explicitly enabled.
511 DebugNonSafepointsRule_IMPLICIT_TEXT_OK=DebugNonSafepoints was implicitly enabled in the JVM version used to create this recording.
512 DiscouragedGcOptionsRule_RULE_NAME=GC Setup
513 DiscouragedGcOptionsRule_TEXT_OK=No problems were found with the GC configuration.
514 DiscouragedVmOptionsRule_RULE_NAME=Discouraged VM Options
515 DiscouragedVmOptionsRule_TEXT_OK=No problems were found with the VM options.
516 DiscouragedVmOptionsRule_BOTH_EXPERIMENTAL_AND_IGNORE=The recording was performed on a JVM that both had Experimental VM Options enabled and which ignored unrecognized VM options.
517 PasswordsInArgsRule_JAVAARGS_TEXT_INFO=The application arguments in the recording may contain passwords.
518 # {0} is a list of argument strings
519 PasswordsInArgsRule_JAVAARGS_TEXT_INFO_LONG=The following suspicious application arguments were found in this recording: {0}&lt;p&gt;They may contain passwords. If you do not want to have your passwords directly as arguments to the Java process, there are usually other means to provide them to your software. If you wish to keep using passwords as arguments, but want to be able to share recordings without also sharing the passwords, please disable the &#39;&#39;JVM Information&#39;&#39; event. Note that disabling the &#39;&#39;JVM Information&#39;&#39; event can limit functionality in the Flight Recorder automated analysis.
520 PasswordsInArgsRule_RULE_NAME=Passwords in Java Arguments
521 PasswordsInArgsRule_TEXT_OK=The recording does not seem to contain passwords in the application arguments.
522 PasswordsInEnvironmentRuleFactory_RULE_NAME=Passwords in Environment Variables
523 PasswordsInEnvironmentRuleFactory_TEXT_INFO=The environment variables in the recording may contain passwords.
524 # {0} is a list of environment variable names
525 PasswordsInEnvironmentRuleFactory_TEXT_INFO_LONG=The following suspicious environment variables were found in this recording: {0}&lt;p&gt;They may contain passwords. If you wish to keep having passwords in your environment variables, but want to be able to share recordings without also sharing the passwords, please disable the &#39;&#39;Initial Environment Variable&#39;&#39; event.
526 PasswordsInEnvironmentRuleFactory_TEXT_OK=The recording does not seem to contain passwords in the environment variables.
527 PasswordsInSystemPropertiesRule_RULE_NAME=Passwords in System Properties
528 PasswordsInSystemPropertiesRule_TEXT_INFO=The system properties in the recording may contain passwords.
529 # {0} is a list of system property names
530 PasswordsInSystemPropertiesRule_TEXT_INFO_LONG=The following suspicious system properties were found in this recording: {0}&lt;p&gt;They may contain passwords. If you wish to keep having passwords in your system properties, but want to be able to share recordings without also sharing the passwords, please disable the &#39;&#39;Initial System Property&#39;&#39; event.
531 PasswordsInSystemPropertiesRule_TEXT_OK=The recording does not seem to contain passwords in the system properties.
532 ReferenceStatisticsType_FINAL_REFERENCES=Final References
533 ReferenceStatisticsType_PHANTOM_REFERENCES=Phantom References
534 ReferenceStatisticsType_SOFT_REFERENCES=Soft References
535 ReferenceStatisticsType_WEAK_REFERENCES=Weak References
536 SerialGcOnMultiCpuRuleFactory_TEXT_INFO=The Serial collector was used on a multi-core machine.
537 SerialGcOnMultiCpuRuleFactory_TEXT_INFO_LONG=The JVM used the Serial GC even though it ran on a multi-core machine. Using Concurrent Mark Sweep, G1 or the Parallel GC instead may yield improved GC performance.
538 SerialOldRuleFactory_TEXT_WARN_CMS=The CMS garbage collector was used, but the JVM had to revert to do a Serial Old Collection.
539 SerialOldRuleFactory_TEXT_WARN_CMS_LONG=The application used the Concurrent Mark Sweep garbage collector, but the JVM had to revert to a Serial Old Collection, which takes more time. This is because the Concurrent Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html&quot;&gt;-XX:CMSInitiatingOccupancyFraction&lt;/a&gt;.
540 SerialOldRuleFactory_TEXT_WARN_G1=The G1 garbage collector was used, but the JVM had to revert to do a Serial Old Collection.
541 SerialOldRuleFactory_TEXT_WARN_G1_LONG=The JVM used the G1 garbage collector, but had to revert to a Serial Old Collection, which takes more time. This is because the G1 Collector could not keep up with the object allocations that happened during the collection. You can decrease the risk of this by lowering the value of &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html&quot;&gt;-XX:InitiatingHeapOccupancyPercent&lt;/a&gt;. This &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&quot;&gt;G1 tuning article&lt;/a&gt; may prove helpful.
542 SocketReadRule_CONFIG_INFO_LIMIT=Socket read duration info limit
543 SocketReadRule_CONFIG_INFO_LIMIT_LONG=The shortest socket read duration that should trigger an info notice
544 SocketReadRule_CONFIG_WARNING_LIMIT=Socket read duration warning limit
545 SocketReadRule_CONFIG_WARNING_LIMIT_LONG=The shortest socket read duration that should trigger a warning
546 SocketReadRuleFactory_RULE_NAME=Socket Read Peak Duration
547 # {0} is a time period
548 SocketReadRuleFactory_TEXT_OK=No long socket read pauses were found in this recording (the longest was {0}).
549 SocketReadRuleFactory_TEXT_NO_EVENTS=There are no socket read events in this recording.
550 SocketReadRuleFactory_TEXT_RMI_NOTE=Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.
551 # {0} is a time period
552 SocketReadRuleFactory_TEXT_WARN=There are long socket read pauses in this recording (the longest is {0}).
553 # {0} is a time period, {1} is a host name, {2} is a size in bytes
554 SocketReadRuleFactory_TEXT_WARN_LONG=The longest recorded socket read took {0} to read {2} from the host at {1}.
555 SocketWriteRule_CONFIG_INFO_LIMIT=Socket write duration info limit
556 SocketWriteRule_CONFIG_INFO_LIMIT_LONG=The shortest socket write duration that should trigger an info notice
557 SocketWriteRule_CONFIG_WARNING_LIMIT=Socket write duration warning limit
558 SocketWriteRule_CONFIG_WARNING_LIMIT_LONG=The shortest socket write duration that should trigger a warning
559 SocketWriteRuleFactory_RULE_NAME=Socket Write Peak Duration
560 # {0} is a time period
561 SocketWriteRuleFactory_TEXT_OK=No long socket write pauses were found in this recording (the longest was {0}).
562 SocketWriteRuleFactory_TEXT_NO_EVENTS=There are no socket write events in this recording.
563 SocketWriteRuleFactory_TEXT_RMI_NOTE=Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.
564 # {0} is a time period
565 SocketWriteRuleFactory_TEXT_WARN=There are long socket write pauses in this recording (the longest is {0}).
566 # {0} is a time period, {1} is a host name, {2} is a size in bytes
567 SocketWriteRuleFactory_TEXT_WARN_LONG=The longest recorded socket write took {0} to write {2} to the host at {1}.
568 StackdepthSettingRule_RULE_NAME=Stackdepth Setting
569 StackdepthSettingRule_TEXT_INFO=Some stack traces were truncated in this recording.
570 # {0} is a number, {1} is an empty String or StackdepthSettingRule_TEXT_INFO_LONG_DEFAULT, {2} is a percentage, {3} is an HTML list of event type names
571 StackdepthSettingRule_TEXT_INFO_LONG=The Flight Recorder is configured with a maximum captured stack depth of {0}. {1}{2} of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the &#39;&#39;-XX:FlightRecorderOptions=stackdepth=&amp;lt;value&amp;gt;&#39;&#39; value.&lt;p&gt;Events of the following types have truncated stack traces:&lt;ul&gt;{3}&lt;/ul&gt;
572 StackdepthSettingRule_TEXT_INFO_LONG_DEFAULT=This is the default depth.
573 StackdepthSettingRule_TEXT_NA=No events with stack traces were recorded.
574 StackdepthSettingRule_TEXT_OK=No stack traces were truncated in this recording.
575 # {0} is an event type name, {1} is a percentage, this is a template that is reused inside &lt;li&gt; tags in the StackdepthSettingRule_TEXT_INFO_LONG {1} parameter
576 StackdepthSettingRule_TYPE_LIST_TEMPLATE={0} ({1} truncated traces)
577 
578 StringDeduplicationRule_RULE_NAME=String Deduplication
579 StringDeduplicationRule_STRING_ARRAY_ALLOCATION_FRAMES=String internal array allocation frames
580 StringDeduplicationRule_STRING_ARRAY_ALLOCATION_FRAMES_DESC=Comma separated list of frames where the string internal char/byte arrays are allocated.
581 StringDeduplicationRule_STRING_ARRAY_LIVESET_RATIO_AND_HEAP_USAGE_LIMIT=Heap usage + String internal array live set ratio info limit
582 StringDeduplicationRule_STRING_ARRAY_LIVESET_RATIO_AND_HEAP_USAGE_LIMIT_DESC=If the heap usage ratio plus the ratio of the string internal char/byte arrays to total liveset exceeds this limit, then an info notice will be triggered.
583 StringDeduplicationRule_STRING_ARRAY_ALLOCATION_RATIO_AND_HEAP_USAGE_LIMIT=Heap usage + String internal array allocation info limit
584 StringDeduplicationRule_STRING_ARRAY_ALLOCATION_RATIO_AND_HEAP_USAGE_LIMIT_DESC=If the heap usage ratio plus the ratio of the allocated string internal char/byte arrays to total allocation exceeds this limit, then an info notice will be triggered.
585 StringDeduplicationRule_RESULT_USE_STRING_DEDUPLICATION_ENABLED=String deduplication is already enabled.
<a name="1" id="anc1"></a><span class="line-modified">586 StringDeduplicationRule_RESULT_GC_LONG=String deduplication is only supported when using the G1 (JDK 8u20+) or Shenandoah garbage collectors. If you want to use this feature you can enable G1 by using &#39;-XX:+UseG1GC&#39;, or enable Shenandoah by using &#39;-XX:+UseShenandoahGC&#39;.</span>

587 StringDeduplicationRule_RESULT_DONT_RECOMMEND_STRING_DEDUPLICATION=There is likely no big benefit from enabling string deduplication.
588 StringDeduplicationRule_RESULT_RECOMMEND_STRING_DEDUPLICATION=Your application might benefit from enabling string deduplication.
589 # {0} is an event type, # {1} is an event type
590 StringDeduplicationRule_RESULT_NO_MAX_HEAP_INFO=No information available about the maximum heap size, enable event type {0} or {1} to improve the accuracy of this rule.
591 StringDeduplicationRule_RESULT_NO_ALLOC_ITEMS=Found no allocation events for the internal arrays in strings. Either the frame filter preference is incorrectly defined, or the stackTrace attribute is not enabled for the allocation events.
592 # {0} is a percentage
593 StringDeduplicationRule_RESULT_HEAP_USAGE=The heap is around {0} % full.
594 # {0} is a percentage, {1} is either &#39;byte[]&#39; or &#39;char[]&#39;
595 StringDeduplicationRule_RESULT_STRING_ARRAY_LIVESET_RATIO=Approximately {0} % of the live set consists of the internal array type of strings (&#39;&#39;{1}&#39;&#39; for this JDK version).
596 # {0} is a percentage, {1} is either &#39;byte[]&#39; or &#39;char[]&#39;
597 StringDeduplicationRule_RESULT_STRING_ARRAY_ALLOCATION_RATIO=Approximately {0} % of all allocations were of internal arrays in strings ({1} for this JDK version).
<a name="2" id="anc2"></a><span class="line-modified">598 StringDeduplicationRule_RESULT_LONG_DESCRIPTION=String deduplication is enabled using the JVM flag &#39;-XX:+UseStringDeduplication&#39;. This flag can be used together with the G1 garbage collector in JDK 8u20 or later, or with the Shenandoah garbage collector.&lt;p&gt;To validate if this gives a performance improvement for your application, create flight recordings both with and without string deduplication. For the run with string deduplication enabled, also enable statistics with &#39;-XX:+PrintStringDeduplicationStatistics&#39; for JDK 8 or &#39;-Xlog:stringdedup*=debug&#39; for JDK 9. Check if the heap live set decrease in the recording with string deduplication enabled is larger than the size of the string deduplication metadata table. The size of the metadata table is printed in the statistics output as &#39;Table/Memory Usage: XX MB&#39;&lt;p&gt;You can read more about string deduplication in the java options documentation or in &lt;a href=&quot;https://openjdk.java.net/jeps/192&quot;&gt;JEP 192&lt;/a&gt;.</span>
599 SystemGcRule_CONFIG_WARNING_LIMIT=System.gc() ratio limit
600 SystemGcRule_CONFIG_WARNING_LIMIT_LONG=Warning limit for ratio between System.gc() and total garbage collections
601 SystemGcRuleFactory_RULE_NAME=GCs Caused by System.gc()
602 # {0} is a percentage
603 SystemGcRuleFactory_TEXT_INFO={0} of the garbage collections were caused by System.gc().
604 SystemGcRuleFactory_TEXT_INFO_LONG=Calling System.gc() can cause unnecessary garbage collections. If you&#39;re not sure that you need these calls, consider removing them.&lt;p&gt;If the calls are in libraries where you can&#39;t change the source code, you can use the command line flag &#39;-XX:+DisableExplicitGC&#39; to make the JVM ignore all System.gc() calls.
605 SystemGcRuleFactory_TEXT_OK=No garbage collections were caused by System.gc().
606 TlabAllocationRatioRuleFactory_RULE_NAME=TLAB Allocation Ratio
607 # {0} is a percentage
608 TlabAllocationRatioRuleFactory_TEXT_INFO=The program allocated {0} of the memory outside of TLABs.
609 TlabAllocationRatioRuleFactory_TEXT_RECOMMEND_LESS_ALLOCATION=Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.
610 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE=The program only allocated objects outside of TLABs.
611 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE_LONG=The program only allocated objects outside of Thread Local Allocation Buffers (TLABs).
612 TlabAllocationRatioRuleFactory_TEXT_OK_NO_OUTSIDE=No object allocations outside of TLABs detected.
613 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO=The recording was performed on a JVM that had Experimental VM Options enabled.
614 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO_LONG=Experimental VM options may be unreliable and should not be used in a production environment. Unless you have to use an experimental option, you should avoid the &#39;-XX:+UnlockExperimentalVMOptions&#39; command line option.
615 VMOperations_RULE_NAME=VMOperation Peak Duration
616 VMOperationRule_CONFIG_WARNING_LIMIT=Blocking VM operation duration warning limit
617 VMOperationRule_CONFIG_WARNING_LIMIT_LONG=The minimum duration for a blocking VM operation needed to trigger a warning
618 # {0} is a time period
619 VMOperationRuleFactory_TEXT_OK=No excessively long VM operations were found in this recording (the longest was {0}).
620 # {0} is a time period
621 VMOperationRuleFactory_TEXT_WARN=There are long lasting blocking VM operations in this recording (the longest is {0}).
622 # {0} is a time period, {1} is a time stamp, {2} is a thread name, {3} is a time stamp
623 VMOperationRuleFactory_TEXT_WARN_LONG=There are long lasting blocking VM operations in this recording. The longest was of type {1} and lasted for {0}. It was initiated from thread &#39;&#39;{2}&#39;&#39; and happened at {3}. &lt;p&gt;VM operations are JVM internal operations. Some VM operations are executed synchronously (i.e. will block the calling thread), and some need to be executed at so called safe points. Safe point polling is a cooperative suspension mechanism that halts byte code execution in the JVM. A VM operation occurring at a safe point will effectively be &quot;stopping the world&quot;, meaning that no Java code will be executing in any thread while executing VM operations at that safe point. Long lasting VM operations executing at safe points can decrease the responsiveness of an application. &lt;p&gt;If you do find such VM operations, then the type of operation and its caller thread provide vital information to understand why the VM operation happened. To find more details, check if there is an event in the caller thread intersecting this event time wise. Looking at the stack trace for such an event can help determining what caused it.&lt;/p&gt;&lt;p&gt;See &lt;a href=&quot;http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html&quot;&gt;Runtime Overview&lt;/a&gt; for further information.&lt;/p&gt;
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>