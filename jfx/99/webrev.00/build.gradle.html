<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New build.gradle</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * The main build script for JavaFX.
  28  *
  29  * MUST FIX tasks to complete:
  30  *  - build check -- making sure the final artifact has the right bits
  31  *      - some things worth automatically sanity checking:
  32  *          - are there images in the javadocs?
  33  *          - are all of the expected dylibs etc there?
  34  *  - Perform sanity checking to make sure a JDK exists with javac, etc
  35  *  - Support building with no known JDK location, as long as javac, etc are on the path
  36  *  - Check all of the native flags. We&#39;re adding weight to some libs that don&#39;t need it, and so forth.
  37  *
  38  * Additional projects to work on as we go:
  39  *  - Add &quot;developer debug&quot;. This is where the natives do not have debug symbols, but the Java code does
  40  *  - The genVSproperties.bat doesn&#39;t find the directory where RC.exe lives. So it is hard coded. Might be a problem.
  41  *  - special tasks for common needs, such as:
  42  *      - updating copyright headers
  43  *      - stripping trailing whitespace (?)
  44  *  - checkstyle
  45  *  - findbugs
  46  *  - re needs?
  47  *  - sqe testing
  48  *  - API change check
  49  *  - Pushing results to a repo?
  50  *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
  51  *  - Integrate Parfait reports for C code
  52  *  - FXML Project tests are not running
  53  */
  54 defaultTasks = [&quot;sdk&quot;]
  55 
  56 import java.util.concurrent.CountDownLatch
  57 import java.util.concurrent.ExecutorService
  58 import java.util.concurrent.Executors
  59 import java.util.concurrent.Future
  60 
  61 /******************************************************************************
  62  *                              Utility methods                               *
  63  *****************************************************************************/
  64 
  65 /**
  66  * If the given named property is not defined, then this method will define
  67  * it with the given defaultValue. Any properties defined by this method can
  68  * be substituted on the command line by using -P, or by specifying a
  69  * gradle.properties file in the user home dir
  70  *
  71  * @param name The name of the property to define
  72  * @param defaultValue The default value to assign the property
  73  */
  74 void defineProperty(String name, String defaultValue) {
  75     if (!project.hasProperty(name)) {
  76         project.ext.set(name, defaultValue);
  77     }
  78 }
  79 
  80 /**
  81  * If the given named property is not defined, then this method will attempt to
  82  * look up the property in the props map, and use the defaultValue if it cannot be found.
  83  *
  84  * @param name The name of the property to look up and/or define
  85  * @param props The properties to look for the named property in, if it has not already been defined
  86  * @param defaultValue The default value if the property has not been defined and the
  87  *                     props map does not contain the named property
  88  */
  89 void defineProperty(String name, Properties props, String defaultValue) {
  90     if (!project.hasProperty(name)) {
  91         project.ext.set(name, props.getProperty(name, defaultValue));
  92     }
  93 }
  94 
  95 /**
  96  * Converts cygwin style paths to windows style paths, but with a forward slash.
  97  * This method is safe to call from any platform, and will only do work if
  98  * called on Windows (in all other cases it simply returns the supplied path.
  99  *
 100  * @param path the path to convert
 101  * @return the path converted to windows style, if on windows, otherwise it
 102  *         is the supplied path.
 103  */
 104 String cygpath(String path) {
 105     if (!IS_WINDOWS) return path;
 106     if (path == null || &quot;&quot;.equals(path)) return path;
 107     String ret = path.replaceAll(&#39;\\\\&#39;, &#39;/&#39;)
 108     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 109     return ret
 110 }
 111 
 112 /**
 113  * Converts cygwin file paths for java executables to windows style
 114  * executable paths by changing forward slashes to back slashes and
 115  * adding the &#39;.exe&#39; extension.
 116  * This method is safe to call from any platform, and will only do work if
 117  * called on Windows (in all other cases it simply returns the supplied path).
 118  *
 119  * @param path the path to convert
 120  * @return the path converted to windows style, if on windows, otherwise it
 121  *         is the supplied path.
 122  */
 123 String cygpathExe(String path) {
 124     if (!IS_WINDOWS) return path;
 125     if (path == null || &quot;&quot;.equals(path)) return path;
 126     String ret = path.replaceAll(&#39;/&#39;, &#39;\\\\&#39;)
 127     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 128     return ret + &quot;.exe&quot;
 129 }
 130 
 131 void loadProperties(String sourceFileName) {
 132     def config = new Properties()
 133     def propFile = new File(sourceFileName)
 134     if (propFile.canRead()) {
 135         config.load(new FileInputStream(propFile))
 136         for (java.util.Map.Entry property in config) {
 137             def keySplit = property.key.split(&quot;\\.&quot;);
 138             def key = keySplit[0];
 139             for (int i = 1; i &lt; keySplit.length; i++) {
 140                 key = key + keySplit[i].capitalize();
 141             }
 142             ext[key] = property.value;
 143         }
 144     }
 145 }
 146 
 147 /**
 148  * Struct used to contain some information passed to the closure
 149  * passed to compileTargets.
 150  */
 151 class CompileTarget {
 152     String name;
 153     String upper;
 154     String capital;
 155 }
 156 
 157 /**
 158  * Iterates over each of the compile targets, passing the given closure
 159  * a CompileTarget instance.
 160  *
 161  * @param c The closure to call
 162  */
 163 void compileTargets(Closure c) {
 164     if (COMPILE_TARGETS == &quot;&quot;) {
 165         return
 166     }
 167     COMPILE_TARGETS.split(&quot;,&quot;).each { target -&gt;
 168         CompileTarget ct = new CompileTarget();
 169         ct.name = target;
 170         ct.upper = target.trim().toUpperCase(Locale.ROOT)
 171         ct.capital = target.trim().capitalize()
 172         c(ct)
 173     }
 174 }
 175 
 176 /**
 177  * Manages the execution of some closure which is responsible for producing
 178  * content for a properties file built at build time and stored in the
 179  * root project&#39;s $buildDir, and then loading that properties file and
 180  * passing it to the processor closure.
 181  *
 182  * This is used on windows to produce a properties file containing all the
 183  * windows visual studio paths and environment variables, and on Linux
 184  * for storing the results of pkg-config calls.
 185  *
 186  * @param name the name of the file to produce
 187  * @param loader a closure which is invoked, given the properties file. This
 188  *        closure is invoked only if the properties file needs to be created
 189  *        and is responsible for populating the properties file.
 190  * @param processor a closure which is invoked every time this method is
 191  *        called and which will be given a Properties object, fully populated.
 192  *        The processor is then responsible for doing whatever it is that it
 193  *        must do with those properties (such as setting up environment
 194  *        variables used in subsequent native builds, or whatnot).
 195  */
 196 void setupTools(String name, Closure loader, Closure processor) {
 197     // Check to see whether $buildDir/$name.properties file exists. If not,
 198     // then generate it. Once generated, we need to read the properties file to
 199     // help us define the defaults for this block of properties
 200     File propFile = file(&quot;$buildDir/${name}.properties&quot;);
 201     if (!propFile.exists()) {
 202         // Create the properties file
 203         propFile.getParentFile().mkdirs();
 204         propFile.createNewFile();
 205         loader(propFile);
 206     }
 207 
 208     // Try reading the properties in order to define the properties. If the property file cannot
 209     // be located, then we will throw an exception because we cannot guess these values
 210     InputStream propStream = null;
 211     try {
 212         Properties properties = new Properties();
 213         propStream = new FileInputStream(propFile);
 214         properties.load(propStream);
 215         processor(properties);
 216     } finally {
 217         try { propStream.close() } catch (Exception e) { }
 218     }
 219 }
 220 
 221 String[] parseJavaVersion(String jRuntimeVersion) {
 222     def jVersion = jRuntimeVersion.split(&quot;[-\\+]&quot;)[0]
 223     def tmpBuildNumber = &quot;0&quot;
 224     if (jVersion.startsWith(&quot;1.&quot;)) {
 225         // This is a pre-JEP-223 version string
 226         def dashbIdx = jRuntimeVersion.lastIndexOf(&quot;-b&quot;)
 227         if (dashbIdx != -1) {
 228             tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
 229         }
 230     } else {
 231         // This is a post-JEP-223 version string
 232         def plusIdx = jRuntimeVersion.indexOf(&quot;+&quot;)
 233         if (plusIdx != -1) {
 234             tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
 235         }
 236     }
 237     def jBuildNumber = tmpBuildNumber.split(&quot;[-\\+]&quot;)[0]
 238     def versionInfo = new String[2];
 239     versionInfo[0] = jVersion
 240     versionInfo[1] = jBuildNumber
 241     return versionInfo
 242 }
 243 
 244 /**
 245  * Fails the build with the specified error message
 246  *
 247  * @param msg the reason for the failure
 248  */
 249 void fail(String msg) {
 250     throw new GradleException(&quot;FAIL: &quot; + msg);
 251 }
 252 
 253 /******************************************************************************
 254  *                                                                            *
 255  *                   Definition of project properties                         *
 256  *                                                                            *
 257  *  All properties defined using ext. are immediately available throughout    *
 258  *  the script as variables that can be used. These variables are attached    *
 259  *  to the root project (whereas if they were defined as def variables then   *
 260  *  they would only be available within the root project scope).              *
 261  *                                                                            *
 262  *  All properties defined using the &quot;defineProperty&quot; method can be replaced  *
 263  *  on the command line by using the -P flag. For example, to override the    *
 264  *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 265  *                                                                            *
 266  *****************************************************************************/
 267 
 268 // If the ../rt-closed directory exists, then we are doing a closed build.
 269 // In this case, build and property files will be read from
 270 // ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
 271 // respectively
 272 
 273 def closedDir = file(&quot;../rt-closed&quot;)
 274 def buildClosed = closedDir.isDirectory()
 275 ext.BUILD_CLOSED = buildClosed
 276 
 277 ext.RUNARGSFILE = &quot;run.args&quot;
 278 ext.COMPILEARGSFILE = &quot;compile.args&quot;
 279 ext.RUNJAVAPOLICYFILE = &#39;run.java.policy&#39;
 280 
 281 ext.TESTCOMPILEARGSFILE = &quot;testcompile.args&quot;
 282 ext.TESTRUNARGSFILE = &quot;testrun.args&quot;
 283 ext.TESTJAVAPOLICYFILE = &#39;test.java.policy&#39;
 284 
 285 // the file containing &quot;extra&quot; --add-exports
 286 ext.EXTRAADDEXPORTS = &#39;buildSrc/addExports&#39;
 287 
 288 ext.MODULESOURCEPATH = &quot;modulesourcepath.args&quot;
 289 
 290 // These variables indicate what platform is running the build. Is
 291 // this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
 292 ext.OS_NAME = System.getProperty(&quot;os.name&quot;).toLowerCase()
 293 ext.OS_ARCH = System.getProperty(&quot;os.arch&quot;)
 294 ext.IS_64 = OS_ARCH.toLowerCase().contains(&quot;64&quot;)
 295 ext.IS_MAC = OS_NAME.contains(&quot;mac&quot;) || OS_NAME.contains(&quot;darwin&quot;)
 296 ext.IS_WINDOWS = OS_NAME.contains(&quot;windows&quot;)
 297 ext.IS_LINUX = OS_NAME.contains(&quot;linux&quot;)
 298 
 299 ext.MAVEN_GROUP_ID = &quot;org.openjfx&quot;
 300 
 301 // Verify that the architecture &amp; OS are supported configurations. Note that
 302 // at present building on PI is not supported, but we would only need to make
 303 // some changes on assumptions on what should be built (like SWT / Swing) and
 304 // such and we could probably make it work.
 305 if (!IS_MAC &amp;&amp; !IS_WINDOWS &amp;&amp; !IS_LINUX) fail(&quot;Unsupported build OS ${OS_NAME}&quot;)
 306 if (IS_WINDOWS &amp;&amp; OS_ARCH != &quot;x86&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 307     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 308 } else if (IS_MAC &amp;&amp; OS_ARCH != &quot;x86_64&quot;) {
 309     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 310 } else if (IS_LINUX &amp;&amp; OS_ARCH != &quot;i386&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 311     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 312 }
 313 
 314 
 315 // Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
 316 // use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified
 317 // independently (or we&#39;ll try to get the right one based on other supplied info). Sometimes the
 318 // JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
 319 //    c:\Program Files (x86)\Java\jdk1.8.0\jre
 320 //    c:\Program Files (x86)\Java\jre8\
 321 // Because of this, you may sometimes get the jdk&#39;s JRE (in which case the logic we used to have here
 322 // was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
 323 def envJavaHome = cygpath(System.getenv(&quot;JDK_HOME&quot;))
 324 if (envJavaHome == null || envJavaHome.equals(&quot;&quot;)) envJavaHome = cygpath(System.getenv(&quot;JAVA_HOME&quot;))
 325 def javaHome = envJavaHome == null || envJavaHome.equals(&quot;&quot;) ? System.getProperty(&quot;java.home&quot;) : envJavaHome
 326 def javaHomeFile = file(javaHome)
 327 defineProperty(&quot;JDK_HOME&quot;,
 328         javaHomeFile.name == &quot;jre&quot; ?
 329         javaHomeFile.getParent().toString() :
 330         javaHomeFile.name.startsWith(&quot;jre&quot;) ?
 331         new File(javaHomeFile.getParent(), &quot;jdk1.${javaHomeFile.name.substring(3)}.0&quot;).toString() :
 332         javaHome) // we have to bail and set it to something and this is as good as any!
 333 ext.JAVA_HOME = JDK_HOME
 334 
 335 defineProperty(&quot;JAVA&quot;, cygpathExe(&quot;$JDK_HOME/bin/java&quot;))
 336 defineProperty(&quot;JAVAC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javac&quot;))
 337 defineProperty(&quot;JAVADOC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javadoc&quot;))
 338 defineProperty(&quot;JMOD&quot;, cygpathExe(&quot;$JDK_HOME/bin/jmod&quot;))
 339 defineProperty(&quot;JDK_DOCS&quot;, &quot;https://docs.oracle.com/en/java/javase/12/docs/api/&quot;)
 340 defineProperty(&quot;JDK_JMODS&quot;, cygpath(System.getenv(&quot;JDK_JMODS&quot;)) ?: cygpath(System.getenv(&quot;JDK_HOME&quot;) + &quot;/jmods&quot;))
 341 
 342 defineProperty(&quot;javaRuntimeVersion&quot;, System.getProperty(&quot;java.runtime.version&quot;))
 343 def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
 344 defineProperty(&quot;javaVersion&quot;, javaVersionInfo[0])
 345 defineProperty(&quot;javaBuildNumber&quot;, javaVersionInfo[1])
 346 
 347 defineProperty(&quot;libAVRepositoryURL&quot;, &quot;https://libav.org/releases/&quot;)
 348 defineProperty(&quot;FFmpegRepositoryURL&quot;, &quot;https://www.ffmpeg.org/releases/&quot;)
 349 
 350 loadProperties(&quot;$projectDir/build.properties&quot;)
 351 
 352 def supplementalPreBuildFile = file(&quot;$closedDir/closed-pre-build.gradle&quot;);
 353 def supplementalBuildFile = file(&quot;$closedDir/closed-build.gradle&quot;);
 354 
 355 if (BUILD_CLOSED) {
 356     apply from: supplementalPreBuildFile
 357 }
 358 
 359 // GRADLE_VERSION_CHECK specifies whether to fail the build if the
 360 // gradle version check fails
 361 defineProperty(&quot;GRADLE_VERSION_CHECK&quot;, &quot;true&quot;)
 362 ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)
 363 
 364 // JFX_DEPS_URL specifies the optional location of an alternate local repository
 365 defineProperty(&quot;JFX_DEPS_URL&quot;, &quot;&quot;)
 366 
 367 // JDK_DOCS_LINK specifies the optional URL for offline javadoc linking
 368 defineProperty(&quot;JDK_DOCS_LINK&quot;, &quot;&quot;)
 369 
 370 // COMPILE_WEBKIT specifies whether to build all of webkit.
 371 defineProperty(&quot;COMPILE_WEBKIT&quot;, &quot;false&quot;)
 372 ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
 373 
 374 // COMPILE_MEDIA specifies whether to build all of media.
 375 defineProperty(&quot;COMPILE_MEDIA&quot;, &quot;false&quot;)
 376 ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)
 377 
 378 // BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries
 379 defineProperty(&quot;BUILD_LIBAV_STUBS&quot;, &quot;false&quot;)
 380 ext.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false
 381 
 382 // BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with
 383 // decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.
 384 defineProperty(&quot;BUILD_WORKING_LIBAV&quot;, &quot;false&quot;)
 385 ext.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false
 386 
 387 // COMPILE_PANGO specifies whether to build javafx_font_pango.
 388 defineProperty(&quot;COMPILE_PANGO&quot;, &quot;${IS_LINUX}&quot;)
 389 ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)
 390 
 391 // COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
 392 defineProperty(&quot;COMPILE_HARFBUZZ&quot;, &quot;false&quot;)
 393 ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)
 394 
 395 // COMPILE_PARFAIT specifies whether to build parfait
 396 defineProperty(&quot;COMPILE_PARFAIT&quot;, &quot;false&quot;)
 397 ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)
 398 
 399 defineProperty(&quot;STATIC_BUILD&quot;, &quot;false&quot;)
 400 ext.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)
 401 
 402 if (IS_STATIC_BUILD &amp;&amp; IS_COMPILE_MEDIA) {
 403     throw new GradleException(&quot;Can not have COMPILE_MEDIA when STATIC_BUILD is enabled&quot;);
 404 }
 405 
 406 // BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads
 407 // required build tools.
 408 defineProperty(&quot;BUILD_TOOLS_DOWNLOAD_SCRIPT&quot;, &quot;&quot;)
 409 
 410 // Define the SWT.jar that we are going to have to download during the build process based
 411 // on what platform we are compiling from (not based on our target).
 412 ext.SWT_FILE_NAME = IS_MAC ? &quot;org.eclipse.swt.cocoa.macosx.x86_64_3.105.3.v20170228-0512&quot; :
 413     IS_WINDOWS &amp;&amp; IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_64_3.105.3.v20170228-0512&quot; :
 414     IS_WINDOWS &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_3.105.3.v20170228-0512&quot; :
 415     IS_LINUX &amp;&amp; IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_64_3.105.3.v20170228-0512&quot; :
 416     IS_LINUX &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_3.105.3.v20170228-0512&quot; : &quot;&quot;
 417 
 418 // Specifies whether to run full tests (true) or smoke tests (false)
 419 defineProperty(&quot;FULL_TEST&quot;, &quot;false&quot;)
 420 ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);
 421 
 422 defineProperty(&quot;FORCE_TESTS&quot;, &quot;false&quot;)
 423 ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);
 424 
 425 // Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
 426 defineProperty(&quot;USE_ROBOT&quot;, &quot;false&quot;)
 427 ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);
 428 
 429 // Specified whether to run tests in headless mode
 430 defineProperty(&quot;HEADLESS_TEST&quot;, &quot;false&quot;)
 431 ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);
 432 
 433 // Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
 434 defineProperty(&quot;AWT_TEST&quot;, &quot;true&quot;)
 435 ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);
 436 
 437 // Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)
 438 defineProperty(&quot;SWT_TEST&quot;, &quot;true&quot;)
 439 ext.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);
 440 
 441 // Specifies whether to run unstable tests (true) - tests that don&#39;t run well with Hudson builds
 442 // These tests should be protected with :
 443 //    assumeTrue(Boolean.getBoolean(&quot;unstable.test&quot;));
 444 defineProperty(&quot;UNSTABLE_TEST&quot;, &quot;false&quot;)
 445 ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);
 446 
 447 // Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.
 448 defineProperty(&quot;WORKER_DEBUG&quot;, &quot;false&quot;)
 449 ext.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);
 450 
 451 // Specify the build configuration (Release, Debug, or DebugNative)
 452 defineProperty(&quot;CONF&quot;, &quot;Debug&quot;)
 453 ext.IS_DEBUG_JAVA = CONF == &quot;Debug&quot; || CONF == &quot;DebugNative&quot;
 454 ext.IS_DEBUG_NATIVE = CONF == &quot;DebugNative&quot;
 455 
 456 // Defines the compiler warning levels to use. If empty, then no warnings are generated. If
 457 // not empty, then the expected syntax is as a space or comma separated list of names, such
 458 // as defined in the javac documentation.
 459 defineProperty(&quot;LINT&quot;, &quot;none&quot;)
 460 ext.IS_LINT = LINT != &quot;none&quot;
 461 
 462 defineProperty(&quot;DOC_LINT&quot;, &quot;all&quot;)
 463 ext.IS_DOC_LINT = DOC_LINT != &quot;&quot;
 464 
 465 // Specifies whether to use the &quot;useDepend&quot; option when compiling Java sources
 466 defineProperty(&quot;USE_DEPEND&quot;, &quot;true&quot;)
 467 ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)
 468 
 469 // Specifies whether to use the &quot;incremental&quot; option when compiling Java sources
 470 defineProperty(&quot;INCREMENTAL&quot;, &quot;false&quot;)
 471 ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)
 472 
 473 // Specifies whether to include the Null3D pipeline (for perf debugging)
 474 defineProperty(&quot;INCLUDE_NULL3D&quot;, &quot;false&quot;)
 475 ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)
 476 
 477 // Specifies whether to include the ES2 pipeline if available
 478 defineProperty(&quot;INCLUDE_ES2&quot;, IS_WINDOWS ? &quot;false&quot; : &quot;true&quot;)
 479 ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)
 480 
 481 // Specifies whether to generate code coverage statistics when running tests
 482 defineProperty(&quot;JCOV&quot;, &quot;false&quot;)
 483 ext.DO_JCOV = Boolean.parseBoolean(JCOV)
 484 
 485 // Specifies whether to use Cygwin when building OpenJFX. This should only ever
 486 // be set to false for development builds (that skip building media and webkit).
 487 defineProperty(&quot;USE_CYGWIN&quot;, &quot;true&quot;)
 488 ext.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)
 489 
 490 // Define the number of threads to use when compiling (specifically for native compilation)
 491 // On Mac we limit it to 1 by default due to problems running gcc in parallel
 492 if (IS_MAC) {
 493     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;1&quot;)
 494 } else {
 495     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;${Runtime.runtime.availableProcessors()}&quot;)
 496 }
 497 
 498 //
 499 // The next three sections of properties are used to generate the
 500 // VersionInfo class, and the Windows DLL manifest.
 501 //
 502 
 503 // The following properties should be left alone by developers and set only from Hudson.
 504 defineProperty(&quot;HUDSON_JOB_NAME&quot;, &quot;not_hudson&quot;)
 505 defineProperty(&quot;HUDSON_BUILD_NUMBER&quot;,&quot;0000&quot;)
 506 defineProperty(&quot;PROMOTED_BUILD_NUMBER&quot;, &quot;0&quot;)
 507 defineProperty(&quot;MILESTONE_FCS&quot;, &quot;false&quot;)
 508 ext.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)
 509 
 510 // The following properties define the product name for Oracle JDK and OpenJDK
 511 // for VersionInfo and the DLL manifest.
 512 if (BUILD_CLOSED) {
 513     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;Java(TM)&quot;)
 514     defineProperty(&quot;COMPANY_NAME&quot;, &quot;Oracle Corporation&quot;)
 515     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform SE&quot;)
 516 } else {
 517     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;OpenJFX&quot;)
 518     defineProperty(&quot;COMPANY_NAME&quot;, &quot;N/A&quot;)
 519     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform&quot;)
 520 }
 521 
 522 // The following properties are set based on properties defined in
 523 // build.properties. The release version and suffix should be updated
 524 // in that file.
 525 def relVer = 0
 526 if (jfxReleasePatchVersion == &quot;0&quot;) {
 527     if (jfxReleaseSecurityVersion == &quot;0&quot;) {
 528         if (jfxReleaseMinorVersion == &quot;0&quot;) {
 529             relVer = &quot;${jfxReleaseMajorVersion}&quot;
 530         } else {
 531             relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}&quot;
 532         }
 533     } else {
 534         relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}&quot;
 535     }
 536 } else {
 537     relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;
 538 }
 539 defineProperty(&quot;RELEASE_VERSION&quot;, relVer)
 540 defineProperty(&quot;RELEASE_VERSION_PADDED&quot;, &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;)
 541 
 542 def buildDate = System.getenv(&quot;SOURCE_DATE_EPOCH&quot;) == null ? new java.util.Date() : new java.util.Date(1000 * Long.parseLong(System.getenv(&quot;SOURCE_DATE_EPOCH&quot;)))
 543 def buildTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd-HHmmss&quot;).format(buildDate)
 544 defineProperty(&quot;BUILD_TIMESTAMP&quot;, buildTimestamp)
 545 def relSuffix = &quot;&quot;
 546 def relOpt = &quot;&quot;
 547 if (HUDSON_JOB_NAME == &quot;not_hudson&quot;) {
 548     relSuffix = &quot;-internal&quot;
 549     relOpt = &quot;-${buildTimestamp}&quot;
 550 } else {
 551     relSuffix = IS_MILESTONE_FCS ? &quot;&quot; : jfxReleaseSuffix
 552 }
 553 defineProperty(&quot;RELEASE_SUFFIX&quot;, relSuffix)
 554 defineProperty(&quot;RELEASE_VERSION_SHORT&quot;, &quot;${RELEASE_VERSION}${RELEASE_SUFFIX}&quot;)
 555 defineProperty(&quot;RELEASE_VERSION_LONG&quot;, &quot;${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}&quot;)
 556 defineProperty(&quot;MAVEN_VERSION&quot;, IS_MILESTONE_FCS ? &quot;${RELEASE_VERSION_SHORT}&quot; : &quot;${RELEASE_VERSION_LONG}&quot;)
 557 
 558 // Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
 559 // the user and not by this script). If it has not been defined then default
 560 // to building the normal desktop build for this machine
 561 project.ext.set(&quot;defaultHostTarget&quot;, IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;);
 562 defineProperty(&quot;COMPILE_TARGETS&quot;, &quot;$defaultHostTarget&quot;)
 563 
 564 // Flag indicating whether to import cross compile tools
 565 def importCrossTools = false
 566 if (hasProperty(&quot;IMPORT_CROSS_TOOLS&quot;)) {
 567     importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
 568 }
 569 ext.IS_IMPORT_CROSS_TOOLS = importCrossTools
 570 
 571 // Location of the cross compile tools
 572 def crossToolsDir = &quot;../crosslibs&quot;
 573 if (hasProperty(&quot;CROSS_TOOLS_DIR&quot;)) {
 574     crossToolsDir = CROSS_TOOLS_DIR
 575 }
 576 ext.CROSS_TOOLS_DIR = file(crossToolsDir)
 577 
 578 // Specifies whether to run tests with the existing javafx.* modules instead of compiling a new one
 579 defineProperty(&quot;BUILD_SDK_FOR_TEST&quot;, &quot;true&quot;)
 580 ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)
 581 
 582 // All &quot;classes&quot; and &quot;jar&quot; tasks and their dependencies would be disabled
 583 // when running with DO_BUILD_SDK_FOR_TEST=false as they&#39;re unneeded for running tests
 584 if (!DO_BUILD_SDK_FOR_TEST) {
 585     gradle.taskGraph.useFilter({ task -&gt; !task.name.equals(&quot;classes&quot;) &amp;&amp; !task.name.equals(&quot;jar&quot;) })
 586 }
 587 
 588 // Make sure JDK_HOME/bin/java exists
 589 if (!file(JAVA).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;java&#39;: &#39;$JAVA&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 590 if (!file(JAVAC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javac&#39;: &#39;$JAVAC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 591 if (!file(JAVADOC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javadoc&#39;: &#39;$JAVADOC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 592 
 593 // Determine the verion of Java in JDK_HOME. It looks like this:
 594 //
 595 // $ java -version
 596 // java version &quot;1.7.0_45&quot;
 597 // Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
 598 // Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
 599 //
 600 // We need to parse the second line
 601 def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;-fullversion&quot;).start().getErrorStream()));
 602 try {
 603     String v = inStream.readLine().trim();
 604     if (v != null) {
 605         int ib = v.indexOf(&quot;full version \&quot;&quot;);
 606         if (ib != -1) {
 607             String str = v.substring(ib);
 608             String ver = str.substring(str.indexOf(&quot;\&quot;&quot;) + 1, str.size() - 1);
 609 
 610             defineProperty(&quot;jdkRuntimeVersion&quot;, ver)
 611             def jdkVersionInfo = parseJavaVersion(ver)
 612             defineProperty(&quot;jdkVersion&quot;, jdkVersionInfo[0])
 613             defineProperty(&quot;jdkBuildNumber&quot;, jdkVersionInfo[1])
 614         }
 615     }
 616 } finally {
 617     inStream.close();
 618 }
 619 if (!project.hasProperty(&quot;jdkRuntimeVersion&quot;)) throw new Exception(&quot;Unable to determine the version of Java in JDK_HOME at $JDK_HOME&quot;);
 620 
 621 
 622 // Determine whether the javafx.* modules are present in the JDK. To do this,
 623 // we will execute &quot;java --list-modules&quot; and search for javafx.base.
 624 ext.HAS_JAVAFX_MODULES = false;
 625 def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;--list-modules&quot;).start().getInputStream()));
 626 try {
 627     String v;
 628     while ((v = inStream2.readLine()) != null) {
 629         v = v.trim();
 630         if (v.startsWith(&quot;javafx.base&quot;)) ext.HAS_JAVAFX_MODULES = true;
 631     }
 632 } finally {
 633     inStream2.close();
 634 }
 635 
 636 // The HAS_JAVAFX_MODULES flag will be used to determine the mode for building
 637 // and running the applications and tests.
 638 // If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules
 639 // for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will
 640 // build / test a standalone sdk for running with a JDK that does not include
 641 // the javafx modules.
 642 
 643 
 644 /**
 645  * Fetch/Check that external tools are present for the build. This method
 646  * will conditionally download the packages from project defined ivy repositories
 647  * and unpack them into the specified destdir
 648  *
 649  * @param configName A unique name to distinguish the configuration (ie &quot;ARMSFV6&quot;)
 650  * @param packages A list of required packages (with extensions .tgz, .zip)
 651  * @param destdir where the packages should be unpacked
 652  * @param doFetch if true, the named packages will be download
 653  */
 654 void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
 655     if (doFetch) {
 656         // create a unique configuration for this fetch
 657         def String fetchToolsConfig = &quot;fetchTools$configName&quot;
 658         rootProject.configurations.create(fetchToolsConfig)
 659 
 660         def List&lt;String&gt; fetchedPackages = []
 661         def int fetchCount = 0
 662 
 663         packages.each { pkgname-&gt;
 664             def int dotdex = pkgname.lastIndexOf(&#39;.&#39;)
 665             def int dashdex = pkgname.lastIndexOf(&#39;-&#39;)
 666             def String basename = pkgname.substring(0,dashdex)
 667             def String ver = pkgname.substring(dashdex+1,dotdex)
 668             def String ext = pkgname.substring(dotdex+1)
 669             def File pkgdir = file(&quot;$destdir/$basename-$ver&quot;)
 670 
 671             if (!pkgdir.isDirectory()) {
 672                 rootProject.dependencies.add(fetchToolsConfig, &quot;javafx:$basename:$ver&quot;, {
 673                     artifact {
 674                         name = basename
 675                         type = ext
 676                     }
 677                 })
 678                 println &quot;adding $pkgname as a downloadable item did not find $pkgdir&quot;
 679                 fetchedPackages.add(pkgname)
 680                 fetchCount++
 681             }
 682         }
 683 
 684         //fetch all the missing packages
 685         if (fetchedPackages.size &gt; 0) {
 686             destdir.mkdirs()
 687 
 688             logger.quiet &quot;fetching missing packages $fetchedPackages&quot;
 689             copy {
 690                 from rootProject.configurations[fetchToolsConfig]
 691                 into destdir
 692             }
 693 
 694             // unpack the fetched packages
 695             fetchedPackages.each { pkgname-&gt;
 696                 logger.quiet &quot;expanding the package $pkgname&quot;
 697                 def srcball = file(&quot;${destdir}/${pkgname}&quot;)
 698 
 699                 if (!srcball.exists()) {
 700                     throw new GradleException(&quot;Failed to fetch $pkgname&quot;);
 701                 }
 702 
 703                 def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 704                 def File pkgdir = file(&quot;$destdir/$basename&quot;)
 705 
 706                 if (pkgname.endsWith(&quot;.tgz&quot;) || pkgname.endsWith(&quot;tar.gz&quot;)) {
 707                     if (IS_LINUX || IS_MAC) {
 708                         // use native tar to support symlinks
 709                         pkgdir.mkdirs()
 710                         exec {
 711                             workingDir pkgdir
 712                             commandLine &quot;tar&quot;, &quot;zxf&quot;, &quot;${srcball}&quot;
 713                          }
 714                     } else {
 715                         copy {
 716                             from tarTree(resources.gzip(&quot;${srcball}&quot;))
 717                             into pkgdir
 718                         }
 719                     }
 720                 } else if (pkgname.endsWith(&quot;.zip&quot;)) {
 721                      copy {
 722                          from zipTree(&quot;${srcball}&quot;)
 723                          into pkgdir
 724                      }
 725                 } else {
 726                     throw new GradleException(&quot;Unhandled package type for compile package ${pkgname}&quot;)
 727                 }
 728                 srcball.delete();
 729             }
 730         } else {
 731             logger.quiet &quot;all tool packages are present $packages&quot;
 732         }
 733     } else { // !doFetch - so just check they are present
 734         // check that all the dirs are really there
 735         def List&lt;String&gt; errors = []
 736         packages.each { pkgname-&gt;
 737             def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 738             def File pkgdir = file(&quot;$destdir/$basename&quot;)
 739 
 740             if (!pkgdir.isDirectory()) {
 741                 errors.add(pkgname)
 742             }
 743         }
 744         if (errors.size &gt; 0) {
 745             throw new GradleException(&quot;Error: missing tool packages: $errors&quot;)
 746         } else {
 747             logger.quiet &quot;all tool packages are present $packages&quot;
 748         }
 749     }
 750 }
 751 
 752 // Make a forked ANT call.
 753 // This needs to be forked so that ant can be used with the right JDK and updated modules
 754 // for testing obscure things like packaging of apps
 755 void ant(String conf,   // platform configuration
 756          String dir,    // directory to run from
 757          String target, // ant target
 758          List&lt;String&gt;  params // parameters (usually -Dxxx=yyy)
 759          ) {
 760     // Try to use ANT_HOME
 761     String antHomeEnv = System.getenv(&quot;ANT_HOME&quot;)
 762     String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;
 763     String ant = (antHome != null &amp;&amp; !antHome.equals(&quot;&quot;)) ? &quot;$antHome/bin/ant&quot; : &quot;ant&quot;;
 764 
 765     exec {
 766         workingDir = dir
 767         environment(&quot;JDK_HOME&quot;, JDK_HOME)
 768         environment(&quot;JAVA_HOME&quot;, JDK_HOME)
 769         if (IS_WINDOWS) {
 770             environment([
 771                     &quot;VCINSTALLDIR&quot;         : WINDOWS_VS_VCINSTALLDIR,
 772                     &quot;VSINSTALLDIR&quot;         : WINDOWS_VS_VSINSTALLDIR,
 773                     &quot;DEVENVDIR&quot;            : WINDOWS_VS_DEVENVDIR,
 774                     &quot;MSVCDIR&quot;              : WINDOWS_VS_MSVCDIR,
 775                     &quot;INCLUDE&quot;              : WINDOWS_VS_INCLUDE,
 776                     &quot;LIB&quot;                  : WINDOWS_VS_LIB,
 777                     &quot;LIBPATH&quot;              : WINDOWS_VS_LIBPATH,
 778                     &quot;DXSDK_DIR&quot;            : WINDOWS_DXSDK_DIR,
 779                     &quot;PATH&quot;                 : WINDOWS_VS_PATH
 780             ]);
 781             commandLine &quot;cmd&quot;, &quot;/c&quot;, ant, &quot;-Dbuild.compiler=javac1.7&quot;
 782         } else {
 783             commandLine ant, &quot;-Dbuild.compiler=javac1.7&quot;
 784         }
 785         if ((conf != null) &amp;&amp; !rootProject.defaultHostTarget.equals(conf)) {
 786             def targetProperties = rootProject.ext[conf.trim().toUpperCase()]
 787             args(&quot;-Dcross.platform=$conf&quot;)
 788             if (targetProperties.containsKey(&#39;arch&#39;)) {
 789                 args(&quot;-Dcross.platform.arch=${targetProperties.arch}&quot;)
 790             }
 791         }
 792         if (params != null) {
 793             params.each() { s-&gt;
 794                 args(s)
 795             }
 796         }
 797         if (IS_MILESTONE_FCS) {
 798             args(&#39;-Djfx.release.suffix=&quot;&quot;&#39;)
 799         }
 800         args(target);
 801     }
 802 }
 803 
 804 List&lt;String&gt; computeLibraryPath(boolean working) {
 805     List&lt;String&gt; lp = []
 806 
 807     if (HAS_JAVAFX_MODULES) {
 808         List&lt;String&gt; modsWithNative = [ &#39;graphics&#39;, &#39;media&#39;, &#39;web&#39; ]
 809 
 810         // the build/modular-sdk area
 811         def platformPrefix = &quot;&quot;
 812         def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
 813         def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
 814         def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
 815 
 816         modsWithNative.each() { m -&gt;
 817             lp &lt;&lt; cygpath(&quot;${modulesLibsDir}/javafx.${m}&quot;)
 818         }
 819     } else {
 820         def platformPrefix = &quot;&quot;
 821         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
 822         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
 823         def modulesLibName = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
 824         def modulesLibsDir = &quot;${standaloneSdkDir}/${modulesLibName}&quot;
 825         lp &lt;&lt; cygpath(&quot;${modulesLibsDir}&quot;)
 826     }
 827 
 828     return lp
 829 }
 830 
 831 // Return list with the arguments needed for --patch-module or --module-path
 832 // for the provided projects. Used with Java executables ie. tests
 833 List&lt;String&gt; computePatchModuleArgs(List&lt;String&gt; deps, boolean test, boolean includeJLP) {
 834     List&lt;String&gt; pma = []
 835 
 836     if (HAS_JAVAFX_MODULES) {
 837         deps.each { String projname -&gt;
 838             def proj = project(projname)
 839             if (proj.hasProperty(&quot;moduleName&quot;)) {
 840                 File dir;
 841                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 842                     dir = file(&quot;${rootProject.buildDir}/shims&quot;)
 843                 } else {
 844                     dir = file(&quot;${rootProject.buildDir}/modular-sdk/modules&quot;)
 845                 }
 846                 String moduleName = proj.ext.moduleName
 847                 String dirpath = cygpath(&quot;${dir}/${moduleName}&quot;)
 848                 pma += &quot;--patch-module=${moduleName}=${dirpath}&quot;
 849             }
 850         }
 851     } else {
 852         String mp = null
 853         deps.each { String projname -&gt;
 854             def proj = project(projname)
 855             if (proj.hasProperty(&quot;moduleName&quot;)) {
 856                 String moduleName = proj.ext.moduleName
 857                 File dir;
 858                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 859                     dir = file(&quot;${rootProject.buildDir}/shims/${moduleName}&quot;)
 860                 } else {
 861                     dir = file(&quot;${rootProject.buildDir}/sdk/lib/${moduleName}.jar&quot;)
 862                 }
 863                 if (mp == null) {
 864                     mp = dir.path
 865                 } else {
 866                     mp = mp + File.pathSeparator + dir.path
 867                 }
 868             }
 869         }
 870 
 871         // in some cases like base we could end up with an empty
 872         // path... make sure we don&#39;t pass one back
 873         if (mp == null) {
 874             return null
 875         }
 876 
 877         pma += &#39;--module-path&#39;
 878         pma += mp
 879 
 880         String addm = null
 881         deps.each {String projname -&gt;
 882             def proj = project(projname)
 883             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp; proj.buildModule) {
 884                 if (addm == null) {
 885                     addm = proj.moduleName
 886                 } else {
 887                     addm = addm + &quot;,&quot; + proj.moduleName
 888                 }
 889             }
 890         }
 891         if (addm != null) {
 892             pma += &quot;--add-modules=${addm}&quot;
 893         }
 894     }
 895 
 896     if (includeJLP) {
 897         pma += &quot;-Djava.library.path=&quot; + computeLibraryPath(true).join(File.pathSeparator)
 898     }
 899 
 900     return pma
 901 }
 902 
 903 // Return a list containing the --upgrade-module-path or --module-path
 904 // used with Javac
 905 List&lt;String&gt; computeModulePathArgs(String  pname, List&lt;String&gt; deps, boolean test) {
 906     List&lt;String&gt; mpa = HAS_JAVAFX_MODULES ? [ &#39;--upgrade-module-path&#39; ] : [ &#39;--module-path&#39; ]
 907     String mp = null
 908     deps.each { String projname -&gt;
 909         def proj = project(projname)
 910         // for a non test set of args, we don&#39;t want the current module in the list
 911         // for a test test, we do need it to update what we built
 912 
 913         if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 914                 proj.buildModule &amp;&amp;
 915                 !(!test &amp;&amp; proj.name.equals(pname))) {
 916 
 917             File dir;
 918             if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 919                 dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
 920             } else {
 921                 dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
 922             }
 923             if (mp == null) {
 924                 mp = dir.path
 925             } else {
 926                 mp = mp + File.pathSeparator + dir.path
 927             }
 928         }
 929     }
 930 
 931     // in some cases like base we could end up with an empty
 932     // path... make sure we don&#39;t pass one back
 933     if (mp == null) {
 934         return null
 935     }
 936 
 937     mpa += mp
 938 
 939     if (!HAS_JAVAFX_MODULES) {
 940         String addm = null
 941         deps.each {String projname -&gt;
 942             def proj = project(projname)
 943             // for a non test set of args, we don&#39;t want the current module in the list
 944             // for a test test, we do need it to update what we built
 945 
 946             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 947                     proj.buildModule &amp;&amp;
 948                     !(!test &amp;&amp; proj.name.equals(pname))) {
 949 
 950                 if (addm == null) {
 951                     addm = proj.moduleName
 952                 } else {
 953                     addm = addm + &quot;,&quot; + proj.moduleName
 954                 }
 955             }
 956         }
 957         if (addm != null) {
 958             mpa += &quot;--add-modules=${addm}&quot;
 959         }
 960     }
 961 
 962     return mpa
 963 }
 964 
 965 
 966 void writeRunArgsFile(File dest, List&lt;String&gt; libpath, List&lt;String&gt; modpath, List&lt;String&gt; modules) {
 967 
 968     dest.delete()
 969 
 970     logger.info(&quot;Creating file ${dest.path}&quot;)
 971 
 972     if (libpath != null) {
 973         dest &lt;&lt;  &quot;-Djava.library.path=\&quot;\\\n&quot;
 974         libpath.each() { e-&gt;
 975             dest &lt;&lt; &quot;  &quot;
 976             dest &lt;&lt; e
 977             dest &lt;&lt; File.pathSeparator
 978             dest &lt;&lt; &quot;\\\n&quot;
 979         }
 980         dest &lt;&lt;  &quot;  \&quot;\n&quot;
 981     }
 982 
 983     if (HAS_JAVAFX_MODULES) {
 984         modpath.each { e -&gt;
 985             dest &lt;&lt;  &quot;--patch-module=\&quot;&quot;
 986             dest &lt;&lt; e
 987             dest &lt;&lt; &quot;\&quot;\n&quot;
 988         }
 989     } else {
 990         if (modpath.size() == 1) {
 991             dest &lt;&lt;  &quot;--module-path=\&quot;&quot;
 992             dest &lt;&lt; modpath[0]
 993             dest &lt;&lt; &quot;\&quot;\n&quot;
 994         } else {
 995             dest &lt;&lt;  &quot;--module-path=\&quot;\\\n&quot;
 996             modpath.each() { e-&gt;
 997                 dest &lt;&lt; &quot;  &quot;
 998                 dest &lt;&lt; e
 999                 dest &lt;&lt; File.pathSeparator
1000                 dest &lt;&lt; &quot;\\\n&quot;
1001             }
1002             dest &lt;&lt;  &quot;  \&quot;\n&quot;
1003         }
1004     }
1005 
1006     if (modules != null) {
1007         dest &lt;&lt;  &quot;--add-modules=&quot;
1008         dest &lt;&lt; modules.join(&quot;,&quot;)
1009         dest &lt;&lt; &quot;\n&quot;
1010     }
1011 }
1012 
1013 // perform common project manipulation for modules
1014 void commonModuleSetup(Project p, List&lt;String&gt; moduleChain) {
1015 
1016     p.ext.moduleChain = moduleChain
1017 
1018     if (p.hasProperty(&quot;moduleName&quot;)) {
1019         p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, &quot;${p.moduleName}&quot;)
1020         if (p.sourceSets.hasProperty(&#39;shims&#39;)) {
1021             p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, &quot;${p.moduleName}&quot;)
1022         }
1023     }
1024 
1025     def mpa = computeModulePathArgs(p.name, moduleChain, false)
1026     if (mpa != null) {
1027         p.ext.modulePathArgs = mpa
1028     }
1029 
1030     p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
1031     p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
1032     p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)
1033 
1034     moduleChain.each() {e -&gt;
1035         if (!e.equals(p.name)) {
1036             p.compileJava.dependsOn(project(e).classes)
1037             p.compileTestJava.dependsOn(project(e).testClasses)
1038         }
1039     }
1040 
1041     // read in any addExports file
1042     File addExportsFile = new File(p.projectDir,&quot;src/test/addExports&quot;)
1043     if (addExportsFile.exists()) {
1044         List&lt;String&gt; ae = []
1045         addExportsFile.eachLine { line -&gt;
1046             line = line.trim()
1047             if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1048                 ae += line.split(&#39; &#39;)
1049             }
1050         }
1051         p.ext.testAddExports  = ae.flatten()
1052     }
1053 
1054     // read in the temporary addExports file EXTRAADDEXPORTS)
1055     //
1056     // These extra --add-exports will be used in two places and so we
1057     // create/modify two items:
1058     // p.testAddExports - add the extra items so they are included in test builds
1059     //
1060     // p.extraAddExports - for use in any other place where we don&#39;t automatically update
1061     //    for example any non modular, non &#39;test&#39; compile, any compile that does not
1062     //    use a module-source-path that includes the dependent modules
1063     //
1064     // Note that we don&#39;t modify the modular build (main, shims) because they use
1065     // module-info directly, and we don&#39;t want to cover up any missing items there.
1066     //
1067     if (!rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_ARGS&quot;)) {
1068         List&lt;String&gt; extraAddExportsList = []
1069         String fullae = &quot;&quot;
1070         File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
1071         if (tmpaddExportsFile.exists()) {
1072             String nl = System.getProperty(&quot;line.separator&quot;)
1073             tmpaddExportsFile.eachLine { line -&gt;
1074                 line = line.trim()
1075                 fullae += line + nl
1076                 if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1077                     extraAddExportsList += line.split(&#39; &#39;)
1078                 }
1079             }
1080         }
1081         // This string is used in the creation of the build/*.args files
1082         // so we preserve comments
1083         if (!extraAddExportsList.isEmpty()) {
1084             rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
1085         }
1086         rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
1087     }
1088 
1089     if (HAS_JAVAFX_MODULES) {
1090         // use this variable, because it shows we have a non empty addition
1091         if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
1092             p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
1093             if (p.hasProperty(&quot;testAddExports&quot;)) {
1094                 p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
1095             }
1096         }
1097     }
1098 }
1099 
1100 if (BUILD_TOOLS_DOWNLOAD_SCRIPT != &quot;&quot;) {
1101     println &quot;Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}&quot;
1102     apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT
1103 }
1104 
1105 // Now we need to define the native compilation tasks. The set of parameters to
1106 // native compilation depends on the target platform (and also to some extent what platform
1107 // you are compiling on). These settings are contained in various gradle files
1108 // such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
1109 // can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
1110 // that will contain the appropriate flags.
1111 defineProperty(&quot;COMPILE_FLAGS_FILES&quot;, COMPILE_TARGETS.split(&quot;,&quot;).collect {&quot;buildSrc/${it.trim()}.gradle&quot;}.join(&quot;,&quot;))
1112 if (COMPILE_TARGETS == &quot;all&quot;) {
1113     def tmp = []
1114     File buildSrcDir = file(&quot;buildSrc&quot;)
1115     buildSrcDir.listFiles().each { File f -&gt;
1116         if (f.isFile() &amp;&amp; f.name.endsWith(&quot;.gradle&quot;) &amp;&amp; !f.name.equals(&quot;build.gradle&quot;)) {
1117             def target = f.name.substring(0, f.name.lastIndexOf(&#39;.gradle&#39;)).toUpperCase(Locale.ROOT)
1118             apply from: f
1119             if (project.ext[&quot;${target}&quot;].canBuild) {
1120                 tmp.add(target)
1121             }
1122         }
1123     }
1124     COMPILE_FLAGS_FILES = tmp.collect { &quot;buildSrc/${it}.gradle&quot;}.join(&quot;,&quot;)
1125     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1126 } else {
1127     COMPILE_FLAGS_FILES.split(&quot;,&quot;).each {
1128         logger.info(&quot;Applying COMPILE_FLAGS_FILE &#39;$it&#39;&quot;)
1129         apply from: it
1130     }
1131 }
1132 
1133 if (COMPILE_TARGETS != &quot;&quot;) {
1134     def tmp = []
1135     COMPILE_TARGETS.split(&quot;,&quot;).each {target -&gt;
1136         if (project.ext[&quot;${target.toUpperCase(Locale.ROOT)}&quot;].canBuild) {
1137             tmp.add(target)
1138         }
1139     }
1140     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1141 }
1142 
1143 // Sanity check the expected properties all exist
1144 compileTargets { t -&gt;
1145     // Every platform must define these variables
1146     if (!project.hasProperty(t.upper)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${t.name} property&quot;)
1147     def props = project.ext[t.upper];
1148     // TODO: we could remove libDest in favor of modLibDest
1149     [&quot;compileSwing&quot;, &quot;compileSWT&quot;, &quot;libDest&quot;].each { prop -&gt;
1150         if (!props.containsKey(prop)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}&quot;)
1151     }
1152 }
1153 
1154 // Various build flags may be set by the different target files, such as
1155 // whether to build Swing, SWT, etc. We iterate over all
1156 // compile targets and look for these settings in our properties. Note that
1157 // these properties cannot be set from the command line, but are set by
1158 // the target build files such as armv6hf.gradle or mac.gradle.
1159 ext.COMPILE_SWING = false;
1160 ext.COMPILE_SWT = false;
1161 compileTargets { t -&gt;
1162     def targetProperties = project.rootProject.ext[t.upper]
1163 
1164     if (targetProperties.compileSwing) COMPILE_SWING = true
1165     if (targetProperties.compileSWT) COMPILE_SWT = true
1166 
1167     if (!targetProperties.containsKey(&#39;compileWebnodeNative&#39;)) {
1168         // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
1169         targetProperties.compileWebnodeNative = true
1170     }
1171 
1172     if (!targetProperties.containsKey(&#39;compileMediaNative&#39;)) {
1173         // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
1174         targetProperties.compileMediaNative = true
1175     }
1176 
1177     if (!targetProperties.containsKey(&#39;includeSWT&#39;)) targetProperties.includeSWT = true
1178     if (!targetProperties.containsKey(&#39;includeSwing&#39;)) targetProperties.includeSwing = true
1179     if (!targetProperties.containsKey(&#39;includeNull3d&#39;)) targetProperties.includeNull3d = true
1180     if (!targetProperties.containsKey(&#39;includeMonocle&#39;)) targetProperties.includeMonocle = false
1181     if (!targetProperties.containsKey(&#39;includeEGL&#39;)) targetProperties.includeEGL = false
1182 
1183     if (!targetProperties.containsKey(&#39;includeGTK&#39;)) targetProperties.includeGTK = IS_LINUX
1184 
1185     if (!targetProperties.containsKey(&#39;modLibDest&#39;)) targetProperties.modLibDest = targetProperties.libDest
1186 
1187     // This value is used as a prefix for various directories under ./build,
1188     // such as sdk, to allow for a common name for the hosted build
1189     // (for use when building apps) and a unique name for cross builds.
1190     if (rootProject.defaultHostTarget.equals(t.name)) {
1191         // use a simple common default for the &quot;host&quot; build
1192         targetProperties.platformPrefix=&quot;&quot;
1193     } else {
1194         // and a more complex one for cross builds
1195         targetProperties.platformPrefix=&quot;${t.name}-&quot;
1196     }
1197 }
1198 
1199 /******************************************************************************
1200  *                                                                            *
1201  *                         Build Setup Sanity Checks                          *
1202  *                                                                            *
1203  *  Here we do a variety of checks so that if the version of Java you are     *
1204  *  building with is misconfigured, or you are using the wrong version of     *
1205  *  gradle, etc you will get some kind of helpful error / warning message     *
1206  *                                                                            *
1207  *****************************************************************************/
1208 
1209 // Sanity check that we actually have a list of compile targets to execute
1210 if (COMPILE_TARGETS == null || COMPILE_TARGETS == &quot;&quot;) {
1211     throw new Exception(&quot;Unable to determine compilation platform, must specify valid COMPILE_TARGETS!&quot;)
1212 }
1213 
1214 // Verify that CONF is something useful
1215 if (CONF != &quot;Release&quot; &amp;&amp; CONF != &quot;Debug&quot; &amp;&amp; CONF != &quot;DebugNative&quot;) {
1216     logger.warn(&quot;Unknown configuration CONF=&#39;$CONF&#39;. Treating as &#39;Release&#39;&quot;)
1217 }
1218 
1219 // If the number of compile threads is less than 1 then we have a problem!
1220 if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) &lt; 1) {
1221     logger.warn(&quot;NUM_COMPILE_THREADS was specified as &#39;$NUM_COMPILE_THREADS&#39; which is less than the minimum value of 1. &quot; +
1222             &quot;Building with a value of 1 instead.&quot;)
1223     NUM_COMPILE_THREADS = 1
1224 }
1225 
1226 // Check gradle version
1227 if (gradle.gradleVersion != jfxGradleVersion) {
1228     def ver = gradle.gradleVersion.split(&quot;[\\.]&quot;);
1229     def verMin = jfxGradleVersionMin.split(&quot;[\\.]&quot;);
1230     def gradleMajor = Integer.parseInt(ver[0]);
1231     def gradleMinor = Integer.parseInt(ver[1].split(&quot;[^0-9]&quot;)[0]);
1232     def gradleMajorMin = Integer.parseInt(verMin[0]);
1233     def gradleMinorMin = Integer.parseInt(verMin[1].split(&quot;[^0-9]&quot;)[0]);
1234     def err = &quot;&quot;;
1235     if (gradleMajor &lt; gradleMajorMin || (gradleMajor == gradleMajorMin &amp;&amp; gradleMinor &lt; gradleMinorMin)) {
1236         err = &quot;Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}&quot;
1237     }
1238 
1239     if (IS_GRADLE_VERSION_CHECK &amp;&amp; err != &quot;&quot;) {
1240         fail(err);
1241     }
1242 
1243     logger.warn(&quot;*****************************************************************&quot;);
1244     logger.warn(&quot;Unsupported gradle version $gradle.gradleVersion in use.&quot;);
1245     logger.warn(&quot;Only version $jfxGradleVersion is supported. Use this version at your own risk&quot;);
1246     if ( err != &quot;&quot;) logger.warn(err);
1247     logger.warn(&quot;*****************************************************************&quot;);
1248 }
1249 
1250 // Look for stub runtime in bundled sdk, standalone sdk, or boot JDK
1251 
1252 def String cachedBundledRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/modular-sdk&quot;
1253 def String cachedStandaloneRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/sdk&quot;
1254 def String jdkStubRuntime = cygpath(&quot;$JDK_HOME&quot;)
1255 
1256 def defaultStubRuntime = &quot;&quot;
1257 if (file(cachedBundledRuntime).exists()) {
1258     defaultStubRuntime = cachedBundledRuntime
1259 } else if (file(cachedStandaloneRuntime).exists()) {
1260     defaultStubRuntime = cachedStandaloneRuntime
1261 } else if (BUILD_CLOSED) {
1262     defaultStubRuntime = cachedBundledRuntime
1263 } else {
1264     defaultStubRuntime = jdkStubRuntime
1265 }
1266 
1267 defineProperty(&quot;STUB_RUNTIME&quot;, defaultStubRuntime)
1268 
1269 if (STUB_RUNTIME.endsWith(&quot;/modular-sdk&quot;)) {
1270     def stubModulesLib = &quot;$STUB_RUNTIME/modules_libs&quot;
1271     defineProperty(&quot;MEDIA_STUB&quot;, &quot;$stubModulesLib/javafx.media&quot;)
1272     defineProperty(&quot;WEB_STUB&quot;, &quot;$stubModulesLib/javafx.web&quot;)
1273 } else {
1274     def libraryStub = IS_WINDOWS ? &quot;$STUB_RUNTIME/bin&quot; : &quot;$STUB_RUNTIME/lib&quot;
1275 
1276     defineProperty(&quot;MEDIA_STUB&quot;, libraryStub)
1277     defineProperty(&quot;WEB_STUB&quot;, libraryStub)
1278 }
1279 
1280 ext.UPDATE_STUB_CACHE = (BUILD_CLOSED &amp;&amp; STUB_RUNTIME != &quot;&quot; &amp;&amp; !file(STUB_RUNTIME).isDirectory())
1281 
1282 
1283 /******************************************************************************
1284  *                                                                            *
1285  *                      Logging of Properties and Settings                    *
1286  *                                                                            *
1287  *  Log some of the settings we&#39;ve determined. We could log more here, it     *
1288  *  doesn&#39;t really hurt.                                                      *
1289  *                                                                            *
1290  *****************************************************************************/
1291 
1292 logger.quiet(&quot;gradle.gradleVersion: $gradle.gradleVersion&quot;)
1293 logger.quiet(&quot;OS_NAME: $OS_NAME&quot;)
1294 logger.quiet(&quot;OS_ARCH: $OS_ARCH&quot;)
1295 logger.quiet(&quot;JAVA_HOME: $JAVA_HOME&quot;)
1296 logger.quiet(&quot;JDK_HOME: $JDK_HOME&quot;)
1297 logger.quiet(&quot;java.runtime.version: ${javaRuntimeVersion}&quot;)
1298 logger.quiet(&quot;java version: ${javaVersion}&quot;)
1299 logger.quiet(&quot;java build number: ${javaBuildNumber}&quot;)
1300 logger.quiet(&quot;jdk.runtime.version: ${jdkRuntimeVersion}&quot;)
1301 logger.quiet(&quot;jdk version: ${jdkVersion}&quot;)
1302 logger.quiet(&quot;jdk build number: ${jdkBuildNumber}&quot;)
1303 logger.quiet(&quot;minimum jdk version: ${jfxBuildJdkVersionMin}&quot;)
1304 logger.quiet(&quot;minimum jdk build number: ${jfxBuildJdkBuildnumMin}&quot;)
1305 
1306 if (IS_LINUX) {
1307     logger.quiet(&quot;GCC version: ${jfxBuildLinuxGccVersion}&quot;)
1308 } else if (IS_WINDOWS) {
1309     logger.quiet(&quot;MSVC version: ${jfxBuildWindowsMsvcVersion}&quot;)
1310 } else if (IS_MAC) {
1311     logger.quiet(&quot;XCODE version: ${jfxBuildMacosxXcodeVersion}&quot;)
1312 }
1313 logger.quiet(&quot;cmake version: ${jfxBuildCmakeVersion}&quot;)
1314 logger.quiet(&quot;ninja version: ${jfxBuildNinjaVersion}&quot;)
1315 logger.quiet(&quot;ant version: ${jfxBuildAntVersion}&quot;)
1316 
1317 logger.quiet(&quot;HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES&quot;)
1318 logger.quiet(&quot;STUB_RUNTIME: $STUB_RUNTIME&quot;)
1319 logger.quiet(&quot;CONF: $CONF&quot;)
1320 logger.quiet(&quot;NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS&quot;)
1321 logger.quiet(&quot;COMPILE_TARGETS: $COMPILE_TARGETS&quot;)
1322 logger.quiet(&quot;COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES&quot;)
1323 logger.quiet(&quot;HUDSON_JOB_NAME: $HUDSON_JOB_NAME&quot;)
1324 logger.quiet(&quot;HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER&quot;)
1325 logger.quiet(&quot;PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER&quot;)
1326 logger.quiet(&quot;PRODUCT_NAME: $PRODUCT_NAME&quot;)
1327 logger.quiet(&quot;RELEASE_VERSION: $RELEASE_VERSION&quot;)
1328 logger.quiet(&quot;RELEASE_SUFFIX: $RELEASE_SUFFIX&quot;)
1329 logger.quiet(&quot;RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT&quot;)
1330 logger.quiet(&quot;RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG&quot;)
1331 logger.quiet(&quot;RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED&quot;)
1332 logger.quiet(&quot;MAVEN_VERSION: $MAVEN_VERSION&quot;)
1333 logger.quiet(&quot;UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE&quot;)
1334 
1335 /******************************************************************************
1336  *                                                                            *
1337  *                Definition of Native Code Compilation Tasks                 *
1338  *                                                                            *
1339  *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
1340  *      .cpp, or .cc files. It uses the headers provided by running           *
1341  *      &#39;javac -h&#39; plus additional platform specific headers. It will         *
1342  *      compile into .obj files.                                              *
1343  *    - LinkTask will perform native linking and create the .dll / .so /      *
1344  *      .dylib as necessary.                                                  *
1345  *                                                                            *
1346  *****************************************************************************/
1347 
1348 // Save a reference to the buildSrc.jar file because we need it for actually
1349 // compiling things, not just for the sake of this build script
1350 // (such as generating the JSL files, etc)
1351 ext.BUILD_SRC = rootProject.files(&quot;buildSrc/build/libs/buildSrc.jar&quot;)
1352 
1353 /**
1354  * Convenience method for creating cc, link, and &quot;native&quot; tasks in the given project. These
1355  * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc
1356  * named tasks.
1357  *
1358  * @param project The project to add tasks to
1359  * @param name The name of the project, such as &quot;prism-common&quot;. This name is used
1360  *        in the name of the generated task, such as ccPrismCommon, and also
1361  *        in the name of the final library, such as libprism-common.dylib.
1362  */
1363 void addNative(Project project, String name) {
1364     // TODO if we want to handle 32/64 bit windows in the same build,
1365     // Then we will need to modify the win compile target to be win32 or win64
1366     def capitalName = name.split(&quot;-&quot;).collect{it.capitalize()}.join()
1367     def nativeTask = project.task(&quot;native$capitalName&quot;, group: &quot;Build&quot;) {
1368         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets&quot;
1369     }
1370     def cleanTask = project.task(&quot;cleanNative$capitalName&quot;, type: Delete, group: &quot;Build&quot;) {
1371         description = &quot;Clean native objects for $name&quot;
1372     }
1373     if (project.hasProperty(&quot;nativeAllTask&quot;)) project.nativeAllTask.dependsOn nativeTask
1374     project.assemble.dependsOn(nativeTask)
1375     if (project.hasProperty(&quot;cleanNativeAllTask&quot;)) project.cleanNativeAllTask.dependsOn cleanTask
1376 
1377     // Each of the different compile targets will be placed in a sub directory
1378     // of these root dirs, with the name of the dir being the name of the target
1379     def nativeRootDir = project.file(&quot;$project.buildDir/native/$name&quot;)
1380     def libRootDir = project.file(&quot;$project.buildDir/libs/$name&quot;)
1381     // For each compile target, create a cc / link pair
1382     compileTargets { t -&gt;
1383         def targetProperties = project.rootProject.ext[t.upper]
1384         def library = targetProperties.library
1385         def properties = targetProperties.get(name)
1386         def nativeDir = file(&quot;$nativeRootDir/${t.name}&quot;)
1387         def headerDir = file(&quot;${project.buildDir}/gensrc/headers/${project.moduleName}&quot;)
1388 
1389         // If there is not a library clause in the properties, assume it is not wanted
1390         if (!targetProperties.containsKey(name)) {
1391             println(&quot;Ignoring native library ${name}. Not defined in ${t.name} project properties&quot;);
1392             return
1393         }
1394 
1395         // check for the property disable${name} = true
1396         def String disableKey = &quot;disable${name}&quot;
1397         def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
1398         if (disabled) {
1399             println(&quot;Native library ${name} disabled in ${t.name} project properties&quot;);
1400             return
1401         }
1402 
1403         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
1404         variants.each { variant -&gt;
1405             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
1406             def capitalVariant = variant.capitalize()
1407             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
1408             def ccTask = project.task(&quot;cc${t.capital}$capitalName$capitalVariant&quot;, type: CCTask, group: &quot;Build&quot;) {
1409                 description = &quot;Compiles native sources for ${name} for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1410                 matches = &quot;.*\\.c|.*\\.cpp|.*\\.m|.*\\.cc&quot;
1411                 headers = headerDir
1412                 output(ccOutput)
1413                 params.addAll(variantProperties.ccFlags)
1414                 compiler = variantProperties.compiler
1415                 source(variantProperties.nativeSource)
1416                 cleanTask.delete ccOutput
1417             }
1418             def linkTask = project.task(&quot;link${t.capital}$capitalName$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask, group: &quot;Build&quot;) {
1419                 description = &quot;Creates native dynamic library for $name for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1420                 objectDir = ccOutput
1421                 linkParams.addAll(variantProperties.linkFlags)
1422                 lib = file(&quot;$libRootDir/${t.name}/${variant == &#39;&#39; ? library(properties.lib) : library(variantProperties.lib)}&quot;)
1423                 linker = variantProperties.linker
1424                 cleanTask.delete &quot;$libRootDir/${t.name}&quot;
1425             }
1426             nativeTask.dependsOn(linkTask)
1427             if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
1428                 def rcTask = project.task(&quot;rc$capitalName$capitalVariant&quot;, type: CompileResourceTask, group: &quot;Build&quot;) {
1429                     description = &quot;Compiles native sources for $name&quot;
1430                     matches = &quot;.*\\.rc&quot;
1431                     compiler = variantProperties.rcCompiler
1432                     source(variantProperties.rcSource)
1433                     if (variantProperties.rcFlags) {
1434                         rcParams.addAll(variantProperties.rcFlags)
1435                     }
1436                     output(ccOutput)
1437                 }
1438                 linkTask.dependsOn rcTask;
1439             }
1440         }
1441 
1442         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
1443         if (useLipo) {
1444             def lipoTask = project.task(&quot;lipo${t.capital}$capitalName&quot;, type: LipoTask, group: &quot;Build&quot;) {
1445                 description = &quot;Creates native fat library for $name for ${t.name}&quot;
1446                 libDir = file(&quot;$libRootDir/${t.name}&quot;)
1447                 lib = file(&quot;$libRootDir/${t.name}/${library(properties.lib)}&quot;)
1448             }
1449             nativeTask.dependsOn(lipoTask)
1450         }
1451     }
1452 }
1453 
1454 void addJSL(Project project, String name, String pkg, List&lt;String&gt; addExports, Closure compile) {
1455     def lowerName = name.toLowerCase()
1456 
1457     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
1458     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
1459     def compileCompilers = project.task(&quot;compile${name}Compilers&quot;,
1460             type: JavaCompile,
1461             dependsOn: project.compileJava) {
1462         description = &quot;Compile the $name JSL Compilers&quot;
1463 
1464         classpath =
1465                project.files(project.sourceSets.jslc.java.outputDir) +
1466                project.configurations.antlr
1467         source = [project.file(&quot;src/main/jsl-$lowerName&quot;)]
1468         destinationDir = project.file(&quot;$project.buildDir/classes/jsl-compilers/$lowerName&quot;)
1469 
1470         options.compilerArgs.addAll([
1471             &quot;-implicit:none&quot;,
1472             &quot;--module-path&quot;, modulePath,
1473             &quot;--add-modules=javafx.graphics&quot;
1474             ])
1475         if (addExports != null) {
1476             options.compilerArgs.addAll(addExports)
1477         }
1478     }
1479 
1480     def generateShaders = project.task(&quot;generate${name}Shaders&quot;,
1481             dependsOn: compileCompilers) {
1482         description = &quot;Generate $name shaders from JSL&quot;
1483         def sourceDir = project.file(&quot;src/main/jsl-$lowerName&quot;)
1484         def destinationDir = project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;)
1485         inputs.dir sourceDir
1486         outputs.dir destinationDir
1487         doLast {
1488             compile(sourceDir, destinationDir)
1489         }
1490     }
1491 
1492     def compileHLSLShaders = project.task(&quot;compile${name}HLSLShaders&quot;,
1493             dependsOn: generateShaders,
1494             type: CompileHLSLTask) {
1495         enabled = IS_WINDOWS
1496         description = &quot;Compile $name HLSL files into .obj files&quot;
1497         matches = &quot;.*\\.hlsl&quot;
1498         output project.file(&quot;$project.buildDir/hlsl/$name/$pkg&quot;)
1499         source project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName/$pkg&quot;)
1500     }
1501 
1502     def processShaders = project.task(&quot;process${name}Shaders&quot;,
1503             dependsOn: [generateShaders, compileHLSLShaders],
1504             type: Copy,
1505             description: &quot;Copy hlsl / frag shaders to build/resources/jsl-$lowerName&quot;) {
1506         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1507             include &quot;**/*.obj&quot;
1508         }
1509         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1510             include(&quot;**/*.frag&quot;)
1511         }
1512         into project.moduleDir
1513     }
1514 
1515     project.processShaders.dependsOn(processShaders)
1516     project.sourceSets.shaders.output.dir(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;, builtBy: processShaders )
1517 
1518     def processShimsShaders = project.task(&quot;process${name}ShimsShaders&quot;,
1519             dependsOn: [generateShaders, compileHLSLShaders],
1520             type: Copy,
1521             description: &quot;Copy hlsl / frag shaders to shims&quot;) {
1522         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1523             include &quot;**/*.obj&quot;
1524         }
1525         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1526             include(&quot;**/*.frag&quot;)
1527         }
1528         into project.moduleShimsDir
1529     }
1530 
1531     project.processShimsShaders.dependsOn(processShimsShaders)
1532 
1533 }
1534 
1535 void addMavenPublication(Project project, List&lt;String&gt; projectDependencies) {
1536     project.apply plugin: &#39;maven-publish&#39;
1537 
1538     project.group = MAVEN_GROUP_ID
1539     project.version = MAVEN_VERSION
1540 
1541     if (project.name == &#39;base&#39;) {
1542         project.publishing {
1543             publications {
1544                 javafx(MavenPublication) {
1545                     artifactId = &#39;javafx&#39;
1546                     artifacts = []
1547                 }
1548             }
1549         }
1550     }
1551 
1552     gradle.taskGraph.whenReady { g -&gt;
1553         project.tasks.findAll { it.name == &#39;generatePomFileForJavafxPublication&#39;}.each { it -&gt;
1554             it.doLast {
1555                 copy {
1556                     into project.file(&quot;${project.buildDir}/publications/javafx&quot;)
1557                     from file(&quot;${rootProject.projectDir}/javafx.pom&quot;)
1558                     rename &quot;javafx.pom&quot;, &quot;pom-default.xml&quot;
1559                     filter { line -&gt;
1560                         line.replaceAll(&quot;@VERSION@&quot;, MAVEN_VERSION)
1561                     }
1562                 }
1563             }
1564         }
1565     }
1566 
1567     project.publishing {
1568         repositories {
1569             maven {
1570                 def repositoryUrl = project.hasProperty(&#39;repositoryUrl&#39;) ? project.getProperty(&#39;repositoryUrl&#39;) : &quot;&quot;
1571                 def repositoryUsername = project.hasProperty(&#39;repositoryUsername&#39;) ? project.getProperty(&#39;repositoryUsername&#39;) : &quot;&quot;
1572                 def repositoryPassword = project.hasProperty(&#39;repositoryPassword&#39;) ? project.getProperty(&#39;repositoryPassword&#39;) : &quot;&quot;
1573                 url repositoryUrl
1574                 credentials {
1575                    username repositoryUsername
1576                    password repositoryPassword
1577                 }
1578             }
1579         }
1580     }
1581 
1582     compileTargets { t -&gt;
1583         project.publishing {
1584             publications {
1585                 maven(MavenPublication) {
1586                     artifactId = &quot;javafx-${project.name}&quot;
1587 
1588                     afterEvaluate {
1589                         artifact project.tasks.&quot;moduleEmptyPublicationJar$t.capital&quot;
1590                         artifact project.tasks.&quot;modularPublicationJar$t.capital&quot; {
1591                             classifier &quot;$t.name&quot;
1592                         }
1593                     }
1594 
1595                     pom.withXml {
1596                         Node parent = asNode().appendNode(&quot;parent&quot;)
1597                         parent.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1598                         parent.appendNode(&quot;artifactId&quot;, &quot;javafx&quot;)
1599                         parent.appendNode(&quot;version&quot;, MAVEN_VERSION)
1600 
1601                         Node dependencies = asNode().appendNode(&quot;dependencies&quot;)
1602 
1603                         Node projectDependencyPlatform = dependencies.appendNode(&quot;dependency&quot;)
1604                         projectDependencyPlatform.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1605                         projectDependencyPlatform.appendNode(&quot;artifactId&quot;, &quot;javafx-${project.name}&quot;)
1606                         projectDependencyPlatform.appendNode(&quot;version&quot;, MAVEN_VERSION)
1607                         projectDependencyPlatform.appendNode(&quot;classifier&quot;, &quot;\${javafx.platform}&quot;)
1608 
1609                         if (!projectDependencies.empty) {
1610                             projectDependencies.each { dep -&gt;
1611                                 Node projectDependency = dependencies.appendNode(&quot;dependency&quot;)
1612                                 projectDependency.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1613                                 projectDependency.appendNode(&quot;artifactId&quot;, &quot;javafx-$dep&quot;)
1614                                 projectDependency.appendNode(&quot;version&quot;, MAVEN_VERSION)
1615                            }
1616                         }
1617                     }
1618                 }
1619             }
1620 
1621         }
1622     }
1623 }
1624 
1625 /**
1626  * Verifies that all of the *.java files in a source tree have the
1627  * correct package name. If not, fail the build.
1628  *
1629  * @param sourceRoot the root of the source tree to check
1630  * @param hasModuleName true if the sources under sourceRoot are being
1631  * compiled as modules, with the immediate child directories being the
1632  * root(s) of the named modules being compiled. In this case the package
1633  * root is one directory below the sourceRoot.
1634  */
1635 void validatePackages(File sourceRoot, boolean hasModuleName) {
1636     if (!sourceRoot.isDirectory()) {
1637         return;
1638     }
1639     def err = false;
1640     String sourceString = sourceRoot.toString().replace(&quot;\\&quot;, &quot;/&quot;)
1641     def startPos = sourceString.length() + 1
1642     logger.info(&quot;validating packages for ${sourceRoot}&quot;)
1643     def inputFiles = fileTree(dir: sourceRoot, include: &quot;**/*.java&quot;)
1644     inputFiles.each { file -&gt;
1645         def packageRoot = file.toString().replace(&quot;\\&quot;, &quot;/&quot;).substring(startPos)
1646         if (hasModuleName) {
1647             packageRoot = packageRoot.substring(packageRoot.indexOf(&quot;/&quot;) + 1)
1648         }
1649         def endPos = packageRoot.lastIndexOf(&quot;/&quot;)
1650         def pkgEx = endPos &gt; -1 ?  packageRoot.substring(0, endPos).replace(&quot;/&quot;, &quot;.&quot;) : &quot;&quot;
1651         def pkg = &quot;&quot;
1652         file.withReader { reader -&gt;
1653             def line
1654             while ((line = reader.readLine()) != null) {
1655                 def words = line.trim().split(&quot;[ ;]+&quot;)
1656                 if (words.length &gt; 1 &amp;&amp; words[0] == &quot;package&quot;) {
1657                     pkg = words[1]
1658                     break;
1659                 }
1660             }
1661         }
1662         if (pkg != pkgEx) {
1663             err = true
1664             println &quot;*** ERROR: File location &lt;${file}&gt; does not match package name &lt;${pkg}&gt;&quot;
1665         }
1666     }
1667     if (err) {
1668         fail(&quot;Package validation failed&quot;)
1669     }
1670 }
1671 
1672 /**
1673  * Add a task to the given project to validate that the package names
1674  * of all java files in the given source sets have the correct package
1675  * name. If not, fail the build.
1676  */
1677 void addValidateSourceSets(Project project,
1678                            Collection&lt;SourceSet&gt; sourceSets,
1679                            Collection&lt;SourceSet&gt; modSourceSets) {
1680     def validateSourceSetsTask = project.task(&quot;validateSourceSets&quot;) {
1681         doLast {
1682             // Accumulate the root directories from all sourceSets.
1683             // We use a Set to elide duplicates (the shims sourceset
1684             // will include the dirs from the main sourceset)
1685             Set&lt;File&gt; sourceRoots = []
1686             sourceSets.each { srcSet -&gt;
1687                 srcSet.java.srcDirs.each { rootDir -&gt;
1688                     sourceRoots += rootDir
1689                 }
1690             }
1691             sourceRoots.each { rootDir -&gt;
1692                 validatePackages(rootDir, false)
1693             }
1694 
1695             Set&lt;File&gt; modSourceRoots = []
1696             modSourceSets.each { srcSet -&gt;
1697                 srcSet.java.srcDirs.each { rootDir -&gt;
1698                     modSourceRoots += rootDir
1699                 }
1700             }
1701             modSourceRoots.each { rootDir -&gt;
1702                 validatePackages(rootDir, true)
1703             }
1704         }
1705     }
1706 
1707     // Run this for all projects when compiling the test sources
1708     // (i.e., when running &quot;gradle test&quot;)
1709     project.compileTestJava.dependsOn(validateSourceSetsTask)
1710 }
1711 
1712 void addValidateSourceSets(Project project, Collection&lt;SourceSet&gt; sourceSets) {
1713     addValidateSourceSets(project, sourceSets, []);
1714 }
1715 
1716 
1717 /**
1718  * Parses a JDK version string. The string must be in one of the following
1719  * two formats:
1720  *
1721  *     major.minor.subminor
1722  * or
1723  *     major.minor.subminor_update
1724  *
1725  * In both cases a list of 4 integers is returned, with element 3 set to
1726  * 0 in the former case.
1727  */
1728 List parseJdkVersion(String version) {
1729     def arr = version.split(&quot;[_\\.]&quot;);
1730     def intArr = [];
1731     arr.each { s -&gt; intArr += Integer.parseInt(s); }
1732     while (intArr.size() &lt; 4) intArr += 0;
1733     return intArr;
1734 }
1735 
1736 /**
1737  * Returns -1, 0, or 1 depending on whether JDK version &quot;a&quot; is less than,
1738  * equal to, or grater than version &quot;b&quot;.
1739  */
1740 int compareJdkVersion(String a, String b) {
1741     def aIntArr = parseJdkVersion(a);
1742     def bIntArr = parseJdkVersion(b);
1743 
1744     for (int i = 0; i &lt; 4; i++) {
1745         if (aIntArr[i] &lt; bIntArr[i]) return -1;
1746         if (aIntArr[i] &gt; bIntArr[i]) return  1;
1747     }
1748     return 0;
1749 }
1750 
1751 // Task to verify the minimum level of Java needed to build JavaFX
1752 task verifyJava() {
1753     doLast {
1754         def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
1755         if (status &lt; 0) {
1756             fail(&quot;java version mismatch: JDK version (${jdkVersion}) &lt; minimum version (${jfxBuildJdkVersionMin})&quot;)
1757         } else if (status == 0) {
1758             def buildNum = Integer.parseInt(jdkBuildNumber)
1759             def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
1760             if (buildNum != 0 &amp;&amp; buildNum &lt; minBuildNum) {
1761                 fail(&quot;JDK build number ($buildNum) &lt; minimum build number ($minBuildNum)&quot;)
1762             }
1763         }
1764     }
1765 }
1766 
1767 task updateCacheIfNeeded() {
1768     // an empty task we can add to as needed for UPDATE_STUB_CACHE
1769 }
1770 
1771 task createTestArgfiles {
1772     // an empty task we can add to as needed
1773 }
1774 
1775 
1776 /*****************************************************************************
1777 *        Project definitions (dependencies, etc)                             *
1778 *****************************************************************************/
1779 
1780 void addJCov(p, test) {
1781     test.doFirst {
1782         def jcovJVMArgument =
1783                 &quot;include=javafx,&quot; +
1784                 &quot;include=com.sun.javafx,&quot; +
1785                 &quot;include=com.sun.glass,&quot; +
1786                 &quot;include=com.sun.openpisces,&quot; +
1787                 &quot;include=com.sun.pisces,&quot; +
1788                 &quot;include=com.sun.prism,&quot; +
1789                 &quot;include=com.sun.scenario,&quot; +
1790                 &quot;include=com.sun.webkit,&quot; +
1791                 &quot;exclude=com,&quot; +
1792                 &quot;exclude=java,&quot; +
1793                 &quot;exclude=javax,&quot; +
1794                 &quot;exclude=\&quot;**.test\&quot;,&quot; +
1795                 &quot;exclude=\&quot;**.*Test\&quot;,&quot; +
1796                 &quot;file=build/reports/jcov/report.xml,&quot; +
1797                 &quot;merge=merge&quot;;
1798         test.jvmArgs(&quot;-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) }}=$jcovJVMArgument&quot;);
1799         p.mkdir p.file(&quot;build/reports/jcov&quot;)
1800     }
1801     test.doLast {
1802         def reportFile = p.file(&quot;build/reports/jcov/report.xml&quot;)
1803         if (reportFile.exists()) {
1804             p.javaexec {
1805                 workingDir = p.file(&quot;build/reports/jcov&quot;)
1806                 classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) })
1807                 main = &quot;com.sun.tdk.jcov.Helper&quot;
1808                 args = [
1809                         &quot;RepGen&quot;,
1810                         &quot;-exclude&quot;, &quot;\&quot;**.test\&quot;&quot;,
1811                         &quot;-exclude&quot;, &quot;\&quot;**.*Test\&quot;&quot;,
1812                         &quot;-output&quot;, &quot;.&quot;,
1813                         &quot;-source&quot;, p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(&quot;:&quot;),
1814                         &quot;report.xml&quot;
1815                 ]
1816             }
1817         }
1818     }
1819 }
1820 
1821 allprojects {
1822 
1823     // Setup the repositories that we&#39;ll download libraries from.
1824     // By default we use Maven Central for most things. The custom &quot;ivy&quot;
1825     // repo is for downloading SWT. The way it works is to setup the
1826     // download URL such that it will resolve to the actual jar file to
1827     // download. See SWT_FILE_NAME for the name of the jar that will be
1828     // used as the &quot;artifact&quot; in the pattern below.
1829     // If JFX_DEPS_URL is set, then that overrides the default
1830     // repositories. This allows the dependencies to be cached locally.
1831 
1832     if (JFX_DEPS_URL != &quot;&quot;) {
1833         repositories {
1834             ivy {
1835                 url JFX_DEPS_URL
1836                 metadataSources {
1837                     artifact()
1838                 }
1839                 patternLayout {
1840                     artifact &quot;[artifact]-[revision](-[classifier]).[ext]&quot;
1841                     artifact &quot;[artifact].[ext]&quot;
1842                 }
1843             }
1844         }
1845     }
1846 
1847     if (JFX_DEPS_URL == &quot;&quot;) {
1848         repositories {
1849             mavenCentral()
1850             ivy {
1851                 url &quot;https://download.eclipse.org/eclipse/updates/4.6/R-4.6.3-201703010400/plugins/&quot;
1852                 metadataSources {
1853                     artifact()
1854                 }
1855                 patternLayout {
1856                     artifact &quot;[artifact].[ext]&quot;
1857                 }
1858             }
1859         }
1860     }
1861 
1862     if (JFX_DEPS_URL == &quot;&quot; &amp;&amp; IS_BUILD_LIBAV_STUBS) {
1863         repositories {
1864             ivy {
1865                 url libAVRepositoryURL
1866                 metadataSources {
1867                     artifact()
1868                 }
1869                 patternLayout {
1870                     artifact &quot;[artifact].[ext]&quot;
1871                 }
1872             }
1873             ivy {
1874                 url FFmpegRepositoryURL
1875                 metadataSources {
1876                     artifact()
1877                 }
1878                 patternLayout {
1879                     artifact &quot;[artifact].[ext]&quot;
1880                 }
1881             }
1882         }
1883     }
1884 
1885     // We want to configure all projects as java projects and use the same compile settings
1886     // etc, except for the root project which we just want to ignore (and for now media)
1887     if (project == rootProject) {
1888        return
1889     }
1890     if (project.path.startsWith(&quot;:apps&quot;)) {
1891         // Lets handle the apps tree differently, as it is a collection of ant builds,
1892         // and the ant importer collides with the &#39;apply plugin:java&#39;
1893         return
1894     }
1895 
1896     // All of our projects are java projects
1897 
1898     apply plugin: &quot;java&quot;
1899     sourceCompatibility = 11
1900 
1901     // By default all of our projects require junit for testing so we can just
1902     // setup this dependency here.
1903     dependencies {
1904         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1905         if (BUILD_CLOSED &amp;&amp; DO_JCOV)  {
1906             testCompile name: &quot;jcov&quot;
1907         }
1908     }
1909 
1910     compileJava.dependsOn verifyJava
1911 
1912     // At the moment the ASM library shipped with Gradle that is used to
1913     // discover the different test classes fails on Java 8, so in order
1914     // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
1915     // and manually specify the includes / excludes. At the moment we use
1916     // Java 7 but when we switch to 8 this will be needed, and probably again when
1917     // we start building with Java 9.
1918     test {
1919         executable = JAVA;
1920         enableAssertions = true;
1921         testLogging.exceptionFormat = &quot;full&quot;;
1922         scanForTestClasses = false;
1923         include(&quot;**/*Test.*&quot;);
1924         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
1925             addJCov(project, test)
1926         }
1927 
1928         if (IS_HEADLESS_TEST) {
1929             systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
1930             systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
1931             systemProperty &#39;prism.order&#39;, &#39;sw&#39;
1932             systemProperty &#39;com.sun.javafx.gestures.zoom&#39;, &#39;true&#39;
1933             systemProperty &#39;com.sun.javafx.gestures.rotate&#39;, &#39;true&#39;
1934             systemProperty &#39;com.sun.javafx.gestures.scroll&#39;, &#39;true&#39;
1935         }
1936 
1937         systemProperty &#39;unstable.test&#39;, IS_UNSTABLE_TEST
1938     }
1939 
1940     compileTestJava {
1941     }
1942 }
1943 
1944 // These strings define the module-source-path to be used in compilation.
1945 // They need to contain the full paths to the sources and the * will be
1946 // used to infer the module name that is used.
1947 project.ext.defaultModuleSourcePath =
1948     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1949         File.pathSeparator  +
1950     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1951 
1952 // graphics pass one
1953 project.ext.defaultModuleSourcePath_GraphicsOne =
1954     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1955         File.pathSeparator  +
1956     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1957 
1958 // web pass one
1959 project.ext.defaultModuleSourcePath_WebOne =
1960     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;)
1961 
1962 // Compiling the test shim files too.
1963 project.ext.defaultModuleSourcePathShim =
1964     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/{main,shims}/java&#39;) +
1965         File.pathSeparator  +
1966     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1967 
1968 // The &quot;base&quot; project is our first module and the most basic one required for
1969 // all other modules. It is useful even for non-GUI applications.
1970 project(&quot;:base&quot;) {
1971     project.ext.buildModule = true
1972     project.ext.includeSources = true
1973     project.ext.moduleRuntime = true
1974     project.ext.moduleName = &quot;javafx.base&quot;
1975 
1976     sourceSets {
1977         main
1978         shims {
1979             java {
1980                 compileClasspath += sourceSets.main.output
1981                 runtimeClasspath += sourceSets.main.output
1982             }
1983         }
1984         test {
1985             java {
1986                 compileClasspath += sourceSets.shims.output
1987                 runtimeClasspath += sourceSets.shims.output
1988             }
1989         }
1990     }
1991 
1992     dependencies {
1993         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1994         testCompile sourceSets.main.output
1995         testCompile sourceSets.shims.output
1996     }
1997 
1998     commonModuleSetup(project, [ &#39;base&#39; ])
1999 
2000     project.ext.moduleSourcePath = defaultModuleSourcePath
2001     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2002 
2003     // We need to take the VersionInfo.java file and replace the various
2004     // properties within it
2005     def replacements = [
2006         &quot;BUILD_TIMESTAMP&quot;: BUILD_TIMESTAMP,
2007         &quot;HUDSON_JOB_NAME&quot;: HUDSON_JOB_NAME,
2008         &quot;HUDSON_BUILD_NUMBER&quot;: HUDSON_BUILD_NUMBER,
2009         &quot;PROMOTED_BUILD_NUMBER&quot;: PROMOTED_BUILD_NUMBER,
2010         &quot;PRODUCT_NAME&quot;: PRODUCT_NAME,
2011         &quot;RELEASE_VERSION&quot;: RELEASE_VERSION,
2012         &quot;RELEASE_SUFFIX&quot;: RELEASE_SUFFIX];
2013     task processVersionInfo(type: Copy, description: &quot;Replace params in VersionInfo and copy file to destination&quot;) {
2014         doFirst { mkdir &quot;$buildDir/gensrc/java&quot; }
2015         from &quot;src/main/version-info&quot;
2016         into &quot;$buildDir/gensrc/java/com/sun/javafx/runtime&quot;
2017         filter {line-&gt;
2018             replacements.each() {k, v -&gt;
2019                 line = line.replace(&quot;@$k@&quot;, v.toString());
2020             }
2021             line
2022         }
2023     }
2024 
2025     // Make sure to include $buildDir/gensrc/java that we previously created.
2026     // We DO NOT want to include src/main/version-info
2027 
2028     sourceSets.main.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
2029 
2030     compileJava.dependsOn processVersionInfo
2031     addMavenPublication(project, [])
2032 
2033     addValidateSourceSets(project, sourceSets)
2034 }
2035 
2036 // The graphics module is needed for any graphical JavaFX application. It requires
2037 // the base module and includes the scene graph, layout, css, prism, windowing, etc.
2038 // This is a fairly complicated module. There are many different types of native components
2039 // that all need to be compiled.
2040 project(&quot;:graphics&quot;) {
2041 
2042     project.ext.buildModule = true
2043     project.ext.includeSources = true
2044     project.ext.moduleRuntime = true
2045     project.ext.moduleName = &quot;javafx.graphics&quot;
2046     project.ext.mavenPublish = true
2047 
2048     getConfigurations().create(&quot;antlr&quot;);
2049 
2050     sourceSets {
2051         jslc   // JSLC gramar subset
2052         main
2053         shims {
2054             java {
2055                 compileClasspath += sourceSets.main.output
2056                 runtimeClasspath += sourceSets.main.output
2057             }
2058         }
2059         shaders // generated shaders (prism &amp; decora)
2060         test {
2061             java {
2062                 compileClasspath += sourceSets.shims.output
2063                 runtimeClasspath += sourceSets.shims.output
2064             }
2065         }
2066         stub
2067     }
2068 
2069     dependencies {
2070         stubCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2071 
2072         antlr group: &quot;org.antlr&quot;, name: &quot;antlr4&quot;, version: &quot;4.7.2&quot;, classifier: &quot;complete&quot;
2073         compile project(&#39;:base&#39;)
2074     }
2075 
2076     project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne
2077     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2078 
2079     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2080 
2081     List&lt;String&gt; decoraAddExports = [
2082             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED&#39;,
2083             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED&#39;,
2084             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED&#39;
2085             ]
2086     /*
2087     Graphics compilation is &quot;complicated&quot; by the generated shaders.
2088 
2089     We have two shader groups - Decora and Prism.
2090 
2091     The shader groups each will generate a custom compiler that
2092     then genarates the shader code. These compilers rely on the JSLC
2093     gramar parser which is antlr generated and compile separately.
2094 
2095     The decora compiler relies on compileJava - which is sourceSet.main.java
2096     It also accesses module private packages, so will need add-exports
2097 
2098     Once the shader java code is generated, we can compileFullJava
2099 
2100     After that, we can generate the required native header and then build the native code
2101     */
2102 
2103     project.task(&quot;processShaders&quot;) {
2104         // an empty task to hang the prism and decora shaders on
2105     }
2106 
2107     project.task(&quot;processShimsShaders&quot;) {
2108         // an empty task to hang the prism and decora shaders on
2109     }
2110 
2111     compileShimsJava.dependsOn(&quot;processShimsShaders&quot;)
2112 
2113     // Generate the JSLC support grammar
2114     project.task(&quot;generateGrammarSource&quot;, type: JavaExec) {
2115         // use antlr to generate our grammar.
2116         // note: the antlr plugin creates some issues with the other compiles
2117         // so we will do this by hand
2118 
2119         File wd = file(project.projectDir.path + &quot;/src/jslc/antlr&quot;)
2120         File outDir = file(&quot;$buildDir/gensrc/antlr&quot;)
2121         def inJSL = &quot;com/sun/scenario/effect/compiler/JSL.g4&quot;
2122         if (IS_WINDOWS) {
2123             // antlr needs backslashes on Windows
2124             inJSL = inJSL.replace(&quot;/&quot;, &quot;\\&quot;)
2125         }
2126 
2127         executable = JAVA
2128         classpath = project.configurations.antlr
2129         workingDir = wd
2130         main = &quot;org.antlr.v4.Tool&quot;
2131 
2132         args = [
2133             &quot;-o&quot;,
2134             outDir.toString(),
2135             &quot;-package&quot;,
2136             &quot;com.sun.scenario.effect.compiler&quot;,
2137             &quot;-visitor&quot;,
2138             inJSL ]
2139 
2140         inputs.dir wd
2141         outputs.dir outDir
2142     }
2143     sourceSets.jslc.java.srcDirs += &quot;$buildDir/gensrc/antlr&quot;
2144 
2145     // and compile the JSLC support classes
2146     compileJslcJava.dependsOn(generateGrammarSource)
2147     compileJslcJava.classpath = project.configurations.antlr
2148 
2149     compileJava.dependsOn(compileJslcJava)
2150 
2151     // this task is the &quot;second pass&quot; compile of all of the module classes
2152     project.task(&quot;compileFullJava&quot;, type: JavaCompile, dependsOn: processShaders) {
2153         description = &quot;Compile all of the graphics java classes - main and shaders&quot;
2154 
2155         classpath = configurations.compile
2156 
2157         source = project.sourceSets.main.java.srcDirs
2158         source += &quot;$buildDir/gensrc/java&quot;
2159         source += project.sourceSets.shaders.output
2160 
2161         destinationDir = project.sourceSets.main.java.outputDir
2162         options.compilerArgs.addAll([
2163             &#39;-h&#39;, &quot;$buildDir/gensrc/headers/&quot;,  // Note: this creates the native headers
2164             &#39;-implicit:none&#39;,
2165             &#39;--module-source-path&#39;, defaultModuleSourcePath
2166             ] )
2167     }
2168     classes.dependsOn(compileFullJava)
2169 
2170     project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output
2171     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-prism&quot;
2172     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-decora&quot;
2173 
2174     compileShimsJava.dependsOn(compileFullJava)
2175 
2176     // Create a single &quot;native&quot; task which will depend on all the individual native tasks for graphics
2177     project.ext.nativeAllTask = task(&quot;native&quot;, group: &quot;Build&quot;, description: &quot;Compiles and Builds all native libraries for Graphics&quot;);
2178     project.ext.cleanNativeAllTask = task(&quot;cleanNative&quot;, group: &quot;Build&quot;, description: &quot;Clean all native libraries and objects for Graphics&quot;);
2179 
2180     // Add tasks for native compilation
2181     addNative(project, &quot;glass&quot;);
2182     addNative(project, &quot;prism&quot;)
2183     addNative(project, &quot;prismSW&quot;)
2184     addNative(project, &quot;font&quot;)
2185     addNative(project, &quot;iio&quot;)
2186     addNative(project, &quot;prismES2&quot;)
2187 
2188     if (IS_COMPILE_PANGO) {
2189         addNative(project, &quot;fontFreetype&quot;)
2190         addNative(project, &quot;fontPango&quot;)
2191     }
2192 
2193     if (IS_WINDOWS) {
2194         addNative(project, &quot;prismD3D&quot;)
2195         // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
2196         task generateD3DHeaders(group: &quot;Build&quot;) {
2197             enabled = IS_WINDOWS
2198             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;
2199             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;
2200             inputs.file &quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;
2201             outputs.dir &quot;$buildDir/headers/PrismD3D/&quot;
2202             outputs.dir &quot;$buildDir/headers/PrismD3D/hlsl/&quot;
2203             description = &quot;Generate headers by compiling hlsl files&quot;
2204             doLast {
2205                 mkdir file(&quot;$buildDir/headers/PrismD3D/hlsl&quot;)
2206                 def PS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;)
2207                 def VS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;)
2208                 def PASSTHROUGH_VS_SRC = file(&quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;)
2209                 def jobs = [
2210                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/PassThroughVS.h&quot;, &quot;/E&quot;, &quot;passThrough&quot;, &quot;$PASSTHROUGH_VS_SRC&quot;],
2211                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2212                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2213                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2214                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2215                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2216                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2217                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2218                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2219                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2220                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2221                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2222                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2223                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2224                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2225                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2226                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2227                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2228                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2229                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2230                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2231                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2232                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2233                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2234                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2235                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2236                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2237                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2238                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2239                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2240                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2241                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2242                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2243                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2244                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2245                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2246                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2247                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2248                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2249                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2250                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2251                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2252                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2253                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2254                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2255                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2256                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2257                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2258                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2259                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2260                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2261                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h&quot;, &quot;/DVertexType=ObjVertex&quot;, &quot;$VS_3D_SRC&quot;]
2262                 ]
2263                 final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
2264                 final CountDownLatch latch = new CountDownLatch(jobs.size());
2265                 List futures = new ArrayList&lt;Future&gt;();
2266                 jobs.each { cmd -&gt;
2267                     futures.add(executor.submit(new Runnable() {
2268                         @Override public void run() {
2269                             try {
2270                                 exec {
2271                                     commandLine cmd
2272                                 }
2273                             } finally {
2274                                 latch.countDown();
2275                             }
2276                         }
2277                     }));
2278                 }
2279                 latch.await();
2280                 // Looking for whether an exception occurred while executing any of the futures.
2281                 // By calling &quot;get()&quot; on each future an exception will be thrown if one had occurred
2282                 // on the background thread.
2283                 futures.each {it.get();}
2284             }
2285         }
2286 
2287         ccWinPrismD3D.dependsOn generateD3DHeaders
2288     }
2289 
2290     // The Decora and Prism JSL files have to be generated in a very specific set of steps.
2291     //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
2292     //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
2293     //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
2294     //         will be output to $buildDir/gensrc/jsl-*
2295     //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output
2296     //         into classes/jsl-*
2297     //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj
2298     //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
2299     //      5) Modify the jar step to include classes/jsl-*
2300     // The native library must be copied over during SDK creation time in the &quot;sdk&quot; task. In
2301     // addition to these steps, the clean task is created. Note that I didn&#39;t bother to create
2302     // a new task for each of the decora files, preferring instead just to create a rule?? Also
2303     // need &quot;clean&quot; tasks for each compile task.
2304 
2305     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2306     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2307     addJSL(project, &quot;Decora&quot;, &quot;com/sun/scenario/effect/impl/hw/d3d/hlsl&quot;, decoraAddExports) { sourceDir, destinationDir -&gt;
2308         [[fileName: &quot;ColorAdjust&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2309          [fileName: &quot;Brightpass&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2310          [fileName: &quot;SepiaTone&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2311          [fileName: &quot;PerspectiveTransform&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2312          [fileName: &quot;DisplacementMap&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2313          [fileName: &quot;InvertMask&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2314          [fileName: &quot;Blend&quot;, generator: &quot;CompileBlend&quot;, outputs: &quot;-all&quot;],
2315          [fileName: &quot;PhongLighting&quot;, generator: &quot;CompilePhong&quot;, outputs: &quot;-all&quot;],
2316          [fileName: &quot;LinearConvolve&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;],
2317          [fileName: &quot;LinearConvolveShadow&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;]].each { settings -&gt;
2318             javaexec {
2319                 executable = JAVA
2320                 workingDir = project.projectDir
2321                 main = settings.generator
2322                 classpath = configurations.compile + configurations.antlr
2323                 classpath += files(project.sourceSets.jslc.java.outputDir)
2324 
2325                 classpath += files(&quot;${project.projectDir}/src/jslc/resources&quot;)
2326 
2327                 classpath += files(&quot;$buildDir/classes/jsl-compilers/decora&quot;)
2328                 jvmArgs += &quot;--module-path=$modulePath&quot;
2329                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2330                 jvmArgs += decoraAddExports
2331                 args += [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/scenario/effect&quot;, &quot;$settings.outputs&quot;, &quot;$settings.fileName&quot;]
2332             }
2333         }
2334     }
2335 
2336 
2337     task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: &quot;Build&quot;) {
2338         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for Decora&quot;
2339     }
2340     task cleanNativeDecora(type: Delete, group: &quot;Build&quot;) {
2341         description = &quot;Clean native objects for Decora&quot;
2342     }
2343 
2344     def headerDir = file(&quot;$buildDir/gensrc/headers/javafx.graphics&quot;)
2345     def nativeRootDir = project.file(&quot;$project.buildDir/native/jsl-decora&quot;)
2346     def libRootDir = project.file(&quot;$project.buildDir/libs/jsl-decora&quot;)
2347     // For each compile target, create cc and link tasks
2348     compileTargets { t -&gt;
2349         def target = t.name
2350         def upperTarget = t.upper
2351         def capitalTarget = t.capital
2352         def targetProperties = rootProject.ext[upperTarget];
2353         def library = targetProperties.library
2354         def properties = targetProperties.get(&#39;decora&#39;)
2355         def nativeDir = file(&quot;$nativeRootDir/$target&quot;);
2356 
2357         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
2358         variants.each { variant -&gt;
2359             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
2360             def capitalVariant = variant.capitalize()
2361             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
2362 
2363             def ccTask = task(&quot;compileDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CCTask ) {
2364                 description = &quot;Compiles Decora SSE natives for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2365                 matches = &quot;.*\\.cc&quot;
2366                 source file(&quot;$buildDir/gensrc/jsl-decora&quot;)
2367                 source file(project.projectDir.path + &quot;/src/main/native-decora&quot;)
2368                 headers = headerDir
2369                 params.addAll(variantProperties.ccFlags)
2370                 output(ccOutput)
2371                 compiler = variantProperties.compiler
2372                 cleanNativeDecora.delete ccOutput
2373             }
2374 
2375             def linkTask = task(&quot;linkDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask) {
2376                 description = &quot;Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2377                 objectDir = ccOutput
2378                 linkParams.addAll(variantProperties.linkFlags)
2379                 lib = file(&quot;$libRootDir/$t.name/${library(variantProperties.lib)}&quot;)
2380                 linker = variantProperties.linker
2381                 cleanNativeDecora.delete &quot;$libRootDir/$t.name/&quot;
2382             }
2383 
2384             if (IS_WINDOWS &amp;&amp; target == &quot;win&quot;) {
2385                 def rcTask = project.task(&quot;rcDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CompileResourceTask) {
2386                     description = &quot;Compiles native sources for Decora SSE&quot;
2387                     matches = &quot;.*\\.rc&quot;
2388                     compiler = variantProperties.rcCompiler
2389                     source(variantProperties.rcSource)
2390                     if (variantProperties.rcFlags) {
2391                         rcParams.addAll(variantProperties.rcFlags)
2392                     }
2393                     output(ccOutput)
2394                 }
2395                 linkTask.dependsOn rcTask;
2396             }
2397 
2398             nativeDecora.dependsOn(linkTask)
2399         }
2400     }
2401 
2402     // Prism JSL
2403     addJSL(project, &quot;Prism&quot;, &quot;com/sun/prism/d3d/hlsl&quot;, null) { sourceDir, destinationDir -&gt;
2404         def inputFiles = fileTree(dir: sourceDir)
2405         inputFiles.include &quot;**/*.jsl&quot;
2406         inputFiles.each { file -&gt;
2407             javaexec {
2408                 executable = JAVA
2409                 workingDir = project.projectDir
2410                 main = &quot;CompileJSL&quot;
2411                 classpath = configurations.compile + configurations.antlr
2412                 classpath += files(project.sourceSets.jslc.java.outputDir)
2413                 classpath += files(project.sourceSets.jslc.resources)
2414                 classpath += files(&quot;$buildDir/classes/jsl-compilers/prism&quot;,
2415                     project.projectDir.path + &quot;/src/main/jsl-prism&quot;) // for the .stg
2416                 args = [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/prism&quot;, &quot;-d3d&quot;, &quot;-es2&quot;, &quot;-name&quot;, &quot;$file&quot;]
2417             }
2418         }
2419     }
2420 
2421     nativePrism.dependsOn compilePrismHLSLShaders;
2422 
2423     project.nativeAllTask.dependsOn nativeDecora
2424     project.cleanNativeAllTask.dependsOn cleanNativeDecora
2425     assemble.dependsOn nativeDecora
2426     processResources.dependsOn processDecoraShaders, processPrismShaders
2427 
2428     test {
2429         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2430         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2431             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2432         enableAssertions = true
2433         testLogging.exceptionFormat = &quot;full&quot;
2434         scanForTestClasses = false
2435         include &quot;**/*Test.*&quot;
2436         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
2437             addJCov(project, test)
2438         }
2439     }
2440 
2441     // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
2442     // available in some known location. Maybe in the future the Gradle plugins to each
2443     // of the IDEs will be good enough that we won&#39;t need this hack anymore.
2444     classes {
2445         doLast {
2446             // Copy all of the download libraries to the libs directory for the sake of the IDEs
2447             File libsDir = rootProject.file(&quot;build/libs&quot;);
2448 
2449             // In some IDEs (Eclipse for example), touching these libraries
2450             // cauese a full build within the IDE. When gradle is used
2451             // outside of the IDE, for example to build the native code,
2452             // a full rebuild is caused within the IDE. The fix is to check
2453             // for the presence of the target files in the lib directory
2454             // and not copy the files if all are present.
2455 
2456             libsDir.mkdirs();
2457 
2458             def allLibsPresent = true
2459             def libNames = [ &quot;antlr4-4.7.2-complete.jar&quot; ]
2460             libNames.each { name -&gt;
2461                 File f = new File(libsDir, name)
2462                 if (!f.exists()) allLibsPresent = false
2463             }
2464             if (allLibsPresent) return;
2465 
2466             for (File f : [configurations.compile.files, configurations.antlr.files].flatten()) {
2467                 copy {
2468                     into libsDir
2469                     from f.getParentFile()
2470                     include &quot;**/antlr4-4.7.2-complete.jar&quot;
2471                     includeEmptyDirs = false
2472                 }
2473             }
2474         }
2475     }
2476 
2477     addMavenPublication(project, [ &#39;base&#39; ])
2478 
2479     addValidateSourceSets(project, sourceSets)
2480 }
2481 
2482 project(&quot;:controls&quot;) {
2483     project.ext.buildModule = true
2484     project.ext.includeSources = true
2485     project.ext.moduleRuntime = true
2486     project.ext.moduleName = &quot;javafx.controls&quot;
2487 
2488     sourceSets {
2489         main
2490         shims {
2491             java {
2492                 compileClasspath += sourceSets.main.output
2493                 runtimeClasspath += sourceSets.main.output
2494             }
2495         }
2496         test {
2497             java {
2498                 compileClasspath += sourceSets.shims.output
2499                 runtimeClasspath += sourceSets.shims.output
2500             }
2501         }
2502     }
2503 
2504     project.ext.moduleSourcePath = defaultModuleSourcePath
2505     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2506 
2507     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39; ])
2508 
2509     dependencies {
2510         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2511         testCompile project(&quot;:base&quot;).sourceSets.test.output
2512         compile project(&#39;:base&#39;)
2513         compile project(&#39;:graphics&#39;)
2514     }
2515 
2516     test {
2517         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2518         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2519             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2520     }
2521 
2522     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2523     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2524     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2525     processResources {
2526       doLast {
2527         def cssFiles = fileTree(dir: &quot;$moduleDir/com/sun/javafx/scene/control/skin&quot;)
2528         cssFiles.include &quot;**/*.css&quot;
2529         cssFiles.each { css -&gt;
2530             logger.info(&quot;converting CSS to BSS ${css}&quot;);
2531 
2532             javaexec {
2533                 executable = JAVA
2534                 workingDir = project.projectDir
2535                 jvmArgs += patchModuleArgs
2536                 jvmArgs += &quot;--module-path=$modulePath&quot;
2537                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2538                 main = &quot;com.sun.javafx.css.parser.Css2Bin&quot;
2539                 args css
2540             }
2541         }
2542       }
2543     }
2544 
2545     processShimsResources.dependsOn(project.task(&quot;copyShimBss&quot;, type: Copy) {
2546         from project.moduleDir
2547         into project.moduleShimsDir
2548         include &quot;**/*.bss&quot;
2549     })
2550 
2551     addMavenPublication(project, [ &#39;graphics&#39; ])
2552 
2553     addValidateSourceSets(project, sourceSets)
2554 }
2555 
2556 project(&quot;:swing&quot;) {
2557 
2558     tasks.all {
2559         if (!COMPILE_SWING) it.enabled = false
2560     }
2561 
2562     project.ext.buildModule = COMPILE_SWING
2563     project.ext.includeSources = true
2564     project.ext.moduleRuntime = true
2565     project.ext.moduleName = &quot;javafx.swing&quot;
2566 
2567     sourceSets {
2568         main
2569         //shims // no test shims needed
2570         test
2571     }
2572 
2573     project.ext.moduleSourcePath = defaultModuleSourcePath
2574     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2575 
2576     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;swing&#39; ])
2577 
2578     dependencies {
2579         compile project(&quot;:base&quot;)
2580         compile project(&quot;:graphics&quot;)
2581     }
2582 
2583     test {
2584         enabled = IS_FULL_TEST &amp;&amp; IS_AWT_TEST
2585     }
2586 
2587     if (COMPILE_SWING) {
2588         addMavenPublication(project, [ &#39;graphics&#39; ])
2589     }
2590 
2591     addValidateSourceSets(project, sourceSets)
2592 }
2593 
2594 project(&quot;:swt&quot;) {
2595     tasks.all {
2596         if (!COMPILE_SWT) it.enabled = false
2597     }
2598 
2599     // javafx.swt is an automatic module
2600     project.ext.buildModule = false
2601 
2602     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2603 
2604     dependencies {
2605         compile name: SWT_FILE_NAME
2606     }
2607 
2608     classes {
2609         doLast {
2610             // Copy all of the download libraries to libs directory for the sake of the IDEs
2611             File libsDir = rootProject.file(&quot;build/libs&quot;);
2612             File swtLib = new File(libsDir, &quot;swt-debug.jar&quot;)
2613             libsDir.mkdirs();
2614 
2615             // Skip copy if file is present.
2616             if (swtLib.exists()) return;
2617 
2618             for (File f : configurations.compile.files) {
2619                 // Have to rename the swt jar because it is some platform specific name but
2620                 // for the sake of the IDEs we need to have a single stable name that works
2621                 // on every platform
2622                 copy {
2623                     into libsDir
2624                     from f.getParentFile()
2625                     include &quot;**/*swt*.jar&quot;
2626                     includeEmptyDirs = false
2627                     rename &quot;.*swt.*jar&quot;, &quot;swt-debug\\.jar&quot;
2628                 }
2629             }
2630         }
2631     }
2632 
2633     compileJava.options.compilerArgs.addAll([
2634             &quot;--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED&quot;,
2635             &quot;--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED&quot;,
2636             &quot;--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED&quot;,
2637             &quot;--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED&quot;,
2638             &quot;--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED&quot;,
2639             ])
2640 
2641     test {
2642         //enabled = IS_FULL_TEST &amp;&amp; IS_SWT_TEST
2643         enabled = false // FIXME: JIGSAW -- support this with modules
2644         logger.info(&quot;JIGSAW Testing disabled for swt&quot;)
2645 
2646         if (IS_MAC) {
2647             enabled = false
2648             logger.info(&quot;SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).&quot;)
2649         }
2650     }
2651 
2652     addValidateSourceSets(project, sourceSets)
2653 }
2654 
2655 project(&quot;:fxml&quot;) {
2656     project.ext.buildModule = true
2657     project.ext.includeSources = true
2658     project.ext.moduleRuntime = true
2659     project.ext.moduleName = &quot;javafx.fxml&quot;
2660 
2661     sourceSets {
2662         main
2663         shims {
2664             java {
2665                 compileClasspath += sourceSets.main.output
2666                 runtimeClasspath += sourceSets.main.output
2667             }
2668         }
2669         test {
2670             java {
2671                 compileClasspath += sourceSets.shims.output
2672                 runtimeClasspath += sourceSets.shims.output
2673             }
2674         }
2675     }
2676 
2677     project.ext.moduleSourcePath = defaultModuleSourcePath
2678     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2679 
2680     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;fxml&#39; ])
2681 
2682 
2683     dependencies {
2684         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2685         testCompile project(&quot;:base&quot;).sourceSets.test.output
2686         compile project(&quot;:base&quot;)
2687         compile project(&quot;:graphics&quot;)
2688     }
2689 
2690     test {
2691         // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
2692         // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
2693         // we have to use the stub toolkit for now.
2694         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;
2695         // FIXME: change this to also allow JDK 9 boot jdk
2696         classpath += files(&quot;$JDK_HOME/jre/lib/ext/nashorn.jar&quot;)
2697     }
2698 
2699     addMavenPublication(project, [ &#39;controls&#39; ])
2700 
2701     addValidateSourceSets(project, sourceSets)
2702 }
2703 
2704 project(&quot;:media&quot;) {
2705     configurations {
2706         media
2707     }
2708 
2709     project.ext.buildModule = true
2710     project.ext.includeSources = true
2711     project.ext.moduleRuntime = true
2712     project.ext.moduleName = &quot;javafx.media&quot;
2713 
2714     sourceSets {
2715         main
2716         //shims // no test shims needed
2717         test
2718         tools {
2719             java.srcDir &quot;src/tools/java&quot;
2720         }
2721     }
2722 
2723     project.ext.moduleSourcePath = defaultModuleSourcePath
2724     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2725 
2726     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;media&#39; ])
2727 
2728     dependencies {
2729         if (IS_BUILD_LIBAV_STUBS) {
2730             media name: &quot;libav-9.14&quot;, ext: &quot;tar.gz&quot;
2731             media name: &quot;libav-11.4&quot;, ext: &quot;tar.gz&quot;
2732             media name: &quot;libav-12.1&quot;, ext: &quot;tar.gz&quot;
2733             media name: &quot;ffmpeg-3.3.3&quot;, ext: &quot;tar.gz&quot;
2734             media name: &quot;ffmpeg-4.0.2&quot;, ext: &quot;tar.gz&quot;
2735         }
2736         compile project(&quot;:base&quot;)
2737         compile project(&quot;:graphics&quot;)
2738     }
2739 
2740     compileJava.dependsOn updateCacheIfNeeded
2741 
2742     compileJava {
2743         // generate the native headers during compile
2744         options.compilerArgs.addAll([
2745             &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
2746             ])
2747     }
2748 
2749     compileToolsJava {
2750         enabled = IS_COMPILE_MEDIA
2751         def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2752         options.compilerArgs.addAll([
2753             &quot;--module-path=$modulePath&quot;,
2754             &quot;--add-modules=javafx.media&quot;,
2755             &#39;--add-exports&#39;, &#39;javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39;,
2756             ])
2757     }
2758 
2759     project.ext.makeJobsFlag = IS_WINDOWS &amp;&amp; IS_DEBUG_NATIVE ? &quot;-j1&quot; : &quot;-j5&quot;;
2760     project.ext.buildType = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;;
2761 
2762     def nativeSrcDir = file(&quot;${projectDir}/src/main/native&quot;)
2763     def generatedHeadersDir = file(&quot;${buildDir}/gensrc/headers/${project.moduleName}&quot;)
2764 
2765     task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {
2766         enabled = IS_COMPILE_MEDIA
2767         def headerpath = file(&quot;$generatedHeadersDir/jfxmedia_errors.h&quot;);
2768         doLast {
2769             def classpath = files(sourceSets.tools.output);
2770             def sourcepath = sourceSets.main.java.srcDirs;
2771             def srcRoot = (sourcepath.toArray())[0];
2772 
2773             mkdir generatedHeadersDir;
2774 
2775             def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2776             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2777             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2778 
2779             exec {
2780                 commandLine(&quot;$JAVA&quot;);
2781                 args += patchModuleArgs
2782                 args += [ &quot;--module-path=$modulePath&quot; ]
2783                 args += [ &quot;--add-modules=javafx.media&quot; ]
2784                 args +=  [ &#39;--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39; ]
2785                 args +=  [ &#39;-classpath&#39;, &quot;${classpath.asPath}&quot; ]
2786                 args += [ &quot;headergen.HeaderGen&quot;, &quot;$headerpath&quot;, &quot;$srcRoot&quot; ]
2787             }
2788         }
2789         outputs.file(project.file(&quot;$headerpath&quot;))
2790     }
2791 
2792     task buildNativeTargets {
2793         enabled = IS_COMPILE_MEDIA
2794     }
2795 
2796     compileTargets { t-&gt;
2797         def targetProperties = project.rootProject.ext[t.upper]
2798         def nativeOutputDir = file(&quot;${buildDir}/native/${t.name}&quot;)
2799         def projectDir = t.name.startsWith(&quot;arm&quot;) ? &quot;linux&quot; : t.name
2800         def mediaProperties = targetProperties.media
2801         // Makefile for OSX needs to know if we&#39;re building for parfait
2802         def compileParfait = IS_COMPILE_PARFAIT ? &quot;true&quot; : &quot;false&quot;
2803 
2804         def buildNative = task(&quot;build${t.capital}Native&quot;, dependsOn: [generateMediaErrorHeader]) {
2805             enabled = targetProperties.compileMediaNative
2806             if (!targetProperties.compileMediaNative) {
2807                 println(&quot;Not compiling native Media for ${t.name} per configuration request&quot;);
2808             }
2809 
2810             doLast {
2811                 exec {
2812                     commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/jfxmedia/projects/${projectDir}&quot;)
2813                     args(&quot;JAVA_HOME=${JDK_HOME}&quot;, &quot;GENERATED_HEADERS_DIR=${generatedHeadersDir}&quot;,
2814                          &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=jfxmedia&quot;,
2815                          &quot;COMPILE_PARFAIT=${compileParfait}&quot;,
2816                          IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2817                         &quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2818 
2819                     if (t.name == &quot;win&quot;) {
2820                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2821                         args( &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}&quot;)
2822                     } else {
2823                         if (t.name.startsWith(&quot;arm&quot;)) {
2824                             args(&quot;EXTRA_CFLAGS=${mediaProperties.extra_cflags}&quot;, &quot;EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}&quot;)
2825                         } else {
2826                             args(&quot;HOST_COMPILE=1&quot;)
2827                         }
2828                     }
2829                 }
2830             }
2831         }
2832 
2833         // check for the property disable${name} = true
2834         def boolean disabled = targetProperties.containsKey(&#39;disableMedia&#39;) ? targetProperties.get(&#39;disableMedia&#39;) : false
2835         if (!disabled) {
2836             // Building GStreamer
2837             def buildGStreamer = task(&quot;build${t.capital}GStreamer&quot;) {
2838                 enabled = IS_COMPILE_MEDIA
2839                 doLast {
2840                     exec {
2841                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite&quot;)
2842                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=gstreamer-lite&quot;,
2843                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;CC=${mediaProperties.compiler}&quot;,
2844                              &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2845 
2846                         if (t.name == &quot;win&quot;) {
2847                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2848                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}&quot;)
2849                         }
2850                     }
2851                 }
2852             }
2853 
2854             def buildPlugins = task(&quot;build${t.capital}Plugins&quot;, dependsOn: buildGStreamer) {
2855                 enabled = IS_COMPILE_MEDIA
2856 
2857                 doLast {
2858                     exec {
2859                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins&quot;)
2860                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=fxplugins&quot;,
2861                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2862                              &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2863 
2864                         if (t.name == &quot;win&quot;) {
2865                             Map winEnv = new HashMap(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2866 
2867                             String sdkDir = System.getenv(&quot;BASECLASSES_SDK_DIR&quot;);
2868                             if (sdkDir == null) {
2869                                 sdkDir = &quot;C:/Program Files/Microsoft SDKs/Windows/v7.1&quot; // Default value
2870                                 winEnv[&quot;BASECLASSES_SDK_DIR&quot;] = sdkDir
2871                             }
2872                             environment(winEnv)
2873 
2874                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}&quot;)
2875                         }
2876                     }
2877                 }
2878             }
2879 
2880             buildNative.dependsOn buildPlugins
2881 
2882             if (t.name == &quot;linux&quot;) {
2883                 // Pre-defined command line arguments
2884                 def cfgCMDArgs = [&quot;sh&quot;, &quot;configure&quot;]
2885                 def commonCfgArgs = [&quot;--enable-shared&quot;, &quot;--disable-debug&quot;, &quot;--disable-static&quot;, &quot;--disable-yasm&quot;, &quot;--disable-doc&quot;, &quot;--disable-programs&quot;, &quot;--disable-everything&quot;]
2886                 def codecsCfgArgs = [&quot;--enable-decoder=aac,mp3,mp3float,h264&quot;, &quot;--enable-parser=aac,h264&quot;, &quot;--enable-demuxer=aac,h264,mpegts,mpegtsraw&quot;]
2887 
2888                 def copyLibAVStubs = {String fromDir, String toDir -&gt;
2889                     FileCollection config = files(&quot;config.h&quot;)
2890                     FileCollection libavcodec = files(&quot;avcodec.h&quot;, &quot;avfft.h&quot;, &quot;dxva2.h&quot;, &quot;vaapi.h&quot;, &quot;vda.h&quot;,
2891                                                       &quot;vdpau.h&quot;, &quot;version.h&quot;, &quot;xvmc.h&quot;, &quot;old_codec_ids.h&quot;)
2892                     FileCollection libavdevice = files(&quot;avdevice.h&quot;, &quot;version.h&quot;)
2893                     FileCollection libavfilter = files(&quot;avfiltergraph.h&quot;, &quot;avfilter.h&quot;, &quot;buffersink.h&quot;, &quot;buffersrc.h&quot;, &quot;version.h&quot;);
2894                     FileCollection libavformat = files(&quot;avformat.h&quot;, &quot;avio.h&quot;, &quot;version.h&quot;)
2895                     FileCollection libavresample = files(&quot;avresample.h&quot;, &quot;version.h&quot;)
2896                     FileCollection libavutil = files(&quot;adler32.h&quot;, &quot;blowfish.h&quot;, &quot;error.h&quot;, &quot;log.h&quot;, &quot;pixfmt.h&quot;,
2897                                                      &quot;aes.h&quot;, &quot;bswap.h&quot;, &quot;eval.h&quot;, &quot;lzo.h&quot;, &quot;random_seed.h&quot;,
2898                                                      &quot;attributes.h&quot;, &quot;buffer.h&quot;, &quot;fifo.h&quot;, &quot;macros.h&quot;, &quot;rational.h&quot;,
2899                                                      &quot;audio_fifo.h&quot;, &quot;channel_layout.h&quot;, &quot;file.h&quot;, &quot;mathematics.h&quot;, &quot;samplefmt.h&quot;,
2900                                                      &quot;avassert.h&quot;, &quot;common.h&quot;, &quot;frame.h&quot;, &quot;md5.h&quot;, &quot;sha.h&quot;,
2901                                                      &quot;avconfig.h&quot;, &quot;imgutils.h&quot;, &quot;mem.h&quot;, &quot;time.h&quot;, &quot;avstring.h&quot;,
2902                                                      &quot;cpu_internal.h&quot;, &quot;intfloat.h&quot;, &quot;opt.h&quot;, &quot;version.h&quot;, &quot;avutil.h&quot;,
2903                                                      &quot;crc.h&quot;, &quot;intreadwrite.h&quot;, &quot;parseutils.h&quot;, &quot;xtea.h&quot;, &quot;base64.h&quot;,
2904                                                      &quot;dict.h&quot;, &quot;lfg.h&quot;, &quot;pixdesc.h&quot;, &quot;intfloat_readwrite.h&quot;, &quot;old_pix_fmts.h&quot;, &quot;audioconvert.h&quot;,
2905                                                      &quot;cpu.h&quot;, &quot;hwcontext.h&quot;)
2906                     FileCollection libavutil_x86 = files(&quot;cpu.h&quot;) // Use cpu.h from x86 instead of libavutil root if exist
2907                     FileCollection libswscale = files(&quot;swscale.h&quot;, &quot;version.h&quot;)
2908 
2909                     def copyLibAVFiles = {FileCollection files, String fDir, String tDir -&gt;
2910                         File dir = file(tDir)
2911                         dir.mkdirs()
2912 
2913                         files.each { File file -&gt;
2914                             copy {
2915                                 from fDir
2916                                 into tDir
2917                                 include file.name
2918                             }
2919                         }
2920                     }
2921 
2922                     copyLibAVFiles(config, fromDir, &quot;${toDir}/include&quot;)
2923                     copyLibAVFiles(libavcodec, &quot;${fromDir}/libavcodec&quot;, &quot;${toDir}/include/libavcodec&quot;)
2924                     copyLibAVFiles(libavdevice, &quot;${fromDir}/libavdevice&quot;, &quot;${toDir}/include/libavdevice&quot;)
2925                     copyLibAVFiles(libavfilter, &quot;${fromDir}/libavfilter&quot;, &quot;${toDir}/include/libavfilter&quot;)
2926                     copyLibAVFiles(libavformat, &quot;${fromDir}/libavformat&quot;, &quot;${toDir}/include/libavformat&quot;)
2927                     copyLibAVFiles(libavresample, &quot;${fromDir}/libavresample&quot;, &quot;${toDir}/include/libavresample&quot;)
2928                     copyLibAVFiles(libavutil, &quot;${fromDir}/libavutil&quot;, &quot;${toDir}/include/libavutil&quot;)
2929                     copyLibAVFiles(libavutil_x86, &quot;${fromDir}/libavutil/x86&quot;, &quot;${toDir}/include/libavutil&quot;)
2930                     copyLibAVFiles(libswscale, &quot;${fromDir}/libswscale&quot;, &quot;${toDir}/include/libswscale&quot;)
2931 
2932                     // Copy libs
2933                     FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*.so*&quot;)
2934                     libs.each {File file -&gt;
2935                         copy {
2936                             from file
2937                             into &quot;${toDir}/lib&quot;
2938                         }
2939                     }
2940                 }
2941 
2942                 def buildLibAVStubs = task(&quot;buildLibAVStubs&quot;, dependsOn: []) {
2943                     enabled = IS_BUILD_LIBAV_STUBS
2944 
2945                     doLast {
2946                         project.ext.libav = [:]
2947                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav&quot;
2948                         project.ext.libav.versions = [ &quot;9.14&quot;, &quot;11.4&quot;, &quot;12.1&quot; ]
2949                         project.ext.libav.versionmap = [ &quot;9.14&quot; : &quot;54&quot;, &quot;11.4&quot; : &quot;56&quot;, &quot;12.1&quot; : &quot;57&quot; ]
2950 
2951                         libav.versions.each { version -&gt;
2952                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2953                             for (File f : configurations.media.files) {
2954                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
2955                                     File dir = file(libavDir)
2956                                     dir.mkdirs()
2957                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
2958                                     ant.gunzip(src: f, dest: libavTar)
2959                                     ant.untar(src: libavTar, dest: libav.basedir)
2960                                 }
2961                             }
2962                         }
2963 
2964                         libav.versions.each { version -&gt;
2965                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2966                             File dir = file(libavDir)
2967                             if (dir.exists()) {
2968                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
2969                                 File cfgFile = file(configFile)
2970                                 if (!cfgFile.exists()) {
2971                                     // Add execute permissions to version.sh, otherwise build fails
2972                                     exec {
2973                                         workingDir(&quot;$libavDir&quot;)
2974                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
2975                                     }
2976                                     exec {
2977                                         workingDir(&quot;$libavDir&quot;)
2978                                         if (IS_BUILD_WORKING_LIBAV) {
2979                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
2980                                         } else {
2981                                             commandLine(cfgCMDArgs + commonCfgArgs)
2982                                         }
2983                                     }
2984                                 }
2985                                 exec {
2986                                     workingDir(&quot;$libavDir&quot;)
2987                                     commandLine(&quot;make&quot;)
2988                                 }
2989                             }
2990                         }
2991 
2992                         libav.versions.each { version -&gt;
2993                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
2994                             def majorVersion = libav.versionmap[version]
2995                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
2996                             copyLibAVStubs(fromDir, toDir)
2997                         }
2998                     }
2999                 }
3000 
3001                 def buildLibAVFFmpegStubs = task(&quot;buildLibAVFFmpegStubs&quot;, dependsOn: []) {
3002                     enabled = IS_BUILD_LIBAV_STUBS
3003 
3004                     def extraCfgArgs = [&quot;--build-suffix=-ffmpeg&quot;]
3005 
3006                     doLast {
3007                         project.ext.libav = [:]
3008                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libavffmpeg&quot;
3009                         project.ext.libav.versions = [ &quot;11.4&quot; ]
3010                         project.ext.libav.versionmap = [ &quot;11.4&quot; : &quot;56&quot; ]
3011 
3012                         libav.versions.each { version -&gt;
3013                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3014                             for (File f : configurations.media.files) {
3015                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
3016                                     File dir = file(libavDir)
3017                                     dir.mkdirs()
3018                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
3019                                     ant.gunzip(src: f, dest: libavTar)
3020                                     ant.untar(src: libavTar, dest: libav.basedir)
3021                                 }
3022                             }
3023                         }
3024 
3025                         libav.versions.each { version -&gt;
3026                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3027                             File dir = file(libavDir)
3028                             if (dir.exists()) {
3029                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
3030                                 File cfgFile = file(configFile)
3031                                 if (!cfgFile.exists()) {
3032                                     // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded
3033                                     FileTree vfiles = fileTree(dir: &quot;${libavDir}&quot;, include: &quot;**/*.v&quot;)
3034                                     vfiles.each {File file -&gt;
3035                                         String data = file.getText(&quot;UTF-8&quot;)
3036                                         data = data.replace(&quot;_\$MAJOR&quot;, &quot;_FFMPEG_\$MAJOR&quot;)
3037                                         file.write(data, &quot;UTF-8&quot;)
3038                                     }
3039                                     // Add execute permissions to version.sh, otherwise build fails
3040                                     exec {
3041                                         workingDir(&quot;$libavDir&quot;)
3042                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3043                                     }
3044                                     exec {
3045                                         workingDir(&quot;$libavDir&quot;)
3046                                         if (IS_BUILD_WORKING_LIBAV) {
3047                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)
3048                                         } else {
3049                                             commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)
3050                                         }
3051                                     }
3052                                 }
3053                                 exec {
3054                                     workingDir(&quot;$libavDir&quot;)
3055                                     commandLine(&quot;make&quot;)
3056                                 }
3057                             }
3058                         }
3059 
3060                         libav.versions.each { version -&gt;
3061                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3062                             def majorVersion = libav.versionmap[version]
3063                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3064                             copyLibAVStubs(fromDir, toDir)
3065 
3066                             // Special case to copy *-ffmpeg.so to *.so
3067                             FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*-ffmpeg.so&quot;)
3068                             libs.each {File file -&gt;
3069                                 copy {
3070                                     from file
3071                                     into &quot;${toDir}/lib&quot;
3072                                     rename { String fileName -&gt;
3073                                         fileName.replace(&quot;-ffmpeg&quot;, &quot;&quot;)
3074                                     }
3075                                 }
3076                             }
3077                         }
3078                     }
3079                 }
3080 
3081                 def buildFFmpegStubs = task(&quot;buildFFmpegStubs&quot;, dependsOn: []) {
3082                     enabled = IS_BUILD_LIBAV_STUBS
3083 
3084                     doLast {
3085                         project.ext.libav = [:]
3086                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/ffmpeg&quot;
3087                         project.ext.libav.versions = [ &quot;3.3.3&quot;, &quot;4.0.2&quot; ]
3088                         project.ext.libav.versionmap = [ &quot;3.3.3&quot; : &quot;57&quot;, &quot;4.0.2&quot; : &quot;58&quot; ]
3089 
3090                         libav.versions.each { version -&gt;
3091                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3092                             for (File f : configurations.media.files) {
3093                                 if (f.name.startsWith(&quot;ffmpeg-${version}&quot;)) {
3094                                     File dir = file(libavDir)
3095                                     dir.mkdirs()
3096                                     def libavTar = &quot;${libav.basedir}/ffmpeg-${version}.tar&quot;
3097                                     ant.gunzip(src: f, dest: libavTar)
3098                                     ant.untar(src: libavTar, dest: libav.basedir)
3099                                 }
3100                             }
3101                         }
3102 
3103                         libav.versions.each { version -&gt;
3104                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3105                             File dir = file(libavDir)
3106                             if (dir.exists()) {
3107                                 def configFile = &quot;${libavDir}/config.h&quot;
3108                                 File cfgFile = file(configFile)
3109                                 if (!cfgFile.exists()) {
3110                                     // Add execute permissions to version.sh, otherwise build fails
3111                                     def versionFile = &quot;${libavDir}/version.sh&quot;
3112                                     File verFile = file(versionFile)
3113                                     if (verFile.exists()) {
3114                                         exec {
3115                                             workingDir(&quot;$libavDir&quot;)
3116                                             commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3117                                         }
3118                                     } else {
3119                                         versionFile = &quot;${libavDir}/ffbuild/version.sh&quot;
3120                                         verFile = file(versionFile)
3121                                         if (verFile.exists()) {
3122                                             exec {
3123                                                 workingDir(&quot;${libavDir}/ffbuild&quot;)
3124                                                 commandLine(&quot;chmod&quot;)
3125                                                 args += &quot;+x&quot;
3126                                                 args += [&quot;version.sh&quot;, &quot;libversion.sh&quot;, &quot;pkgconfig_generate.sh&quot;]
3127                                             }
3128                                         }
3129                                     }
3130                                     exec {
3131                                         workingDir(&quot;$libavDir&quot;)
3132                                         if (IS_BUILD_WORKING_LIBAV) {
3133                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
3134                                         } else {
3135                                             commandLine(cfgCMDArgs + commonCfgArgs)
3136                                         }
3137                                     }
3138                                 }
3139                                 exec {
3140                                     workingDir(&quot;$libavDir&quot;)
3141                                     commandLine(&quot;make&quot;)
3142                                 }
3143                             }
3144                         }
3145 
3146                         libav.versions.each { version -&gt;
3147                             def fromDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3148                             def majorVersion = libav.versionmap[version]
3149                             def toDir = &quot;${libav.basedir}/ffmpeg-${majorVersion}&quot;
3150                             copyLibAVStubs(fromDir, toDir)
3151                         }
3152                     }
3153                 }
3154 
3155                 def buildAVPlugin = task( &quot;buildAVPlugin&quot;, dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {
3156                     enabled = IS_COMPILE_MEDIA
3157 
3158                     doLast {
3159                         if (IS_BUILD_LIBAV_STUBS) {
3160                             project.ext.libav = [:]
3161                             project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav/libav&quot;
3162                             project.ext.libav.versions = [ &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot; ]
3163                             project.ext.libav.libavffmpeg = [:]
3164                             project.ext.libav.libavffmpeg.basedir = &quot;${buildDir}/native/linux/libavffmpeg/libav&quot;
3165                             project.ext.libav.libavffmpeg.versions = [ &quot;56&quot; ]
3166                             project.ext.libav.ffmpeg = [:]
3167                             project.ext.libav.ffmpeg.basedir = &quot;${buildDir}/native/linux/ffmpeg/ffmpeg&quot;
3168                             project.ext.libav.ffmpeg.versions = [ &quot;57&quot;, &quot;58&quot; ]
3169 
3170                             project.ext.libav.versions.each { version -&gt;
3171                                 def libavDir = &quot;${project.ext.libav.basedir}-${version}&quot;
3172                                 File dir = file(libavDir)
3173                                 if (dir.exists()) {
3174                                     exec {
3175                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3176                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3177                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3178                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3179                                              &quot;SUFFIX=&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3180                                     }
3181                                 }
3182                             }
3183 
3184                             project.ext.libav.libavffmpeg.versions.each { version -&gt;
3185                                 def libavDir = &quot;${project.ext.libav.libavffmpeg.basedir}-${version}&quot;
3186                                 File dir = file(libavDir)
3187                                 if (dir.exists()) {
3188                                     exec {
3189                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3190                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3191                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3192                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3193                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3194                                     }
3195                                 }
3196                             }
3197 
3198                             project.ext.libav.ffmpeg.versions.each { version -&gt;
3199                                 def libavDir = &quot;${project.ext.libav.ffmpeg.basedir}-${version}&quot;
3200                                 File dir = file(libavDir)
3201                                 if (dir.exists()) {
3202                                     exec {
3203                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3204                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3205                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3206                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3207                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3208                                     }
3209                                 }
3210                             }
3211                         } else {
3212                             // Building fxavcodec plugin (libav plugin)
3213                             exec {
3214                                 commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3215                                 args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3216                                      &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3217                                      &quot;BASE_NAME=avplugin&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3218                             }
3219                         }
3220                     }
3221                 }
3222                 buildNative.dependsOn buildAVPlugin
3223             }
3224 
3225             if (t.name == &quot;win&quot;) {
3226                 def buildResources = task(&quot;buildResources&quot;) {
3227                     doLast {
3228                         def rcOutputDir = &quot;${nativeOutputDir}/${buildType}&quot;
3229                         mkdir rcOutputDir
3230                         exec {
3231                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3232                             commandLine (WIN.media.rcCompiler)
3233                             args(WIN.media.glibRcFlags)
3234                             args(&quot;/Fo${rcOutputDir}/${WIN.media.glibRcFile}&quot;, WIN.media.rcSource)
3235                         }
3236 
3237                         exec {
3238                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3239                             commandLine (WIN.media.rcCompiler)
3240                             args(WIN.media.gstreamerRcFlags)
3241                             args(&quot;/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}&quot;, WIN.media.rcSource)
3242                         }
3243 
3244                         exec {
3245                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3246                             commandLine (WIN.media.rcCompiler)
3247                             args(WIN.media.fxpluginsRcFlags)
3248                             args(&quot;/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}&quot;, WIN.media.rcSource)
3249                         }
3250 
3251                         exec {
3252                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3253                             commandLine (WIN.media.rcCompiler)
3254                             args(WIN.media.jfxmediaRcFlags)
3255                             args(&quot;/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}&quot;, WIN.media.rcSource)
3256                         }
3257                     }
3258                 }
3259 
3260                 def buildGlib = task(&quot;build${t.capital}Glib&quot;, dependsOn: [buildResources]) {
3261                     enabled = IS_COMPILE_MEDIA
3262                     doLast {
3263                         exec {
3264                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3265                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3266                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;,
3267                                  IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}&quot;,
3268                                  &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3269                         }
3270                     }
3271                 }
3272                 buildGStreamer.dependsOn buildGlib
3273 
3274             } else if (t.name == &quot;mac&quot;) {
3275                 def buildGlib = task(&quot;build${t.capital}Glib&quot;) {
3276                     enabled = IS_COMPILE_MEDIA
3277                     doLast {
3278                         exec {
3279                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi&quot;)
3280                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=ffi&quot;)
3281                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;, &quot;AR=${mediaProperties.ar}&quot;)
3282                         }
3283 
3284                         exec {
3285                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3286                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;)
3287                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3288                         }
3289                     }
3290                 }
3291                 buildGStreamer.dependsOn buildGlib
3292             }
3293         }
3294 
3295         buildNativeTargets.dependsOn buildNative
3296     }
3297 
3298     jar {
3299         exclude(&quot;headergen/**&quot;)
3300 
3301         dependsOn compileJava
3302         if (IS_COMPILE_MEDIA) {
3303             dependsOn buildNativeTargets
3304         }
3305     }
3306 
3307     addMavenPublication(project, [ &#39;graphics&#39; ])
3308 
3309     addValidateSourceSets(project, sourceSets)
3310 }
3311 
3312 project(&quot;:web&quot;) {
3313     configurations {
3314         webkit
3315     }
3316     project.ext.buildModule = true
3317     project.ext.includeSources = true
3318     project.ext.moduleRuntime = true
3319     project.ext.moduleName = &quot;javafx.web&quot;
3320 
3321     sourceSets {
3322         main
3323         shims {
3324             java {
3325                 compileClasspath += sourceSets.main.output
3326                 runtimeClasspath += sourceSets.main.output
3327             }
3328         }
3329         test {
3330             java {
3331                 compileClasspath += sourceSets.shims.output
3332                 runtimeClasspath += sourceSets.shims.output
3333             }
3334         }
3335     }
3336 
3337     project.ext.moduleSourcePath = defaultModuleSourcePath
3338     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
3339 
3340     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39; ])
3341 
3342     dependencies {
3343         compile project(&quot;:base&quot;)
3344         compile project(&quot;:graphics&quot;)
3345         compile project(&quot;:controls&quot;)
3346         compile project(&quot;:media&quot;)
3347     }
3348 
3349     compileJava.dependsOn updateCacheIfNeeded
3350 
3351     task webArchiveJar(type: Jar) {
3352         from (project.file(&quot;$projectDir/src/test/resources/test/html&quot;)) {
3353             include &quot;**/archive-*.*&quot;
3354         }
3355         archiveName = &quot;webArchiveJar.jar&quot;
3356         destinationDir = file(&quot;$buildDir/testing/resources&quot;)
3357     }
3358 
3359     def gensrcDir = &quot;${buildDir}/gensrc/java&quot;
3360 
3361     // add in the wrappers to the compile
3362     sourceSets.main.java.srcDirs += &quot;${gensrcDir}&quot;
3363 
3364     if (IS_COMPILE_WEBKIT) {
3365         compileJava {
3366             // generate the native headers during compile
3367             // only needed if we are doing the native compile
3368             options.compilerArgs.addAll([
3369                 &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
3370                 ])
3371         }
3372     }
3373 
3374     // Copy these to a common location in the moduleSourcePath
3375     def copyWrappers = project.task(&quot;copyPreGeneratedWrappers&quot;, type: Copy) {
3376         from &quot;src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
3377         into &quot;${gensrcDir}&quot;
3378     }
3379 
3380     compileJava.dependsOn(copyWrappers);
3381 
3382     test {
3383         doFirst {
3384             if (!IS_COMPILE_WEBKIT) {
3385                 println &quot;*****************************************************&quot;
3386                 println &quot;WARNING: running web tests without building webkit.&quot;
3387                 println &quot;The webkit native library will be copied from the JDK,&quot;
3388                 println &quot;which might lead to failures in some web tests.&quot;
3389                 println &quot;To avoid these failures, you should either build&quot;
3390                 println &quot;webkit locally, copy the native webkit library from a&quot;
3391                 println &quot;recent build, or skip execution of web test cases with&quot;
3392                 println &quot;&#39;-x :web:test&#39;&quot;
3393                 println &quot;*****************************************************&quot;
3394             }
3395         }
3396         // Run web tests in headless mode
3397         systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
3398         systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
3399         systemProperty &#39;prism.order&#39;, &#39;sw&#39;
3400         dependsOn webArchiveJar
3401         def testResourceDir = file(&quot;$buildDir/testing/resources&quot;)
3402         jvmArgs &quot;-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir&quot;
3403     }
3404 
3405     task compileJavaDOMBinding()
3406 
3407     compileTargets { t -&gt;
3408         def targetProperties = project.rootProject.ext[t.upper]
3409         def webkitProperties = targetProperties.webkit
3410         def classifier = (t.name != &quot;linux&quot; &amp;&amp; t.name != &quot;win&quot;) ? t.name :
3411                           IS_64 ? &quot;${t.name}-amd64&quot; : &quot;${t.name}-i586&quot;
3412 
3413         def webkitOutputDir = cygpath(&quot;$buildDir/${t.name}&quot;)
3414         def webkitConfig = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;
3415 
3416         File nativeBuildDir = new File(&quot;${webkitOutputDir}&quot;)
3417         nativeBuildDir.mkdirs()
3418 
3419         def compileNativeTask = task(&quot;compileNative${t.capital}&quot;, dependsOn: [compileJava]) {
3420             println &quot;Building Webkit configuration /$webkitConfig/ into $webkitOutputDir&quot;
3421             enabled =  (IS_COMPILE_WEBKIT)
3422 
3423             doLast {
3424                 exec {
3425                     workingDir(&quot;$webkitOutputDir&quot;)
3426                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration&quot;, &quot;--$webkitConfig&quot;)
3427                     environment([&quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir])
3428                 }
3429 
3430                 exec {
3431                     workingDir(&quot;$webkitOutputDir&quot;)
3432                     def cmakeArgs = &quot;-DENABLE_TOOLS=1&quot;
3433                     cmakeArgs = &quot; $cmakeArgs -DCMAKE_C_COMPILER=&#39;${webkitProperties.compiler}&#39;&quot;
3434                     if (t.name == &quot;win&quot;) {
3435                         // To enable ninja build on Windows
3436                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3437                     } else if (t.name == &quot;mac&quot;) {
3438                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH&quot;
3439                     } else if (t.name == &quot;linux&quot;) {
3440                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux&quot;
3441                         if (IS_64) {
3442                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64&quot;
3443                         } else {
3444                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586&quot;
3445                         }
3446                         // TODO: Use cflags and ldflags from all platforms
3447                         def cFlags = webkitProperties.ccFlags?.join(&#39; &#39;) ?: &#39;&#39;
3448                         def lFlags = webkitProperties.linkFlags?.join(&#39; &#39;) ?: &#39;&#39;
3449                         // -shared flag should be omitted while creating executable.
3450                         def exeFlags = webkitProperties.linkFlags?.join(&#39; &#39;)?.replace(&#39;-shared&#39;, &#39;&#39;) ?: &#39;&#39;
3451                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_C_FLAGS=&#39;${cFlags}&#39; -DCMAKE_CXX_FLAGS=&#39;${cFlags}&#39;&quot;
3452                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS=&#39;${lFlags}&#39; -DCMAKE_EXE_LINKER_FLAGS=&#39;${exeFlags}&#39;&quot;
3453                     } else if (t.name.startsWith(&quot;arm&quot;)) {
3454                         fail(&quot;ARM target is not supported as of now.&quot;)
3455                     }
3456 
3457                     if (IS_COMPILE_PARFAIT) {
3458                         environment([
3459                             &quot;COMPILE_PARFAIT&quot; : &quot;true&quot;
3460                         ])
3461                         environment &quot;PATH&quot;, System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH
3462                         cmakeArgs = &quot;-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++&quot;
3463                     }
3464 
3465                     if (project.hasProperty(&#39;toolsPath&#39;)) {
3466                         environment &quot;PATH&quot;, toolsPath + File.pathSeparator + environment.PATH
3467                     }
3468 
3469                     environment([
3470                         &quot;JAVA_HOME&quot;       : JDK_HOME,
3471                         &quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir,
3472                         &quot;PYTHONDONTWRITEBYTECODE&quot; : &quot;1&quot;,
3473                     ])
3474 
3475                     def targetCpuBitDepthSwitch = &quot;&quot;
3476                     if (IS_64) {
3477                         targetCpuBitDepthSwitch = &quot;--64-bit&quot;
3478                     } else {
3479                         targetCpuBitDepthSwitch = &quot;--32-bit&quot;
3480                     }
3481                     cmakeArgs += &quot; -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}&quot;
3482                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/build-webkit&quot;,
3483                         &quot;--java&quot;, &quot;--icu-unicode&quot;, targetCpuBitDepthSwitch,
3484                         &quot;--no-experimental-features&quot;, &quot;--cmakeargs=${cmakeArgs}&quot;)
3485                 }
3486             }
3487         }
3488 
3489         // Cmake places Windows DLL in bin directory
3490         def dllDir = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
3491         def copyDumpTreeNativeTask = task(&quot;copyDumpTreeNative${t.capital}&quot;, type: Copy,
3492                 dependsOn: [ compileNativeTask]) {
3493             def library = rootProject.ext[t.upper].library
3494             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;DumpRenderTreeJava&#39;)}&quot;
3495             into &quot;$buildDir/test/${t.name}&quot;
3496         }
3497 
3498         def copyNativeTask = task(&quot;copyNative${t.capital}&quot;, type: Copy,
3499                 dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {
3500             enabled =  (IS_COMPILE_WEBKIT)
3501             def library = rootProject.ext[t.upper].library
3502             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;jfxwebkit&#39;)}&quot;
3503             into &quot;$buildDir/libs/${t.name}&quot;
3504         }
3505 
3506         if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
3507             def rcTask = project.task(&quot;rc${t.capital}&quot;, type: CompileResourceTask) {
3508                 compiler = webkitProperties.rcCompiler
3509                 source(webkitProperties.rcSource)
3510                 if (webkitProperties.rcFlags) {
3511                     rcParams.addAll(webkitProperties.rcFlags)
3512                 }
3513                 output(file(&quot;$webkitOutputDir/$webkitConfig/WebCore/obj&quot;))
3514             }
3515             compileNativeTask.dependsOn rcTask
3516         }
3517 
3518         def compileJavaDOMBindingTask = task(&quot;compileJavaDOMBinding${t.capital}&quot;, type: JavaCompile,
3519                 dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {
3520             destinationDir = file(&quot;$buildDir/classes/java/main&quot;)
3521             classpath = configurations.compile
3522             source = project.sourceSets.main.java.srcDirs
3523             options.compilerArgs.addAll([
3524                 &#39;-implicit:none&#39;,
3525                 &#39;--module-source-path&#39;, defaultModuleSourcePath
3526                 ])
3527         }
3528 
3529         compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask
3530 
3531         if (!targetProperties.compileWebnodeNative) {
3532             println(&quot;Not compiling native Webkit for ${t.name} per configuration request&quot;);
3533             compileNativeTask.enabled = false
3534         }
3535     }
3536 
3537     def drtClasses = &quot;**/com/sun/javafx/webkit/drt/**&quot;
3538     task drtJar(type: Jar, dependsOn: compileJava) {
3539         archiveName = &quot;drt.jar&quot;
3540         destinationDir = file(&quot;$buildDir/test&quot;)
3541         from &quot;$buildDir/classes/java/main/javafx.web/&quot;
3542         include drtClasses
3543         includeEmptyDirs = false
3544     }
3545 
3546     if (IS_COMPILE_WEBKIT) {
3547         assemble.dependsOn compileJavaDOMBinding, drtJar
3548     }
3549 
3550     addMavenPublication(project, [ &#39;controls&#39;, &#39;media&#39; ])
3551 
3552     addValidateSourceSets(project, sourceSets)
3553 }
3554 
3555 // This project is for system tests that need to run with a full SDK.
3556 // Most of them display a stage or do other things that preclude running
3557 // them in a shared JVM or as part of the &quot;smoke test&quot; run (which must
3558 // not pop up any windows or use audio). As such, they are only enabled
3559 // when FULL_TEST is specified, and each test runs in its own JVM
3560 project(&quot;:systemTests&quot;) {
3561 
3562     sourceSets {
3563         test
3564 
3565         // Source sets for standalone test apps (used for launcher tests)
3566         testapp1
3567 
3568         // Modular applications
3569         testapp2
3570         testapp3
3571         testapp4
3572         testapp5
3573         testapp6
3574     }
3575 
3576     def nonModSrcSets = [
3577         sourceSets.test,
3578         sourceSets.testapp1
3579     ]
3580 
3581     def modSrcSets = [
3582         sourceSets.testapp2,
3583         sourceSets.testapp3,
3584         sourceSets.testapp4,
3585         sourceSets.testapp5,
3586         sourceSets.testapp6
3587     ]
3588 
3589     project.ext.buildModule = false
3590     project.ext.moduleRuntime = false
3591     project.ext.moduleName = &quot;systemTests&quot;
3592 
3593     dependencies {
3594         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
3595         testCompile project(&quot;:base&quot;).sourceSets.test.output
3596         testCompile project(&quot;:controls&quot;).sourceSets.test.output
3597         testCompile project(&quot;:swing&quot;).sourceSets.test.output
3598     }
3599 
3600     def dependentProjects = [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39;, &#39;swing&#39;, &#39;fxml&#39; ]
3601     commonModuleSetup(project, dependentProjects)
3602 
3603     File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE);
3604     File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);
3605 
3606     File stRunArgsFile = new File(project.buildDir,&quot;st.run.args&quot;);
3607 
3608     def sts = task(&quot;systemTestSetup&quot;) {
3609         outputs.file(stRunArgsFile)
3610 
3611         doLast() {
3612             stRunArgsFile.delete()
3613 
3614             logger.info(&quot;Creating patchmodule.args file ${stRunArgsFile}&quot;)
3615 
3616             // Create an argfile with the information needed to launch
3617             // the stand alone system unit tests.
3618 
3619             //First add in all of the patch-module args we use for the
3620             //normal unit tests, copied from test.run.args
3621             testRunArgsFile.eachLine { str -&gt;
3622                 stRunArgsFile &lt;&lt;  &quot;${str}\n&quot;
3623             }
3624 
3625             // Now add in the working classpath elements (junit, test classes...)
3626             stRunArgsFile &lt;&lt;  &quot;-cp \&quot;\\\n&quot;
3627             test.classpath.each() { elem -&gt;
3628                 def e = cygpath(&quot;${elem}&quot;)
3629                 stRunArgsFile &lt;&lt;  &quot;  ${e}${File.pathSeparator}\\\n&quot;
3630             }
3631             stRunArgsFile &lt;&lt;  &quot;\&quot;\n&quot;
3632         }
3633     }
3634 
3635     test.dependsOn(sts)
3636     test.dependsOn(createTestArgfiles);
3637 
3638     // Tasks to create standalone test applications for the launcher tests
3639 
3640     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3641         compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)
3642     }
3643     dependentProjects.each { e -&gt;
3644         compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)
3645     }
3646 
3647     def testapp1JarName = &quot;testapp1.jar&quot;
3648     task createTestapp1Jar1(type: Jar) {
3649         dependsOn compileTestapp1Java
3650         enabled = IS_FULL_TEST
3651 
3652         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3653         archiveName = testapp1JarName
3654         includeEmptyDirs = false
3655         from project.sourceSets.testapp1.java.outputDir
3656         include(&quot;testapp/**&quot;)
3657         include(&quot;com/javafx/main/**&quot;)
3658 
3659         manifest {
3660             attributes(
3661                 &quot;Main-Class&quot; : &quot;com.javafx.main.Main&quot;,
3662                 &quot;JavaFX-Version&quot; : &quot;2.2&quot;,
3663                 &quot;JavaFX-Application-Class&quot; : &quot;testapp.HelloWorld&quot;,
3664                 &quot;JavaFX-Class-Path&quot; : &quot;jar2.jar&quot;
3665             )
3666         }
3667     }
3668 
3669     task createTestapp1Jar2(type: Jar) {
3670         dependsOn compileTestapp1Java
3671         enabled = IS_FULL_TEST
3672 
3673         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3674         archiveName = &quot;jar2.jar&quot;;
3675         includeEmptyDirs = false
3676         from project.sourceSets.testapp1.java.outputDir
3677         include(&quot;pkg2/**&quot;)
3678     }
3679 
3680     task createTestApps() {
3681         dependsOn(createTestapp1Jar1)
3682         dependsOn(createTestapp1Jar2)
3683     }
3684     test.dependsOn(createTestApps);
3685 
3686     def modtestapps = [ &quot;testapp2&quot;, &quot;testapp3&quot;, &quot;testapp4&quot;, &quot;testapp5&quot;, &quot;testapp6&quot;  ]
3687     modtestapps.each { testapp -&gt;
3688         def testappCapital = testapp.capitalize()
3689         def copyTestAppTask = task(&quot;copy${testappCapital}&quot;, type: Copy) {
3690             from project.sourceSets.&quot;${testapp}&quot;.java.outputDir
3691             from project.sourceSets.&quot;${testapp}&quot;.output.resourcesDir
3692             into &quot;${project.buildDir}/modules/${testapp}&quot;
3693         }
3694 
3695         def List&lt;String&gt; testAppSourceDirs = []
3696         project.sourceSets.&quot;${testapp}&quot;.java.srcDirs.each { dir -&gt;
3697             testAppSourceDirs += dir
3698         }
3699         def testappCompileTasks = project.getTasksByName(&quot;compile${testappCapital}Java&quot;, true);
3700         def testappResourceTasks = project.getTasksByName(&quot;process${testappCapital}Resources&quot;, true);
3701         testappCompileTasks.each { appCompileTask -&gt;
3702             appCompileTask.options.compilerArgs.addAll([
3703                 &#39;-implicit:none&#39;,
3704                 &#39;--module-source-path&#39;, testAppSourceDirs.join(File.pathSeparator),
3705                 ] )
3706             if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3707                 appCompileTask.options.compilerArgs.addAll(testModulePathArgs)
3708             }
3709 
3710             dependentProjects.each { e -&gt;
3711                 appCompileTask.dependsOn(rootProject.project(e).testClasses)
3712             }
3713 
3714             copyTestAppTask.dependsOn(appCompileTask)
3715         }
3716         testappResourceTasks.each { appResourceTask -&gt;
3717             copyTestAppTask.dependsOn(appResourceTask)
3718         }
3719 
3720         createTestApps.dependsOn(copyTestAppTask)
3721     }
3722 
3723     test {
3724         enabled = IS_FULL_TEST
3725 
3726         // Parse testPatchModuleArgs looking for &quot;--module-path&quot;.
3727         // Save path if found so we can pass it to the module launcher tests
3728         def pendingModulePath = false
3729         testPatchModuleArgs.each { str -&gt;
3730             if (pendingModulePath) {
3731                 project.ext.launcherModulePath = str;
3732                 pendingModulePath = false
3733             } else if (str == &quot;--module-path&quot;) {
3734                 pendingModulePath = true
3735             }
3736         }
3737 
3738         // Properties passed to launcher tests
3739         systemProperty &quot;launchertest.testapp1.jar&quot;, &quot;build/testapp1/$testapp1JarName&quot;
3740         modtestapps.each { testapp -&gt;
3741             systemProperty &quot;launchertest.${testapp}.module.path&quot;,
3742                     &quot;${project.buildDir}/modules/${testapp}&quot;
3743         }
3744 
3745         // Properties passed to test.util.Util
3746         systemProperties &#39;worker.debug&#39;: IS_WORKER_DEBUG
3747         systemProperties &#39;worker.patchmodule.file&#39;: cygpath(stRunArgsFile.path)
3748         if (project.hasProperty(&quot;launcherModulePath&quot;)) {
3749             systemProperties &#39;worker.module.path&#39;: launcherModulePath
3750         }
3751         systemProperties &#39;worker.patch.policy&#39;: cygpath(testJavaPolicyFile.path)
3752         systemProperties &#39;worker.java.cmd&#39;: JAVA
3753 
3754         if (rootProject.hasProperty(&quot;ClipShapeTest.numTests&quot;)) {
3755             systemProperty &quot;ClipShapeTest.numTests&quot;, rootProject.getProperty(&quot;ClipShapeTest.numTests&quot;)
3756         }
3757 
3758         if (!IS_USE_ROBOT) {
3759             // Disable all robot-based visual tests
3760             exclude(&quot;test/robot/**&quot;);
3761         }
3762         if (!IS_UNSTABLE_TEST) {
3763             // JDK-8196607 Don&#39;t run monocle test cases 
3764             exclude(&quot;test/robot/com/sun/glass/ui/monocle/**&quot;);
3765         }
3766         if (!IS_AWT_TEST) {
3767             // Disable all AWT-based tests
3768             exclude(&quot;**/javafx/embed/swing/*.*&quot;);
3769             exclude(&quot;**/com/sun/javafx/application/Swing*.*&quot;);
3770         }
3771 
3772         forkEvery = 1
3773     }
3774 
3775     addValidateSourceSets(project, nonModSrcSets, modSrcSets)
3776 }
3777 
3778 allprojects {
3779     // The following block is a workaround for the fact that presently Gradle
3780     // can&#39;t set the -XDignore.symbol.file flag, because it appears that the
3781     // javac API is lacking support for it. So what we&#39;ll do is find any Compile
3782     // task and manually provide the options necessary to fire up the
3783     // compiler with the right settings.
3784     tasks.withType(JavaCompile) { compile -&gt;
3785         if (compile.options.hasProperty(&quot;useAnt&quot;)) {
3786             compile.options.useAnt = true
3787             compile.options.useDepend = IS_USE_DEPEND
3788         } else if (compile.options.hasProperty(&quot;incremental&quot;)) {
3789             compile.options.incremental = IS_INCREMENTAL
3790         }
3791         compile.options.debug = true // we always generate debugging info in the class files
3792         compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? &quot;source,lines,vars&quot; : &quot;source,lines&quot;
3793         compile.options.fork = true
3794 
3795         compile.options.forkOptions.executable = JAVAC
3796 
3797         compile.options.warnings = IS_LINT
3798 
3799         compile.options.compilerArgs += [&quot;-XDignore.symbol.file&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;]
3800 
3801         // we use a custom javadoc command
3802         project.javadoc.enabled = false
3803 
3804         // Add in the -Xlint options
3805         if (IS_LINT) {
3806             LINT.split(&quot;[, ]&quot;).each { s -&gt;
3807                 compile.options.compilerArgs += &quot;-Xlint:$s&quot;
3808             }
3809         }
3810     } // tasks with javaCompile
3811 
3812     // If I am a module....
3813     if (project.hasProperty(&#39;moduleSourcePath&#39;) &amp;&amp;
3814             (project.hasProperty(&#39;buildModule&#39;) &amp;&amp; project.buildModule)) {
3815         project.compileJava {
3816             options.compilerArgs.addAll([
3817                 &#39;-implicit:none&#39;,
3818                 &#39;--module-source-path&#39;, project.moduleSourcePath
3819                 ])
3820         }
3821         // no jars needed for modules
3822         project.jar.enabled = false
3823 
3824         // and redirect the resources into the module
3825         project.sourceSets.main.output.resourcesDir = project.moduleDir
3826         project.processResources.destinationDir = project.moduleDir
3827     }
3828 
3829     if (project.hasProperty(&#39;moduleSourcePathShim&#39;) &amp;&amp;
3830             project.sourceSets.hasProperty(&#39;shims&#39;)) {
3831 
3832         // sync up the obvious source directories with the shims
3833         // others (like the shaders in graphics) should be added in there
3834         project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs
3835         project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
3836 
3837         project.compileShimsJava {
3838             options.compilerArgs.addAll([
3839                 &#39;-implicit:none&#39;,
3840                 &#39;--module-source-path&#39;, project.moduleSourcePathShim
3841                 ])
3842         }
3843         project.compileShimsJava.dependsOn(project.compileJava)
3844 
3845         def copyGeneratedShimsTask = task(&quot;copyGeneratedShims&quot;, type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {
3846             from project.sourceSets.shims.java.outputDir
3847             into &quot;${rootProject.buildDir}/shims&quot;
3848             if (HAS_JAVAFX_MODULES) {
3849                 exclude(&quot;*/module-info.class&quot;)
3850             }
3851         }
3852 
3853         project.processShimsResources.dependsOn(project.processResources)
3854 
3855         // shims resources should have the main resouces as a base
3856         project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs
3857 
3858         // and redirect the resources into the module
3859         project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir
3860         project.processShimsResources.destinationDir = project.moduleShimsDir
3861 
3862        compileTestJava.dependsOn(copyGeneratedShimsTask)
3863     }
3864 
3865     if (project.hasProperty(&#39;modulePathArgs&#39;)) {
3866         project.compileJava.options.compilerArgs.addAll(modulePathArgs)
3867     }
3868 
3869     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3870         project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)
3871     }
3872 
3873     if (project.hasProperty(&#39;testPatchModuleArgs&#39;)) {
3874         project.test.jvmArgs += testPatchModuleArgs
3875     }
3876 
3877     /* Note: we should not have to add extraAddExports to the normal
3878      * modular compile, as it contains all of the module-info files.
3879      * In fact doing so might cover up a module-info issue.
3880      * so we don&#39;t do it, and I will leave this commented out
3881      * block as a reminder of this fact.
3882     if (project.hasProperty(&#39;extraAddExports&#39;)) {
3883         project.compileJava.options.compilerArgs.addAll(extraAddExports);
3884     }
3885     */
3886 
3887     if (project.hasProperty(&#39;testAddExports&#39;)) {
3888         project.compileTestJava.options.compilerArgs.addAll(testAddExports);
3889         project.test.jvmArgs += testAddExports
3890     }
3891 
3892     if (rootProject.hasProperty(&quot;EXTRA_TEST_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;test&#39;)) {
3893         EXTRA_TEST_ARGS.split(&#39; &#39;).each() { e -&gt;
3894             project.test.jvmArgs += e
3895         }
3896     }
3897 
3898     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileJava&#39;)) {
3899         project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3900     }
3901 
3902     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileTestJava&#39;)) {
3903         project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3904     }
3905 }
3906 
3907 /******************************************************************************
3908  *                                                                            *
3909  *                             Top Level Tasks                                *
3910  *                                                                            *
3911  *  These are the tasks which are defined only for the top level project and  *
3912  *  not for any sub projects. These are generally the entry point that is     *
3913  *  used by Hudson and by the continuous build system.                        *
3914  *                                                                            *
3915  *****************************************************************************/
3916 
3917 task clean() {
3918     group = &quot;Basic&quot;
3919     description = &quot;Deletes the build directory and the build directory of all sub projects&quot;
3920     getSubprojects().each { subProject -&gt;
3921         dependsOn(subProject.getTasksByName(&quot;clean&quot;, true));
3922     }
3923     doLast {
3924         delete(buildDir);
3925     }
3926 }
3927 
3928 task cleanAll() {
3929     group = &quot;Basic&quot;
3930     description = &quot;Scrubs the repo of build artifacts&quot;
3931     dependsOn(clean)
3932     doLast {
3933         //delete(&quot;.gradle&quot;); This causes problems on windows.
3934         delete(&quot;buildSrc/build&quot;);
3935     }
3936 }
3937 
3938 task createMSPfile() {
3939     group = &quot;Build&quot;
3940     File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)
3941     outputs.file(mspFile)
3942 
3943     doLast {
3944         mspFile.delete()
3945         mspFile &lt;&lt; &quot;--module-source-path\n&quot;
3946         mspFile &lt;&lt; defaultModuleSourcePath
3947         mspFile &lt;&lt; &quot;\n&quot;
3948     }
3949 }
3950 
3951 task javadoc(type: Javadoc, dependsOn: createMSPfile) {
3952     group = &quot;Basic&quot;
3953     description = &quot;Generates the JavaDoc for all the public API&quot;
3954     executable = JAVADOC
3955     def projectsToDocument = [
3956             project(&quot;:base&quot;), project(&quot;:graphics&quot;), project(&quot;:controls&quot;), project(&quot;:media&quot;),
3957             project(&quot;:swing&quot;), /*project(&quot;:swt&quot;),*/ project(&quot;:fxml&quot;), project(&quot;:web&quot;)]
3958     source(projectsToDocument.collect({
3959         [it.sourceSets.main.java]
3960     }));
3961     setDestinationDir(new File(buildDir, &#39;javadoc&#39;));
3962 
3963     exclude(&quot;com/**/*&quot;, &quot;Compile*&quot;, &quot;javafx/builder/**/*&quot;, &quot;javafx/scene/accessibility/**/*&quot;);
3964 
3965     options.tags(&quot;apiNote:a:API Note:&quot;)
3966     options.tags(&quot;implSpec:a:Implementation Requirements:&quot;)
3967     options.tags(&quot;implNote:a:Implementation Note:&quot;)
3968     options.tags(&quot;param&quot;)
3969     options.tags(&quot;return&quot;)
3970     options.tags(&quot;throws&quot;)
3971     options.tags(&quot;moduleGraph:X&quot;)
3972     options.tags(&quot;since&quot;)
3973     options.tags(&quot;version&quot;)
3974     options.tags(&quot;serialData&quot;)
3975     options.tags(&quot;factory&quot;)
3976     options.tags(&quot;see&quot;)
3977 
3978     options.windowTitle(&quot;${javadocTitle}&quot;)
3979     options.header(&quot;${javadocHeader}&quot;)
3980     options.bottom(&quot;${javadocBottom}&quot;)
3981     options.locale(&quot;en&quot;);
3982     if (JDK_DOCS_LINK != &quot;&quot;) {
3983         options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);
3984     } else {
3985         options.links(JDK_DOCS);
3986     }
3987     options.addBooleanOption(&quot;XDignore.symbol.file&quot;).setValue(true);
3988     options.addBooleanOption(&quot;Xdoclint:${DOC_LINT}&quot;).setValue(IS_DOC_LINT);
3989     options.addBooleanOption(&quot;html5&quot;).setValue(true);
3990     options.addBooleanOption(&quot;javafx&quot;).setValue(true);
3991     options.addBooleanOption(&quot;use&quot;).setValue(true);
3992 
3993     options.setOptionFiles([
3994         new File(rootProject.buildDir,MODULESOURCEPATH)
3995         ]);
3996 
3997     doLast {
3998         projectsToDocument.each { p -&gt;
3999             def destDir = &quot;$buildDir/javadoc/${p.ext.moduleName}&quot;
4000             copy {
4001                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4002                     include &quot;**/*.html&quot;
4003                     filter { line-&gt;
4004                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4005                     }
4006                 }
4007                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4008                     exclude &quot;**/*.html&quot;
4009                 }
4010 
4011                 into destDir
4012             }
4013         }
4014     }
4015 
4016     dependsOn(projectsToDocument.collect { project -&gt; project.getTasksByName(&quot;classes&quot;, true)});
4017 }
4018 
4019 task sdk() {
4020     if (DO_BUILD_SDK_FOR_TEST) {
4021         rootProject.getTasksByName(&quot;test&quot;, true).each { t -&gt;
4022             if (t.enabled) t.dependsOn(sdk)
4023         }
4024     }
4025 }
4026 
4027 task jmods() {
4028     dependsOn(sdk)
4029     // real work items added later.
4030 }
4031 
4032 task appsjar() {
4033     dependsOn(sdk)
4034     // Note: the jar dependencies get added elsewhere see project(&quot;:apps&quot;)
4035 }
4036 
4037 // these are empty tasks, allowing us to depend on the task, which may have other
4038 // real work items added later.
4039 task copyAppsArtifacts() {
4040     dependsOn(appsjar)
4041 }
4042 
4043 task apps() {
4044     dependsOn(sdk)
4045     dependsOn(appsjar)
4046     dependsOn(copyAppsArtifacts)
4047 }
4048 
4049 task findbugs() {
4050     dependsOn(sdk)
4051 
4052     doLast {
4053         if (!BUILD_CLOSED) {
4054             println &quot;findbugs task is only run for a closed build&quot;
4055         }
4056     }
4057 }
4058 
4059 // create the zip file of modules for a JDK build
4060 task jdkZip {
4061     dependsOn(sdk)
4062 }
4063 
4064 // The following tasks are for the closed build only. They are a no-op for the open build
4065 
4066 task checkCache() {
4067     dependsOn(updateCacheIfNeeded)
4068 }
4069 
4070 task publicExports() {
4071     dependsOn(sdk, jmods, apps, javadoc, jdkZip)
4072     // note the real work is below in the compileTargets
4073 }
4074 
4075 task perf() {
4076     dependsOn(sdk, apps)
4077     doLast {
4078         if (!BUILD_CLOSED) {
4079             println &quot;perf task is only run for a closed build&quot;
4080         }
4081     }
4082 }
4083 
4084 task zips() {
4085     dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)
4086     // note the real work is below in the compileTargets
4087 }
4088 
4089 task all() {
4090     dependsOn(sdk,publicExports,apps,perf,zips)
4091 }
4092 
4093 
4094 // Construct list of subprojects that are modules
4095 ext.moduleProjList = []
4096 subprojects {
4097     if (project.hasProperty(&quot;buildModule&quot;) &amp;&amp; project.ext.buildModule) {
4098         rootProject.ext.moduleProjList += project
4099         println &quot;module: $project (buildModule=YES)&quot;
4100     } else {
4101         println &quot;module: $project (buildModule=NO)&quot;
4102     }
4103 }
4104 
4105 
4106 // Define the sdk task, which also produces the javafx.swt modular jar
4107 
4108 compileTargets { t -&gt;
4109 
4110     def javafxSwtTask = task(&quot;javafxSwt$t.capital&quot;, type: Jar) {
4111         enabled = COMPILE_SWT
4112         group = &quot;Basic&quot;
4113         description = &quot;Creates the javafx-swt.jar for the $t.name target&quot;
4114         destinationDir = file(&quot;${project(&quot;:swt&quot;).buildDir}/libs&quot;)
4115         archiveName = &quot;javafx-swt.jar&quot;
4116         includeEmptyDirs = false
4117         from(&quot;${project(&quot;:swt&quot;).buildDir}/classes/java/main&quot;);
4118         include(&quot;**/javafx/embed/swt/**&quot;)
4119 
4120         dependsOn(
4121             project(&quot;:swt&quot;).compileJava,
4122             project(&quot;:swt&quot;).processResources,
4123             // note: assemble and classes are not enough for DidWork
4124             project(&quot;:swt&quot;).classes,
4125             // classes is needed for a jar copy
4126             )
4127     }
4128 
4129     // FIXME: do we really need the index task for this modular jar?
4130     def javafxSwtIndexTask = task(&quot;javafxSwtIndex$t.capital&quot;) {
4131         //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
4132         dependsOn(javafxSwtTask)
4133 
4134         doLast() {
4135             ant.jar (update: true, index: true, destfile: &quot;${javafxSwtTask.destinationDir}/${javafxSwtTask.archiveName}&quot;)
4136         }
4137     }
4138 
4139     def sdkTask = task(&quot;sdk$t.capital&quot;) {
4140         group = &quot;Basic&quot;
4141         dependsOn(javafxSwtIndexTask)
4142     }
4143 
4144     sdk.dependsOn(sdkTask)
4145 }
4146 
4147 project(&quot;:apps&quot;) {
4148     // The apps build is Ant based, we will exec ant from gradle.
4149 
4150     // Download the Lucene libraries needed for the Ensemble8 app
4151     def luceneVersion = &quot;7.7.1&quot;
4152     getConfigurations().create(&quot;lucene&quot;);
4153     dependencies {
4154         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-core&quot;, version: luceneVersion
4155         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-grouping&quot;, version: luceneVersion
4156         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-queryparser&quot;, version: luceneVersion
4157     }
4158 
4159     // Copy Lucene libraries into the Ensemble8/lib directory
4160     File ensembleLibDir = rootProject.file(&quot;apps/samples/Ensemble8/lib&quot;);
4161     def libNames = [ &quot;lucene-core-${luceneVersion}.jar&quot;,
4162                      &quot;lucene-grouping-${luceneVersion}.jar&quot;,
4163                      &quot;lucene-queryparser-${luceneVersion}.jar&quot; ]
4164 
4165 
4166     task getLucene(type: Copy) {
4167         doFirst {
4168             ensembleLibDir.mkdirs();
4169         }
4170         into ensembleLibDir
4171         includeEmptyDirs = false
4172         configurations.lucene.files.each { f -&gt;
4173             libNames.each { name -&gt;
4174                 if (name == f.getName()) {
4175                     from f.getPath()
4176                 }
4177             }
4178         }
4179     }
4180 
4181     compileTargets { t -&gt;
4182         List&lt;String&gt; params = []
4183 
4184         params &lt;&lt; &quot;-DtargetBld=$t.name&quot;
4185 
4186         if (!rootProject.ext[t.upper].compileSwing) {
4187             params &lt;&lt; &quot;-DJFX_CORE_ONLY=true&quot;
4188         }
4189         params &lt;&lt; &quot;-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}&quot;
4190         params &lt;&lt; &quot;-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}&quot;
4191         params &lt;&lt; &quot;-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}&quot;
4192 
4193         def appsJar = project.task(&quot;appsJar${t.capital}&quot;) {
4194             dependsOn(sdk, getLucene)
4195             doLast() {
4196                 ant(t.name,
4197                       projectDir.path,
4198                       &quot;appsJar&quot;,
4199                       params);
4200             }
4201         }
4202         rootProject.appsjar.dependsOn(appsJar)
4203 
4204         def appsClean = project.task(&quot;clean${t.capital}&quot;) {
4205             doLast() {
4206                 ant(t.name,
4207                       project.projectDir.path,
4208                       &quot;clean&quot;,
4209                       params);
4210                 delete(ensembleLibDir);
4211             }
4212         }
4213         rootProject.clean.dependsOn(appsClean)
4214     }
4215 }
4216 
4217 // Tasks to create the disk layout for the sdk, jmods, and docs
4218 // in the artifacts directory (publicExports), and zip them up in
4219 // artifacts/bundles (zips)
4220 // These tasks are only used for the standalone SDK.
4221 compileTargets { t -&gt;
4222     if (!HAS_JAVAFX_MODULES) {
4223         def targetProperties = rootProject.ext[t.upper]
4224         def platformPrefix = targetProperties.platformPrefix
4225 
4226         def artifactsDir = &quot;${rootProject.buildDir}/artifacts&quot;
4227         def bundlesDir = &quot;${artifactsDir}/bundles&quot;
4228 
4229         def sdkDirName = &quot;${platformPrefix}sdk&quot;
4230         def sdkDir = &quot;${rootProject.buildDir}/${sdkDirName}&quot;
4231         def sdkBundleName = &quot;javafx-sdk-${RELEASE_VERSION}&quot;
4232         def sdkArtifactsDir = &quot;${artifactsDir}/${sdkBundleName}&quot;
4233 
4234         def docsDirName = &quot;javadoc&quot;
4235         def docsDir = &quot;${rootProject.buildDir}/${docsDirName}&quot;
4236         def docsBundleName = &quot;javafx-docs-${RELEASE_VERSION}&quot;
4237         def docsArtifactsDir = &quot;${artifactsDir}/${docsBundleName}&quot;
4238 
4239         def jmodsDirName = &quot;jmods&quot;
4240         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
4241         def jmodsBundleName = &quot;javafx-jmods-${RELEASE_VERSION}&quot;
4242         def jmodsArtifactsDir = &quot;${artifactsDir}/${jmodsBundleName}&quot;
4243 
4244         def publicExportsTask = task (&quot;publicExportsStandalone${t.capital}&quot;) {
4245             group = &quot;Basic&quot;
4246             description = &quot;Creates the disk layout for sdk, jmods, and docs&quot;
4247         }
4248         publicExports.dependsOn(publicExportsTask)
4249 
4250         def copyArtifactsSdkTask = task(&quot;copyArtifactsSdk$t.capital&quot;, type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {
4251             from sdkDir
4252             into sdkArtifactsDir
4253         }
4254         publicExportsTask.dependsOn(copyArtifactsSdkTask)
4255 
4256         // Need to modify file permissions Windows to make sure that the
4257         // execute bit is set, and that the files are world readable
4258         def chmodArtifactsSdkTask = task(&quot;chmodArtifactsSdk$t.capital&quot;, dependsOn: copyArtifactsSdkTask) {
4259             if (IS_WINDOWS &amp;&amp; IS_USE_CYGWIN) {
4260                 doLast {
4261                     exec {
4262                         workingDir(sdkArtifactsDir)
4263                         commandLine(&quot;chmod&quot;, &quot;-R&quot;, &quot;755&quot;, &quot;.&quot;)
4264                     }
4265                 }
4266             }
4267         }
4268         publicExportsTask.dependsOn(chmodArtifactsSdkTask)
4269 
4270         def copyArtifactsDocsTask = task(&quot;copyArtifactsDocs$t.capital&quot;, type: Copy, dependsOn: chmodArtifactsSdkTask) {
4271             from docsDir
4272             into &quot;${docsArtifactsDir}/api&quot;
4273         }
4274         publicExportsTask.dependsOn(copyArtifactsDocsTask)
4275 
4276         def copyArtifactsJmodsTask = task(&quot;copyArtifactsJmods$t.capital&quot;, type: Copy, dependsOn: copyArtifactsDocsTask) {
4277             from jmodsDir
4278             into &quot;${jmodsArtifactsDir}&quot;
4279         }
4280         publicExportsTask.dependsOn(copyArtifactsJmodsTask)
4281 
4282         def zipsTask = task (&quot;zipsStandalone${t.capital}&quot;) {
4283             group = &quot;Basic&quot;
4284             description = &quot;Creates the public zip bundles&quot;
4285         }
4286         zips.dependsOn(zipsTask)
4287 
4288         // Use native zip tool so that file permissions are preserved on Windows
4289         def zipSdkTask = task(&quot;zipSdk$t.capital&quot;, dependsOn: publicExportsTask) {
4290             doLast {
4291                 def outZipFile = &quot;${bundlesDir}/${sdkBundleName}.zip&quot;
4292                 mkdir bundlesDir
4293                 exec {
4294                     workingDir(artifactsDir)
4295                     commandLine(&quot;zip&quot;, &quot;-q&quot;, &quot;-r&quot;, outZipFile, sdkBundleName)
4296                 }
4297             }
4298         }
4299         zipsTask.dependsOn(zipSdkTask)
4300 
4301         def zipDocsTask = task(&quot;zipDocs$t.capital&quot;, type: Zip, dependsOn: zipSdkTask) {
4302             destinationDir = file(&quot;${bundlesDir}&quot;)
4303             archiveName = &quot;${docsBundleName}.zip&quot;
4304             includeEmptyDirs = false
4305             from docsArtifactsDir
4306             into &quot;${docsBundleName}&quot;
4307         }
4308         zipsTask.dependsOn(zipDocsTask)
4309 
4310         def zipJmodsTask = task(&quot;zipJmods$t.capital&quot;, type: Zip, dependsOn: zipDocsTask) {
4311             destinationDir = file(&quot;${bundlesDir}&quot;)
4312             archiveName = &quot;${jmodsBundleName}.zip&quot;
4313             includeEmptyDirs = false
4314             from jmodsArtifactsDir
4315             into &quot;${jmodsBundleName}&quot;
4316         }
4317         zipsTask.dependsOn(zipJmodsTask)
4318     }
4319 }
4320 
4321 
4322 /******************************************************************************
4323  *                                                                            *
4324  *                               Modules                                      *
4325  *                                                                            *
4326  *****************************************************************************/
4327 
4328 ext.moduleDependencies = [file(&quot;dependencies&quot;)]
4329 
4330 task buildModules {
4331 }
4332 
4333 // Combine the classes, lib, and bin for each module
4334 compileTargets { t -&gt;
4335     def targetProperties = project.ext[t.upper]
4336 
4337     def platformPrefix = targetProperties.platformPrefix
4338     def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
4339     def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
4340     def modulesDir = &quot;${bundledSdkDir}/modules&quot;
4341     def modulesCmdsDir = &quot;${bundledSdkDir}/modules_cmds&quot;
4342     def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
4343     def modulesSrcDir = &quot;${bundledSdkDir}/modules_src&quot;
4344     def modulesConfDir = &quot;${bundledSdkDir}/modules_conf&quot;
4345     def modulesLegalDir = &quot;${bundledSdkDir}/modules_legal&quot;
4346     def modulesMakeDir = &quot;${bundledSdkDir}/make&quot;
4347 
4348     final File runArgsFile = file(&quot;${rootProject.buildDir}/${RUNARGSFILE}&quot;)
4349     final File compileArgsFile = file(&quot;${rootProject.buildDir}/${COMPILEARGSFILE}&quot;)
4350 
4351     project.files(runArgsFile);
4352 
4353     def buildModulesTask = task(&quot;buildModules$t.capital&quot;, group: &quot;Build&quot;) {
4354         // BUNDLED SDK
4355 
4356         // Copy dependencies/*/module-info.java.extra
4357         // merging as needed, removing duplicates
4358         // only lines with &#39;exports&#39; will be copied
4359         def dependencyRoots = moduleDependencies
4360         if (rootProject.hasProperty(&quot;closedModuleDepedencies&quot;)) {
4361             dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
4362         }
4363 
4364         // Create the inputs/outputs list first to support UP-TO-DATE
4365         ArrayList outputNames = new ArrayList()
4366         dependencyRoots.each { root -&gt;
4367             FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4368             ft.each() { e-&gt;
4369                 inputs.file(e)
4370 
4371                 String usename = e.path
4372                 String filePath = e.getAbsolutePath()
4373                 String folderPath = root.getAbsolutePath()
4374                 if (filePath.startsWith(folderPath)) {
4375                     usename = filePath.substring(folderPath.length() + 1);
4376                 }
4377                 if (! outputNames.contains(usename) ) {
4378                     outputNames.add(usename)
4379                 }
4380             }
4381         }
4382 
4383         outputNames.each() { e-&gt;
4384                 File f = new File(modulesSrcDir, e)
4385                 outputs.file(f)
4386         }
4387 
4388         def outputPolicyDir = &quot;${modulesConfDir}/java.base/security&quot;
4389         def outputPolicyFile = file(&quot;${outputPolicyDir}/java.policy.extra&quot;)
4390 
4391         outputs.file(outputPolicyFile)
4392         moduleProjList.each { project -&gt;
4393             def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4394             def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4395             if (policyFile.exists()) {
4396                 inputs.file(policyFile)
4397             }
4398         }
4399 
4400         doLast {
4401             Map extras = [:]
4402 
4403             dependencyRoots.each { root -&gt;
4404                 FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4405                 ft.each() { e-&gt;
4406                     String usename = e.path
4407                     String filePath = e.getAbsolutePath()
4408                     String folderPath = root.getAbsolutePath()
4409                     if (filePath.startsWith(folderPath)) {
4410                         usename = filePath.substring(folderPath.length() + 1);
4411                     }
4412                     if (extras.containsKey(usename)) {
4413                         List&lt;String&gt; lines = extras.get(usename)
4414                         e.eachLine { line -&gt;
4415                             line = line.trim()
4416                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4417                                 lines &lt;&lt; line
4418                             }
4419                         }
4420 
4421                     } else {
4422                         List&lt;String&gt; lines = []
4423                         e.eachLine { line -&gt;
4424                             line = line.trim()
4425                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4426                                 lines &lt;&lt; line
4427                             }
4428                         }
4429                         extras.put(usename,lines)
4430                     }
4431                 }
4432             }
4433             extras.keySet().each() { e-&gt;
4434                 File f = new File(modulesSrcDir, e)
4435                 f.getParentFile().mkdirs()
4436                 f.delete()
4437 
4438                 extras.get(e).unique().each() { l-&gt;
4439                     f &lt;&lt; l
4440                     f &lt;&lt; &quot;\n&quot;
4441                 }
4442             }
4443 
4444             // concatecate java.policy files into a single file
4445             //
4446             mkdir outputPolicyDir
4447             outputPolicyFile.delete()
4448             moduleProjList.each { project -&gt;
4449                 def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4450                 def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4451                 if (policyFile.exists()) outputPolicyFile &lt;&lt; policyFile.text
4452             }
4453         }
4454     }
4455     buildModules.dependsOn(buildModulesTask)
4456 
4457     // BUNDLED SDK
4458     moduleProjList.each { project -&gt;
4459         // Copy classes, bin, and lib directories
4460 
4461         def moduleName = project.ext.moduleName
4462         def buildDir = project.buildDir
4463 
4464         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4465         def dstClassesDir = &quot;${modulesDir}/${moduleName}&quot;
4466         def copyClassFilesTask = project.task(&quot;copyClassFiles$t.capital&quot;, type: Copy, dependsOn: project.assemble) {
4467             from srcClassesDir
4468             into dstClassesDir
4469             exclude(&quot;module-info.class&quot;)
4470         }
4471 
4472         def srcCmdsDir = &quot;${buildDir}/${platformPrefix}module-bin&quot;
4473         def dstCmdsDir = &quot;${modulesCmdsDir}/${moduleName}&quot;
4474         def copyBinFilesTask = project.task(&quot;copyBinFiles$t.capital&quot;, type: Copy, dependsOn: copyClassFilesTask) {
4475             from srcCmdsDir
4476             into dstCmdsDir
4477         }
4478 
4479         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4480         def dstLibsDir = &quot;${modulesLibsDir}/${moduleName}&quot;
4481         def copyLibFilesTask = project.task(&quot;copyLibFiles$t.capital&quot;, type: Copy, dependsOn: copyBinFilesTask) {
4482             from srcLibsDir
4483             into dstLibsDir
4484         }
4485 
4486         // Copy module sources
4487         // FIXME: javafx.swt sources?
4488         def copySources = project.hasProperty(&quot;includeSources&quot;) &amp;&amp; project.includeSources
4489         def copySourceFilesTask = project.task(&quot;copySourceFiles$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4490             if (copySources) {
4491                 from &quot;${project.projectDir}/src/main/java&quot;
4492                 if (project.name.equals(&quot;base&quot;)) {
4493                     from &quot;${project.projectDir}/build/gensrc/java&quot;
4494                 }
4495                 if (project.name.equals(&quot;web&quot;)) {
4496                     from &quot;${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
4497                 }
4498             } else {
4499                 from &quot;${project.projectDir}/src/main/java/module-info.java&quot;
4500             }
4501             into &quot;${modulesSrcDir}/${moduleName}&quot;
4502             include &quot;**/*.java&quot;
4503 
4504             if (project.hasProperty(&quot;sourceFilter&quot;)) {
4505                 filter(project.sourceFilter)
4506             }
4507         }
4508 
4509         // Copy .html and other files needed for doc bundles
4510         def copyDocFiles = project.task(&quot;copyDocFiles$t.capital&quot;, type: Copy, dependsOn: copySourceFilesTask) {
4511             if (copySources) {
4512                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4513                     include &quot;**/*.html&quot;
4514                     filter { line-&gt;
4515                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4516                     }
4517                 }
4518                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4519                     exclude &quot;**/*.html&quot;
4520                 }
4521                 from(&quot;${project.projectDir}/src/main/java&quot;) {
4522                     exclude &quot;**/*.java&quot;
4523                 }
4524 
4525                 into &quot;${modulesSrcDir}/${moduleName}&quot;
4526             }
4527         }
4528 
4529         // Copy make/build.properties
4530         def srcMakeDir = &quot;${project.projectDir}/make&quot;
4531         def dstMakeDir = &quot;${modulesMakeDir}/${moduleName}&quot;
4532         def copyBuildPropertiesTask = project.task(&quot;copyBuildProperties$t.capital&quot;, type: Copy, dependsOn: copyDocFiles) {
4533             from srcMakeDir
4534             into dstMakeDir
4535         }
4536 
4537         // Copy legal files
4538         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4539         def dstLegalDir = &quot;${modulesLegalDir}/${moduleName}&quot;
4540         def copyLegalTask = project.task(&quot;copyLegal$t.capital&quot;, type: Copy, dependsOn: copyBuildPropertiesTask) {
4541             from srcLegalDir
4542             into dstLegalDir
4543 
4544             // Exclude ANGLE since we (currently) do not use it
4545             exclude(&quot;angle.md&quot;)
4546         }
4547 
4548         buildModulesTask.dependsOn(
4549             copyClassFilesTask,
4550             copyLibFilesTask,
4551             copySourceFilesTask,
4552             copyDocFiles,
4553             copyBuildPropertiesTask,
4554             copyLegalTask)
4555     }
4556 
4557     // ============================================================
4558 
4559     def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
4560     def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
4561     def standaloneLibDir = &quot;${standaloneSdkDir}/lib&quot;
4562     def libDest=targetProperties.libDest
4563     def standaloneNativeDir = &quot;${standaloneSdkDir}/${libDest}&quot;
4564     def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
4565     def standaloneSrcZipName = &quot;src.zip&quot;
4566 
4567     // STANDALONE SDK
4568     moduleProjList.each { project -&gt;
4569         // Copy classes, bin, and lib directories
4570 
4571         def moduleName = project.ext.moduleName
4572         def buildDir = project.buildDir
4573 
4574         // Create modular jars
4575         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4576         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4577         def dstModularJarDir = &quot;${standaloneLibDir}&quot;
4578         def modularJarName = &quot;${moduleName}.jar&quot;
4579         def modularJarTask = project.task(&quot;modularJarStandalone$t.capital&quot;, type: Jar, dependsOn: project.assemble) {
4580             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4581             archiveName = modularJarName
4582             includeEmptyDirs = false
4583             from srcClassesDir
4584         }
4585 
4586         // Copy native libraries
4587         def srcNativeDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4588         def dstNativeDir = &quot;${standaloneNativeDir}&quot;
4589         def copyNativeFilesTask = project.task(&quot;copyNativeFilesStandalone$t.capital&quot;, type: Copy, dependsOn: modularJarTask) {
4590             from srcNativeDir
4591             into dstNativeDir
4592             include(&quot;*.dll&quot;)
4593         }
4594 
4595         // Copy other lib files
4596         def dstLibsDir = &quot;${standaloneLibDir}&quot;
4597         def copyLibFilesTask = project.task(&quot;copyLibFilesStandalone$t.capital&quot;, type: Copy, dependsOn: copyNativeFilesTask) {
4598             from srcLibsDir
4599             into dstLibsDir
4600             exclude(&quot;*.dll&quot;)
4601         }
4602 
4603         // Copy legal files
4604         def licenseFiles = [ &quot;ADDITIONAL_LICENSE_INFO&quot;, &quot;ASSEMBLY_EXCEPTION&quot;, &quot;LICENSE&quot; ]
4605         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4606         def dstLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
4607         def copyLegalTask = project.task(&quot;copyLegalStandalone$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4608 
4609             def rtDir = rootProject.file(&#39;.&#39;)
4610             licenseFiles.each { lFile -&gt;
4611                 from &quot;${rtDir}/${lFile}&quot;
4612             }
4613 
4614             from srcLegalDir
4615 
4616             into dstLegalDir
4617 
4618             // Exclude ANGLE since we (currently) do not use it
4619             exclude(&quot;angle.md&quot;)
4620         }
4621 
4622         buildModulesTask.dependsOn(
4623             modularJarTask,
4624             copyNativeFilesTask,
4625             copyLibFilesTask,
4626             copyLegalTask)
4627     }
4628 
4629     // Zip module sources for standalone SDK
4630     //
4631     // NOTE: the input is taken from the modular-sdk/modules_src dir
4632     // so that we don&#39;t have to duplicate the logic and create another
4633     // temporary directory. This is somewhat inelegant, since the bundled sdk
4634     // and the standalone sdk should be independent of one another, but seems
4635     // better than the alternatives.
4636     def zipSourceFilesTask = project.task(&quot;zipSourceFilesStandalone$t.capital&quot;, type: Zip, dependsOn: buildModulesTask) {
4637         destinationDir = file(&quot;${standaloneLibDir}&quot;)
4638         archiveName = standaloneSrcZipName
4639         includeEmptyDirs = false
4640         from modulesSrcDir
4641         include &quot;**/*.java&quot;
4642     }
4643     buildModules.dependsOn(zipSourceFilesTask)
4644 
4645     // ============================================================
4646 
4647     // Maven Publications
4648     def publicationDirName = &quot;${platformPrefix}publications&quot;
4649     def publicationDir = &quot;${rootProject.buildDir}/${publicationDirName}&quot;
4650 
4651     moduleProjList.each { project -&gt; 
4652         // Create publications to be uploaded 
4653 
4654         def moduleName = project.ext.moduleName
4655         def buildDir = project.buildDir
4656 
4657         def dstModularJarDir=&quot;${publicationDir}&quot;
4658         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4659         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4660 
4661         def modularEmptyPublicationJarName = &quot;${moduleName}.jar&quot;
4662         def modularEmptyPublicationJarTask = project.task(&quot;moduleEmptyPublicationJar${t.capital}&quot;, type: Jar) {
4663             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4664             archiveName = modularEmptyPublicationJarName
4665             manifest {
4666                 attributes(
4667                     &#39;Automatic-Module-Name&#39;:&quot;${moduleName}Empty&quot;
4668                 )
4669             }
4670         }
4671 
4672         def modularPublicationJarName = &quot;${moduleName}-${t.name}.jar&quot;
4673         def modularPublicationJarTask = project.task(&quot;modularPublicationJar${t.capital}&quot;, type: Jar, dependsOn: modularEmptyPublicationJarTask) {
4674             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4675             archiveName = modularPublicationJarName
4676             from srcLibsDir
4677             from srcClassesDir
4678         }
4679 
4680         buildModulesTask.dependsOn(modularPublicationJarTask)
4681 
4682     }
4683     // ============================================================
4684 
4685     def buildRunArgsTask = task(&quot;buildRunArgs$t.capital&quot;,
4686             group: &quot;Build&quot;, dependsOn: buildModulesTask) {
4687         outputs.file(runArgsFile);
4688         inputs.file(EXTRAADDEXPORTS);
4689         doLast() {
4690             List&lt;String&gt;modpath = []
4691             List&lt;String&gt;modnames = []
4692 
4693             moduleProjList.each { project -&gt;
4694                 def moduleName = project.ext.moduleName
4695                 def dstModuleDir = cygpath(&quot;${modulesDir}/${moduleName}&quot;)
4696                 if (HAS_JAVAFX_MODULES) {
4697                     modpath &lt;&lt;  &quot;${moduleName}=${dstModuleDir}&quot;
4698                 } else {
4699                     modnames &lt;&lt; moduleName
4700                 }
4701             }
4702 
4703             if (HAS_JAVAFX_MODULES) {
4704                 writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)
4705                 writeRunArgsFile(compileArgsFile, null, modpath, null)
4706 
4707                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
4708                     runArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4709                     compileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4710                 }
4711             } else {
4712                 modpath = [ cygpath(&quot;${standaloneLibDir}&quot;) ]
4713                 writeRunArgsFile(runArgsFile, null, modpath, modnames)
4714                 writeRunArgsFile(compileArgsFile, null, modpath, modnames)
4715             }
4716         }
4717     }
4718     buildModules.dependsOn(buildRunArgsTask)
4719 
4720     def isWindows = IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;;
4721     def isMac = IS_MAC &amp;&amp; t.name == &quot;mac&quot;;
4722 
4723     // Create layout for modular classes
4724     moduleProjList.each { project -&gt;
4725         def buildModuleClassesTask = project.task(&quot;buildModule$t.capital&quot;, group: &quot;Build&quot;, type: Copy) {
4726             dependsOn(project.assemble)
4727             def buildDir = project.buildDir
4728             def sourceBuildDirs = [
4729                 &quot;${buildDir}/classes/java/main/${project.moduleName}&quot;,
4730             ]
4731 
4732             def moduleClassesDir = &quot;$buildDir/${platformPrefix}module-classes&quot;
4733                 includeEmptyDirs = false
4734                 sourceBuildDirs.each { d -&gt;
4735                     from d
4736                 }
4737                 into moduleClassesDir
4738 
4739                 // Exclude obsolete, experimental, or non-shipping code
4740                 exclude(&quot;version.rc&quot;)
4741                 exclude(&quot;com/sun/glass/ui/swt&quot;)
4742                 exclude(&quot;com/sun/javafx/tools/ant&quot;)
4743                 exclude(&quot;com/javafx/main&quot;)
4744                 exclude(&quot;com/sun/javafx/webkit/drt&quot;)
4745                 if (!IS_INCLUDE_NULL3D) {
4746                     exclude (&quot;com/sun/prism/null3d&quot;)
4747                 }
4748                 if (!IS_INCLUDE_ES2) {
4749                        exclude(&quot;com/sun/prism/es2&quot;,
4750                                &quot;com/sun/scenario/effect/impl/es2&quot;)
4751                 }
4752 
4753                 // Exclude platform-specific classes for other platforms
4754 
4755                 if (!isMac) {
4756                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/osx&quot;,
4757                              &quot;com/sun/prism/es2/MacGL*&quot;,
4758                              &quot;com/sun/glass/events/mac&quot;,
4759                              &quot;com/sun/glass/ui/mac&quot;,
4760                              )
4761                 }
4762 
4763                 if (!isWindows) {
4764                     exclude (&quot;**/*.hlsl&quot;,
4765                              &quot;com/sun/glass/ui/win&quot;,
4766                              &quot;com/sun/prism/d3d&quot;,
4767                              &quot;com/sun/prism/es2/WinGL*&quot;,
4768                              &quot;com/sun/scenario/effect/impl/hw/d3d&quot;
4769                              )
4770                 }
4771 
4772                 if (!targetProperties.includeGTK) { //usually IS_LINUX
4773                     exclude (
4774                              &quot;com/sun/glass/ui/gtk&quot;,
4775                              &quot;com/sun/prism/es2/EGL*&quot;,
4776                              &quot;com/sun/prism/es2/X11GL*&quot;
4777                              )
4778                 }
4779 
4780                 if (!targetProperties.includeEGL) {
4781                     exclude (&quot;com/sun/prism/es2/EGL*&quot;)
4782                 }
4783 
4784                 if (!targetProperties.includeMonocle) {
4785                     exclude (&quot;com/sun/glass/ui/monocle&quot;)
4786                     exclude(&quot;com/sun/prism/es2/Monocle*&quot;)
4787                 }
4788 
4789                 if (t.name != &#39;ios&#39;) {
4790                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/ios&quot;,
4791                              &quot;com/sun/glass/ui/ios&quot;,
4792                              &quot;com/sun/prism/es2/IOS*&quot;
4793                              )
4794                 }
4795 
4796                 if (t.name != &#39;android&#39; &amp;&amp; t.name != &#39;dalvik&#39;) {
4797                     exclude (&quot;com/sun/glass/ui/android&quot;)
4798                 }
4799 
4800                 // Filter out other platform-specific classes
4801                 if (targetProperties.containsKey(&#39;jfxrtJarExcludes&#39;)) {
4802                     exclude(targetProperties.jfxrtJarExcludes)
4803                 }
4804 
4805                 /* FIXME: JIGSAW -- handle this in the module itself
4806                 String webbld = project(&quot;:web&quot;).buildDir.path
4807                 String ctrlbld = project(&quot;:controls&quot;).buildDir.path
4808                 if (t.name == &#39;android&#39;) {
4809                     from (&quot;${webbld}/classes/android&quot;,
4810                           &quot;${webbld}/resources/android&quot;,
4811                           &quot;${ctrlbld}/classes/android&quot;,
4812                           &quot;${ctrlbld}/resources/android&quot;)
4813                 } else if (t.name == &#39;ios&#39;) {
4814                     from (&quot;${webbld}/classes/ios&quot;,
4815                           &quot;${webbld}/resources/ios&quot;)
4816                 } else {
4817                     from (&quot;${webbld}/classes/java/main&quot;)
4818                 }
4819                 */
4820         }
4821         buildModulesTask.dependsOn(buildModuleClassesTask)
4822     }
4823 
4824     def buildModuleLibsTask = task(&quot;buildModuleLibs$t.capital&quot;) {
4825         group = &quot;Basic&quot;
4826 
4827         def baseProject = project(&quot;:base&quot;);
4828 
4829         def graphicsProject = project(&quot;:graphics&quot;);
4830 
4831         def mediaProject = project(&quot;:media&quot;);
4832 
4833         def webProject = project(&quot;:web&quot;);
4834         dependsOn(webProject.assemble)
4835 
4836         def swtProject = project(&quot;:swt&quot;);
4837 
4838         def library = targetProperties.library
4839 
4840         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
4841         def modLibDest = targetProperties.modLibDest
4842         def moduleNativeDirName = &quot;${platformPrefix}module-$modLibDest&quot;
4843 
4844         def buildModuleBaseTask = task(&quot;buildModuleBase$t.capital&quot;, dependsOn: baseProject.assemble) {
4845             group = &quot;Basic&quot;
4846             description = &quot;creates javafx.base property files&quot;
4847 
4848             def moduleLibDir = &quot;${baseProject.buildDir}/${platformPrefix}module-lib&quot;
4849             final File javafxProperties = file(&quot;${moduleLibDir}/javafx.properties&quot;)
4850             outputs.file(javafxProperties)
4851 
4852             if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4853                 final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4854                 outputs.file(javafxPlatformProperties)
4855             }
4856 
4857             doLast {
4858                 mkdir moduleLibDir
4859 
4860                 javafxProperties.delete()
4861                 javafxProperties &lt;&lt; &quot;javafx.version=$RELEASE_VERSION_SHORT&quot;;
4862                 javafxProperties &lt;&lt; &quot;\n&quot;
4863                 javafxProperties &lt;&lt; &quot;javafx.runtime.version=$RELEASE_VERSION_LONG&quot;;
4864                 javafxProperties &lt;&lt; &quot;\n&quot;
4865                 javafxProperties &lt;&lt; &quot;javafx.runtime.build=$PROMOTED_BUILD_NUMBER&quot;;
4866                 javafxProperties &lt;&lt; &quot;\n&quot;
4867                 // Include any properties that have been defined (most likely in
4868                 // one of the various platform gradle files)
4869                 if (targetProperties.containsKey(&quot;javafxProperties&quot;)) {
4870                     javafxProperties &lt;&lt; targetProperties.javafxProperties
4871                     javafxProperties &lt;&lt; &quot;\n&quot;
4872                 }
4873 
4874                 // Embedded builds define this file as well
4875                 if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4876                     final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4877                     javafxPlatformProperties.delete()
4878                     javafxPlatformProperties &lt;&lt; targetProperties.javafxPlatformProperties
4879                     javafxPlatformProperties &lt;&lt; &quot;\n&quot;
4880                 }
4881             }
4882         }
4883 
4884         def buildModuleGraphicsTask = task(&quot;buildModuleGraphics$t.capital&quot;, type: Copy, dependsOn: graphicsProject.assemble) {
4885             group = &quot;Basic&quot;
4886             description = &quot;copies javafx.graphics native libraries&quot;
4887 
4888             into &quot;${graphicsProject.buildDir}/${moduleNativeDirName}&quot;
4889 
4890             from(&quot;${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}&quot;)
4891             def libs = [&#39;font&#39;, &#39;prism&#39;, &#39;prismSW&#39;, &#39;glass&#39;, &#39;iio&#39;]
4892             if (IS_INCLUDE_ES2) {
4893                 libs += [&#39;prismES2&#39;];
4894             }
4895             if (IS_COMPILE_PANGO) {
4896                 libs += [&#39;fontFreetype&#39;, &#39;fontPango&#39;];
4897             }
4898             libs.each { lib -&gt;
4899                 def variants = targetProperties[lib].containsKey(&#39;variants&#39;) &amp;&amp; !useLipo ? targetProperties[lib].variants : [null]
4900                 variants.each { variant -&gt;
4901                     def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
4902                     from (&quot;${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}&quot;)
4903                 }
4904             }
4905             if (IS_WINDOWS) {
4906                 from (&quot;${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}&quot;);
4907                 targetProperties.VS2017DLLs.each { vslib -&gt;
4908                     from (&quot;$vslib&quot;);
4909                 }
4910                 targetProperties.WinSDKDLLs.each { winsdklib -&gt;
4911                     from (&quot;$winsdklib&quot;);
4912                 }
4913             }
4914         }
4915 
4916         def buildModuleMediaTask = task(&quot;buildModuleMedia$t.capital&quot;, type: Copy, dependsOn: mediaProject.assemble) {
4917             group = &quot;Basic&quot;
4918             description = &quot;copies javafx.media native libraries&quot;
4919 
4920             into &quot;${mediaProject.buildDir}/${moduleNativeDirName}&quot;
4921 
4922             def mediaBuildType = project(&quot;:media&quot;).ext.buildType
4923             if (IS_COMPILE_MEDIA) {
4924                 [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4925                     from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4926 
4927                 if (t.name == &quot;mac&quot;) {
4928                     // OSX media natives
4929                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4930                         from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4931                 } else if (t.name == &quot;linux&quot;) {
4932                     from(&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}&quot;) { include &quot;libavplugin*.so&quot; }
4933                 } else from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(&quot;glib-lite&quot;)}&quot;)
4934             } else {
4935                 if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4936                     [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4937                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4938                 }
4939 
4940                 if (t.name == &quot;mac&quot;) {
4941                     // copy libjfxmedia_{avf,qtkit}.dylib if they exist
4942                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4943                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4944                 } else if (t.name == &quot;linux&quot;) {
4945                     from(MEDIA_STUB) { include &quot;libavplugin*.so&quot; }
4946                 }
4947                 else if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4948                     from (&quot;$MEDIA_STUB/${library(&quot;glib-lite&quot;)}&quot;)
4949                 }
4950             }
4951         }
4952 
4953         def buildModuleWeb = task(&quot;buildModuleWeb$t.capital&quot;, type: Copy, dependsOn: webProject.assemble) {
4954             group = &quot;Basic&quot;
4955             description = &quot;copies javafx.web native libraries&quot;
4956 
4957             into &quot;${webProject.buildDir}/${moduleNativeDirName}&quot;
4958 
4959             if (IS_COMPILE_WEBKIT) {
4960                 from (&quot;${webProject.buildDir}/libs/${t.name}/${library(&#39;jfxwebkit&#39;)}&quot;)
4961             } else {
4962                 if (t.name != &quot;android&quot; &amp;&amp; t.name != &quot;ios&quot; &amp;&amp; t.name != &quot;dalvik&quot;) {
4963                     from (&quot;$WEB_STUB/${library(&#39;jfxwebkit&#39;)}&quot;)
4964                 }
4965             }
4966         }
4967 
4968         def buildModuleSWT = task(&quot;buildModuleSWT$t.capital&quot;, type: Copy) {
4969             group = &quot;Basic&quot;
4970             description = &quot;copies SWT JAR&quot;
4971 
4972             // FIXME: the following is a hack to workaround the fact that there
4973             // is no way to deliver javafx-swt.jar other than in one of the
4974             // existing runtime modules.
4975 
4976             dependsOn(buildModuleGraphicsTask) // we copy to the graphics module
4977 
4978             if (COMPILE_SWT) {
4979                 def javafxSwtIndexTask = tasks.getByName(&quot;javafxSwtIndex${t.capital}&quot;);
4980                 dependsOn(javafxSwtIndexTask)
4981                 //enabled = COMPILE_SWT
4982             }
4983 
4984             // Copy javafx-swt.jar to the javafx-graphics module lib dir
4985             from &quot;${swtProject.buildDir}/libs/javafx-swt.jar&quot;
4986             into &quot;${graphicsProject.buildDir}/${platformPrefix}module-lib&quot;
4987         }
4988 
4989         dependsOn(
4990             buildModuleBaseTask,
4991             buildModuleGraphicsTask,
4992             buildModuleMediaTask,
4993             buildModuleWeb,
4994             buildModuleSWT,
4995             )
4996     }
4997     buildModulesTask.dependsOn(buildModuleLibsTask)
4998 
4999     def zipTask = project.task(&quot;buildModuleZip$t.capital&quot;, type: Zip, group: &quot;Build&quot;,
5000             dependsOn: buildModulesTask ) {
5001 
5002         // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
5003         def jfxBundle = &quot;${platformPrefix}javafx-exports.zip&quot;
5004 
5005         doFirst() {
5006             file(&quot;${rootProject.buildDir}/${jfxBundle}&quot;).delete()
5007         }
5008 
5009         archiveName = jfxBundle
5010         destinationDir = file(&quot;${rootProject.buildDir}&quot;)
5011         includeEmptyDirs = false
5012         from &quot;${bundledSdkDir}&quot;
5013     }
5014     jdkZip.dependsOn(zipTask)
5015 
5016     Task testArgFiles = task(&quot;createTestArgfiles${t.capital}&quot;) {
5017 
5018         File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)
5019         //test (shimed) version
5020         File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)
5021         // And a test java.policy file
5022         File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE)
5023         // and the non-test version to go with run.args
5024         File runJavaPolicyFile = new File(rootProject.buildDir, RUNJAVAPOLICYFILE);
5025 
5026         outputs.file(testRunArgsFile)
5027         outputs.file(testCompileArgsFile)
5028         outputs.file(testJavaPolicyFile)
5029         outputs.file(runJavaPolicyFile)
5030         inputs.file(EXTRAADDEXPORTS);
5031 
5032         doLast() {
5033             rootProject.buildDir.mkdir()
5034 
5035             List&lt;String&gt; projNames = []
5036             moduleProjList.each { project -&gt;
5037                 projNames &lt;&lt; project.name
5038             }
5039 
5040             // And the test (shimed) variation...
5041 
5042             testRunArgsFile.delete()
5043             testCompileArgsFile.delete()
5044 
5045             testJavaPolicyFile.delete()
5046             runJavaPolicyFile.delete()
5047 
5048             List&lt;String&gt; modpath = []
5049 
5050             if (HAS_JAVAFX_MODULES) {
5051                 moduleProjList.each { project -&gt;
5052                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5053                         File dir;
5054                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5055                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5056                         } else {
5057                            dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5058                         }
5059 
5060                         def dstModuleDir = cygpath(dir.path)
5061                         modpath &lt;&lt; &quot;${project.ext.moduleName}=${dstModuleDir}&quot;
5062 
5063                         String themod = dir.toURI()
5064                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5065                         &quot;    permission java.security.AllPermission;\n&quot; +
5066                         &quot;};\n&quot;
5067 
5068                         dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5069                         themod = dir.toURI()
5070                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5071                         &quot;    permission java.security.AllPermission;\n&quot; +
5072                         &quot;};\n&quot;
5073                     }
5074                 }
5075 
5076                 writeRunArgsFile(testCompileArgsFile, null, modpath, null)
5077                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)
5078 
5079                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
5080                     testCompileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5081                     testRunArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5082                 }
5083             } else  {
5084                 def modnames = []
5085                 moduleProjList.each { project -&gt;
5086                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5087                         modnames &lt;&lt; project.ext.moduleName
5088                         File dir;
5089                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5090                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5091                         } else {
5092                            dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5093                         }
5094 
5095                         def dstModuleDir = cygpath(dir.path)
5096                         modpath &lt;&lt; &quot;${dstModuleDir}&quot;
5097 
5098                         String themod = dir.toURI()
5099                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5100                         &quot;    permission java.security.AllPermission;\n&quot; +
5101                         &quot;};\n&quot;
5102 
5103                         dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5104                         themod = dir.toURI()
5105                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5106                         &quot;    permission java.security.AllPermission;\n&quot; +
5107                         &quot;};\n&quot;
5108                     }
5109                 }
5110 
5111                 writeRunArgsFile(testCompileArgsFile, null, modpath, modnames)
5112                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)
5113 
5114             }
5115         }
5116     }
5117     sdk.dependsOn(testArgFiles)
5118     createTestArgfiles.dependsOn(testArgFiles)
5119 
5120     def sdkTask = tasks.getByName(&quot;sdk${t.capital}&quot;);
5121     sdkTask.dependsOn(buildModulesTask)
5122 }
5123 sdk.dependsOn(buildModules)
5124 
5125 // Build the jmod for each module for the standalone SDK only.
5126 compileTargets { t -&gt;
5127     if (!HAS_JAVAFX_MODULES) {
5128         def targetProperties = project.ext[t.upper]
5129 
5130         def platformPrefix = targetProperties.platformPrefix
5131         def jmodsDirName = &quot;${platformPrefix}jmods&quot;
5132         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
5133         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
5134         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
5135         def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
5136 
5137         def excludeNativeLibs = []
5138         if (IS_WINDOWS) {
5139             // List of duplicate Microsoft DLLs to exclude
5140             excludeNativeLibs += targetProperties.VS2017DLLNames
5141             excludeNativeLibs += targetProperties.WinSDKDLLNames
5142         }
5143 
5144         moduleProjList.each { project -&gt;
5145             def moduleName = project.ext.moduleName
5146             def buildDir = project.buildDir
5147 
5148             def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
5149             def srcLibDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
5150             def srcLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
5151 
5152             def jmodName = &quot;${moduleName}.jmod&quot;
5153             def jmodFile = &quot;${jmodsDir}/${jmodName}&quot;
5154             def jmodTask = project.task(&quot;jmod$t.capital&quot;, group: &quot;Build&quot;, dependsOn: sdk) {
5155                 doLast {
5156                     mkdir jmodsDir
5157                     delete(jmodFile);
5158                     exec {
5159                         commandLine(JMOD)
5160                         args(&quot;create&quot;)
5161                         args(&quot;--class-path&quot;)
5162                         args(srcClassesDir)
5163                         // Not all modules have a &quot;lib&quot; dir
5164                         if (file(srcLibDir).isDirectory()) {
5165                             args(&quot;--libs&quot;)
5166                             args(srcLibDir)
5167                         }
5168                         // Exclude duplicate native libs from javafx.graphics.jmod
5169                         if (moduleName == &quot;javafx.graphics&quot;) {
5170                             excludeNativeLibs.each { name -&gt;
5171                                 args(&quot;--exclude&quot;)
5172                                 args(name)
5173                             }
5174                         }
5175                         args(&quot;--legal-notices&quot;)
5176                         args(srcLegalDir)
5177                         args(jmodFile)
5178                     }
5179                 }
5180             }
5181 
5182             jmods.dependsOn(jmodTask)
5183         }
5184     }
5185 }
5186 
5187 /******************************************************************************
5188  *                                                                            *
5189  *                              BUILD_CLOSED                                  *
5190  *                                                                            *
5191  * This next section should remain at the end of the build script. It allows  *
5192  * for a &quot;supplemental&quot; gradle file to be used to extend the normal build     *
5193  * structure. For example, this is used for passing a supplemental gradle     *
5194  * file for producing official JavaFX builds.                                 *
5195  *                                                                            *
5196  *****************************************************************************/
5197 
5198 if (BUILD_CLOSED) {
5199     apply from: supplementalBuildFile
5200 }
5201 
5202 task showFlags {
5203 }
5204 
5205 compileTargets { t -&gt;
5206     // Every platform must define these variables
5207     def props = project.ext[t.upper];
5208     showFlags.dependsOn(
5209         project.task(&quot;showFlags$t.upper&quot;) {
5210             doLast() {
5211                 println &quot;Properties set for $t.upper&quot;
5212                 props.each { println it }
5213             }
5214         }
5215     )
5216 
5217 }
    </pre>
  </body>
</html>