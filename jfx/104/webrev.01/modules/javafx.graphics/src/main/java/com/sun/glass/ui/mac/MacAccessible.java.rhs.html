<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/glass/ui/mac/MacAccessible.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.glass.ui.mac;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Arrays;
  30 import java.util.List;
  31 import java.util.function.Function;
  32 import javafx.collections.FXCollections;
  33 import javafx.collections.ObservableList;
  34 import javafx.geometry.BoundingBox;
  35 import javafx.geometry.Bounds;
  36 import javafx.geometry.Point2D;
  37 import javafx.geometry.Orientation;
  38 import javafx.scene.AccessibleAction;
  39 import javafx.scene.AccessibleAttribute;
  40 import javafx.scene.AccessibleRole;
  41 import javafx.scene.Scene;
  42 import javafx.scene.Node;
  43 import javafx.scene.input.KeyCharacterCombination;
  44 import javafx.scene.input.KeyCode;
  45 import javafx.scene.input.KeyCodeCombination;
  46 import javafx.scene.input.KeyCombination;
  47 import javafx.scene.text.Font;
  48 import com.sun.glass.ui.Accessible;
  49 import com.sun.glass.ui.Screen;
  50 import com.sun.glass.ui.View;
  51 import static javafx.scene.AccessibleAttribute.*;
  52 
  53 /**
  54  * Native Interface - Implements NSAccessibility Protocol
  55  *
  56  */
  57 final class MacAccessible extends Accessible {
  58 
  59     private native static void _initIDs();
  60     private native static boolean _initEnum(String enumName);
  61     static {
  62         _initIDs();
  63         if (!_initEnum(&quot;MacAttribute&quot;)) {
  64             System.err.println(&quot;Fail linking MacAttribute&quot;);
  65         }
  66         if (!_initEnum(&quot;MacAction&quot;)) {
  67             System.err.println(&quot;Fail linking MacAction&quot;);
  68         }
  69         if (!_initEnum(&quot;MacRole&quot;)) {
  70             System.err.println(&quot;Fail linking MacRole&quot;);
  71         }
  72         if (!_initEnum(&quot;MacSubrole&quot;)) {
  73             System.err.println(&quot;Fail linking MacSubrole&quot;);
  74         }
  75         if (!_initEnum(&quot;MacNotification&quot;)) {
  76             System.err.println(&quot;Fail linking MacNotification&quot;);
  77         }
  78         if (!_initEnum(&quot;MacOrientation&quot;)) {
  79             System.err.println(&quot;Fail linking MacOrientation&quot;);
  80         }
  81         if (!_initEnum(&quot;MacText&quot;)) {
  82             System.err.println(&quot;Fail linking MacText&quot;);
  83         }
  84     }
  85 
  86     private static enum MacAttribute {
  87         // Dynamic mapping to FX attribute, dynamic return type
  88         NSAccessibilityValueAttribute(null, null),
  89 
  90         // 1-to-1 mapping between FX attribute and Mac attribute, static return type
  91         NSAccessibilityChildrenAttribute(CHILDREN, MacVariant::createNSArray),
  92         NSAccessibilityEnabledAttribute(DISABLED, MacVariant::createNSNumberForBoolean),
  93         NSAccessibilityHelpAttribute(HELP, MacVariant::createNSString),
  94 
  95         // FOCUSED might not match the result of accessibilityFocusedUIElement() cause of FOCUS_ITEM
  96         NSAccessibilityFocusedAttribute(FOCUSED, MacVariant::createNSNumberForBoolean),
  97         NSAccessibilityExpandedAttribute(EXPANDED, MacVariant::createNSNumberForBoolean),
  98         NSAccessibilityMaxValueAttribute(MAX_VALUE, MacVariant::createNSNumberForDouble),
  99         NSAccessibilityMinValueAttribute(MIN_VALUE, MacVariant::createNSNumberForDouble),
 100         NSAccessibilityParentAttribute(PARENT, MacVariant::createNSObject),
 101         NSAccessibilityPositionAttribute(BOUNDS, MacVariant::createNSValueForPoint),
 102         NSAccessibilityRoleAttribute(ROLE, MacVariant::createNSObject),
 103         NSAccessibilitySubroleAttribute(ROLE, MacVariant::createNSObject),
 104         NSAccessibilityRoleDescriptionAttribute(ROLE_DESCRIPTION, MacVariant::createNSString),
 105         NSAccessibilitySizeAttribute(BOUNDS, MacVariant::createNSValueForSize),
 106         NSAccessibilityTabsAttribute(ITEM_COUNT, MacVariant::createNSArray),
 107         NSAccessibilityTitleAttribute(TEXT, MacVariant::createNSString),
 108         NSAccessibilityTopLevelUIElementAttribute(SCENE, MacVariant::createNSObject),
 109         NSAccessibilityWindowAttribute(SCENE, MacVariant::createNSObject),
 110         NSAccessibilityTitleUIElementAttribute(LABELED_BY, MacVariant::createNSObject),
 111         NSAccessibilityOrientationAttribute(ORIENTATION, MacVariant::createNSObject),
 112         NSAccessibilityOverflowButtonAttribute(OVERFLOW_BUTTON, MacVariant::createNSObject),
 113 
 114         // Custom attributes
 115         AXVisited(VISITED, MacVariant::createNSNumberForBoolean),
 116         AXMenuItemCmdChar(ACCELERATOR, MacVariant::createNSString),
 117         AXMenuItemCmdVirtualKey(ACCELERATOR, MacVariant::createNSNumberForInt),
 118         AXMenuItemCmdGlyph(ACCELERATOR, MacVariant::createNSNumberForInt),
 119         AXMenuItemCmdModifiers(ACCELERATOR, MacVariant::createNSNumberForInt),
 120         AXMenuItemMarkChar(SELECTED, MacVariant::createNSString),
 121         AXDateTimeComponents(null, MacVariant::createNSNumberForInt),
 122 
 123         // NSAccessibilityMenuRole
 124         NSAccessibilitySelectedChildrenAttribute(null, MacVariant::createNSArray),
 125 
 126         // NSAccessibilityStaticText
 127         NSAccessibilityNumberOfCharactersAttribute(TEXT, MacVariant::createNSNumberForInt),
 128         NSAccessibilitySelectedTextAttribute(SELECTION_START, MacVariant::createNSString),
 129         NSAccessibilitySelectedTextRangeAttribute(SELECTION_START, MacVariant::createNSValueForRange),
 130         NSAccessibilitySelectedTextRangesAttribute(null, null), //TODO Array of ranges
 131         NSAccessibilityInsertionPointLineNumberAttribute(CARET_OFFSET, MacVariant::createNSNumberForInt),
 132         NSAccessibilityVisibleCharacterRangeAttribute(TEXT, MacVariant::createNSValueForRange),
 133 
 134         // NSAccessibilityScrollAreaRole
 135         NSAccessibilityContentsAttribute(CONTENTS, MacVariant::createNSArray),
 136         NSAccessibilityHorizontalScrollBarAttribute(HORIZONTAL_SCROLLBAR, MacVariant::createNSObject),
 137         NSAccessibilityVerticalScrollBarAttribute(VERTICAL_SCROLLBAR, MacVariant::createNSObject),
 138 
 139         // NSAccessibilityRowRole
 140         NSAccessibilityIndexAttribute(INDEX, MacVariant::createNSNumberForInt),
 141         NSAccessibilitySelectedAttribute(SELECTED, MacVariant::createNSNumberForBoolean),
 142         NSAccessibilityVisibleChildrenAttribute(CHILDREN, MacVariant::createNSArray),
 143 
 144         // NSAccessibilityOutlineRowRole
 145         NSAccessibilityDisclosedByRowAttribute(TREE_ITEM_PARENT, MacVariant::createNSObject),
 146         NSAccessibilityDisclosedRowsAttribute(null, null), // virtual only
 147         NSAccessibilityDisclosingAttribute(EXPANDED, MacVariant::createNSNumberForBoolean),
 148         NSAccessibilityDisclosureLevelAttribute(DISCLOSURE_LEVEL, MacVariant::createNSNumberForInt),
 149 
 150         // NSAccessibilityTableRole
 151         NSAccessibilityColumnsAttribute(null, null), //virtual only
 152         NSAccessibilityRowsAttribute(null, null), //virtual only
 153         NSAccessibilityHeaderAttribute(HEADER, MacVariant::createNSObject),
 154         NSAccessibilitySelectedRowsAttribute(SELECTED_ITEMS, MacVariant::createNSArray),
 155         NSAccessibilityRowCountAttribute(ROW_COUNT, MacVariant::createNSNumberForInt),
 156         NSAccessibilityColumnCountAttribute(COLUMN_COUNT, MacVariant::createNSNumberForInt),
 157         NSAccessibilitySelectedCellsAttribute(SELECTED_ITEMS, MacVariant::createNSArray),
 158         NSAccessibilityRowIndexRangeAttribute(ROW_INDEX, MacVariant::createNSValueForRange),
 159         NSAccessibilityColumnIndexRangeAttribute(COLUMN_INDEX, MacVariant::createNSValueForRange),
 160 
 161         // Parameterized Attributes
 162         NSAccessibilityLineForIndexParameterizedAttribute(LINE_FOR_OFFSET, MacVariant::createNSNumberForInt, MacVariant.NSNumber_Int),
 163         NSAccessibilityStringForRangeParameterizedAttribute(TEXT, MacVariant::createNSString, MacVariant.NSValue_range),
 164         NSAccessibilityRangeForLineParameterizedAttribute(LINE_START, MacVariant::createNSValueForRange, MacVariant.NSNumber_Int),
 165         NSAccessibilityAttributedStringForRangeParameterizedAttribute(TEXT, MacVariant::createNSAttributedString, MacVariant.NSValue_range),
 166         NSAccessibilityCellForColumnAndRowParameterizedAttribute(CELL_AT_ROW_COLUMN, MacVariant::createNSObject, MacVariant.NSArray_int),
 167         NSAccessibilityRangeForPositionParameterizedAttribute(OFFSET_AT_POINT, MacVariant::createNSValueForRange, MacVariant.NSValue_point),
 168         NSAccessibilityBoundsForRangeParameterizedAttribute(BOUNDS_FOR_RANGE, MacVariant::createNSValueForRectangle, MacVariant.NSValue_range),
 169 
 170         ;long ptr; /* Initialized natively - treat as final */
 171         AccessibleAttribute jfxAttr;
 172         Function&lt;Object, MacVariant&gt; map; /* Maps the object returned by JavaFX to the appropriate MacVariant */
 173         int inputType; /* Defined only for parameterized attributes to convert the native input parameter (id) to MacVariant */
 174 
 175         MacAttribute(AccessibleAttribute jfxAttr, Function&lt;Object, MacVariant&gt; map, int inputType) {
 176             this.jfxAttr = jfxAttr;
 177             this.map = map;
 178             this.inputType = inputType;
 179         }
 180 
 181         MacAttribute(AccessibleAttribute jfxAttr, Function&lt;Object, MacVariant&gt; map) {
 182             this.jfxAttr = jfxAttr;
 183             this.map = map;
 184         }
 185 
 186         static MacAttribute getAttribute(long ptr) {
 187             if (ptr == 0) return null;
 188             for (MacAttribute attr : values()) {
 189                 if (ptr == attr.ptr || isEqualToString(attr.ptr, ptr)) {
 190                     return attr;
 191                 }
 192             }
 193             return null;
 194         }
 195     }
 196 
 197     /*
 198      * The Attribute and Action for roles are defined in
 199      * https://developer.apple.com/library/mac/documentation/UserExperience/Reference/Accessibility_RoleAttribute_Ref/Introduction.html
 200      */
 201     private static enum MacRole {
 202         NSAccessibilityUnknownRole(AccessibleRole.NODE, null, null),
 203         NSAccessibilityGroupRole(AccessibleRole.PARENT, null, null),
 204         NSAccessibilityButtonRole(new AccessibleRole[] {AccessibleRole.BUTTON, AccessibleRole.INCREMENT_BUTTON, AccessibleRole.DECREMENT_BUTTON, AccessibleRole.SPLIT_MENU_BUTTON},
 205             new MacAttribute[] {
 206                 MacAttribute.NSAccessibilityEnabledAttribute,
 207                 MacAttribute.NSAccessibilityTitleAttribute,
 208             },
 209             new MacAction[] {MacAction.NSAccessibilityPressAction},
 210             null
 211         ),
 212         NSAccessibilityIncrementorRole(AccessibleRole.SPINNER,
 213             new MacAttribute[] {
 214                 MacAttribute.NSAccessibilityEnabledAttribute,
 215                 MacAttribute.NSAccessibilityTitleAttribute,
 216             },
 217             new MacAction[] {
 218                 MacAction.NSAccessibilityIncrementAction,
 219                 MacAction.NSAccessibilityDecrementAction,
 220             }
 221         ),
 222         /* AXJFXTOOLTIP is a custom name used to ignore the tooltip window. See GlassWindow.m for details. */
 223         AXJFXTOOLTIP(AccessibleRole.TOOLTIP, null, null),
 224         NSAccessibilityImageRole(AccessibleRole.IMAGE_VIEW, null, null),
 225         NSAccessibilityRadioButtonRole(new AccessibleRole[] {AccessibleRole.RADIO_BUTTON, AccessibleRole.TAB_ITEM, AccessibleRole.PAGE_ITEM},
 226             new MacAttribute[] {
 227                 MacAttribute.NSAccessibilityEnabledAttribute,
 228                 MacAttribute.NSAccessibilityTitleAttribute,
 229                 MacAttribute.NSAccessibilityValueAttribute,
 230             },
 231             new MacAction[] {MacAction.NSAccessibilityPressAction},
 232             null
 233         ),
 234         NSAccessibilityCheckBoxRole(new AccessibleRole[] {AccessibleRole.CHECK_BOX, AccessibleRole.TOGGLE_BUTTON},
 235             new MacAttribute[] {
 236                 MacAttribute.NSAccessibilityEnabledAttribute,
 237                 MacAttribute.NSAccessibilityTitleAttribute,
 238                 MacAttribute.NSAccessibilityValueAttribute,
 239             },
 240             new MacAction[] {MacAction.NSAccessibilityPressAction},
 241             null
 242         ),
 243         /* ComboBox can be either a NSAccessibilityComboBoxRole or a NSAccessibilityPopUpButtonRole (Based on EDITABLE) */
 244         NSAccessibilityComboBoxRole(AccessibleRole.COMBO_BOX,
 245             new MacAttribute[] {
 246                 MacAttribute.NSAccessibilityExpandedAttribute
 247             },
 248             new MacAction[] {MacAction.NSAccessibilityPressAction}
 249         ),
 250         NSAccessibilityPopUpButtonRole(AccessibleRole.COMBO_BOX,
 251             new MacAttribute[] {
 252                 MacAttribute.NSAccessibilityEnabledAttribute,
 253                 MacAttribute.NSAccessibilityValueAttribute,
 254             },
 255             new MacAction[] {MacAction.NSAccessibilityPressAction}
 256         ),
 257         NSAccessibilityTabGroupRole(new AccessibleRole[] {AccessibleRole.TAB_PANE, AccessibleRole.PAGINATION},
 258             new MacAttribute[] {
 259 //              MacAttributes.NSAccessibilityContentsAttribute,
 260                 MacAttribute.NSAccessibilityTabsAttribute,
 261                 MacAttribute.NSAccessibilityValueAttribute,
 262             },
 263             null,
 264             null
 265         ),
 266         NSAccessibilityProgressIndicatorRole(AccessibleRole.PROGRESS_INDICATOR,
 267             new MacAttribute[] {
 268                 MacAttribute.NSAccessibilityOrientationAttribute,
 269                 MacAttribute.NSAccessibilityValueAttribute,
 270                 MacAttribute.NSAccessibilityMaxValueAttribute,
 271                 MacAttribute.NSAccessibilityMinValueAttribute,
 272             },
 273             null
 274         ),
 275         NSAccessibilityMenuBarRole(AccessibleRole.MENU_BAR,
 276             new MacAttribute[] {
 277                 MacAttribute.NSAccessibilitySelectedChildrenAttribute,
 278                 MacAttribute.NSAccessibilityEnabledAttribute,
 279             },
 280             new MacAction[] {
 281                 MacAction.NSAccessibilityCancelAction,
 282             }
 283         ),
 284         NSAccessibilityMenuRole(AccessibleRole.CONTEXT_MENU,
 285             new MacAttribute[] {
 286                 MacAttribute.NSAccessibilitySelectedChildrenAttribute,
 287                 MacAttribute.NSAccessibilityEnabledAttribute,
 288             },
 289             new MacAction[] {
 290                 MacAction.NSAccessibilityPressAction,
 291                 MacAction.NSAccessibilityCancelAction,
 292             }
 293         ),
 294         NSAccessibilityMenuItemRole(new AccessibleRole[] {AccessibleRole.MENU_ITEM, AccessibleRole.RADIO_MENU_ITEM, AccessibleRole.CHECK_MENU_ITEM, AccessibleRole.MENU},
 295             new MacAttribute[] {
 296                 MacAttribute.NSAccessibilityEnabledAttribute,
 297                 MacAttribute.NSAccessibilityTitleAttribute,
 298                 MacAttribute.NSAccessibilitySelectedAttribute,
 299                 MacAttribute.AXMenuItemCmdChar,
 300                 MacAttribute.AXMenuItemCmdVirtualKey,
 301                 MacAttribute.AXMenuItemCmdGlyph,
 302                 MacAttribute.AXMenuItemCmdModifiers,
 303                 MacAttribute.AXMenuItemMarkChar,
 304             },
 305             new MacAction[] {
 306                 MacAction.NSAccessibilityPressAction,
 307                 MacAction.NSAccessibilityCancelAction,
 308             },
 309             null
 310         ),
 311         NSAccessibilityMenuButtonRole(AccessibleRole.MENU_BUTTON,
 312             new MacAttribute[] {
 313                 MacAttribute.NSAccessibilityEnabledAttribute,
 314                 MacAttribute.NSAccessibilityTitleAttribute,
 315             },
 316             new MacAction[] {
 317                 MacAction.NSAccessibilityPressAction,
 318             }
 319         ),
 320         NSAccessibilityStaticTextRole(new AccessibleRole[] {AccessibleRole.TEXT},
 321             null, null, null
 322         ),
 323         NSAccessibilityTextFieldRole(new AccessibleRole[] {AccessibleRole.TEXT_FIELD, AccessibleRole.PASSWORD_FIELD},
 324             null, null, null
 325         ),
 326         NSAccessibilityTextAreaRole(AccessibleRole.TEXT_AREA, null, null),
 327         NSAccessibilitySliderRole(AccessibleRole.SLIDER,
 328             new MacAttribute[] {
 329                 MacAttribute.NSAccessibilityEnabledAttribute,
 330                 MacAttribute.NSAccessibilityOrientationAttribute,
 331                 MacAttribute.NSAccessibilityValueAttribute,
 332                 MacAttribute.NSAccessibilityMaxValueAttribute,
 333                 MacAttribute.NSAccessibilityMinValueAttribute,
 334             },
 335             new MacAction[] {
 336                 MacAction.NSAccessibilityDecrementAction,
 337                 MacAction.NSAccessibilityIncrementAction,
 338             }
 339         ),
 340         NSAccessibilityScrollAreaRole(AccessibleRole.SCROLL_PANE,
 341             new MacAttribute[] {
 342                 MacAttribute.NSAccessibilityContentsAttribute,
 343                 MacAttribute.NSAccessibilityHorizontalScrollBarAttribute,
 344                 MacAttribute.NSAccessibilityVerticalScrollBarAttribute,
 345             },
 346             null
 347         ),
 348         NSAccessibilityScrollBarRole(AccessibleRole.SCROLL_BAR,
 349             new MacAttribute[] {
 350                 MacAttribute.NSAccessibilityValueAttribute,
 351                 MacAttribute.NSAccessibilityMinValueAttribute,
 352                 MacAttribute.NSAccessibilityMaxValueAttribute,
 353                 MacAttribute.NSAccessibilityEnabledAttribute,
 354                 MacAttribute.NSAccessibilityOrientationAttribute,
 355             },
 356             null
 357         ),
 358         NSAccessibilityValueIndicatorRole(AccessibleRole.THUMB,
 359             new MacAttribute[] {
 360                 MacAttribute.NSAccessibilityValueAttribute,
 361             },
 362             null
 363         ),
 364         NSAccessibilityRowRole(new AccessibleRole[] {AccessibleRole.LIST_ITEM, AccessibleRole.TABLE_ROW, AccessibleRole.TREE_ITEM, AccessibleRole.TREE_TABLE_ROW},
 365             new MacAttribute[] {
 366                 MacAttribute.NSAccessibilitySubroleAttribute,
 367                 MacAttribute.NSAccessibilityIndexAttribute,
 368                 MacAttribute.NSAccessibilitySelectedAttribute,
 369                 MacAttribute.NSAccessibilityVisibleChildrenAttribute,
 370             },
 371             null, null
 372         ),
 373         NSAccessibilityTableRole(new AccessibleRole[] {AccessibleRole.LIST_VIEW, AccessibleRole.TABLE_VIEW},
 374             new MacAttribute[] {
 375                 MacAttribute.NSAccessibilityEnabledAttribute,
 376                 MacAttribute.NSAccessibilityColumnsAttribute,
 377                 MacAttribute.NSAccessibilityHeaderAttribute,
 378                 MacAttribute.NSAccessibilityRowsAttribute,
 379                 MacAttribute.NSAccessibilitySelectedRowsAttribute,
 380                 MacAttribute.NSAccessibilityRowCountAttribute,
 381                 MacAttribute.NSAccessibilityColumnCountAttribute,
 382                 MacAttribute.NSAccessibilitySelectedCellsAttribute,
 383             },
 384             null,
 385             new MacAttribute[] {
 386                 MacAttribute.NSAccessibilityCellForColumnAndRowParameterizedAttribute,
 387             }
 388         ),
 389         NSAccessibilityColumnRole(AccessibleRole.TABLE_COLUMN,
 390             new MacAttribute[] {
 391                 MacAttribute.NSAccessibilityHeaderAttribute,
 392                 MacAttribute.NSAccessibilityIndexAttribute,
 393                 MacAttribute.NSAccessibilityRowsAttribute,
 394                 MacAttribute.NSAccessibilitySelectedAttribute,
 395             },
 396             null
 397         ),
 398         NSAccessibilityCellRole(new AccessibleRole[] {AccessibleRole.TABLE_CELL, AccessibleRole.TREE_TABLE_CELL},
 399             new MacAttribute[] {
 400                 MacAttribute.NSAccessibilityColumnIndexRangeAttribute,
 401                 MacAttribute.NSAccessibilityEnabledAttribute,
 402                 MacAttribute.NSAccessibilityRowIndexRangeAttribute,
 403                 MacAttribute.NSAccessibilitySelectedAttribute,
 404             },
 405             null,
 406             null
 407         ),
 408         NSAccessibilityLinkRole(AccessibleRole.HYPERLINK,
 409             new MacAttribute[] {
 410                 MacAttribute.NSAccessibilityEnabledAttribute,
 411                 MacAttribute.AXVisited
 412             },
 413             null
 414         ),
 415         NSAccessibilityOutlineRole(new AccessibleRole[] {AccessibleRole.TREE_VIEW, AccessibleRole.TREE_TABLE_VIEW},
 416             new MacAttribute[] {
 417                 MacAttribute.NSAccessibilityColumnsAttribute,
 418                 MacAttribute.NSAccessibilityEnabledAttribute,
 419                 MacAttribute.NSAccessibilityHeaderAttribute,
 420                 MacAttribute.NSAccessibilityRowsAttribute,
 421                 MacAttribute.NSAccessibilitySelectedRowsAttribute,
 422                 MacAttribute.NSAccessibilitySelectedCellsAttribute,
 423             },
 424             null,
 425             new MacAttribute[] {
 426                 MacAttribute.NSAccessibilityCellForColumnAndRowParameterizedAttribute,
 427             }
 428         ),
 429         NSAccessibilityDisclosureTriangleRole(AccessibleRole.TITLED_PANE,
 430             new MacAttribute[] {
 431                 MacAttribute.NSAccessibilityEnabledAttribute,
 432                 MacAttribute.NSAccessibilityValueAttribute
 433             },
 434             new MacAction[] {
 435                 MacAction.NSAccessibilityPressAction
 436             }
 437         ),
 438         NSAccessibilityToolbarRole(AccessibleRole.TOOL_BAR,
 439             new MacAttribute[] {
 440                 MacAttribute.NSAccessibilityEnabledAttribute,
 441                 MacAttribute.NSAccessibilityOverflowButtonAttribute,
 442             },
 443             null
 444         ),
 445         AXDateTimeArea(AccessibleRole.DATE_PICKER,
 446             new MacAttribute[] {
 447                 MacAttribute.NSAccessibilityEnabledAttribute,
 448                 MacAttribute.NSAccessibilityValueAttribute,
 449                 MacAttribute.AXDateTimeComponents,
 450             },
 451             null
 452         ),
 453 
 454         ;long ptr; /* Initialized natively - treat as final */
 455         AccessibleRole[] jfxRoles;
 456         List&lt;MacAttribute&gt; macAttributes;
 457         List&lt;MacAttribute&gt; macParameterizedAttributes;
 458         List&lt;MacAction&gt; macActions;
 459         MacRole(AccessibleRole jfxRole, MacAttribute[] macAttributes, MacAction[] macActions) {
 460             this(new AccessibleRole[] {jfxRole}, macAttributes, macActions, null);
 461         }
 462 
 463         MacRole(AccessibleRole[] jfxRoles, MacAttribute[] macAttributes, MacAction[] macActions, MacAttribute[] macParameterizedAttributes) {
 464             this.jfxRoles = jfxRoles;
 465             this.macAttributes = macAttributes != null ? Arrays.asList(macAttributes) : null;
 466             this.macActions = macActions != null ? Arrays.asList(macActions) : null;
 467             this.macParameterizedAttributes = macParameterizedAttributes != null ? Arrays.asList(macParameterizedAttributes) : null;
 468         }
 469 
 470         static MacRole getRole(AccessibleRole targetRole) {
 471             if (targetRole == null) return null;
 472             for (MacRole macRole : values()) {
 473                 for (AccessibleRole jfxRole : macRole.jfxRoles) {
 474                     if (jfxRole == targetRole) {
 475                         return macRole;
 476                     }
 477                 }
 478             }
 479             return null;
 480         }
 481     }
 482 
 483     private static enum MacSubrole {
 484         NSAccessibilityTableRowSubrole(AccessibleRole.LIST_ITEM, AccessibleRole.TABLE_ROW),
 485         NSAccessibilitySecureTextFieldSubrole(AccessibleRole.PASSWORD_FIELD),
 486         NSAccessibilityOutlineRowSubrole(new AccessibleRole[] { AccessibleRole.TREE_ITEM, AccessibleRole.TREE_TABLE_ROW },
 487             new MacAttribute[] {
 488                 MacAttribute.NSAccessibilityDisclosedByRowAttribute,
 489                 MacAttribute.NSAccessibilityDisclosedRowsAttribute,
 490                 MacAttribute.NSAccessibilityDisclosingAttribute,
 491                 MacAttribute.NSAccessibilityDisclosureLevelAttribute
 492             }
 493         ),
 494         NSAccessibilityDecrementArrowSubrole(new AccessibleRole[] { AccessibleRole.DECREMENT_BUTTON },
 495             new MacAttribute[] {
 496                 MacAttribute.NSAccessibilitySubroleAttribute
 497             }
 498         ),
 499         NSAccessibilityIncrementArrowSubrole(new AccessibleRole[] { AccessibleRole.INCREMENT_BUTTON },
 500             new MacAttribute[] {
 501                 MacAttribute.NSAccessibilitySubroleAttribute
 502             }
 503         )
 504 
 505         ;long ptr; /* Initialized natively - treat as final */
 506         AccessibleRole[] jfxRoles;
 507         List&lt;MacAttribute&gt; macAttributes;
 508 
 509         MacSubrole(AccessibleRole... jfxRoles) {
 510             this(jfxRoles, null);
 511         }
 512 
 513         MacSubrole(AccessibleRole[] jfxRoles, MacAttribute[] macAttributes) {
 514             this.jfxRoles = jfxRoles;
 515             this.macAttributes = macAttributes != null ? Arrays.asList(macAttributes) : null;
 516         }
 517 
 518         static MacSubrole getRole(AccessibleRole targetRole) {
 519             if (targetRole == null) return null;
 520             for (MacSubrole macRole : values()) {
 521                 for (AccessibleRole jfxRole : macRole.jfxRoles) {
 522                     if (jfxRole == targetRole) {
 523                         return macRole;
 524                     }
 525                 }
 526             }
 527             return null;
 528         }
 529     }
 530 
 531     private static enum MacAction {
 532         NSAccessibilityCancelAction,
 533         NSAccessibilityConfirmAction,
 534         NSAccessibilityDecrementAction(AccessibleAction.DECREMENT),
 535         NSAccessibilityDeleteAction,
 536         NSAccessibilityIncrementAction(AccessibleAction.INCREMENT),
 537         NSAccessibilityPickAction,
 538         NSAccessibilityPressAction(AccessibleAction.FIRE),
 539         NSAccessibilityRaiseAction,
 540         NSAccessibilityShowMenuAction(AccessibleAction.SHOW_MENU),
 541 
 542         ;long ptr; /* Initialized natively - treat as final */
 543         AccessibleAction jfxAction;
 544         MacAction() {}
 545         MacAction(AccessibleAction jfxAction) {
 546             this.jfxAction = jfxAction;
 547         }
 548 
 549         static MacAction getAction(long ptr) {
 550             for (MacAction macAction : MacAction.values()) {
 551                 if (macAction.ptr == ptr || isEqualToString(macAction.ptr, ptr)) {
 552                     return macAction;
 553                 }
 554             }
 555             return null;
 556         }
 557     }
 558 
 559     private static enum MacNotification {
 560         NSAccessibilityCreatedNotification,
 561         NSAccessibilityFocusedUIElementChangedNotification,
 562         NSAccessibilityValueChangedNotification,
 563         NSAccessibilitySelectedChildrenChangedNotification,
 564         NSAccessibilitySelectedRowsChangedNotification,
 565         NSAccessibilityTitleChangedNotification,
 566         NSAccessibilityRowCountChangedNotification,
 567         NSAccessibilitySelectedCellsChangedNotification,
 568         NSAccessibilityUIElementDestroyedNotification,
 569         NSAccessibilitySelectedTextChangedNotification,
 570         NSAccessibilityRowExpandedNotification,
 571         NSAccessibilityRowCollapsedNotification,
 572         AXMenuOpened,
 573         AXMenuClosed,
 574         ;long ptr; /* Initialized natively - treat as final */
 575     }
 576 
 577     private static enum MacOrientation {
 578         NSAccessibilityHorizontalOrientationValue,
 579         NSAccessibilityVerticalOrientationValue,
 580         NSAccessibilityUnknownOrientationValue,
 581         ;long ptr; /* Initialized natively - treat as final */
 582     }
 583 
 584     private static enum MacText {
 585         NSAccessibilityBackgroundColorTextAttribute,
 586         NSAccessibilityForegroundColorTextAttribute,
 587         NSAccessibilityUnderlineTextAttribute,
 588         NSAccessibilityStrikethroughTextAttribute,
 589         NSAccessibilityMarkedMisspelledTextAttribute,
 590         NSAccessibilityFontTextAttribute,
 591         NSAccessibilityFontNameKey,
 592         NSAccessibilityFontFamilyKey,
 593         NSAccessibilityVisibleNameKey,
 594         NSAccessibilityFontSizeKey,
 595         ;long ptr; /* Initialized natively - treat as final */
 596     }
 597 
 598     /*
 599      * Do not access the following lists directly from the Mac enums.
 600      * It can cause the static initialization to happen in an unexpected order.
 601      */
<a name="1" id="anc1"></a><span class="line-modified"> 602     private static final List&lt;MacAttribute&gt; BASE_ATTRIBUTES = List.of(</span>
 603         MacAttribute.NSAccessibilityRoleAttribute,
 604         MacAttribute.NSAccessibilityRoleDescriptionAttribute,
 605         MacAttribute.NSAccessibilityHelpAttribute,
 606         MacAttribute.NSAccessibilityFocusedAttribute,
 607         MacAttribute.NSAccessibilityParentAttribute,
 608         MacAttribute.NSAccessibilityChildrenAttribute,
 609         MacAttribute.NSAccessibilityPositionAttribute,
 610         MacAttribute.NSAccessibilitySizeAttribute,
 611         MacAttribute.NSAccessibilityWindowAttribute,
 612         MacAttribute.NSAccessibilityTopLevelUIElementAttribute,
 613         MacAttribute.NSAccessibilityTitleUIElementAttribute
 614     );
 615 
<a name="2" id="anc2"></a><span class="line-modified"> 616     private static final List&lt;MacAttribute&gt; TEXT_ATTRIBUTES = List.of(</span>
 617         MacAttribute.NSAccessibilityEnabledAttribute,
 618         MacAttribute.NSAccessibilityValueAttribute,
 619         MacAttribute.NSAccessibilityNumberOfCharactersAttribute,
 620         MacAttribute.NSAccessibilitySelectedTextAttribute,
 621         MacAttribute.NSAccessibilitySelectedTextRangeAttribute,
 622         MacAttribute.NSAccessibilityInsertionPointLineNumberAttribute,
 623         MacAttribute.NSAccessibilityVisibleCharacterRangeAttribute
 624     );
 625 
<a name="3" id="anc3"></a><span class="line-modified"> 626     private static final List&lt;MacAttribute&gt; TEXT_PARAMETRIZED_ATTRIBUTES = List.of(</span>
 627         MacAttribute.NSAccessibilityLineForIndexParameterizedAttribute,
 628         MacAttribute.NSAccessibilityRangeForLineParameterizedAttribute,
 629         MacAttribute.NSAccessibilityAttributedStringForRangeParameterizedAttribute,
 630         MacAttribute.NSAccessibilityStringForRangeParameterizedAttribute
 631     );
 632 
 633     /* The native peer associated with the instance */
 634     private long peer;
 635 
 636     /* Creates a GlassAccessible linked to the caller (GlobalRef) */
 637     private native long _createGlassAccessible();
 638 
 639     /* Releases the GlassAccessible and deletes the GlobalRef */
 640     private native void _destroyGlassAccessible(long accessible);
 641 
 642     private static native String getString(long nsString);
 643     private static native boolean isEqualToString(long nsString1, long nsString);
 644     private static native long NSAccessibilityUnignoredAncestor(long id);
 645     private static native long[] NSAccessibilityUnignoredChildren(long[] originalChildren);
 646     private static native void NSAccessibilityPostNotification(long element, long notification);
 647     private static native String NSAccessibilityActionDescription(long action);
 648     private static native String NSAccessibilityRoleDescription(long role, long subrole);
 649     private static native MacVariant idToMacVariant(long id, int type);
 650     private static native MacAccessible GlassAccessibleToMacAccessible(long glassAccessible);
 651     private static final int kAXMenuItemModifierNone         = 0;
 652     private static final int kAXMenuItemModifierShift        = (1 &lt;&lt; 0);
 653     private static final int kAXMenuItemModifierOption       = (1 &lt;&lt; 1);
 654     private static final int kAXMenuItemModifierControl      = (1 &lt;&lt; 2);
 655     private static final int kAXMenuItemModifierNoCommand    = (1 &lt;&lt; 3);
 656 
 657     MacAccessible() {
 658         this.peer = _createGlassAccessible();
 659         if (this.peer == 0L) {
 660             throw new RuntimeException(&quot;could not create platform accessible&quot;);
 661         }
 662     }
 663 
 664     @Override
 665     public void dispose() {
 666         if (peer != 0L) {
 667             if (getView() == null) {
 668                 NSAccessibilityPostNotification(peer, MacNotification.NSAccessibilityUIElementDestroyedNotification.ptr);
 669             }
 670             _destroyGlassAccessible(peer);
 671             peer = 0L;
 672         }
 673         super.dispose();
 674     }
 675 
 676     @Override
 677     public void sendNotification(AccessibleAttribute notification) {
 678         if (isDisposed()) return;
 679 
 680         MacNotification macNotification = null;
 681         switch (notification) {
 682             case FOCUS_ITEM: {
 683                 AccessibleRole role = (AccessibleRole) getAttribute(ROLE);
 684                 if (role == AccessibleRole.TABLE_VIEW || role == AccessibleRole.TREE_TABLE_VIEW) {
 685                     /* Cell based controls */
 686                     macNotification = MacNotification.NSAccessibilitySelectedCellsChangedNotification;
 687                 } else if (role == AccessibleRole.LIST_VIEW || role == AccessibleRole.TREE_VIEW) {
 688                     /* Row based controls */
 689                     macNotification = MacNotification.NSAccessibilitySelectedRowsChangedNotification;
 690                 } else {
 691                     /* TabPane and Pagination */
 692                     Node node = (Node)getAttribute(FOCUS_ITEM);
 693                     long id = getNativeAccessible(node);
 694                     if (id != 0) {
 695                         NSAccessibilityPostNotification(id, MacNotification.NSAccessibilityFocusedUIElementChangedNotification.ptr);
 696                     }
 697                 }
 698                 break;
 699             }
 700             case FOCUS_NODE: {
 701                 Node node = (Node)getAttribute(FOCUS_NODE);
 702                 View view = getView();
 703                 if (node == null &amp;&amp; view == null) {
 704                     /*
 705                      * The transientFocusContainer resigns focus.
 706                      * Delegate to the scene.
 707                      */
 708                     Scene scene = (Scene)getAttribute(SCENE);
 709                     if (scene != null) {
 710                         Accessible acc = getAccessible(scene);
 711                         if (acc != null) {
 712                             node = (Node)acc.getAttribute(FOCUS_NODE);
 713                         }
 714                     }
 715                 }
 716 
 717                 long id = 0L;
 718                 if (node != null) {
 719                     Node item = (Node)getAccessible(node).getAttribute(FOCUS_ITEM);
 720                     id = item != null ? getNativeAccessible(item) : getNativeAccessible(node);
 721                 } else {
 722                     /*
 723                      * No focused element. Send the notification to the scene itself.
 724                      * Note, the view is NULL when the FOCUS_NODE notification is sent
 725                      * by the transientFocusContainer.
 726                      */
 727                     if (view == null) view = getRootView((Scene)getAttribute(SCENE));
 728                     if (view != null) id = view.getNativeView();
 729                 }
 730 
 731                 if (id != 0) {
 732                     NSAccessibilityPostNotification(id, MacNotification.NSAccessibilityFocusedUIElementChangedNotification.ptr);
 733                 }
 734                 return;
 735             }
 736             case FOCUSED:
 737                 return;
 738             case SELECTION_START:
 739             case SELECTION_END:
 740                 macNotification = MacNotification.NSAccessibilitySelectedTextChangedNotification;
 741                 break;
 742             case EXPANDED:
 743                 boolean expanded = Boolean.TRUE.equals(getAttribute(EXPANDED));
 744                 if (expanded) {
 745                     macNotification = MacNotification.NSAccessibilityRowExpandedNotification;
 746                 } else {
 747                     macNotification = MacNotification.NSAccessibilityRowCollapsedNotification;
 748                 }
 749 
 750                 AccessibleRole role = (AccessibleRole) getAttribute(ROLE);
 751                 if (role == AccessibleRole.TREE_ITEM || role == AccessibleRole.TREE_TABLE_ROW) {
 752                     AccessibleRole containerRole = role == AccessibleRole.TREE_ITEM ? AccessibleRole.TREE_VIEW : AccessibleRole.TREE_TABLE_VIEW;
 753                     MacAccessible container = (MacAccessible)getContainerAccessible(containerRole);
 754                     if (container != null) {
 755                         NSAccessibilityPostNotification(container.getNativeAccessible(), MacNotification.NSAccessibilityRowCountChangedNotification.ptr);
 756                     }
 757                 }
 758                 break;
 759             case VISIBLE: {
 760                 if (getAttribute(ROLE) == AccessibleRole.CONTEXT_MENU) {
 761                     Boolean visible = (Boolean)getAttribute(VISIBLE);
 762                     if (Boolean.TRUE.equals(visible)) {
 763                         macNotification = MacNotification.AXMenuOpened;
 764                     } else {
 765                         macNotification = MacNotification.AXMenuClosed;
 766 
 767                         /*
 768                          * When a submenu closes the focus is returned to the main
 769                          * window, as opposite of the previous menu.
 770                          * The work around is to look for a previous menu
 771                          * and send a close and open event for it.
 772                          */
 773                         Node menuItemOwner = (Node)getAttribute(PARENT_MENU);
 774                         MacAccessible acc  = (MacAccessible)getAccessible(menuItemOwner);
 775                         if (acc != null) {
 776                             MacAccessible menu = (MacAccessible)acc.getContainerAccessible(AccessibleRole.CONTEXT_MENU);
 777                             if (menu != null) {
 778                                 long ptr = menu.getNativeAccessible();
 779                                 NSAccessibilityPostNotification(ptr, MacNotification.AXMenuClosed.ptr);
 780                                 NSAccessibilityPostNotification(ptr, MacNotification.AXMenuOpened.ptr);
 781                             }
 782                         }
 783                     }
 784                 }
 785                 break;
 786             }
 787             case TEXT:
 788                 if (getAttribute(ROLE) == AccessibleRole.SPINNER) {
 789                     macNotification = MacNotification.NSAccessibilityTitleChangedNotification;
 790                 } else {
 791                     macNotification = MacNotification.NSAccessibilityValueChangedNotification;
 792                 }
 793                 break;
 794             case PARENT:
 795                 ignoreInnerText = null;
 796                 break;
 797             default:
 798                 macNotification = MacNotification.NSAccessibilityValueChangedNotification;
 799         }
 800         if (macNotification != null) {
 801             View view = getView();
 802             long id = view != null ? view.getNativeView() : peer;
 803             NSAccessibilityPostNotification(id, macNotification.ptr);
 804         }
 805     }
 806 
 807     @Override
 808     protected long getNativeAccessible() {
 809         return peer;
 810     }
 811 
 812     private View getRootView(Scene scene) {
 813         if (scene == null) return null;
 814         Accessible acc = getAccessible(scene);
 815         if (acc == null || acc.isDisposed()) return null;
 816         View view = acc.getView();
 817         if (view == null || view.isClosed()) return null;
 818         return view;
 819     }
 820 
 821     private long[] getUnignoredChildren(ObservableList&lt;Node&gt; children) {
 822         if (children == null) return new long[0];
 823         long[] ids = children.stream()
 824                              .filter(Node::isVisible)
 825                              .mapToLong(n -&gt; getNativeAccessible(n))
 826                              .filter(n -&gt; n != 0)
 827                              .toArray();
 828         return NSAccessibilityUnignoredChildren(ids);
 829     }
 830 
 831     private Boolean inMenu;
 832     private boolean isInMenu() {
 833         /* This flag will be wrong if the Node is ever re-parented */
 834         if (inMenu == null) {
 835             inMenu = getContainerAccessible(AccessibleRole.CONTEXT_MENU) != null || getContainerAccessible(AccessibleRole.MENU_BAR) != null;
 836         }
 837         return inMenu;
 838     }
 839 
 840     private boolean isMenuElement(AccessibleRole role) {
 841         if (role == null) return false;
 842         switch (role) {
 843             case MENU_BAR:
 844             case CONTEXT_MENU:
 845             case MENU_ITEM:
 846             case RADIO_MENU_ITEM:
 847             case CHECK_MENU_ITEM:
 848             case MENU: return true;
 849             default: return false;
 850         }
 851     }
 852 
 853     private Boolean inSlider;
 854     private boolean isInSlider() {
 855         /* This flag will be wrong if the Node is ever re-parented */
 856         if (inSlider == null) {
 857             inSlider = getContainerAccessible(AccessibleRole.SLIDER) != null;
 858         }
 859         return inSlider;
 860     }
 861 
 862     private Boolean ignoreInnerText;
 863     private boolean ignoreInnerText() {
 864         if (ignoreInnerText != null) return ignoreInnerText;
 865         /*
 866          * JavaFX controls are implemented by the skin by adding new nodes.
 867          * In accessibility these nodes sometimes duplicate the data in the
 868          * control. For example, a Label is implemented using a Text, creating a
 869          * AXStaticText inside an AXStaticText. In order to  improve accessibility
 870          * navigation to following code ignores these inner text for the most
 871          * common cases.
 872          */
 873         AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
 874         ignoreInnerText = false;
 875         if (role == AccessibleRole.TEXT) {
 876             Node parent = (Node)getAttribute(PARENT);
 877             if (parent == null) return ignoreInnerText;
 878             AccessibleRole parentRole = (AccessibleRole)getAccessible(parent).getAttribute(ROLE);
 879             if (parentRole == null) return ignoreInnerText;
 880             switch (parentRole) {
 881                 case BUTTON:
 882                 case TOGGLE_BUTTON:
 883                 case CHECK_BOX:
 884                 case RADIO_BUTTON:
 885                 case COMBO_BOX:
 886                 case TEXT:
 887                 case HYPERLINK:
 888                 case TAB_ITEM:
 889                     ignoreInnerText = true;
 890                 default:
 891             }
 892         }
 893         return ignoreInnerText;
 894     }
 895 
 896     private int getMenuItemCmdGlyph(KeyCode code) {
 897         // Based on System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Menus.h
 898         switch (code) {
 899             case ENTER:        return 0x04;
 900             case SHIFT:        return 0x05;
 901             case CONTROL:      return 0x06;
 902             case META:         return 0x07;
 903             case SPACE:        return 0x09;
 904             case COMMAND:      return 0x11;
 905             case ESCAPE:       return 0x1b;
 906             case CLEAR:        return 0x1c;
 907             case PAGE_UP:      return 0x62;
 908             case CAPS:         return 0x63;
 909             case LEFT:
 910             case KP_LEFT:      return 0x64;
 911             case RIGHT:
 912             case KP_RIGHT:     return 0x65;
 913             case HELP:         return 0x67;
 914             case UP:
 915             case KP_UP:        return 0x68;
 916             case DOWN:
 917             case KP_DOWN:      return 0x6a;
 918             case PAGE_DOWN:    return 0x6b;
 919             case CONTEXT_MENU: return 0x6d;
 920             case POWER:        return 0x6e;
 921             case F1:           return 0x6f;
 922             case F2:           return 0x70;
 923             case F3:           return 0x71;
 924             case F4:           return 0x72;
 925             case F5:           return 0x73;
 926             case F6:           return 0x74;
 927             case F7:           return 0x75;
 928             case F8:           return 0x76;
 929             case F9:           return 0x77;
 930             case F10:          return 0x78;
 931             case F11:          return 0x79;
 932             case F12:          return 0x7a;
 933             case F13:          return 0x87;
 934             case F14:          return 0x88;
 935             case F15:          return 0x89;
 936             default: return 0;
 937         }
 938     }
 939 
 940     private boolean isCmdCharBased(KeyCode code) {
 941         return code.isLetterKey() || (code.isDigitKey() &amp;&amp; !code.isKeypadKey());
 942     }
 943 
 944     private MacRole getRole(AccessibleRole role) {
 945         if (role == AccessibleRole.COMBO_BOX) {
 946             if (Boolean.TRUE.equals(getAttribute(EDITABLE))) {
 947                 return MacRole.NSAccessibilityComboBoxRole;
 948             } else {
 949                 return MacRole.NSAccessibilityPopUpButtonRole;
 950             }
 951         }
 952         return MacRole.getRole(role);
 953     }
 954 
 955     private Bounds flipBounds(Bounds bounds) {
 956         View view = getRootView((Scene)getAttribute(SCENE));
 957         if (view == null || view.getWindow() == null) return null;
 958         Screen screen = view.getWindow().getScreen();
 959         float height = screen.getHeight();
 960         return new BoundingBox(bounds.getMinX(),
 961                                height - bounds.getMinY() - bounds.getHeight(),
 962                                bounds.getWidth(),
 963                                bounds.getHeight());
 964     }
 965 
 966     /* NSAccessibility Protocol - JNI entry points */
 967     private long[] accessibilityAttributeNames() {
 968         if (getView() != null) return null; /* Let NSView answer for the Scene */
 969         AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
 970         if (role != null) {
<a name="4" id="anc4"></a><span class="line-modified"> 971             List&lt;MacAttribute&gt; attrs = new ArrayList&lt;&gt;(BASE_ATTRIBUTES);</span>
 972             MacRole macRole = getRole(role);
 973             if (macRole != null &amp;&amp; macRole.macAttributes != null) {
 974                 attrs.addAll(macRole.macAttributes);
 975             }
 976 
 977             /* Look to see if there is a subrole that we should also get the attributes of */
 978             MacSubrole macSubrole = MacSubrole.getRole(role);
 979             if (macSubrole != null &amp;&amp; macSubrole.macAttributes != null) {
 980                 attrs.addAll(macSubrole.macAttributes);
 981             }
 982 
 983             switch (role) {
 984                 case LIST_VIEW:
 985                 case TREE_VIEW:
 986                     /* Row-based control, must remove all the cell-based attributes */
 987                     attrs.remove(MacAttribute.NSAccessibilitySelectedCellsAttribute);
 988                     break;
 989                 case MENU_ITEM:
 990                 case RADIO_MENU_ITEM:
 991                 case CHECK_MENU_ITEM:
 992                 case MENU:
 993                 case CONTEXT_MENU:
 994                 case MENU_BAR:
 995                     /* Menu and MenuItem do have have Window and top-level UI Element*/
 996                     attrs.remove(MacAttribute.NSAccessibilityWindowAttribute);
 997                     attrs.remove(MacAttribute.NSAccessibilityTopLevelUIElementAttribute);
 998                     break;
 999                 case TEXT:
1000                 case TEXT_FIELD:
1001                 case TEXT_AREA:
1002                 case PASSWORD_FIELD:
1003                 case COMBO_BOX:
<a name="5" id="anc5"></a><span class="line-modified">1004                     attrs.addAll(TEXT_ATTRIBUTES);</span>
1005                     break;
1006                 default:
1007             }
1008             return attrs.stream().mapToLong(a -&gt; a.ptr).toArray();
1009         }
1010         return null;
1011     }
1012 
1013     private int accessibilityArrayAttributeCount(long attribute) {
1014         MacAttribute attr = MacAttribute.getAttribute(attribute);
1015         if (attr == null) {
1016             return -1;
1017         }
1018         switch (attr) {
1019             case NSAccessibilityRowsAttribute: {
1020                 AccessibleAttribute jfxAttr;
1021                 if (getAttribute(ROLE) == AccessibleRole.LIST_VIEW) {
1022                     jfxAttr = AccessibleAttribute.ITEM_COUNT;
1023                 } else {
1024                     jfxAttr = AccessibleAttribute.ROW_COUNT;
1025                 }
1026                 Integer count = (Integer)getAttribute(jfxAttr);
1027                 return count != null ? count : 0;
1028             }
1029             case NSAccessibilityColumnsAttribute: {
1030                 Integer count = (Integer)getAttribute(COLUMN_COUNT);
1031 
1032                 /*
1033                  * JFX does not require ListView to report column count == 1
1034                  * But Mac needs NSAccessibilityColumnCountAttribute == 1 to work
1035                  */
1036                 return count != null ? count : 1;
1037             }
1038             case NSAccessibilityChildrenAttribute: {
1039                 /*
1040                  * The way VoiceOver identifies a menu item as having a sub menu is
1041                  * by detecting an AXMenu child. It is important that the AXMenu
1042                  * child be the actual sub menu so that navigation between menus
1043                  * work.
1044                  * Note: strictly the context menu is a child of the PopWindow.
1045                  */
1046                 if (getAttribute(ROLE) == AccessibleRole.MENU) {
1047                     @SuppressWarnings(&quot;unchecked&quot;)
1048                     ObservableList&lt;Node&gt; children = (ObservableList&lt;Node&gt;)getAttribute(CHILDREN);
1049                     if (children == null) return 0;
1050                     long[] ids = getUnignoredChildren(children);
1051                     int count = ids.length;
1052                     if (getAttribute(SUBMENU) != null) {
1053                         count++;
1054                     }
1055                     return count;
1056                 }
1057                 return -1;
1058             }
1059             case NSAccessibilityDisclosedRowsAttribute: {
1060                 Integer count = (Integer)getAttribute(TREE_ITEM_COUNT);
1061                 return count != null ? count : 0;
1062             }
1063             default:
1064         }
1065         return -1;
1066     }
1067 
1068     private long[] accessibilityArrayAttributeValues(long attribute, int index, int maxCount) {
1069         MacAttribute attr = MacAttribute.getAttribute(attribute);
1070         if (attr == null) {
1071             return null;
1072         }
1073 
1074         AccessibleAttribute jfxAttr = null;
1075         switch (attr) {
1076             case NSAccessibilityColumnsAttribute: jfxAttr = COLUMN_AT_INDEX; break;
1077             case NSAccessibilityRowsAttribute: {
1078                 if (getAttribute(ROLE) == AccessibleRole.LIST_VIEW) {
1079                     jfxAttr = AccessibleAttribute.ITEM_AT_INDEX;
1080                 } else {
1081                     jfxAttr = AccessibleAttribute.ROW_AT_INDEX;
1082                 }
1083                 break;
1084             }
1085             case NSAccessibilityDisclosedRowsAttribute: jfxAttr = TREE_ITEM_AT_INDEX; break;
1086             case NSAccessibilityChildrenAttribute: {
1087                 if (getAttribute(ROLE) == AccessibleRole.MENU) {
1088                     long[] result = new long[maxCount];
1089                     int i = 0;
1090                     if (index == 0) {
1091                         Node menu = (Node)getAttribute(SUBMENU);
1092                         if (menu != null) result[i++] = getNativeAccessible(menu);
1093                     }
1094                     if (i &lt; maxCount) {
1095                         @SuppressWarnings(&quot;unchecked&quot;)
1096                         ObservableList&lt;Node&gt; children = (ObservableList&lt;Node&gt;)getAttribute(CHILDREN);
1097                         if (children == null) return null;
1098                         long[] ids = getUnignoredChildren(children);
1099                         index--;
1100                         while (i &lt; maxCount &amp;&amp; index &lt; ids.length) {
1101                             result[i++] = ids[index++];
1102                         }
1103                     }
1104                     if (i &lt; maxCount) {
1105                         result = Arrays.copyOf(result, i);
1106                     }
1107                     return result;
1108                 }
1109                 break;
1110             }
1111             default:
1112         }
1113         if (jfxAttr != null) {
1114             long[] result = new long[maxCount];
1115             int i = 0;
1116             while (i &lt; maxCount) {
1117                 Node node = (Node)getAttribute(jfxAttr, index + i);
1118                 if (node == null) break;
1119                 result[i] = getNativeAccessible(node);
1120                 i++;
1121             }
1122             if (i == maxCount) return NSAccessibilityUnignoredChildren(result);;
1123         }
1124         return null;
1125     }
1126 
1127     private boolean accessibilityIsAttributeSettable(long attribute) {
1128         MacAttribute attr = MacAttribute.getAttribute(attribute);
1129         if (attr == null) return false;
1130         switch (attr) {
1131             case NSAccessibilityDisclosingAttribute:
1132                 Integer itemCount = (Integer)getAttribute(TREE_ITEM_COUNT);
1133                 return itemCount != null &amp;&amp; itemCount &gt; 0;
1134             case NSAccessibilityFocusedAttribute:
1135             case NSAccessibilitySelectedAttribute:
1136             case NSAccessibilitySelectedRowsAttribute:
1137             case NSAccessibilitySelectedCellsAttribute:
1138                 return true;
1139             case NSAccessibilityValueAttribute:
1140             case NSAccessibilitySelectedTextRangeAttribute: {
1141                 AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1142                 if (role == AccessibleRole.TEXT_FIELD || role == AccessibleRole.TEXT_AREA) {
1143                     if (Boolean.TRUE.equals(getAttribute(EDITABLE))) {
1144                         return true;
1145                     }
1146                 }
1147                 break;
1148             }
1149             default:
1150         }
1151         return false;
1152     }
1153 
1154     private MacVariant accessibilityAttributeValue(long attribute) {
1155         MacAttribute attr = MacAttribute.getAttribute(attribute);
1156         if (attr == null) {
1157             return null;
1158         }
1159 
1160         Function&lt;Object, MacVariant&gt; map = attr.map;
1161         AccessibleAttribute jfxAttr = attr.jfxAttr;
1162         AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1163         if (role == null) return null;
1164         if (jfxAttr == null) {
1165             switch (attr) {
1166                 case NSAccessibilityValueAttribute: {
1167                     switch (role) {
1168                         case TAB_PANE:
1169                         case PAGINATION:
1170                             jfxAttr = FOCUS_ITEM;
1171                             map = MacVariant::createNSObject;
1172                             break;
1173                         case PAGE_ITEM:
1174                         case TAB_ITEM:
1175                         case RADIO_BUTTON:
1176                             jfxAttr = SELECTED;
1177                             map = MacVariant::createNSNumberForBoolean;
1178                             break;
1179                         case SCROLL_BAR:
1180                         case SLIDER:
1181                         case PROGRESS_INDICATOR:
1182                         case THUMB:
1183                             jfxAttr = VALUE;
1184                             map = MacVariant::createNSNumberForDouble;
1185                             break;
1186                         case TEXT:
1187                         case TEXT_FIELD:
1188                         case TEXT_AREA:
1189                         case COMBO_BOX:
1190                             jfxAttr = TEXT;
1191                             map = MacVariant::createNSString;
1192                             break;
1193                         case CHECK_BOX:
1194                         case TOGGLE_BUTTON:
1195                             jfxAttr = SELECTED;
1196                             map = MacVariant::createNSNumberForInt;
1197                             break;
1198                         case DATE_PICKER:
1199                             jfxAttr = DATE;
1200                             map = MacVariant::createNSDate;
1201                             break;
1202                         case TITLED_PANE:
1203                             jfxAttr = EXPANDED;
1204                             map = MacVariant::createNSNumberForInt;
1205                             break;
1206                         default:
1207                             /* VoiceOver can ask NSAccessibilityValueAttribute in unexpected cases, AXColumn for example. */
1208                             return null;
1209                     }
1210                     break;
1211                 }
1212                 case NSAccessibilitySelectedChildrenAttribute: {
1213                     Node focus = null;
1214                     if (role == AccessibleRole.CONTEXT_MENU) {
1215                         /*
1216                          * ContextMenu is in its separate Window. It is safe to
1217                          * use FOCUS_NODE to locate the selected menu item
1218                          * within it.
1219                          */
1220                         Scene scene = (Scene)getAttribute(SCENE);
1221                         Accessible acc = getAccessible(scene);
1222                         if (acc != null) {
1223                             focus = (Node)acc.getAttribute(FOCUS_NODE);
1224                         }
1225                     }
1226                     if (role == AccessibleRole.MENU_BAR) {
1227                         /*
1228                          * MenuBar has special code to intercept the FOCUS_NODE
1229                          * (see Scene#transientFocusContainer).
1230                          */
1231                         focus = (Node)getAttribute(FOCUS_NODE);
1232                     }
1233                     if (focus != null) {
1234                         AccessibleRole focusRole = (AccessibleRole)getAccessible(focus).getAttribute(ROLE);
1235                         if (isMenuElement(focusRole)) {
1236                             long[] result = {getNativeAccessible(focus)};
1237                             return attr.map.apply(result);
1238                         }
1239                     }
1240                     return null;
1241                 }
1242                 case AXDateTimeComponents: {
1243                     /* Mac Yosemite crashes if AXDateTimeComponents set
1244                      * and NULL is returned for AXValue.
1245                      */
1246                     if (getAttribute(DATE) == null) return null;
1247 
1248                     /*
1249                      * AXDateTimeComponents is an undocumented attribute which
1250                      * is used by native DateTime controls in Cocoa.
1251                      * It it used a bit vector and 224 indicates that
1252                      * month, day, and year should be read out.
1253                      */
1254                     return attr.map.apply(224);
1255                 }
1256                 default:
1257               }
1258         }
1259         if (jfxAttr == null) {
1260             return null;
1261         }
1262         Object result = getAttribute(jfxAttr);
1263         if (result == null) {
1264             switch (attr) {
1265                 case NSAccessibilityParentAttribute: break;
1266                 case NSAccessibilityColumnCountAttribute:
1267                     /*
1268                      * JFX does not require ListView to report column count == 1
1269                      * But Mac needs NSAccessibilityColumnCountAttribute == 1 to work
1270                      */
1271                     result = 1;
1272                     break;
1273                 case NSAccessibilityColumnIndexRangeAttribute:
1274                     if (role == AccessibleRole.TABLE_COLUMN) {
1275                         /*
1276                          * Mac 10.10 sends AXColumnIndexRange instead of AXIndex for
1277                          * AXColumns. This is undocumented but without it the column
1278                          * header name is not read.
1279                          */
1280                         result = getAttribute(INDEX);
1281                         if (result != null) break;
1282                     }
1283                     return null;
1284                 case AXMenuItemCmdModifiers:
1285                     return attr.map.apply(kAXMenuItemModifierNoCommand);
1286                 case NSAccessibilityRoleDescriptionAttribute: {
1287                     /*
1288                      * In some cases there is no proper mapping from a JFX role
1289                      * to a Mac role. For example, reporting &#39;disclosure triangle&#39;
1290                      * for a TITLED_PANE is not appropriate.
1291                      * Providing a custom role description makes it much better.
1292                      *
1293                      * Note: The user can redefine this attribuet by specifying
1294                      * a DESCRIPTION.
1295                      */
1296                     switch (role) {
1297                         case TITLED_PANE: result = &quot;title pane&quot;; break;
1298                         case SPLIT_MENU_BUTTON: result = &quot;split button&quot;; break;
1299                         case PAGE_ITEM: result = &quot;page&quot;; break;
1300                         case TAB_ITEM: result = &quot;tab&quot;; break;
1301                         case LIST_VIEW: result = &quot;list&quot;; break;
1302                         default:
1303                             MacRole macRole = getRole(role);
1304                             MacSubrole subRole = MacSubrole.getRole(role);
1305                             result = NSAccessibilityRoleDescription(macRole.ptr, subRole != null ? subRole.ptr : 0l);
1306                     }
1307                     break;
1308                 }
1309                 default: return null;
1310             }
1311         }
1312 
1313         /* Some Attributes need to be modified before creating the MacVariant */
1314         switch (attr) {
1315             case NSAccessibilityWindowAttribute:
1316             case NSAccessibilityTopLevelUIElementAttribute: {
1317                 if (isMenuElement(role)) {
1318                     return null;
1319                 }
1320                 Scene scene = (Scene)result;
1321                 View view = getRootView(scene);
1322                 if (view == null || view.getWindow() == null) return null;
1323                 result = view.getWindow().getNativeWindow();
1324                 break;
1325             }
1326             case NSAccessibilitySubroleAttribute: {
1327                 MacSubrole subRole = MacSubrole.getRole((AccessibleRole)result);
1328                 result = subRole != null ? subRole.ptr : 0L;
1329                 break;
1330             }
1331             case NSAccessibilityRoleAttribute: {
1332                 MacRole macRole = getRole(role);
1333                 result = macRole != null ? macRole.ptr : 0L;
1334                 break;
1335             }
1336             case NSAccessibilityEnabledAttribute: {
1337                 result = Boolean.FALSE.equals(result);
1338                 break;
1339             }
1340             case NSAccessibilityTabsAttribute: {
1341                 Integer count = (Integer)result;
1342                 long[] tabs = new long[count];
1343                 for (int i = 0; i &lt; count; i++) {
1344                     Node child = (Node)getAttribute(ITEM_AT_INDEX, i);
1345                     tabs[i] = getNativeAccessible(child);
1346                 }
1347                 result = NSAccessibilityUnignoredChildren(tabs);
1348                 break;
1349             }
1350             case NSAccessibilitySelectedCellsAttribute:
1351             case NSAccessibilitySelectedRowsAttribute:
1352             case NSAccessibilityVisibleChildrenAttribute:
1353             case NSAccessibilityChildrenAttribute: {
1354                 @SuppressWarnings(&quot;unchecked&quot;)
1355                 ObservableList&lt;Node&gt; children = (ObservableList&lt;Node&gt;)result;
1356                 result = getUnignoredChildren(children);
1357                 break;
1358             }
1359             case NSAccessibilityParentAttribute: {
1360                 if (getView() != null) {
1361                     if (getView().getWindow() == null) return null;
1362                     result = getView().getWindow().getNativeWindow();
1363                 } else if (result != null) {
1364                     if (role == AccessibleRole.CONTEXT_MENU) {
1365                         Node menuItem = (Node)getAttribute(PARENT_MENU);
1366                         if (menuItem != null) {
1367                             if (getAccessible(menuItem).getAttribute(ROLE) == AccessibleRole.MENU) {
1368                                 result = menuItem;
1369                             }
1370                         }
1371                     }
1372                     result = getNativeAccessible((Node)result);
1373                 } else {
1374                     /* Root node: return the NSView (instead of acc.getNativeAccessible()) */
1375                     View view = getRootView((Scene)getAttribute(SCENE));
1376                     if (view == null) return null;
1377                     result = view.getNativeView();
1378                 }
1379                 result = NSAccessibilityUnignoredAncestor((long)result);
1380                 break;
1381             }
1382             case NSAccessibilityValueAttribute: {
1383                 switch (role) {
1384                     case TAB_PANE:
1385                     case PAGINATION:
1386                         result = getNativeAccessible((Node)result);
1387                         break;
1388                     case CHECK_BOX:
1389                     case TOGGLE_BUTTON:
1390                         if (Boolean.TRUE.equals(getAttribute(INDETERMINATE))) {
1391                             result = 2;
1392                         } else {
1393                             result = Boolean.TRUE.equals(result) ? 1 : 0;
1394                         }
1395                         break;
1396                     case TITLED_PANE:
1397                         result = Boolean.TRUE.equals(result) ? 1 : 0;
1398                         break;
1399                     default:
1400                 }
1401                 break;
1402             }
1403             case NSAccessibilityPositionAttribute: {
1404                 /*
1405                  * NSAccessibilityPositionAttribute requires the point relative
1406                  * to the lower-left corner in screen.
1407                  */
1408                 result = flipBounds((Bounds)result);
1409                 break;
1410             }
1411             case NSAccessibilityMaxValueAttribute: {
1412                 /*
1413                  * VoiceOver reports &#39;Indeterminate Progress Indicator&#39; when
1414                  * the max value is not specified.
1415                  */
1416                 if (Boolean.TRUE.equals(getAttribute(INDETERMINATE))) {
1417                     return null;
1418                 }
1419                 break;
1420             }
1421             case NSAccessibilityTitleAttribute: {
1422                 /*
1423                  * Voice over sends title attributes in unexpected cases.
1424                  * For text roles, where the title is reported in AXValue, reporting
1425                  * the value again in AXTitle will cause voice over to read the text twice.
1426                  */
1427                 switch (role) {
1428                     case COMBO_BOX:
1429                     case TEXT:
1430                     case TEXT_FIELD:
1431                     case TEXT_AREA:
1432                         return null;
1433                     default:
1434                 }
1435                 break;
1436             }
1437             case AXMenuItemCmdChar: {
1438                 KeyCombination kc = (KeyCombination)result;
1439                 result = null;
1440                 if (kc instanceof KeyCharacterCombination) {
1441                     result = ((KeyCharacterCombination)kc).getCharacter();
1442                 }
1443                 if (kc instanceof KeyCodeCombination) {
1444                     KeyCode code = ((KeyCodeCombination)kc).getCode();
1445                     if (isCmdCharBased(code)) {
1446                         result = code.getName();
1447                     }
1448                 }
1449                 if (result == null) return null;
1450                 break;
1451             }
1452             case AXMenuItemCmdVirtualKey: {
1453                 KeyCombination kc = (KeyCombination)result;
1454                 result = null;
1455                 if (kc instanceof KeyCodeCombination) {
1456                     KeyCode code = ((KeyCodeCombination)kc).getCode();
1457                     if (!isCmdCharBased(code)) {
1458                         @SuppressWarnings(&quot;deprecation&quot;)
1459                         int keyCode = code.getCode();
1460                         result = MacApplication._getMacKey(keyCode);
1461                     }
1462                 }
1463                 if (result == null) return null;
1464                 break;
1465             }
1466             case AXMenuItemCmdGlyph: {
1467                 KeyCombination kc = (KeyCombination)result;
1468                 result = null;
1469                 if (kc instanceof KeyCodeCombination) {
1470                     KeyCode code = ((KeyCodeCombination)kc).getCode();
1471                     if (!isCmdCharBased(code)) {
1472                         result = getMenuItemCmdGlyph(code);
1473                     }
1474                 }
1475                 if (result == null) return null;
1476                 break;
1477             }
1478             case AXMenuItemCmdModifiers: {
1479                 KeyCombination kc = (KeyCombination)result;
1480                 int mod = kAXMenuItemModifierNoCommand;
1481                 if (kc != null) {
1482                     if (kc.getShortcut() == KeyCombination.ModifierValue.DOWN) {
1483                         mod = kAXMenuItemModifierNone;
1484                     }
1485                     if (kc.getAlt() == KeyCombination.ModifierValue.DOWN) {
1486                         mod |= kAXMenuItemModifierOption;
1487                     }
1488                     if (kc.getControl() == KeyCombination.ModifierValue.DOWN) {
1489                         mod |= kAXMenuItemModifierControl;
1490                     }
1491                     if (kc.getShift() == KeyCombination.ModifierValue.DOWN) {
1492                         mod |= kAXMenuItemModifierShift;
1493                     }
1494                 }
1495                 result = mod;
1496                 break;
1497             }
1498             case AXMenuItemMarkChar: {
1499                 if (Boolean.TRUE.equals(result)) {
1500                     result = &quot;\u2713&quot;;
1501                 } else {
1502                     return null;
1503                 }
1504                 break;
1505             }
1506             case NSAccessibilityNumberOfCharactersAttribute: {
1507                 String text = (String)result;
1508                 result = (Integer)text.length();
1509                 break;
1510             }
1511             case NSAccessibilitySelectedTextAttribute: {
1512                 int start = (Integer)result, end = -1;
1513                 if (start != -1) {
1514                     result = getAttribute(SELECTION_END);
1515                     if (result == null) return null;
1516                     end = (Integer)result;
1517                 }
1518                 if (start &lt; 0 || end &lt; 0 || start &gt; end) return null;
1519                 String string = (String)getAttribute(TEXT);
1520                 if (string == null) return null;
1521                 if (end &gt; string.length()) return null;
1522                 result = string.substring(start, end);
1523                 break;
1524             }
1525             case NSAccessibilitySelectedTextRangeAttribute: {
1526                 int start = (Integer)result, end = -1;
1527                 if (start != -1) {
1528                     result = getAttribute(SELECTION_END);
1529                     if (result == null) return null;
1530                     end = (Integer)result;
1531                 }
1532                 if (start &lt; 0 || end &lt; 0 || start &gt; end) return null;
1533                 String string = (String)getAttribute(TEXT);
1534                 if (string == null) return null;
1535                 if (end &gt; string.length()) return null;
1536                 result = new int[] {start, end - start};
1537                 break;
1538             }
1539             case NSAccessibilityInsertionPointLineNumberAttribute: {
1540                 if (role == AccessibleRole.TEXT_AREA) {
1541                     Integer lineIndex = (Integer)getAttribute(LINE_FOR_OFFSET, result /*CARET_OFFSET*/);
1542                     result = lineIndex != null ? lineIndex : 0;
1543                 } else {
1544                     /* Combo and TextArea */
1545                     result = 0;
1546                 }
1547                 break;
1548             }
1549             case NSAccessibilityVisibleCharacterRangeAttribute: {
1550                 String string = (String)result;
1551                 result = new int[] {0, string.length()};
1552                 break;
1553             }
1554             case NSAccessibilityContentsAttribute: {
1555                 if (result != null) {
1556                     result = new long [] {getNativeAccessible((Node)result)};
1557                 }
1558                 break;
1559             }
1560             case NSAccessibilityRowIndexRangeAttribute:
1561             case NSAccessibilityColumnIndexRangeAttribute: {
1562                 Integer location = (Integer)result;
1563                 result = new int[] {location, 1 /* length */};
1564                 break;
1565             }
1566             case NSAccessibilityDisclosedByRowAttribute:
1567             case NSAccessibilityOverflowButtonAttribute:
1568             case NSAccessibilityTitleUIElementAttribute:
1569             case NSAccessibilityHeaderAttribute:
1570             case NSAccessibilityHorizontalScrollBarAttribute:
1571             case NSAccessibilityVerticalScrollBarAttribute: {
1572                 result = getNativeAccessible((Node)result);
1573                 break;
1574             }
1575             case NSAccessibilityOrientationAttribute:
1576                 Orientation orientation = (Orientation)result;
1577                 switch (orientation) {
1578                     case HORIZONTAL: result = MacOrientation.NSAccessibilityHorizontalOrientationValue.ptr; break;
1579                     case VERTICAL: result = MacOrientation.NSAccessibilityVerticalOrientationValue.ptr; break;
1580                     default: return null;
1581                 }
1582                 break;
1583             case NSAccessibilityDisclosingAttribute: {
1584                 if (result/*Expanded*/ == Boolean.TRUE) {
1585                     if (Boolean.TRUE.equals(getAttribute(LEAF))) {
1586                         result = Boolean.FALSE;
1587                     }
1588                 }
1589                 break;
1590             }
1591             default:
1592         }
1593         return result != null ? map.apply(result) : null;
1594     }
1595 
1596     private void accessibilitySetValue(long value, long attribute) {
1597         MacAttribute attr = MacAttribute.getAttribute(attribute);
1598         if (attr != null) {
1599             switch (attr) {
1600                 case NSAccessibilityFocusedAttribute: {
1601                     MacVariant variant = idToMacVariant(value, MacVariant.NSNumber_Boolean);
1602                     if (variant != null &amp;&amp; variant.int1 != 0) {
1603                         executeAction(AccessibleAction.REQUEST_FOCUS);
1604                     }
1605                     break;
1606                 }
1607                 case NSAccessibilityDisclosingAttribute: {
1608                     MacVariant variant = idToMacVariant(value, MacVariant.NSNumber_Boolean);
1609                     if (variant != null) {
1610                         if (variant.int1 != 0) {
1611                             executeAction(AccessibleAction.EXPAND);
1612                         } else {
1613                             executeAction(AccessibleAction.COLLAPSE);
1614                         }
1615                     }
1616                     break;
1617                 }
1618                 case NSAccessibilityExpandedAttribute:
1619                     if (getAttribute(ROLE) == AccessibleRole.COMBO_BOX) {
1620                         executeAction(AccessibleAction.EXPAND);
1621                     }
1622                     break;
1623                 case NSAccessibilitySelectedCellsAttribute: {
1624                     /* Table and TreeTable */
1625                     MacVariant variant = idToMacVariant(value, MacVariant.NSArray_id);
1626                     if (variant != null &amp;&amp; variant.longArray != null &amp;&amp; variant.longArray.length &gt; 0) {
1627                         long[] ids = variant.longArray;
1628                         ObservableList&lt;Node&gt; items = FXCollections.observableArrayList();
1629                         for (long id : ids) {
1630                             MacAccessible acc = GlassAccessibleToMacAccessible(id);
1631                             if (acc != null) {
1632                                 Integer rowIndex = (Integer)acc.getAttribute(ROW_INDEX);
1633                                 Integer columnIndex = (Integer)acc.getAttribute(COLUMN_INDEX);
1634                                 if (rowIndex != null &amp;&amp; columnIndex != null) {
1635                                     Node cell = (Node)getAttribute(CELL_AT_ROW_COLUMN, rowIndex, columnIndex);
1636                                     if (cell != null) {
1637                                         items.add(cell);
1638                                     }
1639                                 }
1640                             }
1641                         }
1642                         executeAction(AccessibleAction.SET_SELECTED_ITEMS, items);
1643                     }
1644                     break;
1645                 }
1646                 case NSAccessibilitySelectedRowsAttribute: {
1647                     /* List and Tree */
1648                     MacVariant variant = idToMacVariant(value, MacVariant.NSArray_id);
1649                     if (variant != null &amp;&amp; variant.longArray != null &amp;&amp; variant.longArray.length &gt; 0) {
1650                         long[] ids = variant.longArray;
1651                         ObservableList&lt;Node&gt; items = FXCollections.observableArrayList();
1652                         for (long id : ids) {
1653                             MacAccessible acc = GlassAccessibleToMacAccessible(id);
1654                             if (acc != null) {
1655                                 Integer index = (Integer)acc.getAttribute(INDEX);
1656                                 if (index != null) {
1657                                     Node cell = (Node)getAttribute(ROW_AT_INDEX, index);
1658                                     if (cell != null) {
1659                                         items.add(cell);
1660                                     }
1661                                 }
1662                             }
1663                         }
1664                         executeAction(AccessibleAction.SET_SELECTED_ITEMS, items);
1665                     }
1666                     break;
1667                 }
1668                 case NSAccessibilitySelectedTextRangeAttribute: {
1669                     MacVariant variant = idToMacVariant(value, MacVariant.NSValue_range);
1670                     if (variant != null) {
1671                         int start = variant.int1; /* range.location */
1672                         int end = variant.int1 + variant.int2; /* range.location + range.length */
1673                         executeAction(AccessibleAction.SET_TEXT_SELECTION, start, end);
1674                     }
1675                     break;
1676                 }
1677                 default:
1678             }
1679         }
1680     }
1681 
1682     private long accessibilityIndexOfChild(long child) {
1683         /* Forward to native code */
1684         return -1;
1685     }
1686 
1687     private long[] accessibilityParameterizedAttributeNames() {
1688         if (getView() != null) return null; /* Let NSView answer for the Scene */
1689         AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1690         if (role != null) {
1691             List&lt;MacAttribute&gt; attrs = new ArrayList&lt;&gt;();
1692             MacRole macRole = getRole(role);
1693             if (macRole != null &amp;&amp; macRole.macParameterizedAttributes != null) {
1694                 attrs.addAll(macRole.macParameterizedAttributes);
1695             }
1696             switch (role) {
1697                 case LIST_VIEW:
1698                 case TREE_VIEW:
1699                     /* Row-based control, must remove all the cell-based attributes */
1700                     attrs.remove(MacAttribute.NSAccessibilityCellForColumnAndRowParameterizedAttribute);
1701                     break;
1702                 case TEXT:
1703                 case TEXT_FIELD:
1704                 case TEXT_AREA:
1705                 case PASSWORD_FIELD:
1706                 case COMBO_BOX:
<a name="6" id="anc6"></a><span class="line-modified">1707                     attrs.addAll(TEXT_PARAMETRIZED_ATTRIBUTES);</span>
1708                     break;
1709                 default:
1710             }
1711             return attrs.stream().mapToLong(a -&gt; a.ptr).toArray();
1712         }
1713         return null;
1714     }
1715 
1716     private MacVariant accessibilityAttributeValueForParameter(long attribute, long parameter) {
1717         MacAttribute attr = MacAttribute.getAttribute(attribute);
1718         if (attr == null || attr.inputType == 0 || attr.jfxAttr == null) {
1719             return null;
1720         }
1721         MacVariant variant = idToMacVariant(parameter, attr.inputType);
1722         if (variant == null) return null;
1723         Object value = variant.getValue();
1724         Object result;
1725         switch (attr) {
1726             case NSAccessibilityCellForColumnAndRowParameterizedAttribute: {
1727                 int[] intArray = (int[])value;
1728                 result = getAttribute(attr.jfxAttr, intArray[1] /*row*/, intArray[0] /*column*/);
1729                 break;
1730             }
1731             case NSAccessibilityLineForIndexParameterizedAttribute: {
1732                 if (getAttribute(ROLE) == AccessibleRole.TEXT_AREA) {
1733                     result = getAttribute(attr.jfxAttr, value /*charOffset*/);
1734                 } else {
1735                     /* Combo and TextField */
1736                     result = 0;
1737                 }
1738                 break;
1739             }
1740             case NSAccessibilityRangeForLineParameterizedAttribute: {
1741                 if (getAttribute(ROLE) == AccessibleRole.TEXT_AREA) {
1742                     Integer lineStart = (Integer)getAttribute(LINE_START, value /*line index*/);
1743                     Integer lineEnd = (Integer)getAttribute(LINE_END, value /*line index*/);
1744                     if (lineStart != null &amp;&amp; lineEnd != null) {
1745                         result = new int[] {lineStart, lineEnd - lineStart};
1746                     } else {
1747                         result = null;
1748                     }
1749                 } else {
1750                     /* Combo and TextField */
1751                     String text = (String)getAttribute(TEXT);
1752                     result = new int[] {0, text != null ? text.length() : 0};
1753                 }
1754                 break;
1755             }
1756             case NSAccessibilityBoundsForRangeParameterizedAttribute: {
1757                 int[] intArray = (int[])value; /* range.location, range.length */
1758                 Bounds[] bounds = (Bounds[])getAttribute(attr.jfxAttr, intArray[0], intArray[0] + intArray[1] - 1);
1759                 double left = Double.POSITIVE_INFINITY;
1760                 double top = Double.POSITIVE_INFINITY;
1761                 double right = Double.NEGATIVE_INFINITY;
1762                 double bottom = Double.NEGATIVE_INFINITY;
1763                 if (bounds != null) {
1764                     for (int i = 0; i &lt; bounds.length; i++) {
1765                         Bounds b = bounds[i];
1766                         if (b != null) {
1767                             if (b.getMinX() &lt; left) left = b.getMinX();
1768                             if (b.getMinY() &lt; top) top = b.getMinY();
1769                             if (b.getMaxX() &gt; right) right = b.getMaxX();
1770                             if (b.getMaxY() &gt; bottom) bottom = b.getMaxY();
1771                         }
1772                     }
1773                 }
1774                 result = flipBounds(new BoundingBox(left, top, right - left, bottom - top));
1775                 break;
1776             }
1777             case NSAccessibilityRangeForPositionParameterizedAttribute: {
1778                 float[] floatArray = (float[])value;
1779                 Integer offset = (Integer)getAttribute(attr.jfxAttr, new Point2D(floatArray[0], floatArray[1]));
1780                 if (offset != null) {
1781                     result = new int[] {offset, 1};
1782                 } else {
1783                     result = null;
1784                 }
1785                 break;
1786             }
1787             default:
1788                 result = getAttribute(attr.jfxAttr, value);
1789         }
1790         if (result == null) return null;
1791         switch (attr) {
1792             case NSAccessibilityAttributedStringForRangeParameterizedAttribute: {
1793                 String text = (String)result;
1794                 text = text.substring(variant.int1, variant.int1 + variant.int2);
1795                 List&lt;MacVariant&gt; styles = new ArrayList&lt;&gt;();
1796                 Font font = (Font)getAttribute(FONT);
1797                 if (font != null) {
1798                     MacVariant fontDict = new MacVariant();
1799                     fontDict.type = MacVariant.NSDictionary;
1800                     fontDict.longArray = new long[] {
1801                         MacText.NSAccessibilityFontNameKey.ptr,
1802                         MacText.NSAccessibilityFontFamilyKey.ptr,
1803                         MacText.NSAccessibilityVisibleNameKey.ptr,
1804                         MacText.NSAccessibilityFontSizeKey.ptr,
1805                     };
1806                     fontDict.variantArray = new MacVariant[] {
1807                         MacVariant.createNSString(font.getName()),
1808                         MacVariant.createNSString(font.getFamily()),
1809                         MacVariant.createNSString(font.getName()),
1810                         MacVariant.createNSNumberForDouble(font.getSize()),
1811                     };
1812 
1813                     fontDict.key = MacText.NSAccessibilityFontTextAttribute.ptr;
1814                     fontDict.location = 0;
1815                     fontDict.length = text.length();
1816                     styles.add(fontDict);
1817                 }
1818                 MacVariant attrString = attr.map.apply(text);
1819                 attrString.variantArray = styles.toArray(new MacVariant[0]);
1820                 return attrString;
1821             }
1822             case NSAccessibilityStringForRangeParameterizedAttribute: {
1823                 String text = (String)result;
1824                 result = text.substring(variant.int1, variant.int1 + variant.int2);
1825                 break;
1826             }
1827             case NSAccessibilityCellForColumnAndRowParameterizedAttribute: {
1828                 result = getNativeAccessible((Node)result);
1829                 break;
1830             }
1831             default:
1832         }
1833         return attr.map.apply(result);
1834     }
1835 
1836     private long[] accessibilityActionNames() {
1837         if (getView() != null) return null; /* Let NSView answer for the Scene */
1838         AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1839         List&lt;MacAction&gt; actions = new ArrayList&lt;&gt;();
1840         if (role != null) {
1841             MacRole macRole = getRole(role);
1842             if (macRole != null &amp;&amp; macRole.macActions != null) {
1843                 actions.addAll(macRole.macActions);
1844             }
1845             /*
1846              * Consider add a attribute to indicate when the node
1847              * has a menu instead of using the role.
1848              */
1849             if (role != AccessibleRole.NODE &amp;&amp; role != AccessibleRole.PARENT) {
1850                 actions.add(MacAction.NSAccessibilityShowMenuAction);
1851             }
1852         }
1853         /* Return empty array instead of null to prevent warnings in the accessibility verifier */
1854         return actions.stream().mapToLong(a -&gt; a.ptr).toArray();
1855     }
1856 
1857     private String accessibilityActionDescription(long action) {
1858         return NSAccessibilityActionDescription(action);
1859     }
1860 
1861     private void accessibilityPerformAction(long action) {
1862         MacAction macAction = MacAction.getAction(action);
1863         boolean expand = false;
1864         if (macAction == MacAction.NSAccessibilityPressAction) {
1865             AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1866             if (role == AccessibleRole.TITLED_PANE || role == AccessibleRole.COMBO_BOX) {
1867                 expand = true;
1868             }
1869         }
1870         if (macAction == MacAction.NSAccessibilityShowMenuAction) {
1871             if (getAttribute(ROLE) == AccessibleRole.SPLIT_MENU_BUTTON) {
1872                 expand = true;
1873             }
1874         }
1875         if (expand) {
1876             if (Boolean.TRUE.equals(getAttribute(EXPANDED))) {
1877                 executeAction(AccessibleAction.COLLAPSE);
1878             } else {
1879                 executeAction(AccessibleAction.EXPAND);
1880             }
1881             return;
1882         }
1883         if (macAction != null &amp;&amp; macAction.jfxAction != null) {
1884             executeAction(macAction.jfxAction);
1885         }
1886     }
1887 
1888     private long accessibilityFocusedUIElement() {
1889         Node node = (Node)getAttribute(FOCUS_NODE);
1890         if (node == null) return 0L;
1891 
1892         Node item = (Node)getAccessible(node).getAttribute(FOCUS_ITEM);
1893         if (item != null) return getNativeAccessible(item);
1894         return getNativeAccessible(node);
1895     }
1896 
1897     private boolean accessibilityIsIgnored() {
1898         if (isIgnored()) return true;
1899         if (isInSlider()) {
1900             /*
1901              * Ignoring the children within the slider, otherwise VoiceOver
1902              * reports &#39;multiple indicator slider&#39; instead of the value.
1903              */
1904             return true;
1905         }
1906         if (isInMenu()) {
1907             AccessibleRole role = (AccessibleRole)getAttribute(ROLE);
1908             /* Within a ContextMenu or MenuBar ignore all nodes but menu item roles */
1909             return !isMenuElement(role);
1910         }
1911         if (ignoreInnerText()) {
1912             return true;
1913         }
1914         return false;
1915     }
1916 
1917     private long accessibilityHitTest(float x, float y) {
1918         View view = getView();
1919         if (view == null || view.getWindow() == null) {
1920             return 0L;
1921         }
1922         Screen screen = view.getWindow().getScreen();
1923         y = screen.getHeight() - y;
1924         Node node = (Node)getAttribute(NODE_AT_POINT, new Point2D(x, y));
1925         return NSAccessibilityUnignoredAncestor(getNativeAccessible(node));
1926   }
1927 
1928 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>