<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/WebView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import com.sun.java.scene.web.WebViewHelper;
  29 import javafx.beans.property.BooleanProperty;
  30 import javafx.beans.property.DoubleProperty;
  31 import javafx.beans.property.ObjectProperty;
  32 import javafx.beans.property.ReadOnlyDoubleProperty;
  33 import javafx.beans.property.ReadOnlyDoubleWrapper;
  34 import javafx.collections.ObservableList;
  35 import javafx.css.CssMetaData;
  36 import javafx.css.Styleable;
  37 import javafx.css.StyleableBooleanProperty;
  38 import javafx.css.StyleableDoubleProperty;
  39 import javafx.css.StyleableObjectProperty;
  40 import javafx.css.StyleableProperty;
  41 import javafx.event.EventHandler;
  42 import javafx.event.EventType;
  43 import javafx.geometry.NodeOrientation;
  44 import javafx.geometry.Point2D;
  45 import javafx.scene.Node;
  46 import javafx.scene.Parent;
<a name="1" id="anc1"></a>
  47 import javafx.scene.input.DataFormat;
  48 import javafx.scene.input.DragEvent;
  49 import javafx.scene.input.Dragboard;
  50 import javafx.scene.input.InputMethodEvent;
  51 import javafx.scene.input.KeyEvent;
  52 import javafx.scene.input.MouseButton;
  53 import javafx.scene.input.MouseEvent;
  54 import javafx.scene.input.ScrollEvent;
  55 import javafx.scene.input.TransferMode;
  56 import javafx.scene.text.FontSmoothingType;
  57 import javafx.stage.Stage;
  58 import javafx.stage.Window;
  59 import java.util.ArrayList;
  60 import java.util.Collections;
<a name="2" id="anc2"></a>
  61 import java.util.LinkedList;
  62 import java.util.List;
  63 import java.util.Map;
  64 import javafx.css.converter.BooleanConverter;
  65 import javafx.css.converter.EnumConverter;
  66 import javafx.css.converter.SizeConverter;
  67 import com.sun.javafx.geom.BaseBounds;
  68 import com.sun.javafx.geom.PickRay;
  69 import com.sun.javafx.geom.transform.BaseTransform;
  70 import com.sun.javafx.scene.DirtyBits;
  71 import com.sun.javafx.scene.NodeHelper;
  72 import com.sun.javafx.scene.SceneHelper;
  73 import com.sun.javafx.scene.input.PickResultChooser;
  74 import com.sun.javafx.sg.prism.NGNode;
  75 import com.sun.javafx.sg.prism.web.NGWebView;
  76 import com.sun.javafx.tk.TKPulseListener;
  77 import com.sun.javafx.tk.Toolkit;
  78 import com.sun.javafx.webkit.InputMethodClientImpl;
  79 import com.sun.javafx.webkit.KeyCodeMap;
  80 import com.sun.webkit.WebPage;
  81 import com.sun.webkit.event.WCFocusEvent;
  82 import com.sun.webkit.event.WCInputMethodEvent;
  83 import com.sun.webkit.event.WCKeyEvent;
  84 import com.sun.webkit.event.WCMouseEvent;
  85 import com.sun.webkit.event.WCMouseWheelEvent;
  86 
  87 /**
  88  * {@code WebView} is a {@link javafx.scene.Node} that manages a
  89  * {@link WebEngine} and displays its content. The associated {@code WebEngine}
  90  * is created automatically at construction time and cannot be changed
  91  * afterwards. {@code WebView} handles mouse and some keyboard events, and
  92  * manages scrolling automatically, so there&#39;s no need to put it into a
  93  * {@code ScrollPane}.
  94  *
  95  * &lt;p&gt;{@code WebView} objects must be created and accessed solely from the
  96  * FX thread.
  97  * @since JavaFX 2.0
  98  */
  99 final public class WebView extends Parent {
 100 
<a name="3" id="anc3"></a><span class="line-modified"> 101     private static final Map&lt;Object, Integer&gt; ID_MAP = Map.ofEntries(</span>
<span class="line-added"> 102         Map.entry(MouseButton.NONE, WCMouseEvent.NOBUTTON),</span>
<span class="line-added"> 103         Map.entry(MouseButton.PRIMARY, WCMouseEvent.BUTTON1),</span>
<span class="line-added"> 104         Map.entry(MouseButton.MIDDLE, WCMouseEvent.BUTTON2),</span>
<span class="line-added"> 105         Map.entry(MouseButton.SECONDARY, WCMouseEvent.BUTTON3),</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107         Map.entry(MouseEvent.MOUSE_PRESSED, WCMouseEvent.MOUSE_PRESSED),</span>
<span class="line-added"> 108         Map.entry(MouseEvent.MOUSE_RELEASED, WCMouseEvent.MOUSE_RELEASED),</span>
<span class="line-added"> 109         Map.entry(MouseEvent.MOUSE_MOVED, WCMouseEvent.MOUSE_MOVED),</span>
<span class="line-added"> 110         Map.entry(MouseEvent.MOUSE_DRAGGED, WCMouseEvent.MOUSE_DRAGGED),</span>
<span class="line-added"> 111 </span>
<span class="line-added"> 112         Map.entry(KeyEvent.KEY_PRESSED, WCKeyEvent.KEY_PRESSED),</span>
<span class="line-added"> 113         Map.entry(KeyEvent.KEY_RELEASED, WCKeyEvent.KEY_RELEASED),</span>
<span class="line-added"> 114         Map.entry(KeyEvent.KEY_TYPED, WCKeyEvent.KEY_TYPED));</span>
 115 
 116     private static final boolean DEFAULT_CONTEXT_MENU_ENABLED = true;
 117     private static final FontSmoothingType DEFAULT_FONT_SMOOTHING_TYPE = FontSmoothingType.LCD;
 118     private static final double DEFAULT_ZOOM = 1.0;
 119     private static final double DEFAULT_FONT_SCALE = 1.0;
 120     private static final double DEFAULT_MIN_WIDTH = 0;
 121     private static final double DEFAULT_MIN_HEIGHT = 0;
 122     private static final double DEFAULT_PREF_WIDTH = 800;
 123     private static final double DEFAULT_PREF_HEIGHT = 600;
 124     private static final double DEFAULT_MAX_WIDTH = Double.MAX_VALUE;
 125     private static final double DEFAULT_MAX_HEIGHT = Double.MAX_VALUE;
 126 
 127     private final WebPage page;
 128     private final WebEngine engine;
 129     private volatile InputMethodClientImpl imClient;
 130 
 131     /**
 132      * The stage pulse listener registered with the toolkit.
 133      * This field guarantees that the listener will exist throughout
 134      * the whole lifetime of the WebView node. This field is necessary
 135      * because the toolkit references its stage pulse listeners weakly.
 136      */
 137     private final TKPulseListener stagePulseListener;
 138 
 139     /**
 140      * Returns the {@code WebEngine} object.
 141      * @return the WebEngine
 142      */
 143     public final WebEngine getEngine() {
 144         return engine;
 145     }
 146 
 147     private final ReadOnlyDoubleWrapper width = new ReadOnlyDoubleWrapper(this, &quot;width&quot;);
 148 
 149     public final double getWidth() {
 150         return width.get();
 151     }
 152 
 153     /**
 154      * Width of this {@code WebView}.
 155      * @return the width property
 156      */
 157     public ReadOnlyDoubleProperty widthProperty() {
 158         return width.getReadOnlyProperty();
 159     }
 160 
 161     private final ReadOnlyDoubleWrapper height = new ReadOnlyDoubleWrapper(this, &quot;height&quot;);
 162 
 163     public final double getHeight() {
 164         return height.get();
 165     }
 166 
 167     /**
 168      * Height of this {@code WebView}.
 169      * @return the height property
 170      */
 171     public ReadOnlyDoubleProperty heightProperty() {
 172         return height.getReadOnlyProperty();
 173     }
 174 
 175     /*
 176      * Zoom factor applied to the entire page contents.
 177      */
 178     private DoubleProperty zoom;
 179 
 180     public final void setZoom(double value) {
 181         WebEngine.checkThread();
 182         zoomProperty().set(value);
 183     }
 184 
 185     public final double getZoom() {
 186         return (this.zoom != null)
 187                 ? this.zoom.get()
 188                 : DEFAULT_ZOOM;
 189     }
 190 
 191     /**
 192      * The current zoom factor applied to the entire page contents.
 193      *
 194      * @return the zoom property
 195      * @defaultValue 1.0
 196      *
 197      * @since JavaFX 8.0
 198      */
 199     public final DoubleProperty zoomProperty() {
 200         if (zoom == null) {
 201             zoom = new StyleableDoubleProperty(DEFAULT_ZOOM) {
 202                 @Override public void invalidated() {
 203                     Toolkit.getToolkit().checkFxUserThread();
 204                     page.setZoomFactor((float) get(), false);
 205                 }
 206 
 207                 @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 208                     return StyleableProperties.ZOOM;
 209                 }
 210                 @Override public Object getBean() {
 211                     return WebView.this;
 212                 }
 213                 @Override public String getName() {
 214                     return &quot;zoom&quot;;
 215                 }
 216             };
 217         }
 218         return zoom;
 219     }
 220 
 221     /**
 222      * Specifies scale factor applied to font. This setting affects
 223      * text content but not images and fixed size elements.
 224      *
 225      * @defaultValue 1.0
 226      */
 227     private DoubleProperty fontScale;
 228 
 229     public final void setFontScale(double value) {
 230         WebEngine.checkThread();
 231         fontScaleProperty().set(value);
 232     }
 233 
 234     public final double getFontScale() {
 235         return (this.fontScale != null)
 236                 ? this.fontScale.get()
 237                 : DEFAULT_FONT_SCALE;
 238     }
 239 
 240     public DoubleProperty fontScaleProperty() {
 241         if (fontScale == null) {
 242             fontScale = new StyleableDoubleProperty(DEFAULT_FONT_SCALE) {
 243                 @Override public void invalidated() {
 244                     Toolkit.getToolkit().checkFxUserThread();
 245                     page.setZoomFactor((float)get(), true);
 246                 }
 247                 @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 248                     return StyleableProperties.FONT_SCALE;
 249                 }
 250                 @Override public Object getBean() {
 251                     return WebView.this;
 252                 }
 253                 @Override public String getName() {
 254                     return &quot;fontScale&quot;;
 255                 }
 256             };
 257         }
 258         return fontScale;
 259     }
 260 
 261     {
 262         // To initialize the class helper at the begining each constructor of this class
 263         WebViewHelper.initHelper(this);
 264     }
 265     /**
 266      * Creates a {@code WebView} object.
 267      */
 268     public WebView() {
 269         setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
 270         getStyleClass().add(&quot;web-view&quot;);
 271         engine = new WebEngine();
 272         engine.setView(this);
 273         page = engine.getPage();
 274         page.setFontSmoothingType(DEFAULT_FONT_SMOOTHING_TYPE.ordinal());
 275 
 276         registerEventHandlers();
 277         stagePulseListener = () -&gt; {
 278             handleStagePulse();
 279         };
 280         focusedProperty().addListener((ov, t, t1) -&gt; {
 281             if (page != null) {
 282                 // Traversal direction is not currently available in FX.
 283                 WCFocusEvent focusEvent = new WCFocusEvent(
 284                     isFocused() ? WCFocusEvent.FOCUS_GAINED
 285                             : WCFocusEvent.FOCUS_LOST,
 286                 WCFocusEvent.UNKNOWN);
 287                 page.dispatchFocusEvent(focusEvent);
 288             }
 289         });
 290         setFocusTraversable(true);
 291         Toolkit.getToolkit().addStageTkPulseListener(stagePulseListener);
 292     }
 293 
 294     // Resizing support. Allows arbitrary growing and shrinking.
 295     // Designed after javafx.scene.control.Control
 296 
 297     @Override public boolean isResizable() {
 298         return true;
 299     }
 300 
 301     @Override public void resize(double width, double height) {
 302         if ((width != this.width.get()) || (height != this.height.get())) {
 303             this.width.set(width);
 304             this.height.set(height);
 305             NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
 306             NodeHelper.geomChanged(this);
 307         }
 308     }
 309 
 310     /**
 311      * Called during layout to determine the minimum width for this node.
 312      *
 313      * @return the minimum width that this node should be resized to during layout
 314      */
 315     @Override public final double minWidth(double height) {
 316         final double result = getMinWidth();
 317         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 318     }
 319 
 320     /**
 321      * Called during layout to determine the minimum height for this node.
 322      *
 323      * @return the minimum height that this node should be resized to during layout
 324      */
 325     @Override public final double minHeight(double width) {
 326         final double result = getMinHeight();
 327         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 328     }
 329 
 330 
 331     /**
 332      * Called during layout to determine the preferred width for this node.
 333      *
 334      * @return the preferred width that this node should be resized to during layout
 335      */
 336     @Override public final double prefWidth(double height) {
 337         final double result = getPrefWidth();
 338         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 339     }
 340 
 341     /**
 342      * Called during layout to determine the preferred height for this node.
 343      *
 344      * @return the preferred height that this node should be resized to during layout
 345      */
 346     @Override public final double prefHeight(double width) {
 347         final double result = getPrefHeight();
 348         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 349     }
 350     /**
 351      * Called during layout to determine the maximum width for this node.
 352      *
 353      * @return the maximum width that this node should be resized to during layout
 354      */
 355     @Override public final double maxWidth(double height) {
 356         final double result = getMaxWidth();
 357         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 358     }
 359 
 360     /**
 361      * Called during layout to determine the maximum height for this node.
 362      *
 363      * @return the maximum height that this node should be resized to during layout
 364      */
 365     @Override public final double maxHeight(double width) {
 366         final double result = getMaxHeight();
 367         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 368     }
 369 
 370     /**
 371      * Minimum width property.
 372      * @return the minWidth property
 373      */
 374     public DoubleProperty minWidthProperty() {
 375         if (minWidth == null) {
 376             minWidth = new StyleableDoubleProperty(DEFAULT_MIN_WIDTH) {
 377                 @Override
 378                 public void invalidated() {
 379                     if (getParent() != null) {
 380                         getParent().requestLayout();
 381                     }
 382                 }
 383                 @Override
 384                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 385                     return StyleableProperties.MIN_WIDTH;
 386                 }
 387                 @Override
 388                 public Object getBean() {
 389                     return WebView.this;
 390                 }
 391                 @Override
 392                 public String getName() {
 393                     return &quot;minWidth&quot;;
 394                 }
 395             };
 396         }
 397         return minWidth;
 398     }
 399     private DoubleProperty minWidth;
 400 
 401     public final void setMinWidth(double value) {
 402         minWidthProperty().set(value);
 403     }
 404 
 405     public final double getMinWidth() {
 406         return (this.minWidth != null)
 407                 ? this.minWidth.get()
 408                 : DEFAULT_MIN_WIDTH;
 409     }
 410 
 411     /**
 412      * Minimum height property.
 413      * @return the minHeight property
 414      */
 415     public DoubleProperty minHeightProperty() {
 416         if (minHeight == null) {
 417             minHeight = new StyleableDoubleProperty(DEFAULT_MIN_HEIGHT) {
 418                 @Override
 419                 public void invalidated() {
 420                     if (getParent() != null) {
 421                         getParent().requestLayout();
 422                     }
 423                 }
 424                 @Override
 425                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 426                     return StyleableProperties.MIN_HEIGHT;
 427                 }
 428                 @Override
 429                 public Object getBean() {
 430                     return WebView.this;
 431                 }
 432                 @Override
 433                 public String getName() {
 434                     return &quot;minHeight&quot;;
 435                 }
 436             };
 437         }
 438         return minHeight;
 439     }
 440     private DoubleProperty minHeight;
 441 
 442     public final void setMinHeight(double value) {
 443         minHeightProperty().set(value);
 444     }
 445 
 446     public final double getMinHeight() {
 447         return (this.minHeight != null)
 448                 ? this.minHeight.get()
 449                 : DEFAULT_MIN_HEIGHT;
 450     }
 451 
 452     /**
 453      * Convenience method for setting minimum width and height.
 454      * @param minWidth the minimum width
 455      * @param minHeight the minimum height
 456      */
 457     public void setMinSize(double minWidth, double minHeight) {
 458         setMinWidth(minWidth);
 459         setMinHeight(minHeight);
 460     }
 461 
 462     /**
 463      * Preferred width property.
 464      * @return the prefWidth property
 465      */
 466     public DoubleProperty prefWidthProperty() {
 467         if (prefWidth == null) {
 468             prefWidth = new StyleableDoubleProperty(DEFAULT_PREF_WIDTH) {
 469                 @Override
 470                 public void invalidated() {
 471                     if (getParent() != null) {
 472                         getParent().requestLayout();
 473                     }
 474                 }
 475                 @Override
 476                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 477                     return StyleableProperties.PREF_WIDTH;
 478                 }
 479                 @Override
 480                 public Object getBean() {
 481                     return WebView.this;
 482                 }
 483                 @Override
 484                 public String getName() {
 485                     return &quot;prefWidth&quot;;
 486                 }
 487             };
 488         }
 489         return prefWidth;
 490     }
 491     private DoubleProperty prefWidth;
 492 
 493     public final void setPrefWidth(double value) {
 494         prefWidthProperty().set(value);
 495     }
 496 
 497     public final double getPrefWidth() {
 498         return (this.prefWidth != null)
 499                 ? this.prefWidth.get()
 500                 : DEFAULT_PREF_WIDTH;
 501     }
 502 
 503     /**
 504      * Preferred height property.
 505      * @return the prefHeight property
 506      */
 507     public DoubleProperty prefHeightProperty() {
 508         if (prefHeight == null) {
 509             prefHeight = new StyleableDoubleProperty(DEFAULT_PREF_HEIGHT) {
 510                 @Override
 511                 public void invalidated() {
 512                     if (getParent() != null) {
 513                         getParent().requestLayout();
 514                     }
 515                 }
 516                 @Override
 517                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 518                     return StyleableProperties.PREF_HEIGHT;
 519                 }
 520                 @Override
 521                 public Object getBean() {
 522                     return WebView.this;
 523                 }
 524                 @Override
 525                 public String getName() {
 526                     return &quot;prefHeight&quot;;
 527                 }
 528             };
 529         }
 530         return prefHeight;
 531     }
 532     private DoubleProperty prefHeight;
 533 
 534     public final void setPrefHeight(double value) {
 535         prefHeightProperty().set(value);
 536     }
 537 
 538     public final double getPrefHeight() {
 539         return (this.prefHeight != null)
 540                 ? this.prefHeight.get()
 541                 : DEFAULT_PREF_HEIGHT;
 542     }
 543 
 544     /**
 545      * Convenience method for setting preferred width and height.
 546      * @param prefWidth the preferred width
 547      * @param prefHeight the preferred height
 548      */
 549     public void setPrefSize(double prefWidth, double prefHeight) {
 550         setPrefWidth(prefWidth);
 551         setPrefHeight(prefHeight);
 552     }
 553 
 554     /**
 555      * Maximum width property.
 556      * @return the maxWidth property
 557      */
 558     public DoubleProperty maxWidthProperty() {
 559         if (maxWidth == null) {
 560             maxWidth = new StyleableDoubleProperty(DEFAULT_MAX_WIDTH) {
 561                 @Override
 562                 public void invalidated() {
 563                     if (getParent() != null) {
 564                         getParent().requestLayout();
 565                     }
 566                 }
 567                 @Override
 568                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 569                     return StyleableProperties.MAX_WIDTH;
 570                 }
 571                 @Override
 572                 public Object getBean() {
 573                     return WebView.this;
 574                 }
 575                 @Override
 576                 public String getName() {
 577                     return &quot;maxWidth&quot;;
 578                 }
 579             };
 580         }
 581         return maxWidth;
 582     }
 583     private DoubleProperty maxWidth;
 584 
 585     public final void setMaxWidth(double value) {
 586         maxWidthProperty().set(value);
 587     }
 588 
 589     public final double getMaxWidth() {
 590         return (this.maxWidth != null)
 591                 ? this.maxWidth.get()
 592                 : DEFAULT_MAX_WIDTH;
 593     }
 594 
 595     /**
 596      * Maximum height property.
 597      * @return the maxHeight property
 598      */
 599     public DoubleProperty maxHeightProperty() {
 600         if (maxHeight == null) {
 601             maxHeight = new StyleableDoubleProperty(DEFAULT_MAX_HEIGHT) {
 602                 @Override
 603                 public void invalidated() {
 604                     if (getParent() != null) {
 605                         getParent().requestLayout();
 606                     }
 607                 }
 608                 @Override
 609                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 610                     return StyleableProperties.MAX_HEIGHT;
 611                 }
 612                 @Override
 613                 public Object getBean() {
 614                     return WebView.this;
 615                 }
 616                 @Override
 617                 public String getName() {
 618                     return &quot;maxHeight&quot;;
 619                 }
 620             };
 621         }
 622         return maxHeight;
 623     }
 624     private DoubleProperty maxHeight;
 625 
 626     public final void setMaxHeight(double value) {
 627         maxHeightProperty().set(value);
 628     }
 629 
 630     public final double getMaxHeight() {
 631         return (this.maxHeight != null)
 632                 ? this.maxHeight.get()
 633                 : DEFAULT_MAX_HEIGHT;
 634     }
 635 
 636     /**
 637      * Convenience method for setting maximum width and height.
 638      * @param maxWidth the maximum width
 639      * @param maxHeight the maximum height
 640      */
 641     public void setMaxSize(double maxWidth, double maxHeight) {
 642         setMaxWidth(maxWidth);
 643         setMaxHeight(maxHeight);
 644     }
 645 
 646 
 647     /**
 648      * Specifies a requested font smoothing type : gray or LCD.
 649      *
 650      * The width of the bounding box is defined by the widest row.
 651      *
 652      * Note: LCD mode doesn&#39;t apply in numerous cases, such as various
 653      * compositing modes, where effects are applied and very large glyphs.
 654      *
 655      * @defaultValue FontSmoothingType.LCD
 656      * @since JavaFX 2.2
 657      */
 658     private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;
 659 
 660     public final void setFontSmoothingType(FontSmoothingType value) {
 661         fontSmoothingTypeProperty().set(value);
 662     }
 663 
 664     public final FontSmoothingType getFontSmoothingType() {
 665         return (this.fontSmoothingType != null)
 666                 ? this.fontSmoothingType.get()
 667                 : DEFAULT_FONT_SMOOTHING_TYPE;
 668     }
 669 
 670     public final ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingTypeProperty() {
 671         if (this.fontSmoothingType == null) {
 672             this.fontSmoothingType = new StyleableObjectProperty&lt;FontSmoothingType&gt;(DEFAULT_FONT_SMOOTHING_TYPE) {
 673                 @Override
 674                 public void invalidated() {
 675                     Toolkit.getToolkit().checkFxUserThread();
 676                     page.setFontSmoothingType(get().ordinal());
 677                 }
 678                 @Override
 679                 public CssMetaData&lt;WebView, FontSmoothingType&gt; getCssMetaData() {
 680                     return StyleableProperties.FONT_SMOOTHING_TYPE;
 681                 }
 682                 @Override
 683                 public Object getBean() {
 684                     return WebView.this;
 685                 }
 686                 @Override
 687                 public String getName() {
 688                     return &quot;fontSmoothingType&quot;;
 689                 }
 690             };
 691         }
 692         return this.fontSmoothingType;
 693     }
 694 
 695     /**
 696      * Specifies whether context menu is enabled.
 697      *
 698      * @defaultValue true
 699      * @since JavaFX 2.2
 700      */
 701     private BooleanProperty contextMenuEnabled;
 702 
 703     public final void setContextMenuEnabled(boolean value) {
 704         contextMenuEnabledProperty().set(value);
 705     }
 706 
 707     public final boolean isContextMenuEnabled() {
 708         return contextMenuEnabled == null
 709                 ? DEFAULT_CONTEXT_MENU_ENABLED
 710                 : contextMenuEnabled.get();
 711     }
 712 
 713     public final BooleanProperty contextMenuEnabledProperty() {
 714         if (contextMenuEnabled == null) {
 715             contextMenuEnabled = new StyleableBooleanProperty(DEFAULT_CONTEXT_MENU_ENABLED) {
 716                 @Override public void invalidated() {
 717                     Toolkit.getToolkit().checkFxUserThread();
 718                     page.setContextMenuEnabled(get());
 719                 }
 720 
 721                 @Override public CssMetaData&lt;WebView, Boolean&gt; getCssMetaData() {
 722                     return StyleableProperties.CONTEXT_MENU_ENABLED;
 723                 }
 724 
 725                 @Override public Object getBean() {
 726                     return WebView.this;
 727                 }
 728 
 729                 @Override public String getName() {
 730                     return &quot;contextMenuEnabled&quot;;
 731                 }
 732             };
 733         }
 734         return contextMenuEnabled;
 735     }
 736 
 737     /**
 738      * Super-lazy instantiation pattern from Bill Pugh.
 739      */
 740     private static final class StyleableProperties {
 741 
 742         private static final CssMetaData&lt;WebView, Boolean&gt; CONTEXT_MENU_ENABLED
 743                 = new CssMetaData&lt;WebView, Boolean&gt;(
 744                 &quot;-fx-context-menu-enabled&quot;,
 745                 BooleanConverter.getInstance(),
 746                 DEFAULT_CONTEXT_MENU_ENABLED)
 747         {
 748             @Override public boolean isSettable(WebView view) {
 749                 return view.contextMenuEnabled == null || !view.contextMenuEnabled.isBound();
 750             }
 751             @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(WebView view) {
 752                 return (StyleableProperty&lt;Boolean&gt;)view.contextMenuEnabledProperty();
 753             }
 754         };
 755 
 756         private static final CssMetaData&lt;WebView, FontSmoothingType&gt; FONT_SMOOTHING_TYPE
 757                 = new CssMetaData&lt;WebView, FontSmoothingType&gt;(
 758                 &quot;-fx-font-smoothing-type&quot;,
 759                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
 760                 DEFAULT_FONT_SMOOTHING_TYPE) {
 761             @Override
 762             public boolean isSettable(WebView view) {
 763                 return view.fontSmoothingType == null || !view.fontSmoothingType.isBound();
 764             }
 765             @Override
 766             public StyleableProperty&lt;FontSmoothingType&gt; getStyleableProperty(WebView view) {
 767                 return (StyleableProperty&lt;FontSmoothingType&gt;)view.fontSmoothingTypeProperty();
 768             }
 769         };
 770 
 771         private static final CssMetaData&lt;WebView, Number&gt; ZOOM
 772                 = new CssMetaData&lt;WebView, Number&gt;(
 773                 &quot;-fx-zoom&quot;,
 774                 SizeConverter.getInstance(),
 775                 DEFAULT_ZOOM) {
 776             @Override public boolean isSettable(WebView view) {
 777                 return view.zoom == null || !view.zoom.isBound();
 778             }
 779             @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 780                 return (StyleableProperty&lt;Number&gt;)view.zoomProperty();
 781             }
 782         };
 783 
 784         private static final CssMetaData&lt;WebView, Number&gt; FONT_SCALE
 785                 = new CssMetaData&lt;WebView, Number&gt;(
 786                 &quot;-fx-font-scale&quot;,
 787                 SizeConverter.getInstance(),
 788                 DEFAULT_FONT_SCALE) {
 789             @Override
 790             public boolean isSettable(WebView view) {
 791                 return view.fontScale == null || !view.fontScale.isBound();
 792             }
 793             @Override
 794             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 795                 return (StyleableProperty&lt;Number&gt;)view.fontScaleProperty();
 796             }
 797         };
 798 
 799         private static final CssMetaData&lt;WebView, Number&gt; MIN_WIDTH
 800                 = new CssMetaData&lt;WebView, Number&gt;(
 801                 &quot;-fx-min-width&quot;,
 802                 SizeConverter.getInstance(),
 803                 DEFAULT_MIN_WIDTH) {
 804             @Override
 805             public boolean isSettable(WebView view) {
 806                 return view.minWidth == null || !view.minWidth.isBound();
 807             }
 808             @Override
 809             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 810                 return (StyleableProperty&lt;Number&gt;)view.minWidthProperty();
 811             }
 812         };
 813 
 814         private static final CssMetaData&lt;WebView, Number&gt; MIN_HEIGHT
 815                 = new CssMetaData&lt;WebView, Number&gt;(
 816                 &quot;-fx-min-height&quot;,
 817                 SizeConverter.getInstance(),
 818                 DEFAULT_MIN_HEIGHT) {
 819             @Override
 820             public boolean isSettable(WebView view) {
 821                 return view.minHeight == null || !view.minHeight.isBound();
 822             }
 823             @Override
 824             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 825                 return (StyleableProperty&lt;Number&gt;)view.minHeightProperty();
 826             }
 827         };
 828 
 829         private static final CssMetaData&lt;WebView, Number&gt; MAX_WIDTH
 830                 = new CssMetaData&lt;WebView, Number&gt;(
 831                 &quot;-fx-max-width&quot;,
 832                 SizeConverter.getInstance(),
 833                 DEFAULT_MAX_WIDTH) {
 834             @Override
 835             public boolean isSettable(WebView view) {
 836                 return view.maxWidth == null || !view.maxWidth.isBound();
 837             }
 838             @Override
 839             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 840                 return (StyleableProperty&lt;Number&gt;)view.maxWidthProperty();
 841             }
 842         };
 843 
 844         private static final CssMetaData&lt;WebView, Number&gt; MAX_HEIGHT
 845                 = new CssMetaData&lt;WebView, Number&gt;(
 846                 &quot;-fx-max-height&quot;,
 847                 SizeConverter.getInstance(),
 848                 DEFAULT_MAX_HEIGHT) {
 849             @Override
 850             public boolean isSettable(WebView view) {
 851                 return view.maxHeight == null || !view.maxHeight.isBound();
 852             }
 853             @Override
 854             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 855                 return (StyleableProperty&lt;Number&gt;)view.maxHeightProperty();
 856             }
 857         };
 858 
 859         private static final CssMetaData&lt;WebView, Number&gt; PREF_WIDTH
 860                 = new CssMetaData&lt;WebView, Number&gt;(
 861                 &quot;-fx-pref-width&quot;,
 862                 SizeConverter.getInstance(),
 863                 DEFAULT_PREF_WIDTH) {
 864             @Override
 865             public boolean isSettable(WebView view) {
 866                 return view.prefWidth == null || !view.prefWidth.isBound();
 867             }
 868             @Override
 869             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 870                 return (StyleableProperty&lt;Number&gt;)view.prefWidthProperty();
 871             }
 872         };
 873 
 874         private static final CssMetaData&lt;WebView, Number&gt; PREF_HEIGHT
 875                 = new CssMetaData&lt;WebView, Number&gt;(
 876                 &quot;-fx-pref-height&quot;,
 877                 SizeConverter.getInstance(),
 878                 DEFAULT_PREF_HEIGHT) {
 879             @Override
 880             public boolean isSettable(WebView view) {
 881                 return view.prefHeight == null || !view.prefHeight.isBound();
 882             }
 883             @Override
 884             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 885                 return (StyleableProperty&lt;Number&gt;)view.prefHeightProperty();
 886             }
 887         };
 888 
 889         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 890 
 891         static {
 892             List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables
 893                     = new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Parent.getClassCssMetaData());
 894             styleables.add(CONTEXT_MENU_ENABLED);
 895             styleables.add(FONT_SMOOTHING_TYPE);
 896             styleables.add(ZOOM);
 897             styleables.add(FONT_SCALE);
 898             styleables.add(MIN_WIDTH);
 899             styleables.add(PREF_WIDTH);
 900             styleables.add(MAX_WIDTH);
 901             styleables.add(MIN_HEIGHT);
 902             styleables.add(PREF_HEIGHT);
 903             styleables.add(MAX_HEIGHT);
 904             STYLEABLES = Collections.unmodifiableList(styleables);
 905          }
 906     }
 907 
 908     /**
 909      * @return The CssMetaData associated with this class, which may include the
 910      * CssMetaData of its superclasses.
 911      * @since JavaFX 8.0
 912      */
 913     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 914         return StyleableProperties.STYLEABLES;
 915     }
 916 
 917     /**
 918      * {@inheritDoc}
 919      * @since JavaFX 8.0
 920      */
 921     @Override
 922     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 923         return getClassCssMetaData();
 924     }
 925 
 926     // event handling
 927 
 928     // To handle stage pulse we need to know if currently webview and
 929     // tree is visible or not
 930     private boolean isTreeReallyVisible() {
 931         if (getScene() == null) {
 932             return false;
 933         }
 934 
 935         final Window window = getScene().getWindow();
 936 
 937         if (window == null) {
 938             return false;
 939         }
 940 
 941         boolean iconified = (window instanceof Stage) ? ((Stage)window).isIconified() : false;
 942 
 943         return NodeHelper.isTreeVisible(this)
 944                &amp;&amp; window.isShowing()
 945                &amp;&amp; window.getWidth() &gt; 0
 946                &amp;&amp; window.getHeight() &gt; 0
 947                &amp;&amp; !iconified;
 948     }
 949 
 950     private void handleStagePulse() {
 951         // The stage pulse occurs before the scene pulse.
 952         // Here the page content is updated before CSS/Layout/Sync pass
 953         // is initiated by the scene pulse. The update may
 954         // change the WebView children and, if so, the children should be
 955         // processed right away during the scene pulse.
 956 
 957         // The WebView node does not render its pending render queues
 958         // while it is invisible. Therefore, we should not schedule new
 959         // render queues while the WebView is invisible to prevent
 960         // the list of render queues from growing infinitely.
 961         // Also, if and when the WebView becomes invisible, the currently
 962         // pending render queues, if any, become obsolete and should be
 963         // discarded.
 964 
 965         if (page == null) return;
 966 
 967         boolean reallyVisible = isTreeReallyVisible();
 968 
 969         if (reallyVisible) {
 970             if (page.isDirty()) {
 971                 SceneHelper.setAllowPGAccess(true);
 972                 final NGWebView peer = NodeHelper.getPeer(this);
 973                 peer.update(); // creates new render queues
 974                 if (page.isRepaintPending()) {
 975                     NodeHelper.markDirty(this, DirtyBits.WEBVIEW_VIEW);
 976                 }
 977                 SceneHelper.setAllowPGAccess(false);
 978             }
 979         } else {
 980             page.dropRenderFrames();
 981         }
 982     }
 983 
 984     private void processMouseEvent(MouseEvent ev) {
 985         if (page == null) {
 986             return;
 987         }
 988 
 989         // RT-24511
 990         EventType&lt;? extends MouseEvent&gt; type = ev.getEventType();
 991         double x = ev.getX();
 992         double y = ev.getY();
 993         double screenX = ev.getScreenX();
 994         double screenY = ev.getScreenY();
 995         if (type == MouseEvent.MOUSE_EXITED) {
 996             type = MouseEvent.MOUSE_MOVED;
 997             x = Short.MIN_VALUE;
 998             y = Short.MIN_VALUE;
 999             Point2D screenPoint = localToScreen(x, y);
1000             if (screenPoint == null) {
1001                 return;
1002             }
1003             screenX = screenPoint.getX();
1004             screenY = screenPoint.getY();
1005         }
1006 
<a name="4" id="anc4"></a><span class="line-modified">1007         final Integer id = ID_MAP.get(type);</span>
<span class="line-modified">1008         final Integer button = ID_MAP.get(ev.getButton());</span>
1009         if (id == null || button == null) {
1010             // not supported by webkit
1011             return;
1012         }
1013         WCMouseEvent mouseEvent =
1014                 new WCMouseEvent(id, button,
1015                     ev.getClickCount(), (int) x, (int) y,
1016                     (int) screenX, (int) screenY,
1017                     System.currentTimeMillis(),
1018                     ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
1019                     ev.isMetaDown(), ev.isPopupTrigger());
1020         page.dispatchMouseEvent(mouseEvent);
1021         ev.consume();
1022     }
1023 
1024     private void processScrollEvent(ScrollEvent ev) {
1025         if (page == null) {
1026             return;
1027         }
1028         double dx = - ev.getDeltaX() * getFontScale() * getScaleX();
1029         double dy = - ev.getDeltaY() * getFontScale() * getScaleY();
1030         WCMouseWheelEvent wheelEvent =
1031                 new WCMouseWheelEvent((int)ev.getX(), (int)ev.getY(),
1032                     (int)ev.getScreenX(), (int)ev.getScreenY(),
1033                     System.currentTimeMillis(),
1034                     ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
1035                     ev.isMetaDown(), (float)dx, (float)dy);
1036         page.dispatchMouseWheelEvent(wheelEvent);
1037         ev.consume();
1038     }
1039 
1040     private void processKeyEvent(KeyEvent ev) {
1041         if (page == null) return;
1042 
1043         String text = null;
1044         String keyIdentifier = null;
1045         int windowsVirtualKeyCode = 0;
1046         if(ev.getEventType() == KeyEvent.KEY_TYPED) {
1047             text = ev.getCharacter();
1048         } else {
1049             KeyCodeMap.Entry keyCodeEntry = KeyCodeMap.lookup(ev.getCode());
1050             keyIdentifier = keyCodeEntry.getKeyIdentifier();
1051             windowsVirtualKeyCode = keyCodeEntry.getWindowsVirtualKeyCode();
1052         }
1053 
1054         WCKeyEvent keyEvent = new WCKeyEvent(
<a name="5" id="anc5"></a><span class="line-modified">1055                 ID_MAP.get(ev.getEventType()),</span>
1056                 text,
1057                 keyIdentifier,
1058                 windowsVirtualKeyCode,
1059                 ev.isShiftDown(), ev.isControlDown(),
1060                 ev.isAltDown(), ev.isMetaDown(), System.currentTimeMillis());
1061         if (page.dispatchKeyEvent(keyEvent)) {
1062             ev.consume();
1063         }
1064     }
1065 
1066     private InputMethodClientImpl getInputMethodClient() {
1067          if (imClient == null) {
1068              synchronized (this) {
1069                  if (imClient == null) {
1070                      imClient = new InputMethodClientImpl(this, page);
1071                  }
1072              }
1073          }
1074          return imClient;
1075     }
1076 
1077     private void processInputMethodEvent(InputMethodEvent ie) {
1078         if (page == null) {
1079             return;
1080         }
1081 
1082         if (!getInputMethodClient().getInputMethodState()) {
1083             ie.consume();
1084             return;
1085         }
1086 
1087         WCInputMethodEvent imEvent = InputMethodClientImpl.convertToWCInputMethodEvent(ie);
1088         if (page.dispatchInputMethodEvent(imEvent)) {
1089             ie.consume();
1090             return;
1091         }
1092     }
1093 
1094     private static final int WK_DND_ACTION_NONE = 0x0;
1095     private static final int WK_DND_ACTION_COPY = 0x1;
1096     private static final int WK_DND_ACTION_MOVE = 0x2;
1097     private static final int WK_DND_ACTION_LINK = 0x40000000;
1098 
1099     private static int getWKDndEventType(EventType  et) {
1100         int commandId = 0;
1101         if (et == DragEvent.DRAG_ENTERED)
1102             commandId = WebPage.DND_DST_ENTER;
1103         else if (et == DragEvent.DRAG_EXITED)
1104             commandId = WebPage.DND_DST_EXIT;
1105         else if (et == DragEvent.DRAG_OVER)
1106             commandId = WebPage.DND_DST_OVER;
1107         else if (et == DragEvent.DRAG_DROPPED)
1108             commandId = WebPage.DND_DST_DROP;
1109         return commandId;
1110     }
1111 
1112     private static int getWKDndAction(TransferMode... tms) {
1113         int dndActionId = WK_DND_ACTION_NONE;
1114         for (TransferMode tm : tms) {
1115            if (tm == TransferMode.COPY)
1116                dndActionId |=  WK_DND_ACTION_COPY;
1117            else if (tm == TransferMode.MOVE)
1118                dndActionId |=  WK_DND_ACTION_MOVE;
1119            else if (tm == TransferMode.LINK)
1120                dndActionId |=  WK_DND_ACTION_LINK;
1121         }
1122         return dndActionId;
1123     }
1124 
1125     private static TransferMode[] getFXDndAction(int wkDndAction) {
1126         LinkedList&lt;TransferMode&gt; tms = new LinkedList&lt;TransferMode&gt;();
1127         if ((wkDndAction &amp; WK_DND_ACTION_COPY) != 0)
1128             tms.add(TransferMode.COPY);
1129         if ((wkDndAction &amp; WK_DND_ACTION_MOVE) != 0)
1130             tms.add(TransferMode.MOVE);
1131         if ((wkDndAction &amp; WK_DND_ACTION_LINK) != 0)
1132             tms.add(TransferMode.LINK);
1133         return tms.toArray(new TransferMode[0]);
1134     }
1135 
1136     private void registerEventHandlers() {
1137         addEventHandler(KeyEvent.ANY,
1138                 event -&gt; {
1139                     processKeyEvent(event);
1140                 });
1141         addEventHandler(MouseEvent.ANY,
1142                 event -&gt; {
1143                     processMouseEvent(event);
1144                     if (event.isDragDetect() &amp;&amp; !page.isDragConfirmed()) {
1145                         //postpone drag recognition:
1146                         //Webkit cannot resolve here is it a drag
1147                         //or selection.
1148                         event.setDragDetect(false);
1149                     }
1150                 });
1151         addEventHandler(ScrollEvent.SCROLL,
1152                 event -&gt; {
1153                     processScrollEvent(event);
1154                 });
1155         setOnInputMethodTextChanged(
1156                 event -&gt; {
1157                     processInputMethodEvent(event);
1158                 });
1159 
1160         //Drop target implementation:
1161         EventHandler&lt;DragEvent&gt; destHandler = event -&gt; {
1162             try {
1163                 Dragboard db = event.getDragboard();
1164                 LinkedList&lt;String&gt; mimes = new LinkedList&lt;String&gt;();
1165                 LinkedList&lt;String&gt; values = new LinkedList&lt;String&gt;();
1166                 for (DataFormat df : db.getContentTypes()) {
1167                     //TODO: extend to non-string serialized values.
1168                     //Please, look at the native code.
1169                     Object content = db.getContent(df);
1170                     if (content != null) {
1171                         for (String mime : df.getIdentifiers()) {
1172                             mimes.add(mime);
1173                             values.add(content.toString());
1174                         }
1175                     }
1176                 }
1177                 if (!mimes.isEmpty()) {
1178                     int wkDndEventType = getWKDndEventType(event.getEventType());
1179                     int wkDndAction = page.dispatchDragOperation(
1180                         wkDndEventType,
1181                         mimes.toArray(new String[0]), values.toArray(new String[0]),
1182                         (int)event.getX(), (int)event.getY(),
1183                         (int)event.getScreenX(), (int)event.getScreenY(),
1184                         getWKDndAction(db.getTransferModes().toArray(new TransferMode[0])));
1185 
1186                     //we cannot accept nothing on drop (we skip FX exception)
1187                     if (!(wkDndEventType == WebPage.DND_DST_DROP &amp;&amp; wkDndAction == WK_DND_ACTION_NONE)) {
1188                         event.acceptTransferModes(getFXDndAction(wkDndAction));
1189                     }
1190                     event.consume();
1191                 }
1192             } catch (SecurityException ex) {
1193                 // Just ignore the exception
1194                 //ex.printStackTrace();
1195             }
1196         };
1197         setOnDragEntered(destHandler);
1198         setOnDragExited(destHandler);
1199         setOnDragOver(destHandler);
1200         setOnDragDropped(destHandler);
1201 
1202         //Drag source implementation:
1203         setOnDragDetected(event -&gt; {
1204                if (page.isDragConfirmed()) {
1205                    page.confirmStartDrag();
1206                    event.consume();
1207                }
1208            });
1209         setOnDragDone(event -&gt; {
1210                 page.dispatchDragOperation(
1211                     WebPage.DND_SRC_DROP,
1212                     null, null,
1213                     (int)event.getX(), (int)event.getY(),
1214                     (int)event.getScreenX(), (int)event.getScreenY(),
1215                     getWKDndAction(event.getAcceptedTransferMode()));
1216                 event.consume();
1217             });
1218 
1219         setInputMethodRequests(getInputMethodClient());
1220     }
1221 
1222     /*
1223      * Note: This method MUST only be called via its accessor method.
1224      */
1225     private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
1226         NodeHelper.intersects(this, pickRay, result);
1227     }
1228 
1229     @Override protected ObservableList&lt;Node&gt; getChildren() {
1230         return super.getChildren();
1231     }
1232 
1233     // Node stuff
1234 
1235     /*
1236      * Note: This method MUST only be called via its accessor method.
1237      */
1238     private NGNode doCreatePeer() {
1239         return new NGWebView();
1240     }
1241 
1242     /*
1243      * Note: This method MUST only be called via its accessor method.
1244      */
1245     private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
1246         bounds.deriveWithNewBounds(0, 0, 0, (float) getWidth(), (float)getHeight(), 0);
1247         tx.transform(bounds, bounds);
1248         return bounds;
1249     }
1250 
1251     /*
1252      * Note: This method MUST only be called via its accessor method.
1253      */
1254     private void doTransformsChanged() {
1255     }
1256 
1257     /*
1258      * Note: This method MUST only be called via its accessor method.
1259      */
1260     private boolean doComputeContains(double localX, double localY) {
1261         // Note: Local bounds contain test is already done by the caller. (Node.contains()).
1262         return true;
1263     }
1264 
1265     /*
1266      * Note: This method MUST only be called via its accessor method.
1267      */
1268     private void doUpdatePeer() {
1269         final NGWebView peer = NodeHelper.getPeer(this);
1270 
1271         if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
1272             peer.setPage(page);
1273         }
1274         if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
1275             peer.resize((float)getWidth(), (float)getHeight());
1276         }
1277         if (NodeHelper.isDirty(this, DirtyBits.WEBVIEW_VIEW)) {
1278             peer.requestRender();
1279         }
1280     }
1281 
1282     static {
1283         WebViewHelper.setWebViewAccessor(new WebViewHelper.WebViewAccessor() {
1284             @Override
1285             public NGNode doCreatePeer(Node node) {
1286                 return ((WebView) node).doCreatePeer();
1287             }
1288 
1289             @Override
1290             public void doUpdatePeer(Node node) {
1291                 ((WebView) node).doUpdatePeer();
1292             }
1293 
1294             @Override
1295             public void doTransformsChanged(Node node) {
1296                 ((WebView) node).doTransformsChanged();
1297             }
1298 
1299             @Override
1300             public BaseBounds doComputeGeomBounds(Node node,
1301                     BaseBounds bounds, BaseTransform tx) {
1302                 return ((WebView) node).doComputeGeomBounds(bounds, tx);
1303             }
1304 
1305             @Override
1306             public boolean doComputeContains(Node node, double localX, double localY) {
1307                 return ((WebView) node).doComputeContains(localX, localY);
1308             }
1309 
1310             @Override
1311             public void doPickNodeLocal(Node node, PickRay localPickRay,
1312                     PickResultChooser result) {
1313                 ((WebView) node).doPickNodeLocal(localPickRay, result);
1314             }
1315         });
<a name="6" id="anc6"></a>













1316     }
1317 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>