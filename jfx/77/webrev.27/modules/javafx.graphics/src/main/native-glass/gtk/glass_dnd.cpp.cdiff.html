<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="GlassWindow.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_general.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,10 ***</span>
<span class="line-new-header">--- 20,11 ---</span>
   *
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
<span class="line-added">+ </span>
  #include &quot;glass_dnd.h&quot;
  #include &quot;glass_general.h&quot;
  #include &quot;glass_evloop.h&quot;
  
  #include &quot;com_sun_glass_events_DndEvent.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,614 ***</span>
  #include &lt;gtk/gtk.h&gt;
  #include &lt;gdk/gdkx.h&gt;
  #include &lt;gdk/gdkkeysyms.h&gt;
  
  /************************* COMMON *********************************************/
<span class="line-modified">! static jint translate_gdk_action_to_glass(GdkDragAction action)</span>
<span class="line-removed">- {</span>
      jint result = 0;
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_COPY)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;</span>
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_MOVE)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;</span>
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_LINK)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;</span>
      return result;
  }
  
<span class="line-modified">! static GdkDragAction translate_glass_action_to_gdk(jint action)</span>
<span class="line-removed">- {</span>
      int result = 0;
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY)? GDK_ACTION_COPY : 0;</span>
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE)? GDK_ACTION_MOVE : 0;</span>
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE)? GDK_ACTION_LINK : 0;</span>
      return static_cast&lt;GdkDragAction&gt;(result);
  }
  
<span class="line-modified">! static gboolean target_atoms_initialized = FALSE;</span>
<span class="line-modified">! static GdkAtom TARGET_UTF8_STRING_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_MIME_TEXT_PLAIN_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_COMPOUND_TEXT_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_STRING_ATOM;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static GdkAtom TARGET_MIME_URI_LIST_ATOM;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static GdkAtom TARGET_MIME_PNG_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_MIME_JPEG_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_MIME_TIFF_ATOM;</span>
<span class="line-removed">- static GdkAtom TARGET_MIME_BMP_ATOM;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void init_target_atoms()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (target_atoms_initialized) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     TARGET_UTF8_STRING_ATOM = gdk_atom_intern_static_string(&quot;UTF8_STRING&quot;);</span>
<span class="line-removed">-     TARGET_MIME_TEXT_PLAIN_ATOM = gdk_atom_intern_static_string(&quot;text/plain&quot;);</span>
<span class="line-removed">-     TARGET_COMPOUND_TEXT_ATOM = gdk_atom_intern_static_string(&quot;COMPOUND_TEXT&quot;);</span>
<span class="line-removed">-     TARGET_STRING_ATOM = gdk_atom_intern_static_string(&quot;STRING&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     TARGET_MIME_URI_LIST_ATOM = gdk_atom_intern_static_string(&quot;text/uri-list&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     TARGET_MIME_PNG_ATOM = gdk_atom_intern_static_string(&quot;image/png&quot;);</span>
<span class="line-removed">-     TARGET_MIME_JPEG_ATOM = gdk_atom_intern_static_string(&quot;image/jpeg&quot;);</span>
<span class="line-removed">-     TARGET_MIME_TIFF_ATOM = gdk_atom_intern_static_string(&quot;image/tiff&quot;);</span>
<span class="line-removed">-     TARGET_MIME_BMP_ATOM = gdk_atom_intern_static_string(&quot;image/bmp&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     target_atoms_initialized = TRUE;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean target_is_text(GdkAtom target)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     init_target_atoms();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return (target == TARGET_UTF8_STRING_ATOM ||</span>
<span class="line-removed">-             target == TARGET_STRING_ATOM ||</span>
<span class="line-removed">-             target == TARGET_MIME_TEXT_PLAIN_ATOM/* ||</span>
<span class="line-removed">-             target == TARGET_COMPOUND_TEXT_ATOM*/);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean target_is_uri(GdkAtom target)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     init_target_atoms();</span>
<span class="line-removed">-     return target == TARGET_MIME_URI_LIST_ATOM;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean target_is_image(GdkAtom target)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     init_target_atoms();</span>
<span class="line-removed">-     return (target == TARGET_MIME_PNG_ATOM ||</span>
<span class="line-removed">-             target == TARGET_MIME_JPEG_ATOM ||</span>
<span class="line-removed">-             target == TARGET_MIME_TIFF_ATOM ||</span>
<span class="line-removed">-             target == TARGET_MIME_BMP_ATOM);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void clear_global_ref(gpointer data)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     mainEnv-&gt;DeleteGlobalRef((jobject)data);</span>
  }
  
  static void dnd_set_performed_action(jint performed_action);
  static jint dnd_get_performed_action();
  
<span class="line-modified">! /************************* TARGET *********************************************/</span>
<span class="line-modified">! struct selection_data_ctx {</span>
<span class="line-modified">!     gboolean received;</span>
<span class="line-modified">!     guchar *data;</span>
<span class="line-modified">!     GdkAtom type;</span>
<span class="line-removed">-     gint format;</span>
<span class="line-removed">-     gint length;</span>
  };
  
<span class="line-modified">! static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx);</span>
  
  static struct {
      GdkDragContext *ctx;
      gboolean just_entered;
      jobjectArray mimes;
<span class="line-modified">!     gint dx, dy;</span>
<span class="line-removed">- } enter_ctx = {NULL, FALSE, NULL, 0, 0};</span>
  
  gboolean is_dnd_owner = FALSE;
<span class="line-removed">- </span>
  GtkWidget *drag_widget = NULL;
  
  gboolean is_in_drag() {
      return drag_widget != NULL;
  }
  
<span class="line-modified">! static void reset_enter_ctx() {</span>
<span class="line-modified">!     if (enter_ctx.mimes != NULL) {</span>
<span class="line-modified">!         mainEnv-&gt;DeleteGlobalRef(enter_ctx.mimes);</span>
      }
  
<span class="line-modified">!     memset(&amp;enter_ctx, 0, sizeof(enter_ctx));</span>
  }
  
<span class="line-modified">! static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     reset_enter_ctx();</span>
<span class="line-modified">!     enter_ctx.ctx = event-&gt;context;</span>
<span class="line-modified">!     enter_ctx.just_entered = TRUE;</span>
<span class="line-modified">!     gdk_window_get_origin(ctx-&gt;get_gdk_window(), &amp;enter_ctx.dx, &amp;enter_ctx.dy);</span>
<span class="line-modified">!     is_dnd_owner = is_in_drag();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!enter_ctx.ctx) {</span>
<span class="line-modified">!         gdk_drag_status(event-&gt;context, static_cast&lt;GdkDragAction&gt;(0), GDK_CURRENT_TIME);</span>
<span class="line-modified">!         return; // Do not process motion events if no enter event was received</span>
      }
<span class="line-modified">!     jmethodID method = enter_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;</span>
<span class="line-modified">!     GdkDragAction suggested = gdk_drag_context_get_suggested_action(event-&gt;context);</span>
      GdkDragAction result = translate_glass_action_to_gdk(mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), method,
<span class="line-modified">!             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,</span>
<span class="line-modified">!             (jint)event-&gt;x_root, (jint)event-&gt;y_root,</span>
<span class="line-modified">!             translate_gdk_action_to_glass(suggested)));</span>
<span class="line-modified">!     CHECK_JNI_EXCEPTION(mainEnv)</span>
  
<span class="line-modified">!     if (enter_ctx.just_entered) {</span>
<span class="line-modified">!         enter_ctx.just_entered = FALSE;</span>
      }
<span class="line-modified">!     gdk_drag_status(event-&gt;context, result, GDK_CURRENT_TIME);</span>
  }
  
<span class="line-modified">! static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     (void)event;</span>
  
<span class="line-modified">!     mainEnv-&gt;CallVoidMethod(ctx-&gt;get_jview(), jViewNotifyDragLeave, NULL);</span>
<span class="line-modified">!     CHECK_JNI_EXCEPTION(mainEnv)</span>
  }
  
<span class="line-modified">! static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!enter_ctx.ctx || enter_ctx.just_entered) {</span>
<span class="line-modified">!         gdk_drop_finish(event-&gt;context, FALSE, GDK_CURRENT_TIME);</span>
<span class="line-modified">!         gdk_drop_reply(event-&gt;context, FALSE, GDK_CURRENT_TIME);</span>
<span class="line-modified">!         return; // Do not process drop events if no enter event and subsequent motion event were received</span>
      }
<span class="line-removed">-     GdkDragAction selected = gdk_drag_context_get_selected_action(event-&gt;context);</span>
  
      mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), jViewNotifyDragDrop,
<span class="line-modified">!             (jint)event-&gt;x_root - enter_ctx.dx, (jint)event-&gt;y_root - enter_ctx.dy,</span>
<span class="line-modified">!             (jint)event-&gt;x_root, (jint)event-&gt;y_root,</span>
<span class="line-modified">!             translate_gdk_action_to_glass(selected));</span>
      LOG_EXCEPTION(mainEnv)
  
<span class="line-modified">!     gdk_drop_finish(event-&gt;context, TRUE, GDK_CURRENT_TIME);</span>
<span class="line-modified">!     gdk_drop_reply(event-&gt;context, TRUE, GDK_CURRENT_TIME);</span>
  }
  
<span class="line-modified">! static gboolean check_state_in_drag(JNIEnv *env)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     if (!enter_ctx.ctx) {</span>
          jclass jc = env-&gt;FindClass(&quot;java/lang/IllegalStateException&quot;);
          if (!env-&gt;ExceptionCheck()) {
              env-&gt;ThrowNew(jc,
<span class="line-modified">!                     &quot;Cannot get supported actions. Drag pointer haven&#39;t entered the application window&quot;);</span>
          }
          return TRUE;
      }
      return FALSE;
  }
  
<span class="line-modified">! // Events coming from application that are related to us being a DnD target</span>
<span class="line-modified">! void process_dnd_target(WindowContext *ctx, GdkEventDND *event)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     switch (event-&gt;type) {</span>
<span class="line-modified">!         case GDK_DRAG_ENTER:</span>
<span class="line-modified">!             process_dnd_target_drag_enter(ctx, event);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case GDK_DRAG_MOTION:</span>
<span class="line-removed">-             process_dnd_target_drag_motion(ctx, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_DRAG_LEAVE:</span>
<span class="line-removed">-             process_dnd_target_drag_leave(ctx, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case GDK_DROP_START:</span>
<span class="line-removed">-             process_dnd_target_drop_start(ctx, event);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             break;</span>
      }
  }
  
<span class="line-modified">! jobjectArray dnd_target_get_mimes(JNIEnv *env)</span>
<span class="line-removed">- {</span>
      if (check_state_in_drag(env)) {
          return NULL;
      }
<span class="line-modified">!     if (!enter_ctx.mimes) {</span>
<span class="line-modified">!         GList* targets = gdk_drag_context_list_targets(enter_ctx.ctx);</span>
          jobject set = env-&gt;NewObject(jHashSetCls, jHashSetInit, NULL);
          EXCEPTION_OCCURED(env);
  
<span class="line-modified">!         while (targets) {</span>
<span class="line-modified">!             GdkAtom target = GDK_POINTER_TO_ATOM(targets-&gt;data);</span>
<span class="line-modified">!             gchar *name = gdk_atom_name(target);</span>
  
<span class="line-modified">!             if (target_is_text(target)) {</span>
<span class="line-modified">!                 jstring jStr = env-&gt;NewStringUTF(&quot;text/plain&quot;);</span>
<span class="line-modified">!                 EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-modified">!                 EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             if (target_is_image(target)) {</span>
<span class="line-modified">!                 jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-rawimage&quot;);</span>
<span class="line-modified">!                 EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-modified">!                 EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             if (target_is_uri(target)) {</span>
<span class="line-modified">!                 selection_data_ctx ctx;</span>
<span class="line-modified">!                 if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {</span>
<span class="line-modified">!                     gchar** uris = g_uri_list_extract_uris((gchar *) ctx.data);</span>
<span class="line-modified">!                     guint size = g_strv_length(uris);</span>
<span class="line-removed">-                     guint files_cnt = get_files_count(uris);</span>
<span class="line-removed">-                     if (files_cnt) {</span>
<span class="line-removed">-                         jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-file-list&quot;);</span>
<span class="line-removed">-                         EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-removed">-                         EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (size - files_cnt) {</span>
<span class="line-removed">-                         jstring jStr = env-&gt;NewStringUTF(&quot;text/uri-list&quot;);</span>
<span class="line-removed">-                         EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                         env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-removed">-                         EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     g_strfreev(uris);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 g_free(ctx.data);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 jstring jStr = env-&gt;NewStringUTF(name);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                 env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-             }</span>
  
              g_free(name);
<span class="line-removed">-             targets = targets-&gt;next;</span>
          }
<span class="line-modified">!         enter_ctx.mimes = env-&gt;NewObjectArray(env-&gt;CallIntMethod(set, jSetSize, NULL),</span>
<span class="line-modified">!                 jStringCls, NULL);</span>
          EXCEPTION_OCCURED(env);
<span class="line-modified">!         enter_ctx.mimes = (jobjectArray)env-&gt;CallObjectMethod(set, jSetToArray, enter_ctx.mimes, NULL);</span>
<span class="line-modified">!         enter_ctx.mimes = (jobjectArray)env-&gt;NewGlobalRef(enter_ctx.mimes);</span>
      }
<span class="line-modified">!     return enter_ctx.mimes;</span>
  }
  
<span class="line-modified">! jint dnd_target_get_supported_actions(JNIEnv *env)</span>
<span class="line-removed">- {</span>
      if (check_state_in_drag(env)) {
          return 0;
      }
<span class="line-modified">!     return translate_gdk_action_to_glass(gdk_drag_context_get_actions(enter_ctx.ctx));</span>
  }
  
<span class="line-modified">! static void wait_for_selection_data_hook(GdkEvent * event, void * data)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     selection_data_ctx *ctx = (selection_data_ctx*)data;</span>
<span class="line-removed">-     GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);</span>
<span class="line-removed">-     if (event-&gt;type == GDK_SELECTION_NOTIFY &amp;&amp;</span>
<span class="line-removed">-             event-&gt;selection.window == dest) {</span>
<span class="line-removed">-         if (event-&gt;selection.property) { // if 0, that we received negative response</span>
<span class="line-removed">-             ctx-&gt;length = gdk_selection_property_get(dest, &amp;(ctx-&gt;data), &amp;(ctx-&gt;type), &amp;(ctx-&gt;format));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ctx-&gt;received = TRUE;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     GevlHookRegistration hookReg;</span>
  
<span class="line-modified">!     memset(selection_ctx, 0, sizeof(selection_data_ctx));</span>
  
<span class="line-modified">!     gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx), gdk_drag_get_selection(enter_ctx.ctx), target,</span>
<span class="line-modified">!                           GDK_CURRENT_TIME);</span>
  
<span class="line-modified">!     hookReg =</span>
<span class="line-removed">-             glass_evloop_hook_add(</span>
<span class="line-removed">-                     (GevlHookFunction) wait_for_selection_data_hook,</span>
<span class="line-removed">-                     selection_ctx);</span>
<span class="line-removed">-     if (HANDLE_MEM_ALLOC_ERROR(env, hookReg,</span>
<span class="line-removed">-                                &quot;Failed to allocate event hook&quot;)) {</span>
<span class="line-removed">-         return TRUE;</span>
      }
  
<span class="line-modified">!     do {</span>
<span class="line-removed">-         gtk_main_iteration();</span>
<span class="line-removed">-     } while (!(selection_ctx-&gt;received));</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     glass_evloop_hook_remove(hookReg);</span>
<span class="line-removed">-     return selection_ctx-&gt;data != NULL;</span>
  }
  
<span class="line-modified">! static jobject dnd_target_get_string(JNIEnv *env)</span>
<span class="line-removed">- {</span>
      jobject result = NULL;
<span class="line-modified">!     selection_data_ctx ctx;</span>
  
<span class="line-modified">!     if (dnd_target_receive_data(env, TARGET_UTF8_STRING_ATOM, &amp;ctx)) {</span>
<span class="line-modified">!         result = env-&gt;NewStringUTF((char *)ctx.data);</span>
<span class="line-modified">!         EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!         g_free(ctx.data);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_MIME_TEXT_PLAIN_ATOM, &amp;ctx)) {</span>
<span class="line-removed">-         result = env-&gt;NewStringUTF((char *)ctx.data);</span>
<span class="line-removed">-         EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-         g_free(ctx.data);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // TODO find out how to convert from compound text</span>
<span class="line-removed">-     // if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_COMPOUND_TEXT_ATOM, &amp;ctx)) {</span>
<span class="line-removed">-     // }</span>
<span class="line-removed">-     if (!result &amp;&amp; dnd_target_receive_data(env, TARGET_STRING_ATOM, &amp;ctx)) {</span>
<span class="line-removed">-         gchar *str;</span>
<span class="line-removed">-         str = g_convert( (gchar *)ctx.data, -1, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, NULL, NULL, NULL);</span>
<span class="line-removed">-         if (str != NULL) {</span>
<span class="line-removed">-             result = env-&gt;NewStringUTF(str);</span>
<span class="line-removed">-             EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-             g_free(str);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         g_free(ctx.data);</span>
      }
      return result;
  }
  
<span class="line-modified">! static jobject dnd_target_get_list(JNIEnv *env, gboolean files)</span>
<span class="line-removed">- {</span>
      jobject result = NULL;
<span class="line-removed">-     selection_data_ctx ctx;</span>
  
<span class="line-modified">!     if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &amp;ctx)) {</span>
<span class="line-modified">!         result = uris_to_java(env, g_uri_list_extract_uris((gchar *)ctx.data), files);</span>
<span class="line-removed">-         g_free(ctx.data);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return result;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static jobject dnd_target_get_image(JNIEnv *env)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     GdkPixbuf *buf;</span>
<span class="line-removed">-     GInputStream *stream;</span>
<span class="line-removed">-     jobject result = NULL;</span>
<span class="line-removed">-     GdkAtom targets[] = {</span>
<span class="line-removed">-         TARGET_MIME_PNG_ATOM,</span>
<span class="line-removed">-         TARGET_MIME_JPEG_ATOM,</span>
<span class="line-removed">-         TARGET_MIME_TIFF_ATOM,</span>
<span class="line-removed">-         TARGET_MIME_BMP_ATOM,</span>
<span class="line-removed">-         0};</span>
<span class="line-removed">-     GdkAtom *cur_target = targets;</span>
<span class="line-removed">-     selection_data_ctx ctx;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while(*cur_target != 0 &amp;&amp; result == NULL) {</span>
<span class="line-removed">-         if (dnd_target_receive_data(env, *cur_target, &amp;ctx)) {</span>
<span class="line-removed">-             stream = g_memory_input_stream_new_from_data(ctx.data, ctx.length * (ctx.format / 8),</span>
<span class="line-removed">-                     (GDestroyNotify)g_free);</span>
<span class="line-removed">-             buf = gdk_pixbuf_new_from_stream(stream, NULL, NULL);</span>
<span class="line-removed">-             if (buf) {</span>
<span class="line-removed">-                 int w;</span>
<span class="line-removed">-                 int h;</span>
<span class="line-removed">-                 int stride;</span>
<span class="line-removed">-                 guchar *data;</span>
<span class="line-removed">-                 jbyteArray data_array;</span>
<span class="line-removed">-                 jobject buffer;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (!gdk_pixbuf_get_has_alpha(buf)) {</span>
<span class="line-removed">-                     GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);</span>
<span class="line-removed">-                     g_object_unref(buf);</span>
<span class="line-removed">-                     buf = tmp_buf;</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 w = gdk_pixbuf_get_width(buf);</span>
<span class="line-modified">!                 h = gdk_pixbuf_get_height(buf);</span>
<span class="line-modified">!                 stride = gdk_pixbuf_get_rowstride(buf);</span>
<span class="line-modified">!                 data = gdk_pixbuf_get_pixels(buf);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 //Actually, we are converting RGBA to BGRA, but that&#39;s the same operation</span>
<span class="line-removed">-                 data = (guchar*) convert_BGRA_to_RGBA((int*) data, stride, h);</span>
<span class="line-removed">-                 data_array = env-&gt;NewByteArray(stride * h);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                 env-&gt;SetByteArrayRegion(data_array, 0, stride*h, (jbyte*) data);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 buffer = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">-                 result = env-&gt;NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);</span>
<span class="line-removed">-                 EXCEPTION_OCCURED(env);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 g_object_unref(buf);</span>
<span class="line-removed">-                 g_free(data); // data from convert_BGRA_to_RGBA</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             g_object_unref(stream);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ++cur_target;</span>
      }
      return result;
  }
  
<span class="line-modified">! static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     selection_data_ctx ctx;</span>
      jobject result = NULL;
<span class="line-modified">!     if (dnd_target_receive_data(env, target, &amp;ctx)) {</span>
<span class="line-modified">!         if (string_data) {</span>
<span class="line-modified">!              result = env-&gt;NewStringUTF((char *)ctx.data);</span>
<span class="line-modified">!              EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             jsize length = ctx.length * (ctx.format / 8);</span>
<span class="line-modified">!             jbyteArray array = env-&gt;NewByteArray(length);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             env-&gt;SetByteArrayRegion(array, 0, length, (const jbyte*)ctx.data);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             result = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!         }</span>
      }
<span class="line-modified">!     g_free(ctx.data);</span>
      return result;
  }
  
<span class="line-modified">! jobject dnd_target_get_data(JNIEnv *env, jstring mime)</span>
<span class="line-modified">! {</span>
      if (check_state_in_drag(env)) {
          return NULL;
      }
<span class="line-removed">-     const char *cmime = env-&gt;GetStringUTFChars(mime, NULL);</span>
<span class="line-removed">-     jobject ret = NULL;</span>
  
<span class="line-modified">!     init_target_atoms();</span>
  
      if (g_strcmp0(cmime, &quot;text/plain&quot;) == 0) {
          ret = dnd_target_get_string(env);
      } else if (g_strcmp0(cmime, &quot;text/uri-list&quot;) == 0) {
          ret = dnd_target_get_list(env, FALSE);
      } else if (g_str_has_prefix(cmime, &quot;text/&quot;)) {
          ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);
      } else if (g_strcmp0(cmime, &quot;application/x-java-file-list&quot;) == 0) {
          ret = dnd_target_get_list(env, TRUE);
<span class="line-modified">!     } else if (g_strcmp0(cmime, &quot;application/x-java-rawimage&quot;) == 0 ) {</span>
          ret = dnd_target_get_image(env);
      } else {
          ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);
      }
      LOG_EXCEPTION(env)
      env-&gt;ReleaseStringUTFChars(mime, cmime);
  
      return ret;
  }
  
  /************************* SOURCE *********************************************/
  
  static jint dnd_performed_action;
  
<span class="line-modified">! const char * const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;</span>
  
<span class="line-modified">! static void dnd_set_performed_action(jint performed_action)</span>
<span class="line-removed">- {</span>
      dnd_performed_action = performed_action;
  }
  
<span class="line-modified">! static jint dnd_get_performed_action()</span>
<span class="line-removed">- {</span>
      return dnd_performed_action;
  }
  
<span class="line-modified">! static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer)</span>
<span class="line-removed">- {</span>
      if (pixels != NULL) {
          g_free(pixels);
      }
  }
  
<span class="line-modified">! static jobject dnd_source_get_data(GtkWidget *widget, const char *key)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     jobject data = (jobject)g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);</span>
      jstring string = mainEnv-&gt;NewStringUTF(key);
      EXCEPTION_OCCURED(mainEnv);
      jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);
  
      return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;
  }
  
<span class="line-modified">! static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags)</span>
<span class="line-removed">- {</span>
      const char *gstring = env-&gt;GetStringUTFChars(string, NULL);
  
      if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_UTF8_STRING_ATOM, flags, 0);</span>
<span class="line-removed">-         gtk_target_list_add(*list, TARGET_MIME_TEXT_PLAIN_ATOM, flags, 0);</span>
<span class="line-removed">-         gtk_target_list_add(*list, TARGET_STRING_ATOM, flags, 0);</span>
<span class="line-removed">-         //gtk_target_list_add(*list, TARGET_COMPOUND_TEXT_ATOM, flags, ??);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_MIME_PNG_ATOM, flags, 0);</span>
<span class="line-removed">-         gtk_target_list_add(*list, TARGET_MIME_JPEG_ATOM, flags, 0);</span>
<span class="line-removed">-         gtk_target_list_add(*list, TARGET_MIME_TIFF_ATOM, flags, 0);</span>
<span class="line-removed">-         gtk_target_list_add(*list, TARGET_MIME_BMP_ATOM, flags, 0);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add(*list, TARGET_MIME_URI_LIST_ATOM, flags, 0);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-drag-image&quot;) == 0
<span class="line-modified">!         || g_strcmp0(gstring, &quot;application/x-java-drag-image-offset&quot;) == 0) {</span>
          // do nothing - those are DragView information
      } else {
          GdkAtom atom = gdk_atom_intern(gstring, FALSE);
<span class="line-modified">!         gtk_target_list_add(*list, atom, flags, 0);</span>
      }
  
      env-&gt;ReleaseStringUTFChars(string, gstring);
  }
  
<span class="line-modified">! static GtkTargetList* data_to_gtk_target_list(JNIEnv *env, jobject data)</span>
<span class="line-removed">- {</span>
      guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;
  
      jobject keys;
      jobject keysIterator;
      jstring next;
  
<span class="line-modified">!     GtkTargetList *tlist = gtk_target_list_new (NULL, 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     init_target_atoms();</span>
  
      gint added_count = 0;
  
      keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);
      JNI_EXCEPTION_TO_CPP(env)
      keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);
      JNI_EXCEPTION_TO_CPP(env)
      while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {
<span class="line-modified">!         next = (jstring)env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);</span>
          JNI_EXCEPTION_TO_CPP(env)
          add_gtk_target_from_jstring(env, &amp;tlist, next, flags);
      }
  
      return tlist;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
<span class="line-removed">- {</span>
      gboolean is_data_set;
  
<span class="line-modified">!     jstring string = (jstring)dnd_source_get_data(widget, &quot;text/plain&quot;);</span>
      if (!string) {
          return FALSE;
      }
  
      const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
<span class="line-modified">!     if (cstring) {</span>
<span class="line-modified">!         if (atom == TARGET_MIME_TEXT_PLAIN_ATOM) {</span>
<span class="line-removed">-             gchar *res_str = g_convert((gchar *) cstring, -1, &quot;ISO-8859-1&quot;, &quot;UTF-8&quot;, NULL, NULL, NULL);</span>
<span class="line-removed">-             if (res_str) {</span>
<span class="line-removed">-                 is_data_set = gtk_selection_data_set_text(data, res_str, strlen(res_str));</span>
<span class="line-removed">-                 g_free(res_str);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             gint size = strlen(cstring);</span>
<span class="line-removed">-             is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      mainEnv-&gt;ReleaseStringUTFChars(string, cstring);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
<span class="line-removed">- {</span>
      jobject pixels = dnd_source_get_data(widget, &quot;application/x-java-rawimage&quot;);
      if (!pixels) {
          return FALSE;
      }
  
      gchar *buffer;
      gsize size;
<span class="line-modified">!     const char * type;</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_data_set;
  
      mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
  
<span class="line-new-header">--- 36,506 ---</span>
  #include &lt;gtk/gtk.h&gt;
  #include &lt;gdk/gdkx.h&gt;
  #include &lt;gdk/gdkkeysyms.h&gt;
  
  /************************* COMMON *********************************************/
<span class="line-modified">! static jint translate_gdk_action_to_glass(GdkDragAction action) {</span>
      jint result = 0;
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_COPY) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;</span>
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_MOVE) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;</span>
<span class="line-modified">!     result |= (action &amp; GDK_ACTION_LINK) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;</span>
      return result;
  }
  
<span class="line-modified">! static GdkDragAction translate_glass_action_to_gdk(jint action) {</span>
      int result = 0;
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY) ? GDK_ACTION_COPY : 0;</span>
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE) ? GDK_ACTION_MOVE : 0;</span>
<span class="line-modified">!     result |= (action &amp; com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE) ? GDK_ACTION_LINK : 0;</span>
      return static_cast&lt;GdkDragAction&gt;(result);
  }
  
<span class="line-modified">! static void clear_global_ref(gpointer data) {</span>
<span class="line-modified">!     mainEnv-&gt;DeleteGlobalRef((jobject) data);</span>
  }
  
  static void dnd_set_performed_action(jint performed_action);
<span class="line-added">+ </span>
  static jint dnd_get_performed_action();
  
<span class="line-modified">! enum {</span>
<span class="line-modified">!     TARGET_TEXT,</span>
<span class="line-modified">!     TARGET_IMAGE,</span>
<span class="line-modified">!     TARGET_URI,</span>
<span class="line-modified">!     TARGET_RAW</span>
  };
  
<span class="line-modified">! /************************* TARGET *********************************************/</span>
  
  static struct {
      GdkDragContext *ctx;
<span class="line-added">+     GtkSelectionData *data;</span>
      gboolean just_entered;
      jobjectArray mimes;
<span class="line-modified">! } target_ctx = {NULL, NULL, FALSE, NULL};</span>
  
  gboolean is_dnd_owner = FALSE;
  GtkWidget *drag_widget = NULL;
  
  gboolean is_in_drag() {
      return drag_widget != NULL;
  }
  
<span class="line-modified">! static void reset_target_ctx() {</span>
<span class="line-modified">!     if (target_ctx.mimes != NULL) {</span>
<span class="line-modified">!         mainEnv-&gt;DeleteGlobalRef(target_ctx.mimes);</span>
      }
  
<span class="line-modified">!     memset(&amp;target_ctx, 0, sizeof(target_ctx));</span>
  }
  
<span class="line-modified">! static gboolean dnd_drag_motion_callback(GtkWidget *widget,</span>
<span class="line-modified">!                                          GdkDragContext *context,</span>
<span class="line-modified">!                                          gint x,</span>
<span class="line-modified">!                                          gint y,</span>
<span class="line-modified">!                                          guint time,</span>
<span class="line-modified">!                                          gpointer user_data) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WindowContext *ctx = (WindowContext *) user_data;</span>
  
<span class="line-modified">!     if (target_ctx.ctx == NULL || (target_ctx.ctx != context &amp;&amp; !target_ctx.just_entered)) {</span>
<span class="line-modified">!         reset_target_ctx();</span>
<span class="line-modified">!         is_dnd_owner = is_in_drag();</span>
<span class="line-modified">!         target_ctx.ctx = context;</span>
<span class="line-modified">!         target_ctx.just_entered = TRUE;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     gint x_abs, y_abs;</span>
<span class="line-added">+     gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &amp;x_abs, &amp;y_abs);</span>
<span class="line-added">+ </span>
<span class="line-added">+     jmethodID method = target_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GdkDragAction suggested = gdk_drag_context_get_suggested_action(context);</span>
      GdkDragAction result = translate_glass_action_to_gdk(mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), method,
<span class="line-modified">!                                                                                 (jint) x, (jint) y,</span>
<span class="line-modified">!                                                                                 (jint) x_abs, (jint) y_abs,</span>
<span class="line-modified">!                                                                                 translate_gdk_action_to_glass(</span>
<span class="line-modified">!                                                                                         suggested)));</span>
<span class="line-added">+     CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)</span>
  
<span class="line-modified">!     if (target_ctx.just_entered) {</span>
<span class="line-modified">!         target_ctx.just_entered = FALSE;</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     gdk_drag_status(context, result, GDK_CURRENT_TIME);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return (gboolean) result;</span>
  }
  
<span class="line-modified">! static gboolean dnd_drag_drop_callback(GtkWidget *widget,</span>
<span class="line-modified">!                                        GdkDragContext *context,</span>
<span class="line-modified">!                                        gint x,</span>
<span class="line-added">+                                        gint y,</span>
<span class="line-added">+                                        guint time,</span>
<span class="line-added">+                                        gpointer user_data) {</span>
<span class="line-added">+     if (target_ctx.ctx == NULL || target_ctx.just_entered) {</span>
<span class="line-added">+         return FALSE; // Do not process drop events if no enter event and subsequent motion event were received</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     GdkAtom target = gtk_drag_dest_find_target(widget, context, NULL);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (target == GDK_NONE) {</span>
<span class="line-added">+         // used for RAW</span>
<span class="line-added">+         target = gdk_atom_intern_static_string(&quot;&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     gtk_drag_get_data(widget, context, target, GDK_CURRENT_TIME);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return TRUE;</span>
  }
  
<span class="line-modified">! static void dnd_on_drag_data_received_callback(GtkWidget *widget,</span>
<span class="line-modified">!                                                GdkDragContext *context,</span>
<span class="line-modified">!                                                gint x,</span>
<span class="line-modified">!                                                gint y,</span>
<span class="line-modified">!                                                GtkSelectionData *data,</span>
<span class="line-modified">!                                                guint info,</span>
<span class="line-added">+                                                guint time,</span>
<span class="line-added">+                                                gpointer user_data) {</span>
<span class="line-added">+     WindowContext *ctx = (WindowContext *) user_data;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (gtk_selection_data_get_length(data) == 0) {</span>
<span class="line-added">+         gtk_drag_finish(context, FALSE, FALSE, GDK_CURRENT_TIME);</span>
<span class="line-added">+         reset_target_ctx();</span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-added">+     gint x_abs, y_abs;</span>
<span class="line-added">+     gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &amp;x_abs, &amp;y_abs);</span>
<span class="line-added">+     GdkDragAction selected = gdk_drag_context_get_selected_action(context);</span>
<span class="line-added">+     target_ctx.data = data;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Delay the notify for when we have the data</span>
      mainEnv-&gt;CallIntMethod(ctx-&gt;get_jview(), jViewNotifyDragDrop,
<span class="line-modified">!                            (jint) x, (jint) y,</span>
<span class="line-modified">!                            (jint) x_abs, (jint) y_abs,</span>
<span class="line-modified">!                            translate_gdk_action_to_glass(selected));</span>
      LOG_EXCEPTION(mainEnv)
  
<span class="line-modified">!     gtk_drag_finish(context, selected, selected == GDK_ACTION_MOVE, GDK_CURRENT_TIME);</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void dnd_drag_leave_callback(WindowContext *ctx) {</span>
<span class="line-added">+     mainEnv-&gt;CallVoidMethod(ctx-&gt;get_jview(), jViewNotifyDragLeave, NULL);</span>
<span class="line-added">+     CHECK_JNI_EXCEPTION(mainEnv)</span>
<span class="line-added">+ </span>
<span class="line-added">+     reset_target_ctx();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void glass_dnd_attach_context(WindowContext *ctx) {</span>
<span class="line-added">+     gtk_drag_dest_set(ctx-&gt;get_gtk_widget(), (GtkDestDefaults) 0, NULL, 0,</span>
<span class="line-added">+                       (GdkDragAction)(GDK_ACTION_COPY | GDK_ACTION_MOVE | GDK_ACTION_LINK));</span>
<span class="line-added">+ </span>
<span class="line-added">+     GtkTargetList *target_list = gtk_target_list_new(NULL, 0);</span>
<span class="line-added">+     gtk_target_list_add_image_targets(target_list, TARGET_IMAGE, TRUE);</span>
<span class="line-added">+     gtk_target_list_add_uri_targets(target_list, TARGET_URI);</span>
<span class="line-added">+     gtk_target_list_add_text_targets(target_list, TARGET_TEXT);</span>
<span class="line-added">+     gtk_target_list_add(target_list, gdk_atom_intern_static_string(&quot;&quot;), 0, TARGET_RAW);</span>
<span class="line-added">+ </span>
<span class="line-added">+     gtk_drag_dest_set_target_list(ctx-&gt;get_gtk_widget(), target_list);</span>
<span class="line-added">+ </span>
<span class="line-added">+     g_signal_connect(ctx-&gt;get_gtk_widget(), &quot;drag-motion&quot;, G_CALLBACK(dnd_drag_motion_callback), ctx);</span>
<span class="line-added">+     g_signal_connect(ctx-&gt;get_gtk_widget(), &quot;drag-drop&quot;, G_CALLBACK(dnd_drag_drop_callback), ctx);</span>
<span class="line-added">+     g_signal_connect(ctx-&gt;get_gtk_widget(), &quot;drag-data-received&quot;, G_CALLBACK(dnd_on_drag_data_received_callback), ctx);</span>
  }
  
<span class="line-modified">! static gboolean check_state_in_drag(JNIEnv *env) {</span>
<span class="line-modified">!     if (!target_ctx.ctx) {</span>
          jclass jc = env-&gt;FindClass(&quot;java/lang/IllegalStateException&quot;);
          if (!env-&gt;ExceptionCheck()) {
              env-&gt;ThrowNew(jc,
<span class="line-modified">!                           &quot;Cannot get supported actions. Drag pointer haven&#39;t entered the application window&quot;);</span>
          }
          return TRUE;
      }
      return FALSE;
  }
  
<span class="line-modified">! static GdkAtom *get_target_ctx_target_atoms(gint *size) {</span>
<span class="line-modified">!     GList *targets = gdk_drag_context_list_targets(target_ctx.ctx);</span>
<span class="line-modified">!     gint s = (gint) g_list_length(targets);</span>
<span class="line-modified">!     GdkAtom *atoms = (GdkAtom *) g_try_malloc0(sizeof(GdkAtom) * s);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     int i = 0;</span>
<span class="line-modified">!     for (; targets != NULL; targets = targets-&gt;next) {</span>
<span class="line-modified">!         atoms[i++] = (GdkAtom) targets-&gt;data;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     *size = s;</span>
<span class="line-added">+ </span>
<span class="line-added">+     g_list_free(targets);</span>
<span class="line-added">+     return atoms;</span>
  }
  
<span class="line-modified">! jobjectArray dnd_target_get_mimes(JNIEnv *env) {</span>
      if (check_state_in_drag(env)) {
          return NULL;
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (!target_ctx.mimes) {</span>
          jobject set = env-&gt;NewObject(jHashSetCls, jHashSetInit, NULL);
          EXCEPTION_OCCURED(env);
  
<span class="line-modified">!         gboolean was_set = FALSE;</span>
<span class="line-modified">!         gint size;</span>
<span class="line-modified">!         GdkAtom *targets = get_target_ctx_target_atoms(&amp;size);</span>
  
<span class="line-modified">!         if (gtk_targets_include_image(targets, size, TRUE)) {</span>
<span class="line-modified">!             jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-rawimage&quot;);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             was_set = TRUE;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (gtk_targets_include_uri(targets, size)) {</span>
<span class="line-added">+             // it&#39;s a possibility</span>
<span class="line-added">+             jstring jStr = env-&gt;NewStringUTF(&quot;application/x-java-file-list&quot;);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
<span class="line-added">+             env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
  
<span class="line-modified">!             jstring jStr2 = env-&gt;NewStringUTF(&quot;text/uri-list&quot;);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             env-&gt;CallBooleanMethod(set, jSetAdd, jStr2, NULL);</span>
<span class="line-modified">!             EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!             was_set = TRUE;</span>
<span class="line-modified">!         } else if (gtk_targets_include_text(targets, size)) {</span>
<span class="line-added">+             jstring jStr = env-&gt;NewStringUTF(&quot;text/plain&quot;);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
<span class="line-added">+             env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
<span class="line-added">+             was_set = TRUE;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         g_free(targets);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (!was_set) {</span>
<span class="line-modified">!             GdkAtom target = gtk_selection_data_get_target(target_ctx.data);</span>
<span class="line-modified">!             gchar *name = gdk_atom_name(target);</span>
  
<span class="line-added">+             jstring jStr = env-&gt;NewStringUTF(name);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
<span class="line-added">+             env-&gt;CallBooleanMethod(set, jSetAdd, jStr, NULL);</span>
<span class="line-added">+             EXCEPTION_OCCURED(env);</span>
              g_free(name);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         target_ctx.mimes = env-&gt;NewObjectArray(env-&gt;CallIntMethod(set, jSetSize, NULL),</span>
<span class="line-added">+                                                jStringCls, NULL);</span>
          EXCEPTION_OCCURED(env);
<span class="line-modified">!         target_ctx.mimes = (jobjectArray) env-&gt;CallObjectMethod(set, jSetToArray, target_ctx.mimes, NULL);</span>
<span class="line-modified">!         target_ctx.mimes = (jobjectArray) env-&gt;NewGlobalRef(target_ctx.mimes);</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     return target_ctx.mimes;</span>
  }
  
<span class="line-modified">! jint dnd_target_get_supported_actions(JNIEnv *env) {</span>
      if (check_state_in_drag(env)) {
          return 0;
      }
<span class="line-modified">!     return translate_gdk_action_to_glass(gdk_drag_context_get_actions(target_ctx.ctx));</span>
  }
  
<span class="line-modified">! static jobject dnd_target_get_string(JNIEnv *env) {</span>
<span class="line-modified">!     jobject result = NULL;</span>
  
<span class="line-modified">!     GdkAtom atom = gtk_selection_data_get_data_type(target_ctx.data);</span>
<span class="line-added">+     guchar *data = gtk_selection_data_get_text(target_ctx.data);</span>
  
<span class="line-modified">!     if (data) {</span>
<span class="line-modified">!         result = env-&gt;NewStringUTF((char *) data);</span>
<span class="line-added">+         EXCEPTION_OCCURED(env);</span>
  
<span class="line-modified">!         g_free(data);</span>
      }
  
<span class="line-modified">!     return result;</span>
  }
  
<span class="line-modified">! static jobject dnd_target_get_list(JNIEnv *env, gboolean files) {</span>
      jobject result = NULL;
<span class="line-modified">!     GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);</span>
<span class="line-added">+     gchar **data = gtk_selection_data_get_uris(target_ctx.data);</span>
  
<span class="line-modified">!     if (data) {</span>
<span class="line-modified">!         result = uris_to_java(env, data, files);</span>
<span class="line-modified">!         // uris_to_java frees it</span>
<span class="line-modified">!         //g_strfreev(data);</span>
      }
<span class="line-added">+ </span>
      return result;
  }
  
<span class="line-modified">! static jobject dnd_target_get_image(JNIEnv *env) {</span>
      jobject result = NULL;
  
<span class="line-modified">!     GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);</span>
<span class="line-modified">!     GdkPixbuf *buf = gtk_selection_data_get_pixbuf(target_ctx.data);</span>
  
<span class="line-modified">!     if (buf == NULL) {</span>
<span class="line-modified">!         return NULL;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     gint length = gtk_selection_data_get_length(target_ctx.data);</span>
  
<span class="line-modified">!     if (!gdk_pixbuf_get_has_alpha(buf)) {</span>
<span class="line-modified">!         GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);</span>
<span class="line-modified">!         g_object_unref(buf);</span>
<span class="line-modified">!         buf = tmp_buf;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     gint w, h, stride;</span>
<span class="line-added">+     guchar *cdata;</span>
<span class="line-added">+     jbyteArray data_array;</span>
<span class="line-added">+     jobject buffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     w = gdk_pixbuf_get_width(buf);</span>
<span class="line-added">+     h = gdk_pixbuf_get_height(buf);</span>
<span class="line-added">+     stride = gdk_pixbuf_get_rowstride(buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+     cdata = gdk_pixbuf_get_pixels(buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+     //Actually, we are converting RGBA to BGRA, but that&#39;s the same operation</span>
<span class="line-added">+     cdata = (guchar *) convert_BGRA_to_RGBA((int *) cdata, stride, h);</span>
<span class="line-added">+     data_array = env-&gt;NewByteArray(stride * h);</span>
<span class="line-added">+     EXCEPTION_OCCURED(env);</span>
<span class="line-added">+     env-&gt;SetByteArrayRegion(data_array, 0, stride * h, (jbyte *) cdata);</span>
<span class="line-added">+     EXCEPTION_OCCURED(env);</span>
<span class="line-added">+ </span>
<span class="line-added">+     buffer = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);</span>
<span class="line-added">+     EXCEPTION_OCCURED(env);</span>
<span class="line-added">+     result = env-&gt;NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);</span>
<span class="line-added">+     EXCEPTION_OCCURED(env);</span>
<span class="line-added">+ </span>
<span class="line-added">+     g_object_unref(buf);</span>
<span class="line-added">+     g_free(cdata);</span>
<span class="line-added">+ </span>
      return result;
  }
  
<span class="line-modified">! static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data) {</span>
      jobject result = NULL;
<span class="line-modified">!     GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);</span>
<span class="line-modified">!     const guchar *data = gtk_selection_data_get_data(target_ctx.data);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (string_data) {</span>
<span class="line-modified">!         result = env-&gt;NewStringUTF((char *) data);</span>
<span class="line-modified">!         EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         gint length = gtk_selection_data_get_length(target_ctx.data);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         jbyteArray array = env-&gt;NewByteArray((jsize) length);</span>
<span class="line-modified">!         EXCEPTION_OCCURED(env);</span>
<span class="line-modified">!         env-&gt;SetByteArrayRegion(array, 0, length, (const jbyte *) data);</span>
<span class="line-modified">!         EXCEPTION_OCCURED(env);</span>
<span class="line-added">+         result = env-&gt;CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);</span>
<span class="line-added">+         EXCEPTION_OCCURED(env);</span>
      }
<span class="line-modified">! </span>
      return result;
  }
  
<span class="line-modified">! jobject dnd_target_get_data(JNIEnv *env, jstring mime) {</span>
<span class="line-modified">!     jobject ret = NULL;</span>
<span class="line-added">+ </span>
      if (check_state_in_drag(env)) {
          return NULL;
      }
  
<span class="line-modified">!     const char *cmime = env-&gt;GetStringUTFChars(mime, NULL);</span>
  
      if (g_strcmp0(cmime, &quot;text/plain&quot;) == 0) {
          ret = dnd_target_get_string(env);
      } else if (g_strcmp0(cmime, &quot;text/uri-list&quot;) == 0) {
          ret = dnd_target_get_list(env, FALSE);
      } else if (g_str_has_prefix(cmime, &quot;text/&quot;)) {
          ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);
      } else if (g_strcmp0(cmime, &quot;application/x-java-file-list&quot;) == 0) {
          ret = dnd_target_get_list(env, TRUE);
<span class="line-modified">!     } else if (g_strcmp0(cmime, &quot;application/x-java-rawimage&quot;) == 0) {</span>
          ret = dnd_target_get_image(env);
      } else {
          ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);
      }
<span class="line-added">+ </span>
      LOG_EXCEPTION(env)
      env-&gt;ReleaseStringUTFChars(mime, cmime);
  
      return ret;
  }
  
  /************************* SOURCE *********************************************/
  
  static jint dnd_performed_action;
  
<span class="line-modified">! const char *const SOURCE_DND_DATA = &quot;fx-dnd-data&quot;;</span>
  
<span class="line-modified">! static void dnd_set_performed_action(jint performed_action) {</span>
      dnd_performed_action = performed_action;
  }
  
<span class="line-modified">! static jint dnd_get_performed_action() {</span>
      return dnd_performed_action;
  }
  
<span class="line-modified">! static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {</span>
      if (pixels != NULL) {
          g_free(pixels);
      }
  }
  
<span class="line-modified">! static jobject dnd_source_get_data(GtkWidget *widget, const char *key) {</span>
<span class="line-modified">!     jobject data = (jobject) g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);</span>
      jstring string = mainEnv-&gt;NewStringUTF(key);
      EXCEPTION_OCCURED(mainEnv);
      jobject result = mainEnv-&gt;CallObjectMethod(data, jMapGet, string, NULL);
  
      return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;
  }
  
<span class="line-modified">! static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags) {</span>
      const char *gstring = env-&gt;GetStringUTFChars(string, NULL);
  
      if (g_strcmp0(gstring, &quot;text/plain&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add_text_targets(*list, TARGET_TEXT);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-rawimage&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add_image_targets(*list, TARGET_IMAGE, TRUE);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-file-list&quot;) == 0) {
<span class="line-modified">!         gtk_target_list_add_uri_targets(*list, TARGET_URI);</span>
      } else if (g_strcmp0(gstring, &quot;application/x-java-drag-image&quot;) == 0
<span class="line-modified">!                || g_strcmp0(gstring, &quot;application/x-java-drag-image-offset&quot;) == 0) {</span>
          // do nothing - those are DragView information
      } else {
          GdkAtom atom = gdk_atom_intern(gstring, FALSE);
<span class="line-modified">!         gtk_target_list_add(*list, atom, flags, TARGET_RAW);</span>
      }
  
      env-&gt;ReleaseStringUTFChars(string, gstring);
  }
  
<span class="line-modified">! static GtkTargetList *data_to_gtk_target_list(JNIEnv *env, jobject data) {</span>
      guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;
  
      jobject keys;
      jobject keysIterator;
      jstring next;
  
<span class="line-modified">!     GtkTargetList *tlist = gtk_target_list_new(NULL, 0);</span>
  
      gint added_count = 0;
  
      keys = env-&gt;CallObjectMethod(data, jMapKeySet, NULL);
      JNI_EXCEPTION_TO_CPP(env)
      keysIterator = env-&gt;CallObjectMethod(keys, jIterableIterator, NULL);
      JNI_EXCEPTION_TO_CPP(env)
      while (env-&gt;CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {
<span class="line-modified">!         next = (jstring) env-&gt;CallObjectMethod(keysIterator, jIteratorNext, NULL);</span>
          JNI_EXCEPTION_TO_CPP(env)
          add_gtk_target_from_jstring(env, &amp;tlist, next, flags);
      }
  
      return tlist;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {</span>
      gboolean is_data_set;
  
<span class="line-modified">!     jstring string = (jstring) dnd_source_get_data(widget, &quot;text/plain&quot;);</span>
      if (!string) {
          return FALSE;
      }
  
      const char *cstring = mainEnv-&gt;GetStringUTFChars(string, NULL);
<span class="line-modified">!     gint size = strlen(cstring);</span>
<span class="line-modified">!     is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);</span>
  
      mainEnv-&gt;ReleaseStringUTFChars(string, cstring);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {</span>
      jobject pixels = dnd_source_get_data(widget, &quot;application/x-java-rawimage&quot;);
      if (!pixels) {
<span class="line-added">+         g_warning(&quot;DND source failed to set image\n&quot;);</span>
          return FALSE;
      }
  
      gchar *buffer;
      gsize size;
<span class="line-modified">!     const char *type;</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_data_set;
  
      mainEnv-&gt;CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&amp;pixbuf));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,13 ***</span>
      g_object_unref(pixbuf);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     const gchar* url = NULL;</span>
      jstring jurl = NULL;
  
      jobjectArray files_array = NULL;
      gsize files_cnt = 0;
  
<span class="line-new-header">--- 546,12 ---</span>
      g_object_unref(pixbuf);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {</span>
<span class="line-modified">!     const gchar *url = NULL;</span>
      jstring jurl = NULL;
  
      jobjectArray files_array = NULL;
      gsize files_cnt = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 674,18 ***</span>
      if (!url &amp;&amp; !files_cnt) {
          return FALSE;
      }
  
      gboolean is_data_set;
<span class="line-modified">!     GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt</span>
  
      if (files_cnt &gt; 0) {
          for (gsize i = 0; i &lt; files_cnt; ++i) {
              jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
              EXCEPTION_OCCURED(mainEnv);
<span class="line-modified">!             const gchar* file = mainEnv-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-modified">!             gchar* uri = g_filename_to_uri(file, NULL, NULL);</span>
  
              g_string_append(res, uri);
              g_string_append(res, URI_LIST_LINE_BREAK);
  
              g_free(uri);
<span class="line-new-header">--- 566,18 ---</span>
      if (!url &amp;&amp; !files_cnt) {
          return FALSE;
      }
  
      gboolean is_data_set;
<span class="line-modified">!     GString *res = g_string_new(NULL); //http://www.ietf.org/rfc/rfc2483.txt</span>
  
      if (files_cnt &gt; 0) {
          for (gsize i = 0; i &lt; files_cnt; ++i) {
              jstring string = (jstring) mainEnv-&gt;GetObjectArrayElement(files_array, i);
              EXCEPTION_OCCURED(mainEnv);
<span class="line-modified">!             const gchar *file = mainEnv-&gt;GetStringUTFChars(string, NULL);</span>
<span class="line-modified">!             gchar *uri = g_filename_to_uri(file, NULL, NULL);</span>
  
              g_string_append(res, uri);
              g_string_append(res, URI_LIST_LINE_BREAK);
  
              g_free(uri);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,26 ***</span>
      g_free(uri[0]);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom)</span>
<span class="line-removed">- {</span>
      gchar *target_name = gdk_atom_name(atom);
      jobject data = dnd_source_get_data(widget, target_name);
      gboolean is_data_set = FALSE;
      if (data) {
          if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
<span class="line-modified">!             const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring)data, NULL);</span>
              if (cstring) {
                  is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));
<span class="line-modified">!                 mainEnv-&gt;ReleaseStringUTFChars((jstring)data, cstring);</span>
              }
          } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
<span class="line-modified">!             jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);</span>
              if (!EXCEPTION_OCCURED(mainEnv)) {
<span class="line-modified">!                 jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
                  if (raw) {
                      jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
                      gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);
                      mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
                      is_data_set = TRUE;
<span class="line-new-header">--- 599,25 ---</span>
      g_free(uri[0]);
  
      return is_data_set;
  }
  
<span class="line-modified">! static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom) {</span>
      gchar *target_name = gdk_atom_name(atom);
      jobject data = dnd_source_get_data(widget, target_name);
      gboolean is_data_set = FALSE;
      if (data) {
          if (mainEnv-&gt;IsInstanceOf(data, jStringCls)) {
<span class="line-modified">!             const char *cstring = mainEnv-&gt;GetStringUTFChars((jstring) data, NULL);</span>
              if (cstring) {
                  is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));
<span class="line-modified">!                 mainEnv-&gt;ReleaseStringUTFChars((jstring) data, cstring);</span>
              }
          } else if (mainEnv-&gt;IsInstanceOf(data, jByteBufferCls)) {
<span class="line-modified">!             jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(data, jByteBufferArray);</span>
              if (!EXCEPTION_OCCURED(mainEnv)) {
<span class="line-modified">!                 jbyte *raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
                  if (raw) {
                      jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
                      gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);
                      mainEnv-&gt;ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
                      is_data_set = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,24 ***</span>
      return FALSE;
  }
  
  static void dnd_end_callback(GtkWidget *widget,
                               GdkDragContext *context,
<span class="line-modified">!                              gpointer user_data)</span>
<span class="line-removed">- {</span>
      if (drag_widget) {
          GdkDragAction action = gdk_drag_context_get_selected_action(context);
          dnd_set_performed_action(translate_gdk_action_to_glass(action));
      }
      gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
  }
  
  static gboolean dnd_drag_failed_callback(GtkWidget *widget,
<span class="line-modified">!                                      GdkDragContext *context,</span>
<span class="line-modified">!                                      GtkDragResult result,</span>
<span class="line-modified">!                                      gpointer user_data)</span>
<span class="line-removed">- {</span>
      dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);
      gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
  
      return FALSE;
  }
<span class="line-new-header">--- 639,22 ---</span>
      return FALSE;
  }
  
  static void dnd_end_callback(GtkWidget *widget,
                               GdkDragContext *context,
<span class="line-modified">!                              gpointer user_data) {</span>
      if (drag_widget) {
          GdkDragAction action = gdk_drag_context_get_selected_action(context);
          dnd_set_performed_action(translate_gdk_action_to_glass(action));
      }
      gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
  }
  
  static gboolean dnd_drag_failed_callback(GtkWidget *widget,
<span class="line-modified">!                                          GdkDragContext *context,</span>
<span class="line-modified">!                                          GtkDragResult result,</span>
<span class="line-modified">!                                          gpointer user_data) {</span>
      dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);
      gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
  
      return FALSE;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 773,62 ***</span>
  static void dnd_data_get_callback(GtkWidget *widget,
                                    GdkDragContext *context,
                                    GtkSelectionData *data,
                                    guint info,
                                    guint time,
<span class="line-modified">!                                   gpointer user_data)</span>
<span class="line-removed">- {</span>
      GdkAtom atom = gtk_selection_data_get_target(data);
  
<span class="line-modified">!     if (target_is_text(atom)) {</span>
<span class="line-modified">!         dnd_source_set_string(widget, data, atom);</span>
<span class="line-modified">!     } else if (target_is_image(atom)) {</span>
<span class="line-modified">!         dnd_source_set_image(widget, data, atom);</span>
<span class="line-modified">!     } else if (target_is_uri(atom)) {</span>
<span class="line-modified">!         dnd_source_set_uri(widget, data, atom);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         dnd_source_set_raw(widget, data, atom);</span>
      }
  }
  
  static void dnd_drag_begin_callback(GtkWidget *widget,
                                      GdkDragContext *context,
<span class="line-modified">!                                     gpointer user_data)</span>
<span class="line-removed">- {</span>
      DragView::set_drag_view(widget, context);
  }
  
<span class="line-modified">! static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)</span>
<span class="line-removed">- {</span>
      if (supported == 0) {
          return; // No supported actions, do nothing
      }
  
      data = env-&gt;NewGlobalRef(data);
  
      GdkDragAction actions = translate_glass_action_to_gdk(supported);
  
      // this widget is used only to pass events and will
      // be destroyed on drag end
<span class="line-modified">!     drag_widget = gtk_window_new(GTK_WINDOW_POPUP);</span>
<span class="line-removed">-     gtk_window_resize(GTK_WINDOW(drag_widget), 1, 1);</span>
<span class="line-removed">-     gtk_window_move(GTK_WINDOW(drag_widget), -200, -200);</span>
      gtk_widget_show(drag_widget);
  
      g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);
  
      g_signal_connect(drag_widget, &quot;drag-begin&quot;,
<span class="line-modified">!         G_CALLBACK(dnd_drag_begin_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-failed&quot;,
<span class="line-modified">!         G_CALLBACK(dnd_drag_failed_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-data-get&quot;,
<span class="line-modified">!         G_CALLBACK(dnd_data_get_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-end&quot;,
<span class="line-modified">!         G_CALLBACK(dnd_end_callback), NULL);</span>
  
      GtkTargetList *tlist = data_to_gtk_target_list(env, data);
  
      GdkDragContext *context;
  
<span class="line-new-header">--- 662,61 ---</span>
  static void dnd_data_get_callback(GtkWidget *widget,
                                    GdkDragContext *context,
                                    GtkSelectionData *data,
                                    guint info,
                                    guint time,
<span class="line-modified">!                                   gpointer user_data) {</span>
      GdkAtom atom = gtk_selection_data_get_target(data);
  
<span class="line-modified">!     switch (info) {</span>
<span class="line-modified">!         case TARGET_TEXT:</span>
<span class="line-modified">!             dnd_source_set_string(widget, data, atom);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case TARGET_IMAGE:</span>
<span class="line-modified">!             dnd_source_set_image(widget, data, atom);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case TARGET_URI:</span>
<span class="line-added">+             dnd_source_set_uri(widget, data, atom);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             dnd_source_set_raw(widget, data, atom);</span>
      }
  }
  
  static void dnd_drag_begin_callback(GtkWidget *widget,
                                      GdkDragContext *context,
<span class="line-modified">!                                     gpointer user_data) {</span>
      DragView::set_drag_view(widget, context);
  }
  
<span class="line-modified">! static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported) {</span>
      if (supported == 0) {
          return; // No supported actions, do nothing
      }
  
      data = env-&gt;NewGlobalRef(data);
  
      GdkDragAction actions = translate_glass_action_to_gdk(supported);
  
      // this widget is used only to pass events and will
      // be destroyed on drag end
<span class="line-modified">!     drag_widget = gtk_invisible_new();</span>
      gtk_widget_show(drag_widget);
  
      g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);
  
      g_signal_connect(drag_widget, &quot;drag-begin&quot;,
<span class="line-modified">!                      G_CALLBACK(dnd_drag_begin_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-failed&quot;,
<span class="line-modified">!                      G_CALLBACK(dnd_drag_failed_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-data-get&quot;,
<span class="line-modified">!                      G_CALLBACK(dnd_data_get_callback), NULL);</span>
  
      g_signal_connect(drag_widget, &quot;drag-end&quot;,
<span class="line-modified">!                      G_CALLBACK(dnd_end_callback), NULL);</span>
  
      GtkTargetList *tlist = data_to_gtk_target_list(env, data);
  
      GdkDragContext *context;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,15 ***</span>
  #endif
  
      gtk_target_list_unref(tlist);
  }
  
<span class="line-modified">! jint execute_dnd(JNIEnv *env, jobject data, jint supported)</span>
<span class="line-removed">- {</span>
      try {
          dnd_source_push_data(env, data, supported);
<span class="line-modified">!     } catch (jni_exception&amp;) {</span>
          gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
          return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;
      }
  
      while (is_in_drag()) {
<span class="line-new-header">--- 732,14 ---</span>
  #endif
  
      gtk_target_list_unref(tlist);
  }
  
<span class="line-modified">! jint execute_dnd(JNIEnv *env, jobject data, jint supported) {</span>
      try {
          dnd_source_push_data(env, data, supported);
<span class="line-modified">!     } catch (jni_exception &amp;) {</span>
          gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
          return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;
      }
  
      while (is_in_drag()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 860,25 ***</span>
      }
  
      return dnd_get_performed_action();
  }
  
<span class="line-modified">!  /******************** DRAG VIEW ***************************/</span>
<span class="line-modified">!  DragView::View* DragView::view = NULL;</span>
  
<span class="line-modified">!  gboolean DragView::get_drag_image_offset(GtkWidget *widget, int* x, int* y)</span>
<span class="line-removed">-  {</span>
      gboolean offset_set = FALSE;
      jobject bb = dnd_source_get_data(widget, &quot;application/x-java-drag-image-offset&quot;);
      if (bb) {
<span class="line-modified">!         jbyteArray byteArray = (jbyteArray)mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);</span>
          if (!EXCEPTION_OCCURED(mainEnv)) {
<span class="line-modified">!             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              if ((size_t) nraw &gt;= sizeof(jint) * 2) {
<span class="line-modified">!                 jint* r = (jint*) raw;</span>
                  *x = BSWAP_32(r[0]);
                  *y = BSWAP_32(r[1]);
                  offset_set = TRUE;
              }
  
<span class="line-new-header">--- 747,24 ---</span>
      }
  
      return dnd_get_performed_action();
  }
  
<span class="line-modified">! /******************** DRAG VIEW ***************************/</span>
<span class="line-modified">! DragView::View *DragView::view = NULL;</span>
  
<span class="line-modified">! gboolean DragView::get_drag_image_offset(GtkWidget *widget, int *x, int *y) {</span>
      gboolean offset_set = FALSE;
      jobject bb = dnd_source_get_data(widget, &quot;application/x-java-drag-image-offset&quot;);
      if (bb) {
<span class="line-modified">!         jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(bb, jByteBufferArray);</span>
          if (!EXCEPTION_OCCURED(mainEnv)) {
<span class="line-modified">!             jbyte *raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              if ((size_t) nraw &gt;= sizeof(jint) * 2) {
<span class="line-modified">!                 jint *r = (jint *) raw;</span>
                  *x = BSWAP_32(r[0]);
                  *y = BSWAP_32(r[1]);
                  offset_set = TRUE;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 886,35 ***</span>
          }
      }
      return offset_set;
  }
  
<span class="line-modified">! GdkPixbuf* DragView::get_drag_image(GtkWidget *widget, gboolean* is_raw_image, gint* width, gint* height)</span>
<span class="line-removed">- {</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_raw = FALSE;
  
      jobject drag_image = dnd_source_get_data(widget, &quot;application/x-java-drag-image&quot;);
  
      if (drag_image) {
          jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
  
<span class="line-modified">!             jbyte* raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              int w = 0, h = 0;
              int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
              // in this byteArray: width and height
              if (nraw &gt; whsz) {
<span class="line-modified">!                 jint* int_raw = (jint*) raw;</span>
                  w = BSWAP_32(int_raw[0]);
                  h = BSWAP_32(int_raw[1]);
  
                  // We should have enough pixels for requested width and height
<span class="line-modified">!                 if ((nraw - whsz) / 4 - w * h &gt;= 0 ) {</span>
<span class="line-modified">!                     guchar* data = (guchar*) g_try_malloc0(nraw - whsz);</span>
                      if (data) {
                          memcpy(data, (raw + whsz), nraw - whsz);
                          pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
                                                            w, h, w * 4, pixbufDestroyNotifyFunc, NULL);
                      }
<span class="line-new-header">--- 772,34 ---</span>
          }
      }
      return offset_set;
  }
  
<span class="line-modified">! GdkPixbuf *DragView::get_drag_image(GtkWidget *widget, gboolean *is_raw_image, gint *width, gint *height) {</span>
      GdkPixbuf *pixbuf = NULL;
      gboolean is_raw = FALSE;
  
      jobject drag_image = dnd_source_get_data(widget, &quot;application/x-java-drag-image&quot;);
  
      if (drag_image) {
          jbyteArray byteArray = (jbyteArray) mainEnv-&gt;CallObjectMethod(drag_image, jByteBufferArray);
          if (!EXCEPTION_OCCURED(mainEnv)) {
  
<span class="line-modified">!             jbyte *raw = mainEnv-&gt;GetByteArrayElements(byteArray, NULL);</span>
              jsize nraw = mainEnv-&gt;GetArrayLength(byteArray);
  
              int w = 0, h = 0;
              int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
              // in this byteArray: width and height
              if (nraw &gt; whsz) {
<span class="line-modified">!                 jint *int_raw = (jint *) raw;</span>
                  w = BSWAP_32(int_raw[0]);
                  h = BSWAP_32(int_raw[1]);
  
                  // We should have enough pixels for requested width and height
<span class="line-modified">!                 if ((nraw - whsz) / 4 - w * h &gt;= 0) {</span>
<span class="line-modified">!                     guchar *data = (guchar *) g_try_malloc0(nraw - whsz);</span>
                      if (data) {
                          memcpy(data, (raw + whsz), nraw - whsz);
                          pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
                                                            w, h, w * 4, pixbufDestroyNotifyFunc, NULL);
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 939,12 ***</span>
  
      int w = gdk_pixbuf_get_width(pixbuf);
      int h = gdk_pixbuf_get_height(pixbuf);
  
      if (w &gt; DRAG_IMAGE_MAX_WIDTH || h &gt; DRAG_IMAGE_MAX_HEIGH) {
<span class="line-modified">!         double rw = DRAG_IMAGE_MAX_WIDTH / (double)w;</span>
<span class="line-modified">!         double rh =  DRAG_IMAGE_MAX_HEIGH / (double)h;</span>
          double r = MIN(rw, rh);
  
          int new_w = w * r;
          int new_h = h * r;
  
<span class="line-new-header">--- 824,12 ---</span>
  
      int w = gdk_pixbuf_get_width(pixbuf);
      int h = gdk_pixbuf_get_height(pixbuf);
  
      if (w &gt; DRAG_IMAGE_MAX_WIDTH || h &gt; DRAG_IMAGE_MAX_HEIGH) {
<span class="line-modified">!         double rw = DRAG_IMAGE_MAX_WIDTH / (double) w;</span>
<span class="line-modified">!         double rh = DRAG_IMAGE_MAX_HEIGH / (double) h;</span>
          double r = MIN(rw, rh);
  
          int new_w = w * r;
          int new_h = h * r;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,55 ***</span>
      *height = h;
  
      return pixbuf;
  }
  
<span class="line-modified">! void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context)</span>
<span class="line-removed">- {</span>
      gboolean is_raw_image = FALSE;
      gint w = 0, h = 0;
<span class="line-modified">!     GdkPixbuf* pixbuf = get_drag_image(widget, &amp;is_raw_image, &amp;w, &amp;h);</span>
  
      if (GDK_IS_PIXBUF(pixbuf)) {
          gint offset_x = w / 2;
          gint offset_y = h / 2;
  
          gboolean is_offset_set = get_drag_image_offset(widget, &amp;offset_x, &amp;offset_y);
  
          DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,
<span class="line-modified">!             is_offset_set, offset_x, offset_y);</span>
      }
  }
  
<span class="line-modified">! static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     (void)widget;</span>
<span class="line-removed">-     (void)previous_screen;</span>
  
<span class="line-modified">!     ((DragView::View*) view)-&gt;screen_changed();</span>
  }
  
<span class="line-modified">! static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     (void)widget;</span>
<span class="line-removed">-     (void)event;</span>
  
<span class="line-modified">!     ((DragView::View*) view)-&gt;expose();</span>
      return FALSE;
  }
  
<span class="line-modified">! DragView::View::View(GdkDragContext* _context, GdkPixbuf* _pixbuf, gint _width, gint _height,</span>
                       gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :
<span class="line-modified">!     context(_context),</span>
<span class="line-modified">!     pixbuf(_pixbuf),</span>
<span class="line-modified">!     width(_width),</span>
<span class="line-modified">!     height(_height),</span>
<span class="line-modified">!     is_raw_image(_is_raw_image),</span>
<span class="line-modified">!     is_offset_set(_is_offset_set),</span>
<span class="line-modified">!     offset_x(_offset_x),</span>
<span class="line-modified">!     offset_y(_offset_y)</span>
<span class="line-removed">- {</span>
  #ifdef GLASS_GTK3
      gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);
  #else
      widget = gtk_window_new(GTK_WINDOW_POPUP);
      gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
<span class="line-new-header">--- 849,51 ---</span>
      *height = h;
  
      return pixbuf;
  }
  
<span class="line-modified">! void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context) {</span>
      gboolean is_raw_image = FALSE;
      gint w = 0, h = 0;
<span class="line-modified">!     GdkPixbuf *pixbuf = get_drag_image(widget, &amp;is_raw_image, &amp;w, &amp;h);</span>
  
      if (GDK_IS_PIXBUF(pixbuf)) {
          gint offset_x = w / 2;
          gint offset_y = h / 2;
  
          gboolean is_offset_set = get_drag_image_offset(widget, &amp;offset_x, &amp;offset_y);
  
          DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,
<span class="line-modified">!                                             is_offset_set, offset_x, offset_y);</span>
      }
  }
  
<span class="line-modified">! static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {</span>
<span class="line-modified">!     (void) widget;</span>
<span class="line-modified">!     (void) previous_screen;</span>
  
<span class="line-modified">!     ((DragView::View *) view)-&gt;screen_changed();</span>
  }
  
<span class="line-modified">! static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {</span>
<span class="line-modified">!     (void) widget;</span>
<span class="line-modified">!     (void) event;</span>
  
<span class="line-modified">!     ((DragView::View *) view)-&gt;expose();</span>
      return FALSE;
  }
  
<span class="line-modified">! DragView::View::View(GdkDragContext *_context, GdkPixbuf *_pixbuf, gint _width, gint _height,</span>
                       gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :
<span class="line-modified">!         context(_context),</span>
<span class="line-modified">!         pixbuf(_pixbuf),</span>
<span class="line-modified">!         width(_width),</span>
<span class="line-modified">!         height(_height),</span>
<span class="line-modified">!         is_raw_image(_is_raw_image),</span>
<span class="line-modified">!         is_offset_set(_is_offset_set),</span>
<span class="line-modified">!         offset_x(_offset_x),</span>
<span class="line-modified">!         offset_y(_offset_y) {</span>
  #ifdef GLASS_GTK3
      gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);
  #else
      widget = gtk_window_new(GTK_WINDOW_POPUP);
      gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1031,12 ***</span>
      gtk_widget_show_all(widget);
      gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);
  #endif
  }
  
<span class="line-modified">! void DragView::View::screen_changed()</span>
<span class="line-removed">- {</span>
      GdkScreen *screen = gtk_widget_get_screen(widget);
  
      glass_configure_window_transparency(widget, true);
  
      if (!gdk_screen_is_composited(screen)) {
<span class="line-new-header">--- 912,11 ---</span>
      gtk_widget_show_all(widget);
      gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);
  #endif
  }
  
<span class="line-modified">! void DragView::View::screen_changed() {</span>
      GdkScreen *screen = gtk_widget_get_screen(widget);
  
      glass_configure_window_transparency(widget, true);
  
      if (!gdk_screen_is_composited(screen)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1045,21 ***</span>
              offset_y = 1;
          }
      }
  }
  
<span class="line-modified">! void DragView::View::expose()</span>
<span class="line-removed">- {</span>
      cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));
  
<span class="line-modified">!     cairo_surface_t* cairo_surface;</span>
  
<span class="line-modified">!     guchar* pixels = is_raw_image</span>
<span class="line-modified">!             ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),</span>
<span class="line-modified">!                                                 gdk_pixbuf_get_rowstride(pixbuf),</span>
<span class="line-modified">!                                                 height)</span>
<span class="line-modified">!             : gdk_pixbuf_get_pixels(pixbuf);</span>
  
      cairo_surface = cairo_image_surface_create_for_data(
              pixels,
              CAIRO_FORMAT_ARGB32,
              width, height, width * 4);
<span class="line-new-header">--- 925,20 ---</span>
              offset_y = 1;
          }
      }
  }
  
<span class="line-modified">! void DragView::View::expose() {</span>
      cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));
  
<span class="line-modified">!     cairo_surface_t *cairo_surface;</span>
  
<span class="line-modified">!     guchar *pixels = is_raw_image</span>
<span class="line-modified">!                      ? (guchar *) convert_BGRA_to_RGBA((const int *) gdk_pixbuf_get_pixels(pixbuf),</span>
<span class="line-modified">!                                                        gdk_pixbuf_get_rowstride(pixbuf),</span>
<span class="line-modified">!                                                        height)</span>
<span class="line-modified">!                      : gdk_pixbuf_get_pixels(pixbuf);</span>
  
      cairo_surface = cairo_image_surface_create_for_data(
              pixels,
              CAIRO_FORMAT_ARGB32,
              width, height, width * 4);
</pre>
<center><a href="GlassWindow.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="glass_general.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>