<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/CssStyleHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collections;
  29 import java.util.HashMap;
  30 import java.util.HashSet;
  31 import java.util.List;
  32 import java.util.Locale;
  33 import java.util.Map;
  34 import java.util.Map.Entry;
  35 import java.util.Set;
  36 
  37 import javafx.beans.property.ObjectProperty;
  38 import javafx.beans.property.SimpleObjectProperty;
  39 import javafx.beans.value.WritableValue;
  40 import com.sun.javafx.css.CascadingStyle;
  41 import javafx.css.CssMetaData;
  42 import javafx.css.CssParser;
  43 import javafx.css.FontCssMetaData;
  44 import javafx.css.ParsedValue;
  45 import javafx.css.PseudoClass;
  46 import javafx.css.Rule;
  47 import javafx.css.Selector;
  48 import javafx.css.Style;
  49 import javafx.css.StyleConverter;
  50 import javafx.css.StyleOrigin;
  51 import javafx.css.Styleable;
  52 import javafx.css.StyleableProperty;
  53 import javafx.css.Stylesheet;
  54 import javafx.scene.text.Font;
  55 import javafx.scene.text.FontPosture;
  56 import javafx.scene.text.FontWeight;
  57 
  58 import com.sun.javafx.css.CalculatedValue;
  59 import com.sun.javafx.css.ParsedValueImpl;
  60 import com.sun.javafx.css.PseudoClassState;
  61 import com.sun.javafx.css.StyleCache;
  62 import com.sun.javafx.css.StyleCacheEntry;
  63 import com.sun.javafx.css.StyleManager;
  64 import com.sun.javafx.css.StyleMap;
  65 import javafx.css.converter.FontConverter;
  66 import com.sun.javafx.util.Logging;
  67 import com.sun.javafx.util.Utils;
  68 
  69 import com.sun.javafx.logging.PlatformLogger;
  70 import com.sun.javafx.logging.PlatformLogger.Level;
  71 
  72 import static com.sun.javafx.css.CalculatedValue.*;
  73 
  74 /**
  75  * The StyleHelper is a helper class used for applying CSS information to Nodes.
  76  */
  77 final class CssStyleHelper {
  78 
  79     private static final PlatformLogger LOGGER = com.sun.javafx.util.Logging.getCSSLogger();
  80 
  81     private CssStyleHelper() {
  82         this.triggerStates = new PseudoClassState();
  83     }
  84 
  85     /**
  86      * Creates a new StyleHelper.
  87      */
  88     static CssStyleHelper createStyleHelper(final Node node) {
  89 
  90         // need to know how far we are to root in order to init arrays.
  91         // TODO: should we hang onto depth to avoid this nonsense later?
  92         // TODO: is there some other way of knowing how far from the root a node is?
  93         Styleable parent = node;
  94         int depth = 0;
  95         while(parent != null) {
  96             depth++;
  97             parent = parent.getStyleableParent();
  98         }
  99 
 100         // The List&lt;CacheEntry&gt; should only contain entries for those
 101         // pseudo-class states that have styles. The StyleHelper&#39;s
 102         // pseudoclassStateMask is a bitmask of those pseudoclasses that
 103         // appear in the node&#39;s StyleHelper&#39;s smap. This list of
 104         // pseudo-class masks is held by the StyleCacheKey. When a node is
 105         // styled, its pseudoclasses and the pseudoclasses of its parents
 106         // are gotten. By comparing the actual pseudo-class state to the
 107         // pseudo-class states that apply, a CacheEntry can be created or
 108         // fetched using only those pseudoclasses that matter.
 109         final PseudoClassState[] triggerStates = new PseudoClassState[depth];
 110 
 111         final StyleMap styleMap =
 112                 StyleManager.getInstance().findMatchingStyles(node, node.getSubScene(), triggerStates);
 113 
 114         //
 115         // reuse the existing styleHelper if possible.
 116         //
 117         if ( canReuseStyleHelper(node, styleMap) ) {
 118 
 119             //
 120             // RT-33080
 121             //
 122             // If we&#39;re reusing a style helper, clear the fontSizeCache in case either this node or some parent
 123             // node has changed font from a user calling setFont.
 124             //
 125             // It may be the case that the node&#39;s font has changed from a call to setFont, which will
 126             // trigger a REAPPLY. If the REAPPLY comes because of a change in font, then the fontSizeCache
 127             // needs to be invalidated (cleared) so that new values will be looked up for all transition states.
 128             //
 129             if (node.styleHelper.cacheContainer != null &amp;&amp; node.styleHelper.isUserSetFont(node)) {
 130                 node.styleHelper.cacheContainer.fontSizeCache.clear();
 131             }
 132             node.styleHelper.cacheContainer.forceSlowpath = true;
 133             node.styleHelper.triggerStates.addAll(triggerStates[0]);
<a name="2" id="anc2"></a><span class="line-modified"> 134 </span>
 135             updateParentTriggerStates(node, depth, triggerStates);
 136             return node.styleHelper;
 137 
 138         }
 139 
 140         if (styleMap == null || styleMap.isEmpty()) {
 141 
 142             boolean mightInherit = false;
 143 
 144             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 145 
 146             final int pMax = props != null ? props.size() : 0;
 147             for (int p=0; p&lt;pMax; p++) {
 148 
 149                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 150                 if (prop.isInherits()) {
 151                     mightInherit = true;
 152                     break;
 153                 }
 154             }
 155 
 156             if (mightInherit == false) {
 157 
 158                 // If this node had a style helper, then reset properties to their initial value
 159                 // since the node won&#39;t have a style helper after this call
 160                 if (node.styleHelper != null) {
 161                     node.styleHelper.resetToInitialValues(node);
 162                 }
 163 
 164                 //
 165                 // This node didn&#39;t have a StyleHelper before and it doesn&#39;t need one now since there are
 166                 // no styles in the StyleMap and no inherited styles.
 167                 return null;
 168             }
 169 
 170         }
 171 
 172         final CssStyleHelper helper = new CssStyleHelper();
 173         helper.triggerStates.addAll(triggerStates[0]);
 174 
 175         updateParentTriggerStates(node, depth, triggerStates);
 176 
 177         helper.cacheContainer = new CacheContainer(node, styleMap, depth);
 178 
 179         helper.firstStyleableAncestor = findFirstStyleableAncestor(node);
 180 
 181         // If this node had a style helper, then reset properties to their initial value
 182         // since the style map might now be different
 183         if (node.styleHelper != null) {
 184             node.styleHelper.resetToInitialValues(node);
 185         }
 186         return helper;
 187     }
 188 
 189     private static void updateParentTriggerStates(Styleable styleable, int depth, PseudoClassState[] triggerStates) {
 190         // make sure parent&#39;s transition states include the pseudo-classes
 191         // found when matching selectors
 192         Styleable parent = styleable.getStyleableParent();
 193         for(int n=1; n&lt;depth; n++) {
 194 
 195             // TODO: this means that a style like .menu-item:hover won&#39;t work. Need to separate CssStyleHelper tree from scene-graph tree
 196             if (parent instanceof Node == false) {
 197                 parent=parent.getStyleableParent();
 198                 continue;
 199             }
 200             Node parentNode = (Node)parent;
 201 
 202             final PseudoClassState triggerState = triggerStates[n];
 203 
 204             // if there is nothing in triggerState, then continue since there
 205             // isn&#39;t any pseudo-class state that might trigger a state change
 206             if (triggerState != null &amp;&amp; triggerState.size() &gt; 0) {
 207 
 208                 // Create a StyleHelper for the parent, if necessary.
 209                 // TODO : check why calling createStyleHelper(parentNode) does not work here?
 210                 if (parentNode.styleHelper == null) {
 211                     parentNode.styleHelper = new CssStyleHelper();
 212                     parentNode.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(parentNode) ;
 213                 }
 214                 parentNode.styleHelper.triggerStates.addAll(triggerState);
 215 
 216             }
 217 
 218             parent=parent.getStyleableParent();
 219         }
 220 
 221     }
 222     //
 223     // return true if the fontStyleableProperty&#39;s origin is USER
 224     //
 225     private boolean isUserSetFont(Styleable node) {
 226 
 227         if (node == null) return false; // should never happen, but just to be safe...
 228 
 229         CssMetaData&lt;Styleable, Font&gt; fontCssMetaData = cacheContainer != null ? cacheContainer.fontProp : null;
 230         if (fontCssMetaData != null) {
 231             StyleableProperty&lt;Font&gt; fontStyleableProperty = fontCssMetaData != null ? fontCssMetaData.getStyleableProperty(node) : null;
 232             if (fontStyleableProperty != null &amp;&amp; fontStyleableProperty.getStyleOrigin() == StyleOrigin.USER) return true;
 233         }
 234 
 235         Styleable styleableParent = firstStyleableAncestor;
 236         CssStyleHelper parentStyleHelper = getStyleHelper(firstStyleableAncestor);
 237 
 238         if (parentStyleHelper != null) {
 239             return parentStyleHelper.isUserSetFont(styleableParent);
 240         } else {
 241             return false;
 242         }
 243     }
 244 
 245     private static CssStyleHelper getStyleHelper(Node n) {
 246         return (n != null)? n.styleHelper : null;
 247     }
 248 
 249     private static Node findFirstStyleableAncestor(Styleable st) {
 250         Node ancestor = null;
 251         Styleable parent = st.getStyleableParent();
 252         while (parent != null) {
 253             if (parent instanceof Node) {
 254                 if (((Node) parent).styleHelper != null) {
 255                     ancestor = (Node) parent;
 256                     break;
 257                 }
 258             }
 259             parent = parent.getStyleableParent();
 260         }
 261 
 262         return ancestor;
 263     }
 264 
 265     //
 266     // return the value of the property
 267     //
 268     private static boolean isTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
 269         return booleanProperty != null &amp;&amp; booleanProperty.getValue();
 270     }
 271 
 272     //
 273     // set the value of the property to true
 274     //
 275     private static void setTrue(WritableValue&lt;Boolean&gt; booleanProperty) {
 276         if (booleanProperty != null) booleanProperty.setValue(true);
 277     }
 278 
 279     //
 280     // return true if the Node&#39;s current styleHelper can be reused.
 281     //
 282     private static boolean canReuseStyleHelper(final Node node, final StyleMap styleMap) {
 283 
 284         // Obviously, we cannot reuse the node&#39;s style helper if it doesn&#39;t have one.
 285         if (node == null || node.styleHelper == null) {
 286             return false;
 287         }
 288 
 289         // If we have a styleHelper but the new styleMap is null, then we don&#39;t need a styleHelper at all
 290         if (styleMap == null) {
 291             return false;
 292         }
 293 
 294         StyleMap currentMap = node.styleHelper.getStyleMap(node);
 295 
 296         // We cannot reuse the style helper if the styleMap is not the same instance as the current one
 297         // Note: check instance equality!
 298         if (currentMap != styleMap) {
 299             return false;
 300         }
 301 
<a name="3" id="anc3"></a><span class="line-added"> 302         //update ancestor since this node may have changed positions in the scene graph (JDK-8237469)</span>
<span class="line-added"> 303         node.styleHelper.firstStyleableAncestor = findFirstStyleableAncestor(node);</span>
<span class="line-added"> 304 </span>
 305         // If the style maps are the same instance, we can re-use the current styleHelper if the cacheContainer is null.
 306         // Under this condition, there are no styles for this node _and_ no styles inherit.
 307         if (node.styleHelper.cacheContainer == null) {
 308             return true;
 309         }
 310 
 311         //
 312         // The current map might be the same, but one of the node&#39;s parent&#39;s maps might have changed which
 313         // might cause some calculated values to change. To see if we can re-use the style-helper, we need to
 314         // check if the StyleMap id&#39;s have changed, which we can do by inspecting the cacheContainer&#39;s styleCacheKey
 315         // since it is made up of the current set of StyleMap ids.
 316         //
 317 
 318         Styleable parent = node.getStyleableParent();
 319 
 320         // if the node&#39;s parent is null and the style maps are the same, then we can certainly reuse the style-helper
 321         if (parent == null) {
 322             return true;
 323         }
 324 
 325         CssStyleHelper parentHelper = getStyleHelper(node.styleHelper.firstStyleableAncestor);
 326 
 327         if (parentHelper != null &amp;&amp; parentHelper.cacheContainer != null) {
 328 
 329             int[] parentIds = parentHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 330             int[] nodeIds = node.styleHelper.cacheContainer.styleCacheKey.getStyleMapIds();
 331 
 332             if (parentIds.length == nodeIds.length - 1) {
 333 
 334                 boolean isSame = true;
 335 
 336                 // check that all of the style map ids are the same.
 337                 for (int i = 0; i &lt; parentIds.length; i++) {
 338                     if (nodeIds[i + 1] != parentIds[i]) {
 339                         isSame = false;
 340                         break;
 341                     }
 342                 }
 343 
 344                 return isSame;
 345 
 346             }
 347         }
 348 
 349         return false;
 350     }
 351 
 352     /* This is the first Styleable parent (of Node this StyleHelper belongs to)
 353      * having a valid StyleHelper */
 354     private Node firstStyleableAncestor;
 355 
 356     private CacheContainer cacheContainer;
 357 
 358     private final static class CacheContainer {
 359 
 360         // Set internal internalState structures
 361         private CacheContainer(
 362                 Node node,
 363                 final StyleMap styleMap,
 364                 int depth) {
 365 
 366             int ctr = 0;
 367             int[] smapIds = new int[depth];
 368             smapIds[ctr++] = this.smapId = styleMap.getId();
 369 
 370             //
 371             // Create a set of StyleMap id&#39;s from the parent&#39;s smapIds.
 372             // The resulting smapIds array may have less than depth elements.
 373             // If a parent doesn&#39;t have a styleHelper or the styleHelper&#39;s
 374             // internal state is null, then that parent doesn&#39;t contribute
 375             // to the selection of a style. Any Node that has the same
 376             // set of smapId&#39;s can potentially share previously calculated
 377             // values.
 378             //
 379             Styleable parent = node.getStyleableParent();
 380             for(int d=1; d&lt;depth; d++) {
 381 
 382                 // TODO: won&#39;t work for something like .menu-item:hover. Need to separate CssStyleHelper tree from scene-graph tree
 383                 if ( parent instanceof Node) {
 384                     Node parentNode = (Node)parent;
 385                 final CssStyleHelper helper = parentNode.styleHelper;
 386                     if (helper != null &amp;&amp; helper.cacheContainer != null) {
 387                         smapIds[ctr++] = helper.cacheContainer.smapId;
 388                     }
 389                 }
 390                 parent = parent.getStyleableParent();
 391 
 392             }
 393 
 394             this.styleCacheKey = new StyleCache.Key(smapIds, ctr);
 395 
 396             CssMetaData&lt;Styleable,Font&gt; styleableFontProperty = null;
 397 
 398             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; props = node.getCssMetaData();
 399             final int pMax = props != null ? props.size() : 0;
 400             for (int p=0; p&lt;pMax; p++) {
 401                 final CssMetaData&lt;? extends Styleable, ?&gt; prop = props.get(p);
 402 
 403                 if (&quot;-fx-font&quot;.equals(prop.getProperty())) {
 404                     // unchecked!
 405                     styleableFontProperty = (CssMetaData&lt;Styleable, Font&gt;) prop;
 406                     break;
 407                 }
 408             }
 409 
 410             this.fontProp = styleableFontProperty;
 411             this.fontSizeCache = new HashMap&lt;&gt;();
 412 
 413             this.cssSetProperties = new HashMap&lt;&gt;();
 414 
 415         }
 416 
 417         private StyleMap getStyleMap(Styleable styleable) {
 418             if (styleable != null) {
 419                 SubScene subScene =  (styleable instanceof Node) ? ((Node) styleable).getSubScene() : null;
 420                 return StyleManager.getInstance().getStyleMap(styleable, subScene, smapId);
 421             } else {
 422                 return StyleMap.EMPTY_MAP;
 423             }
 424 
 425         }
 426 
 427         // This is the key we use to find the shared cache
 428         private final StyleCache.Key styleCacheKey;
 429 
 430         // If the node has a fontProperty, we hang onto the CssMetaData for it
 431         // so we can get at it later.
 432         // TBD - why not the fontProperty itself?
 433         private final CssMetaData&lt;Styleable,Font&gt; fontProp;
 434 
 435         // The id of StyleMap that contains the styles that apply to this node
 436         private final int smapId;
 437 
 438         // All nodes with the same set of styles share the same cache of
 439         // calculated values. But one node might have a different font-size
 440         // than another so the values are stored in cache by font-size.
 441         // This map associates a style cache entry with the font to use when
 442         // getting a value from or putting a value into cache.
 443         private final Map&lt;StyleCacheEntry.Key, CalculatedValue&gt; fontSizeCache;
 444 
 445         // Any properties that have been set by this style helper are tracked
 446         // here so the property can be reset without expanding properties that
 447         // were not set by css.
 448         private final Map&lt;CssMetaData, CalculatedValue&gt; cssSetProperties;
 449 
 450         private boolean forceSlowpath = false;
 451     }
 452 
 453     private void resetToInitialValues(final Styleable styleable) {
 454 
 455         if (cacheContainer == null ||
 456                 cacheContainer.cssSetProperties == null ||
 457                 cacheContainer.cssSetProperties.isEmpty()) return;
 458 
 459         // RT-31714 - make a copy of the entry set and clear the cssSetProperties immediately.
 460         Set&lt;Entry&lt;CssMetaData, CalculatedValue&gt;&gt; entrySet = new HashSet&lt;&gt;(cacheContainer.cssSetProperties.entrySet());
 461         cacheContainer.cssSetProperties.clear();
 462 
 463         for (Entry&lt;CssMetaData, CalculatedValue&gt; resetValues : entrySet) {
 464 
 465             final CssMetaData metaData = resetValues.getKey();
 466             final StyleableProperty styleableProperty = metaData.getStyleableProperty(styleable);
 467 
 468             final StyleOrigin styleOrigin = styleableProperty.getStyleOrigin();
 469             if (styleOrigin != null &amp;&amp; styleOrigin != StyleOrigin.USER) {
 470                 final CalculatedValue calculatedValue = resetValues.getValue();
 471                 styleableProperty.applyStyle(calculatedValue.getOrigin(), calculatedValue.getValue());
 472             }
 473         }
 474     }
 475 
 476 
 477     private StyleMap getStyleMap(Styleable styleable) {
 478         if (cacheContainer == null || styleable == null) return null;
 479         return cacheContainer.getStyleMap(styleable);
 480     }
 481 
 482     /**
 483      * A Set of all the pseudo-class states which, if they change, need to
 484      * cause the Node to be set to UPDATE its CSS styles on the next pulse.
 485      * For example, your stylesheet might have:
 486      * &lt;pre&gt;&lt;code&gt;
 487      * .button { ... }
 488      * .button:hover { ... }
 489      * .button *.label { text-fill: black }
 490      * .button:hover *.label { text-fill: blue }
 491      * &lt;/code&gt;&lt;/pre&gt;
 492      * In this case, the first 2 rules apply to the Button itself, but the
 493      * second two rules apply to the label within a Button. When the hover
 494      * changes on the Button, however, we must mark the Button as needing
 495      * an UPDATE. StyleHelper though only contains styles for the first two
 496      * rules for Button. The pseudoclassStateMask would in this case have
 497      * only a single bit set for &quot;hover&quot;. In this way the StyleHelper associated
 498      * with the Button would know whether a change to &quot;hover&quot; requires the
 499      * button and all children to be update. Other pseudo-class state changes
 500      * that are not in this hash set are ignored.
 501      * *
 502      * Called &quot;triggerStates&quot; since they would trigger a CSS update.
 503      */
 504     private PseudoClassState triggerStates = new PseudoClassState();
 505 
 506     boolean pseudoClassStateChanged(PseudoClass pseudoClass) {
 507         return triggerStates.contains(pseudoClass);
 508     }
 509 
 510     /**
 511      * Dynamic pseudo-class state of the node and its parents.
 512      * Only valid during a pulse.
 513      *
 514      * The StyleCacheEntry to choose depends on the Node&#39;s pseudo-class state
 515      * and the pseudo-class state of its parents. Without the parent
 516      * pseudo-class state, the fact that the the node in this pseudo-class state
 517      * matched foo:blah bar { } is lost.
 518      */
 519     // TODO: this should work on Styleable, not Node
 520     private Set&lt;PseudoClass&gt;[] getTransitionStates(final Node node) {
 521 
 522         // if cacheContainer is null, then CSS just doesn&#39;t apply to this node
 523         if (cacheContainer == null) return null;
 524 
 525         int depth = 0;
 526         Node parent = node;
 527         while (parent != null) {
 528             depth += 1;
 529             parent = parent.getParent();
 530         }
 531 
 532         //
 533         // StyleHelper#triggerStates is the set of pseudo-classes that appear
 534         // in the style maps of this StyleHelper. Calculated values are
 535         // cached by pseudo-class state, but only the pseudo-class states
 536         // that mater are used in the search. So we take the transition states
 537         // and intersect them with triggerStates to remove the
 538         // transition states that don&#39;t matter when it comes to matching states
 539         // on a  selector. For example if the style map contains only
 540         // .foo:hover { -fx-fill: red; } then only the hover state matters
 541         // but the transtion state could be [hover, focused]
 542         //
 543         final Set&lt;PseudoClass&gt;[] retainedStates = new PseudoClassState[depth];
 544 
 545         //
 546         // Note Well: The array runs from leaf to root. That is,
 547         // retainedStates[0] is the pseudo-class state for node and
 548         // retainedStates[1..(states.length-1)] are the retainedStates for the
 549         // node&#39;s parents.
 550         //
 551 
 552         int count = 0;
 553         parent = node;
 554         while (parent != null) { // This loop traverses through all ancestors till root
 555             final CssStyleHelper helper = (parent instanceof Node) ? parent.styleHelper : null;
 556             if (helper != null) {
 557                 final Set&lt;PseudoClass&gt; pseudoClassState = parent.pseudoClassStates;
 558                 retainedStates[count] = new PseudoClassState();
 559                 retainedStates[count].addAll(pseudoClassState);
 560                 // retainAll method takes the intersection of pseudoClassState and helper.triggerStates
 561                 retainedStates[count].retainAll(helper.triggerStates);
 562                 count += 1;
 563             }
 564             parent = parent.getParent();
 565         }
 566 
 567         final Set&lt;PseudoClass&gt;[] transitionStates = new PseudoClassState[count];
 568         System.arraycopy(retainedStates, 0, transitionStates, 0, count);
 569 
 570         return transitionStates;
 571 
 572     }
 573 
 574     /**
 575      * Called by the Node whenever it has transitioned from one set of
 576      * pseudo-class states to another. This function will then lookup the
 577      * new values for each of the styleable variables on the Node, and
 578      * then either set the value directly or start an animation based on
 579      * how things are specified in the CSS file. Currently animation support
 580      * is disabled until the new parser comes online with support for
 581      * animations and that support is detectable via the API.
 582      */
 583     void transitionToState(final Node node) {
 584 
 585         if (cacheContainer == null) {
 586             return;
 587         }
 588 
 589         //
 590         // If styleMap is null, then StyleManager has blown it away and we need to reapply CSS.
 591         //
 592         final StyleMap styleMap = getStyleMap(node);
 593         if (styleMap == null) {
 594             cacheContainer = null;
 595             node.reapplyCSS();
 596             return;
 597         }
 598 
 599         // if the style-map is empty, then we are only looking for inherited styles.
 600         final boolean inheritOnly = styleMap.isEmpty();
 601 
 602         //
 603         // Styles that need lookup can be cached provided none of the styles
 604         // are from Node.style.
 605         //
 606         final StyleCache sharedCache = StyleManager.getInstance().getSharedCache(node, node.getSubScene(), cacheContainer.styleCacheKey);
 607 
 608         if (sharedCache == null) {
 609             // Shared cache was blown away by StyleManager.
 610             // Therefore, this CssStyleHelper is no good.
 611             cacheContainer = null;
 612             node.reapplyCSS();
 613             return;
 614 
 615         }
 616 
 617         final Set&lt;PseudoClass&gt;[] transitionStates = getTransitionStates(node);
 618 
 619         final StyleCacheEntry.Key fontCacheKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
 620         CalculatedValue cachedFont = cacheContainer.fontSizeCache.get(fontCacheKey);
 621 
 622         if (cachedFont == null) {
 623 
 624             cachedFont = lookupFont(node, &quot;-fx-font&quot;, styleMap, cachedFont);
 625 
 626             if (cachedFont == SKIP) cachedFont = getCachedFont(node.getStyleableParent());
 627             if (cachedFont == null) cachedFont = new CalculatedValue(Font.getDefault(), null, false);
 628 
 629             cacheContainer.fontSizeCache.put(fontCacheKey,cachedFont);
 630 
 631         }
 632 
 633         final Font fontForRelativeSizes = (Font)cachedFont.getValue();
 634 
 635         final StyleCacheEntry.Key cacheEntryKey = new StyleCacheEntry.Key(transitionStates, fontForRelativeSizes);
 636         StyleCacheEntry cacheEntry = sharedCache.getStyleCacheEntry(cacheEntryKey);
 637 
 638         // if the cacheEntry already exists, take the fastpath
 639         final boolean fastpath = cacheEntry != null;
 640 
 641         if (cacheEntry == null) {
 642             cacheEntry = new StyleCacheEntry();
 643             sharedCache.addStyleCacheEntry(cacheEntryKey, cacheEntry);
 644         }
 645 
 646         final List&lt;CssMetaData&lt;? extends Styleable,  ?&gt;&gt; styleables = node.getCssMetaData();
 647 
 648         // Used in the for loop below, and a convenient place to stop when debugging.
 649         final int max = styleables.size();
 650 
 651         final boolean isForceSlowpath = cacheContainer.forceSlowpath;
 652         cacheContainer.forceSlowpath = false;
 653 
 654         // For each property that is settable, we need to do a lookup and
 655         // transition to that value.
 656         for(int n=0; n&lt;max; n++) {
 657 
 658             @SuppressWarnings(&quot;unchecked&quot;) // this is a widening conversion
 659             final CssMetaData&lt;Styleable,Object&gt; cssMetaData =
 660                     (CssMetaData&lt;Styleable,Object&gt;)styleables.get(n);
 661 
 662             // Don&#39;t bother looking up styles that don&#39;t inherit.
 663             if (inheritOnly &amp;&amp; cssMetaData.isInherits() == false) {
 664                 continue;
 665             }
 666 
 667             // Skip the lookup if we know there isn&#39;t a chance for this property
 668             // to be set (usually due to a &quot;bind&quot;).
 669             if (!cssMetaData.isSettable(node)) continue;
 670 
 671             final String property = cssMetaData.getProperty();
 672 
 673             CalculatedValue calculatedValue = cacheEntry.get(property);
 674 
 675             // If there is no calculatedValue and we&#39;re on the fast path,
 676             // take the slow path if cssFlags is REAPPLY (RT-31691)
 677             final boolean forceSlowpath =
 678                     fastpath &amp;&amp; calculatedValue == null &amp;&amp; isForceSlowpath;
 679 
 680             final boolean addToCache =
 681                     (!fastpath &amp;&amp; calculatedValue == null) || forceSlowpath;
 682 
 683             if (fastpath &amp;&amp; !forceSlowpath) {
 684 
 685                 // If the cache contains SKIP, then there was an
 686                 // exception thrown from applyStyle
 687                 if (calculatedValue == SKIP) {
 688                     continue;
 689                 }
 690 
 691             } else if (calculatedValue == null) {
 692 
 693                 // slowpath!
 694                 calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],
 695                         node, cachedFont);
 696 
 697                 // lookup is not supposed to return null.
 698                 if (calculatedValue == null) {
 699                     assert false : &quot;lookup returned null for &quot; + property;
 700                     continue;
 701                 }
 702 
 703             }
 704 
 705             // StyleableProperty#applyStyle might throw an exception and it is called
 706             // from two places in this try block.
 707             try {
 708 
 709                 //
 710                 // RT-19089
 711                 // If the current value of the property was set by CSS
 712                 // and there is no style for the property, then reset this
 713                 // property to its initial value. If it was not set by CSS
 714                 // then leave the property alone.
 715                 //
 716                 if (calculatedValue == null || calculatedValue == SKIP) {
 717 
 718                     // cssSetProperties keeps track of the StyleableProperty&#39;s that were set by CSS in the previous state.
 719                     // If this property is not in cssSetProperties map, then the property was not set in the previous state.
 720                     // This accomplishes two things. First, it lets us know if the property was set in the previous state
 721                     // so it can be reset in this state if there is no value for it. Second, it calling
 722                     // CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy
 723                     // properties.
 724                     CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);
 725 
 726                     // if the current value was set by CSS and there
 727                     // is no calculated value for the property, then
 728                     // there was no style for the property in the current
 729                     // state, so reset the property to its initial value.
 730                     if (initialValue != null) {
 731 
 732                         StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 733                         if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {
 734                             styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());
 735                         }
 736                     }
 737 
 738                     continue;
 739 
 740                 }
 741 
 742                 if (addToCache) {
 743 
 744                     // If we&#39;re not on the fastpath, then add the calculated
 745                     // value to cache.
 746                     cacheEntry.put(property, calculatedValue);
 747                 }
 748 
 749                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 750 
 751                 // need to know who set the current value - CSS, the user, or init
 752                 final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();
 753 
 754 
 755                 // RT-10522:
 756                 // If the user set the property and there is a style and
 757                 // the style came from the user agent stylesheet, then
 758                 // skip the value. A style from a user agent stylesheet should
 759                 // not override the user set style.
 760                 //
 761                 final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();
 762 
 763                 // A calculated value should never have a null style origin since that would
 764                 // imply the style didn&#39;t come from a stylesheet or in-line style.
 765                 if (originOfCalculatedValue == null) {
 766                     assert false : styleableProperty.toString();
 767                     continue;
 768                 }
 769 
 770                 if (originOfCurrentValue == StyleOrigin.USER) {
 771                     if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {
 772                         continue;
 773                     }
 774                 }
 775 
 776                 final Object value = calculatedValue.getValue();
 777                 final Object currentValue = styleableProperty.getValue();
 778 
 779                 // RT-21185: Only apply the style if something has changed.
 780                 if ((originOfCurrentValue != originOfCalculatedValue)
 781                         || (currentValue != null
 782                         ? currentValue.equals(value) == false
 783                         : value != null)) {
 784 
 785                     if (LOGGER.isLoggable(Level.FINER)) {
 786                         LOGGER.finer(property + &quot;, call applyStyle: &quot; + styleableProperty + &quot;, value =&quot; +
 787                                 String.valueOf(value) + &quot;, originOfCalculatedValue=&quot; + originOfCalculatedValue);
 788                     }
 789 
 790                     styleableProperty.applyStyle(originOfCalculatedValue, value);
 791 
 792                     if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {
 793                         // track this property
 794                         CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);
 795                         cacheContainer.cssSetProperties.put(cssMetaData, initialValue);
 796                     }
 797 
 798                 }
 799 
 800             } catch (Exception e) {
 801 
 802                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);
 803 
 804                 final String msg = String.format(&quot;Failed to set css [%s] on [%s] due to &#39;%s&#39;\n&quot;,
 805                         cssMetaData.getProperty(), styleableProperty, e.getMessage());
 806 
 807                 List&lt;CssParser.ParseError&gt; errors = null;
 808                 if ((errors = StyleManager.getErrors()) != null) {
 809                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, node, msg);
 810                     errors.add(error);
 811                 }
 812 
 813                 PlatformLogger logger = Logging.getCSSLogger();
 814                 if (logger.isLoggable(Level.WARNING)) {
 815                     logger.warning(msg);
 816                 }
 817 
 818                 // RT-27155: if setting value raises exception, reset value
 819                 // the value to initial and thereafter skip setting the property
 820                 cacheEntry.put(property, SKIP);
 821 
 822                 CalculatedValue cachedValue = null;
 823                 if (cacheContainer != null &amp;&amp; cacheContainer.cssSetProperties != null) {
 824                     cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);
 825                 }
 826                 Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);
 827                 StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;
 828                 try {
 829                     styleableProperty.applyStyle(origin, value);
 830                 } catch (Exception ebad) {
 831                     // This would be bad.
 832                     if (logger.isLoggable(Level.SEVERE)) {
 833                         logger.severe(String.format(&quot;Could not reset [%s] on [%s] due to %s\n&quot; ,
 834                                 cssMetaData.getProperty(), styleableProperty, e.getMessage()));
 835                     }
 836                 }
 837 
 838             }
 839 
 840         }
 841     }
 842 
 843     /**
 844      * Gets the CSS CascadingStyle for the property of this node in these pseudo-class
 845      * states. A null style may be returned if there is no style information
 846      * for this combination of input parameters.
 847      *
 848      *
 849      * @param styleable
 850      * @param property
 851      * @param styleMap
 852      * @param states   @return
 853      * */
 854     private CascadingStyle getStyle(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states){
 855 
 856         if (styleMap == null || styleMap.isEmpty()) return null;
 857 
 858         final Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = styleMap.getCascadingStyles();
 859         if (cascadingStyleMap == null || cascadingStyleMap.isEmpty()) return null;
 860 
 861         // Get all of the Styles which may apply to this particular property
 862         List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);
 863 
 864         // If there are no styles for this property then we can just bail
 865         if ((styles == null) || styles.isEmpty()) return null;
 866 
 867         // Go looking for the style. We do this by visiting each CascadingStyle in
 868         // order finding the first that matches the current node &amp; set of
 869         // pseudo-class states. We use an iteration style that avoids creating
 870         // garbage iterators (and wish javac did it for us...)
 871        CascadingStyle style = null;
 872         final int max = (styles == null) ? 0 : styles.size();
 873         for (int i=0; i&lt;max; i++) {
 874             final CascadingStyle s = styles.get(i);
 875             final Selector sel = s == null ? null : s.getSelector();
 876             if (sel == null) continue; // bail if the selector is null.
 877 //System.out.println(node.toString() + &quot;\n\tstates=&quot; + PseudoClassSet.getPseudoClasses(states) + &quot;\n\tstateMatches? &quot; + sel.stateMatches(node, states) + &quot;\n\tsel=&quot; + sel.toString());
 878             if (sel.stateMatches(styleable, states)) {
 879                 style = s;
 880                 break;
 881             }
 882         }
 883 
 884         return style;
 885     }
 886 
 887     /**
 888      * The main workhorse of this class, the lookup method walks up the CSS
 889      * style tree looking for the style information for the Node, the
 890      * property associated with the given styleable, in these states for this font.
 891      *
 892      *
 893      *
 894      *
 895      * @param styleable
 896      * @param states
 897      * @param originatingStyleable
 898      * @return
 899      */
 900     private CalculatedValue lookup(final Styleable styleable,
 901                                    final CssMetaData cssMetaData,
 902                                    final StyleMap styleMap,
 903                                    final Set&lt;PseudoClass&gt; states,
 904                                    final Styleable originatingStyleable,
 905                                    final CalculatedValue cachedFont) {
 906 
 907         if (cssMetaData.getConverter() == FontConverter.getInstance()) {
 908             return lookupFont(styleable, cssMetaData.getProperty(), styleMap, cachedFont);
 909         }
 910 
 911         final String property = cssMetaData.getProperty();
 912 
 913         // Get the CascadingStyle which may apply to this particular property
 914         CascadingStyle style = getStyle(styleable, property, styleMap, states);
 915 
 916         // If no style was found and there are no sub styleables, then there
 917         // are no matching styles for this property. We will then either SKIP
 918         // or we will INHERIT. We will inspect the default value for the styleable,
 919         // and if it is INHERIT then we will inherit otherwise we just skip it.
 920         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = cssMetaData.getSubProperties();
 921         final int numSubProperties = (subProperties != null) ? subProperties.size() : 0;
 922         if (style == null) {
 923 
 924             if (numSubProperties == 0) {
 925 
 926                 return handleNoStyleFound(styleable, cssMetaData,
 927                         styleMap, states, originatingStyleable, cachedFont);
 928 
 929             } else {
 930 
 931                 // If style is null then it means we didn&#39;t successfully find the
 932                 // property we were looking for. However, there might be sub styleables,
 933                 // in which case we should perform a lookup for them. For example,
 934                 // there might not be a style for &quot;font&quot;, but there might be one
 935                 // for &quot;font-size&quot; or &quot;font-weight&quot;. So if the style is null, then
 936                 // we need to check with the sub-styleables.
 937 
 938                 // Build up a list of all SubProperties which have a constituent part.
 939                 // I default the array to be the size of the number of total
 940                 // sub styleables to avoid having the array grow.
 941                 Map&lt;CssMetaData,Object&gt; subs = null;
 942                 StyleOrigin origin = null;
 943 
 944                 boolean isRelative = false;
 945 
 946                 for (int i=0; i&lt;numSubProperties; i++) {
 947                     CssMetaData subkey = subProperties.get(i);
 948                     CalculatedValue constituent =
 949                         lookup(styleable, subkey, styleMap, states,
 950                                 originatingStyleable, cachedFont);
 951                     if (constituent != SKIP) {
 952                         if (subs == null) {
 953                             subs = new HashMap&lt;&gt;();
 954                         }
 955                         subs.put(subkey, constituent.getValue());
 956 
 957                         // origin of this style is the most specific
 958                         if ((origin != null &amp;&amp; constituent.getOrigin() != null)
 959                                 ? origin.compareTo(constituent.getOrigin()) &lt; 0
 960                                 : constituent.getOrigin() != null) {
 961                             origin = constituent.getOrigin();
 962                         }
 963 
 964                         // if the constiuent uses relative sizes, then
 965                         // isRelative is true;
 966                         isRelative = isRelative || constituent.isRelative();
 967 
 968                     }
 969                 }
 970 
 971                 // If there are no subkeys which apply...
 972                 if (subs == null || subs.isEmpty()) {
 973                     return handleNoStyleFound(styleable, cssMetaData,
 974                             styleMap, states, originatingStyleable, cachedFont);
 975                 }
 976 
 977                 try {
 978                     final StyleConverter keyType = cssMetaData.getConverter();
 979                     Object ret = keyType.convert(subs);
 980                     return new CalculatedValue(ret, origin, isRelative);
 981                 } catch (ClassCastException cce) {
 982                     final String msg = formatExceptionMessage(styleable, cssMetaData, null, cce);
 983                     List&lt;CssParser.ParseError&gt; errors = null;
 984                     if ((errors = StyleManager.getErrors()) != null) {
 985                         final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
 986                         errors.add(error);
 987                     }
 988                     if (LOGGER.isLoggable(Level.WARNING)) {
 989                         LOGGER.warning(msg);
 990                         LOGGER.fine(&quot;caught: &quot;, cce);
 991                         LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
 992                         LOGGER.fine(&quot;node = &quot; + styleable.toString());
 993                     }
 994                     return SKIP;
 995                 }
 996             }
 997 
 998         } else { // style != null
 999 
1000             // RT-10522:
1001             // If the user set the property and there is a style and
1002             // the style came from the user agent stylesheet, then
1003             // skip the value. A style from a user agent stylesheet should
1004             // not override the user set style.
1005             if (style.getOrigin() == StyleOrigin.USER_AGENT) {
1006 
1007                 StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(originatingStyleable);
1008                 // if styleableProperty is null, then we&#39;re dealing with a sub-property.
1009                 if (styleableProperty != null &amp;&amp; styleableProperty.getStyleOrigin() == StyleOrigin.USER) {
1010                     return SKIP;
1011                 }
1012             }
1013 
1014             // If there was a style found, then we want to check whether the
1015             // value was &quot;inherit&quot;. If so, then we will simply inherit.
1016             final ParsedValue cssValue = style.getParsedValue();
1017             if (cssValue != null &amp;&amp; &quot;inherit&quot;.equals(cssValue.getValue())) {
1018                 style = getInheritedStyle(styleable, property);
1019                 if (style == null) return SKIP;
1020             }
1021         }
1022 
1023 //        System.out.println(&quot;lookup &quot; + property +
1024 //                &quot;, selector = \&#39;&quot; + style.selector.toString() + &quot;\&#39;&quot; +
1025 //                &quot;, node = &quot; + node.toString());
1026 
1027         return calculateValue(style, styleable, cssMetaData, styleMap, states,
1028                 originatingStyleable, cachedFont);
1029     }
1030 
1031     /**
1032      * Called when there is no style found.
1033      */
1034     private CalculatedValue handleNoStyleFound(final Styleable styleable,
1035                                                final CssMetaData cssMetaData,
1036                                                final StyleMap styleMap, Set&lt;PseudoClass&gt; pseudoClassStates, Styleable originatingStyleable,
1037                                                final CalculatedValue cachedFont) {
1038 
1039         if (cssMetaData.isInherits()) {
1040 
1041 
1042             StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(styleable);
1043             StyleOrigin origin = styleableProperty != null ? styleableProperty.getStyleOrigin() : null;
1044 
1045             // RT-16308: if there is no matching style and the user set
1046             // the property, do not look for inherited styles.
1047             if (origin == StyleOrigin.USER) {
1048 
1049                     return SKIP;
1050 
1051             }
1052 
1053             CascadingStyle style = getInheritedStyle(styleable, cssMetaData.getProperty());
1054             if (style == null) return SKIP;
1055 
1056             CalculatedValue cv =
1057                     calculateValue(style, styleable, cssMetaData,
1058                             styleMap, pseudoClassStates, originatingStyleable,
1059                                    cachedFont);
1060 
1061             return cv;
1062 
1063         } else {
1064 
1065             // Not inherited. There is no style
1066             return SKIP;
1067 
1068         }
1069     }
1070     /**
1071      * Called when we must getInheritedStyle a value from a parent node in the scenegraph.
1072      */
1073     private CascadingStyle getInheritedStyle(
1074             final Styleable styleable,
1075             final String property) {
1076 
1077         Styleable parent = ((Node)styleable).styleHelper.firstStyleableAncestor;
1078         CssStyleHelper parentStyleHelper = getStyleHelper((Node) parent);
1079 
1080         if (parent != null &amp;&amp; parentStyleHelper != null) {
1081 
1082             StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
1083             Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1084             CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1085 
1086             if (cascadingStyle != null) {
1087 
1088                 final ParsedValue cssValue = cascadingStyle.getParsedValue();
1089 
1090                 if (&quot;inherit&quot;.equals(cssValue.getValue())) {
1091                     return getInheritedStyle(parent, property);
1092                 }
1093                 return cascadingStyle;
1094             }
1095         }
1096 
1097         return null;
1098     }
1099 
1100 
1101     // helps with self-documenting the code
1102     private static final Set&lt;PseudoClass&gt; NULL_PSEUDO_CLASS_STATE = null;
1103 
1104     /**
1105      * Find the property among the styles that pertain to the Node
1106      */
1107     private CascadingStyle resolveRef(final Styleable styleable, final String property, final StyleMap styleMap, final Set&lt;PseudoClass&gt; states) {
1108 
1109         final CascadingStyle style = getStyle(styleable, property, styleMap, states);
1110         if (style != null) {
1111             return style;
1112         } else {
1113             // if style is null, it may be because there isn&#39;t a style for this
1114             // node in this state, or we may need to look up the parent chain
1115             if (states != null &amp;&amp; states.size() &gt; 0) {
1116                 // if states &gt; 0, then we need to check this node again,
1117                 // but without any states.
1118                 return resolveRef(styleable,property, styleMap, NULL_PSEUDO_CLASS_STATE);
1119             } else {
1120                 // TODO: This block was copied from inherit. Both should use same code somehow.
1121 
1122                 Styleable styleableParent = ((Node)styleable).styleHelper.firstStyleableAncestor;
1123                 CssStyleHelper parentStyleHelper = getStyleHelper((Node) styleableParent);
1124 
1125                 if (styleableParent == null || parentStyleHelper == null) {
1126                     return null;
1127                 }
1128 
1129                 StyleMap parentStyleMap = parentStyleHelper.getStyleMap(styleableParent);
1130                 Set&lt;PseudoClass&gt; styleableParentPseudoClassStates =
1131                     styleableParent instanceof Node
1132                         ? ((Node)styleableParent).pseudoClassStates
1133                         : styleable.getPseudoClassStates();
1134 
1135                 return parentStyleHelper.resolveRef(styleableParent, property,
1136                         parentStyleMap, styleableParentPseudoClassStates);
1137             }
1138         }
1139     }
1140 
1141     // to resolve a lookup, we just need to find the parsed value.
1142     private ParsedValue resolveLookups(
1143             final Styleable styleable,
1144             final ParsedValue parsedValue,
1145             final StyleMap styleMap, Set&lt;PseudoClass&gt; states,
1146             final ObjectProperty&lt;StyleOrigin&gt; whence,
1147             Set&lt;ParsedValue&gt; resolves) {
1148 
1149         //
1150         // either the value itself is a lookup, or the value contain a lookup
1151         //
1152         if (parsedValue.isLookup()) {
1153 
1154             // The value we&#39;re looking for should be a Paint, one of the
1155             // containers for linear, radial or ladder, or a derived color.
1156             final Object val = parsedValue.getValue();
1157             if (val instanceof String) {
1158 
1159                 final String sval = ((String) val).toLowerCase(Locale.ROOT);
1160 
1161                 CascadingStyle resolved =
1162                     resolveRef(styleable, sval, styleMap, states);
1163 
1164                 if (resolved != null) {
1165 
1166                     if (resolves.contains(resolved.getParsedValue())) {
1167 
1168                         if (LOGGER.isLoggable(Level.WARNING)) {
1169                             LOGGER.warning(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving &#39;&quot; + sval + &quot;&#39;&quot;);
1170                         }
1171                         throw new IllegalArgumentException(&quot;Loop detected in &quot; + resolved.getRule().toString() + &quot; while resolving &#39;&quot; + sval + &quot;&#39;&quot;);
1172 
1173                     } else {
1174                         resolves.add(parsedValue);
1175                     }
1176 
1177                     // The origin of this parsed value is the greatest of
1178                     // any of the resolved reference. If a resolved reference
1179                     // comes from an inline style, for example, then the value
1180                     // calculated from the resolved lookup should have inline
1181                     // as its origin. Otherwise, an inline style could be
1182                     // stored in shared cache.
1183                     final StyleOrigin wOrigin = whence.get();
1184                     final StyleOrigin rOrigin = resolved.getOrigin();
1185                     if (rOrigin != null &amp;&amp; (wOrigin == null ||  wOrigin.compareTo(rOrigin) &lt; 0)) {
1186                         whence.set(rOrigin);
1187                     }
1188 
1189                     // the resolved value may itself need to be resolved.
1190                     // For example, if the value &quot;color&quot; resolves to &quot;base&quot;,
1191                     // then &quot;base&quot; will need to be resolved as well.
1192                     ParsedValue pv = resolveLookups(styleable, resolved.getParsedValue(), styleMap, states, whence, resolves);
1193 
1194                     if (resolves != null) {
1195                         resolves.remove(parsedValue);
1196                     }
1197 
1198                     return pv;
1199 
1200                 }
1201             }
1202         }
1203 
1204         // If the value doesn&#39;t contain any values that need lookup, then bail
1205         if (!parsedValue.isContainsLookups()) {
1206             return parsedValue;
1207         }
1208 
1209         final Object val = parsedValue.getValue();
1210 
1211         if (val instanceof ParsedValue[][]) {
1212 
1213             // If ParsedValue is a layered sequence of values, resolve the lookups for each.
1214             final ParsedValue[][] layers = (ParsedValue[][])val;
1215             ParsedValue[][] resolved = new ParsedValue[layers.length][0];
1216             for (int l=0; l&lt;layers.length; l++) {
1217                 resolved[l] = new ParsedValue[layers[l].length];
1218                 for (int ll=0; ll&lt;layers[l].length; ll++) {
1219                     if (layers[l][ll] == null) continue;
1220                     resolved[l][ll] =
1221                         resolveLookups(styleable, layers[l][ll], styleMap, states, whence, resolves);
1222                 }
1223             }
1224 
1225             resolves.clear();
1226 
1227             return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);
1228 
1229         } else if (val instanceof ParsedValueImpl[]) {
1230 
1231             // If ParsedValue is a sequence of values, resolve the lookups for each.
1232             final ParsedValue[] layer = (ParsedValue[])val;
1233             ParsedValue[] resolved = new ParsedValue[layer.length];
1234             for (int l=0; l&lt;layer.length; l++) {
1235                 if (layer[l] == null) continue;
1236                 resolved[l] =
1237                     resolveLookups(styleable, layer[l], styleMap, states, whence, resolves);
1238             }
1239 
1240             resolves.clear();
1241 
1242             return new ParsedValueImpl(resolved, parsedValue.getConverter(), false);
1243 
1244         }
1245 
1246         return parsedValue;
1247 
1248     }
1249 
1250     private String getUnresolvedLookup(final ParsedValue resolved) {
1251 
1252         Object value = resolved.getValue();
1253 
1254         if (resolved.isLookup() &amp;&amp; value instanceof String) {
1255             return (String)value;
1256         }
1257 
1258         if (value instanceof ParsedValue[][]) {
1259             final ParsedValue[][] layers = (ParsedValue[][])value;
1260             for (int l=0; l&lt;layers.length; l++) {
1261                 for (int ll=0; ll&lt;layers[l].length; ll++) {
1262                     if (layers[l][ll] == null) continue;
1263                     String unresolvedLookup = getUnresolvedLookup(layers[l][ll]);
1264                     if (unresolvedLookup != null) return unresolvedLookup;
1265                 }
1266             }
1267 
1268         } else if (value instanceof ParsedValue[]) {
1269         // If ParsedValue is a sequence of values, resolve the lookups for each.
1270             final ParsedValue[] layer = (ParsedValue[])value;
1271             for (int l=0; l&lt;layer.length; l++) {
1272                 if (layer[l] == null) continue;
1273                 String unresolvedLookup = getUnresolvedLookup(layer[l]);
1274                 if (unresolvedLookup != null) return unresolvedLookup;
1275             }
1276         }
1277 
1278         return null;
1279     }
1280 
1281     private String formatUnresolvedLookupMessage(Styleable styleable, CssMetaData cssMetaData, Style style, ParsedValue resolved, ClassCastException cce) {
1282 
1283         // Find value that could not be looked up. If the resolved value does not contain lookups, then the
1284         // ClassCastException is not because of trying to convert a String (which is the missing lookup)
1285         // to some value, but is because the convert method got some wrong value - like a paint when it should be a color.
1286         // See RT-33319 for an example of this.
1287         String missingLookup = resolved != null &amp;&amp; resolved.isContainsLookups() ? getUnresolvedLookup(resolved) : null;
1288 
1289         StringBuilder sbuf = new StringBuilder();
1290         if (missingLookup != null) {
1291             sbuf.append(&quot;Could not resolve &#39;&quot;)
1292                     .append(missingLookup)
1293                     .append(&quot;&#39;&quot;)
1294                     .append(&quot; while resolving lookups for &#39;&quot;)
1295                     .append(cssMetaData.getProperty())
1296                     .append(&quot;&#39;&quot;);
1297         } else {
1298             sbuf.append(&quot;Caught &#39;&quot;)
1299                     .append(cce)
1300                     .append(&quot;&#39;&quot;)
1301                     .append(&quot; while converting value for &#39;&quot;)
1302                     .append(cssMetaData.getProperty())
1303                     .append(&quot;&#39;&quot;);
1304         }
1305 
1306         final Rule rule = style != null ? style.getDeclaration().getRule(): null;
1307         final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
1308         final String url = stylesheet != null ? stylesheet.getUrl() : null;
1309         if (url != null) {
1310             sbuf.append(&quot; from rule &#39;&quot;)
1311                 .append(style.getSelector())
1312                 .append(&quot;&#39; in stylesheet &quot;).append(url);
1313         } else if (stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
1314             sbuf.append(&quot; from inline style on &quot; )
1315                 .append(styleable.toString());
1316         }
1317 
1318         return sbuf.toString();
1319     }
1320 
1321     private String formatExceptionMessage(Styleable styleable, CssMetaData cssMetaData, Style style, Exception e) {
1322 
1323         StringBuilder sbuf = new StringBuilder();
1324         sbuf.append(&quot;Caught &quot;)
1325             .append(String.valueOf(e));
1326 
1327         if (cssMetaData != null) {
1328             sbuf.append(&quot;&#39;&quot;)
1329                 .append(&quot; while calculating value for &#39;&quot;)
1330                 .append(cssMetaData.getProperty())
1331                 .append(&quot;&#39;&quot;);
1332         }
1333 
1334         if (style != null) {
1335 
1336             final Rule rule = style.getDeclaration().getRule();
1337             final Stylesheet stylesheet = rule != null ? rule.getStylesheet() : null;
1338             final String url = stylesheet != null ? stylesheet.getUrl() : null;
1339 
1340             if (url != null) {
1341                 sbuf.append(&quot; from rule &#39;&quot;)
1342                         .append(style.getSelector())
1343                         .append(&quot;&#39; in stylesheet &quot;).append(url);
1344             } else if (styleable != null &amp;&amp; stylesheet != null &amp;&amp; StyleOrigin.INLINE == stylesheet.getOrigin()) {
1345                 sbuf.append(&quot; from inline style on &quot; )
1346                         .append(styleable.toString());
1347             } else {
1348                 sbuf.append(&quot; from style &#39;&quot;)
1349                     .append(String.valueOf(style))
1350                     .append(&quot;&#39;&quot;);
1351             }
1352         }
1353 
1354         return sbuf.toString();
1355     }
1356 
1357 
1358     private CalculatedValue calculateValue(
1359             final CascadingStyle style,
1360             final Styleable styleable,
1361             final CssMetaData cssMetaData,
1362             final StyleMap styleMap, final Set&lt;PseudoClass&gt; states,
1363             final Styleable originatingStyleable,
1364             final CalculatedValue fontFromCacheEntry) {
1365 
1366         final ParsedValue cssValue = style.getParsedValue();
1367         if (cssValue != null &amp;&amp; !(&quot;null&quot;.equals(cssValue.getValue()) || &quot;none&quot;.equals(cssValue.getValue()))) {
1368 
1369             ParsedValue resolved = null;
1370             try {
1371 
1372                 ObjectProperty&lt;StyleOrigin&gt; whence = new SimpleObjectProperty&lt;&gt;(style.getOrigin());
1373                 resolved = resolveLookups(styleable, cssValue, styleMap, states, whence, new HashSet&lt;&gt;());
1374 
1375                 final String property = cssMetaData.getProperty();
1376 
1377                 // The computed value
1378                 Object val = null;
1379                 boolean isFontProperty =
1380                         &quot;-fx-font&quot;.equals(property) ||
1381                         &quot;-fx-font-size&quot;.equals(property);
1382 
1383                 boolean isRelative = ParsedValueImpl.containsFontRelativeSize(resolved, isFontProperty);
1384 
1385                 //
1386                 // Avoid using a font calculated from a relative size
1387                 // to calculate a font with a relative size.
1388                 // For example:
1389                 // Assume the default font size is 13 and we have a style with
1390                 // -fx-font-size: 1.5em, then the cacheEntry font value will
1391                 // have a size of 13*1.5=19.5.
1392                 // Now, when converting that same font size again in response
1393                 // to looking up a value for -fx-font, we do not want to use
1394                 // 19.5 as the font for relative size conversion since this will
1395                 // yield a font 19.5*1.5=29.25 when really what we want is
1396                 // a font size of 19.5.
1397                 // In this situation, then, we use the font from the parent&#39;s
1398                 // cache entry.
1399                 Font fontForFontRelativeSizes = null;
1400 
1401                 if (isRelative &amp;&amp; isFontProperty &amp;&amp;
1402                     (fontFromCacheEntry == null || fontFromCacheEntry.isRelative())) {
1403 
1404                     Styleable parent = styleable;
1405                     CalculatedValue childsCachedFont = fontFromCacheEntry;
1406                     do {
1407 
1408                         CalculatedValue parentsCachedFont = getCachedFont(parent.getStyleableParent());
1409 
1410                         if (parentsCachedFont != null)  {
1411 
1412                             if (parentsCachedFont.isRelative()) {
1413 
1414                                 //
1415                                 // If the cached fonts are the same, then the cached font came from the same
1416                                 // style and we need to keep looking. Otherwise, use the font we found.
1417                                 //
1418                                 if (childsCachedFont == null || parentsCachedFont.equals(childsCachedFont)) {
1419                                     childsCachedFont = parentsCachedFont;
1420                                 } else {
1421                                     fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
1422                                 }
1423 
1424                             } else  {
1425                                 // fontValue.isRelative() == false!
1426                                 fontForFontRelativeSizes = (Font)parentsCachedFont.getValue();
1427                             }
1428 
1429                         }
1430 
1431                     } while(fontForFontRelativeSizes == null &amp;&amp;
1432                             (parent = parent.getStyleableParent()) != null);
1433                 }
1434 
1435                 // did we get a fontValue from the preceding block?
1436                 // if not, get it from our cacheEntry or choose the default
1437                 if (fontForFontRelativeSizes == null) {
1438                     if (fontFromCacheEntry != null &amp;&amp; fontFromCacheEntry.isRelative() == false) {
1439                         fontForFontRelativeSizes = (Font)fontFromCacheEntry.getValue();
1440                     } else {
1441                         fontForFontRelativeSizes = Font.getDefault();
1442                     }
1443                 }
1444 
1445                 final StyleConverter cssMetaDataConverter = cssMetaData.getConverter();
1446                 // RT-37727 - handling of properties that are insets is wonky. If the property is -fx-inset, then
1447                 // there isn&#39;t an issue because the converter assigns the InsetsConverter to the ParsedValue.
1448                 // But -my-insets will parse as an array of numbers and the parser will assign the Size sequence
1449                 // converter to it. So, if the CssMetaData says it uses InsetsConverter, use the InsetsConverter
1450                 // and not the parser assigned converter.
1451                 if (cssMetaDataConverter == StyleConverter.getInsetsConverter()) {
1452                     if (resolved.getValue() instanceof ParsedValue) {
1453                         // If you give the parser &quot;-my-insets: 5;&quot; you end up with a ParsedValue&lt;ParsedValue&lt;?,Size&gt;, Number&gt;
1454                         // and not a ParsedValue&lt;ParsedValue[], Number[]&gt; so here we wrap the value into an array
1455                         // to make the InsetsConverter happy.
1456                         resolved = new ParsedValueImpl(new ParsedValue[] {(ParsedValue)resolved.getValue()}, null, false);
1457                     }
1458                     val = cssMetaDataConverter.convert(resolved, fontForFontRelativeSizes);
1459                 }
1460                 else if (resolved.getConverter() != null)
1461                     val = resolved.convert(fontForFontRelativeSizes);
1462                 else
1463                     val = cssMetaData.getConverter().convert(resolved, fontForFontRelativeSizes);
1464 
1465                 final StyleOrigin origin = whence.get();
1466                 return new CalculatedValue(val, origin, isRelative);
1467 
1468             } catch (ClassCastException cce) {
1469                 final String msg = formatUnresolvedLookupMessage(styleable, cssMetaData, style.getStyle(),resolved, cce);
1470                 List&lt;CssParser.ParseError&gt; errors = null;
1471                 if ((errors = StyleManager.getErrors()) != null) {
1472                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1473                     errors.add(error);
1474                 }
1475                 if (LOGGER.isLoggable(Level.WARNING)) {
1476                     LOGGER.warning(msg);
1477                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1478                     LOGGER.fine(&quot;cssMetaData = &quot; + cssMetaData);
1479                     LOGGER.fine(&quot;styles = &quot; + getMatchingStyles(styleable, cssMetaData));
1480                 }
1481                 return SKIP;
1482             } catch (IllegalArgumentException iae) {
1483                 final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), iae);
1484                 List&lt;CssParser.ParseError&gt; errors = null;
1485                 if ((errors = StyleManager.getErrors()) != null) {
1486                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1487                     errors.add(error);
1488                 }
1489                 if (LOGGER.isLoggable(Level.WARNING)) {
1490                     LOGGER.warning(msg);
1491                     LOGGER.fine(&quot;caught: &quot;, iae);
1492                     LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
1493                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1494                 }
1495                 return SKIP;
1496             } catch (NullPointerException npe) {
1497                 final String msg = formatExceptionMessage(styleable, cssMetaData, style.getStyle(), npe);
1498                 List&lt;CssParser.ParseError&gt; errors = null;
1499                 if ((errors = StyleManager.getErrors()) != null) {
1500                     final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, styleable, msg);
1501                     errors.add(error);
1502                 }
1503                 if (LOGGER.isLoggable(Level.WARNING)) {
1504                     LOGGER.warning(msg);
1505                     LOGGER.fine(&quot;caught: &quot;, npe);
1506                     LOGGER.fine(&quot;styleable = &quot; + cssMetaData);
1507                     LOGGER.fine(&quot;node = &quot; + styleable.toString());
1508                 }
1509                 return SKIP;
1510             }
1511 
1512         }
1513         // either cssValue was null or cssValue&#39;s value was &quot;null&quot; or &quot;none&quot;
1514         return new CalculatedValue(null, style.getOrigin(), false);
1515 
1516     }
1517 
1518     private static final CssMetaData dummyFontProperty =
1519             new FontCssMetaData&lt;Node&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1520 
1521         @Override
1522         public boolean isSettable(Node node) {
1523             return true;
1524         }
1525 
1526         @Override
1527         public StyleableProperty&lt;Font&gt; getStyleableProperty(Node node) {
1528             return null;
1529         }
1530     };
1531 
1532     private CalculatedValue getCachedFont(final Styleable styleable) {
1533 
1534         if (styleable instanceof Node == false) return null;
1535 
1536         CalculatedValue cachedFont = null;
1537 
1538         Node parent = (Node)styleable;
1539 
1540         final CssStyleHelper parentHelper = parent.styleHelper;
1541 
1542         // if there is no parentHelper,
1543         // or there is a parentHelper but no cacheContainer,
1544         // then look to the next parent
1545         if (parentHelper == null || parentHelper.cacheContainer == null) {
1546 
1547             cachedFont = getCachedFont(parent.getStyleableParent());
1548 
1549         // there is a parent helper and a cacheContainer,
1550         } else  {
1551 
1552             CacheContainer parentCacheContainer = parentHelper.cacheContainer;
1553             if ( parentCacheContainer != null
1554                     &amp;&amp; parentCacheContainer.fontSizeCache != null
1555                     &amp;&amp; parentCacheContainer.fontSizeCache.isEmpty() == false) {
1556 
1557                 Set&lt;PseudoClass&gt;[] transitionStates = parentHelper.getTransitionStates(parent);
1558                 StyleCacheEntry.Key parentCacheEntryKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());
1559                 cachedFont = parentCacheContainer.fontSizeCache.get(parentCacheEntryKey);
1560             }
1561 
1562             if (cachedFont == null)  {
1563                 StyleMap smap = parentHelper.getStyleMap(parent);
1564                 cachedFont = parentHelper.lookupFont(parent, &quot;-fx-font&quot;, smap, null);
1565             }
1566         }
1567 
1568         return cachedFont != SKIP ? cachedFont : null;
1569     }
1570 
1571     /*package access for testing*/ FontPosture getFontPosture(Font font) {
1572         if (font == null) return FontPosture.REGULAR;
1573 
1574         String fontName = font.getName().toLowerCase(Locale.ROOT);
1575 
1576         if (fontName.contains(&quot;italic&quot;)) {
1577             return FontPosture.ITALIC;
1578         }
1579 
1580         return FontPosture.REGULAR;
1581     }
1582 
1583     /*package access for testing*/ FontWeight getFontWeight(Font font) {
1584         if (font == null) return FontWeight.NORMAL;
1585 
1586         String fontName = font.getName().toLowerCase(Locale.ROOT);
1587 
1588         if (fontName.contains(&quot;bold&quot;)) {
1589             if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_BOLD;
1590             if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_BOLD;
1591             else if (fontName.contains(&quot;semi&quot;)) return FontWeight.SEMI_BOLD;
1592             else if (fontName.contains(&quot;demi&quot;)) return FontWeight.SEMI_BOLD;
1593             else return FontWeight.BOLD;
1594 
1595         } else if (fontName.contains(&quot;light&quot;)) {
1596             if (fontName.contains(&quot;extra&quot;)) return FontWeight.EXTRA_LIGHT;
1597             if (fontName.contains(&quot;ultra&quot;)) return FontWeight.EXTRA_LIGHT;
1598             else return FontWeight.LIGHT;
1599 
1600         } else if (fontName.contains(&quot;black&quot;)) {
1601             return FontWeight.BLACK;
1602 
1603         } else if (fontName.contains(&quot;heavy&quot;)) {
1604             return FontWeight.BLACK;
1605 
1606         } else if (fontName.contains(&quot;medium&quot;)) {
1607             return FontWeight.MEDIUM;
1608         }
1609 
1610         return FontWeight.NORMAL;
1611 
1612     }
1613 
1614     /*package access for testing*/ String getFontFamily(Font font) {
1615         if (font == null) return Font.getDefault().getFamily();
1616         return font.getFamily();
1617     }
1618 
1619 
1620     /*package access for testing*/ Font deriveFont(
1621             Font font,
1622             String fontFamily,
1623             FontWeight fontWeight,
1624             FontPosture fontPosture,
1625             double fontSize) {
1626 
1627         if (font != null &amp;&amp; fontFamily == null) fontFamily = getFontFamily(font);
1628         else if (fontFamily != null) fontFamily = Utils.stripQuotes(fontFamily);
1629 
1630         if (font != null &amp;&amp; fontWeight == null) fontWeight = getFontWeight(font);
1631         if (font != null &amp;&amp; fontPosture == null) fontPosture = getFontPosture(font);
1632         if (font != null &amp;&amp; fontSize &lt;= 0) fontSize = font.getSize();
1633 
1634         return  Font.font(
1635                 fontFamily,
1636                 fontWeight,
1637                 fontPosture,
1638                 fontSize);
1639     }
1640 
1641     /**
1642      * Look up a font property. This is handled separately from lookup since
1643      * font is inherited and has sub-properties. One should expect that the
1644      * text font for the following would be 16px Arial. The lookup method would
1645      * give 16px system since it would look &lt;em&gt;only&lt;/em&gt; for font-size,
1646      * font-family, etc &lt;em&gt;only&lt;/em&gt; if the lookup on font failed.
1647      * &lt;pre&gt;
1648      * Text text = new Text(&quot;Hello World&quot;);
1649      * text.setStyle(&quot;-fx-font-size: 16px;&quot;);
1650      * Group group = new Group();
1651      * group.setStyle(&quot;-fx-font: 12px Arial;&quot;);
1652      * group.getChildren().add(text);
1653      * &lt;/pre&gt;
1654      */
1655      /*package access for testing*/ CalculatedValue lookupFont(
1656             final Styleable styleable,
1657             final String property,
1658             final StyleMap styleMap,
1659             final CalculatedValue cachedFont)
1660     {
1661 
1662         StyleOrigin origin = null;
1663 
1664         // How far from this node did we travel to find a font shorthand?
1665         // Don&#39;t look past this distance for other font properties.
1666         int distance = 0;
1667 
1668         // Did we find a style?
1669         boolean foundStyle = false;
1670 
1671         String family = null;
1672         double size = -1;
1673         FontWeight weight = null;
1674         FontPosture posture = null;
1675 
1676         CalculatedValue cvFont = cachedFont;
1677 
1678 
1679         Set&lt;PseudoClass&gt; states = styleable instanceof Node ? ((Node)styleable).pseudoClassStates : styleable.getPseudoClassStates();
1680 
1681         // RT-20145 - if looking for font size and the node has a font,
1682         // use the font property&#39;s value if it was set by the user and
1683         // there is not an inline or author style.
1684 
1685         if (cacheContainer.fontProp != null) {
1686             StyleableProperty&lt;Font&gt; styleableProp = cacheContainer.fontProp.getStyleableProperty(styleable);
1687             StyleOrigin fpOrigin = styleableProp.getStyleOrigin();
1688             Font font = styleableProp.getValue();
1689             if (font == null) font = Font.getDefault();
1690             if (fpOrigin == StyleOrigin.USER) {
1691                 origin = fpOrigin;
1692                 family = getFontFamily(font);
1693                 size = font.getSize();
1694                 weight = getFontWeight(font);
1695                 posture = getFontPosture(font);
1696                 cvFont = new CalculatedValue(font, fpOrigin, false);
1697             }
1698         }
1699 
1700         CalculatedValue parentCachedFont = getCachedFont(styleable.getStyleableParent());
1701         if (parentCachedFont == null) parentCachedFont = new CalculatedValue(Font.getDefault(), null, false);
1702 
1703         //
1704         // Look up the font- properties
1705         //
1706         CascadingStyle fontShorthand = getStyle(styleable, property, styleMap, states);
1707 
1708         // don&#39;t look past current node for font shorthand if user set the font
1709         if (fontShorthand == null &amp;&amp; origin != StyleOrigin.USER) {
1710 
1711             Styleable parent = styleable != null ? styleable.getStyleableParent() : null;
1712 
1713             while (parent != null) { // This loop traverses through all ancestors till root
1714 
1715                 CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
1716                 if (parentStyleHelper != null) {
1717 
1718                     distance += 1;
1719 
1720                     StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);
1721                     Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1722                     CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1723 
1724                     if (cascadingStyle != null) {
1725 
1726                         final ParsedValue cssValue = cascadingStyle.getParsedValue();
1727 
1728                         if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
1729                             fontShorthand = cascadingStyle;
1730                             break;
1731                         }
1732                     }
1733 
1734                 }
1735 
1736                 parent = parent.getStyleableParent();
1737 
1738             }
1739 
1740         }
1741 
1742         if (fontShorthand != null) {
1743 
1744             //
1745             // If we don&#39;t have an existing font, or if the origin of the
1746             // existing font is less than that of the shorthand, then
1747             // take the shorthand. If the origins compare equals, then take
1748             // the shorthand since the fontProp value will not have been
1749             // updated yet.
1750             //
1751             if (origin == null || origin.compareTo(fontShorthand.getOrigin()) &lt;= 0) {
1752 
1753                 final CalculatedValue cv =
1754                         calculateValue(fontShorthand, styleable, dummyFontProperty,
1755                                 styleMap, states, styleable, parentCachedFont);
1756 
1757                 // cv could be SKIP
1758                 if (cv.getValue() instanceof Font) {
1759                     origin = cv.getOrigin();
1760                     Font font = (Font)cv.getValue();
1761                     family = getFontFamily(font);
1762                     size = font.getSize();
1763                     weight = getFontWeight(font);
1764                     posture = getFontPosture(font);
1765                     cvFont = cv;
1766                     foundStyle = true;
1767                 }
1768 
1769             }
1770         }
1771 
1772         CascadingStyle fontSize = getStyle(styleable, property.concat(&quot;-size&quot;), styleMap, states);
1773         if (fontSize != null) {
1774             // if we have a font shorthand and it is more specific than font-size, then don&#39;t use the font-size style
1775             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontSize) &lt; 0) {
1776                 fontSize = null;
1777             } else if (origin == StyleOrigin.USER) {
1778                 // If fontSize is an inline or author-stylesheet style, use it.
1779                 // Otherwise, fontSize is a user-agent stylesheet style and should not override the USER style.
1780                 if (StyleOrigin.USER.compareTo(fontSize.getOrigin()) &gt; 0) {
1781                     fontSize = null;
1782                 }
1783             }
1784         } else if (origin != StyleOrigin.USER) {
1785             //
1786             // If we don&#39;t have a font-size, see if there is an inherited font-size.
1787             // If lookupInheritedFontProperty returns other than null, then we know that font-size is closer (more specific)
1788             // than the font shorthand
1789             //
1790             fontSize = lookupInheritedFontProperty(styleable, property.concat(&quot;-size&quot;), styleMap, distance, fontShorthand);
1791         }
1792 
1793         if (fontSize != null) {
1794 
1795             // The logic above ensures that, if fontSize is not null, then it is either
1796             // 1) a style matching this node and is more specific than the font shorthand or
1797             // 2) an inherited style that is more specific than the font shorthand
1798             // and, therefore, we can use the fontSize style
1799 
1800             final CalculatedValue cv =
1801                     calculateValue(fontSize, styleable, dummyFontProperty,
1802                             styleMap, states, styleable, parentCachedFont);
1803 
1804             if (cv.getValue() instanceof Double) {
1805                 if (origin == null || origin.compareTo(fontSize.getOrigin()) &lt;= 0) {
1806 
1807                     origin = cv.getOrigin();
1808                 }
1809                 size = (Double) cv.getValue();
1810 
1811                 if (cvFont != null) {
1812                     boolean isRelative = cvFont.isRelative() || cv.isRelative();
1813                     Font font = deriveFont((Font) cvFont.getValue(), family, weight, posture, size);
1814                     cvFont = new CalculatedValue(font, origin, isRelative);
1815                 } else {
1816                     boolean isRelative = cv.isRelative();
1817                     Font font = deriveFont(Font.getDefault(), family, weight, posture, size);
1818                     cvFont = new CalculatedValue(font, origin, isRelative);
1819                 }
1820                 foundStyle = true;
1821             }
1822 
1823         }
1824 
1825         // if cachedFont is null, then we&#39;re in this method to look up a font for the CacheContainer&#39;s fontSizeCache
1826         // and we only care about font-size or the size from font shorthand.
1827         if (cachedFont == null) {
1828             return (cvFont != null) ? cvFont : SKIP;
1829         }
1830 
1831         CascadingStyle fontWeight = getStyle(styleable, property.concat(&quot;-weight&quot;), styleMap, states);
1832         if (fontWeight != null) {
1833             // if we have a font shorthand and it is more specific than font-weight, then don&#39;t use the font-weight style
1834             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontWeight) &lt; 0) {
1835                 fontWeight = null;
1836             }
1837 
1838         } else if (origin != StyleOrigin.USER) {
1839             //
1840             // If we don&#39;t have a font-weight, see if there is an inherited font-weight.
1841             // If lookupInheritedFontProperty returns other than null, then we know that font-weight is closer (more specific)
1842             // than the font shorthand
1843             //
1844             fontWeight = lookupInheritedFontProperty(styleable, property.concat(&quot;-weight&quot;), styleMap, distance, fontShorthand);
1845         }
1846 
1847         if (fontWeight != null) {
1848 
1849             // The logic above ensures that, if fontWeight is not null, then it is either
1850             // 1) a style matching this node and is more specific than the font shorthand or
1851             // 2) an inherited style that is more specific than the font shorthand
1852             // and, therefore, we can use the fontWeight style
1853 
1854             final CalculatedValue cv =
1855                     calculateValue(fontWeight, styleable, dummyFontProperty,
1856                             styleMap, states, styleable, null);
1857 
1858             if (cv.getValue() instanceof FontWeight) {
1859                 if (origin == null || origin.compareTo(fontWeight.getOrigin()) &lt;= 0) {
1860                     origin = cv.getOrigin();
1861                 }
1862                 weight = (FontWeight)cv.getValue();
1863                 foundStyle = true;
1864             }
1865         }
1866 
1867 
1868         CascadingStyle fontStyle = getStyle(styleable, property.concat(&quot;-style&quot;), styleMap, states);
1869         if (fontStyle != null) {
1870             // if we have a font shorthand and it is more specific than font-style, then don&#39;t use the font-style style
1871             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontStyle) &lt; 0) {
1872                 fontStyle = null;
1873             }
1874 
1875         } else if (origin != StyleOrigin.USER) {
1876             //
1877             // If we don&#39;t have a font-style, see if there is an inherited font-style.
1878             // If lookupInheritedFontProperty returns other than null, then we know that font-style is closer (more specific)
1879             // than the font shorthand
1880             //
1881             fontStyle = lookupInheritedFontProperty(styleable, property.concat(&quot;-style&quot;), styleMap, distance, fontShorthand);
1882         }
1883 
1884         if (fontStyle != null) {
1885 
1886             // The logic above ensures that, if fontStyle is not null, then it is either
1887             // 1) a style matching this node and is more specific than the font shorthand or
1888             // 2) an inherited style that is more specific than the font shorthand
1889             // and, therefore, we can use the fontStyle style
1890 
1891             final CalculatedValue cv =
1892                     calculateValue(fontStyle, styleable, dummyFontProperty,
1893                             styleMap, states, styleable, null);
1894 
1895             if (cv.getValue() instanceof FontPosture) {
1896                 if (origin == null || origin.compareTo(fontStyle.getOrigin()) &lt;= 0) {
1897                     origin = cv.getOrigin();
1898                 }
1899                 posture = (FontPosture)cv.getValue();
1900                 foundStyle = true;
1901             }
1902 
1903         }
1904 
1905         CascadingStyle fontFamily = getStyle(styleable, property.concat(&quot;-family&quot;), styleMap, states);
1906         if (fontFamily != null) {
1907             // if we have a font shorthand and it is more specific than font-family, then don&#39;t use the font-family style
1908             if (fontShorthand != null &amp;&amp; fontShorthand.compareTo(fontFamily) &lt; 0) {
1909                 fontFamily = null;
1910             }
1911 
1912         } else if (origin != StyleOrigin.USER) {
1913             //
1914             // If we don&#39;t have a font-family, see if there is an inherited font-family.
1915             // If lookupInheritedFontProperty returns other than null, then we know that font-family is closer (more specific)
1916             // than the font shorthand
1917             //
1918             fontFamily = lookupInheritedFontProperty(styleable, property.concat(&quot;-family&quot;), styleMap, distance, fontShorthand);
1919         }
1920 
1921         if (fontFamily != null) {
1922 
1923             // The logic above ensures that, if fontFamily is not null, then it is either
1924             // 1) a style matching this node and is more specific than the font shorthand or
1925             // 2) an inherited style that is more specific than the font shorthand
1926             // and, therefore, we can use the fontFamily style
1927 
1928             final CalculatedValue cv =
1929                     calculateValue(fontFamily, styleable, dummyFontProperty,
1930                             styleMap, states, styleable, null);
1931 
1932             if (cv.getValue() instanceof String) {
1933                 if (origin == null || origin.compareTo(fontFamily.getOrigin()) &lt;= 0) {
1934                     origin = cv.getOrigin();
1935                 }
1936                 family = (String)cv.getValue();
1937                 foundStyle = true;
1938             }
1939 
1940         }
1941 
1942         if (foundStyle) {
1943 
1944             Font font = cvFont != null ? (Font)cvFont.getValue() : Font.getDefault();
1945             Font derivedFont = deriveFont(font, family, weight, posture, size);
1946             return new CalculatedValue(derivedFont,origin,false);
1947 
1948         }
1949 
1950         return SKIP;
1951     }
1952 
1953     private CascadingStyle lookupInheritedFontProperty(
1954             final Styleable styleable,
1955             final String property,
1956             final StyleMap styleMap,
1957             final int distance,
1958             CascadingStyle fontShorthand) {
1959 
1960         Styleable parent = styleable != null ? styleable.getStyleableParent() : null;
1961 
1962         int nlooks = distance;
1963         while (parent != null &amp;&amp; nlooks &gt; 0) { // This loop traverses through all ancestors till root
1964 
1965             CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;
1966             if (parentStyleHelper != null) {
1967 
1968                 nlooks -= 1;
1969 
1970                 StyleMap parentStyleMap = parentStyleHelper.getStyleMap((parent));
1971                 Set&lt;PseudoClass&gt; transitionStates = ((Node)parent).pseudoClassStates;
1972                 CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);
1973 
1974                 if (cascadingStyle != null) {
1975 
1976                     // If we are closer to the node than the font shorthand, then font shorthand doesn&#39;t matter.
1977                     // If the font shorthand and this style are the same distance, then we need to compare.
1978                     if (fontShorthand != null &amp;&amp; nlooks == 0) {
1979                         if (fontShorthand.compareTo(cascadingStyle) &lt; 0) {
1980                             return null;
1981                         }
1982                     }
1983 
1984                     final ParsedValue cssValue = cascadingStyle.getParsedValue();
1985 
1986                     if (&quot;inherit&quot;.equals(cssValue.getValue()) == false) {
1987                         return cascadingStyle;
1988                     }
1989                 }
1990 
1991             }
1992 
1993             parent = parent.getStyleableParent();
1994 
1995         }
1996 
1997         return null;
1998     }
1999 
2000 
2001     /**
2002      * Called from Node NodeHelper.getMatchingStyles
2003      * @param styleable
2004      * @param styleableProperty
2005      * @return
2006      */
2007     static List&lt;Style&gt; getMatchingStyles(final Styleable styleable, final CssMetaData styleableProperty) {
2008 
2009         if (!(styleable instanceof Node)) return Collections.&lt;Style&gt;emptyList();
2010 
2011         Node node = (Node)styleable;
2012         final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);
2013 
2014         if (helper != null) {
2015             return helper.getMatchingStyles(node, styleableProperty, false);
2016         }
2017         else {
2018             return Collections.&lt;Style&gt;emptyList();
2019         }
2020     }
2021 
2022     static Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getMatchingStyles(Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map, final Node node) {
2023 
2024         final CssStyleHelper helper = (node.styleHelper != null) ? node.styleHelper : createStyleHelper(node);
2025         if (helper != null) {
2026             if (map == null) map = new HashMap&lt;&gt;();
2027             for (CssMetaData metaData : node.getCssMetaData()) {
2028                 List&lt;Style&gt; styleList = helper.getMatchingStyles(node, metaData, true);
2029                 if (styleList != null &amp;&amp; !styleList.isEmpty()) {
2030                     StyleableProperty prop = metaData.getStyleableProperty(node);
2031                     map.put(prop, styleList);
2032                 }
2033             }
2034         }
2035 
2036         if (node instanceof Parent) {
2037             for (Node child : ((Parent)node).getChildren()) {
2038                 map = getMatchingStyles(map, child);
2039             }
2040         }
2041 
2042         return map;
2043     }
2044 
2045     private List&lt;Style&gt; getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, boolean matchState) {
2046 
2047         final List&lt;CascadingStyle&gt; styleList = new ArrayList&lt;&gt;();
2048 
2049         getMatchingStyles(node, styleableProperty, styleList, matchState);
2050 
2051         List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; subProperties = styleableProperty.getSubProperties();
2052         if (subProperties != null) {
2053             for (int n=0,nMax=subProperties.size(); n&lt;nMax; n++) {
2054                 final CssMetaData subProperty = subProperties.get(n);
2055                 getMatchingStyles(node, subProperty, styleList, matchState);
2056             }
2057         }
2058 
2059         Collections.sort(styleList);
2060 
2061         final List&lt;Style&gt; matchingStyles = new ArrayList&lt;&gt;(styleList.size());
2062         for (int n=0,nMax=styleList.size(); n&lt;nMax; n++) {
2063             final Style style = styleList.get(n).getStyle();
2064             if (!matchingStyles.contains(style)) matchingStyles.add(style);
2065         }
2066 
2067         return matchingStyles;
2068     }
2069 
2070     private void getMatchingStyles(final Styleable node, final CssMetaData styleableProperty, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {
2071 
2072         if (node != null) {
2073 
2074             String property = styleableProperty.getProperty();
2075             Node _node = node instanceof Node ? (Node)node : null;
2076             final StyleMap smap = getStyleMap(_node);
2077             if (smap == null) return;
2078 
2079             if (matchState) {
2080                 CascadingStyle cascadingStyle = getStyle(node, styleableProperty.getProperty(), smap, _node.pseudoClassStates);
2081                 if (cascadingStyle != null) {
2082                     styleList.add(cascadingStyle);
2083                     final ParsedValue parsedValue = cascadingStyle.getParsedValue();
2084                     getMatchingLookupStyles(node, parsedValue, styleList, matchState);
2085                 }
2086             }  else {
2087 
2088                 Map&lt;String, List&lt;CascadingStyle&gt;&gt; cascadingStyleMap = smap.getCascadingStyles();
2089                 // StyleMap.getCascadingStyles() does not return null
2090                 List&lt;CascadingStyle&gt; styles = cascadingStyleMap.get(property);
2091 
2092                 if (styles != null) {
2093                     styleList.addAll(styles);
2094                     for (int n=0, nMax=styles.size(); n&lt;nMax; n++) {
2095                         final CascadingStyle style = styles.get(n);
2096                         final ParsedValue parsedValue = style.getParsedValue();
2097                         getMatchingLookupStyles(node, parsedValue, styleList, matchState);
2098                     }
2099                 }
2100             }
2101 
2102             if (styleableProperty.isInherits()) {
2103                 Styleable parent = node.getStyleableParent();
2104                 while (parent != null) { // This loop traverses through all ancestors till root
2105                     CssStyleHelper parentHelper = parent instanceof Node
2106                             ? ((Node)parent).styleHelper
2107                             : null;
2108                     if (parentHelper != null) {
2109                         parentHelper.getMatchingStyles(parent, styleableProperty, styleList, matchState);
2110                     }
2111                     parent = parent.getStyleableParent();
2112                 }
2113             }
2114 
2115         }
2116 
2117     }
2118 
2119     // Pretty much a duplicate of resolveLookups, but without the state
2120     private void getMatchingLookupStyles(final Styleable node, final ParsedValue parsedValue, final List&lt;CascadingStyle&gt; styleList, boolean matchState) {
2121 
2122         if (parsedValue.isLookup()) {
2123 
2124             Object value = parsedValue.getValue();
2125 
2126             if (value instanceof String) {
2127 
2128                 final String property = (String)value;
2129                 // gather up any and all styles that contain this value as a property
2130                 Styleable parent = node;
2131                 do {
2132 
2133                     final Node _parent = parent instanceof Node ? (Node)parent : null;
2134                     final CssStyleHelper helper = _parent != null
2135                             ? _parent.styleHelper
2136                             : null;
2137                     if (helper != null) {
2138 
2139                         StyleMap styleMap = helper.getStyleMap(parent);
2140                         if (styleMap == null || styleMap.isEmpty()) continue;
2141 
2142                         final int start = styleList.size();
2143 
2144                         if (matchState) {
2145                             CascadingStyle cascadingStyle = helper.resolveRef(_parent, property, styleMap, _parent.pseudoClassStates);
2146                             if (cascadingStyle != null) {
2147                                 styleList.add(cascadingStyle);
2148                             }
2149                         } else {
2150                             final Map&lt;String, List&lt;CascadingStyle&gt;&gt; smap = styleMap.getCascadingStyles();
2151                             // getCascadingStyles does not return null
2152                             List&lt;CascadingStyle&gt; styles = smap.get(property);
2153 
2154                             if (styles != null) {
2155                                 styleList.addAll(styles);
2156                             }
2157 
2158                         }
2159 
2160                         final int end = styleList.size();
2161 
2162                         for (int index=start; index&lt;end; index++) {
2163                             final CascadingStyle style = styleList.get(index);
2164                             getMatchingLookupStyles(parent, style.getParsedValue(), styleList, matchState);
2165                         }
2166                     }
2167 
2168                 } while ((parent = parent.getStyleableParent()) != null); // This loop traverses through all ancestors till root
2169 
2170             }
2171         }
2172 
2173         // If the value doesn&#39;t contain any values that need lookup, then bail
2174         if (!parsedValue.isContainsLookups()) {
2175             return;
2176         }
2177 
2178         final Object val = parsedValue.getValue();
2179         if (val instanceof ParsedValue[][]) {
2180         // If ParsedValue is a layered sequence of values, resolve the lookups for each.
2181             final ParsedValue[][] layers = (ParsedValue[][])val;
2182             for (int l=0; l&lt;layers.length; l++) {
2183                 for (int ll=0; ll&lt;layers[l].length; ll++) {
2184                     if (layers[l][ll] == null) continue;
2185                         getMatchingLookupStyles(node, layers[l][ll], styleList, matchState);
2186                 }
2187             }
2188 
2189         } else if (val instanceof ParsedValue[]) {
2190         // If ParsedValue is a sequence of values, resolve the lookups for each.
2191             final ParsedValue[] layer = (ParsedValue[])val;
2192             for (int l=0; l&lt;layer.length; l++) {
2193                 if (layer[l] == null) continue;
2194                     getMatchingLookupStyles(node, layer[l], styleList, matchState);
2195             }
2196         }
2197 
2198     }
2199 
2200 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>