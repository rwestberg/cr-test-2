<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.animation;
  27 
  28 import java.util.HashMap;
  29 
  30 import com.sun.javafx.tk.Toolkit;
  31 import javafx.beans.property.BooleanProperty;
  32 import javafx.beans.property.DoubleProperty;
  33 import javafx.beans.property.DoublePropertyBase;
  34 import javafx.beans.property.IntegerProperty;
  35 import javafx.beans.property.IntegerPropertyBase;
  36 import javafx.beans.property.ObjectProperty;
  37 import javafx.beans.property.ObjectPropertyBase;
  38 import javafx.beans.property.ReadOnlyDoubleProperty;
  39 import javafx.beans.property.ReadOnlyDoublePropertyBase;
  40 import javafx.beans.property.ReadOnlyObjectProperty;
  41 import javafx.beans.property.ReadOnlyObjectPropertyBase;
  42 import javafx.beans.property.SimpleBooleanProperty;
  43 import javafx.beans.property.SimpleObjectProperty;
  44 import javafx.collections.FXCollections;
  45 import javafx.collections.ObservableMap;
  46 import javafx.event.ActionEvent;
  47 import javafx.event.EventHandler;
  48 import javafx.util.Duration;
  49 import com.sun.javafx.animation.TickCalculation;
  50 import com.sun.scenario.animation.AbstractMasterTimer;
  51 import com.sun.scenario.animation.shared.ClipEnvelope;
  52 import com.sun.scenario.animation.shared.PulseReceiver;
  53 
  54 import static com.sun.javafx.animation.TickCalculation.*;
  55 import java.security.AccessControlContext;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 
  59 /**
  60  * The class {@code Animation} provides the core functionality of all animations
  61  * used in the JavaFX runtime.
  62  * &lt;p&gt;
  63  * An animation can run in a loop by setting {@link #cycleCountProperty() cycleCount}.
  64  * To make an animation run back and forth while looping, set the
  65  * {@link #autoReverseProperty() autoReverse} -flag.
  66  * &lt;p&gt;
  67  * Call {@link #play()} or {@link #playFromStart()} to play an {@code Animation}
  68  * . The {@code Animation} progresses in the direction and speed specified by
  69  * {@link #rateProperty() rate}, and stops when its duration is elapsed. An {@code Animation}
  70  * with indefinite duration (a {@link #cycleCountProperty() cycleCount} of {@link #INDEFINITE}) runs
  71  * repeatedly until the {@link #stop()} method is explicitly called, which will
  72  * stop the running {@code Animation} and reset its play head to the initial
  73  * position.
  74  * &lt;p&gt;
  75  * An {@code Animation} can be paused by calling {@link #pause()}, and the next
  76  * {@link #play()} call will resume the {@code Animation} from where it was
  77  * paused.
  78  * &lt;p&gt;
  79  * An {@code Animation}&#39;s play head can be randomly positioned, whether it is
  80  * running or not. If the {@code Animation} is running, the play head jumps to
  81  * the specified position immediately and continues playing from new position.
  82  * If the {@code Animation} is not running, the next {@link #play()} will start
  83  * the {@code Animation} from the specified position.
  84  * &lt;p&gt;
  85  * Inverting the value of {@link #rateProperty() rate} toggles the play direction.
  86  *
  87  * @see Timeline
  88  * @see Transition
  89  *
  90  * @since JavaFX 2.0
  91  */
  92 public abstract class Animation {
  93 
  94     static {
  95         AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
  96     }
  97 
  98     /**
  99      * Used to specify an animation that repeats indefinitely, until the
 100      * {@code stop()} method is called.
 101      */
 102     public static final int INDEFINITE = -1;
 103 
 104     /**
 105      * The possible states for {@link Animation#statusProperty() status}.
 106      * @since JavaFX 2.0
 107      */
 108     public static enum Status {
 109         /**
 110          * The paused state.
 111          */
 112         PAUSED,
 113         /**
 114          * The running state.
 115          */
 116         RUNNING,
 117         /**
 118          * The stopped state.
 119          */
 120         STOPPED
 121     }
 122 
 123     private static final double EPSILON = 1e-12;
 124 
 125     /*
 126         These four fields and associated methods were moved here from AnimationPulseReceiver
 127         when that class was removed. They could probably be integrated much cleaner into Animation,
 128         but to make sure the change was made without introducing regressions, this code was
 129         moved pretty much verbatim.
 130      */
 131     private long startTime;
 132     private long pauseTime;
 133     private boolean paused = false;
 134     private final AbstractMasterTimer timer;
 135 
 136     // Access control context, captured whenever we add this pulse reciever to
 137     // the master timer (which is called when an animation is played or resumed)
 138     private AccessControlContext accessCtrlCtx = null;
 139 
 140     private long now() {
 141         return TickCalculation.fromNano(timer.nanos());
 142     }
 143 
 144     private void addPulseReceiver() {
 145         // Capture the Access Control Context to be used during the animation pulse
 146         accessCtrlCtx = AccessController.getContext();
 147 
 148         timer.addPulseReceiver(pulseReceiver);
 149     }
 150 
 151     void startReceiver(long delay) {
 152         paused = false;
 153         startTime = now() + delay;
 154         addPulseReceiver();
 155     }
 156 
 157     void pauseReceiver() {
 158         if (!paused) {
 159             pauseTime = now();
 160             paused = true;
 161             timer.removePulseReceiver(pulseReceiver);
 162         }
 163     }
 164 
 165     void resumeReceiver() {
 166         if (paused) {
 167             final long deltaTime = now() - pauseTime;
 168             startTime += deltaTime;
 169             paused = false;
 170             addPulseReceiver();
 171         }
 172     }
 173 
 174     // package private only for the sake of testing
 175     final PulseReceiver pulseReceiver = new PulseReceiver() {
 176         @Override public void timePulse(long now) {
 177             final long elapsedTime = now - startTime;
 178             if (elapsedTime &lt; 0) {
 179                 return;
 180             }
 181             if (accessCtrlCtx == null) {
 182                 throw new IllegalStateException(&quot;Error: AccessControlContext not captured&quot;);
 183             }
 184 
 185             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 186                 doTimePulse(elapsedTime);
 187                 return null;
 188             }, accessCtrlCtx);
 189         }
 190     };
 191 
 192     private class CurrentRateProperty extends ReadOnlyDoublePropertyBase {
 193         private double value;
 194 
 195         @Override
 196         public Object getBean() {
 197             return Animation.this;
 198         }
 199 
 200         @Override
 201         public String getName() {
 202             return &quot;currentRate&quot;;
 203         }
 204 
 205         @Override
 206         public double get() {
 207             return value;
 208         }
 209 
 210         private void set(double value) {
 211             this.value = value;
 212             fireValueChangedEvent();
 213         }
 214     }
 215 
 216     private class AnimationReadOnlyProperty&lt;T&gt; extends ReadOnlyObjectPropertyBase&lt;T&gt; {
 217 
 218         private final String name;
 219         private T value;
 220 
 221         private AnimationReadOnlyProperty(String name, T value) {
 222             this.name = name;
 223             this.value = value;
 224         }
 225 
 226         @Override
 227         public Object getBean() {
 228             return Animation.this;
 229         }
 230 
 231         @Override
 232         public String getName() {
 233             return name;
 234         }
 235 
 236         @Override
 237         public T get() {
 238             return value;
 239         }
 240 
 241         private void set(T value) {
 242             this.value = value;
 243             fireValueChangedEvent();
 244         }
 245     }
 246 
 247     /**
 248      * The parent of this {@code Animation}. If this animation has not been
 249      * added to another animation, such as {@link ParallelTransition} and
 250      * {@link SequentialTransition}, then parent will be null.
 251      *
 252      * @defaultValue null
 253      */
 254     Animation parent = null;
 255 
 256     /* Package-private for testing purposes */
 257     ClipEnvelope clipEnvelope;
 258 
<a name="2" id="anc2"></a><span class="line-modified"> 259     private boolean lastPlayedFinished = false;</span>
 260 
 261     private boolean lastPlayedForward = true;
 262     /**
 263      * Defines the direction/speed at which the {@code Animation} is expected to
 264      * be played.
 265      * &lt;p&gt;
 266      * The absolute value of {@code rate} indicates the speed at which the
 267      * {@code Animation} is to be played, while the sign of {@code rate}
 268      * indicates the direction. A positive value of {@code rate} indicates
 269      * forward play, a negative value indicates backward play and {@code 0.0} to
 270      * stop a running {@code Animation}.
 271      * &lt;p&gt;
 272      * Rate {@code 1.0} is normal play, {@code 2.0} is 2 time normal,
 273      * {@code -1.0} is backwards, etc.
 274      *
 275      * &lt;p&gt;
 276      * Inverting the rate of a running {@code Animation} will cause the
 277      * {@code Animation} to reverse direction in place and play back over the
 278      * portion of the {@code Animation} that has already elapsed.
 279      *
 280      * @defaultValue 1.0
 281      */
 282     private DoubleProperty rate;
 283     private static final double DEFAULT_RATE = 1.0;
 284 
 285     public final void setRate(double value) {
 286         if ((rate != null) || (Math.abs(value - DEFAULT_RATE) &gt; EPSILON)) {
 287             rateProperty().set(value);
 288         }
 289     }
 290 
 291     public final double getRate() {
 292         return (rate == null)? DEFAULT_RATE : rate.get();
 293     }
 294 
 295     public final DoubleProperty rateProperty() {
 296         if (rate == null) {
 297             rate = new DoublePropertyBase(DEFAULT_RATE) {
 298 
 299                 @Override
 300                 public void invalidated() {
 301                     final double newRate = getRate();
 302                     if (isRunningEmbedded()) {
 303                         if (isBound()) {
 304                             unbind();
 305                         }
 306                         set(oldRate);
 307                         throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);
 308                     } else {
 309                         if (Math.abs(newRate) &lt; EPSILON) {
 310                             if (getStatus() == Status.RUNNING) {
 311                                 lastPlayedForward = (Math.abs(getCurrentRate()
 312                                         - oldRate) &lt; EPSILON);
 313                             }
 314                             doSetCurrentRate(0.0);
 315                             pauseReceiver();
 316                         } else {
 317                             if (getStatus() == Status.RUNNING) {
 318                                 final double currentRate = getCurrentRate();
 319                                 if (Math.abs(currentRate) &lt; EPSILON) {
 320                                     doSetCurrentRate(lastPlayedForward ? newRate : -newRate);
 321                                     resumeReceiver();
 322                                 } else {
 323                                     final boolean playingForward = Math.abs(currentRate - oldRate) &lt; EPSILON;
 324                                     doSetCurrentRate(playingForward ? newRate : -newRate);
 325                                 }
 326                             }
 327                             oldRate = newRate;
 328                         }
 329                         clipEnvelope.setRate(newRate);
 330                     }
 331                 }
 332 
 333                 @Override
 334                 public Object getBean() {
 335                     return Animation.this;
 336                 }
 337 
 338                 @Override
 339                 public String getName() {
 340                     return &quot;rate&quot;;
 341                 }
 342             };
 343         }
 344         return rate;
 345     }
 346 
 347     private boolean isRunningEmbedded() {
 348         if (parent == null) {
 349             return false;
 350         }
 351         return parent.getStatus() != Status.STOPPED || parent.isRunningEmbedded();
 352     }
 353 
 354     private double oldRate = 1.0;
 355     /**
 356      * Read-only variable to indicate current direction/speed at which the
 357      * {@code Animation} is being played.
 358      * &lt;p&gt;
 359      * {@code currentRate} is not necessarily equal to {@code rate}.
 360      * {@code currentRate} is set to {@code 0.0} when animation is paused or
 361      * stopped. {@code currentRate} may also point in the opposite direction of {@code rate} during
 362      * reverse cycles when {@code autoReverse} is {@code true}.
 363      *
 364      * @defaultValue 0.0
 365      */
 366     private ReadOnlyDoubleProperty currentRate;
 367     private static final double DEFAULT_CURRENT_RATE = 0.0;
 368 
 369     private void doSetCurrentRate(double value) {
 370         if ((currentRate != null) || (Math.abs(value - DEFAULT_CURRENT_RATE) &gt; EPSILON)) {
 371             ((CurrentRateProperty)currentRateProperty()).set(value);
 372         }
 373     }
 374 
 375     public final double getCurrentRate() {
 376         return (currentRate == null)? DEFAULT_CURRENT_RATE : currentRate.get();
 377     }
 378 
 379     public final ReadOnlyDoubleProperty currentRateProperty() {
 380         if (currentRate == null) {
 381             currentRate = new CurrentRateProperty();
 382         }
 383         return currentRate;
 384     }
 385 
 386     /**
 387      * Read-only variable to indicate the duration of one cycle of this
 388      * {@code Animation}: the time it takes to play from time 0 to the
 389      * end of the Animation (at the default {@code rate} of
 390      * 1.0).
 391      *
 392      * @defaultValue 0ms
 393      */
 394     private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
 395     private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
 396 
 397     protected final void setCycleDuration(Duration value) {
 398         if ((cycleDuration != null) || (!DEFAULT_CYCLE_DURATION.equals(value))) {
 399             if (value.lessThan(Duration.ZERO)) {
 400                 throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
 401             }
 402             ((AnimationReadOnlyProperty&lt;Duration&gt;)cycleDurationProperty()).set(value);
 403             updateTotalDuration();
 404         }
 405     }
 406 
 407     public final Duration getCycleDuration() {
 408         return (cycleDuration == null)? DEFAULT_CYCLE_DURATION : cycleDuration.get();
 409     }
 410 
 411     public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
 412         if (cycleDuration == null) {
 413             cycleDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);
 414         }
 415         return cycleDuration;
 416     }
 417 
 418     /**
 419      * Read-only variable to indicate the total duration of this
 420      * {@code Animation}, including repeats. A {@code Animation} with a {@code cycleCount}
 421      * of {@code Animation.INDEFINITE} will have a {@code totalDuration} of
 422      * {@code Duration.INDEFINITE}.
 423      *
 424      * &lt;p&gt;
 425      * This is set to cycleDuration * cycleCount.
 426      *
 427      * @defaultValue 0ms
 428      */
 429     private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
 430     private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
 431 
 432     public final Duration getTotalDuration() {
 433         return (totalDuration == null)? DEFAULT_TOTAL_DURATION : totalDuration.get();
 434     }
 435 
 436     public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
 437         if (totalDuration == null) {
 438             totalDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);
 439         }
 440         return totalDuration;
 441     }
 442 
 443     private void updateTotalDuration() {
 444         // Implementing the bind eagerly, because cycleCount and
 445         // cycleDuration should not change that often
 446         final int cycleCount = getCycleCount();
 447         final Duration cycleDuration = getCycleDuration();
 448         final Duration newTotalDuration = Duration.ZERO.equals(cycleDuration) ? Duration.ZERO
 449                 : (cycleCount == Animation.INDEFINITE) ? Duration.INDEFINITE
 450                         : (cycleCount &lt;= 1) ? cycleDuration : cycleDuration
 451                                 .multiply(cycleCount);
 452         if ((totalDuration != null) || (!DEFAULT_TOTAL_DURATION.equals(newTotalDuration))) {
 453             ((AnimationReadOnlyProperty&lt;Duration&gt;)totalDurationProperty()).set(newTotalDuration);
 454         }
 455         if (getStatus() == Status.STOPPED) {
 456             syncClipEnvelope();
 457             if (newTotalDuration.lessThan(getCurrentTime())) {
 458                 clipEnvelope.jumpTo(fromDuration(newTotalDuration));
 459             }
 460         }
 461     }
 462 
 463     /**
 464      * Defines the {@code Animation}&#39;s play head position.
 465      *
 466      * @defaultValue 0ms
 467      */
 468     private CurrentTimeProperty currentTime;
 469     private long currentTicks;
 470     private class CurrentTimeProperty extends ReadOnlyObjectPropertyBase&lt;Duration&gt; {
 471 
 472         @Override
 473         public Object getBean() {
 474             return Animation.this;
 475         }
 476 
 477         @Override
 478         public String getName() {
 479             return &quot;currentTime&quot;;
 480         }
 481 
 482         @Override
 483         public Duration get() {
 484             return getCurrentTime();
 485         }
 486 
 487         @Override
 488         public void fireValueChangedEvent() {
 489             super.fireValueChangedEvent();
 490         }
 491 
 492     }
 493 
 494     public final Duration getCurrentTime() {
 495         return TickCalculation.toDuration(currentTicks);
 496     }
 497 
 498     public final ReadOnlyObjectProperty&lt;Duration&gt; currentTimeProperty() {
 499         if (currentTime == null) {
 500             currentTime = new CurrentTimeProperty();
 501         }
 502         return currentTime;
 503     }
 504 
 505     /**
 506      * Delays the start of an animation.
 507      *
 508      * Cannot be negative. Setting to a negative number will result in {@link IllegalArgumentException}.
 509      *
 510      * @defaultValue 0ms
 511      */
 512     private ObjectProperty&lt;Duration&gt; delay;
 513     private static final Duration DEFAULT_DELAY = Duration.ZERO;
 514 
 515     public final void setDelay(Duration value) {
 516         if ((delay != null) || (!DEFAULT_DELAY.equals(value))) {
 517             delayProperty().set(value);
 518         }
 519     }
 520 
 521     public final Duration getDelay() {
 522         return (delay == null)? DEFAULT_DELAY : delay.get();
 523     }
 524 
 525     public final ObjectProperty&lt;Duration&gt; delayProperty() {
 526         if (delay == null) {
 527             delay = new ObjectPropertyBase&lt;Duration&gt;(DEFAULT_DELAY) {
 528 
 529                 @Override
 530                 public Object getBean() {
 531                     return Animation.this;
 532                 }
 533 
 534                 @Override
 535                 public String getName() {
 536                     return &quot;delay&quot;;
 537                 }
 538 
 539                 @Override
 540                 protected void invalidated() {
 541                         final Duration newDuration = get();
 542                         if (newDuration.lessThan(Duration.ZERO)) {
 543                             if (isBound()) {
 544                                 unbind();
 545                             }
 546                             set(Duration.ZERO);
 547                             throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);
 548                         }
 549                 }
 550 
 551             };
 552         }
 553         return delay;
 554     }
 555 
 556     /**
 557      * Defines the number of cycles in this animation. The {@code cycleCount}
 558      * may be {@code INDEFINITE} for animations that repeat indefinitely, but
 559      * must otherwise be {@literal &gt;} 0.
 560      * &lt;p&gt;
 561      * It is not possible to change the {@code cycleCount} of a running
 562      * {@code Animation}. If the value of {@code cycleCount} is changed for a
 563      * running {@code Animation}, the animation has to be stopped and started again to pick
 564      * up the new value.
 565      *
 566      * @defaultValue 1
 567      */
 568     private IntegerProperty cycleCount;
 569     private static final int DEFAULT_CYCLE_COUNT = 1;
 570 
 571     public final void setCycleCount(int value) {
 572         if ((cycleCount != null) || (value != DEFAULT_CYCLE_COUNT)) {
 573             cycleCountProperty().set(value);
 574         }
 575     }
 576 
 577     public final int getCycleCount() {
 578         return (cycleCount == null)? DEFAULT_CYCLE_COUNT : cycleCount.get();
 579     }
 580 
 581     public final IntegerProperty cycleCountProperty() {
 582         if (cycleCount == null) {
 583             cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
 584 
 585                 @Override
 586                 public void invalidated() {
 587                     updateTotalDuration();
 588                 }
 589 
 590                 @Override
 591                 public Object getBean() {
 592                     return Animation.this;
 593                 }
 594 
 595                 @Override
 596                 public String getName() {
 597                     return &quot;cycleCount&quot;;
 598                 }
 599             };
 600         }
 601         return cycleCount;
 602     }
 603 
 604     /**
 605      * Defines whether this
 606      * {@code Animation} reverses direction on alternating cycles. If
 607      * {@code true}, the
 608      * {@code Animation} will proceed forward on the first cycle,
 609      * then reverses on the second cycle, and so on. Otherwise, animation will
 610      * loop such that each cycle proceeds forward from the start.
 611      *
 612      * It is not possible to change the {@code autoReverse} flag of a running
 613      * {@code Animation}. If the value of {@code autoReverse} is changed for a
 614      * running {@code Animation}, the animation has to be stopped and started again to pick
 615      * up the new value.
 616      *
 617      * @defaultValue false
 618      */
 619     private BooleanProperty autoReverse;
 620     private static final boolean DEFAULT_AUTO_REVERSE = false;
 621 
 622     public final void setAutoReverse(boolean value) {
 623         if ((autoReverse != null) || (value != DEFAULT_AUTO_REVERSE)) {
 624             autoReverseProperty().set(value);
 625         }
 626     }
 627 
 628     public final boolean isAutoReverse() {
 629         return (autoReverse == null)? DEFAULT_AUTO_REVERSE : autoReverse.get();
 630     }
 631 
 632     public final BooleanProperty autoReverseProperty() {
 633         if (autoReverse == null) {
 634             autoReverse = new SimpleBooleanProperty(this, &quot;autoReverse&quot;, DEFAULT_AUTO_REVERSE);
 635         }
 636         return autoReverse;
 637     }
 638 
 639     /**
 640      * The status of the {@code Animation}.
 641      *
 642      * An {@code Animation} can be in one of three states:
 643      * {@link Status#STOPPED}, {@link Status#PAUSED} or {@link Status#RUNNING}.
 644      */
 645     private ReadOnlyObjectProperty&lt;Status&gt; status;
 646     private static final Status DEFAULT_STATUS = Status.STOPPED;
 647 
 648     protected final void setStatus(Status value) {
 649         if ((status != null) || (!DEFAULT_STATUS.equals(value))) {
 650             ((AnimationReadOnlyProperty&lt;Status&gt;)statusProperty()).set(value);
 651         }
 652     }
 653 
 654     public final Status getStatus() {
 655         return (status == null)? DEFAULT_STATUS : status.get();
 656     }
 657 
 658     public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
 659         if (status == null) {
 660             status = new AnimationReadOnlyProperty&lt;Status&gt;(&quot;status&quot;, Status.STOPPED);
 661         }
 662         return status;
 663     }
 664 
 665     private final double targetFramerate;
 666     private final int resolution;
 667     private long lastPulse;
 668 
 669     /**
 670      * The target framerate is the maximum framerate at which this {@code Animation}
 671      * will run, in frames per second. This can be used, for example, to keep
 672      * particularly complex {@code Animations} from over-consuming system resources.
 673      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning
 674      * the {@code Animation} will run at an optimal framerate for the underlying platform.
 675      *
 676      * @return the target framerate
 677      */
 678     public final double getTargetFramerate() {
 679         return targetFramerate;
 680     }
 681 
 682     /**
 683      * The action to be executed at the conclusion of this {@code Animation}.
 684      *
 685      * @defaultValue null
 686      */
 687     private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
 688     private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
 689 
 690     public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
 691         if ((onFinished != null) || (value != null /* DEFAULT_ON_FINISHED */)) {
 692             onFinishedProperty().set(value);
 693         }
 694     }
 695 
 696     public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
 697         return (onFinished == null)? DEFAULT_ON_FINISHED : onFinished.get();
 698     }
 699 
 700     public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
 701         if (onFinished == null) {
 702             onFinished = new SimpleObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt;(this, &quot;onFinished&quot;, DEFAULT_ON_FINISHED);
 703         }
 704         return onFinished;
 705     }
 706 
 707     private final ObservableMap&lt;String, Duration&gt; cuePoints = FXCollections
 708             .observableMap(new HashMap&lt;String, Duration&gt;(0));
 709 
 710     /**
 711      * The cue points can be
 712      * used to mark important positions of the {@code Animation}. Once a cue
 713      * point was defined, it can be used as an argument of
 714      * {@link #jumpTo(String) jumpTo()} and {@link #playFrom(String) playFrom()}
 715      * to move to the associated position quickly.
 716      * &lt;p&gt;
 717      * Every {@code Animation} has two predefined cue points {@code &quot;start&quot;} and
 718      * {@code &quot;end&quot;}, which are set at the start respectively the end of the
 719      * {@code Animation}. The predefined cuepoints do not appear in the map,
 720      * attempts to override them have no effect.
 721      * &lt;p&gt;
 722      * Another option to define a cue point in a {@code Animation} is to set the
 723      * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
 724      *
 725      * @return {@link javafx.collections.ObservableMap} of cue points
 726      */
 727     public final ObservableMap&lt;String, Duration&gt; getCuePoints() {
 728         return cuePoints;
 729     }
 730 
 731     /**
 732      * Jumps to a given position in this {@code Animation}.
 733      *
 734      * If the given time is less than {@link Duration#ZERO}, this method will
 735      * jump to the start of the animation. If the given time is larger than the
 736      * duration of this {@code Animation}, this method will jump to the end.
 737      *
 738      * @param time
 739      *            the new position
 740      * @throws NullPointerException
 741      *             if {@code time} is {@code null}
 742      * @throws IllegalArgumentException
 743      *             if {@code time} is {@link Duration#UNKNOWN}
 744      * @throws IllegalStateException
 745      *             if embedded in another animation,
 746      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 747      */
 748     public void jumpTo(Duration time) {
 749         if (time == null) {
 750             throw new NullPointerException(&quot;Time needs to be specified.&quot;);
 751         }
 752         if (time.isUnknown()) {
 753             throw new IllegalArgumentException(&quot;The time is invalid&quot;);
 754         }
 755         if (parent != null) {
 756             throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
 757         }
 758 
 759         lastPlayedFinished = false;
 760 
 761         final Duration totalDuration = getTotalDuration();
 762         time = time.lessThan(Duration.ZERO) ? Duration.ZERO : time
 763                 .greaterThan(totalDuration) ? totalDuration : time;
 764         final long ticks = fromDuration(time);
 765 
 766         if (getStatus() == Status.STOPPED) {
 767             syncClipEnvelope();
 768         }
 769         clipEnvelope.jumpTo(ticks);
 770     }
 771 
 772     /**
 773      * Jumps to a predefined position in this {@code Animation}. This method
 774      * looks for an entry in cue points and jumps to the associated
 775      * position, if it finds one.
 776      * &lt;p&gt;
 777      * If the cue point is behind the end of this {@code Animation}, calling
 778      * {@code jumpTo} will result in a jump to the end. If the cue point has a
 779      * negative {@link javafx.util.Duration} it will result in a jump to the
 780      * beginning. If the cue point has a value of
 781      * {@link javafx.util.Duration#UNKNOWN} calling {@code jumpTo} will have no
 782      * effect for this cue point.
 783      * &lt;p&gt;
 784      * There are two predefined cue points {@code &quot;start&quot;} and {@code &quot;end&quot;}
 785      * which are defined to be at the start respectively the end of this
 786      * {@code Animation}.
 787      *
 788      * @param cuePoint
 789      *            the name of the cue point
 790      * @throws NullPointerException
 791      *             if {@code cuePoint} is {@code null}
 792      * @throws IllegalStateException
 793      *             if embedded in another animation,
 794      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 795      * @see #getCuePoints()
 796      */
 797     public void jumpTo(String cuePoint) {
 798         if (cuePoint == null) {
 799             throw new NullPointerException(&quot;CuePoint needs to be specified&quot;);
 800         }
 801         if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
 802             jumpTo(Duration.ZERO);
 803         } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
 804             jumpTo(getTotalDuration());
 805         } else {
 806             final Duration target = getCuePoints().get(cuePoint);
 807             if (target != null) {
 808                 jumpTo(target);
 809             }
 810         }
 811     }
 812 
 813     /**
 814      * A convenience method to play this {@code Animation} from a predefined
 815      * position. The position has to be predefined in cue points.
 816      * Calling this method is equivalent to
 817      *
 818      * &lt;pre&gt;
 819      * &lt;code&gt;
 820      * animation.jumpTo(cuePoint);
 821      * animation.play();
 822      * &lt;/code&gt;
 823      * &lt;/pre&gt;
 824      *
 825      * Note that unlike {@link #playFromStart()} calling this method will not
 826      * change the playing direction of this {@code Animation}.
 827      *
 828      * @param cuePoint
 829      *            name of the cue point
 830      * @throws NullPointerException
 831      *             if {@code cuePoint} is {@code null}
 832      * @throws IllegalStateException
 833      *             if embedded in another animation,
 834      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 835      * @see #getCuePoints()
 836      */
 837     public void playFrom(String cuePoint) {
 838         jumpTo(cuePoint);
 839         play();
 840     }
 841 
 842     /**
 843      * A convenience method to play this {@code Animation} from a specific
 844      * position. Calling this method is equivalent to
 845      *
 846      * &lt;pre&gt;
 847      * &lt;code&gt;
 848      * animation.jumpTo(time);
 849      * animation.play();
 850      * &lt;/code&gt;
 851      * &lt;/pre&gt;
 852      *
 853      * Note that unlike {@link #playFromStart()} calling this method will not
 854      * change the playing direction of this {@code Animation}.
 855      *
 856      * @param time
 857      *            position where to play from
 858      * @throws NullPointerException
 859      *             if {@code time} is {@code null}
 860      * @throws IllegalArgumentException
 861      *             if {@code time} is {@link Duration#UNKNOWN}
 862      * @throws IllegalStateException
 863      *             if embedded in another animation,
 864      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 865      */
 866     public void playFrom(Duration time) {
 867         jumpTo(time);
 868         play();
 869     }
 870 
 871     /**
 872      * Plays {@code Animation} from current position in the direction indicated
 873      * by {@code rate}. If the {@code Animation} is running, it has no effect.
 874      * &lt;p&gt;
 875      * When {@code rate} {@literal &gt;} 0 (forward play), if an {@code Animation} is already
 876      * positioned at the end, the first cycle will not be played, it is
 877      * considered to have already finished. This also applies to a backward (
 878      * {@code rate} {@literal &lt;} 0) cycle if an {@code Animation} is positioned at the beginning.
 879      * However, if the {@code Animation} has {@code cycleCount} {@literal &gt;} 1, following
 880      * cycle(s) will be played as usual.
 881      * &lt;p&gt;
 882      * When the {@code Animation} reaches the end, the {@code Animation} is stopped and
 883      * the play head remains at the end.
 884      * &lt;p&gt;
 885      * To play an {@code Animation} backwards from the end:&lt;br&gt;
 886      * &lt;code&gt;
 887      *  animation.setRate(negative rate);&lt;br&gt;
 888      *  animation.jumpTo(overall duration of animation);&lt;br&gt;
 889      *  animation.play();&lt;br&gt;
 890      * &lt;/code&gt;
 891      * &lt;p&gt;
 892      * Note: &lt;ul&gt;
 893      * &lt;li&gt;{@code play()} is an asynchronous call, the {@code Animation} may not
 894      * start immediately. &lt;/ul&gt;
 895      *
 896      * @throws IllegalStateException
 897      *             if embedded in another animation,
 898      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 899      */
 900     public void play() {
 901         if (parent != null) {
 902             throw new IllegalStateException(&quot;Cannot start when embedded in another animation&quot;);
 903         }
 904         switch (getStatus()) {
 905             case STOPPED:
 906                 if (startable(true)) {
 907                     final double rate = getRate();
 908                     if (lastPlayedFinished) {
 909                         jumpTo((rate &lt; 0)? getTotalDuration() : Duration.ZERO);
 910                     }
 911                     doStart(true);
 912                     startReceiver(TickCalculation.fromDuration(getDelay()));
 913                     if (Math.abs(rate) &lt; EPSILON) {
 914                         pauseReceiver();
 915                     } else {
 916 
 917                     }
 918                 } else {
 919                     final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();
 920                     if (handler != null) {
 921                         handler.handle(new ActionEvent(this, null));
 922                     }
 923                 }
 924                 break;
 925             case PAUSED:
 926                 doResume();
 927                 if (Math.abs(getRate()) &gt;= EPSILON) {
 928                     resumeReceiver();
 929                 }
 930                 break;
 931         }
 932     }
 933 
 934     /**
 935      * Plays an {@code Animation} from initial position in forward direction.
 936      * &lt;p&gt;
 937      * It is equivalent to
 938      * &lt;p&gt;
 939      * &lt;code&gt;
 940      *      animation.stop();&lt;br&gt;
 941      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;
 942      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;
 943      *      animation.play();&lt;br&gt;
 944      *  &lt;/code&gt;
 945      *
 946      * &lt;p&gt;
 947      * Note: &lt;ul&gt;
 948      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may
 949      * not start immediately. &lt;/ul&gt;
 950      *
 951      * @throws IllegalStateException
 952      *             if embedded in another animation,
 953      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 954      */
 955     public void playFromStart() {
 956         stop();
 957         setRate(Math.abs(getRate()));
 958         jumpTo(Duration.ZERO);
 959         play();
 960     }
 961 
 962     /**
 963      * Stops the animation and resets the play head to its initial position. If
 964      * the animation is not currently running, this method has no effect.
 965      * &lt;p&gt;
 966      * Note: &lt;ul&gt;
 967      * &lt;li&gt;{@code stop()} is an asynchronous call, the {@code Animation} may not stop
 968      * immediately. &lt;/ul&gt;
 969      * @throws IllegalStateException
 970      *             if embedded in another animation,
 971      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 972      */
 973     public void stop() {
 974         if (parent != null) {
 975             throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
 976         }
 977         if (getStatus() != Status.STOPPED) {
 978             clipEnvelope.abortCurrentPulse();
 979             doStop();
 980             jumpTo(Duration.ZERO);
<a name="3" id="anc3"></a>
 981         }
 982     }
 983 
 984     /**
 985      * Pauses the animation. If the animation is not currently running, this
 986      * method has no effect.
 987      * &lt;p&gt;
 988      * Note: &lt;ul&gt;
 989      * &lt;li&gt;{@code pause()} is an asynchronous call, the {@code Animation} may not pause
 990      * immediately. &lt;/ul&gt;
 991      * @throws IllegalStateException
 992      *             if embedded in another animation,
 993      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 994      */
 995     public void pause() {
 996         if (parent != null) {
 997             throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
 998         }
 999         if (getStatus() == Status.RUNNING) {
1000             clipEnvelope.abortCurrentPulse();
1001             pauseReceiver();
1002             doPause();
1003         }
1004     }
1005 
1006     /**
1007      * The constructor of {@code Animation}.
1008      *
1009      * This constructor allows to define a target framerate.
1010      *
1011      * @param targetFramerate
1012      *            The custom target frame rate for this {@code Animation}
1013      * @see #getTargetFramerate()
1014      */
1015     protected Animation(double targetFramerate) {
1016         this.targetFramerate = targetFramerate;
1017         this.resolution = (int) Math.max(1, Math.round(TickCalculation.TICKS_PER_SECOND / targetFramerate));
1018         this.clipEnvelope = ClipEnvelope.create(this);
1019         this.timer = Toolkit.getToolkit().getMasterTimer();
1020     }
1021 
1022     /**
1023      * The constructor of {@code Animation}.
1024      */
1025     protected Animation() {
1026         this.resolution = 1;
1027         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / Toolkit.getToolkit().getMasterTimer().getDefaultResolution();
1028         this.clipEnvelope = ClipEnvelope.create(this);
1029         this.timer = Toolkit.getToolkit().getMasterTimer();
1030     }
1031 
1032     // These constructors are only for testing purposes
1033     Animation(AbstractMasterTimer timer) {
1034         this.resolution = 1;
1035         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / timer.getDefaultResolution();
1036         this.clipEnvelope = ClipEnvelope.create(this);
1037         this.timer = timer;
1038     }
1039 
1040     // These constructors are only for testing purposes
1041     Animation(AbstractMasterTimer timer, ClipEnvelope clipEnvelope, int resolution) {
1042         this.resolution = resolution;
1043         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / resolution;
1044         this.clipEnvelope = clipEnvelope;
1045         this.timer = timer;
1046     }
1047 
1048     boolean startable(boolean forceSync) {
1049         return (fromDuration(getCycleDuration()) &gt; 0L)
1050                 || (!forceSync &amp;&amp; clipEnvelope.wasSynched());
1051     }
1052 
1053     void sync(boolean forceSync) {
1054         if (forceSync || !clipEnvelope.wasSynched()) {
1055             syncClipEnvelope();
1056         }
1057     }
1058 
1059     private void syncClipEnvelope() {
1060         final int publicCycleCount = getCycleCount();
1061         final int internalCycleCount = (publicCycleCount &lt;= 0)
1062                 &amp;&amp; (publicCycleCount != INDEFINITE) ? 1 : publicCycleCount;
1063         clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
1064         clipEnvelope.setCycleDuration(getCycleDuration());
1065         clipEnvelope.setAutoReverse(isAutoReverse());
1066     }
1067 
1068     void doStart(boolean forceSync) {
1069         sync(forceSync);
1070         setStatus(Status.RUNNING);
1071         clipEnvelope.start();
1072         doSetCurrentRate(clipEnvelope.getCurrentRate());
1073         lastPulse = 0;
1074     }
1075 
1076     void doPause() {
1077         final double currentRate = getCurrentRate();
1078         if (Math.abs(currentRate) &gt;= EPSILON) {
1079             lastPlayedForward = Math.abs(getCurrentRate() - getRate()) &lt; EPSILON;
1080         }
1081         doSetCurrentRate(0.0);
1082         setStatus(Status.PAUSED);
1083     }
1084 
1085     void doResume() {
1086         setStatus(Status.RUNNING);
1087         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());
1088     }
1089 
1090     void doStop() {
1091         if (!paused) {
1092             timer.removePulseReceiver(pulseReceiver);
1093         }
1094         setStatus(Status.STOPPED);
1095         doSetCurrentRate(0.0);
1096     }
1097 
1098     void doTimePulse(long elapsedTime) {
1099         if (resolution == 1) { // fullspeed
1100             clipEnvelope.timePulse(elapsedTime);
1101         } else if (elapsedTime - lastPulse &gt;= resolution) {
1102             lastPulse = (elapsedTime / resolution) * resolution;
1103             clipEnvelope.timePulse(elapsedTime);
1104         }
1105     }
1106 
1107     abstract void doPlayTo(long currentTicks, long cycleTicks);
1108 
1109     abstract void doJumpTo(long currentTicks, long cycleTicks, boolean forceJump);
1110 
1111     void setCurrentTicks(long ticks) {
1112         currentTicks = ticks;
1113         if (currentTime != null) {
1114             currentTime.fireValueChangedEvent();
1115         }
1116     }
1117 
1118     void setCurrentRate(double currentRate) {
1119 //        if (getStatus() == Status.RUNNING) {
1120             doSetCurrentRate(currentRate);
1121 //        }
1122     }
1123 
1124     final void finished() {
1125         lastPlayedFinished = true;
1126         doStop();
1127         final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();
1128         if (handler != null) {
1129             try {
1130                 handler.handle(new ActionEvent(this, null));
1131             } catch (Exception ex) {
1132                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);
1133             }
1134         }
1135     }
1136 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>