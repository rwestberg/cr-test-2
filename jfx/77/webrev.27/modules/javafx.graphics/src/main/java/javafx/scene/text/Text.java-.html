<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/javafx/scene/text/Text.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.text;
  27 
  28 import javafx.css.converter.BooleanConverter;
  29 import javafx.css.converter.EnumConverter;
  30 import javafx.css.converter.SizeConverter;
  31 import com.sun.javafx.geom.BaseBounds;
  32 import com.sun.javafx.geom.Path2D;
  33 import com.sun.javafx.geom.RectBounds;
  34 import com.sun.javafx.geom.TransformedShape;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.scene.DirtyBits;
  37 import com.sun.javafx.scene.NodeHelper;
  38 import com.sun.javafx.scene.shape.ShapeHelper;
  39 import com.sun.javafx.scene.shape.TextHelper;
  40 import com.sun.javafx.scene.text.GlyphList;
  41 import com.sun.javafx.scene.text.TextLayout;
  42 import com.sun.javafx.scene.text.TextLayoutFactory;
  43 import com.sun.javafx.scene.text.TextLine;
  44 import com.sun.javafx.scene.text.TextSpan;
  45 import com.sun.javafx.sg.prism.NGNode;
  46 import com.sun.javafx.sg.prism.NGShape;
  47 import com.sun.javafx.sg.prism.NGText;
  48 import com.sun.javafx.scene.text.FontHelper;
  49 import com.sun.javafx.tk.Toolkit;
  50 import javafx.beans.DefaultProperty;
  51 import javafx.beans.InvalidationListener;
  52 import javafx.beans.binding.DoubleBinding;
  53 import javafx.beans.binding.ObjectBinding;
  54 import javafx.scene.AccessibleAttribute;
  55 import javafx.scene.AccessibleRole;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.shape.LineTo;
  59 import javafx.scene.shape.MoveTo;
  60 import javafx.scene.shape.PathElement;
  61 import javafx.scene.shape.Shape;
  62 import javafx.scene.shape.StrokeType;
  63 import java.util.ArrayList;
  64 import java.util.Collections;
  65 import java.util.List;
  66 import javafx.beans.property.BooleanProperty;
  67 import javafx.beans.property.DoubleProperty;
  68 import javafx.beans.property.DoublePropertyBase;
  69 import javafx.beans.property.IntegerProperty;
  70 import javafx.beans.property.IntegerPropertyBase;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyDoubleProperty;
  74 import javafx.beans.property.ReadOnlyDoubleWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.property.StringProperty;
  79 import javafx.beans.property.StringPropertyBase;
  80 import javafx.css.CssMetaData;
  81 import javafx.css.FontCssMetaData;
  82 import javafx.css.Styleable;
  83 import javafx.css.StyleableBooleanProperty;
  84 import javafx.css.StyleableDoubleProperty;
  85 import javafx.css.StyleableIntegerProperty;
  86 import javafx.css.StyleableObjectProperty;
  87 import javafx.css.StyleableProperty;
  88 import javafx.geometry.BoundingBox;
  89 import javafx.geometry.Bounds;
  90 import javafx.geometry.NodeOrientation;
  91 import javafx.geometry.Point2D;
  92 import javafx.geometry.VPos;
  93 import javafx.scene.Node;
  94 
  95 /**
  96  * The {@code Text} class defines a node that displays a text.
  97  *
  98  * Paragraphs are separated by {@code &#39;\n&#39;} and the text is wrapped on
  99  * paragraph boundaries.
 100  *
 101 &lt;PRE&gt;
 102 import javafx.scene.text.*;
 103 
 104 Text t = new Text(10, 50, &quot;This is a test&quot;);
 105 t.setFont(new Font(20));
 106 &lt;/PRE&gt;
 107  *
 108 &lt;PRE&gt;
 109 import javafx.scene.text.*;
 110 
 111 Text t = new Text();
 112 text.setFont(new Font(20));
 113 text.setText(&quot;First row\nSecond row&quot;);
 114 &lt;/PRE&gt;
 115  *
 116 &lt;PRE&gt;
 117 import javafx.scene.text.*;
 118 
 119 Text t = new Text();
 120 text.setFont(new Font(20));
 121 text.setWrappingWidth(200);
 122 text.setTextAlignment(TextAlignment.JUSTIFY)
 123 text.setText(&quot;The quick brown fox jumps over the lazy dog&quot;);
 124 &lt;/PRE&gt;
 125  * @since JavaFX 2.0
 126  */
 127 @DefaultProperty(&quot;text&quot;)
 128 public class Text extends Shape {
 129     static {
 130         TextHelper.setTextAccessor(new TextHelper.TextAccessor() {
 131             @Override
 132             public NGNode doCreatePeer(Node node) {
 133                 return ((Text) node).doCreatePeer();
 134             }
 135 
 136             @Override
 137             public void doUpdatePeer(Node node) {
 138                 ((Text) node).doUpdatePeer();
 139             }
 140 
 141             @Override
 142             public Bounds doComputeLayoutBounds(Node node) {
 143                 return ((Text) node).doComputeLayoutBounds();
 144             }
 145 
 146             @Override
 147             public BaseBounds doComputeGeomBounds(Node node,
 148                     BaseBounds bounds, BaseTransform tx) {
 149                 return ((Text) node).doComputeGeomBounds(bounds, tx);
 150             }
 151 
 152             @Override
 153             public boolean doComputeContains(Node node, double localX, double localY) {
 154                 return ((Text) node).doComputeContains(localX, localY);
 155             }
 156 
 157             @Override
 158             public void doGeomChanged(Node node) {
 159                 ((Text) node).doGeomChanged();
 160             }
 161 
 162             @Override
 163             public com.sun.javafx.geom.Shape doConfigShape(Shape shape) {
 164                 return ((Text) shape).doConfigShape();
 165             }
 166         });
 167     }
 168 
 169     private TextLayout layout;
 170     private static final PathElement[] EMPTY_PATH_ELEMENT_ARRAY = new PathElement[0];
 171 
 172     {
 173         // To initialize the class helper at the begining each constructor of this class
 174         TextHelper.initHelper(this);
 175     }
 176 
 177     /**
 178      * Creates an empty instance of Text.
 179      */
 180     public Text() {
 181         setAccessibleRole(AccessibleRole.TEXT);
 182         InvalidationListener listener = observable -&gt; checkSpan();
 183         parentProperty().addListener(listener);
 184         managedProperty().addListener(listener);
 185         effectiveNodeOrientationProperty().addListener(observable -&gt; checkOrientation());
 186         setPickOnBounds(true);
 187     }
 188 
 189     /**
 190      * Creates an instance of Text containing the given string.
 191      * @param text text to be contained in the instance
 192      */
 193     public Text(String text) {
 194         this();
 195         setText(text);
 196     }
 197 
 198     /**
 199      * Creates an instance of Text on the given coordinates containing the
 200      * given string.
 201      * @param x the horizontal position of the text
 202      * @param y the vertical position of the text
 203      * @param text text to be contained in the instance
 204      */
 205     public Text(double x, double y, String text) {
 206         this(text);
 207         setX(x);
 208         setY(y);
 209     }
 210 
 211     /*
 212      * Note: This method MUST only be called via its accessor method.
 213      */
 214     private NGNode doCreatePeer() {
 215         return new NGText();
 216     }
 217 
 218     private boolean isSpan;
 219     private boolean isSpan() {
 220         return isSpan;
 221     }
 222 
 223     private void checkSpan() {
 224         isSpan = isManaged() &amp;&amp; getParent() instanceof TextFlow;
 225         if (isSpan() &amp;&amp; !pickOnBoundsProperty().isBound()) {
 226             /* Documented behavior. See class description for TextFlow */
 227             setPickOnBounds(false);
 228         }
 229     }
 230 
 231     private void checkOrientation() {
 232         if (!isSpan()) {
 233             NodeOrientation orientation = getEffectiveNodeOrientation();
 234             boolean rtl =  orientation == NodeOrientation.RIGHT_TO_LEFT;
 235             int dir = rtl ? TextLayout.DIRECTION_RTL : TextLayout.DIRECTION_LTR;
 236             TextLayout layout = getTextLayout();
 237             if (layout.setDirection(dir)) {
 238                 needsTextLayout();
 239             }
 240         }
 241     }
 242 
 243     @Override
 244     public boolean usesMirroring() {
 245         return false;
 246     }
 247 
 248     private void needsFullTextLayout() {
 249         if (isSpan()) {
 250             /* Create new text span every time the font or text changes
 251              * so the text layout can see that the content has changed.
 252              */
 253             textSpan = null;
 254 
 255             /* Relies on NodeHelper.geomChanged(this) to request text flow to relayout */
 256         } else {
 257             TextLayout layout = getTextLayout();
 258             String string = getTextInternal();
 259             Object font = getFontInternal();
 260             layout.setContent(string, font);
 261         }
 262         needsTextLayout();
 263     }
 264 
 265     private void needsTextLayout() {
 266         textRuns = null;
 267         NodeHelper.geomChanged(this);
 268         NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
 269     }
 270 
 271     private TextSpan textSpan;
 272     TextSpan getTextSpan() {
 273         if (textSpan == null) {
 274             textSpan = new TextSpan() {
 275                 @Override public String getText() {
 276                     return getTextInternal();
 277                 }
 278                 @Override public Object getFont() {
 279                     return getFontInternal();
 280                 }
 281                 @Override public RectBounds getBounds() {
 282                     return null;
 283                 }
 284             };
 285         }
 286         return textSpan;
 287     }
 288 
 289     private TextLayout getTextLayout() {
 290         if (isSpan()) {
 291             layout = null;
 292             TextFlow parent = (TextFlow)getParent();
 293             return parent.getTextLayout();
 294         }
 295         if (layout == null) {
 296             TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
 297             layout = factory.createLayout();
 298             String string = getTextInternal();
 299             Object font = getFontInternal();
 300             TextAlignment alignment = getTextAlignment();
 301             if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
 302             layout.setContent(string, font);
 303             layout.setAlignment(alignment.ordinal());
 304             layout.setLineSpacing((float)getLineSpacing());
 305             layout.setWrapWidth((float)getWrappingWidth());
 306             if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 307                 layout.setDirection(TextLayout.DIRECTION_RTL);
 308             } else {
 309                 layout.setDirection(TextLayout.DIRECTION_LTR);
 310             }
 311             layout.setTabSize(getTabSize());
 312         }
 313         return layout;
 314     }
 315 
 316     private GlyphList[] textRuns = null;
 317     private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
 318     private boolean spanBoundsInvalid = true;
 319 
 320     void layoutSpan(GlyphList[] runs) {
 321         TextSpan span = getTextSpan();
 322         int count = 0;
 323         for (int i = 0; i &lt; runs.length; i++) {
 324             GlyphList run = runs[i];
 325             if (run.getTextSpan() == span) {
 326                 count++;
 327             }
 328         }
 329         textRuns = new GlyphList[count];
 330         count = 0;
 331         for (int i = 0; i &lt; runs.length; i++) {
 332             GlyphList run = runs[i];
 333             if (run.getTextSpan() == span) {
 334                 textRuns[count++] = run;
 335             }
 336         }
 337         spanBoundsInvalid = true;
 338 
 339         /* Sometimes a property change in the text node will causes layout in
 340          * text flow. In this case all the dirty bits are already clear and no
 341          * extra work is necessary. Other times the layout is caused by changes
 342          * in the text flow object (wrapping width and text alignment for example).
 343          * In the second case the dirty bits must be set here using
 344          * NodeHelper.geomChanged(this) and NodeHelper.markDirty(). Note that NodeHelper.geomChanged(this)
 345          * causes another (undesired) layout request in the parent.
 346          * In general this is not a problem because shapes are not resizable and
 347          * region objects do not propagate layout changes to the parent.
 348          * This is a special case where a shape is resized by the parent during
 349          * layoutChildren(). See TextFlow#requestLayout() for information how
 350          * text flow deals with this situation.
 351          */
 352         NodeHelper.geomChanged(this);
 353         NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
 354     }
 355 
 356     BaseBounds getSpanBounds() {
 357         if (spanBoundsInvalid) {
 358             GlyphList[] runs = getRuns();
 359             if (runs.length != 0) {
 360                 float left = Float.POSITIVE_INFINITY;
 361                 float top = Float.POSITIVE_INFINITY;
 362                 float right = 0;
 363                 float bottom = 0;
 364                 for (int i = 0; i &lt; runs.length; i++) {
 365                     GlyphList run = runs[i];
 366                     com.sun.javafx.geom.Point2D location = run.getLocation();
 367                     float width = run.getWidth();
 368                     float height = run.getLineBounds().getHeight();
 369                     left = Math.min(location.x, left);
 370                     top = Math.min(location.y, top);
 371                     right = Math.max(location.x + width, right);
 372                     bottom = Math.max(location.y + height, bottom);
 373                 }
 374                 spanBounds = spanBounds.deriveWithNewBounds(left, top, 0,
 375                                                             right, bottom, 0);
 376             } else {
 377                 spanBounds = spanBounds.makeEmpty();
 378             }
 379             spanBoundsInvalid = false;
 380         }
 381         return spanBounds;
 382     }
 383 
 384     private GlyphList[] getRuns() {
 385         if (textRuns != null) return textRuns;
 386         if (isSpan()) {
 387             /* List of run is initialized when the TextFlow layout the children */
 388             getParent().layout();
 389         } else {
 390             TextLayout layout = getTextLayout();
 391             textRuns = layout.getRuns();
 392         }
 393         return textRuns;
 394     }
 395 
 396     private com.sun.javafx.geom.Shape getShape() {
 397         TextLayout layout = getTextLayout();
 398         /* TextLayout has the text shape cached */
 399         int type = TextLayout.TYPE_TEXT;
 400         if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
 401         if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
 402 
 403         TextSpan filter = null;
 404         if (isSpan()) {
 405             /* Spans are always relative to the top */
 406             type |= TextLayout.TYPE_TOP;
 407             filter = getTextSpan();
 408         } else {
 409             /* Relative to baseline (first line)
 410              * This shape can be translate in the y axis according
 411              * to text origin, see ShapeHelper.configShape().
 412              */
 413             type |= TextLayout.TYPE_BASELINE;
 414         }
 415         return layout.getShape(type, filter);
 416     }
 417 
 418     private BaseBounds getVisualBounds() {
 419         if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
 420             int type = TextLayout.TYPE_TEXT;
 421             if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
 422             if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
 423             return getTextLayout().getVisualBounds(type);
 424         } else {
 425             return getShape().getBounds();
 426         }
 427     }
 428 
 429     private BaseBounds getLogicalBounds() {
 430         TextLayout layout = getTextLayout();
 431         /* TextLayout has the bounds cached */
 432         return layout.getBounds();
 433     }
 434 
 435     /**
 436      * Defines text string that is to be displayed.
 437      *
 438      * @defaultValue empty string
 439      */
 440     private StringProperty text;
 441 
 442     public final void setText(String value) {
 443         if (value == null) value = &quot;&quot;;
 444         textProperty().set(value);
 445     }
 446 
 447     public final String getText() {
 448         return text == null ? &quot;&quot; : text.get();
 449     }
 450 
 451     private String getTextInternal() {
 452         // this might return null in case of bound property
 453         String localText = getText();
 454         return localText == null ? &quot;&quot; : localText;
 455     }
 456 
 457     public final StringProperty textProperty() {
 458         if (text == null) {
 459             text = new StringPropertyBase(&quot;&quot;) {
 460                 @Override public Object getBean() { return Text.this; }
 461                 @Override public String getName() { return &quot;text&quot;; }
 462                 @Override  public void invalidated() {
 463                     needsFullTextLayout();
 464                     setSelectionStart(-1);
 465                     setSelectionEnd(-1);
 466                     setCaretPosition(-1);
 467                     setCaretBias(true);
 468 
 469                     // MH: Functionality copied from store() method,
 470                     // which was removed.
 471                     // Wonder what should happen if text is bound
 472                     //  and becomes null?
 473                     final String value = get();
 474                     if ((value == null) &amp;&amp; !isBound()) {
 475                         set(&quot;&quot;);
 476                     }
 477                     notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
 478                 }
 479             };
 480         }
 481         return text;
 482     }
 483 
 484     /**
 485      * Defines the X coordinate of text origin.
 486      *
 487      * @defaultValue 0
 488      */
 489     private DoubleProperty x;
 490 
 491     public final void setX(double value) {
 492         xProperty().set(value);
 493     }
 494 
 495     public final double getX() {
 496         return x == null ? 0.0 : x.get();
 497     }
 498 
 499     public final DoubleProperty xProperty() {
 500         if (x == null) {
 501             x = new DoublePropertyBase() {
 502                 @Override public Object getBean() { return Text.this; }
 503                 @Override public String getName() { return &quot;x&quot;; }
 504                 @Override public void invalidated() {
 505                     NodeHelper.geomChanged(Text.this);
 506                 }
 507             };
 508         }
 509         return x;
 510     }
 511 
 512     /**
 513      * Defines the Y coordinate of text origin.
 514      *
 515      * @defaultValue 0
 516      */
 517     private DoubleProperty y;
 518 
 519     public final void setY(double value) {
 520         yProperty().set(value);
 521     }
 522 
 523     public final double getY() {
 524         return y == null ? 0.0 : y.get();
 525     }
 526 
 527     public final DoubleProperty yProperty() {
 528         if (y == null) {
 529             y = new DoublePropertyBase() {
 530                 @Override public Object getBean() { return Text.this; }
 531                 @Override public String getName() { return &quot;y&quot;; }
 532                 @Override public void invalidated() {
 533                     NodeHelper.geomChanged(Text.this);
 534                 }
 535             };
 536         }
 537         return y;
 538     }
 539 
 540     /**
 541      * Defines the font of text.
 542      *
 543      * @defaultValue Font{}
 544      */
 545     private ObjectProperty&lt;Font&gt; font;
 546 
 547     public final void setFont(Font value) {
 548         fontProperty().set(value);
 549     }
 550 
 551     public final Font getFont() {
 552         return font == null ? Font.getDefault() : font.get();
 553     }
 554 
 555     /**
 556      * Internally used safe version of getFont which never returns null.
 557      *
 558      * @return the font
 559      */
 560     private Object getFontInternal() {
 561         Font font = getFont();
 562         if (font == null) font = Font.getDefault();
 563         return FontHelper.getNativeFont(font);
 564     }
 565 
 566     public final ObjectProperty&lt;Font&gt; fontProperty() {
 567         if (font == null) {
 568             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 569                 @Override public Object getBean() { return Text.this; }
 570                 @Override public String getName() { return &quot;font&quot;; }
 571                 @Override public CssMetaData&lt;Text,Font&gt; getCssMetaData() {
 572                     return StyleableProperties.FONT;
 573                 }
 574                 @Override public void invalidated() {
 575                     needsFullTextLayout();
 576                     NodeHelper.markDirty(Text.this, DirtyBits.TEXT_FONT);
 577                 }
 578             };
 579         }
 580         return font;
 581     }
 582 
 583     public final void setTextOrigin(VPos value) {
 584         textOriginProperty().set(value);
 585     }
 586 
 587     public final VPos getTextOrigin() {
 588         if (attributes == null || attributes.textOrigin == null) {
 589             return DEFAULT_TEXT_ORIGIN;
 590         }
 591         return attributes.getTextOrigin();
 592     }
 593 
 594     /**
 595      * Defines the origin of text coordinate system in local coordinates.
 596      * Note: in case multiple rows are rendered {@code VPos.BASELINE} and
 597      * {@code VPos.TOP} define the origin of the top row while
 598      * {@code VPos.BOTTOM} defines the origin of the bottom row.
 599      *
 600      * @return the origin of text coordinate system in local coordinates
 601      * @defaultValue VPos.BASELINE
 602      */
 603     public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
 604         return getTextAttribute().textOriginProperty();
 605     }
 606 
 607     /**
 608      * Determines how the bounds of the text node are calculated.
 609      * Logical bounds is a more appropriate default for text than
 610      * the visual bounds. See {@code TextBoundsType} for more information.
 611      *
 612      * @defaultValue TextBoundsType.LOGICAL
 613      */
 614     private ObjectProperty&lt;TextBoundsType&gt; boundsType;
 615 
 616     public final void setBoundsType(TextBoundsType value) {
 617         boundsTypeProperty().set(value);
 618     }
 619 
 620     public final TextBoundsType getBoundsType() {
 621         return boundsType == null ?
 622             DEFAULT_BOUNDS_TYPE : boundsTypeProperty().get();
 623     }
 624 
 625     public final ObjectProperty&lt;TextBoundsType&gt; boundsTypeProperty() {
 626         if (boundsType == null) {
 627             boundsType =
 628                new StyleableObjectProperty&lt;TextBoundsType&gt;(DEFAULT_BOUNDS_TYPE) {
 629                    @Override public Object getBean() { return Text.this; }
 630                    @Override public String getName() { return &quot;boundsType&quot;; }
 631                    @Override public CssMetaData&lt;Text,TextBoundsType&gt; getCssMetaData() {
 632                        return StyleableProperties.BOUNDS_TYPE;
 633                    }
 634                    @Override public void invalidated() {
 635                        TextLayout layout = getTextLayout();
 636                        int type = 0;
 637                        if (boundsType.get() == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
 638                            type |= TextLayout.BOUNDS_CENTER;
 639                        }
 640                        if (layout.setBoundsType(type)) {
 641                            needsTextLayout();
 642                        } else {
 643                            NodeHelper.geomChanged(Text.this);
 644                        }
 645                    }
 646             };
 647         }
 648         return boundsType;
 649     }
 650 
 651     /**
 652      * Defines a width constraint for the text in user space coordinates.
 653      * The width is measured in pixels (and not glyph or character count).
 654      * If the value is {@code &gt; 0} text will be line wrapped as needed
 655      * to satisfy this constraint.
 656      *
 657      * @defaultValue 0
 658      */
 659     private DoubleProperty wrappingWidth;
 660 
 661     public final void setWrappingWidth(double value) {
 662         wrappingWidthProperty().set(value);
 663     }
 664 
 665     public final double getWrappingWidth() {
 666         return wrappingWidth == null ? 0 : wrappingWidth.get();
 667     }
 668 
 669     public final DoubleProperty wrappingWidthProperty() {
 670         if (wrappingWidth == null) {
 671             wrappingWidth = new DoublePropertyBase() {
 672                 @Override public Object getBean() { return Text.this; }
 673                 @Override public String getName() { return &quot;wrappingWidth&quot;; }
 674                 @Override public void invalidated() {
 675                     if (!isSpan()) {
 676                         TextLayout layout = getTextLayout();
 677                         if (layout.setWrapWidth((float)get())) {
 678                             needsTextLayout();
 679                         } else {
 680                             NodeHelper.geomChanged(Text.this);
 681                         }
 682                     }
 683                 }
 684             };
 685         }
 686         return wrappingWidth;
 687     }
 688 
 689     public final void setUnderline(boolean value) {
 690         underlineProperty().set(value);
 691     }
 692 
 693     public final boolean isUnderline() {
 694         if (attributes == null || attributes.underline == null) {
 695             return DEFAULT_UNDERLINE;
 696         }
 697         return attributes.isUnderline();
 698     }
 699 
 700     /**
 701      * Defines if each line of text should have a line below it.
 702      *
 703      * @return if each line of text should have a line below it
 704      * @defaultValue false
 705      */
 706     public final BooleanProperty underlineProperty() {
 707         return getTextAttribute().underlineProperty();
 708     }
 709 
 710     public final void setStrikethrough(boolean value) {
 711         strikethroughProperty().set(value);
 712     }
 713 
 714     public final boolean isStrikethrough() {
 715         if (attributes == null || attributes.strikethrough == null) {
 716             return DEFAULT_STRIKETHROUGH;
 717         }
 718         return attributes.isStrikethrough();
 719     }
 720 
 721     /**
 722      * Defines if each line of text should have a line through it.
 723      *
 724      * @return if each line of text should have a line through it
 725      * @defaultValue false
 726      */
 727     public final BooleanProperty strikethroughProperty() {
 728         return getTextAttribute().strikethroughProperty();
 729     }
 730 
 731     public final void setTextAlignment(TextAlignment value) {
 732         textAlignmentProperty().set(value);
 733     }
 734 
 735     public final TextAlignment getTextAlignment() {
 736         if (attributes == null || attributes.textAlignment == null) {
 737             return DEFAULT_TEXT_ALIGNMENT;
 738         }
 739         return attributes.getTextAlignment();
 740     }
 741 
 742     /**
 743      * Defines horizontal text alignment in the bounding box.
 744      *
 745      * The width of the bounding box is defined by the widest row.
 746      *
 747      * Note: In the case of a single line of text, where the width of the
 748      * node is determined by the width of the text, the alignment setting
 749      * has no effect.
 750      *
 751      * @return the horizontal text alignment in the bounding box
 752      * @defaultValue TextAlignment.LEFT
 753      */
 754     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 755         return getTextAttribute().textAlignmentProperty();
 756     }
 757 
 758     public final void setLineSpacing(double spacing) {
 759         lineSpacingProperty().set(spacing);
 760     }
 761 
 762     public final double getLineSpacing() {
 763         if (attributes == null || attributes.lineSpacing == null) {
 764             return DEFAULT_LINE_SPACING;
 765         }
 766         return attributes.getLineSpacing();
 767     }
 768 
 769     /**
 770      * Defines the vertical space in pixel between lines.
 771      *
 772      * @return the vertical space in pixel between lines
 773      * @defaultValue 0
 774      *
 775      * @since JavaFX 8.0
 776      */
 777     public final DoubleProperty lineSpacingProperty() {
 778         return getTextAttribute().lineSpacingProperty();
 779     }
 780 
 781     @Override
 782     public final double getBaselineOffset() {
 783         return baselineOffsetProperty().get();
 784     }
 785 
 786     /**
 787      * The &#39;alphabetic&#39; (or roman) baseline offset from the Text node&#39;s
 788      * layoutBounds.minY location.
 789      * The value typically corresponds to the max ascent of the font.
 790      * @return the baseline offset from this text node
 791      */
 792     public final ReadOnlyDoubleProperty baselineOffsetProperty() {
 793         return getTextAttribute().baselineOffsetProperty();
 794     }
 795 
 796     /**
 797      * Specifies a requested font smoothing type: gray or LCD.
 798      *
 799      * The width of the bounding box is defined by the widest row.
 800      *
 801      * Note: LCD mode doesn&#39;t apply in numerous cases, such as various
 802      * compositing modes, where effects are applied and very large glyphs.
 803      *
 804      * @defaultValue FontSmoothingType.GRAY
 805      * @since JavaFX 2.1
 806      */
 807     private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;
 808 
 809     public final void setFontSmoothingType(FontSmoothingType value) {
 810         fontSmoothingTypeProperty().set(value);
 811     }
 812 
 813     public final FontSmoothingType getFontSmoothingType() {
 814         return fontSmoothingType == null ?
 815             FontSmoothingType.GRAY : fontSmoothingType.get();
 816     }
 817 
 818     public final ObjectProperty&lt;FontSmoothingType&gt;
 819         fontSmoothingTypeProperty() {
 820         if (fontSmoothingType == null) {
 821             fontSmoothingType =
 822                 new StyleableObjectProperty&lt;FontSmoothingType&gt;
 823                                                (FontSmoothingType.GRAY) {
 824                 @Override public Object getBean() { return Text.this; }
 825                 @Override public String getName() { return &quot;fontSmoothingType&quot;; }
 826                 @Override public CssMetaData&lt;Text,FontSmoothingType&gt; getCssMetaData() {
 827                     return StyleableProperties.FONT_SMOOTHING_TYPE;
 828                 }
 829                 @Override public void invalidated() {
 830                     NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
 831                     NodeHelper.geomChanged(Text.this);
 832                 }
 833             };
 834         }
 835         return fontSmoothingType;
 836     }
 837 
 838     /*
 839      * Note: This method MUST only be called via its accessor method.
 840      */
 841     private void doGeomChanged() {
 842         if (attributes != null) {
 843             if (attributes.caretBinding != null) {
 844                 attributes.caretBinding.invalidate();
 845             }
 846             if (attributes.selectionBinding != null) {
 847                 attributes.selectionBinding.invalidate();
 848             }
 849         }
 850         NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
 851     }
 852 
 853     public final PathElement[] getSelectionShape() {
 854         return selectionShapeProperty().get();
 855     }
 856 
 857     /**
 858      * The shape of the selection in local coordinates.
 859      *
 860      * @return the {@code selectionShape} property
 861      *
 862      * @since 9
 863      */
 864     public final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
 865         return getTextAttribute().selectionShapeProperty();
 866     }
 867 
 868     public final void setSelectionStart(int value) {
 869         if (value == -1 &amp;&amp;
 870                 (attributes == null || attributes.selectionStart == null)) {
 871             return;
 872         }
 873         selectionStartProperty().set(value);
 874     }
 875 
 876     public final int getSelectionStart() {
 877         if (attributes == null || attributes.selectionStart == null) {
 878             return DEFAULT_SELECTION_START;
 879         }
 880         return attributes.getSelectionStart();
 881     }
 882 
 883     /**
 884      * The start index of the selection in the content.
 885      * If the value is -1, the selection is unset.
 886      *
 887      * @return the {@code selectionStart} property
 888      *
 889      * @defaultValue -1
 890      *
 891      * @since 9
 892      */
 893     public final IntegerProperty selectionStartProperty() {
 894         return getTextAttribute().selectionStartProperty();
 895     }
 896 
 897     public final void setSelectionEnd(int value) {
 898         if (value == -1 &amp;&amp;
 899                 (attributes == null || attributes.selectionEnd == null)) {
 900             return;
 901         }
 902         selectionEndProperty().set(value);
 903     }
 904 
 905     public final int getSelectionEnd() {
 906         if (attributes == null || attributes.selectionEnd == null) {
 907             return DEFAULT_SELECTION_END;
 908         }
 909         return attributes.getSelectionEnd();
 910     }
 911 
 912     /**
 913      * The end index of the selection in the content.
 914      * If the value is -1, the selection is unset.
 915      *
 916      * @return the {@code selectionEnd} property
 917      *
 918      * @defaultValue -1
 919      *
 920      * @since 9
 921      */
 922     public final IntegerProperty selectionEndProperty() {
 923         return getTextAttribute().selectionEndProperty();
 924     }
 925 
 926     /**
 927      * The fill color of selected text.
 928      *
 929      * @return the fill color of selected text
 930      * @since 9
 931      */
 932     public final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
 933         return getTextAttribute().selectionFillProperty();
 934     }
 935 
 936     public final void setSelectionFill(Paint paint) {
 937         selectionFillProperty().set(paint);
 938     }
 939     public final Paint getSelectionFill() {
 940         return selectionFillProperty().get();
 941     }
 942 
 943     public final PathElement[] getCaretShape() {
 944         return caretShapeProperty().get();
 945     }
 946 
 947     /**
 948      * The shape of caret, in local coordinates.
 949      *
 950      * @return the {@code caretShape} property
 951      *
 952      * @since 9
 953      */
 954     public final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
 955         return getTextAttribute().caretShapeProperty();
 956     }
 957 
 958     public final void setCaretPosition(int value) {
 959         if (value == -1 &amp;&amp;
 960                 (attributes == null || attributes.caretPosition == null)) {
 961             return;
 962         }
 963         caretPositionProperty().set(value);
 964     }
 965 
 966     public final int getCaretPosition() {
 967         if (attributes == null || attributes.caretPosition == null) {
 968             return DEFAULT_CARET_POSITION;
 969         }
 970         return attributes.getCaretPosition();
 971     }
 972 
 973     /**
 974      * The caret index in the content.
 975      * If the value is -1, the caret is unset.
 976      *
 977      * @return the {@code caretPosition} property
 978      *
 979      * @defaultValue -1
 980      *
 981      * @since 9
 982      */
 983     public final IntegerProperty caretPositionProperty() {
 984         return getTextAttribute().caretPositionProperty();
 985     }
 986 
 987     public final void setCaretBias(boolean value) {
 988         if (value &amp;&amp; (attributes == null || attributes.caretBias == null)) {
 989             return;
 990         }
 991         caretBiasProperty().set(value);
 992     }
 993 
 994     public final boolean isCaretBias() {
 995         if (attributes == null || attributes.caretBias == null) {
 996             return DEFAULT_CARET_BIAS;
 997         }
 998         return getTextAttribute().isCaretBias();
 999     }
1000 
1001     /**
1002      * The type of caret bias in the content. If {@code true}, the bias is towards the leading character edge,
1003      * otherwise, the bias is towards the trailing character edge.
1004      *
1005      * @return the {@code caretBias} property
1006      *
1007      * @defaultValue {@code true}
1008      *
1009      * @since 9
1010      */
1011     public final BooleanProperty caretBiasProperty() {
1012         return getTextAttribute().caretBiasProperty();
1013     }
1014 
1015     /**
1016      * Maps local point to index in the content.
1017      *
1018      * @param point the specified point to be tested
1019      * @return a {@code HitInfo} representing the character index found
1020      * @since 9
1021      */
1022     public final HitInfo hitTest(Point2D point) {
1023         if (point == null) return null;
1024         TextLayout layout = getTextLayout();
1025         double x = point.getX() - getX();
1026         double y = point.getY() - getY() + getYRendering();
1027         TextLayout.Hit layoutHit = layout.getHitInfo((float)x, (float)y);
1028         return new HitInfo(layoutHit.getCharIndex(), layoutHit.getInsertionIndex(),
1029                            layoutHit.isLeading(), getText());
1030     }
1031 
1032     private PathElement[] getRange(int start, int end, int type) {
1033         int length = getTextInternal().length();
1034         if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
1035             TextLayout layout = getTextLayout();
1036             float x = (float)getX();
1037             float y = (float)getY() - getYRendering();
1038             return layout.getRange(start, end, type, x, y);
1039         }
1040         return EMPTY_PATH_ELEMENT_ARRAY;
1041     }
1042 
1043     /**
1044      * Returns the shape for the caret at the given index and bias.
1045      *
1046      * @param charIndex the character index for the caret
1047      * @param caretBias whether the caret is biased on the leading edge of the character
1048      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1049      * @since 9
1050      */
1051     public final PathElement[] caretShape(int charIndex, boolean caretBias) {
1052         if (0 &lt;= charIndex &amp;&amp; charIndex &lt;= getTextInternal().length()) {
1053             float x = (float)getX();
1054             float y = (float)getY() - getYRendering();
1055             return getTextLayout().getCaretShape(charIndex, caretBias, x, y);
1056         } else {
1057             return null;
1058         }
1059     }
1060 
1061     /**
1062      * Returns the shape for the range of the text in local coordinates.
1063      *
1064      * @param start the beginning character index for the range
1065      * @param end the end character index (non-inclusive) for the range
1066      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1067      * @since 9
1068      */
1069     public final PathElement[] rangeShape(int start, int end) {
1070         return getRange(start, end, TextLayout.TYPE_TEXT);
1071     }
1072 
1073     /**
1074      * Returns the shape for the underline in local coordinates.
1075      *
1076      * @param start the beginning character index for the range
1077      * @param end the end character index (non-inclusive) for the range
1078      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1079      * @since 9
1080      */
1081     public final PathElement[] underlineShape(int start, int end) {
1082         return getRange(start, end, TextLayout.TYPE_UNDERLINE);
1083     }
1084 
1085     private float getYAdjustment(BaseBounds bounds) {
1086         VPos origin = getTextOrigin();
1087         if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
1088         switch (origin) {
1089         case TOP: return -bounds.getMinY();
1090         case BASELINE: return 0;
1091         case CENTER: return -bounds.getMinY() - bounds.getHeight() / 2;
1092         case BOTTOM: return -bounds.getMinY() - bounds.getHeight();
1093         default: return 0;
1094         }
1095     }
1096 
1097     private float getYRendering() {
1098         if (isSpan()) return 0;
1099 
1100         /* Always logical for rendering */
1101         BaseBounds bounds = getLogicalBounds();
1102 
1103         VPos origin = getTextOrigin();
1104         if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
1105         if (getBoundsType() == TextBoundsType.VISUAL) {
1106             BaseBounds vBounds = getVisualBounds();
1107             float delta = vBounds.getMinY() - bounds.getMinY();
1108             switch (origin) {
1109             case TOP: return delta;
1110             case BASELINE: return -vBounds.getMinY() + delta;
1111             case CENTER: return vBounds.getHeight() / 2 + delta;
1112             case BOTTOM: return vBounds.getHeight() + delta;
1113             default: return 0;
1114             }
1115         } else {
1116             switch (origin) {
1117             case TOP: return 0;
1118             case BASELINE: return -bounds.getMinY();
1119             case CENTER: return bounds.getHeight() / 2;
1120             case BOTTOM: return bounds.getHeight();
1121             default: return 0;
1122             }
1123         }
1124     }
1125 
1126     private Bounds doComputeLayoutBounds() {
1127         if (isSpan()) {
1128             BaseBounds bounds = getSpanBounds();
1129             double width = bounds.getWidth();
1130             double height = bounds.getHeight();
1131             return new BoundingBox(0, 0, width, height);
1132         }
1133 
1134         if (getBoundsType() == TextBoundsType.VISUAL) {
1135             /* In Node the layout bounds is computed based in the geom
1136              * bounds and in Shape the geom bounds is computed based
1137              * on the shape (generated here in #configShape()) */
1138             return TextHelper.superComputeLayoutBounds(this);
1139         }
1140         BaseBounds bounds = getLogicalBounds();
1141         double x = bounds.getMinX() + getX();
1142         double y = bounds.getMinY() + getY() + getYAdjustment(bounds);
1143         double width = bounds.getWidth();
1144         double height = bounds.getHeight();
1145         double wrappingWidth = getWrappingWidth();
1146         if (wrappingWidth != 0) width = wrappingWidth;
1147         return new BoundingBox(x, y, width, height);
1148     }
1149 
1150     /*
1151      * Note: This method MUST only be called via its accessor method.
1152      */
1153     private BaseBounds doComputeGeomBounds(BaseBounds bounds,
1154                                                    BaseTransform tx) {
1155         if (isSpan()) {
1156             if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
1157                 return TextHelper.superComputeGeomBounds(this, bounds, tx);
1158             }
1159             TextLayout layout = getTextLayout();
1160             bounds = layout.getBounds(getTextSpan(), bounds);
1161             BaseBounds spanBounds = getSpanBounds();
1162             float minX = bounds.getMinX() - spanBounds.getMinX();
1163             float minY = bounds.getMinY() - spanBounds.getMinY();
1164             float maxX = minX + bounds.getWidth();
1165             float maxY = minY + bounds.getHeight();
1166             bounds = bounds.deriveWithNewBounds(minX, minY, 0, maxX, maxY, 0);
1167             return tx.transform(bounds, bounds);
1168         }
1169 
1170        if (getBoundsType() == TextBoundsType.VISUAL) {
1171             if (getTextInternal().length() == 0 || ShapeHelper.getMode(this) == NGShape.Mode.EMPTY) {
1172                 return bounds.makeEmpty();
1173             }
1174             if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
1175                 /* Optimize for FILL and INNER STROKE: save the cost of shaping each glyph */
1176                 BaseBounds visualBounds = getVisualBounds();
1177                 float x = visualBounds.getMinX() + (float) getX();
1178                 float yadj = getYAdjustment(visualBounds);
1179                 float y = visualBounds.getMinY() + yadj + (float) getY();
1180                 bounds.deriveWithNewBounds(x, y, 0, x + visualBounds.getWidth(),
1181                         y + visualBounds.getHeight(), 0);
1182                 return tx.transform(bounds, bounds);
1183             } else {
1184                 /* Let the superclass compute the bounds using shape */
1185                 return TextHelper.superComputeGeomBounds(this, bounds, tx);
1186             }
1187         }
1188 
1189         BaseBounds textBounds = getLogicalBounds();
1190         float x = textBounds.getMinX() + (float)getX();
1191         float yadj = getYAdjustment(textBounds);
1192         float y = textBounds.getMinY() + yadj + (float)getY();
1193         float width = textBounds.getWidth();
1194         float height = textBounds.getHeight();
1195         float wrappingWidth = (float)getWrappingWidth();
1196         if (wrappingWidth &gt; width) {
1197             width = wrappingWidth;
1198         } else {
1199             /* The following adjustment is necessary for the text bounds to be
1200              * relative to the same location as the mirrored bounds returned
1201              * by layout.getBounds().
1202              */
1203             if (wrappingWidth &gt; 0) {
1204                 NodeOrientation orientation = getEffectiveNodeOrientation();
1205                 if (orientation == NodeOrientation.RIGHT_TO_LEFT) {
1206                     x -= width - wrappingWidth;
1207                 }
1208             }
1209         }
1210         textBounds = new RectBounds(x, y, x + width, y + height);
1211 
1212         /* handle stroked text */
1213         if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
1214             bounds = TextHelper.superComputeGeomBounds(this, bounds,
1215                     BaseTransform.IDENTITY_TRANSFORM);
1216         } else {
1217             TextLayout layout = getTextLayout();
1218             bounds = layout.getBounds(null, bounds);
1219             x = bounds.getMinX() + (float)getX();
1220             width = bounds.getWidth();
1221             bounds = bounds.deriveWithNewBounds(x, y, 0, x + width, y + height, 0);
1222         }
1223 
1224         bounds = bounds.deriveWithUnion(textBounds);
1225         return tx.transform(bounds, bounds);
1226     }
1227 
1228     /*
1229      * Note: This method MUST only be called via its accessor method.
1230      */
1231     private boolean doComputeContains(double localX, double localY) {
1232         /* Used for spans, regular text uses bounds based picking */
1233         double x = localX + getSpanBounds().getMinX();
1234         double y = localY + getSpanBounds().getMinY();
1235         GlyphList[] runs = getRuns();
1236         if (runs.length != 0) {
1237             for (int i = 0; i &lt; runs.length; i++) {
1238                 GlyphList run = runs[i];
1239                 com.sun.javafx.geom.Point2D location = run.getLocation();
1240                 float width = run.getWidth();
1241                 RectBounds lineBounds = run.getLineBounds();
1242                 float height = lineBounds.getHeight();
1243                 if (location.x &lt;= x &amp;&amp; x &lt; location.x + width &amp;&amp;
1244                     location.y &lt;= y &amp;&amp; y &lt; location.y + height) {
1245                         return true;
1246                 }
1247             }
1248         }
1249         return false;
1250     }
1251 
1252     /*
1253      * Note: This method MUST only be called via its accessor method.
1254      */
1255     private com.sun.javafx.geom.Shape doConfigShape() {
1256         if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
1257             return new Path2D();
1258         }
1259         com.sun.javafx.geom.Shape shape = getShape();
1260         float x, y;
1261         if (isSpan()) {
1262             BaseBounds bounds = getSpanBounds();
1263             x = -bounds.getMinX();
1264             y = -bounds.getMinY();
1265         } else {
1266             x = (float)getX();
1267             y = getYAdjustment(getVisualBounds()) + (float)getY();
1268         }
1269         return TransformedShape.translatedShape(shape, x, y);
1270     }
1271 
1272     /**
1273      * The size of a tab stop in spaces.
1274      * Values less than 1 are treated as 1.
1275      *
1276      * @defaultValue 8
1277      *
1278      * @since 14
1279      */
1280     public final IntegerProperty tabSizeProperty() {
1281         return getTextAttribute().tabSizeProperty();
1282     }
1283 
1284     public final int getTabSize() {
1285         if (attributes == null || attributes.tabSize == null) {
1286             return TextLayout.DEFAULT_TAB_SIZE;
1287         }
1288         return getTextAttribute().getTabSize();
1289     }
1290 
1291     public final void setTabSize(int spaces) {
1292         tabSizeProperty().set(spaces);
1293     }
1294 
1295 
1296    /***************************************************************************
1297     *                                                                         *
1298     *                            Stylesheet Handling                          *
1299     *                                                                         *
1300     **************************************************************************/
1301 
1302     /*
1303      * Super-lazy instantiation pattern from Bill Pugh.
1304      */
1305     private static class StyleableProperties {
1306 
1307         private static final CssMetaData&lt;Text,Font&gt; FONT =
1308             new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1309 
1310             @Override
1311             public boolean isSettable(Text node) {
1312                 return node.font == null || !node.font.isBound();
1313             }
1314 
1315             @Override
1316             public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
1317                 return (StyleableProperty&lt;Font&gt;)node.fontProperty();
1318             }
1319         };
1320 
1321         private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =
1322             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
1323                 BooleanConverter.getInstance(), Boolean.FALSE) {
1324 
1325             @Override
1326             public boolean isSettable(Text node) {
1327                 return node.attributes == null ||
1328                        node.attributes.underline == null ||
1329                       !node.attributes.underline.isBound();
1330             }
1331 
1332             @Override
1333             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1334                 return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
1335             }
1336         };
1337 
1338         private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =
1339             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
1340                 BooleanConverter.getInstance(), Boolean.FALSE) {
1341 
1342             @Override
1343             public boolean isSettable(Text node) {
1344                 return node.attributes == null ||
1345                        node.attributes.strikethrough == null ||
1346                       !node.attributes.strikethrough.isBound();
1347             }
1348 
1349             @Override
1350             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1351                 return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
1352             }
1353         };
1354 
1355         private static final
1356             CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =
1357                 new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
1358                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
1359                 TextAlignment.LEFT) {
1360 
1361             @Override
1362             public boolean isSettable(Text node) {
1363                 return node.attributes == null ||
1364                        node.attributes.textAlignment == null ||
1365                       !node.attributes.textAlignment.isBound();
1366             }
1367 
1368             @Override
1369             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
1370                 return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
1371             }
1372         };
1373 
1374         private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =
1375                 new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,
1376                 new EnumConverter&lt;VPos&gt;(VPos.class),
1377                 VPos.BASELINE) {
1378 
1379             @Override
1380             public boolean isSettable(Text node) {
1381                 return node.attributes == null ||
1382                        node.attributes.textOrigin == null ||
1383                       !node.attributes.textOrigin.isBound();
1384             }
1385 
1386             @Override
1387             public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
1388                 return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
1389             }
1390         };
1391 
1392         private static final CssMetaData&lt;Text,FontSmoothingType&gt;
1393             FONT_SMOOTHING_TYPE =
1394             new CssMetaData&lt;Text,FontSmoothingType&gt;(
1395                 &quot;-fx-font-smoothing-type&quot;,
1396                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
1397                 FontSmoothingType.GRAY) {
1398 
1399             @Override
1400             public boolean isSettable(Text node) {
1401                 return node.fontSmoothingType == null ||
1402                        !node.fontSmoothingType.isBound();
1403             }
1404 
1405             @Override
1406             public StyleableProperty&lt;FontSmoothingType&gt;
1407                                  getStyleableProperty(Text node) {
1408 
1409                 return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
1410             }
1411         };
1412 
1413         private static final
1414             CssMetaData&lt;Text,Number&gt; LINE_SPACING =
1415                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,
1416                 SizeConverter.getInstance(), 0) {
1417 
1418             @Override
1419             public boolean isSettable(Text node) {
1420                 return node.attributes == null ||
1421                        node.attributes.lineSpacing == null ||
1422                       !node.attributes.lineSpacing.isBound();
1423             }
1424 
1425             @Override
1426             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1427                 return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
1428             }
1429         };
1430 
1431         private static final CssMetaData&lt;Text, TextBoundsType&gt;
1432             BOUNDS_TYPE =
1433             new CssMetaData&lt;Text,TextBoundsType&gt;(
1434                 &quot;-fx-bounds-type&quot;,
1435                 new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),
1436                 DEFAULT_BOUNDS_TYPE) {
1437 
1438             @Override
1439             public boolean isSettable(Text node) {
1440                 return node.boundsType == null || !node.boundsType.isBound();
1441             }
1442 
1443             @Override
1444             public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
1445                 return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
1446             }
1447         };
1448 
1449         private static final CssMetaData&lt;Text, Number&gt; TAB_SIZE =
1450                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-tab-size&quot;,
1451                 SizeConverter.getInstance(), TextLayout.DEFAULT_TAB_SIZE) {
1452 
1453             @Override
1454             public boolean isSettable(Text node) {
1455                 return node.attributes == null ||
1456                        node.attributes.tabSize == null ||
1457                       !node.attributes.tabSize.isBound();
1458             }
1459 
1460             @Override
1461             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1462                 return (StyleableProperty&lt;Number&gt;)node.tabSizeProperty();
1463             }
1464         };
1465 
1466     private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1467         static {
1468             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1469                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
1470             styleables.add(FONT);
1471             styleables.add(UNDERLINE);
1472             styleables.add(STRIKETHROUGH);
1473             styleables.add(TEXT_ALIGNMENT);
1474             styleables.add(TEXT_ORIGIN);
1475             styleables.add(FONT_SMOOTHING_TYPE);
1476             styleables.add(LINE_SPACING);
1477             styleables.add(BOUNDS_TYPE);
1478             styleables.add(TAB_SIZE);
1479             STYLEABLES = Collections.unmodifiableList(styleables);
1480         }
1481     }
1482 
1483     /**
1484      * @return The CssMetaData associated with this class, which may include the
1485      * CssMetaData of its superclasses.
1486      * @since JavaFX 8.0
1487      */
1488     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1489         return StyleableProperties.STYLEABLES;
1490     }
1491 
1492     /**
1493      * {@inheritDoc}
1494      *
1495      * @since JavaFX 8.0
1496      */
1497 
1498 
1499     @Override
1500     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
1501         return getClassCssMetaData();
1502     }
1503 
1504     @SuppressWarnings(&quot;deprecation&quot;)
1505     private void updatePGText() {
1506         final NGText peer = NodeHelper.getPeer(this);
1507         if (NodeHelper.isDirty(this, DirtyBits.TEXT_ATTRS)) {
1508             peer.setUnderline(isUnderline());
1509             peer.setStrikethrough(isStrikethrough());
1510             FontSmoothingType smoothing = getFontSmoothingType();
1511             if (smoothing == null) smoothing = FontSmoothingType.GRAY;
1512             peer.setFontSmoothingType(smoothing.ordinal());
1513         }
1514         if (NodeHelper.isDirty(this, DirtyBits.TEXT_FONT)) {
1515             peer.setFont(getFontInternal());
1516         }
1517         if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
1518             peer.setGlyphs(getRuns());
1519         }
1520         if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
1521             if (isSpan()) {
1522                 BaseBounds spanBounds = getSpanBounds();
1523                 peer.setLayoutLocation(spanBounds.getMinX(), spanBounds.getMinY());
1524             } else {
1525                 float x = (float)getX();
1526                 float y = (float)getY();
1527                 float yadj = getYRendering();
1528                 peer.setLayoutLocation(-x, yadj - y);
1529             }
1530         }
1531         if (NodeHelper.isDirty(this, DirtyBits.TEXT_SELECTION)) {
1532             Object fillObj = null;
1533             int start = getSelectionStart();
1534             int end = getSelectionEnd();
1535             int length = getTextInternal().length();
1536             if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
1537                 Paint fill = selectionFillProperty().get();
1538                 fillObj = fill != null ? Toolkit.getPaintAccessor().getPlatformPaint(fill) : null;
1539             }
1540             peer.setSelection(start, end, fillObj);
1541         }
1542     }
1543 
1544     /*
1545      * Note: This method MUST only be called via its accessor method.
1546      */
1547     private void doUpdatePeer() {
1548         updatePGText();
1549     }
1550 
1551     /***************************************************************************
1552      *                                                                         *
1553      *                       Seldom Used Properties                            *
1554      *                                                                         *
1555      **************************************************************************/
1556 
1557     private TextAttribute attributes;
1558 
1559     private TextAttribute getTextAttribute() {
1560         if (attributes == null) {
1561             attributes = new TextAttribute();
1562         }
1563         return attributes;
1564     }
1565 
1566     private static final VPos DEFAULT_TEXT_ORIGIN = VPos.BASELINE;
1567     private static final TextBoundsType DEFAULT_BOUNDS_TYPE = TextBoundsType.LOGICAL;
1568     private static final boolean DEFAULT_UNDERLINE = false;
1569     private static final boolean DEFAULT_STRIKETHROUGH = false;
1570     private static final TextAlignment DEFAULT_TEXT_ALIGNMENT = TextAlignment.LEFT;
1571     private static final double DEFAULT_LINE_SPACING = 0;
1572     private static final int DEFAULT_CARET_POSITION = -1;
1573     private static final int DEFAULT_SELECTION_START = -1;
1574     private static final int DEFAULT_SELECTION_END = -1;
1575     private static final Color DEFAULT_SELECTION_FILL= Color.WHITE;
1576     private static final boolean DEFAULT_CARET_BIAS = true;
1577 
1578     private final class TextAttribute {
1579 
1580         private ObjectProperty&lt;VPos&gt; textOrigin;
1581 
1582         final VPos getTextOrigin() {
1583             return textOrigin == null ? DEFAULT_TEXT_ORIGIN : textOrigin.get();
1584         }
1585 
1586         public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
1587             if (textOrigin == null) {
1588                 textOrigin = new StyleableObjectProperty&lt;VPos&gt;(DEFAULT_TEXT_ORIGIN) {
1589                     @Override public Object getBean() { return Text.this; }
1590                     @Override public String getName() { return &quot;textOrigin&quot;; }
1591                     @Override public CssMetaData getCssMetaData() {
1592                         return StyleableProperties.TEXT_ORIGIN;
1593                     }
1594                     @Override public void invalidated() {
1595                         NodeHelper.geomChanged(Text.this);
1596                     }
1597                 };
1598             }
1599             return textOrigin;
1600         }
1601 
1602         private BooleanProperty underline;
1603 
1604         final boolean isUnderline() {
1605             return underline == null ? DEFAULT_UNDERLINE : underline.get();
1606         }
1607 
1608         final BooleanProperty underlineProperty() {
1609             if (underline == null) {
1610                 underline = new StyleableBooleanProperty() {
1611                     @Override public Object getBean() { return Text.this; }
1612                     @Override public String getName() { return &quot;underline&quot;; }
1613                     @Override public CssMetaData getCssMetaData() {
1614                         return StyleableProperties.UNDERLINE;
1615                     }
1616                     @Override public void invalidated() {
1617                         NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1618                         if (getBoundsType() == TextBoundsType.VISUAL) {
1619                             NodeHelper.geomChanged(Text.this);
1620                         }
1621                     }
1622                 };
1623             }
1624             return underline;
1625         }
1626 
1627         private BooleanProperty strikethrough;
1628 
1629         final boolean isStrikethrough() {
1630             return strikethrough == null ? DEFAULT_STRIKETHROUGH : strikethrough.get();
1631         }
1632 
1633         final BooleanProperty strikethroughProperty() {
1634             if (strikethrough == null) {
1635                 strikethrough = new StyleableBooleanProperty() {
1636                     @Override public Object getBean() { return Text.this; }
1637                     @Override public String getName() { return &quot;strikethrough&quot;; }
1638                     @Override public CssMetaData getCssMetaData() {
1639                         return StyleableProperties.STRIKETHROUGH;
1640                     }
1641                     @Override public void invalidated() {
1642                         NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1643                         if (getBoundsType() == TextBoundsType.VISUAL) {
1644                             NodeHelper.geomChanged(Text.this);
1645                         }
1646                     }
1647                 };
1648             }
1649             return strikethrough;
1650         }
1651 
1652         private ObjectProperty&lt;TextAlignment&gt; textAlignment;
1653 
1654         final TextAlignment getTextAlignment() {
1655             return textAlignment == null ? DEFAULT_TEXT_ALIGNMENT : textAlignment.get();
1656         }
1657 
1658         final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
1659             if (textAlignment == null) {
1660                 textAlignment =
1661                     new StyleableObjectProperty&lt;TextAlignment&gt;(DEFAULT_TEXT_ALIGNMENT) {
1662                     @Override public Object getBean() { return Text.this; }
1663                     @Override public String getName() { return &quot;textAlignment&quot;; }
1664                     @Override public CssMetaData getCssMetaData() {
1665                         return StyleableProperties.TEXT_ALIGNMENT;
1666                     }
1667                     @Override public void invalidated() {
1668                         if (!isSpan()) {
1669                             TextAlignment alignment = get();
1670                             if (alignment == null) {
1671                                 alignment = DEFAULT_TEXT_ALIGNMENT;
1672                             }
1673                             TextLayout layout = getTextLayout();
1674                             if (layout.setAlignment(alignment.ordinal())) {
1675                                 needsTextLayout();
1676                             }
1677                         }
1678                     }
1679                 };
1680             }
1681             return textAlignment;
1682         }
1683 
1684         private DoubleProperty lineSpacing;
1685 
1686         final double getLineSpacing() {
1687             return lineSpacing == null ? DEFAULT_LINE_SPACING : lineSpacing.get();
1688         }
1689 
1690         final DoubleProperty lineSpacingProperty() {
1691             if (lineSpacing == null) {
1692                 lineSpacing =
1693                     new StyleableDoubleProperty(DEFAULT_LINE_SPACING) {
1694                     @Override public Object getBean() { return Text.this; }
1695                     @Override public String getName() { return &quot;lineSpacing&quot;; }
1696                     @Override public CssMetaData getCssMetaData() {
1697                         return StyleableProperties.LINE_SPACING;
1698                     }
1699                     @Override public void invalidated() {
1700                         if (!isSpan()) {
1701                             TextLayout layout = getTextLayout();
1702                             if (layout.setLineSpacing((float)get())) {
1703                                 needsTextLayout();
1704                             }
1705                         }
1706                     }
1707                 };
1708             }
1709             return lineSpacing;
1710         }
1711 
1712         private ReadOnlyDoubleWrapper baselineOffset;
1713 
1714         final ReadOnlyDoubleProperty baselineOffsetProperty() {
1715             if (baselineOffset == null) {
1716                 baselineOffset = new ReadOnlyDoubleWrapper(Text.this, &quot;baselineOffset&quot;) {
1717                     {bind(new DoubleBinding() {
1718                         {bind(fontProperty());}
1719                         @Override protected double computeValue() {
1720                             /* This method should never be used for spans.
1721                              * If it is, it will still returns the ascent
1722                              * for the first line in the layout */
1723                             BaseBounds bounds = getLogicalBounds();
1724                             return -bounds.getMinY();
1725                         }
1726                     });}
1727                 };
1728             }
1729             return baselineOffset.getReadOnlyProperty();
1730         }
1731 
1732         private ObjectProperty&lt;PathElement[]&gt; selectionShape;
1733         private ObjectBinding&lt;PathElement[]&gt; selectionBinding;
1734 
1735         final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
1736             if (selectionShape == null) {
1737                 selectionBinding = new ObjectBinding&lt;PathElement[]&gt;() {
1738                     {bind(selectionStartProperty(), selectionEndProperty());}
1739                     @Override protected PathElement[] computeValue() {
1740                         int start = getSelectionStart();
1741                         int end = getSelectionEnd();
1742                         return getRange(start, end, TextLayout.TYPE_TEXT);
1743                     }
1744               };
1745               selectionShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;selectionShape&quot;);
1746               selectionShape.bind(selectionBinding);
1747             }
1748             return selectionShape;
1749         }
1750 
1751         private ObjectProperty&lt;Paint&gt; selectionFill;
1752 
1753         final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
1754             if (selectionFill == null) {
1755                 selectionFill =
1756                     new ObjectPropertyBase&lt;Paint&gt;(DEFAULT_SELECTION_FILL) {
1757                         @Override public Object getBean() { return Text.this; }
1758                         @Override public String getName() { return &quot;selectionFill&quot;; }
1759                         @Override protected void invalidated() {
1760                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1761                         }
1762                     };
1763             }
1764             return selectionFill;
1765         }
1766 
1767         private IntegerProperty selectionStart;
1768 
1769         final int getSelectionStart() {
1770             return selectionStart == null ? DEFAULT_SELECTION_START : selectionStart.get();
1771         }
1772 
1773         final IntegerProperty selectionStartProperty() {
1774             if (selectionStart == null) {
1775                 selectionStart =
1776                     new IntegerPropertyBase(DEFAULT_SELECTION_START) {
1777                         @Override public Object getBean() { return Text.this; }
1778                         @Override public String getName() { return &quot;selectionStart&quot;; }
1779                         @Override protected void invalidated() {
1780                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1781                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1782                         }
1783                 };
1784             }
1785             return selectionStart;
1786         }
1787 
1788         private IntegerProperty selectionEnd;
1789 
1790         final int getSelectionEnd() {
1791             return selectionEnd == null ? DEFAULT_SELECTION_END : selectionEnd.get();
1792         }
1793 
1794         final IntegerProperty selectionEndProperty() {
1795             if (selectionEnd == null) {
1796                 selectionEnd =
1797                     new IntegerPropertyBase(DEFAULT_SELECTION_END) {
1798                         @Override public Object getBean() { return Text.this; }
1799                         @Override public String getName() { return &quot;selectionEnd&quot;; }
1800                         @Override protected void invalidated() {
1801                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1802                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1803                         }
1804                     };
1805             }
1806             return selectionEnd;
1807         }
1808 
1809         private ObjectProperty&lt;PathElement[]&gt; caretShape;
1810         private ObjectBinding&lt;PathElement[]&gt; caretBinding;
1811 
1812         final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
1813             if (caretShape == null) {
1814                 caretBinding = new ObjectBinding&lt;PathElement[]&gt;() {
1815                     {bind(caretPositionProperty(), caretBiasProperty());}
1816                     @Override protected PathElement[] computeValue() {
1817                         int pos = getCaretPosition();
1818                         int length = getTextInternal().length();
1819                         if (0 &lt;= pos &amp;&amp; pos &lt;= length) {
1820                             boolean bias = isCaretBias();
1821                             float x = (float)getX();
1822                             float y = (float)getY() - getYRendering();
1823                             TextLayout layout = getTextLayout();
1824                             return layout.getCaretShape(pos, bias, x, y);
1825                         }
1826                         return EMPTY_PATH_ELEMENT_ARRAY;
1827                     }
1828                 };
1829                 caretShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;caretShape&quot;);
1830                 caretShape.bind(caretBinding);
1831             }
1832             return caretShape;
1833         }
1834 
1835         private IntegerProperty caretPosition;
1836 
1837         final int getCaretPosition() {
1838             return caretPosition == null ? DEFAULT_CARET_POSITION : caretPosition.get();
1839         }
1840 
1841         final IntegerProperty caretPositionProperty() {
1842             if (caretPosition == null) {
1843                 caretPosition =
1844                     new IntegerPropertyBase(DEFAULT_CARET_POSITION) {
1845                         @Override public Object getBean() { return Text.this; }
1846                         @Override public String getName() { return &quot;caretPosition&quot;; }
1847                         @Override protected void invalidated() {
1848                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1849                         }
1850                     };
1851             }
1852             return caretPosition;
1853         }
1854 
1855         private BooleanProperty caretBias;
1856 
1857         final boolean isCaretBias() {
1858             return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
1859         }
1860 
1861         final BooleanProperty caretBiasProperty() {
1862             if (caretBias == null) {
1863                 caretBias =
1864                         new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
1865             }
1866             return caretBias;
1867         }
1868 
1869         private IntegerProperty tabSize;
1870 
1871         final int getTabSize() {
1872             return tabSize == null ? TextLayout.DEFAULT_TAB_SIZE : tabSize.get();
1873         }
1874 
1875         final IntegerProperty tabSizeProperty() {
1876             if (tabSize == null) {
1877                 tabSize = new StyleableIntegerProperty(TextLayout.DEFAULT_TAB_SIZE) {
1878                     @Override public Object getBean() { return Text.this; }
1879                     @Override public String getName() { return &quot;tabSize&quot;; }
1880                     @Override public CssMetaData getCssMetaData() {
1881                         return StyleableProperties.TAB_SIZE;
1882                     }
1883                     @Override protected void invalidated() {
1884                         if (!isSpan()) {
1885                             TextLayout layout = getTextLayout();
1886                             if (layout.setTabSize(get())) {
1887                                 needsTextLayout();
1888                             }
1889                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1890                             if (getBoundsType() == TextBoundsType.VISUAL) {
1891                                 NodeHelper.geomChanged(Text.this);
1892                             }
1893                         }
1894                     }
1895                 };
1896             }
1897             return tabSize;
1898         }
1899     }
1900 
1901     /**
1902      * Returns a string representation of this {@code Text} object.
1903      * @return a string representation of this {@code Text} object.
1904      */
1905     @Override
1906     public String toString() {
1907         final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);
1908 
1909         String id = getId();
1910         if (id != null) {
1911             sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
1912         }
1913 
1914         sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
1915         sb.append(&quot;, x=&quot;).append(getX());
1916         sb.append(&quot;, y=&quot;).append(getY());
1917         sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
1918         sb.append(&quot;, origin=&quot;).append(getTextOrigin());
1919         sb.append(&quot;, boundsType=&quot;).append(getBoundsType());
1920 
1921         double spacing = getLineSpacing();
1922         if (spacing != DEFAULT_LINE_SPACING) {
1923             sb.append(&quot;, lineSpacing=&quot;).append(spacing);
1924         }
1925 
1926         double wrap = getWrappingWidth();
1927         if (wrap != 0) {
1928             sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
1929         }
1930 
1931         int tab = getTabSize();
1932         if (tab != TextLayout.DEFAULT_TAB_SIZE) {
1933             sb.append(&quot;, tabSize=&quot;).append(tab);
1934         }
1935 
1936         sb.append(&quot;, font=&quot;).append(getFont());
1937         sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());
1938 
1939         if (isStrikethrough()) {
1940             sb.append(&quot;, strikethrough&quot;);
1941         }
1942         if (isUnderline()) {
1943             sb.append(&quot;, underline&quot;);
1944         }
1945 
1946         sb.append(&quot;, fill=&quot;).append(getFill());
1947 
1948         Paint stroke = getStroke();
1949         if (stroke != null) {
1950             sb.append(&quot;, stroke=&quot;).append(stroke);
1951             sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
1952         }
1953 
1954         return sb.append(&quot;]&quot;).toString();
1955     }
1956 
1957     /** {@inheritDoc} */
1958     @Override
1959     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1960         switch (attribute) {
1961             case TEXT: {
1962                 String accText = getAccessibleText();
1963                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1964                 return getText();
1965             }
1966             case FONT: return getFont();
1967             case CARET_OFFSET: {
1968                 int sel = getCaretPosition();
1969                 if (sel &gt;=  0) return sel;
1970                 return getText().length();
1971             }
1972             case SELECTION_START: {
1973                 int sel = getSelectionStart();
1974                 if (sel &gt;=  0) return sel;
1975                 sel = getCaretPosition();
1976                 if (sel &gt;=  0) return sel;
1977                 return getText().length();
1978             }
1979             case SELECTION_END:  {
1980                 int sel = getSelectionEnd();
1981                 if (sel &gt;=  0) return sel;
1982                 sel = getCaretPosition();
1983                 if (sel &gt;=  0) return sel;
1984                 return getText().length();
1985             }
1986             case LINE_FOR_OFFSET: {
1987                 int offset = (Integer)parameters[0];
1988                 if (offset &gt; getTextInternal().length()) return null;
1989                 TextLine[] lines = getTextLayout().getLines();
1990                 int lineIndex = 0;
1991                 for (int i = 1; i &lt; lines.length; i++) {
1992                     TextLine line = lines[i];
1993                     if (line.getStart() &gt; offset) break;
1994                     lineIndex++;
1995                 }
1996                 return lineIndex;
1997             }
1998             case LINE_START: {
1999                 int lineIndex = (Integer)parameters[0];
2000                 TextLine[] lines = getTextLayout().getLines();
2001                 if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
2002                     TextLine line = lines[lineIndex];
2003                     return line.getStart();
2004                 }
2005                 return null;
2006             }
2007             case LINE_END: {
2008                 int lineIndex = (Integer)parameters[0];
2009                 TextLine[] lines = getTextLayout().getLines();
2010                 if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
2011                     TextLine line = lines[lineIndex];
2012                     return line.getStart() + line.getLength();
2013                 }
2014                 return null;
2015             }
2016             case OFFSET_AT_POINT: {
2017                 Point2D point = (Point2D)parameters[0];
2018                 point = screenToLocal(point);
2019                 return hitTest(point).getCharIndex();
2020             }
2021             case BOUNDS_FOR_RANGE: {
2022                 int start = (Integer)parameters[0];
2023                 int end = (Integer)parameters[1];
2024                 PathElement[] elements = rangeShape(start, end + 1);
2025                 /* Each bounds is defined by a MoveTo (top-left) followed by
2026                  * 4 LineTo (to top-right, bottom-right, bottom-left, back to top-left).
2027                  */
2028                 Bounds[] bounds = new Bounds[elements.length / 5];
2029                 int index = 0;
2030                 for (int i = 0; i &lt; bounds.length; i++) {
2031                     MoveTo topLeft = (MoveTo)elements[index];
2032                     LineTo topRight = (LineTo)elements[index+1];
2033                     LineTo bottomRight = (LineTo)elements[index+2];
2034                     BoundingBox b = new BoundingBox(topLeft.getX(), topLeft.getY(),
2035                                                     topRight.getX() - topLeft.getX(),
2036                                                     bottomRight.getY() - topRight.getY());
2037                     bounds[i] = localToScreen(b);
2038                     index += 5;
2039                 }
2040                 return bounds;
2041             }
2042             default: return super.queryAccessibleAttribute(attribute, parameters);
2043         }
2044     }
2045 }
    </pre>
  </body>
</html>