<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/font/PrismFontFile.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.font;
  27 
  28 
  29 import java.lang.ref.WeakReference;
  30 import java.io.File;
  31 import java.io.FileNotFoundException;
  32 import java.security.AccessController;
  33 import java.security.PrivilegedAction;
  34 import java.util.HashMap;
  35 import java.util.Locale;
  36 import java.util.Map;
  37 import java.util.concurrent.ConcurrentHashMap;
  38 import com.sun.javafx.geom.RectBounds;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.font.FontFileReader.Buffer;
  41 import static com.sun.javafx.font.PrismMetrics.*;
  42 
  43 public abstract class PrismFontFile implements FontResource, FontConstants {
  44 
  45     private int fontInstallationType = -1; // unknown, 0=embedded, 1=system
  46 
  47     // TrueType fonts can have multiple names, most notably split up by
  48     // platform and locale. Whilst fonts that have different names for
  49     // different platforms are arguable buggy, those with localised names
  50     // are not. This can cause problems. Suppose that a font has English,
  51     // French and German names, and the platform enumerates the name that
  52     // is most appropriate for the user locale. Then suppose a French
  53     // developer uses the French name, but for his German user this font
  54     // is not located by the platform because it reports the German name
  55     // for that font. At runtime we no longer have any connection to the
  56     // locale of the developer so we can&#39;t look for the name for that
  57     // locale, even if the platform have us a performant option for that.
  58     //
  59     // The English name which some might think is supposed
  60     // to be the interoperable name is not treated at all specially in
  61     // the font format and doesn&#39;t even come up for either the user or
  62     // the developer, and in fact doesn&#39;t even have to be present.
  63     // Having said that we&#39;ll probably have the best luck for most users
  64     // and fonts by assuming the English name if the locale name doesn&#39;t
  65     // work. But either way, without platform API support for this
  66     // then its really expensive as all font files need to be opened.
  67     //
  68     String familyName;           /* Family font name (English) */
  69     String fullName;             /* Full font name (English)   */
  70     String psName;               /* PostScript font name       */
  71     String localeFamilyName;
  72     String localeFullName;
  73     String styleName;
  74     String localeStyleName;
  75     String filename;
  76     int filesize;
  77     FontFileReader filereader;
  78     int numGlyphs = -1;
  79     short indexToLocFormat;
  80     int fontIndex; // into a TTC.
  81     boolean isCFF;
  82     boolean isEmbedded = false;
  83     boolean isCopy = false;
  84     boolean isTracked = false;
  85     boolean isDecoded = false;
  86     boolean isRegistered = true;
  87 
  88     /* The glyph image data is stored only in a texture, and we
  89      * manage how much of that is kept around. We clearly want
  90      * to keep a reference to the strike that created that data.
  91      */
  92     Map&lt;FontStrikeDesc, WeakReference&lt;PrismFontStrike&gt;&gt; strikeMap =
  93         new ConcurrentHashMap&lt;FontStrikeDesc, WeakReference&lt;PrismFontStrike&gt;&gt;();
  94 
  95     protected PrismFontFile(String name, String filename, int fIndex,
  96                           boolean register, boolean embedded,
  97                           boolean copy, boolean tracked) throws Exception {
  98         this.filename = filename;
  99         this.isRegistered = register;
 100         this.isEmbedded = embedded;
 101         this.isCopy = copy;
 102         this.isTracked = tracked;
 103         init(name, fIndex);
 104     }
 105 
 106     WeakReference&lt;PrismFontFile&gt; createFileDisposer(PrismFontFactory factory,
 107                                                     FileRefCounter rc) {
 108         FileDisposer disposer = new FileDisposer(filename, isTracked, rc);
 109         WeakReference&lt;PrismFontFile&gt; ref = Disposer.addRecord(this, disposer);
 110         disposer.setFactory(factory, ref);
 111         return ref;
 112     }
 113 
 114     void setIsDecoded(boolean decoded) {
 115         isDecoded = decoded;
 116     }
 117 
 118     /* This is called only for fonts where a temp file was created
 119      */
 120     protected synchronized void disposeOnShutdown() {
 121         if (isCopy || isDecoded) {
 122             AccessController.doPrivileged(
 123                     (PrivilegedAction&lt;Void&gt;) () -&gt; {
 124                         try {
 125                             /* Although there is likely no harm in calling
 126                              * delete on a file &gt; once, we want to refrain
 127                              * from deleting it until the shutdown hook
 128                              * code in subclasses has had an opportunity
 129                              * to clean up native accesses on the resource.
 130                              */
 131                             if (decFileRefCount() &gt; 0) {
 132                                 return null;
 133                             }
 134                             boolean delOK = (new File(filename)).delete();
 135                             if (!delOK &amp;&amp; PrismFontFactory.debugFonts) {
 136                                  System.err.println(&quot;Temp file not deleted : &quot;
 137                                                     + filename);
 138                             }
 139                             /* Embedded fonts (copy) can also be decoded.
 140                              * Set both flags to false to avoid double deletes.
 141                              */
 142                             isCopy = isDecoded = false;
 143                         } catch (Exception e) {
 144                         }
 145                         return null;
 146                     }
 147             );
 148             if (PrismFontFactory.debugFonts) {
 149                 System.err.println(&quot;Temp file deleted: &quot; + filename);
 150             }
 151         }
 152     }
 153 
 154     public int getDefaultAAMode() {
 155         return AA_GREYSCALE;
 156     }
 157 
 158     public boolean isInstalledFont() {
 159         if (fontInstallationType == -1) {
 160             PrismFontFactory factory = PrismFontFactory.getFontFactory();
 161             fontInstallationType = factory.isInstalledFont(filename) ? 1 : 0;
 162         }
 163         return fontInstallationType &gt; 0;
 164     }
 165 
 166 
 167     /* A TTC file resource is shared, so reference count and delete
 168      * only when no longer using the file from any PrismFontFile instance
 169      */
 170    static class FileRefCounter {
 171        private int refCnt = 1; // start with 1.
 172 
 173        synchronized int getRefCount() {
 174            return refCnt;
 175        }
 176 
 177        synchronized int increment() {
 178            return ++refCnt;
 179        }
 180 
 181        synchronized int decrement() {
 182            return (refCnt == 0) ? 0 : --refCnt;
 183        }
 184     }
 185 
 186     private FileRefCounter refCounter = null;
 187 
 188     FileRefCounter getFileRefCounter() {
 189         return refCounter;
 190     }
 191 
 192     FileRefCounter createFileRefCounter() {
 193         refCounter = new FileRefCounter();
 194         return refCounter;
 195     }
 196 
 197     void setAndIncFileRefCounter(FileRefCounter rc) {
 198           this.refCounter = rc;
 199           this.refCounter.increment();
 200     }
 201 
 202     int decFileRefCount() {
 203         if (refCounter == null) {
 204             return 0;
 205          } else {
 206             return refCounter.decrement();
 207          }
 208     }
 209 
 210     static class FileDisposer implements DisposerRecord {
 211         String fileName;
 212         boolean isTracked;
 213         FileRefCounter refCounter;
 214         PrismFontFactory factory;
 215         WeakReference&lt;PrismFontFile&gt; refKey;
 216 
 217         public FileDisposer(String fileName, boolean isTracked,
 218                             FileRefCounter rc) {
 219             this.fileName = fileName;
 220             this.isTracked = isTracked;
 221             this.refCounter = rc;
 222         }
 223 
 224         public void setFactory(PrismFontFactory factory,
 225                                WeakReference&lt;PrismFontFile&gt; refKey) {
 226             this.factory = factory;
 227             this.refKey = refKey;
 228         }
 229 
 230         public synchronized void dispose() {
 231             if (fileName != null) {
 232                 AccessController.doPrivileged(
 233                         (PrivilegedAction&lt;Void&gt;) () -&gt; {
 234                             try {
 235                                 if (refCounter != null &amp;&amp;
 236                                     refCounter.decrement() &gt; 0)
 237                                 {
 238                                     return null;
 239                                 }
 240                                 File file = new File(fileName);
 241                                 int size = (int)file.length();
 242                                 file.delete();
 243                                 // decrement tracker only after
 244                                 // successful deletion.
 245                                 if (isTracked) {
 246                                     FontFileWriter.FontTracker.
 247                                         getTracker().subBytes(size);
 248                                 }
 249                                 if (factory != null &amp;&amp; refKey != null) {
 250                                     Object o = refKey.get();
 251                                     if (o == null) {
 252                                         factory.removeTmpFont(refKey);
 253                                         factory = null;
 254                                         refKey = null;
 255                                     }
 256                                 }
 257                                 if (PrismFontFactory.debugFonts) {
 258                                     System.err.println(&quot;FileDisposer=&quot; + fileName);
 259                                 }
 260                             } catch (Exception e) {
 261                                 if (PrismFontFactory.debugFonts) {
 262                                     e.printStackTrace();
 263                                 }
 264                             }
 265                             return null;
 266                         }
 267                 );
 268                 fileName = null;
 269             }
 270         }
 271     }
 272 
 273     public String getFileName() {
 274         return filename;
 275     }
 276 
 277     protected int getFileSize() {
 278         return filesize;
 279     }
 280 
 281     protected int getFontIndex() {
 282         return fontIndex;
 283     }
 284 
 285     public String getFullName() {
 286         return fullName;
 287     }
 288 
 289     public String getPSName() {
 290         if (psName == null) {
 291             psName = fullName;
 292         }
 293         return psName;
 294     }
 295 
 296     public String getFamilyName() {
 297         return familyName;
 298     }
 299 
 300     public String getStyleName() {
 301         return styleName;
 302     }
 303 
 304     public String getLocaleFullName() {
 305         return localeFullName;
 306     }
 307 
 308     public String getLocaleFamilyName() {
 309         return localeFamilyName;
 310     }
 311 
 312     public String getLocaleStyleName() {
 313         return localeStyleName;
 314     }
 315 
 316     /*
 317      * Returns the features the font supports.
 318      */
 319     public int getFeatures() {
 320         //TODO check font file for features
 321         return -1;
 322     }
 323 
 324     public Map getStrikeMap() {
 325         return strikeMap;
 326     }
 327 
 328     protected abstract PrismFontStrike createStrike(float size,
 329                                                     BaseTransform transform,
 330                                                     int aaMode,
 331                                                     FontStrikeDesc desc);
 332 
 333     public FontStrike getStrike(float size, BaseTransform transform,
 334                                 int aaMode) {
 335         FontStrikeDesc desc = new FontStrikeDesc(size, transform, aaMode);
 336         WeakReference&lt;PrismFontStrike&gt; ref = strikeMap.get(desc);
 337         PrismFontStrike strike = null;
 338         if (ref != null) {
 339             strike = ref.get();
 340         }
 341         if (strike == null) {
 342             strike = createStrike(size, transform, aaMode, desc);
 343             DisposerRecord disposer = strike.getDisposer();
 344             if (disposer != null) {
 345                 ref = Disposer.addRecord(strike, disposer);
 346             } else {
 347                 ref = new WeakReference&lt;PrismFontStrike&gt;(strike);
 348             }
 349             strikeMap.put(desc, ref);
 350         }
 351         return strike;
 352     }
 353 
 354     HashMap&lt;Integer, int[]&gt; bbCache = null;
 355     static final int[] EMPTY_BOUNDS = new int[4];
 356 
 357     protected abstract int[] createGlyphBoundingBox(int gc);
 358 
 359     @Override
 360     public float[] getGlyphBoundingBox(int gc, float size, float[] retArr) {
 361         if (retArr == null || retArr.length &lt; 4) {
 362             retArr = new float[4];
 363         }
 364         if (gc &gt;= getNumGlyphs()) {
 365             retArr[0] = retArr[1] = retArr[2] = retArr[3] = 0;
 366             return retArr;
 367         }
 368         if (bbCache == null) {
 369             bbCache = new HashMap&lt;Integer, int[]&gt;();
 370         }
 371         int[] bb = bbCache.get(gc);
 372         if (bb == null) {
 373             bb = createGlyphBoundingBox(gc);
 374             if (bb == null) bb = EMPTY_BOUNDS;
 375             bbCache.put(gc, bb);
 376         }
 377         float scale = size / getUnitsPerEm();
 378         retArr[0] = bb[0] * scale;
 379         retArr[1] = bb[1] * scale;
 380         retArr[2] = bb[2] * scale;
 381         retArr[3] = bb[3] * scale;
 382         return retArr;
 383     }
 384 
 385     int getNumGlyphs() {
 386         if (numGlyphs == -1) {
 387             Buffer buffer = readTable(maxpTag);
 388             numGlyphs = buffer.getChar(4); // offset 4 bytes in MAXP table.
 389         }
 390         return numGlyphs;
 391     }
 392 
 393     protected boolean isCFF() {
 394         return isCFF;
 395     }
 396 
 397     private Object peer;
 398     public Object getPeer() {
 399         return peer;
 400     }
 401 
 402     public void setPeer(Object peer) {
 403         this.peer = peer;
 404     }
 405 
<a name="1" id="anc1"></a><span class="line-added"> 406     int getTableLength(int tag) {</span>
<span class="line-added"> 407         int len = 0;</span>
<span class="line-added"> 408         DirectoryEntry tagDE = getDirectoryEntry(tag);</span>
<span class="line-added"> 409         if (tagDE != null) {</span>
<span class="line-added"> 410             len = tagDE.length;</span>
<span class="line-added"> 411         }</span>
<span class="line-added"> 412         return len;</span>
<span class="line-added"> 413     }</span>
<span class="line-added"> 414 </span>
 415     synchronized Buffer readTable(int tag) {
 416         Buffer buffer = null;
 417         boolean openedFile = false;
 418         try {
 419             openedFile = filereader.openFile();
 420             DirectoryEntry tagDE = getDirectoryEntry(tag);
 421             if (tagDE != null) {
 422                 buffer = filereader.readBlock(tagDE.offset, tagDE.length);
 423             }
 424         } catch (Exception e) {
 425             if (PrismFontFactory.debugFonts) {
 426                 e.printStackTrace();
 427             }
 428         } finally {
 429             if (openedFile) {
 430                 try {
 431                     filereader.closeFile();
 432                 } catch (Exception e2) {
 433                 }
 434             }
 435         }
 436         return buffer;
 437     }
 438 
 439     int directoryCount = 1;
 440 
 441     /**
 442      * @return number of logical fonts. Is &quot;1&quot; for all but TTC files
 443      */
 444     public int getFontCount() {
 445         return directoryCount;
 446     }
 447 
 448     int numTables;
 449     DirectoryEntry[] tableDirectory;
 450     static class DirectoryEntry {
 451         int tag;
 452         int offset;
 453         int length;
 454     }
 455 
 456     DirectoryEntry getDirectoryEntry(int tag) {
 457         for (int i=0;i&lt;numTables;i++) {
 458             if (tableDirectory[i].tag == tag) {
 459                 return tableDirectory[i];
 460             }
 461         }
 462         return null;
 463     }
 464 
 465     /* Called from the constructor. Does the basic work of finding
 466      * the right font in a TTC, the font names and enough info
 467      * (the table offset directory) to be able to locate tables later.
 468      * Throws an exception if it doesn&#39;t like what it finds.
 469      */
 470     private void init(String name, int fIndex) throws Exception {
 471         filereader = new FontFileReader(filename);
 472         WoffDecoder decoder = null;
 473         try {
 474             if (!filereader.openFile()) {
 475                 throw new FileNotFoundException(&quot;Unable to create FontResource&quot;
 476                         + &quot; for file &quot; + filename);
 477             }
 478             Buffer buffer = filereader.readBlock(0, TTCHEADERSIZE);
 479             int sfntTag = buffer.getInt();
 480 
 481             /* Handle wOFF files */
 482             if (sfntTag == woffTag) {
 483                 decoder = new WoffDecoder();
 484                 File file = decoder.openFile();
 485                 decoder.decode(filereader);
 486                 decoder.closeFile();
 487 
 488                 /* Create a new reader with the decoded file */
 489                 filereader.closeFile();
 490                 filereader = new FontFileReader(file.getPath());
 491                 if (!filereader.openFile()) {
 492                     throw new FileNotFoundException(&quot;Unable to create &quot;
 493                             + &quot;FontResource for file &quot; + filename);
 494                 }
 495                 buffer = filereader.readBlock(0, TTCHEADERSIZE);
 496                 sfntTag = buffer.getInt();
 497             }
 498 
 499             filesize = (int)filereader.getLength();
 500             int headerOffset = 0;
 501             if (sfntTag == ttcfTag) {
 502                 buffer.getInt(); // skip TTC version ID
 503                 directoryCount = buffer.getInt();
 504                 if (fIndex &gt;= directoryCount) {
 505                     throw new Exception(&quot;Bad collection index&quot;);
 506                 }
 507                 fontIndex = fIndex;
 508                 buffer = filereader.readBlock(TTCHEADERSIZE+4*fIndex, 4);
 509                 headerOffset = buffer.getInt();
 510                 buffer = filereader.readBlock(headerOffset, 4);
 511                 sfntTag = buffer.getInt();
 512             }
 513 
 514             switch (sfntTag) {
 515             case v1ttTag:
 516             case trueTag:
 517                 break;
 518 
 519             case ottoTag:
 520                 isCFF = true;
 521                 break;
 522 
 523             default:
 524                 throw new Exception(&quot;Unsupported sfnt &quot; + filename);
 525             }
 526 
 527             /* Now have the offset of this TT font (possibly within a TTC)
 528              * After the TT version/scaler type field, is the short
 529              * representing the number of tables in the table directory.
 530              * The table directory begins at 12 bytes after the header.
 531              * Each table entry is 16 bytes long (4 32-bit ints)
 532              */
 533             buffer = filereader.readBlock(headerOffset+4, 2);
 534             numTables = buffer.getShort();
 535             int directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
 536             Buffer ibuffer = filereader.
 537                     readBlock(directoryOffset, numTables*DIRECTORYENTRYSIZE);
 538             DirectoryEntry table;
 539             tableDirectory = new DirectoryEntry[numTables];
 540             for (int i=0; i&lt;numTables;i++) {
 541                 tableDirectory[i] = table = new DirectoryEntry();
 542                 table.tag   =  ibuffer.getInt();
 543                 /* checksum */ ibuffer.skip(4);
 544                 table.offset = ibuffer.getInt();
 545                 table.length = ibuffer.getInt();
 546                 if (table.offset + table.length &gt; filesize) {
 547                     throw new Exception(&quot;bad table, tag=&quot;+table.tag);
 548                 }
 549             }
 550 
 551             DirectoryEntry headDE = getDirectoryEntry(headTag);
 552             Buffer headTable = filereader.readBlock(headDE.offset,
 553                                                     headDE.length);
 554             // Important font attribute must be set in order to prevent div by zero
 555             upem = (float)(headTable.getShort(18) &amp; 0xffff);
 556             if (!(16 &lt;= upem &amp;&amp; upem &lt;= 16384)) {
 557                 upem = 2048;
 558             }
 559 
 560             indexToLocFormat = headTable.getShort(50);
 561             // 0 for short offsets, 1 for long
 562             if (indexToLocFormat &lt; 0 || indexToLocFormat &gt; 1) {
 563                 throw new Exception(&quot;Bad indexToLocFormat&quot;);
 564             }
 565 
 566             // In a conventional optimised layout, the
 567             // hhea table immediately follows the &#39;head&#39; table.
 568             Buffer hhea = readTable(hheaTag);
 569             if (hhea == null) {
 570                 numHMetrics = -1;
 571             } else {
 572                 // the font table has the sign of ascent and descent
 573                 // reversed from our coordinate system.
 574                 ascent = -(float)hhea.getShort(4);
 575                 descent = -(float)hhea.getShort(6);
 576                 linegap = (float)hhea.getShort(8);
 577                 // advanceWidthMax is max horizontal advance of all glyphs in
 578                 // font. For some fonts advanceWidthMax is much larger then &quot;M&quot;
 579                 // advanceWidthMax = (float)hhea.getChar(10);
 580                 numHMetrics = hhea.getChar(34) &amp; 0xffff;
<a name="2" id="anc2"></a><span class="line-added"> 581                 /* the hmtx table may have a trailing LSB array which we don&#39;t</span>
<span class="line-added"> 582                  * use. But it means we must not assume these two values match.</span>
<span class="line-added"> 583                  * We are only concerned here with not reading more data than</span>
<span class="line-added"> 584                  * there is in the table.</span>
<span class="line-added"> 585                  */</span>
<span class="line-added"> 586                 int hmtxEntries = getTableLength(hmtxTag) &gt;&gt; 2;</span>
<span class="line-added"> 587                 if (numHMetrics &gt; hmtxEntries) {</span>
<span class="line-added"> 588                     numHMetrics = hmtxEntries;</span>
<span class="line-added"> 589                 }</span>
 590             }
 591 
 592             // maxp table is before the OS/2 table. Read it now
 593             // while file is open - will be very cheap as its just
 594             // 32 bytes and we already have it in a byte[].
 595             getNumGlyphs();
 596 
 597             setStyle();
 598 
 599             // sanity check the cmap table
 600             checkCMAP();
 601 
 602             /* Get names last, as the name table is far from the file header.
 603              * Although its also likely too big to fit in the read cache
 604              * in which case that would remain valid, but also will help
 605              * any file read implementation which doesn&#39;t have random access.
 606              */
 607             initNames();
 608 
 609             if (familyName == null || fullName == null) {
 610                 String fontName = name != null ? name : &quot;&quot;;
 611                 if (fullName == null) {
 612                     fullName = familyName != null ? familyName : fontName;
 613                 }
 614                 if (familyName == null) {
 615                     familyName = fullName != null ? fullName : fontName;
 616                 }
 617                 throw new Exception(&quot;Font name not found.&quot;);
 618             }
 619 
 620             /* update the font resource only if the file was decoded
 621              * and initialized successfully.
 622              */
 623             if (decoder != null) {
 624                 isDecoded = true;
 625                 filename = filereader.getFilename();
 626                 PrismFontFactory.getFontFactory().addDecodedFont(this);
 627             }
 628         } catch (Exception e) {
 629             if (decoder != null) {
 630                 decoder.deleteFile();
 631             }
 632             throw e;
 633         } finally {
 634             filereader.closeFile();
 635         }
 636     }
 637 
 638     /* TrueTypeFont can use the fsSelection fields of OS/2 table
 639      * or macStyleBits of the &#39;head&#39; table to determine the style.
 640      */
 641     private static final int fsSelectionItalicBit  = 0x00001;
 642     private static final int fsSelectionBoldBit    = 0x00020;
 643 
 644     private static final int MACSTYLE_BOLD_BIT   = 0x1;
 645     private static final int MACSTYLE_ITALIC_BIT = 0x2;
 646 
 647     // Comment out some of this until we have both a need and a way to use it.
 648     // private int embeddingInfo;
 649     //private int fontWeight;
 650     private boolean isBold;
 651     private boolean isItalic;
 652     private float upem;
 653     private float ascent, descent, linegap; // in design units
 654     private int numHMetrics;
 655 
 656     private void setStyle() {
 657         // A number of fonts on Mac OS X do not have an OS/2
 658         // table. For those need to get info from a different source.
 659         DirectoryEntry os2_DE = getDirectoryEntry(os_2Tag);
 660         if (os2_DE != null) {
 661             // os2 Table ver 4      DataType    Offset
 662             //version               USHORT      0
 663             //xAvgCharWidth         SHORT       2
 664             //usWeightClass         USHORT      4
 665             //usWidthClass          USHORT      6
 666             //fsType                USHORT      8
 667             //ySubscriptXSize       SHORT      10
 668             //ySubscriptYSize       SHORT      12
 669             //ySubscriptXOffset     SHORT      14
 670             //ySubscriptYOffset     SHORT      16
 671             //ySuperscriptXSize     SHORT      18
 672             //ySuperscriptYSize     SHORT      20
 673             //ySuperscriptXOffset   SHORT      22
 674             //ySuperscriptYOffset   SHORT      24
 675             //yStrikeoutSize        SHORT      26
 676             //yStrikeoutPosition    SHORT      28
 677             //sFamilyClass          SHORT      30
 678             //panose[10]            BYTE       32
 679             //ulUnicodeRange1       ULONG      42
 680             //ulUnicodeRange2       ULONG      46
 681             //ulUnicodeRange3       ULONG      50
 682             //ulUnicodeRange4       ULONG      54
 683             //achVendID[4]          CHAR       58
 684             //fsSelection           USHORT     62
 685             //usFirstCharIndex      USHORT     64
 686             //usLastCharIndex       USHORT     66
 687             //sTypoAscender         SHORT      68
 688             //sTypoDescender        SHORT      70
 689             //sTypoLineGap          SHORT      72
 690             //usWinAscent           USHORT     74
 691             //usWinDescent          USHORT     76
 692             //ulCodePageRange1      ULONG      78
 693             //ulCodePageRange2      ULONG      82
 694             //sxHeight              SHORT      86
 695             //sCapHeight            SHORT      88
 696             //usDefaultChar         USHORT     90
 697             //usBreakChar           USHORT     92
 698             //usMaxContext          USHORT     94
 699 
 700             Buffer os_2Table = filereader.readBlock(os2_DE.offset,
 701                                                     os2_DE.length);
 702             int fsSelection = os_2Table.getChar(62) &amp; 0xffff;
 703             isItalic = (fsSelection &amp; fsSelectionItalicBit) != 0;
 704             isBold   = (fsSelection &amp; fsSelectionBoldBit) != 0;
 705         } else {
 706             DirectoryEntry headDE = getDirectoryEntry(headTag);
 707             Buffer headTable = filereader.readBlock(headDE.offset,
 708                                                     headDE.length);
 709             short macStyleBits = headTable.getShort(44);
 710             isItalic = (macStyleBits &amp; MACSTYLE_ITALIC_BIT) != 0;
 711             isBold = (macStyleBits &amp; MACSTYLE_BOLD_BIT) != 0;
 712         }
 713     }
 714 
 715     public boolean isBold() {
 716         return isBold;
 717     }
 718 
 719     public boolean isItalic() {
 720         return isItalic;
 721     }
 722 
 723     public boolean isDecoded() {
 724         return isDecoded;
 725     }
 726 
 727     public boolean isRegistered() {
 728         return isRegistered;
 729     }
 730 
 731     public boolean isEmbeddedFont() {
 732         return isEmbedded;
 733     }
 734 
 735     /**
 736      * per the OT spec. this is an unsigned short.
 737      */
 738     public int getUnitsPerEm() {
 739         return (int)upem;
 740     }
 741 
 742     public short getIndexToLocFormat() {
 743         return indexToLocFormat;
 744     }
 745 
 746     /**
 747      * per the OT spec. this is an unsigned short.
 748      */
 749     public int getNumHMetrics() {
 750         return numHMetrics;
 751     }
 752 
 753     /* -- ID&#39;s used in the &#39;name&#39; table */
 754     public static final int MAC_PLATFORM_ID = 1;
 755     public static final int MACROMAN_SPECIFIC_ID = 0;
 756     public static final int MACROMAN_ENGLISH_LANG = 0;
 757 
 758     public static final int MS_PLATFORM_ID = 3;
 759     /* MS locale id for US English is the &quot;default&quot; */
 760     public static final short MS_ENGLISH_LOCALE_ID = 0x0409; // 1033 decimal
 761     public static final int FAMILY_NAME_ID = 1;
 762     public static final int STYLE_NAME_ID = 2;
 763     public static final int FULL_NAME_ID = 4;
 764     public static final int PS_NAME_ID = 6;
 765 
 766     void initNames() throws Exception {
 767         byte[] name = new byte[256];
 768 
 769         DirectoryEntry nameDE = getDirectoryEntry(nameTag);
 770         Buffer buffer = filereader.readBlock(nameDE.offset, nameDE.length);
 771 
 772         buffer.skip(2); // format - not needed.
 773         short numRecords = buffer.getShort();
 774         /* The name table uses unsigned shorts. Many of these
 775          * are known small values that fit in a short.
 776          * The values that are sizes or offsets into the table could be
 777          * greater than 32767, so read and store those as ints
 778          */
 779         int stringPtr = buffer.getShort() &amp; 0xffff;
 780 
 781         /* Microsoft Windows font names are preferred but numerous Mac
 782          * fonts do not have these, so we must also accept these in the
 783          * absence of the preferred Windows names.
 784          */
 785         for (int i=0; i&lt;numRecords; i++) {
 786             short platformID = buffer.getShort();
 787             if (platformID != MS_PLATFORM_ID &amp;&amp;
 788                 platformID != MAC_PLATFORM_ID) {
 789                 buffer.skip(10);
 790                 continue; // skip over this record.
 791             }
 792             short encodingID = buffer.getShort();
 793             // only want UTF-16 (inc. symbol) encodingIDs for Windows,
 794             // or MacRoman on Mac.
 795             if ((platformID == MS_PLATFORM_ID &amp;&amp; encodingID &gt; 1) ||
 796                 (platformID == MAC_PLATFORM_ID &amp;&amp;
 797                  encodingID != MACROMAN_SPECIFIC_ID)) {
 798                 buffer.skip(8);
 799                 continue;
 800             }
 801             short langID     = buffer.getShort();
 802             if (platformID == MAC_PLATFORM_ID &amp;&amp;
 803                 langID != MACROMAN_ENGLISH_LANG) {
 804                 buffer.skip(6);
 805                 continue;
 806             }
 807             short nameID     = buffer.getShort();
 808             int nameLen    = ((int)buffer.getShort()) &amp; 0xffff;
 809             int namePtr    = (((int)buffer.getShort()) &amp; 0xffff) + stringPtr;
 810             String tmpName = null;
 811             String enc;
 812             switch (nameID) {
 813 
 814             case FAMILY_NAME_ID:
 815 
 816                 if (familyName == null || langID == MS_ENGLISH_LOCALE_ID ||
 817                     langID == nameLocaleID)
 818                     {
 819                         buffer.get(namePtr, name, 0, nameLen);
 820                         if (platformID == MAC_PLATFORM_ID) {
 821                             enc = &quot;US-ASCII&quot;;
 822                         } else {
 823                             enc = &quot;UTF-16BE&quot;;
 824                         }
 825                         tmpName = new String(name, 0, nameLen, enc);
 826 
 827                         if (familyName == null ||
 828                             langID == MS_ENGLISH_LOCALE_ID){
 829                             familyName = tmpName;
 830                         }
 831                         if (langID == nameLocaleID) {
 832                             localeFamilyName = tmpName;
 833                         }
 834                     }
 835                     break;
 836 
 837                 case FULL_NAME_ID:
 838 
 839                     if (fullName == null ||
 840                         langID == MS_ENGLISH_LOCALE_ID ||
 841                         langID == nameLocaleID)
 842                     {
 843                         buffer.get(namePtr, name, 0, nameLen);
 844                         if (platformID == MAC_PLATFORM_ID) {
 845                             enc = &quot;US-ASCII&quot;;
 846                         } else {
 847                             enc = &quot;UTF-16BE&quot;;
 848                         }
 849                         tmpName = new String(name, 0, nameLen, enc);
 850 
 851                         if (fullName == null ||
 852                             langID == MS_ENGLISH_LOCALE_ID) {
 853                             fullName = tmpName;
 854                         }
 855                         if (langID == nameLocaleID) {
 856                             localeFullName = tmpName;
 857                         }
 858                     }
 859                     break;
 860 
 861                 case PS_NAME_ID:
 862 
 863                     if (psName == null) {
 864                         buffer.get(namePtr, name, 0, nameLen);
 865                         if (platformID == MAC_PLATFORM_ID) {
 866                             enc = &quot;US-ASCII&quot;;
 867                         } else {
 868                             enc = &quot;UTF-16BE&quot;;
 869                         }
 870                         psName = new String(name, 0, nameLen, enc);
 871                     }
 872                     break;
 873 
 874                 case STYLE_NAME_ID:
 875 
 876                     if (styleName == null ||
 877                         langID == MS_ENGLISH_LOCALE_ID ||
 878                         langID == nameLocaleID)
 879                     {
 880                         buffer.get(namePtr, name, 0, nameLen);
 881                         if (platformID == MAC_PLATFORM_ID) {
 882                             enc = &quot;US-ASCII&quot;;
 883                         } else {
 884                             enc = &quot;UTF-16BE&quot;;
 885                         }
 886                         tmpName = new String(name, 0, nameLen, enc);
 887 
 888                         if (styleName == null ||
 889                             langID == MS_ENGLISH_LOCALE_ID) {
 890                             styleName = tmpName;
 891                         }
 892                         if (langID == nameLocaleID) {
 893                             localeStyleName = tmpName;
 894                         }
 895                     }
 896                     break;
 897 
 898             default:
 899                 break;
 900             }
 901 
 902             if (localeFamilyName == null) {
 903                 localeFamilyName = familyName;
 904             }
 905             if (localeFullName == null) {
 906                 localeFullName = fullName;
 907             }
 908             if (localeStyleName == null) {
 909                 localeStyleName = styleName;
 910             }
 911         }
 912     }
 913 
 914     private void checkCMAP() throws Exception {
 915         DirectoryEntry cmapDE = getDirectoryEntry(FontConstants.cmapTag);
 916         if (cmapDE != null) {
 917             if (cmapDE.length &lt; 4) {
 918                 throw new Exception(&quot;Invalid cmap table length&quot;);
 919             }
 920             Buffer cmapTableHeader = filereader.readBlock(cmapDE.offset, 4);
 921             short version = cmapTableHeader.getShort();
 922             short numberSubTables = cmapTableHeader.getShort();
 923             int indexLength = numberSubTables * 8;
 924             if (numberSubTables &lt;= 0 || cmapDE.length &lt; indexLength + 4) {
 925                 throw new Exception(&quot;Invalid cmap subtables count&quot;);
 926             }
 927             Buffer cmapTableIndex = filereader.readBlock(cmapDE.offset + 4, indexLength);
 928             for (int i = 0; i &lt; numberSubTables; i++) {
 929                 short platformID = cmapTableIndex.getShort();
 930                 short encodingID = cmapTableIndex.getShort();
 931                 int offset = cmapTableIndex.getInt();
 932                 if (offset &lt; 0 || offset &gt;= cmapDE.length) {
 933                     throw new Exception(&quot;Invalid cmap subtable offset&quot;);
 934                 }
 935             }
 936         }
 937     }
 938 
 939     /*** BEGIN LOCALE_ID MAPPING ****/
 940 
 941     private static Map&lt;String, Short&gt; lcidMap;
 942 
 943     // Return a Microsoft LCID from the given Locale.
 944     // Used when getting localized font data.
 945 
 946     private static void addLCIDMapEntry(Map&lt;String, Short&gt; map,
 947                                         String key, short value) {
 948         map.put(key, Short.valueOf(value));
 949     }
 950 
 951     private static synchronized void createLCIDMap() {
 952         if (lcidMap != null) {
 953             return;
 954         }
 955 
 956         Map&lt;String, Short&gt; map = new HashMap&lt;String, Short&gt;(200);
 957         addLCIDMapEntry(map, &quot;ar&quot;, (short) 0x0401);
 958         addLCIDMapEntry(map, &quot;bg&quot;, (short) 0x0402);
 959         addLCIDMapEntry(map, &quot;ca&quot;, (short) 0x0403);
 960         addLCIDMapEntry(map, &quot;zh&quot;, (short) 0x0404);
 961         addLCIDMapEntry(map, &quot;cs&quot;, (short) 0x0405);
 962         addLCIDMapEntry(map, &quot;da&quot;, (short) 0x0406);
 963         addLCIDMapEntry(map, &quot;de&quot;, (short) 0x0407);
 964         addLCIDMapEntry(map, &quot;el&quot;, (short) 0x0408);
 965         addLCIDMapEntry(map, &quot;es&quot;, (short) 0x040a);
 966         addLCIDMapEntry(map, &quot;fi&quot;, (short) 0x040b);
 967         addLCIDMapEntry(map, &quot;fr&quot;, (short) 0x040c);
 968         addLCIDMapEntry(map, &quot;iw&quot;, (short) 0x040d);
 969         addLCIDMapEntry(map, &quot;hu&quot;, (short) 0x040e);
 970         addLCIDMapEntry(map, &quot;is&quot;, (short) 0x040f);
 971         addLCIDMapEntry(map, &quot;it&quot;, (short) 0x0410);
 972         addLCIDMapEntry(map, &quot;ja&quot;, (short) 0x0411);
 973         addLCIDMapEntry(map, &quot;ko&quot;, (short) 0x0412);
 974         addLCIDMapEntry(map, &quot;nl&quot;, (short) 0x0413);
 975         addLCIDMapEntry(map, &quot;no&quot;, (short) 0x0414);
 976         addLCIDMapEntry(map, &quot;pl&quot;, (short) 0x0415);
 977         addLCIDMapEntry(map, &quot;pt&quot;, (short) 0x0416);
 978         addLCIDMapEntry(map, &quot;rm&quot;, (short) 0x0417);
 979         addLCIDMapEntry(map, &quot;ro&quot;, (short) 0x0418);
 980         addLCIDMapEntry(map, &quot;ru&quot;, (short) 0x0419);
 981         addLCIDMapEntry(map, &quot;hr&quot;, (short) 0x041a);
 982         addLCIDMapEntry(map, &quot;sk&quot;, (short) 0x041b);
 983         addLCIDMapEntry(map, &quot;sq&quot;, (short) 0x041c);
 984         addLCIDMapEntry(map, &quot;sv&quot;, (short) 0x041d);
 985         addLCIDMapEntry(map, &quot;th&quot;, (short) 0x041e);
 986         addLCIDMapEntry(map, &quot;tr&quot;, (short) 0x041f);
 987         addLCIDMapEntry(map, &quot;ur&quot;, (short) 0x0420);
 988         addLCIDMapEntry(map, &quot;in&quot;, (short) 0x0421);
 989         addLCIDMapEntry(map, &quot;uk&quot;, (short) 0x0422);
 990         addLCIDMapEntry(map, &quot;be&quot;, (short) 0x0423);
 991         addLCIDMapEntry(map, &quot;sl&quot;, (short) 0x0424);
 992         addLCIDMapEntry(map, &quot;et&quot;, (short) 0x0425);
 993         addLCIDMapEntry(map, &quot;lv&quot;, (short) 0x0426);
 994         addLCIDMapEntry(map, &quot;lt&quot;, (short) 0x0427);
 995         addLCIDMapEntry(map, &quot;fa&quot;, (short) 0x0429);
 996         addLCIDMapEntry(map, &quot;vi&quot;, (short) 0x042a);
 997         addLCIDMapEntry(map, &quot;hy&quot;, (short) 0x042b);
 998         addLCIDMapEntry(map, &quot;eu&quot;, (short) 0x042d);
 999         addLCIDMapEntry(map, &quot;mk&quot;, (short) 0x042f);
1000         addLCIDMapEntry(map, &quot;tn&quot;, (short) 0x0432);
1001         addLCIDMapEntry(map, &quot;xh&quot;, (short) 0x0434);
1002         addLCIDMapEntry(map, &quot;zu&quot;, (short) 0x0435);
1003         addLCIDMapEntry(map, &quot;af&quot;, (short) 0x0436);
1004         addLCIDMapEntry(map, &quot;ka&quot;, (short) 0x0437);
1005         addLCIDMapEntry(map, &quot;fo&quot;, (short) 0x0438);
1006         addLCIDMapEntry(map, &quot;hi&quot;, (short) 0x0439);
1007         addLCIDMapEntry(map, &quot;mt&quot;, (short) 0x043a);
1008         addLCIDMapEntry(map, &quot;se&quot;, (short) 0x043b);
1009         addLCIDMapEntry(map, &quot;gd&quot;, (short) 0x043c);
1010         addLCIDMapEntry(map, &quot;ms&quot;, (short) 0x043e);
1011         addLCIDMapEntry(map, &quot;kk&quot;, (short) 0x043f);
1012         addLCIDMapEntry(map, &quot;ky&quot;, (short) 0x0440);
1013         addLCIDMapEntry(map, &quot;sw&quot;, (short) 0x0441);
1014         addLCIDMapEntry(map, &quot;tt&quot;, (short) 0x0444);
1015         addLCIDMapEntry(map, &quot;bn&quot;, (short) 0x0445);
1016         addLCIDMapEntry(map, &quot;pa&quot;, (short) 0x0446);
1017         addLCIDMapEntry(map, &quot;gu&quot;, (short) 0x0447);
1018         addLCIDMapEntry(map, &quot;ta&quot;, (short) 0x0449);
1019         addLCIDMapEntry(map, &quot;te&quot;, (short) 0x044a);
1020         addLCIDMapEntry(map, &quot;kn&quot;, (short) 0x044b);
1021         addLCIDMapEntry(map, &quot;ml&quot;, (short) 0x044c);
1022         addLCIDMapEntry(map, &quot;mr&quot;, (short) 0x044e);
1023         addLCIDMapEntry(map, &quot;sa&quot;, (short) 0x044f);
1024         addLCIDMapEntry(map, &quot;mn&quot;, (short) 0x0450);
1025         addLCIDMapEntry(map, &quot;cy&quot;, (short) 0x0452);
1026         addLCIDMapEntry(map, &quot;gl&quot;, (short) 0x0456);
1027         addLCIDMapEntry(map, &quot;dv&quot;, (short) 0x0465);
1028         addLCIDMapEntry(map, &quot;qu&quot;, (short) 0x046b);
1029         addLCIDMapEntry(map, &quot;mi&quot;, (short) 0x0481);
1030         addLCIDMapEntry(map, &quot;ar_IQ&quot;, (short) 0x0801);
1031         addLCIDMapEntry(map, &quot;zh_CN&quot;, (short) 0x0804);
1032         addLCIDMapEntry(map, &quot;de_CH&quot;, (short) 0x0807);
1033         addLCIDMapEntry(map, &quot;en_GB&quot;, (short) 0x0809);
1034         addLCIDMapEntry(map, &quot;es_MX&quot;, (short) 0x080a);
1035         addLCIDMapEntry(map, &quot;fr_BE&quot;, (short) 0x080c);
1036         addLCIDMapEntry(map, &quot;it_CH&quot;, (short) 0x0810);
1037         addLCIDMapEntry(map, &quot;nl_BE&quot;, (short) 0x0813);
1038         addLCIDMapEntry(map, &quot;no_NO_NY&quot;, (short) 0x0814);
1039         addLCIDMapEntry(map, &quot;pt_PT&quot;, (short) 0x0816);
1040         addLCIDMapEntry(map, &quot;ro_MD&quot;, (short) 0x0818);
1041         addLCIDMapEntry(map, &quot;ru_MD&quot;, (short) 0x0819);
1042         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x081a);
1043         addLCIDMapEntry(map, &quot;sv_FI&quot;, (short) 0x081d);
1044         addLCIDMapEntry(map, &quot;az_AZ&quot;, (short) 0x082c);
1045         addLCIDMapEntry(map, &quot;se_SE&quot;, (short) 0x083b);
1046         addLCIDMapEntry(map, &quot;ga_IE&quot;, (short) 0x083c);
1047         addLCIDMapEntry(map, &quot;ms_BN&quot;, (short) 0x083e);
1048         addLCIDMapEntry(map, &quot;uz_UZ&quot;, (short) 0x0843);
1049         addLCIDMapEntry(map, &quot;qu_EC&quot;, (short) 0x086b);
1050         addLCIDMapEntry(map, &quot;ar_EG&quot;, (short) 0x0c01);
1051         addLCIDMapEntry(map, &quot;zh_HK&quot;, (short) 0x0c04);
1052         addLCIDMapEntry(map, &quot;de_AT&quot;, (short) 0x0c07);
1053         addLCIDMapEntry(map, &quot;en_AU&quot;, (short) 0x0c09);
1054         addLCIDMapEntry(map, &quot;fr_CA&quot;, (short) 0x0c0c);
1055         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x0c1a);
1056         addLCIDMapEntry(map, &quot;se_FI&quot;, (short) 0x0c3b);
1057         addLCIDMapEntry(map, &quot;qu_PE&quot;, (short) 0x0c6b);
1058         addLCIDMapEntry(map, &quot;ar_LY&quot;, (short) 0x1001);
1059         addLCIDMapEntry(map, &quot;zh_SG&quot;, (short) 0x1004);
1060         addLCIDMapEntry(map, &quot;de_LU&quot;, (short) 0x1007);
1061         addLCIDMapEntry(map, &quot;en_CA&quot;, (short) 0x1009);
1062         addLCIDMapEntry(map, &quot;es_GT&quot;, (short) 0x100a);
1063         addLCIDMapEntry(map, &quot;fr_CH&quot;, (short) 0x100c);
1064         addLCIDMapEntry(map, &quot;hr_BA&quot;, (short) 0x101a);
1065         addLCIDMapEntry(map, &quot;ar_DZ&quot;, (short) 0x1401);
1066         addLCIDMapEntry(map, &quot;zh_MO&quot;, (short) 0x1404);
1067         addLCIDMapEntry(map, &quot;de_LI&quot;, (short) 0x1407);
1068         addLCIDMapEntry(map, &quot;en_NZ&quot;, (short) 0x1409);
1069         addLCIDMapEntry(map, &quot;es_CR&quot;, (short) 0x140a);
1070         addLCIDMapEntry(map, &quot;fr_LU&quot;, (short) 0x140c);
1071         addLCIDMapEntry(map, &quot;bs_BA&quot;, (short) 0x141a);
1072         addLCIDMapEntry(map, &quot;ar_MA&quot;, (short) 0x1801);
1073         addLCIDMapEntry(map, &quot;en_IE&quot;, (short) 0x1809);
1074         addLCIDMapEntry(map, &quot;es_PA&quot;, (short) 0x180a);
1075         addLCIDMapEntry(map, &quot;fr_MC&quot;, (short) 0x180c);
1076         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x181a);
1077         addLCIDMapEntry(map, &quot;ar_TN&quot;, (short) 0x1c01);
1078         addLCIDMapEntry(map, &quot;en_ZA&quot;, (short) 0x1c09);
1079         addLCIDMapEntry(map, &quot;es_DO&quot;, (short) 0x1c0a);
1080         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x1c1a);
1081         addLCIDMapEntry(map, &quot;ar_OM&quot;, (short) 0x2001);
1082         addLCIDMapEntry(map, &quot;en_JM&quot;, (short) 0x2009);
1083         addLCIDMapEntry(map, &quot;es_VE&quot;, (short) 0x200a);
1084         addLCIDMapEntry(map, &quot;ar_YE&quot;, (short) 0x2401);
1085         addLCIDMapEntry(map, &quot;es_CO&quot;, (short) 0x240a);
1086         addLCIDMapEntry(map, &quot;ar_SY&quot;, (short) 0x2801);
1087         addLCIDMapEntry(map, &quot;en_BZ&quot;, (short) 0x2809);
1088         addLCIDMapEntry(map, &quot;es_PE&quot;, (short) 0x280a);
1089         addLCIDMapEntry(map, &quot;ar_JO&quot;, (short) 0x2c01);
1090         addLCIDMapEntry(map, &quot;en_TT&quot;, (short) 0x2c09);
1091         addLCIDMapEntry(map, &quot;es_AR&quot;, (short) 0x2c0a);
1092         addLCIDMapEntry(map, &quot;ar_LB&quot;, (short) 0x3001);
1093         addLCIDMapEntry(map, &quot;en_ZW&quot;, (short) 0x3009);
1094         addLCIDMapEntry(map, &quot;es_EC&quot;, (short) 0x300a);
1095         addLCIDMapEntry(map, &quot;ar_KW&quot;, (short) 0x3401);
1096         addLCIDMapEntry(map, &quot;en_PH&quot;, (short) 0x3409);
1097         addLCIDMapEntry(map, &quot;es_CL&quot;, (short) 0x340a);
1098         addLCIDMapEntry(map, &quot;ar_AE&quot;, (short) 0x3801);
1099         addLCIDMapEntry(map, &quot;es_UY&quot;, (short) 0x380a);
1100         addLCIDMapEntry(map, &quot;ar_BH&quot;, (short) 0x3c01);
1101         addLCIDMapEntry(map, &quot;es_PY&quot;, (short) 0x3c0a);
1102         addLCIDMapEntry(map, &quot;ar_QA&quot;, (short) 0x4001);
1103         addLCIDMapEntry(map, &quot;es_BO&quot;, (short) 0x400a);
1104         addLCIDMapEntry(map, &quot;es_SV&quot;, (short) 0x440a);
1105         addLCIDMapEntry(map, &quot;es_HN&quot;, (short) 0x480a);
1106         addLCIDMapEntry(map, &quot;es_NI&quot;, (short) 0x4c0a);
1107         addLCIDMapEntry(map, &quot;es_PR&quot;, (short) 0x500a);
1108 
1109         lcidMap = map;
1110     }
1111 
1112     private static short getLCIDFromLocale(Locale locale) {
1113         // optimize for common case
1114         if (locale.equals(Locale.US) || locale.getLanguage().equals(&quot;en&quot;)) {
1115             return MS_ENGLISH_LOCALE_ID;
1116         }
1117 
1118         if (lcidMap == null) {
1119             createLCIDMap();
1120         }
1121 
1122         String key = locale.toString();
1123         while (!key.isEmpty()) {
1124             Short lcidObject = (Short) lcidMap.get(key);
1125             if (lcidObject != null) {
1126                 return lcidObject.shortValue();
1127             }
1128             int pos = key.lastIndexOf(&#39;_&#39;);
1129             if (pos &lt; 1) {
1130                 return MS_ENGLISH_LOCALE_ID;
1131             }
1132             key = key.substring(0, pos);
1133         }
1134 
1135         return MS_ENGLISH_LOCALE_ID;
1136     }
1137 
1138 
1139     /* On Windows this is set to the System Locale, which matches how
1140      * GDI enumerates font names. For display purposes we may want
1141      * the user locale which could be different.
1142      */
1143     static short nameLocaleID = getSystemLCID();
1144 
1145     private static short getSystemLCID() {
1146         if (PrismFontFactory.isWindows) {
1147             return PrismFontFactory.getSystemLCID();
1148         } else {
1149             return getLCIDFromLocale(Locale.getDefault());
1150         }
1151     }
1152 
1153     private OpenTypeGlyphMapper mapper = null;
1154 
1155     public CharToGlyphMapper getGlyphMapper() {
1156         if (mapper == null) {
1157             mapper = new OpenTypeGlyphMapper(this);
1158         }
1159         return mapper;
1160     }
1161 
1162     public FontStrike getStrike(float size, BaseTransform transform) {
1163         return getStrike(size, transform, getDefaultAAMode());
1164     }
1165 
1166     char[] advanceWidths = null;
1167     /*
1168      * This is returning the unhinted advance, should be OK so
1169      * long as we do unhinted rendering. If we are doing hinted glyphs
1170      * and I suppose, integer metrics, then we can use the hdmx table.
1171      * But since the hdmx table doesn&#39;t provide anything except integers
1172      * it will only be useful for some cases. Also even then the ptSize
1173      * alone doesn&#39;t help, since we need to know the graphics scale
1174      * to know the real glyph size that&#39;s required, then of course we
1175      * have to translate that back into user space. So all of that will
1176      * need to be looked into, or we reserve this path for unhinted rendering.
1177      * Note that if there&#39;s no hdmx entry for a given size, then we need
1178      * to scale the glyph to get the hinted advance. However before doing
1179      * so we should consult the &#39;gasp&#39; table to see it its a size at
1180      * which hinting should be performed anyway.
1181      * (1) The GASP table indicates size at which hinting should be applied
1182      * usually this is all larger sizes so probably wouldn&#39;t help, however
1183      * (2) If there is a LTSH (Linear Threshold) table, we can use that
1184      * to see if for the requested &#39;ppem&#39; size, the glyph scales linearly.
1185      *
1186      * Interestingly Amble sets the &#39;head&#39; flags bit to say non-linear
1187      * scaling and so legitimately has a LTSH table but this all may be
1188      * a hold-over from when its gasp table said to apply hints at some sizes.
1189      * I suppose I am not 100% certain if the gasp table can be trusted to
1190      * use as a short-cut for when you don&#39;t need to scale, or if choosing
1191      * not to hint means you can always just assume linear scaling, but I
1192      * do find that to be consistent with the data in Microsoft fonts where
1193      * they do not provide hdmx entry for sizes below that where hinting is
1194      * required, suggesting the htmx table is fine for such cases.
1195      */
1196     public float getAdvance(int glyphCode, float ptSize) {
1197         if (glyphCode == CharToGlyphMapper.INVISIBLE_GLYPH_ID)
1198             return 0f;
1199 
1200         // If we haven&#39;t initialised yet, do so now.
1201         if (advanceWidths == null &amp;&amp; numHMetrics &gt; 0) {
1202             synchronized (this) {
1203                 Buffer hmtx = readTable(hmtxTag);
1204                 if (hmtx == null) {
1205                     numHMetrics = -1;
1206                     return 0;
1207                 }
1208                 char[] aw = new char[numHMetrics];
1209                 for (int i=0; i&lt;numHMetrics; i++) {
1210                     aw[i] = hmtx.getChar(i*4);
1211                 }
1212                 advanceWidths = aw;
1213             }
1214         }
1215 
1216         // If we have a valid numHMetrics, look up the advance
1217         if (numHMetrics &gt; 0) {
1218             char cadv;
1219             if (glyphCode &lt; numHMetrics) {
1220                 cadv = advanceWidths[glyphCode];
1221             } else {
1222                 cadv = advanceWidths[numHMetrics-1];
1223             }
1224             return ((float)(cadv &amp; 0xffff)*ptSize)/upem;
1225         } else { // no valid lookup.
1226             return 0f;
1227         }
1228     }
1229 
1230     public PrismMetrics getFontMetrics(float ptSize) {
1231         return new PrismMetrics((ascent*ptSize)/upem,
1232                               (descent*ptSize)/upem,
1233                               (linegap*ptSize)/upem,
1234                               this, ptSize);
1235     }
1236 
1237     private float[] styleMetrics;
1238     float[] getStyleMetrics(float ptSize) {
1239         if (styleMetrics == null) {
1240             float [] smetrics = new float[METRICS_TOTAL];
1241 
1242             Buffer os_2 = readTable(os_2Tag);
1243             int length = os_2 != null ? os_2.capacity() : 0;
1244 
1245             if (length &gt;= 30) {
1246                 smetrics[STRIKETHROUGH_THICKNESS] = os_2.getShort(26) / upem;
1247                 smetrics[STRIKETHROUGH_OFFSET] = -os_2.getShort(28) / upem;
1248             } else {
1249                 smetrics[STRIKETHROUGH_THICKNESS] = 0.05f;
1250                 smetrics[STRIKETHROUGH_OFFSET] = -0.4f;
1251             }
1252             if (length &gt;= 74) {
1253                 // ascent, descent, leading are set in constructor
1254                 smetrics[TYPO_ASCENT] = -os_2.getShort(68) / upem;
1255                 smetrics[TYPO_DESCENT] = -os_2.getShort(70) / upem;
1256                 smetrics[TYPO_LINEGAP] = os_2.getShort(72) / upem;
1257             } else {
1258                 smetrics[TYPO_ASCENT] = ascent / upem;
1259                 smetrics[TYPO_DESCENT] = descent / upem;
1260                 smetrics[TYPO_LINEGAP] = linegap / upem;
1261             }
1262             // REMIND : OpenType spec introduced xHeight, many fonts
1263             // won&#39;t have this info.
1264             // xHeight should be available in OS2 font table ver. 3 or greater
1265             if (length &gt;= 90) {
1266                 smetrics[XHEIGHT] = os_2.getShort(86) / upem;
1267                 smetrics[CAPHEIGHT] = os_2.getShort(88);
1268 
1269                 /* Some fonts have bad values for capHeight. For example,
1270                  * Comic Sans MS. The fix is to ignore the capHeight in the
1271                  * font file when it is less than half of the ascent */
1272                 if ((smetrics[CAPHEIGHT] / ascent) &lt; 0.5) {
1273                     smetrics[CAPHEIGHT] = 0;
1274                 } else {
1275                     smetrics[CAPHEIGHT] /= upem;
1276                 }
1277             }
1278 
1279             if (smetrics[XHEIGHT] == 0 || smetrics[CAPHEIGHT] == 0) {
1280                 FontStrike strike = getStrike(ptSize, BaseTransform.IDENTITY_TRANSFORM);
1281                 CharToGlyphMapper mapper = getGlyphMapper();
1282                 int missingGlyph = mapper.getMissingGlyphCode();
1283 
1284                 if (smetrics[XHEIGHT] == 0) {
1285                     int gc = mapper.charToGlyph(&#39;x&#39;);
1286                     if (gc != missingGlyph) {
1287                         RectBounds fbds = strike.getGlyph(gc).getBBox();
1288                         smetrics[XHEIGHT] = fbds.getHeight() / ptSize;
1289                     } else {
1290                         smetrics[XHEIGHT] = -ascent * 0.6f / upem;
1291                     }
1292                 }
1293                 if (smetrics[CAPHEIGHT] == 0) {
1294                     int gc = mapper.charToGlyph(&#39;H&#39;);
1295                     if (gc != missingGlyph) {
1296                         RectBounds fbds = strike.getGlyph(gc).getBBox();
1297                         smetrics[CAPHEIGHT] = fbds.getHeight() / ptSize;
1298                     } else {
1299                         smetrics[CAPHEIGHT] = -ascent * 0.9f / upem;
1300                     }
1301                 }
1302             }
1303 
1304             Buffer postTable = readTable(postTag);
1305             if (postTable == null || postTable.capacity() &lt; 12) {
1306                 smetrics[UNDERLINE_OFFSET] = 0.1f;
1307                 smetrics[UNDERLINE_THICKESS] = 0.05f;
1308             } else {
1309                 smetrics[UNDERLINE_OFFSET] = -postTable.getShort(8) / upem;
1310                 smetrics[UNDERLINE_THICKESS] = postTable.getShort(10) / upem;
1311             }
1312             styleMetrics = smetrics;
1313         }
1314 
1315         float[] metrics = new float[METRICS_TOTAL];
1316         for (int i = 0; i &lt; METRICS_TOTAL; i++) {
1317             metrics[i] = styleMetrics[i] * ptSize;
1318         }
1319 
1320         return metrics;
1321     }
1322 
1323     byte[] getTableBytes(int tag) {
1324         Buffer buffer = readTable(tag);
1325         byte[] table = null;
1326         if(buffer != null){
1327             table = new byte[buffer.capacity()];
1328             buffer.get(0, table, 0, buffer.capacity());
1329         }
1330         return table;
1331     }
1332 
1333     @Override
1334     public boolean equals(Object obj) {
1335         if (obj == null) {
1336             return false;
1337         }
1338         if (!(obj instanceof PrismFontFile)) {
1339             return false;
1340         }
1341         final PrismFontFile other = (PrismFontFile)obj;
1342         return filename.equals(other.filename) &amp;&amp; fullName.equals(other.fullName);
1343     }
1344 
1345     @Override
1346     public int hashCode() {
1347         return filename.hashCode() + (71 * fullName.hashCode());
1348     }
1349 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>