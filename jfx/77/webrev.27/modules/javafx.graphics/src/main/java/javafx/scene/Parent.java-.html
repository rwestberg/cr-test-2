<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/javafx/scene/Parent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  29 import javafx.beans.property.ReadOnlyBooleanProperty;
  30 import javafx.beans.property.ReadOnlyBooleanWrapper;
  31 import javafx.collections.FXCollections;
  32 import javafx.collections.ListChangeListener.Change;
  33 import javafx.collections.ObservableList;
  34 import java.util.ArrayList;
  35 import java.util.HashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 
  39 import com.sun.javafx.util.TempState;
  40 import com.sun.javafx.util.Utils;
  41 import com.sun.javafx.collections.TrackableObservableList;
  42 import com.sun.javafx.collections.VetoableListDecorator;
  43 import javafx.css.Selector;
  44 import com.sun.javafx.css.StyleManager;
  45 import com.sun.javafx.geom.BaseBounds;
  46 import com.sun.javafx.geom.PickRay;
  47 import com.sun.javafx.geom.Point2D;
  48 import com.sun.javafx.geom.RectBounds;
  49 import com.sun.javafx.geom.transform.BaseTransform;
  50 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  51 import com.sun.javafx.scene.CssFlags;
  52 import com.sun.javafx.scene.DirtyBits;
  53 import com.sun.javafx.scene.input.PickResultChooser;
  54 import com.sun.javafx.sg.prism.NGGroup;
  55 import com.sun.javafx.sg.prism.NGNode;
  56 import com.sun.javafx.tk.Toolkit;
  57 import com.sun.javafx.scene.LayoutFlags;
  58 import com.sun.javafx.scene.NodeHelper;
  59 import com.sun.javafx.scene.ParentHelper;
  60 import com.sun.javafx.stage.WindowHelper;
  61 import java.util.Collections;
  62 import javafx.stage.Window;
  63 
  64 /**
  65  * The base class for all nodes that have children in the scene graph.
  66  * &lt;p&gt;
  67  * This class handles all hierarchical scene graph operations, including adding/removing
  68  * child nodes, marking branches dirty for layout and rendering, picking,
  69  * bounds calculations, and executing the layout pass on each pulse.
  70  * &lt;p&gt;
  71  * There are two direct concrete Parent subclasses
  72  * &lt;ul&gt;
  73  * &lt;li&gt;{@link Group} effects and transforms to be applied to a collection of child nodes.&lt;/li&gt;
  74  * &lt;li&gt;{@link javafx.scene.layout.Region} class for nodes that can be styled with CSS and layout children. &lt;/li&gt;
  75  * &lt;/ul&gt;
  76  *
  77  * @since JavaFX 2.0
  78  */
  79 public abstract class Parent extends Node {
  80     // package private for testing
  81     static final int DIRTY_CHILDREN_THRESHOLD = 10;
  82 
  83     // If set to true, generate a warning message whenever adding a node to a
  84     // parent if it is currently a child of another parent.
  85     private static final boolean warnOnAutoMove = PropertyHelper.getBooleanProperty(&quot;javafx.sg.warn&quot;);
  86 
  87     /**
  88      * Threshold when it&#39;s worth to populate list of removed children.
  89      */
  90     private static final int REMOVED_CHILDREN_THRESHOLD = 20;
  91 
  92     /**
  93      * Do not populate list of removed children when its number exceeds threshold,
  94      * but mark whole parent dirty.
  95      */
  96     private boolean removedChildrenOptimizationDisabled = false;
  97 
  98     static {
  99         // This is used by classes in different packages to get access to
 100         // private and package private methods.
 101         ParentHelper.setParentAccessor(new ParentHelper.ParentAccessor() {
 102             @Override
 103             public NGNode doCreatePeer(Node node) {
 104                 return ((Parent) node).doCreatePeer();
 105             }
 106 
 107             @Override
 108             public void doUpdatePeer(Node node) {
 109                 ((Parent) node).doUpdatePeer();
 110             }
 111 
 112             @Override
 113             public BaseBounds doComputeGeomBounds(Node node,
 114                     BaseBounds bounds, BaseTransform tx) {
 115                 return ((Parent) node).doComputeGeomBounds(bounds, tx);
 116             }
 117 
 118             @Override
 119             public boolean doComputeContains(Node node, double localX, double localY) {
 120                 return ((Parent) node).doComputeContains(localX, localY);
 121             }
 122 
 123             @Override
 124             public void doProcessCSS(Node node) {
 125                 ((Parent) node).doProcessCSS();
 126             }
 127 
 128             @Override
 129             public void doPickNodeLocal(Node node, PickRay localPickRay,
 130                     PickResultChooser result) {
 131                 ((Parent) node).doPickNodeLocal(localPickRay, result);
 132             }
 133 
 134             @Override
 135             public boolean pickChildrenNode(Parent parent, PickRay pickRay, PickResultChooser result) {
 136                 return parent.pickChildrenNode(pickRay, result);
 137             }
 138 
 139             @Override
 140             public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {
 141                 parent.setTraversalEngine(value);
 142             }
 143 
 144             @Override
 145             public ParentTraversalEngine getTraversalEngine(Parent parent) {
 146                 return parent.getTraversalEngine();
 147             }
 148 
 149             @Override
 150             public List&lt;String&gt; doGetAllParentStylesheets(Parent parent) {
 151                 return parent.doGetAllParentStylesheets();
 152             }
 153         });
 154     }
 155 
 156     /*
 157      * Note: This method MUST only be called via its accessor method.
 158      */
 159     private void doUpdatePeer() {
 160         final NGGroup peer = getPeer();
 161 
 162         if (Utils.assertionEnabled()) {
 163             List&lt;NGNode&gt; pgnodes = peer.getChildren();
 164             if (pgnodes.size() != pgChildrenSize) {
 165                 java.lang.System.err.println(&quot;*** pgnodes.size() [&quot; + pgnodes.size() + &quot;] != pgChildrenSize [&quot; + pgChildrenSize + &quot;]&quot;);
 166             }
 167         }
 168 
 169         if (isDirty(DirtyBits.PARENT_CHILDREN)) {
 170             // Whether a permutation, or children having been added or
 171             // removed, we&#39;ll want to clear out the PG side starting
 172             // from startIdx. We know that everything up to but not
 173             // including startIdx is identical between the FX and PG
 174             // sides, so we only need to update the remaining portion.
 175             peer.clearFrom(startIdx);
 176             for (int idx = startIdx; idx &lt; children.size(); idx++) {
 177                 peer.add(idx, children.get(idx).getPeer());
 178             }
 179             if (removedChildrenOptimizationDisabled) {
 180                 peer.markDirty();
 181                 removedChildrenOptimizationDisabled = false;
 182             } else {
 183                 if (removed != null &amp;&amp; !removed.isEmpty()) {
 184                     for(int i = 0; i &lt; removed.size(); i++) {
 185                         peer.addToRemoved(removed.get(i).getPeer());
 186                     }
 187                 }
 188             }
 189             if (removed != null) {
 190                 removed.clear();
 191             }
 192             pgChildrenSize = children.size();
 193             startIdx = pgChildrenSize;
 194         }
 195 
 196         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 197             computeViewOrderChildren();
 198             peer.setViewOrderChildren(viewOrderChildren);
 199         }
 200 
 201         if (Utils.assertionEnabled()) validatePG();
 202     }
 203 
 204 
 205     /***********************************************************************
 206      *                        Scenegraph Structure                         *
 207      *                                                                     *
 208      *  Functions and variables related to the scenegraph structure,       *
 209      *  modifying the structure, and walking the structure.                *
 210      *                                                                     *
 211      **********************************************************************/
 212 
 213     // Used to check for duplicate nodes
 214     private final Set&lt;Node&gt; childSet = new HashSet&lt;Node&gt;();
 215 
 216     // starting child index from which we need to send the children to the PGGroup
 217     private int startIdx = 0;
 218 
 219     // double of children in the PGGroup as of the last update
 220     private int pgChildrenSize = 0;
 221 
 222     void validatePG() {
 223         boolean assertionFailed = false;
 224         final NGGroup peer = getPeer();
 225         List&lt;NGNode&gt; pgnodes = peer.getChildren();
 226         if (pgnodes.size() != children.size()) {
 227             java.lang.System.err.println(&quot;*** pgnodes.size validatePG() [&quot; + pgnodes.size() + &quot;] != children.size() [&quot; + children.size() + &quot;]&quot;);
 228             assertionFailed = true;
 229         } else {
 230             for (int idx = 0; idx &lt; children.size(); idx++) {
 231                 Node n = children.get(idx);
 232                 if (n.getParent() != this) {
 233                     java.lang.System.err.println(&quot;*** this=&quot; + this + &quot; validatePG children[&quot; + idx + &quot;].parent= &quot; + n.getParent());
 234                     assertionFailed = true;
 235                 }
 236                 if (n.getPeer() != pgnodes.get(idx)) {
 237                     java.lang.System.err.println(&quot;*** pgnodes[&quot; + idx + &quot;] validatePG != children[&quot; + idx + &quot;]&quot;);
 238                     assertionFailed = true;
 239                 }
 240             }
 241         }
 242         if (assertionFailed) {
 243             throw new java.lang.AssertionError(&quot;validation of PGGroup children failed&quot;);
 244         }
 245 
 246     }
 247 
 248     void printSeq(String prefix, List&lt;Node&gt; nodes) {
 249         String str = prefix;
 250         for (Node nn : nodes) {
 251             str += nn + &quot; &quot;;
 252         }
 253         System.out.println(str);
 254     }
 255 
 256     /**
 257      * The viewOrderChildren is a list children sorted in decreasing viewOrder
 258      * order if it is not empty. Its size should always be equal to
 259      * children.size(). If viewOrderChildren is empty it implies that the
 260      * rendering order of the children is the same as the order in the children
 261      * list.
 262      */
 263     private final List&lt;Node&gt; viewOrderChildren = new ArrayList(1);
 264 
 265     void markViewOrderChildrenDirty() {
 266         NodeHelper.markDirty(this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
 267     }
 268 
 269     private void computeViewOrderChildren() {
 270         boolean viewOrderSet = false;
 271         for (Node child : children) {
 272             double vo = child.getViewOrder();
 273 
 274             if (!viewOrderSet &amp;&amp; vo != 0) {
 275                 viewOrderSet = true;
 276             }
 277         }
 278 
 279         viewOrderChildren.clear();
 280         if (viewOrderSet) {
 281             viewOrderChildren.addAll(children);
 282 
 283             // Sort in descending order (or big-to-small order)
 284             Collections.sort(viewOrderChildren, (Node a, Node b)
 285                     -&gt; a.getViewOrder() &lt; b.getViewOrder() ? 1
 286                             : a.getViewOrder() == b.getViewOrder() ? 0 : -1);
 287         }
 288     }
 289 
 290     // Call this method if children view order is needed for picking.
 291     // The returned list should be treated as read only.
 292     private List&lt;Node&gt; getOrderedChildren() {
 293         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 294             //Fix for JDK-8205092
 295             computeViewOrderChildren();
 296         }
 297         if (!viewOrderChildren.isEmpty()) {
 298             return viewOrderChildren;
 299         }
 300         return children;
 301     }
 302 
 303     // Variable used to indicate that the change to the children ObservableList is
 304     // a simple permutation as the result of a toFront or toBack operation.
 305     // We can avoid almost all of the processing of the on replace trigger in
 306     // this case.
 307     private boolean childrenTriggerPermutation = false;
 308 
 309     //accumulates all removed nodes between pulses, for dirty area calculation.
 310     private List&lt;Node&gt; removed;
 311 
 312     // set to true if either childRemoved or childAdded returns
 313     // true. These functions will indicate whether the geom
 314     // bounds for the parent have changed
 315     private boolean geomChanged;
 316     private boolean childSetModified;
 317     private final ObservableList&lt;Node&gt; children = new VetoableListDecorator&lt;Node&gt;(new TrackableObservableList&lt;Node&gt;() {
 318 
 319 
 320         protected void onChanged(Change&lt;Node&gt; c) {
 321             // proceed with updating the scene graph
 322             unmodifiableManagedChildren = null;
 323             boolean relayout = false;
 324             boolean viewOrderChildrenDirty = false;
 325 
 326             if (childSetModified) {
 327                 while (c.next()) {
 328                     int from = c.getFrom();
 329                     int to = c.getTo();
 330                     for (int i = from; i &lt; to; ++i) {
 331                         Node n = children.get(i);
 332                         if (n.getParent() != null &amp;&amp; n.getParent() != Parent.this) {
 333                             if (warnOnAutoMove) {
 334                                 java.lang.System.err.println(&quot;WARNING added to a new parent without first removing it from its current&quot;);
 335                                 java.lang.System.err.println(&quot;    parent. It will be automatically removed from its current parent.&quot;);
 336                                 java.lang.System.err.println(&quot;    node=&quot; + n + &quot; oldparent= &quot; + n.getParent() + &quot; newparent=&quot; + this);
 337                             }
 338                             n.getParent().children.remove(n);
 339                             if (warnOnAutoMove) {
 340                                 Thread.dumpStack();
 341                             }
 342                         }
 343                     }
 344 
 345                     List&lt;Node&gt; removed = c.getRemoved();
 346                     int removedSize = removed.size();
 347                     for (int i = 0; i &lt; removedSize; ++i) {
 348                         final Node n = removed.get(i);
 349                         if (n.isManaged()) {
 350                             relayout = true;
 351                         }
 352                     }
 353 
 354                     // Mark viewOrderChildrenDirty if there is modification to children list
 355                     // and view order was set on one or more of the children prior to this change
 356                     if (((removedSize &gt; 0) || (to - from) &gt; 0) &amp;&amp; !viewOrderChildren.isEmpty()) {
 357                         viewOrderChildrenDirty = true;
 358                     }
 359                     // update the parent and scene for each new node
 360                     for (int i = from; i &lt; to; ++i) {
 361                         Node node = children.get(i);
 362 
 363                         // Newly added node has view order set.
 364                         if (node.getViewOrder() != 0) {
 365                             viewOrderChildrenDirty = true;
 366                         }
 367                         if (node.isManaged() || (node instanceof Parent &amp;&amp; ((Parent) node).layoutFlag != LayoutFlags.CLEAN)) {
 368                             relayout = true;
 369                         }
 370                         node.setParent(Parent.this);
 371                         node.setScenes(getScene(), getSubScene());
 372                         // assert !node.boundsChanged;
 373                         if (node.isVisible()) {
 374                             geomChanged = true;
 375                             childIncluded(node);
 376                         }
 377                     }
 378                 }
 379 
 380                 // check to see if the number of children exceeds
 381                 // DIRTY_CHILDREN_THRESHOLD and dirtyChildren is null.
 382                 // If so, then we need to create dirtyChildren and
 383                 // populate it.
 384                 if (dirtyChildren == null &amp;&amp; children.size() &gt; DIRTY_CHILDREN_THRESHOLD) {
 385                     dirtyChildren
 386                             = new ArrayList&lt;Node&gt;(2 * DIRTY_CHILDREN_THRESHOLD);
 387                     // only bother populating children if geom has
 388                     // changed, otherwise there is no need
 389                     if (dirtyChildrenCount &gt; 0) {
 390                         int size = children.size();
 391                         for (int i = 0; i &lt; size; ++i) {
 392                             Node ch = children.get(i);
 393                             if (ch.isVisible() &amp;&amp; ch.boundsChanged) {
 394                                 dirtyChildren.add(ch);
 395                             }
 396                         }
 397                     }
 398                 }
 399             } else {
 400                 // If childSet was not modified, we still need to check whether the permutation
 401                 // did change the layout
 402                 layout_loop:while (c.next()) {
 403                     List&lt;Node&gt; removed = c.getRemoved();
 404                     for (int i = 0, removedSize = removed.size(); i &lt; removedSize; ++i) {
 405                         if (removed.get(i).isManaged()) {
 406                             relayout = true;
 407                             break layout_loop;
 408                         }
 409                     }
 410 
 411                     for (int i = c.getFrom(), to = c.getTo(); i &lt; to; ++i) {
 412                         if (children.get(i).isManaged()) {
 413                             relayout = true;
 414                             break layout_loop;
 415                         }
 416                     }
 417                 }
 418             }
 419 
 420 
 421             //
 422             // Note that the styles of a child do not affect the parent or
 423             // its siblings. Thus, it is only necessary to reapply css to
 424             // the Node just added and not to this parent and all of its
 425             // children. So the following call to reapplyCSS was moved
 426             // to Node.parentProperty. The original comment and code were
 427             // purposely left here as documentation should there be any
 428             // question about how the code used to work and why the change
 429             // was made.
 430             //
 431             // if children have changed then I need to reapply
 432             // CSS from this node on down
 433 //                reapplyCSS();
 434             //
 435 
 436             // request layout if a Group subclass has overridden doLayout OR
 437             // if one of the new children needs layout, in which case need to ensure
 438             // the needsLayout flag is set all the way to the root so the next layout
 439             // pass will reach the child.
 440             if (relayout) {
 441                 requestLayout();
 442             }
 443 
 444             if (geomChanged) {
 445                 NodeHelper.geomChanged(Parent.this);
 446             }
 447 
 448             // Note the starting index at which we need to update the
 449             // PGGroup on the next update, and mark the children dirty
 450             c.reset();
 451             c.next();
 452             if (startIdx &gt; c.getFrom()) {
 453                 startIdx = c.getFrom();
 454             }
 455 
 456             NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN);
 457             // Force synchronization to include the handling of invisible node
 458             // so that removed list will get cleanup to prevent memory leak.
 459             NodeHelper.markDirty(Parent.this, DirtyBits.NODE_FORCE_SYNC);
 460 
 461             if (viewOrderChildrenDirty) {
 462                 NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
 463             }
 464         }
 465 
 466     }) {
 467         @Override
 468         protected void onProposedChange(final List&lt;Node&gt; newNodes, int[] toBeRemoved) {
 469             final Scene scene = getScene();
 470             if (scene != null) {
 471                 Window w = scene.getWindow();
 472                 if (w != null &amp;&amp; WindowHelper.getPeer(w) != null) {
 473                     Toolkit.getToolkit().checkFxUserThread();
 474                 }
 475             }
 476             geomChanged = false;
 477 
 478             long newLength = children.size() + newNodes.size();
 479             int removedLength = 0;
 480             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 481                 removedLength += toBeRemoved[i + 1] - toBeRemoved[i];
 482             }
 483             newLength -= removedLength;
 484 
 485             // If the childrenTriggerPermutation flag is set, then we know it
 486             // is a simple permutation and no further checking is needed.
 487             if (childrenTriggerPermutation) {
 488                 childSetModified = false;
 489                 return;
 490             }
 491 
 492             // If the childrenTriggerPermutation flag is not set, then we will
 493             // check to see whether any element in the ObservableList has changed,
 494             // or whether the new ObservableList is a permutation on the existing
 495             // ObservableList. Note that even if the childrenModified flag is false,
 496             // we still have to check for duplicates. If it is a simple
 497             // permutation, we can avoid checking for cycles or other parents.
 498             childSetModified = true;
 499             if (newLength == childSet.size()) {
 500                 childSetModified = false;
 501                 for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 502                     Node n = newNodes.get(i);
 503                     if (!childSet.contains(n)) {
 504                         childSetModified = true;
 505                         break;
 506                     }
 507                 }
 508             }
 509 
 510             // Enforce scene graph invariants, and check for structural errors.
 511             //
 512             // 1. If a child has been added to this parent more than once,
 513             // then it is an error
 514             //
 515             // 2. If a child is a target of a clip, then it is an error.
 516             //
 517             // 3. If a node would cause a cycle, then it is an error.
 518             //
 519             // 4. If a node is null
 520             //
 521             // Note that if a node is the child of another parent, we will
 522             // implicitly remove the node from its former Parent after first
 523             // checking for errors.
 524 
 525             // iterate over the nodes that were removed and remove them from
 526             // the hash set.
 527             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 528                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 529                     childSet.remove(children.get(j));
 530                 }
 531             }
 532 
 533             try {
 534                 if (childSetModified) {
 535                     // check individual children before duplication test
 536                     // if done in this order, the exception is more specific
 537                     for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 538                         Node node = newNodes.get(i);
 539                         if (node == null) {
 540                             throw new NullPointerException(
 541                                     constructExceptionMessage(
 542                                         &quot;child node is null&quot;, null));
 543                         }
 544                         if (node.getClipParent() != null) {
 545                             throw new IllegalArgumentException(
 546                                     constructExceptionMessage(
 547                                         &quot;node already used as a clip&quot;, node));
 548                         }
 549                         if (wouldCreateCycle(Parent.this, node)) {
 550                             throw new IllegalArgumentException(
 551                                     constructExceptionMessage(
 552                                         &quot;cycle detected&quot;, node));
 553                         }
 554                     }
 555                 }
 556 
 557                 childSet.addAll(newNodes);
 558                 if (childSet.size() != newLength) {
 559                     throw new IllegalArgumentException(
 560                             constructExceptionMessage(
 561                                 &quot;duplicate children added&quot;, null));
 562                 }
 563             } catch (RuntimeException e) {
 564                 //Return children to it&#39;s original state
 565                 childSet.clear();
 566                 childSet.addAll(children);
 567 
 568                 // rethrow
 569                 throw e;
 570             }
 571 
 572             // Done with error checking
 573 
 574             if (!childSetModified) {
 575                 return;
 576             }
 577 
 578             // iterate over the nodes that were removed and clear their
 579             // parent and scene. Add to them also to removed list for further
 580             // dirty regions calculation.
 581             if (removed == null) {
 582                 removed = new ArrayList&lt;Node&gt;();
 583             }
 584             if (removed.size() + removedLength &gt; REMOVED_CHILDREN_THRESHOLD || !isTreeVisible()) {
 585                 //do not populate too many children in removed list
 586                 removedChildrenOptimizationDisabled = true;
 587             }
 588             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 589                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 590                     Node old = children.get(j);
 591                     final Scene oldScene = old.getScene();
 592                     if (oldScene != null) {
 593                         oldScene.generateMouseExited(old);
 594                     }
 595                     if (dirtyChildren != null) {
 596                         dirtyChildren.remove(old);
 597                     }
 598                     if (old.isVisible()) {
 599                         geomChanged = true;
 600                         childExcluded(old);
 601                     }
 602                     if (old.getParent() == Parent.this) {
 603                         old.setParent(null);
 604                         old.setScenes(null, null);
 605                     }
 606                     // Do not add node with null scene to the removed list.
 607                     // It will not be processed in the list and its memory
 608                     // will not be freed.
 609                     if (scene != null &amp;&amp; !removedChildrenOptimizationDisabled) {
 610                         removed.add(old);
 611                     }
 612                 }
 613             }
 614         }
 615 
 616         private String constructExceptionMessage(
 617                 String cause, Node offendingNode) {
 618             final StringBuilder sb = new StringBuilder(&quot;Children: &quot;);
 619             sb.append(cause);
 620             sb.append(&quot;: parent = &quot;).append(Parent.this);
 621             if (offendingNode != null) {
 622                 sb.append(&quot;, node = &quot;).append(offendingNode);
 623             }
 624 
 625             return sb.toString();
 626         }
 627     };
 628 
 629     /**
 630      * A constant reference to an unmodifiable view of the children, such that every time
 631      * we ask for an unmodifiable list of children, we don&#39;t actually create a new
 632      * collection and return it. The memory overhead is pretty lightweight compared
 633      * to all the garbage we would otherwise generate.
 634      */
 635     private final ObservableList&lt;Node&gt; unmodifiableChildren =
 636             FXCollections.unmodifiableObservableList(children);
 637 
 638     /**
 639      * A cached reference to the unmodifiable managed children of this Parent. This is
 640      * created whenever first asked for, and thrown away whenever children are added
 641      * or removed or when their managed state changes. This could be written
 642      * differently, such that this list is essentially a filtered copy of the
 643      * main children, but that additional overhead might not be worth it.
 644      */
 645     private List&lt;Node&gt; unmodifiableManagedChildren = null;
 646 
 647     /**
 648      * Gets the list of children of this {@code Parent}.
 649      *
 650      * &lt;p&gt;
 651      * See the class documentation for {@link Node} for scene graph structure
 652      * restrictions on setting a {@link Parent}&#39;s children list.
 653      * If these restrictions are violated by a change to the list of children,
 654      * the change is ignored and the previous value of the children list is
 655      * restored. An {@link IllegalArgumentException} is thrown in this case.
 656      *
 657      * &lt;p&gt;
 658      * If this {@link Parent} node is attached to a {@link Scene} attached to a {@link Window}
 659      * that is showning ({@link javafx.stage.Window#isShowing()}), then its
 660      * list of children must only be modified on the JavaFX Application Thread.
 661      * An {@link IllegalStateException} is thrown if this restriction is
 662      * violated.
 663      *
 664      * &lt;p&gt;
 665      * Note to subclasses: if you override this method, you must return from
 666      * your implementation the result of calling this super method. The actual
 667      * list instance returned from any getChildren() implementation must be
 668      * the list owned and managed by this Parent. The only typical purpose
 669      * for overriding this method is to promote the method to be public.
 670      *
 671      * @return the list of children of this {@code Parent}.
 672      */
 673     protected ObservableList&lt;Node&gt; getChildren() {
 674         return children;
 675     }
 676 
 677     /**
 678      * Gets the list of children of this {@code Parent} as a read-only
 679      * list.
 680      *
 681      * @return read-only access to this parent&#39;s children ObservableList
 682      */
 683     public ObservableList&lt;Node&gt; getChildrenUnmodifiable() {
 684         return unmodifiableChildren;
 685     }
 686 
 687     /**
 688      * Gets the list of all managed children of this {@code Parent}.
 689      *
 690      * @param &lt;E&gt; the type of the children nodes
 691      * @return list of all managed children in this parent
 692      */
 693     protected &lt;E extends Node&gt; List&lt;E&gt; getManagedChildren() {
 694         if (unmodifiableManagedChildren == null) {
 695             unmodifiableManagedChildren = new ArrayList&lt;Node&gt;();
 696             for (int i=0, max=children.size(); i&lt;max; i++) {
 697                 Node e = children.get(i);
 698                 if (e.isManaged()) {
 699                     unmodifiableManagedChildren.add(e);
 700                 }
 701             }
 702         }
 703         return (List&lt;E&gt;)unmodifiableManagedChildren;
 704     }
 705 
 706     /**
 707      * Called by Node whenever its managed state may have changed, this
 708      * method will cause the view of managed children to be updated
 709      * such that it properly includes or excludes this child.
 710      */
 711     final void managedChildChanged() {
 712         requestLayout();
 713         unmodifiableManagedChildren = null;
 714     }
 715 
 716     // implementation of Node.toFront function
 717     final void toFront(Node node) {
 718         if (Utils.assertionEnabled()) {
 719             if (!childSet.contains(node)) {
 720                 throw new java.lang.AssertionError(
 721                         &quot;specified node is not in the list of children&quot;);
 722             }
 723         }
 724 
 725         if (children.get(children.size() - 1) != node) {
 726             childrenTriggerPermutation = true;
 727             try {
 728                 children.remove(node);
 729                 children.add(node);
 730             } finally {
 731                 childrenTriggerPermutation = false;
 732             }
 733         }
 734     }
 735 
 736     // implementation of Node.toBack function
 737     final void toBack(Node node) {
 738         if (Utils.assertionEnabled()) {
 739             if (!childSet.contains(node)) {
 740                 throw new java.lang.AssertionError(
 741                         &quot;specified node is not in the list of children&quot;);
 742             }
 743         }
 744 
 745         if (children.get(0) != node) {
 746             childrenTriggerPermutation = true;
 747             try {
 748                 children.remove(node);
 749                 children.add(0, node);
 750             } finally {
 751                 childrenTriggerPermutation = false;
 752             }
 753         }
 754     }
 755 
 756     @Override
 757     void scenesChanged(final Scene newScene, final SubScene newSubScene,
 758                        final Scene oldScene, final SubScene oldSubScene) {
 759 
 760         if (oldScene != null &amp;&amp; newScene == null) {
 761             // RT-34863 - clean up CSS cache when Parent is removed from scene-graph
 762             StyleManager.getInstance().forget(this);
 763 
 764             // Clear removed list on parent who is no longer in a scene
 765             if (removed != null) {
 766                 removed.clear();
 767             }
 768         }
 769 
 770         for (int i=0; i&lt;children.size(); i++) {
 771             children.get(i).setScenes(newScene, newSubScene);
 772         }
 773 
 774         final boolean awaitingLayout = layoutFlag != LayoutFlags.CLEAN;
 775 
 776         sceneRoot = (newSubScene != null &amp;&amp; newSubScene.getRoot() == this) ||
 777                     (newScene != null &amp;&amp; newScene.getRoot() == this);
 778         layoutRoot = !isManaged() || sceneRoot;
 779 
 780 
 781         if (awaitingLayout) {
 782             // If this node is dirty and the new scene or subScene is not null
 783             // then add this node to the new scene&#39;s dirty list
 784             if (newScene != null &amp;&amp; layoutRoot) {
 785                 if (newSubScene != null) {
 786                     newSubScene.setDirtyLayout(this);
 787                 }
 788             }
 789         }
 790     }
 791 
 792     @Override
 793     void setDerivedDepthTest(boolean value) {
 794         super.setDerivedDepthTest(value);
 795 
 796         for (int i=0, max=children.size(); i&lt;max; i++) {
 797             final Node node = children.get(i);
 798             node.computeDerivedDepthTest();
 799         }
 800     }
 801 
 802     boolean pickChildrenNode(PickRay pickRay, PickResultChooser result) {
 803         List&lt;Node&gt; orderedChildren = getOrderedChildren();
 804         for (int i = orderedChildren.size() - 1; i &gt;= 0; i--) {
 805             orderedChildren.get(i).pickNode(pickRay, result);
 806             if (result.isClosed()) {
 807                 return false;
 808             }
 809         }
 810         return true;
 811     }
 812 
 813     /*
 814      * Note: This method MUST only be called via its accessor method.
 815      */
 816     private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
 817          double boundsDistance = intersectsBounds(pickRay);
 818 
 819         if (!Double.isNaN(boundsDistance) &amp;&amp; pickChildrenNode(pickRay, result)) {
 820             if (isPickOnBounds()) {
 821                 result.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 822             }
 823         }
 824     }
 825 
 826     @Override boolean isConnected() {
 827         return super.isConnected() || sceneRoot;
 828     }
 829 
 830     @Override public Node lookup(String selector) {
 831         Node n = super.lookup(selector);
 832         if (n == null) {
 833             for (int i=0, max=children.size(); i&lt;max; i++) {
 834                 final Node node = children.get(i);
 835                 n = node.lookup(selector);
 836                 if (n != null) return n;
 837             }
 838         }
 839         return n;
 840     }
 841 
 842     /**
 843      * Please Note: This method should never create the results set,
 844      * let the Node class implementation do this!
 845      */
 846     @Override List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 847         results = super.lookupAll(selector, results);
 848         for (int i=0, max=children.size(); i&lt;max; i++) {
 849             final Node node = children.get(i);
 850             results = node.lookupAll(selector, results);
 851         }
 852         return results;
 853     }
 854 
 855     private ParentTraversalEngine traversalEngine;
 856 
 857     private final void setTraversalEngine(ParentTraversalEngine value) {
 858         this.traversalEngine = value;
 859     }
 860 
 861     private final ParentTraversalEngine getTraversalEngine() {
 862         return traversalEngine;
 863     }
 864 
 865     /***********************************************************************
 866      *                               Layout                                *
 867      *                                                                     *
 868      *  Functions and variables related to the layout scheme used by       *
 869      *  JavaFX. Includes both public and private API.                      *
 870      *                                                                     *
 871      **********************************************************************/
 872     /**
 873      * Indicates that this Node and its subnodes requires a layout pass on
 874      * the next pulse.
 875      */
 876     private ReadOnlyBooleanWrapper needsLayout;
 877     LayoutFlags layoutFlag = LayoutFlags.CLEAN;
 878 
 879     protected final void setNeedsLayout(boolean value) {
 880         if (value) {
 881             markDirtyLayout(true, false);
 882         } else if (layoutFlag == LayoutFlags.NEEDS_LAYOUT) {
 883             boolean hasBranch = false;
 884             for (int i = 0, max = children.size(); i &lt; max; i++) {
 885                 final Node child = children.get(i);
 886                 if (child instanceof Parent) {
 887                     if (((Parent)child).layoutFlag != LayoutFlags.CLEAN) {
 888                         hasBranch = true;
 889                         break;
 890                     }
 891 
 892                 }
 893             }
 894             setLayoutFlag(hasBranch ? LayoutFlags.DIRTY_BRANCH : LayoutFlags.CLEAN);
 895         }
 896     }
 897 
 898     public final boolean isNeedsLayout() {
 899         return layoutFlag == LayoutFlags.NEEDS_LAYOUT;
 900     }
 901 
 902     public final ReadOnlyBooleanProperty needsLayoutProperty() {
 903         if (needsLayout == null) {
 904             needsLayout = new ReadOnlyBooleanWrapper(this, &quot;needsLayout&quot;, layoutFlag == LayoutFlags.NEEDS_LAYOUT);
 905         }
 906         return needsLayout;
 907     }
 908 
 909     /**
 910      * This is used only by CCS in Node. It is set to true while
 911      * the layout() function is processing and set to false on the conclusion.
 912      * It is used by the Node to decide whether to perform CSS updates
 913      * synchronously or asynchronously.
 914      */
 915     private boolean performingLayout = false;
 916 
 917     boolean isPerformingLayout() {
 918         return performingLayout;
 919     }
 920 
 921     private boolean sizeCacheClear = true;
 922     private double prefWidthCache = -1;
 923     private double prefHeightCache = -1;
 924     private double minWidthCache = -1;
 925     private double minHeightCache = -1;
 926 
 927     void setLayoutFlag(LayoutFlags flag) {
 928         if (needsLayout != null) {
 929             needsLayout.set(flag == LayoutFlags.NEEDS_LAYOUT);
 930         }
 931         layoutFlag = flag;
 932     }
 933 
 934     private void markDirtyLayout(boolean local, boolean forceParentLayout) {
 935         setLayoutFlag(LayoutFlags.NEEDS_LAYOUT);
 936         if (local || layoutRoot) {
 937             if (sceneRoot) {
 938                 Toolkit.getToolkit().requestNextPulse();
 939                 if (getSubScene() != null) {
 940                     getSubScene().setDirtyLayout(this);
 941                 }
 942             } else {
 943                 markDirtyLayoutBranch();
 944             }
 945         } else {
 946             requestParentLayout(forceParentLayout);
 947         }
 948     }
 949 
 950     /**
 951      * Requests a layout pass to be performed before the next scene is
 952      * rendered. This is batched up asynchronously to happen once per
 953      * &quot;pulse&quot;, or frame of animation.
 954      * &lt;p&gt;
 955      * If this parent is either a layout root or unmanaged, then it will be
 956      * added directly to the scene&#39;s dirty layout list, otherwise requestParentLayout
 957      * will be invoked.
 958      * @since JavaFX 8.0
 959      */
 960     public void requestLayout() {
 961         clearSizeCache();
 962         markDirtyLayout(false, forceParentLayout);
 963     }
 964 
 965     private boolean forceParentLayout = false;
 966     /**
 967      * A package scope method used by Node and serves as a helper method for
 968      * requestLayout() (see above). If forceParentLayout is true it will
 969      * propagate this force layout flag to its parent.
 970      */
 971     void requestLayout(boolean forceParentLayout) {
 972         boolean savedForceParentLayout = this.forceParentLayout;
 973         this.forceParentLayout = forceParentLayout;
 974         requestLayout();
 975         this.forceParentLayout = savedForceParentLayout;
 976     }
 977 
 978     /**
 979      * Requests a layout pass of the parent to be performed before the next scene is
 980      * rendered. This is batched up asynchronously to happen once per
 981      * &quot;pulse&quot;, or frame of animation.
 982      * &lt;p&gt;
 983      * This may be used when the current parent have changed it&#39;s min/max/preferred width/height,
 984      * but doesn&#39;t know yet if the change will lead to it&#39;s actual size change. This will be determined
 985      * when it&#39;s parent recomputes the layout with the new hints.
 986      */
 987     protected final void requestParentLayout() {
 988        requestParentLayout(false);
 989     }
 990 
 991     /**
 992      * A package scope method used by Node and serves as a helper method for
 993      * requestParentLayout() (see above). If forceParentLayout is true it will
 994      * force a request layout call on its parent if its parent is not null.
 995      */
 996     void requestParentLayout(boolean forceParentLayout) {
 997         if (!layoutRoot) {
 998             final Parent p = getParent();
 999             if (p != null &amp;&amp; (!p.performingLayout || forceParentLayout)) {
1000                 p.requestLayout();
1001             }
1002         }
1003     }
1004 
1005     void clearSizeCache() {
1006         if (sizeCacheClear) {
1007             return;
1008         }
1009         sizeCacheClear = true;
1010         prefWidthCache = -1;
1011         prefHeightCache = -1;
1012         minWidthCache = -1;
1013         minHeightCache = -1;
1014     }
1015 
1016     @Override public double prefWidth(double height) {
1017         if (height == -1) {
1018             if (prefWidthCache == -1) {
1019                 prefWidthCache = computePrefWidth(-1);
1020                 if (Double.isNaN(prefWidthCache) || prefWidthCache &lt; 0) prefWidthCache = 0;
1021                 sizeCacheClear = false;
1022             }
1023             return prefWidthCache;
1024         } else {
1025             double result = computePrefWidth(height);
1026             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1027         }
1028     }
1029 
1030     @Override public double prefHeight(double width) {
1031         if (width == -1) {
1032             if (prefHeightCache == -1) {
1033                 prefHeightCache = computePrefHeight(-1);
1034                 if (Double.isNaN(prefHeightCache) || prefHeightCache &lt; 0) prefHeightCache = 0;
1035                 sizeCacheClear = false;
1036             }
1037             return prefHeightCache;
1038         } else {
1039             double result = computePrefHeight(width);
1040             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1041         }
1042     }
1043 
1044     @Override public double minWidth(double height) {
1045         if (height == -1) {
1046             if (minWidthCache == -1) {
1047                 minWidthCache = computeMinWidth(-1);
1048                 if (Double.isNaN(minWidthCache) || minWidthCache &lt; 0) minWidthCache = 0;
1049                 sizeCacheClear = false;
1050             }
1051             return minWidthCache;
1052         } else {
1053             double result = computeMinWidth(height);
1054             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1055         }
1056     }
1057 
1058     @Override public double minHeight(double width) {
1059         if (width == -1) {
1060             if (minHeightCache == -1) {
1061                 minHeightCache = computeMinHeight(-1);
1062                 if (Double.isNaN(minHeightCache) || minHeightCache &lt; 0) minHeightCache = 0;
1063                 sizeCacheClear = false;
1064             }
1065             return minHeightCache;
1066         } else {
1067             double result = computeMinHeight(width);
1068             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1069         }
1070     }
1071 
1072     // PENDING_DOC_REVIEW
1073     /**
1074      * Calculates the preferred width of this {@code Parent}. The default
1075      * implementation calculates this width as the width of the area occupied
1076      * by its managed children when they are positioned at their
1077      * current positions at their preferred widths.
1078      *
1079      * @param height the height that should be used if preferred width depends
1080      *      on it
1081      * @return the calculated preferred width
1082      */
1083     protected double computePrefWidth(double height) {
1084         double minX = 0;
1085         double maxX = 0;
1086         for (int i=0, max=children.size(); i&lt;max; i++) {
1087             Node node = children.get(i);
1088             if (node.isManaged()) {
1089                 final double x = node.getLayoutBounds().getMinX() + node.getLayoutX();
1090                 minX = Math.min(minX, x);
1091                 maxX = Math.max(maxX, x + boundedSize(node.prefWidth(-1), node.minWidth(-1), node.maxWidth(-1)));
1092             }
1093         }
1094         return maxX - minX;
1095     }
1096 
1097     // PENDING_DOC_REVIEW
1098     /**
1099      * Calculates the preferred height of this {@code Parent}. The default
1100      * implementation calculates this height as the height of the area occupied
1101      * by its managed children when they are positioned at their current
1102      * positions at their preferred heights.
1103      *
1104      * @param width the width that should be used if preferred height depends
1105      *      on it
1106      * @return the calculated preferred height
1107      */
1108     protected double computePrefHeight(double width) {
1109         double minY = 0;
1110         double maxY = 0;
1111         for (int i=0, max=children.size(); i&lt;max; i++) {
1112             Node node = children.get(i);
1113             if (node.isManaged()) {
1114                 final double y = node.getLayoutBounds().getMinY() + node.getLayoutY();
1115                 minY = Math.min(minY, y);
1116                 maxY = Math.max(maxY, y + boundedSize(node.prefHeight(-1), node.minHeight(-1), node.maxHeight(-1)));
1117             }
1118         }
1119         return maxY - minY;
1120     }
1121 
1122     /**
1123      * Calculates the minimum width of this {@code Parent}. The default
1124      * implementation simply returns the pref width.
1125      *
1126      * @param height the height that should be used if min width depends
1127      *      on it
1128      * @return the calculated min width
1129      * @since JavaFX 2.1
1130      */
1131     protected double computeMinWidth(double height) {
1132         return prefWidth(height);
1133     }
1134 
1135     // PENDING_DOC_REVIEW
1136     /**
1137      * Calculates the min height of this {@code Parent}. The default
1138      * implementation simply returns the pref height;
1139      *
1140      * @param width the width that should be used if min height depends
1141      *      on it
1142      * @return the calculated min height
1143      * @since JavaFX 2.1
1144      */
1145     protected double computeMinHeight(double width) {
1146         return prefHeight(width);
1147     }
1148 
1149     /**
1150      * Calculates the baseline offset based on the first managed child. If there
1151      * is no such child, returns {@link Node#getBaselineOffset()}.
1152      *
1153      * @return baseline offset
1154      */
1155     @Override public double getBaselineOffset() {
1156         for (int i=0, max=children.size(); i&lt;max; i++) {
1157             final Node child = children.get(i);
1158             if (child.isManaged()) {
1159                 double offset = child.getBaselineOffset();
1160                 if (offset == BASELINE_OFFSET_SAME_AS_HEIGHT) {
1161                     continue;
1162                 }
1163                 return child.getLayoutBounds().getMinY() + child.getLayoutY() + offset;
1164             }
1165         }
1166         return super.getBaselineOffset();
1167     }
1168 
1169     /***
1170      * It stores the reference to the current child being laid out by its parent.
1171      * This reference is important to differentiate whether a layout is triggered
1172      * by its parent or other events.
1173      */
1174     private Node currentLayoutChild = null;
1175 
1176     boolean isCurrentLayoutChild(Node node) {
1177         return node == currentLayoutChild;
1178     }
1179 
1180     /**
1181      * Executes a top-down layout pass on the scene graph under this parent.
1182      *
1183      * Calling this method while the Parent is doing layout is a no-op.
1184      */
1185     public final void layout() {
1186         // layoutFlag can be accessed or changed during layout processing.
1187         // Hence we need to cache and reset it before performing layout.
1188         LayoutFlags flag = layoutFlag;
1189         setLayoutFlag(LayoutFlags.CLEAN);
1190         switch(flag) {
1191             case CLEAN:
1192                 break;
1193             case NEEDS_LAYOUT:
1194                 if (performingLayout) {
1195                     /* This code is here mainly to avoid infinite loops as layout() is public and the call might be (indirectly) invoked accidentally
1196                      * while doing the layout.
1197                      * One example might be an invocation from Group layout bounds recalculation
1198                      *  (e.g. during the localToScene/localToParent calculation).
1199                      * The layout bounds will thus return layout bounds that are &quot;old&quot; (i.e. before the layout changes, that are just being done),
1200                      * which is likely what the code would expect.
1201                      * The changes will invalidate the layout bounds again however, so the layout bounds query after layout pass will return correct answer.
1202                      */
1203                     break;
1204                 }
1205                 performingLayout = true;
1206                 layoutChildren();
1207                 // Intended fall-through
1208             case DIRTY_BRANCH:
1209                 for (int i = 0, max = children.size(); i &lt; max; i++) {
1210                     final Node child = children.get(i);
1211                     currentLayoutChild = child;
1212                     if (child instanceof Parent) {
1213                         ((Parent)child).layout();
1214                     } else if (child instanceof SubScene) {
1215                         ((SubScene)child).layoutPass();
1216                     }
1217                 }
1218                 currentLayoutChild = null;
1219                 performingLayout = false;
1220                 break;
1221         }
1222     }
1223 
1224     /**
1225      * Invoked during the layout pass to layout the children in this
1226      * {@code Parent}. By default it will only set the size of managed,
1227      * resizable content to their preferred sizes and does not do any node
1228      * positioning.
1229      * &lt;p&gt;
1230      * Subclasses should override this function to layout content as needed.
1231      */
1232     protected void layoutChildren() {
1233         for (int i=0, max=children.size(); i&lt;max; i++) {
1234             final Node node = children.get(i);
1235             currentLayoutChild = node;
1236             if (node.isResizable() &amp;&amp; node.isManaged()) {
1237                 node.autosize();
1238             }
1239         }
1240         currentLayoutChild = null;
1241     }
1242 
1243     /**
1244      * This field is managed by the Scene, and set on any node which is the
1245      * root of a Scene.
1246      */
1247     private boolean sceneRoot = false;
1248 
1249     /**
1250      * Keeps track of whether this node is a layout root. This is updated
1251      * whenever the sceneRoot field changes, or whenever the managed
1252      * property changes.
1253      */
1254     boolean layoutRoot = false;
1255     @Override final void notifyManagedChanged() {
1256         layoutRoot = !isManaged() || sceneRoot;
1257     }
1258 
1259     final boolean isSceneRoot() {
1260         return sceneRoot;
1261     }
1262 
1263     /***********************************************************************
1264      *                                                                     *
1265      *                         Stylesheet Handling                         *
1266      *                                                                     *
1267      **********************************************************************/
1268 
1269 
1270     /**
1271      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1272      * contents. For additional information about using CSS with the
1273      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1274      * Guide&lt;/a&gt;.
1275      */
1276     private final ObservableList&lt;String&gt; stylesheets = new TrackableObservableList&lt;String&gt;() {
1277         @Override
1278         protected void onChanged(Change&lt;String&gt; c) {
1279             final Scene scene = getScene();
1280             if (scene != null) {
1281 
1282                 // Notify the StyleManager if stylesheets change. This Parent&#39;s
1283                 // styleManager will get recreated in NodeHelper.processCSS.
1284                 StyleManager.getInstance().stylesheetsChanged(Parent.this, c);
1285 
1286                 // RT-9784 - if stylesheet is removed, reset styled properties to
1287                 // their initial value.
1288                 c.reset();
1289                 while(c.next()) {
1290                     if (c.wasRemoved() == false) {
1291                         continue;
1292                     }
1293                     break; // no point in resetting more than once...
1294                 }
1295 
1296                 reapplyCSS();
1297             }
1298         }
1299     };
1300 
1301     /**
1302      * Gets an observable list of string URLs linking to the stylesheets to use
1303      * with this Parent&#39;s contents. See {@link Scene#getStylesheets()} for details.
1304      * &lt;p&gt;For additional information about using CSS
1305      * with the scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1306      * Guide&lt;/a&gt;.&lt;/p&gt;
1307      *
1308      * @return the list of stylesheets to use with this Parent
1309      * @since JavaFX 2.1
1310      */
1311     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1312 
1313     /*
1314      * This method recurses up the parent chain until parent is null. As the
1315      * stack unwinds, if the Parent has stylesheets, they are added to the
1316      * list.
1317      *
1318      * It is possible to override this method to stop the recursion. This allows
1319      * a Parent to have a set of stylesheets distinct from its Parent.
1320      *
1321      * Note: This method MUST only be called via its accessor method.
1322      */
1323      // SB-dependency: RT-21247 has been filed to track this
1324     private List&lt;String&gt; doGetAllParentStylesheets() {
1325 
1326         List&lt;String&gt; list = null;
1327         final Parent myParent = getParent();
1328         if (myParent != null) {
1329 
1330             //
1331             // recurse so that stylesheets of Parents closest to the root are
1332             // added to the list first. The ensures that declarations for
1333             // stylesheets further down the tree (closer to the leaf) have
1334             // a higer ordinal in the cascade.
1335             //
1336             list = ParentHelper.getAllParentStylesheets(myParent);
1337         }
1338 
1339         if (stylesheets != null &amp;&amp; stylesheets.isEmpty() == false) {
1340             if (list == null) {
1341                 list = new ArrayList&lt;String&gt;(stylesheets.size());
1342             }
1343             for (int n=0,nMax=stylesheets.size(); n&lt;nMax; n++) {
1344                 list.add(stylesheets.get(n));
1345             }
1346         }
1347 
1348         return list;
1349 
1350     }
1351 
1352     /*
1353      * Note: This method MUST only be called via its accessor method.
1354      */
1355     private void doProcessCSS() {
1356 
1357         // Nothing to do...
1358         if (cssFlag == CssFlags.CLEAN) return;
1359 
1360         // RT-29254 - If DIRTY_BRANCH, pass control to Node#processCSS. This avoids calling NodeHelper.processCSS on
1361         // this node and all of its children when css doesn&#39;t need updated, recalculated, or reapplied.
1362         if (cssFlag == CssFlags.DIRTY_BRANCH) {
1363             super.processCSS();
1364             return;
1365         }
1366 
1367         // Let the super implementation handle CSS for this node
1368         ParentHelper.superProcessCSS(this);
1369 
1370         // avoid the following call to children.toArray if there are no children
1371         if (children.isEmpty()) return;
1372 
1373         //
1374         // RT-33103
1375         //
1376         // It is possible for a child to be removed from children in the middle of
1377         // the following loop. Iterating over the children may result in an IndexOutOfBoundsException.
1378         // So a copy is made and the copy is iterated over.
1379         //
1380         // Note that we don&#39;t want the fail-fast feature of an iterator, not to mention the general iterator overhead.
1381         //
1382         final Node[] childArray = children.toArray(new Node[children.size()]);
1383 
1384         // For each child, process CSS
1385         for (int i=0; i&lt;childArray.length; i++) {
1386 
1387             final Node child = childArray[i];
1388 
1389             //  If a child no longer has this as its parent, then it is skipped.
1390             final Parent childParent = child.getParent();
1391             if (childParent == null || childParent != this) continue;
1392 
1393             // If the parent styles are being updated, recalculated or
1394             // reapplied, then make sure the children get the same treatment.
1395             // Unless the child is already more dirty than this parent (RT-29074).
1396             if(CssFlags.UPDATE.compareTo(child.cssFlag) &gt; 0) {
1397                 child.cssFlag = CssFlags.UPDATE;
1398             }
1399             NodeHelper.processCSS(child);
1400         }
1401     }
1402 
1403     /***********************************************************************
1404      *                               Misc                                  *
1405      *                                                                     *
1406      *  Initialization and other functions                                 *
1407      *                                                                     *
1408      **********************************************************************/
1409     {
1410         // To initialize the class helper at the begining each constructor of this class
1411         ParentHelper.initHelper(this);
1412     }
1413 
1414     /**
1415      * Constructs a new {@code Parent}.
1416      */
1417     protected Parent() {
1418         layoutFlag = LayoutFlags.NEEDS_LAYOUT;
1419         setAccessibleRole(AccessibleRole.PARENT);
1420     }
1421 
1422     private NGNode doCreatePeer() {
1423         return new NGGroup();
1424     }
1425 
1426     @Override
1427     void nodeResolvedOrientationChanged() {
1428         for (int i = 0, max = children.size(); i &lt; max; ++i) {
1429             children.get(i).parentResolvedOrientationInvalidated();
1430         }
1431     }
1432 
1433     /***************************************************************************
1434      *                                                                         *
1435      *                         Bounds Computations                             *
1436      *                                                                         *
1437      *  This code originated in GroupBoundsHelper (part of javafx-sg-common)   *
1438      *  but has been ported here to the FX side since we cannot rely on the PG *
1439      *  side for computing the bounds (due to the decoupling of the two        *
1440      *  scenegraphs for threading and other purposes).                         *
1441      *                                                                         *
1442      *  Unfortunately, we cannot simply reuse GroupBoundsHelper without some  *
1443      *  major (and hacky) modification due to the fact that GroupBoundsHelper  *
1444      *  relies on PG state and we need to do similar things here that rely on  *
1445      *  core scenegraph state. Unfortunately, that means we made a port.       *
1446      *                                                                         *
1447      **************************************************************************/
1448 
1449     private BaseBounds tmp = new RectBounds();
1450 
1451     /**
1452      * The cached bounds for the Group. If the cachedBounds are invalid
1453      * then we have no history of what the bounds are, or were.
1454      */
1455     private BaseBounds cachedBounds = new RectBounds();
1456 
1457     /**
1458      * Indicates that the cachedBounds is invalid (or old) and need to be recomputed.
1459      * If cachedBoundsInvalid is true and dirtyChildrenCount is non-zero,
1460      * then when we recompute the cachedBounds we can consider the
1461      * values in cachedBounds to represent the last valid bounds for the group.
1462      * This is useful for several fast paths.
1463      */
1464     private boolean cachedBoundsInvalid;
1465 
1466     /**
1467      * The number of dirty children which bounds haven&#39;t been incorporated
1468      * into the cached bounds yet. Can be used even when dirtyChildren is null.
1469      */
1470     private int dirtyChildrenCount;
1471 
1472     /**
1473      * This set is used to track all of the children of this group which are
1474      * dirty. It is only used in cases where the number of children is &gt; some
1475      * value (currently 10). For very wide trees, this can provide a very
1476      * important speed boost. For the sake of memory consumption, this is
1477      * null unless the number of children ever crosses the threshold where
1478      * it will be activated.
1479      */
1480     private ArrayList&lt;Node&gt; dirtyChildren;
1481 
1482     private Node top;
1483     private Node left;
1484     private Node bottom;
1485     private Node right;
1486     private Node near;
1487     private Node far;
1488 
1489     private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
1490         // If we have no children, our bounds are invalid
1491         if (children.isEmpty()) {
1492             return bounds.makeEmpty();
1493         }
1494 
1495         if (tx.isTranslateOrIdentity()) {
1496             // this is a transform which is only doing translations, or nothing
1497             // at all (no scales, rotates, or shears)
1498             // so in this case we can easily use the cached bounds
1499             if (cachedBoundsInvalid) {
1500                 recomputeBounds();
1501 
1502                 if (dirtyChildren != null) {
1503                     dirtyChildren.clear();
1504                 }
1505                 cachedBoundsInvalid = false;
1506                 dirtyChildrenCount = 0;
1507             }
1508             if (!tx.isIdentity()) {
1509                 bounds = bounds.deriveWithNewBounds((float)(cachedBounds.getMinX() + tx.getMxt()),
1510                                  (float)(cachedBounds.getMinY() + tx.getMyt()),
1511                                  (float)(cachedBounds.getMinZ() + tx.getMzt()),
1512                                  (float)(cachedBounds.getMaxX() + tx.getMxt()),
1513                                  (float)(cachedBounds.getMaxY() + tx.getMyt()),
1514                                  (float)(cachedBounds.getMaxZ() + tx.getMzt()));
1515             } else {
1516                 bounds = bounds.deriveWithNewBounds(cachedBounds);
1517             }
1518 
1519             return bounds;
1520         } else {
1521             // there is a scale, shear, or rotation happening, so need to
1522             // do the full transform!
1523             double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
1524             double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;
1525             boolean first = true;
1526             for (int i=0, max=children.size(); i&lt;max; i++) {
1527                 final Node node = children.get(i);
1528                 if (node.isVisible()) {
1529                     bounds = getChildTransformedBounds(node, tx, bounds);
1530                     // if the bounds of the child are invalid, we don&#39;t want
1531                     // to use those in the remaining computations.
1532                     if (bounds.isEmpty()) continue;
1533                     if (first) {
1534                         minX = bounds.getMinX();
1535                         minY = bounds.getMinY();
1536                         minZ = bounds.getMinZ();
1537                         maxX = bounds.getMaxX();
1538                         maxY = bounds.getMaxY();
1539                         maxZ = bounds.getMaxZ();
1540                         first = false;
1541                     } else {
1542                         minX = Math.min(bounds.getMinX(), minX);
1543                         minY = Math.min(bounds.getMinY(), minY);
1544                         minZ = Math.min(bounds.getMinZ(), minZ);
1545                         maxX = Math.max(bounds.getMaxX(), maxX);
1546                         maxY = Math.max(bounds.getMaxY(), maxY);
1547                         maxZ = Math.max(bounds.getMaxZ(), maxZ);
1548                     }
1549                 }
1550             }
1551             // if &quot;first&quot; is still true, then we didn&#39;t have any children with
1552             // non-empty bounds and thus we must return an empty bounds,
1553             // otherwise we have non-empty bounds so go for it.
1554             if (first)
1555                 bounds.makeEmpty();
1556             else
1557                 bounds = bounds.deriveWithNewBounds((float)minX, (float)minY, (float)minZ,
1558                         (float)maxX, (float)maxY, (float)maxZ);
1559 
1560             return bounds;
1561         }
1562     }
1563 
1564     private void setChildDirty(final Node node, final boolean dirty) {
1565         if (node.boundsChanged == dirty) {
1566             return;
1567         }
1568 
1569         node.boundsChanged = dirty;
1570         if (dirty) {
1571             if (dirtyChildren != null) {
1572                 dirtyChildren.add(node);
1573             }
1574             ++dirtyChildrenCount;
1575         } else {
1576             if (dirtyChildren != null) {
1577                 dirtyChildren.remove(node);
1578             }
1579             --dirtyChildrenCount;
1580         }
1581     }
1582 
1583     private void childIncluded(final Node node) {
1584         // assert node.isVisible();
1585         cachedBoundsInvalid = true;
1586         setChildDirty(node, true);
1587     }
1588 
1589     // This is called when either the child is actually removed, OR IF IT IS
1590     // TOGGLED TO BE INVISIBLE. This is because in both cases it needs to be
1591     // cleared from the state which manages bounds.
1592     private void childExcluded(final Node node) {
1593         if (node == left) {
1594             left = null;
1595             cachedBoundsInvalid = true;
1596         }
1597         if (node == top) {
1598             top = null;
1599             cachedBoundsInvalid = true;
1600         }
1601         if (node == near) {
1602             near = null;
1603             cachedBoundsInvalid = true;
1604         }
1605         if (node == right) {
1606             right = null;
1607             cachedBoundsInvalid = true;
1608         }
1609         if (node == bottom) {
1610             bottom = null;
1611             cachedBoundsInvalid = true;
1612         }
1613         if (node == far) {
1614             far = null;
1615             cachedBoundsInvalid = true;
1616         }
1617 
1618         setChildDirty(node, false);
1619     }
1620 
1621     /**
1622      * Recomputes the bounds from scratch and saves the cached bounds.
1623      */
1624     private void recomputeBounds() {
1625         // fast path for case of no children
1626         if (children.isEmpty()) {
1627             cachedBounds.makeEmpty();
1628             return;
1629         }
1630 
1631         // fast path for case of 1 child
1632         if (children.size() == 1) {
1633             Node node = children.get(0);
1634             node.boundsChanged = false;
1635             if (node.isVisible()) {
1636                 cachedBounds = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, cachedBounds);
1637                 top = left = bottom = right = near = far = node;
1638             } else {
1639                 cachedBounds.makeEmpty();
1640                 // no need to null edge nodes here, it was done in childExcluded
1641                 // top = left = bottom = right = near = far = null;
1642             }
1643             return;
1644         }
1645 
1646         if ((dirtyChildrenCount == 0) ||
1647                 !updateCachedBounds(dirtyChildren != null
1648                                         ? dirtyChildren : children,
1649                                     dirtyChildrenCount)) {
1650             // failed to update cached bounds, recreate them
1651             createCachedBounds(children);
1652         }
1653     }
1654 
1655     private final int LEFT_INVALID = 1;
1656     private final int TOP_INVALID = 1 &lt;&lt; 1;
1657     private final int NEAR_INVALID = 1 &lt;&lt; 2;
1658     private final int RIGHT_INVALID = 1 &lt;&lt; 3;
1659     private final int BOTTOM_INVALID = 1 &lt;&lt; 4;
1660     private final int FAR_INVALID = 1 &lt;&lt; 5;
1661 
1662     private boolean updateCachedBounds(final List&lt;Node&gt; dirtyNodes,
1663                                        int remainingDirtyNodes) {
1664         // fast path for untransformed bounds calculation
1665         if (cachedBounds.isEmpty()) {
1666             createCachedBounds(dirtyNodes);
1667             return true;
1668         }
1669 
1670         int invalidEdges = 0;
1671 
1672         if ((left == null) || left.boundsChanged) {
1673             invalidEdges |= LEFT_INVALID;
1674         }
1675         if ((top == null) || top.boundsChanged) {
1676             invalidEdges |= TOP_INVALID;
1677         }
1678         if ((near == null) || near.boundsChanged) {
1679             invalidEdges |= NEAR_INVALID;
1680         }
1681         if ((right == null) || right.boundsChanged) {
1682             invalidEdges |= RIGHT_INVALID;
1683         }
1684         if ((bottom == null) || bottom.boundsChanged) {
1685             invalidEdges |= BOTTOM_INVALID;
1686         }
1687         if ((far == null) || far.boundsChanged) {
1688             invalidEdges |= FAR_INVALID;
1689         }
1690 
1691         // These indicate the bounds of the Group as computed by this
1692         // function
1693         float minX = cachedBounds.getMinX();
1694         float minY = cachedBounds.getMinY();
1695         float minZ = cachedBounds.getMinZ();
1696         float maxX = cachedBounds.getMaxX();
1697         float maxY = cachedBounds.getMaxY();
1698         float maxZ = cachedBounds.getMaxZ();
1699 
1700         // this checks the newly added nodes first, so if dirtyNodes is the
1701         // whole children list, we can end early
1702         for (int i = dirtyNodes.size() - 1; remainingDirtyNodes &gt; 0; --i) {
1703             final Node node = dirtyNodes.get(i);
1704             if (node.boundsChanged) {
1705                 // assert node.isVisible();
1706                 node.boundsChanged = false;
1707                 --remainingDirtyNodes;
1708                 tmp = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, tmp);
1709                 if (!tmp.isEmpty()) {
1710                     float tmpx = tmp.getMinX();
1711                     float tmpy = tmp.getMinY();
1712                     float tmpz = tmp.getMinZ();
1713                     float tmpx2 = tmp.getMaxX();
1714                     float tmpy2 = tmp.getMaxY();
1715                     float tmpz2 = tmp.getMaxZ();
1716 
1717                     // If this node forms an edge, then we will set it to be the
1718                     // node for this edge and update the min/max values
1719                     if (tmpx &lt;= minX) {
1720                         minX = tmpx;
1721                         left = node;
1722                         invalidEdges &amp;= ~LEFT_INVALID;
1723                     }
1724                     if (tmpy &lt;= minY) {
1725                         minY = tmpy;
1726                         top = node;
1727                         invalidEdges &amp;= ~TOP_INVALID;
1728                     }
1729                     if (tmpz &lt;= minZ) {
1730                         minZ = tmpz;
1731                         near = node;
1732                         invalidEdges &amp;= ~NEAR_INVALID;
1733                     }
1734                     if (tmpx2 &gt;= maxX) {
1735                         maxX = tmpx2;
1736                         right = node;
1737                         invalidEdges &amp;= ~RIGHT_INVALID;
1738                     }
1739                     if (tmpy2 &gt;= maxY) {
1740                         maxY = tmpy2;
1741                         bottom = node;
1742                         invalidEdges &amp;= ~BOTTOM_INVALID;
1743                     }
1744                     if (tmpz2 &gt;= maxZ) {
1745                         maxZ = tmpz2;
1746                         far = node;
1747                         invalidEdges &amp;= ~FAR_INVALID;
1748                     }
1749                 }
1750             }
1751         }
1752 
1753         if (invalidEdges != 0) {
1754             // failed to validate some edges
1755             return false;
1756         }
1757 
1758         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1759                                                         maxX, maxY, maxZ);
1760         return true;
1761     }
1762 
1763     private void createCachedBounds(final List&lt;Node&gt; fromNodes) {
1764         // These indicate the bounds of the Group as computed by this function
1765         float minX, minY, minZ;
1766         float maxX, maxY, maxZ;
1767 
1768         final int nodeCount = fromNodes.size();
1769         int i;
1770 
1771         // handle first visible non-empty node
1772         for (i = 0; i &lt; nodeCount; ++i) {
1773             final Node node = fromNodes.get(i);
1774             node.boundsChanged = false;
1775             if (node.isVisible()) {
1776                 tmp = node.getTransformedBounds(
1777                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1778                 if (!tmp.isEmpty()) {
1779                     left = top = near = right = bottom = far = node;
1780                     break;
1781                 }
1782             }
1783         }
1784 
1785         if (i == nodeCount) {
1786             left = top = near = right = bottom = far = null;
1787             cachedBounds.makeEmpty();
1788             return;
1789         }
1790 
1791         minX = tmp.getMinX();
1792         minY = tmp.getMinY();
1793         minZ = tmp.getMinZ();
1794         maxX = tmp.getMaxX();
1795         maxY = tmp.getMaxY();
1796         maxZ = tmp.getMaxZ();
1797 
1798         // handle remaining visible non-empty nodes
1799         for (++i; i &lt; nodeCount; ++i) {
1800             final Node node = fromNodes.get(i);
1801             node.boundsChanged = false;
1802             if (node.isVisible()) {
1803                 tmp = node.getTransformedBounds(
1804                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1805                 if (!tmp.isEmpty()) {
1806                     final float tmpx = tmp.getMinX();
1807                     final float tmpy = tmp.getMinY();
1808                     final float tmpz = tmp.getMinZ();
1809                     final float tmpx2 = tmp.getMaxX();
1810                     final float tmpy2 = tmp.getMaxY();
1811                     final float tmpz2 = tmp.getMaxZ();
1812 
1813                     if (tmpx &lt; minX) { minX = tmpx; left = node; }
1814                     if (tmpy &lt; minY) { minY = tmpy; top = node; }
1815                     if (tmpz &lt; minZ) { minZ = tmpz; near = node; }
1816                     if (tmpx2 &gt; maxX) { maxX = tmpx2; right = node; }
1817                     if (tmpy2 &gt; maxY) { maxY = tmpy2; bottom = node; }
1818                     if (tmpz2 &gt; maxZ) { maxZ = tmpz2; far = node; }
1819                 }
1820             }
1821         }
1822 
1823         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1824                                                         maxX, maxY, maxZ);
1825     }
1826 
1827     /**
1828      * Updates the bounds of this {@code Parent} and its children.
1829      */
1830     @Override protected void updateBounds() {
1831         for (int i=0, max=children.size(); i&lt;max; i++) {
1832             children.get(i).updateBounds();
1833         }
1834         super.updateBounds();
1835     }
1836 
1837     // Note: this marks the currently processed child in terms of transformed bounds. In rare situations like
1838     // in RT-37879, it might happen that the child bounds will be marked as invalid. Due to optimizations,
1839     // the invalidation must *always* be propagated to the parent, because the parent with some transformation
1840     // calls child&#39;s getTransformedBounds non-idenitity transform and the child&#39;s transformed bounds are thus not validated.
1841     // This does not apply to the call itself however, because the call will yield the correct result even if something
1842     // was invalidated during the computation. We can safely ignore such invalidations from that Node in this case
1843     private Node currentlyProcessedChild;
1844 
1845     private BaseBounds getChildTransformedBounds(Node node, BaseTransform tx, BaseBounds bounds) {
1846         currentlyProcessedChild = node;
1847         bounds = node.getTransformedBounds(bounds, tx);
1848         currentlyProcessedChild = null;
1849         return bounds;
1850     }
1851 
1852     /**
1853      * Called by Node whenever its bounds have changed.
1854      */
1855     void childBoundsChanged(Node node) {
1856         // See comment above at &quot;currentlyProcessedChild&quot; field
1857         if (node == currentlyProcessedChild) {
1858             return;
1859         }
1860 
1861         cachedBoundsInvalid = true;
1862 
1863         // mark the node such that the parent knows that the child&#39;s bounds
1864         // are not in sync with this parent. In this way, when the bounds
1865         // need to be computed, we&#39;ll come back and figure out the new bounds
1866         // for all the children which have boundsChanged set to true
1867         setChildDirty(node, true);
1868 
1869         // go ahead and indicate that the geom has changed for this parent,
1870         // even though once we figure it all out it may be that the bounds
1871         // have not changed
1872         NodeHelper.geomChanged(this);
1873     }
1874 
1875     /**
1876      * Called by node whenever the visibility of the node changes.
1877      */
1878     void childVisibilityChanged(Node node) {
1879         if (node.isVisible()) {
1880             childIncluded(node);
1881         } else {
1882             childExcluded(node);
1883         }
1884 
1885         NodeHelper.geomChanged(this);
1886     }
1887 
1888     /*
1889      * Note: This method MUST only be called via its accessor method.
1890      */
1891     private boolean doComputeContains(double localX, double localY) {
1892         final Point2D tempPt = TempState.getInstance().point;
1893         for (int i=0, max=children.size(); i&lt;max; i++) {
1894             final Node node = children.get(i);
1895             tempPt.x = (float)localX;
1896             tempPt.y = (float)localY;
1897             try {
1898                 node.parentToLocal(tempPt);
1899             } catch (NoninvertibleTransformException e) {
1900                 continue;
1901             }
1902             if (node.contains(tempPt.x, tempPt.y)) {
1903                 return true;
1904             }
1905         }
1906         return false;
1907     }
1908 
1909     /** {@inheritDoc} */
1910     @Override
1911     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1912         switch (attribute) {
1913             case CHILDREN: return getChildrenUnmodifiable();
1914             default: return super.queryAccessibleAttribute(attribute, parameters);
1915         }
1916     }
1917 
1918     void releaseAccessible() {
1919         for (int i=0, max=children.size(); i&lt;max; i++) {
1920             final Node node = children.get(i);
1921             node.releaseAccessible();
1922         }
1923         super.releaseAccessible();
1924     }
1925 
1926     /**
1927      * Note: The only user of this method is in unit test: Parent_structure_sync_Test.
1928      */
1929     List&lt;Node&gt; test_getRemoved() {
1930         return removed;
1931     }
1932 
1933     /**
1934      * Note: The only user of this method is in unit test:
1935      * Parent_viewOrderChildren_sync_Test.
1936      */
1937     List&lt;Node&gt; test_getViewOrderChildren() {
1938         return viewOrderChildren;
1939     }
1940 }
    </pre>
  </body>
</html>