<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/scene/Parent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  29 import javafx.beans.property.ReadOnlyBooleanProperty;
  30 import javafx.beans.property.ReadOnlyBooleanWrapper;
  31 import javafx.collections.FXCollections;
  32 import javafx.collections.ListChangeListener.Change;
  33 import javafx.collections.ObservableList;
  34 import java.util.ArrayList;
  35 import java.util.HashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 
  39 import com.sun.javafx.util.TempState;
  40 import com.sun.javafx.util.Utils;
  41 import com.sun.javafx.collections.TrackableObservableList;
  42 import com.sun.javafx.collections.VetoableListDecorator;
  43 import javafx.css.Selector;
  44 import com.sun.javafx.css.StyleManager;
  45 import com.sun.javafx.geom.BaseBounds;
  46 import com.sun.javafx.geom.PickRay;
  47 import com.sun.javafx.geom.Point2D;
  48 import com.sun.javafx.geom.RectBounds;
  49 import com.sun.javafx.geom.transform.BaseTransform;
  50 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  51 import com.sun.javafx.scene.CssFlags;
  52 import com.sun.javafx.scene.DirtyBits;
  53 import com.sun.javafx.scene.input.PickResultChooser;
  54 import com.sun.javafx.sg.prism.NGGroup;
  55 import com.sun.javafx.sg.prism.NGNode;
  56 import com.sun.javafx.tk.Toolkit;
  57 import com.sun.javafx.scene.LayoutFlags;
  58 import com.sun.javafx.scene.NodeHelper;
  59 import com.sun.javafx.scene.ParentHelper;
  60 import com.sun.javafx.stage.WindowHelper;
  61 import java.util.Collections;
  62 import javafx.stage.Window;
  63 
  64 /**
  65  * The base class for all nodes that have children in the scene graph.
  66  * &lt;p&gt;
  67  * This class handles all hierarchical scene graph operations, including adding/removing
  68  * child nodes, marking branches dirty for layout and rendering, picking,
  69  * bounds calculations, and executing the layout pass on each pulse.
  70  * &lt;p&gt;
  71  * There are two direct concrete Parent subclasses
  72  * &lt;ul&gt;
  73  * &lt;li&gt;{@link Group} effects and transforms to be applied to a collection of child nodes.&lt;/li&gt;
  74  * &lt;li&gt;{@link javafx.scene.layout.Region} class for nodes that can be styled with CSS and layout children. &lt;/li&gt;
  75  * &lt;/ul&gt;
  76  *
  77  * @since JavaFX 2.0
  78  */
  79 public abstract class Parent extends Node {
  80     // package private for testing
  81     static final int DIRTY_CHILDREN_THRESHOLD = 10;
  82 
  83     // If set to true, generate a warning message whenever adding a node to a
  84     // parent if it is currently a child of another parent.
  85     private static final boolean warnOnAutoMove = PropertyHelper.getBooleanProperty(&quot;javafx.sg.warn&quot;);
  86 
  87     /**
  88      * Threshold when it&#39;s worth to populate list of removed children.
  89      */
  90     private static final int REMOVED_CHILDREN_THRESHOLD = 20;
  91 
  92     /**
  93      * Do not populate list of removed children when its number exceeds threshold,
  94      * but mark whole parent dirty.
  95      */
  96     private boolean removedChildrenOptimizationDisabled = false;
  97 
  98     static {
  99         // This is used by classes in different packages to get access to
 100         // private and package private methods.
 101         ParentHelper.setParentAccessor(new ParentHelper.ParentAccessor() {
 102             @Override
 103             public NGNode doCreatePeer(Node node) {
 104                 return ((Parent) node).doCreatePeer();
 105             }
 106 
 107             @Override
 108             public void doUpdatePeer(Node node) {
 109                 ((Parent) node).doUpdatePeer();
 110             }
 111 
 112             @Override
 113             public BaseBounds doComputeGeomBounds(Node node,
 114                     BaseBounds bounds, BaseTransform tx) {
 115                 return ((Parent) node).doComputeGeomBounds(bounds, tx);
 116             }
 117 
 118             @Override
 119             public boolean doComputeContains(Node node, double localX, double localY) {
 120                 return ((Parent) node).doComputeContains(localX, localY);
 121             }
 122 
 123             @Override
 124             public void doProcessCSS(Node node) {
 125                 ((Parent) node).doProcessCSS();
 126             }
 127 
 128             @Override
 129             public void doPickNodeLocal(Node node, PickRay localPickRay,
 130                     PickResultChooser result) {
 131                 ((Parent) node).doPickNodeLocal(localPickRay, result);
 132             }
 133 
 134             @Override
 135             public boolean pickChildrenNode(Parent parent, PickRay pickRay, PickResultChooser result) {
 136                 return parent.pickChildrenNode(pickRay, result);
 137             }
 138 
 139             @Override
 140             public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {
 141                 parent.setTraversalEngine(value);
 142             }
 143 
 144             @Override
 145             public ParentTraversalEngine getTraversalEngine(Parent parent) {
 146                 return parent.getTraversalEngine();
 147             }
 148 
 149             @Override
 150             public List&lt;String&gt; doGetAllParentStylesheets(Parent parent) {
 151                 return parent.doGetAllParentStylesheets();
 152             }
 153         });
 154     }
 155 
 156     /*
 157      * Note: This method MUST only be called via its accessor method.
 158      */
 159     private void doUpdatePeer() {
 160         final NGGroup peer = getPeer();
 161 
 162         if (Utils.assertionEnabled()) {
 163             List&lt;NGNode&gt; pgnodes = peer.getChildren();
 164             if (pgnodes.size() != pgChildrenSize) {
 165                 java.lang.System.err.println(&quot;*** pgnodes.size() [&quot; + pgnodes.size() + &quot;] != pgChildrenSize [&quot; + pgChildrenSize + &quot;]&quot;);
 166             }
 167         }
 168 
 169         if (isDirty(DirtyBits.PARENT_CHILDREN)) {
 170             // Whether a permutation, or children having been added or
 171             // removed, we&#39;ll want to clear out the PG side starting
 172             // from startIdx. We know that everything up to but not
 173             // including startIdx is identical between the FX and PG
 174             // sides, so we only need to update the remaining portion.
 175             peer.clearFrom(startIdx);
 176             for (int idx = startIdx; idx &lt; children.size(); idx++) {
 177                 peer.add(idx, children.get(idx).getPeer());
 178             }
 179             if (removedChildrenOptimizationDisabled) {
 180                 peer.markDirty();
 181                 removedChildrenOptimizationDisabled = false;
 182             } else {
 183                 if (removed != null &amp;&amp; !removed.isEmpty()) {
 184                     for(int i = 0; i &lt; removed.size(); i++) {
 185                         peer.addToRemoved(removed.get(i).getPeer());
 186                     }
 187                 }
 188             }
 189             if (removed != null) {
 190                 removed.clear();
 191             }
 192             pgChildrenSize = children.size();
 193             startIdx = pgChildrenSize;
 194         }
 195 
 196         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 197             computeViewOrderChildren();
 198             peer.setViewOrderChildren(viewOrderChildren);
 199         }
 200 
 201         if (Utils.assertionEnabled()) validatePG();
 202     }
 203 
 204 
 205     /***********************************************************************
 206      *                        Scenegraph Structure                         *
 207      *                                                                     *
 208      *  Functions and variables related to the scenegraph structure,       *
 209      *  modifying the structure, and walking the structure.                *
 210      *                                                                     *
 211      **********************************************************************/
 212 
 213     // Used to check for duplicate nodes
 214     private final Set&lt;Node&gt; childSet = new HashSet&lt;Node&gt;();
 215 
 216     // starting child index from which we need to send the children to the PGGroup
 217     private int startIdx = 0;
 218 
 219     // double of children in the PGGroup as of the last update
 220     private int pgChildrenSize = 0;
 221 
 222     void validatePG() {
 223         boolean assertionFailed = false;
 224         final NGGroup peer = getPeer();
 225         List&lt;NGNode&gt; pgnodes = peer.getChildren();
 226         if (pgnodes.size() != children.size()) {
 227             java.lang.System.err.println(&quot;*** pgnodes.size validatePG() [&quot; + pgnodes.size() + &quot;] != children.size() [&quot; + children.size() + &quot;]&quot;);
 228             assertionFailed = true;
 229         } else {
 230             for (int idx = 0; idx &lt; children.size(); idx++) {
 231                 Node n = children.get(idx);
 232                 if (n.getParent() != this) {
 233                     java.lang.System.err.println(&quot;*** this=&quot; + this + &quot; validatePG children[&quot; + idx + &quot;].parent= &quot; + n.getParent());
 234                     assertionFailed = true;
 235                 }
 236                 if (n.getPeer() != pgnodes.get(idx)) {
 237                     java.lang.System.err.println(&quot;*** pgnodes[&quot; + idx + &quot;] validatePG != children[&quot; + idx + &quot;]&quot;);
 238                     assertionFailed = true;
 239                 }
 240             }
 241         }
 242         if (assertionFailed) {
 243             throw new java.lang.AssertionError(&quot;validation of PGGroup children failed&quot;);
 244         }
 245 
 246     }
 247 
 248     void printSeq(String prefix, List&lt;Node&gt; nodes) {
 249         String str = prefix;
 250         for (Node nn : nodes) {
 251             str += nn + &quot; &quot;;
 252         }
 253         System.out.println(str);
 254     }
 255 
 256     /**
 257      * The viewOrderChildren is a list children sorted in decreasing viewOrder
 258      * order if it is not empty. Its size should always be equal to
 259      * children.size(). If viewOrderChildren is empty it implies that the
 260      * rendering order of the children is the same as the order in the children
 261      * list.
 262      */
 263     private final List&lt;Node&gt; viewOrderChildren = new ArrayList(1);
 264 
 265     void markViewOrderChildrenDirty() {
 266         viewOrderChildren.clear();
 267         NodeHelper.markDirty(this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
 268     }
 269 
 270     private void computeViewOrderChildren() {
 271         boolean viewOrderSet = false;
 272         for (Node child : children) {
 273             double vo = child.getViewOrder();
 274 
 275             if (!viewOrderSet &amp;&amp; vo != 0) {
 276                 viewOrderSet = true;
 277             }
 278         }
 279 
 280         viewOrderChildren.clear();
 281         if (viewOrderSet) {
 282             viewOrderChildren.addAll(children);
 283 
 284             // Sort in descending order (or big-to-small order)
 285             Collections.sort(viewOrderChildren, (Node a, Node b)
 286                     -&gt; a.getViewOrder() &lt; b.getViewOrder() ? 1
 287                             : a.getViewOrder() == b.getViewOrder() ? 0 : -1);
 288         }
 289     }
 290 
 291     // Call this method if children view order is needed for picking.
 292     // The returned list should be treated as read only.
 293     private List&lt;Node&gt; getOrderedChildren() {
 294         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 295             //Fix for JDK-8205092
 296             computeViewOrderChildren();
 297         }
 298         if (!viewOrderChildren.isEmpty()) {
 299             return viewOrderChildren;
 300         }
 301         return children;
 302     }
 303 
 304     // Variable used to indicate that the change to the children ObservableList is
 305     // a simple permutation as the result of a toFront or toBack operation.
 306     // We can avoid almost all of the processing of the on replace trigger in
 307     // this case.
 308     private boolean childrenTriggerPermutation = false;
 309 
 310     //accumulates all removed nodes between pulses, for dirty area calculation.
 311     private List&lt;Node&gt; removed;
 312 
 313     // set to true if either childRemoved or childAdded returns
 314     // true. These functions will indicate whether the geom
 315     // bounds for the parent have changed
 316     private boolean geomChanged;
 317     private boolean childSetModified;
 318     private final ObservableList&lt;Node&gt; children = new VetoableListDecorator&lt;Node&gt;(new TrackableObservableList&lt;Node&gt;() {
 319 
 320 
 321         protected void onChanged(Change&lt;Node&gt; c) {
 322             // proceed with updating the scene graph
 323             unmodifiableManagedChildren = null;
 324             boolean relayout = false;
 325             boolean viewOrderChildrenDirty = false;
 326 
 327             if (childSetModified) {
 328                 while (c.next()) {
 329                     int from = c.getFrom();
 330                     int to = c.getTo();
 331                     for (int i = from; i &lt; to; ++i) {
 332                         Node n = children.get(i);
 333                         if (n.getParent() != null &amp;&amp; n.getParent() != Parent.this) {
 334                             if (warnOnAutoMove) {
 335                                 java.lang.System.err.println(&quot;WARNING added to a new parent without first removing it from its current&quot;);
 336                                 java.lang.System.err.println(&quot;    parent. It will be automatically removed from its current parent.&quot;);
 337                                 java.lang.System.err.println(&quot;    node=&quot; + n + &quot; oldparent= &quot; + n.getParent() + &quot; newparent=&quot; + this);
 338                             }
 339                             n.getParent().children.remove(n);
 340                             if (warnOnAutoMove) {
 341                                 Thread.dumpStack();
 342                             }
 343                         }
 344                     }
 345 
 346                     List&lt;Node&gt; removed = c.getRemoved();
 347                     int removedSize = removed.size();
 348                     for (int i = 0; i &lt; removedSize; ++i) {
 349                         final Node n = removed.get(i);
 350                         if (n.isManaged()) {
 351                             relayout = true;
 352                         }
 353                     }
 354 
 355                     // Mark viewOrderChildrenDirty if there is modification to children list
 356                     // and view order was set on one or more of the children prior to this change
 357                     if (((removedSize &gt; 0) || (to - from) &gt; 0) &amp;&amp; !viewOrderChildren.isEmpty()) {
 358                         viewOrderChildrenDirty = true;
 359                     }
 360                     // update the parent and scene for each new node
 361                     for (int i = from; i &lt; to; ++i) {
 362                         Node node = children.get(i);
 363 
 364                         // Newly added node has view order set.
 365                         if (node.getViewOrder() != 0) {
 366                             viewOrderChildrenDirty = true;
 367                         }
 368                         if (node.isManaged() || (node instanceof Parent &amp;&amp; ((Parent) node).layoutFlag != LayoutFlags.CLEAN)) {
 369                             relayout = true;
 370                         }
 371                         node.setParent(Parent.this);
 372                         node.setScenes(getScene(), getSubScene());
 373                         // assert !node.boundsChanged;
 374                         if (node.isVisible()) {
 375                             geomChanged = true;
 376                             childIncluded(node);
 377                         }
 378                     }
 379                 }
 380 
 381                 // check to see if the number of children exceeds
 382                 // DIRTY_CHILDREN_THRESHOLD and dirtyChildren is null.
 383                 // If so, then we need to create dirtyChildren and
 384                 // populate it.
 385                 if (dirtyChildren == null &amp;&amp; children.size() &gt; DIRTY_CHILDREN_THRESHOLD) {
 386                     dirtyChildren
 387                             = new ArrayList&lt;Node&gt;(2 * DIRTY_CHILDREN_THRESHOLD);
 388                     // only bother populating children if geom has
 389                     // changed, otherwise there is no need
 390                     if (dirtyChildrenCount &gt; 0) {
 391                         int size = children.size();
 392                         for (int i = 0; i &lt; size; ++i) {
 393                             Node ch = children.get(i);
 394                             if (ch.isVisible() &amp;&amp; ch.boundsChanged) {
 395                                 dirtyChildren.add(ch);
 396                             }
 397                         }
 398                     }
 399                 }
 400             } else {
 401                 // If childSet was not modified, we still need to check whether the permutation
 402                 // did change the layout
 403                 layout_loop:while (c.next()) {
 404                     List&lt;Node&gt; removed = c.getRemoved();
 405                     for (int i = 0, removedSize = removed.size(); i &lt; removedSize; ++i) {
 406                         if (removed.get(i).isManaged()) {
 407                             relayout = true;
 408                             break layout_loop;
 409                         }
 410                     }
 411 
 412                     for (int i = c.getFrom(), to = c.getTo(); i &lt; to; ++i) {
 413                         if (children.get(i).isManaged()) {
 414                             relayout = true;
 415                             break layout_loop;
 416                         }
 417                     }
 418                 }
 419             }
 420 
 421 
 422             //
 423             // Note that the styles of a child do not affect the parent or
 424             // its siblings. Thus, it is only necessary to reapply css to
 425             // the Node just added and not to this parent and all of its
 426             // children. So the following call to reapplyCSS was moved
 427             // to Node.parentProperty. The original comment and code were
 428             // purposely left here as documentation should there be any
 429             // question about how the code used to work and why the change
 430             // was made.
 431             //
 432             // if children have changed then I need to reapply
 433             // CSS from this node on down
 434 //                reapplyCSS();
 435             //
 436 
 437             // request layout if a Group subclass has overridden doLayout OR
 438             // if one of the new children needs layout, in which case need to ensure
 439             // the needsLayout flag is set all the way to the root so the next layout
 440             // pass will reach the child.
 441             if (relayout) {
 442                 requestLayout();
 443             }
 444 
 445             if (geomChanged) {
 446                 NodeHelper.geomChanged(Parent.this);
 447             }
 448 
 449             // Note the starting index at which we need to update the
 450             // PGGroup on the next update, and mark the children dirty
 451             c.reset();
 452             c.next();
 453             if (startIdx &gt; c.getFrom()) {
 454                 startIdx = c.getFrom();
 455             }
 456 
 457             NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN);
 458             // Force synchronization to include the handling of invisible node
 459             // so that removed list will get cleanup to prevent memory leak.
 460             NodeHelper.markDirty(Parent.this, DirtyBits.NODE_FORCE_SYNC);
 461 
 462             if (viewOrderChildrenDirty) {
 463                 markViewOrderChildrenDirty();
 464             }
 465         }
 466 
 467     }) {
 468         @Override
 469         protected void onProposedChange(final List&lt;Node&gt; newNodes, int[] toBeRemoved) {
 470             final Scene scene = getScene();
 471             if (scene != null) {
 472                 Window w = scene.getWindow();
 473                 if (w != null &amp;&amp; WindowHelper.getPeer(w) != null) {
 474                     Toolkit.getToolkit().checkFxUserThread();
 475                 }
 476             }
 477             geomChanged = false;
 478 
 479             long newLength = children.size() + newNodes.size();
 480             int removedLength = 0;
 481             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 482                 removedLength += toBeRemoved[i + 1] - toBeRemoved[i];
 483             }
 484             newLength -= removedLength;
 485 
 486             // If the childrenTriggerPermutation flag is set, then we know it
 487             // is a simple permutation and no further checking is needed.
 488             if (childrenTriggerPermutation) {
 489                 childSetModified = false;
 490                 return;
 491             }
 492 
 493             // If the childrenTriggerPermutation flag is not set, then we will
 494             // check to see whether any element in the ObservableList has changed,
 495             // or whether the new ObservableList is a permutation on the existing
 496             // ObservableList. Note that even if the childrenModified flag is false,
 497             // we still have to check for duplicates. If it is a simple
 498             // permutation, we can avoid checking for cycles or other parents.
 499             childSetModified = true;
 500             if (newLength == childSet.size()) {
 501                 childSetModified = false;
 502                 for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 503                     Node n = newNodes.get(i);
 504                     if (!childSet.contains(n)) {
 505                         childSetModified = true;
 506                         break;
 507                     }
 508                 }
 509             }
 510 
 511             // Enforce scene graph invariants, and check for structural errors.
 512             //
 513             // 1. If a child has been added to this parent more than once,
 514             // then it is an error
 515             //
 516             // 2. If a child is a target of a clip, then it is an error.
 517             //
 518             // 3. If a node would cause a cycle, then it is an error.
 519             //
 520             // 4. If a node is null
 521             //
 522             // Note that if a node is the child of another parent, we will
 523             // implicitly remove the node from its former Parent after first
 524             // checking for errors.
 525 
 526             // iterate over the nodes that were removed and remove them from
 527             // the hash set.
 528             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 529                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 530                     childSet.remove(children.get(j));
 531                 }
 532             }
 533 
 534             try {
 535                 if (childSetModified) {
 536                     // check individual children before duplication test
 537                     // if done in this order, the exception is more specific
 538                     for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 539                         Node node = newNodes.get(i);
 540                         if (node == null) {
 541                             throw new NullPointerException(
 542                                     constructExceptionMessage(
 543                                         &quot;child node is null&quot;, null));
 544                         }
 545                         if (node.getClipParent() != null) {
 546                             throw new IllegalArgumentException(
 547                                     constructExceptionMessage(
 548                                         &quot;node already used as a clip&quot;, node));
 549                         }
 550                         if (wouldCreateCycle(Parent.this, node)) {
 551                             throw new IllegalArgumentException(
 552                                     constructExceptionMessage(
 553                                         &quot;cycle detected&quot;, node));
 554                         }
 555                     }
 556                 }
 557 
 558                 childSet.addAll(newNodes);
 559                 if (childSet.size() != newLength) {
 560                     throw new IllegalArgumentException(
 561                             constructExceptionMessage(
 562                                 &quot;duplicate children added&quot;, null));
 563                 }
 564             } catch (RuntimeException e) {
 565                 //Return children to it&#39;s original state
 566                 childSet.clear();
 567                 childSet.addAll(children);
 568 
 569                 // rethrow
 570                 throw e;
 571             }
 572 
 573             // Done with error checking
 574 
 575             if (!childSetModified) {
 576                 return;
 577             }
 578 
 579             // iterate over the nodes that were removed and clear their
 580             // parent and scene. Add to them also to removed list for further
 581             // dirty regions calculation.
 582             if (removed == null) {
 583                 removed = new ArrayList&lt;Node&gt;();
 584             }
 585             if (removed.size() + removedLength &gt; REMOVED_CHILDREN_THRESHOLD || !isTreeVisible()) {
 586                 //do not populate too many children in removed list
 587                 removedChildrenOptimizationDisabled = true;
 588             }
 589             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 590                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 591                     Node old = children.get(j);
 592                     final Scene oldScene = old.getScene();
 593                     if (oldScene != null) {
 594                         oldScene.generateMouseExited(old);
 595                     }
 596                     if (dirtyChildren != null) {
 597                         dirtyChildren.remove(old);
 598                     }
 599                     if (old.isVisible()) {
 600                         geomChanged = true;
 601                         childExcluded(old);
 602                     }
 603                     if (old.getParent() == Parent.this) {
 604                         old.setParent(null);
 605                         old.setScenes(null, null);
 606                     }
 607                     // Do not add node with null scene to the removed list.
 608                     // It will not be processed in the list and its memory
 609                     // will not be freed.
 610                     if (scene != null &amp;&amp; !removedChildrenOptimizationDisabled) {
 611                         removed.add(old);
 612                     }
 613                 }
 614             }
 615         }
 616 
 617         private String constructExceptionMessage(
 618                 String cause, Node offendingNode) {
 619             final StringBuilder sb = new StringBuilder(&quot;Children: &quot;);
 620             sb.append(cause);
 621             sb.append(&quot;: parent = &quot;).append(Parent.this);
 622             if (offendingNode != null) {
 623                 sb.append(&quot;, node = &quot;).append(offendingNode);
 624             }
 625 
 626             return sb.toString();
 627         }
 628     };
 629 
 630     /**
 631      * A constant reference to an unmodifiable view of the children, such that every time
 632      * we ask for an unmodifiable list of children, we don&#39;t actually create a new
 633      * collection and return it. The memory overhead is pretty lightweight compared
 634      * to all the garbage we would otherwise generate.
 635      */
 636     private final ObservableList&lt;Node&gt; unmodifiableChildren =
 637             FXCollections.unmodifiableObservableList(children);
 638 
 639     /**
 640      * A cached reference to the unmodifiable managed children of this Parent. This is
 641      * created whenever first asked for, and thrown away whenever children are added
 642      * or removed or when their managed state changes. This could be written
 643      * differently, such that this list is essentially a filtered copy of the
 644      * main children, but that additional overhead might not be worth it.
 645      */
 646     private List&lt;Node&gt; unmodifiableManagedChildren = null;
 647 
 648     /**
 649      * Gets the list of children of this {@code Parent}.
 650      *
 651      * &lt;p&gt;
 652      * See the class documentation for {@link Node} for scene graph structure
 653      * restrictions on setting a {@link Parent}&#39;s children list.
 654      * If these restrictions are violated by a change to the list of children,
 655      * the change is ignored and the previous value of the children list is
 656      * restored. An {@link IllegalArgumentException} is thrown in this case.
 657      *
 658      * &lt;p&gt;
 659      * If this {@link Parent} node is attached to a {@link Scene} attached to a {@link Window}
 660      * that is showning ({@link javafx.stage.Window#isShowing()}), then its
 661      * list of children must only be modified on the JavaFX Application Thread.
 662      * An {@link IllegalStateException} is thrown if this restriction is
 663      * violated.
 664      *
 665      * &lt;p&gt;
 666      * Note to subclasses: if you override this method, you must return from
 667      * your implementation the result of calling this super method. The actual
 668      * list instance returned from any getChildren() implementation must be
 669      * the list owned and managed by this Parent. The only typical purpose
 670      * for overriding this method is to promote the method to be public.
 671      *
 672      * @return the list of children of this {@code Parent}.
 673      */
 674     protected ObservableList&lt;Node&gt; getChildren() {
 675         return children;
 676     }
 677 
 678     /**
 679      * Gets the list of children of this {@code Parent} as a read-only
 680      * list.
 681      *
 682      * @return read-only access to this parent&#39;s children ObservableList
 683      */
 684     public ObservableList&lt;Node&gt; getChildrenUnmodifiable() {
 685         return unmodifiableChildren;
 686     }
 687 
 688     /**
 689      * Gets the list of all managed children of this {@code Parent}.
 690      *
 691      * @param &lt;E&gt; the type of the children nodes
 692      * @return list of all managed children in this parent
 693      */
 694     protected &lt;E extends Node&gt; List&lt;E&gt; getManagedChildren() {
 695         if (unmodifiableManagedChildren == null) {
 696             unmodifiableManagedChildren = new ArrayList&lt;Node&gt;();
 697             for (int i=0, max=children.size(); i&lt;max; i++) {
 698                 Node e = children.get(i);
 699                 if (e.isManaged()) {
 700                     unmodifiableManagedChildren.add(e);
 701                 }
 702             }
 703         }
 704         return (List&lt;E&gt;)unmodifiableManagedChildren;
 705     }
 706 
 707     /**
 708      * Called by Node whenever its managed state may have changed, this
 709      * method will cause the view of managed children to be updated
 710      * such that it properly includes or excludes this child.
 711      */
 712     final void managedChildChanged() {
 713         requestLayout();
 714         unmodifiableManagedChildren = null;
 715     }
 716 
 717     // implementation of Node.toFront function
 718     final void toFront(Node node) {
 719         if (Utils.assertionEnabled()) {
 720             if (!childSet.contains(node)) {
 721                 throw new java.lang.AssertionError(
 722                         &quot;specified node is not in the list of children&quot;);
 723             }
 724         }
 725 
 726         if (children.get(children.size() - 1) != node) {
 727             childrenTriggerPermutation = true;
 728             try {
 729                 children.remove(node);
 730                 children.add(node);
 731             } finally {
 732                 childrenTriggerPermutation = false;
 733             }
 734         }
 735     }
 736 
 737     // implementation of Node.toBack function
 738     final void toBack(Node node) {
 739         if (Utils.assertionEnabled()) {
 740             if (!childSet.contains(node)) {
 741                 throw new java.lang.AssertionError(
 742                         &quot;specified node is not in the list of children&quot;);
 743             }
 744         }
 745 
 746         if (children.get(0) != node) {
 747             childrenTriggerPermutation = true;
 748             try {
 749                 children.remove(node);
 750                 children.add(0, node);
 751             } finally {
 752                 childrenTriggerPermutation = false;
 753             }
 754         }
 755     }
 756 
 757     @Override
 758     void scenesChanged(final Scene newScene, final SubScene newSubScene,
 759                        final Scene oldScene, final SubScene oldSubScene) {
 760 
 761         if (oldScene != null &amp;&amp; newScene == null) {
 762             // RT-34863 - clean up CSS cache when Parent is removed from scene-graph
 763             StyleManager.getInstance().forget(this);
 764 
 765             // Clear removed list on parent who is no longer in a scene
 766             if (removed != null) {
 767                 removed.clear();
 768             }
 769         }
 770 
 771         for (int i=0; i&lt;children.size(); i++) {
 772             children.get(i).setScenes(newScene, newSubScene);
 773         }
 774 
 775         final boolean awaitingLayout = layoutFlag != LayoutFlags.CLEAN;
 776 
 777         sceneRoot = (newSubScene != null &amp;&amp; newSubScene.getRoot() == this) ||
 778                     (newScene != null &amp;&amp; newScene.getRoot() == this);
 779         layoutRoot = !isManaged() || sceneRoot;
 780 
 781 
 782         if (awaitingLayout) {
 783             // If this node is dirty and the new scene or subScene is not null
 784             // then add this node to the new scene&#39;s dirty list
 785             if (newScene != null &amp;&amp; layoutRoot) {
 786                 if (newSubScene != null) {
 787                     newSubScene.setDirtyLayout(this);
 788                 }
 789             }
 790         }
 791     }
 792 
 793     @Override
 794     void setDerivedDepthTest(boolean value) {
 795         super.setDerivedDepthTest(value);
 796 
 797         for (int i=0, max=children.size(); i&lt;max; i++) {
 798             final Node node = children.get(i);
 799             node.computeDerivedDepthTest();
 800         }
 801     }
 802 
 803     boolean pickChildrenNode(PickRay pickRay, PickResultChooser result) {
 804         List&lt;Node&gt; orderedChildren = getOrderedChildren();
 805         for (int i = orderedChildren.size() - 1; i &gt;= 0; i--) {
 806             orderedChildren.get(i).pickNode(pickRay, result);
 807             if (result.isClosed()) {
 808                 return false;
 809             }
 810         }
 811         return true;
 812     }
 813 
 814     /*
 815      * Note: This method MUST only be called via its accessor method.
 816      */
 817     private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
 818          double boundsDistance = intersectsBounds(pickRay);
 819 
 820         if (!Double.isNaN(boundsDistance) &amp;&amp; pickChildrenNode(pickRay, result)) {
 821             if (isPickOnBounds()) {
 822                 result.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 823             }
 824         }
 825     }
 826 
 827     @Override boolean isConnected() {
 828         return super.isConnected() || sceneRoot;
 829     }
 830 
 831     @Override public Node lookup(String selector) {
 832         Node n = super.lookup(selector);
 833         if (n == null) {
 834             for (int i=0, max=children.size(); i&lt;max; i++) {
 835                 final Node node = children.get(i);
 836                 n = node.lookup(selector);
 837                 if (n != null) return n;
 838             }
 839         }
 840         return n;
 841     }
 842 
 843     /**
 844      * Please Note: This method should never create the results set,
 845      * let the Node class implementation do this!
 846      */
 847     @Override List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 848         results = super.lookupAll(selector, results);
 849         for (int i=0, max=children.size(); i&lt;max; i++) {
 850             final Node node = children.get(i);
 851             results = node.lookupAll(selector, results);
 852         }
 853         return results;
 854     }
 855 
 856     private ParentTraversalEngine traversalEngine;
 857 
 858     private final void setTraversalEngine(ParentTraversalEngine value) {
 859         this.traversalEngine = value;
 860     }
 861 
 862     private final ParentTraversalEngine getTraversalEngine() {
 863         return traversalEngine;
 864     }
 865 
 866     /***********************************************************************
 867      *                               Layout                                *
 868      *                                                                     *
 869      *  Functions and variables related to the layout scheme used by       *
 870      *  JavaFX. Includes both public and private API.                      *
 871      *                                                                     *
 872      **********************************************************************/
 873     /**
 874      * Indicates that this Node and its subnodes requires a layout pass on
 875      * the next pulse.
 876      */
 877     private ReadOnlyBooleanWrapper needsLayout;
 878     LayoutFlags layoutFlag = LayoutFlags.CLEAN;
 879 
 880     protected final void setNeedsLayout(boolean value) {
 881         if (value) {
 882             markDirtyLayout(true, false);
 883         } else if (layoutFlag == LayoutFlags.NEEDS_LAYOUT) {
 884             boolean hasBranch = false;
 885             for (int i = 0, max = children.size(); i &lt; max; i++) {
 886                 final Node child = children.get(i);
 887                 if (child instanceof Parent) {
 888                     if (((Parent)child).layoutFlag != LayoutFlags.CLEAN) {
 889                         hasBranch = true;
 890                         break;
 891                     }
 892 
 893                 }
 894             }
 895             setLayoutFlag(hasBranch ? LayoutFlags.DIRTY_BRANCH : LayoutFlags.CLEAN);
 896         }
 897     }
 898 
 899     public final boolean isNeedsLayout() {
 900         return layoutFlag == LayoutFlags.NEEDS_LAYOUT;
 901     }
 902 
 903     public final ReadOnlyBooleanProperty needsLayoutProperty() {
 904         if (needsLayout == null) {
 905             needsLayout = new ReadOnlyBooleanWrapper(this, &quot;needsLayout&quot;, layoutFlag == LayoutFlags.NEEDS_LAYOUT);
 906         }
 907         return needsLayout;
 908     }
 909 
 910     /**
 911      * This is used only by CCS in Node. It is set to true while
 912      * the layout() function is processing and set to false on the conclusion.
 913      * It is used by the Node to decide whether to perform CSS updates
 914      * synchronously or asynchronously.
 915      */
 916     private boolean performingLayout = false;
 917 
 918     boolean isPerformingLayout() {
 919         return performingLayout;
 920     }
 921 
 922     private boolean sizeCacheClear = true;
 923     private double prefWidthCache = -1;
 924     private double prefHeightCache = -1;
 925     private double minWidthCache = -1;
 926     private double minHeightCache = -1;
 927 
 928     void setLayoutFlag(LayoutFlags flag) {
 929         if (needsLayout != null) {
 930             needsLayout.set(flag == LayoutFlags.NEEDS_LAYOUT);
 931         }
 932         layoutFlag = flag;
 933     }
 934 
 935     private void markDirtyLayout(boolean local, boolean forceParentLayout) {
 936         setLayoutFlag(LayoutFlags.NEEDS_LAYOUT);
 937         if (local || layoutRoot) {
 938             if (sceneRoot) {
 939                 Toolkit.getToolkit().requestNextPulse();
 940                 if (getSubScene() != null) {
 941                     getSubScene().setDirtyLayout(this);
 942                 }
 943             } else {
 944                 markDirtyLayoutBranch();
 945             }
 946         } else {
 947             requestParentLayout(forceParentLayout);
 948         }
 949     }
 950 
 951     /**
 952      * Requests a layout pass to be performed before the next scene is
 953      * rendered. This is batched up asynchronously to happen once per
 954      * &quot;pulse&quot;, or frame of animation.
 955      * &lt;p&gt;
 956      * If this parent is either a layout root or unmanaged, then it will be
 957      * added directly to the scene&#39;s dirty layout list, otherwise requestParentLayout
 958      * will be invoked.
 959      * @since JavaFX 8.0
 960      */
 961     public void requestLayout() {
 962         clearSizeCache();
 963         markDirtyLayout(false, forceParentLayout);
 964     }
 965 
 966     private boolean forceParentLayout = false;
 967     /**
 968      * A package scope method used by Node and serves as a helper method for
 969      * requestLayout() (see above). If forceParentLayout is true it will
 970      * propagate this force layout flag to its parent.
 971      */
 972     void requestLayout(boolean forceParentLayout) {
 973         boolean savedForceParentLayout = this.forceParentLayout;
 974         this.forceParentLayout = forceParentLayout;
 975         requestLayout();
 976         this.forceParentLayout = savedForceParentLayout;
 977     }
 978 
 979     /**
 980      * Requests a layout pass of the parent to be performed before the next scene is
 981      * rendered. This is batched up asynchronously to happen once per
 982      * &quot;pulse&quot;, or frame of animation.
 983      * &lt;p&gt;
 984      * This may be used when the current parent have changed it&#39;s min/max/preferred width/height,
 985      * but doesn&#39;t know yet if the change will lead to it&#39;s actual size change. This will be determined
 986      * when it&#39;s parent recomputes the layout with the new hints.
 987      */
 988     protected final void requestParentLayout() {
 989        requestParentLayout(false);
 990     }
 991 
 992     /**
 993      * A package scope method used by Node and serves as a helper method for
 994      * requestParentLayout() (see above). If forceParentLayout is true it will
 995      * force a request layout call on its parent if its parent is not null.
 996      */
 997     void requestParentLayout(boolean forceParentLayout) {
 998         if (!layoutRoot) {
 999             final Parent p = getParent();
1000             if (p != null &amp;&amp; (!p.performingLayout || forceParentLayout)) {
1001                 p.requestLayout();
1002             }
1003         }
1004     }
1005 
1006     void clearSizeCache() {
1007         if (sizeCacheClear) {
1008             return;
1009         }
1010         sizeCacheClear = true;
1011         prefWidthCache = -1;
1012         prefHeightCache = -1;
1013         minWidthCache = -1;
1014         minHeightCache = -1;
1015     }
1016 
1017     @Override public double prefWidth(double height) {
1018         if (height == -1) {
1019             if (prefWidthCache == -1) {
1020                 prefWidthCache = computePrefWidth(-1);
1021                 if (Double.isNaN(prefWidthCache) || prefWidthCache &lt; 0) prefWidthCache = 0;
1022                 sizeCacheClear = false;
1023             }
1024             return prefWidthCache;
1025         } else {
1026             double result = computePrefWidth(height);
1027             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1028         }
1029     }
1030 
1031     @Override public double prefHeight(double width) {
1032         if (width == -1) {
1033             if (prefHeightCache == -1) {
1034                 prefHeightCache = computePrefHeight(-1);
1035                 if (Double.isNaN(prefHeightCache) || prefHeightCache &lt; 0) prefHeightCache = 0;
1036                 sizeCacheClear = false;
1037             }
1038             return prefHeightCache;
1039         } else {
1040             double result = computePrefHeight(width);
1041             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1042         }
1043     }
1044 
1045     @Override public double minWidth(double height) {
1046         if (height == -1) {
1047             if (minWidthCache == -1) {
1048                 minWidthCache = computeMinWidth(-1);
1049                 if (Double.isNaN(minWidthCache) || minWidthCache &lt; 0) minWidthCache = 0;
1050                 sizeCacheClear = false;
1051             }
1052             return minWidthCache;
1053         } else {
1054             double result = computeMinWidth(height);
1055             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1056         }
1057     }
1058 
1059     @Override public double minHeight(double width) {
1060         if (width == -1) {
1061             if (minHeightCache == -1) {
1062                 minHeightCache = computeMinHeight(-1);
1063                 if (Double.isNaN(minHeightCache) || minHeightCache &lt; 0) minHeightCache = 0;
1064                 sizeCacheClear = false;
1065             }
1066             return minHeightCache;
1067         } else {
1068             double result = computeMinHeight(width);
1069             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1070         }
1071     }
1072 
1073     // PENDING_DOC_REVIEW
1074     /**
1075      * Calculates the preferred width of this {@code Parent}. The default
1076      * implementation calculates this width as the width of the area occupied
1077      * by its managed children when they are positioned at their
1078      * current positions at their preferred widths.
1079      *
1080      * @param height the height that should be used if preferred width depends
1081      *      on it
1082      * @return the calculated preferred width
1083      */
1084     protected double computePrefWidth(double height) {
1085         double minX = 0;
1086         double maxX = 0;
1087         for (int i=0, max=children.size(); i&lt;max; i++) {
1088             Node node = children.get(i);
1089             if (node.isManaged()) {
1090                 final double x = node.getLayoutBounds().getMinX() + node.getLayoutX();
1091                 minX = Math.min(minX, x);
1092                 maxX = Math.max(maxX, x + boundedSize(node.prefWidth(-1), node.minWidth(-1), node.maxWidth(-1)));
1093             }
1094         }
1095         return maxX - minX;
1096     }
1097 
1098     // PENDING_DOC_REVIEW
1099     /**
1100      * Calculates the preferred height of this {@code Parent}. The default
1101      * implementation calculates this height as the height of the area occupied
1102      * by its managed children when they are positioned at their current
1103      * positions at their preferred heights.
1104      *
1105      * @param width the width that should be used if preferred height depends
1106      *      on it
1107      * @return the calculated preferred height
1108      */
1109     protected double computePrefHeight(double width) {
1110         double minY = 0;
1111         double maxY = 0;
1112         for (int i=0, max=children.size(); i&lt;max; i++) {
1113             Node node = children.get(i);
1114             if (node.isManaged()) {
1115                 final double y = node.getLayoutBounds().getMinY() + node.getLayoutY();
1116                 minY = Math.min(minY, y);
1117                 maxY = Math.max(maxY, y + boundedSize(node.prefHeight(-1), node.minHeight(-1), node.maxHeight(-1)));
1118             }
1119         }
1120         return maxY - minY;
1121     }
1122 
1123     /**
1124      * Calculates the minimum width of this {@code Parent}. The default
1125      * implementation simply returns the pref width.
1126      *
1127      * @param height the height that should be used if min width depends
1128      *      on it
1129      * @return the calculated min width
1130      * @since JavaFX 2.1
1131      */
1132     protected double computeMinWidth(double height) {
1133         return prefWidth(height);
1134     }
1135 
1136     // PENDING_DOC_REVIEW
1137     /**
1138      * Calculates the min height of this {@code Parent}. The default
1139      * implementation simply returns the pref height;
1140      *
1141      * @param width the width that should be used if min height depends
1142      *      on it
1143      * @return the calculated min height
1144      * @since JavaFX 2.1
1145      */
1146     protected double computeMinHeight(double width) {
1147         return prefHeight(width);
1148     }
1149 
1150     /**
1151      * Calculates the baseline offset based on the first managed child. If there
1152      * is no such child, returns {@link Node#getBaselineOffset()}.
1153      *
1154      * @return baseline offset
1155      */
1156     @Override public double getBaselineOffset() {
1157         for (int i=0, max=children.size(); i&lt;max; i++) {
1158             final Node child = children.get(i);
1159             if (child.isManaged()) {
1160                 double offset = child.getBaselineOffset();
1161                 if (offset == BASELINE_OFFSET_SAME_AS_HEIGHT) {
1162                     continue;
1163                 }
1164                 return child.getLayoutBounds().getMinY() + child.getLayoutY() + offset;
1165             }
1166         }
1167         return super.getBaselineOffset();
1168     }
1169 
1170     /***
1171      * It stores the reference to the current child being laid out by its parent.
1172      * This reference is important to differentiate whether a layout is triggered
1173      * by its parent or other events.
1174      */
1175     private Node currentLayoutChild = null;
1176 
1177     boolean isCurrentLayoutChild(Node node) {
1178         return node == currentLayoutChild;
1179     }
1180 
1181     /**
1182      * Executes a top-down layout pass on the scene graph under this parent.
1183      *
1184      * Calling this method while the Parent is doing layout is a no-op.
1185      */
1186     public final void layout() {
1187         // layoutFlag can be accessed or changed during layout processing.
1188         // Hence we need to cache and reset it before performing layout.
1189         LayoutFlags flag = layoutFlag;
1190         setLayoutFlag(LayoutFlags.CLEAN);
1191         switch(flag) {
1192             case CLEAN:
1193                 break;
1194             case NEEDS_LAYOUT:
1195                 if (performingLayout) {
1196                     /* This code is here mainly to avoid infinite loops as layout() is public and the call might be (indirectly) invoked accidentally
1197                      * while doing the layout.
1198                      * One example might be an invocation from Group layout bounds recalculation
1199                      *  (e.g. during the localToScene/localToParent calculation).
1200                      * The layout bounds will thus return layout bounds that are &quot;old&quot; (i.e. before the layout changes, that are just being done),
1201                      * which is likely what the code would expect.
1202                      * The changes will invalidate the layout bounds again however, so the layout bounds query after layout pass will return correct answer.
1203                      */
1204                     break;
1205                 }
1206                 performingLayout = true;
1207                 layoutChildren();
1208                 // Intended fall-through
1209             case DIRTY_BRANCH:
1210                 for (int i = 0, max = children.size(); i &lt; max; i++) {
1211                     final Node child = children.get(i);
1212                     currentLayoutChild = child;
1213                     if (child instanceof Parent) {
1214                         ((Parent)child).layout();
1215                     } else if (child instanceof SubScene) {
1216                         ((SubScene)child).layoutPass();
1217                     }
1218                 }
1219                 currentLayoutChild = null;
1220                 performingLayout = false;
1221                 break;
1222         }
1223     }
1224 
1225     /**
1226      * Invoked during the layout pass to layout the children in this
1227      * {@code Parent}. By default it will only set the size of managed,
1228      * resizable content to their preferred sizes and does not do any node
1229      * positioning.
1230      * &lt;p&gt;
1231      * Subclasses should override this function to layout content as needed.
1232      */
1233     protected void layoutChildren() {
1234         for (int i=0, max=children.size(); i&lt;max; i++) {
1235             final Node node = children.get(i);
1236             currentLayoutChild = node;
1237             if (node.isResizable() &amp;&amp; node.isManaged()) {
1238                 node.autosize();
1239             }
1240         }
1241         currentLayoutChild = null;
1242     }
1243 
1244     /**
1245      * This field is managed by the Scene, and set on any node which is the
1246      * root of a Scene.
1247      */
1248     private boolean sceneRoot = false;
1249 
1250     /**
1251      * Keeps track of whether this node is a layout root. This is updated
1252      * whenever the sceneRoot field changes, or whenever the managed
1253      * property changes.
1254      */
1255     boolean layoutRoot = false;
1256     @Override final void notifyManagedChanged() {
1257         layoutRoot = !isManaged() || sceneRoot;
1258     }
1259 
1260     final boolean isSceneRoot() {
1261         return sceneRoot;
1262     }
1263 
1264     /***********************************************************************
1265      *                                                                     *
1266      *                         Stylesheet Handling                         *
1267      *                                                                     *
1268      **********************************************************************/
1269 
1270 
1271     /**
1272      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1273      * contents. For additional information about using CSS with the
1274      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1275      * Guide&lt;/a&gt;.
1276      */
1277     private final ObservableList&lt;String&gt; stylesheets = new TrackableObservableList&lt;String&gt;() {
1278         @Override
1279         protected void onChanged(Change&lt;String&gt; c) {
1280             final Scene scene = getScene();
1281             if (scene != null) {
1282 
1283                 // Notify the StyleManager if stylesheets change. This Parent&#39;s
1284                 // styleManager will get recreated in NodeHelper.processCSS.
1285                 StyleManager.getInstance().stylesheetsChanged(Parent.this, c);
1286 
1287                 // RT-9784 - if stylesheet is removed, reset styled properties to
1288                 // their initial value.
1289                 c.reset();
1290                 while(c.next()) {
1291                     if (c.wasRemoved() == false) {
1292                         continue;
1293                     }
1294                     break; // no point in resetting more than once...
1295                 }
1296 
1297                 reapplyCSS();
1298             }
1299         }
1300     };
1301 
1302     /**
1303      * Gets an observable list of string URLs linking to the stylesheets to use
1304      * with this Parent&#39;s contents. See {@link Scene#getStylesheets()} for details.
1305      * &lt;p&gt;For additional information about using CSS
1306      * with the scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1307      * Guide&lt;/a&gt;.&lt;/p&gt;
1308      *
1309      * @return the list of stylesheets to use with this Parent
1310      * @since JavaFX 2.1
1311      */
1312     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1313 
1314     /*
1315      * This method recurses up the parent chain until parent is null. As the
1316      * stack unwinds, if the Parent has stylesheets, they are added to the
1317      * list.
1318      *
1319      * It is possible to override this method to stop the recursion. This allows
1320      * a Parent to have a set of stylesheets distinct from its Parent.
1321      *
1322      * Note: This method MUST only be called via its accessor method.
1323      */
1324      // SB-dependency: RT-21247 has been filed to track this
1325     private List&lt;String&gt; doGetAllParentStylesheets() {
1326 
1327         List&lt;String&gt; list = null;
1328         final Parent myParent = getParent();
1329         if (myParent != null) {
1330 
1331             //
1332             // recurse so that stylesheets of Parents closest to the root are
1333             // added to the list first. The ensures that declarations for
1334             // stylesheets further down the tree (closer to the leaf) have
1335             // a higer ordinal in the cascade.
1336             //
1337             list = ParentHelper.getAllParentStylesheets(myParent);
1338         }
1339 
1340         if (stylesheets != null &amp;&amp; stylesheets.isEmpty() == false) {
1341             if (list == null) {
1342                 list = new ArrayList&lt;String&gt;(stylesheets.size());
1343             }
1344             for (int n=0,nMax=stylesheets.size(); n&lt;nMax; n++) {
1345                 list.add(stylesheets.get(n));
1346             }
1347         }
1348 
1349         return list;
1350 
1351     }
1352 
1353     /*
1354      * Note: This method MUST only be called via its accessor method.
1355      */
1356     private void doProcessCSS() {
1357 
1358         // Nothing to do...
1359         if (cssFlag == CssFlags.CLEAN) return;
1360 
1361         // RT-29254 - If DIRTY_BRANCH, pass control to Node#processCSS. This avoids calling NodeHelper.processCSS on
1362         // this node and all of its children when css doesn&#39;t need updated, recalculated, or reapplied.
1363         if (cssFlag == CssFlags.DIRTY_BRANCH) {
1364             super.processCSS();
1365             return;
1366         }
1367 
1368         // Let the super implementation handle CSS for this node
1369         ParentHelper.superProcessCSS(this);
1370 
1371         // avoid the following call to children.toArray if there are no children
1372         if (children.isEmpty()) return;
1373 
1374         //
1375         // RT-33103
1376         //
1377         // It is possible for a child to be removed from children in the middle of
1378         // the following loop. Iterating over the children may result in an IndexOutOfBoundsException.
1379         // So a copy is made and the copy is iterated over.
1380         //
1381         // Note that we don&#39;t want the fail-fast feature of an iterator, not to mention the general iterator overhead.
1382         //
1383         final Node[] childArray = children.toArray(new Node[children.size()]);
1384 
1385         // For each child, process CSS
1386         for (int i=0; i&lt;childArray.length; i++) {
1387 
1388             final Node child = childArray[i];
1389 
1390             //  If a child no longer has this as its parent, then it is skipped.
1391             final Parent childParent = child.getParent();
1392             if (childParent == null || childParent != this) continue;
1393 
1394             // If the parent styles are being updated, recalculated or
1395             // reapplied, then make sure the children get the same treatment.
1396             // Unless the child is already more dirty than this parent (RT-29074).
1397             if(CssFlags.UPDATE.compareTo(child.cssFlag) &gt; 0) {
1398                 child.cssFlag = CssFlags.UPDATE;
1399             }
1400             NodeHelper.processCSS(child);
1401         }
1402     }
1403 
1404     /***********************************************************************
1405      *                               Misc                                  *
1406      *                                                                     *
1407      *  Initialization and other functions                                 *
1408      *                                                                     *
1409      **********************************************************************/
1410     {
1411         // To initialize the class helper at the begining each constructor of this class
1412         ParentHelper.initHelper(this);
1413     }
1414 
1415     /**
1416      * Constructs a new {@code Parent}.
1417      */
1418     protected Parent() {
1419         layoutFlag = LayoutFlags.NEEDS_LAYOUT;
1420         setAccessibleRole(AccessibleRole.PARENT);
1421     }
1422 
1423     private NGNode doCreatePeer() {
1424         return new NGGroup();
1425     }
1426 
1427     @Override
1428     void nodeResolvedOrientationChanged() {
1429         for (int i = 0, max = children.size(); i &lt; max; ++i) {
1430             children.get(i).parentResolvedOrientationInvalidated();
1431         }
1432     }
1433 
1434     /***************************************************************************
1435      *                                                                         *
1436      *                         Bounds Computations                             *
1437      *                                                                         *
1438      *  This code originated in GroupBoundsHelper (part of javafx-sg-common)   *
1439      *  but has been ported here to the FX side since we cannot rely on the PG *
1440      *  side for computing the bounds (due to the decoupling of the two        *
1441      *  scenegraphs for threading and other purposes).                         *
1442      *                                                                         *
1443      *  Unfortunately, we cannot simply reuse GroupBoundsHelper without some  *
1444      *  major (and hacky) modification due to the fact that GroupBoundsHelper  *
1445      *  relies on PG state and we need to do similar things here that rely on  *
1446      *  core scenegraph state. Unfortunately, that means we made a port.       *
1447      *                                                                         *
1448      **************************************************************************/
1449 
1450     private BaseBounds tmp = new RectBounds();
1451 
1452     /**
1453      * The cached bounds for the Group. If the cachedBounds are invalid
1454      * then we have no history of what the bounds are, or were.
1455      */
1456     private BaseBounds cachedBounds = new RectBounds();
1457 
1458     /**
1459      * Indicates that the cachedBounds is invalid (or old) and need to be recomputed.
1460      * If cachedBoundsInvalid is true and dirtyChildrenCount is non-zero,
1461      * then when we recompute the cachedBounds we can consider the
1462      * values in cachedBounds to represent the last valid bounds for the group.
1463      * This is useful for several fast paths.
1464      */
1465     private boolean cachedBoundsInvalid;
1466 
1467     /**
1468      * The number of dirty children which bounds haven&#39;t been incorporated
1469      * into the cached bounds yet. Can be used even when dirtyChildren is null.
1470      */
1471     private int dirtyChildrenCount;
1472 
1473     /**
1474      * This set is used to track all of the children of this group which are
1475      * dirty. It is only used in cases where the number of children is &gt; some
1476      * value (currently 10). For very wide trees, this can provide a very
1477      * important speed boost. For the sake of memory consumption, this is
1478      * null unless the number of children ever crosses the threshold where
1479      * it will be activated.
1480      */
1481     private ArrayList&lt;Node&gt; dirtyChildren;
1482 
1483     private Node top;
1484     private Node left;
1485     private Node bottom;
1486     private Node right;
1487     private Node near;
1488     private Node far;
1489 
1490     private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
1491         // If we have no children, our bounds are invalid
1492         if (children.isEmpty()) {
1493             return bounds.makeEmpty();
1494         }
1495 
1496         if (tx.isTranslateOrIdentity()) {
1497             // this is a transform which is only doing translations, or nothing
1498             // at all (no scales, rotates, or shears)
1499             // so in this case we can easily use the cached bounds
1500             if (cachedBoundsInvalid) {
1501                 recomputeBounds();
1502 
1503                 if (dirtyChildren != null) {
1504                     dirtyChildren.clear();
1505                 }
1506                 cachedBoundsInvalid = false;
1507                 dirtyChildrenCount = 0;
1508             }
1509             if (!tx.isIdentity()) {
1510                 bounds = bounds.deriveWithNewBounds((float)(cachedBounds.getMinX() + tx.getMxt()),
1511                                  (float)(cachedBounds.getMinY() + tx.getMyt()),
1512                                  (float)(cachedBounds.getMinZ() + tx.getMzt()),
1513                                  (float)(cachedBounds.getMaxX() + tx.getMxt()),
1514                                  (float)(cachedBounds.getMaxY() + tx.getMyt()),
1515                                  (float)(cachedBounds.getMaxZ() + tx.getMzt()));
1516             } else {
1517                 bounds = bounds.deriveWithNewBounds(cachedBounds);
1518             }
1519 
1520             return bounds;
1521         } else {
1522             // there is a scale, shear, or rotation happening, so need to
1523             // do the full transform!
1524             double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
1525             double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;
1526             boolean first = true;
1527             for (int i=0, max=children.size(); i&lt;max; i++) {
1528                 final Node node = children.get(i);
1529                 if (node.isVisible()) {
1530                     bounds = getChildTransformedBounds(node, tx, bounds);
1531                     // if the bounds of the child are invalid, we don&#39;t want
1532                     // to use those in the remaining computations.
1533                     if (bounds.isEmpty()) continue;
1534                     if (first) {
1535                         minX = bounds.getMinX();
1536                         minY = bounds.getMinY();
1537                         minZ = bounds.getMinZ();
1538                         maxX = bounds.getMaxX();
1539                         maxY = bounds.getMaxY();
1540                         maxZ = bounds.getMaxZ();
1541                         first = false;
1542                     } else {
1543                         minX = Math.min(bounds.getMinX(), minX);
1544                         minY = Math.min(bounds.getMinY(), minY);
1545                         minZ = Math.min(bounds.getMinZ(), minZ);
1546                         maxX = Math.max(bounds.getMaxX(), maxX);
1547                         maxY = Math.max(bounds.getMaxY(), maxY);
1548                         maxZ = Math.max(bounds.getMaxZ(), maxZ);
1549                     }
1550                 }
1551             }
1552             // if &quot;first&quot; is still true, then we didn&#39;t have any children with
1553             // non-empty bounds and thus we must return an empty bounds,
1554             // otherwise we have non-empty bounds so go for it.
1555             if (first)
1556                 bounds.makeEmpty();
1557             else
1558                 bounds = bounds.deriveWithNewBounds((float)minX, (float)minY, (float)minZ,
1559                         (float)maxX, (float)maxY, (float)maxZ);
1560 
1561             return bounds;
1562         }
1563     }
1564 
1565     private void setChildDirty(final Node node, final boolean dirty) {
1566         if (node.boundsChanged == dirty) {
1567             return;
1568         }
1569 
1570         node.boundsChanged = dirty;
1571         if (dirty) {
1572             if (dirtyChildren != null) {
1573                 dirtyChildren.add(node);
1574             }
1575             ++dirtyChildrenCount;
1576         } else {
1577             if (dirtyChildren != null) {
1578                 dirtyChildren.remove(node);
1579             }
1580             --dirtyChildrenCount;
1581         }
1582     }
1583 
1584     private void childIncluded(final Node node) {
1585         // assert node.isVisible();
1586         cachedBoundsInvalid = true;
1587         setChildDirty(node, true);
1588     }
1589 
1590     // This is called when either the child is actually removed, OR IF IT IS
1591     // TOGGLED TO BE INVISIBLE. This is because in both cases it needs to be
1592     // cleared from the state which manages bounds.
1593     private void childExcluded(final Node node) {
1594         if (node == left) {
1595             left = null;
1596             cachedBoundsInvalid = true;
1597         }
1598         if (node == top) {
1599             top = null;
1600             cachedBoundsInvalid = true;
1601         }
1602         if (node == near) {
1603             near = null;
1604             cachedBoundsInvalid = true;
1605         }
1606         if (node == right) {
1607             right = null;
1608             cachedBoundsInvalid = true;
1609         }
1610         if (node == bottom) {
1611             bottom = null;
1612             cachedBoundsInvalid = true;
1613         }
1614         if (node == far) {
1615             far = null;
1616             cachedBoundsInvalid = true;
1617         }
1618 
1619         setChildDirty(node, false);
1620     }
1621 
1622     /**
1623      * Recomputes the bounds from scratch and saves the cached bounds.
1624      */
1625     private void recomputeBounds() {
1626         // fast path for case of no children
1627         if (children.isEmpty()) {
1628             cachedBounds.makeEmpty();
1629             return;
1630         }
1631 
1632         // fast path for case of 1 child
1633         if (children.size() == 1) {
1634             Node node = children.get(0);
1635             node.boundsChanged = false;
1636             if (node.isVisible()) {
1637                 cachedBounds = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, cachedBounds);
1638                 top = left = bottom = right = near = far = node;
1639             } else {
1640                 cachedBounds.makeEmpty();
1641                 // no need to null edge nodes here, it was done in childExcluded
1642                 // top = left = bottom = right = near = far = null;
1643             }
1644             return;
1645         }
1646 
1647         if ((dirtyChildrenCount == 0) ||
1648                 !updateCachedBounds(dirtyChildren != null
1649                                         ? dirtyChildren : children,
1650                                     dirtyChildrenCount)) {
1651             // failed to update cached bounds, recreate them
1652             createCachedBounds(children);
1653         }
1654     }
1655 
1656     private final int LEFT_INVALID = 1;
1657     private final int TOP_INVALID = 1 &lt;&lt; 1;
1658     private final int NEAR_INVALID = 1 &lt;&lt; 2;
1659     private final int RIGHT_INVALID = 1 &lt;&lt; 3;
1660     private final int BOTTOM_INVALID = 1 &lt;&lt; 4;
1661     private final int FAR_INVALID = 1 &lt;&lt; 5;
1662 
1663     private boolean updateCachedBounds(final List&lt;Node&gt; dirtyNodes,
1664                                        int remainingDirtyNodes) {
1665         // fast path for untransformed bounds calculation
1666         if (cachedBounds.isEmpty()) {
1667             createCachedBounds(dirtyNodes);
1668             return true;
1669         }
1670 
1671         int invalidEdges = 0;
1672 
1673         if ((left == null) || left.boundsChanged) {
1674             invalidEdges |= LEFT_INVALID;
1675         }
1676         if ((top == null) || top.boundsChanged) {
1677             invalidEdges |= TOP_INVALID;
1678         }
1679         if ((near == null) || near.boundsChanged) {
1680             invalidEdges |= NEAR_INVALID;
1681         }
1682         if ((right == null) || right.boundsChanged) {
1683             invalidEdges |= RIGHT_INVALID;
1684         }
1685         if ((bottom == null) || bottom.boundsChanged) {
1686             invalidEdges |= BOTTOM_INVALID;
1687         }
1688         if ((far == null) || far.boundsChanged) {
1689             invalidEdges |= FAR_INVALID;
1690         }
1691 
1692         // These indicate the bounds of the Group as computed by this
1693         // function
1694         float minX = cachedBounds.getMinX();
1695         float minY = cachedBounds.getMinY();
1696         float minZ = cachedBounds.getMinZ();
1697         float maxX = cachedBounds.getMaxX();
1698         float maxY = cachedBounds.getMaxY();
1699         float maxZ = cachedBounds.getMaxZ();
1700 
1701         // this checks the newly added nodes first, so if dirtyNodes is the
1702         // whole children list, we can end early
1703         for (int i = dirtyNodes.size() - 1; remainingDirtyNodes &gt; 0; --i) {
1704             final Node node = dirtyNodes.get(i);
1705             if (node.boundsChanged) {
1706                 // assert node.isVisible();
1707                 node.boundsChanged = false;
1708                 --remainingDirtyNodes;
1709                 tmp = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, tmp);
1710                 if (!tmp.isEmpty()) {
1711                     float tmpx = tmp.getMinX();
1712                     float tmpy = tmp.getMinY();
1713                     float tmpz = tmp.getMinZ();
1714                     float tmpx2 = tmp.getMaxX();
1715                     float tmpy2 = tmp.getMaxY();
1716                     float tmpz2 = tmp.getMaxZ();
1717 
1718                     // If this node forms an edge, then we will set it to be the
1719                     // node for this edge and update the min/max values
1720                     if (tmpx &lt;= minX) {
1721                         minX = tmpx;
1722                         left = node;
1723                         invalidEdges &amp;= ~LEFT_INVALID;
1724                     }
1725                     if (tmpy &lt;= minY) {
1726                         minY = tmpy;
1727                         top = node;
1728                         invalidEdges &amp;= ~TOP_INVALID;
1729                     }
1730                     if (tmpz &lt;= minZ) {
1731                         minZ = tmpz;
1732                         near = node;
1733                         invalidEdges &amp;= ~NEAR_INVALID;
1734                     }
1735                     if (tmpx2 &gt;= maxX) {
1736                         maxX = tmpx2;
1737                         right = node;
1738                         invalidEdges &amp;= ~RIGHT_INVALID;
1739                     }
1740                     if (tmpy2 &gt;= maxY) {
1741                         maxY = tmpy2;
1742                         bottom = node;
1743                         invalidEdges &amp;= ~BOTTOM_INVALID;
1744                     }
1745                     if (tmpz2 &gt;= maxZ) {
1746                         maxZ = tmpz2;
1747                         far = node;
1748                         invalidEdges &amp;= ~FAR_INVALID;
1749                     }
1750                 }
1751             }
1752         }
1753 
1754         if (invalidEdges != 0) {
1755             // failed to validate some edges
1756             return false;
1757         }
1758 
1759         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1760                                                         maxX, maxY, maxZ);
1761         return true;
1762     }
1763 
1764     private void createCachedBounds(final List&lt;Node&gt; fromNodes) {
1765         // These indicate the bounds of the Group as computed by this function
1766         float minX, minY, minZ;
1767         float maxX, maxY, maxZ;
1768 
1769         final int nodeCount = fromNodes.size();
1770         int i;
1771 
1772         // handle first visible non-empty node
1773         for (i = 0; i &lt; nodeCount; ++i) {
1774             final Node node = fromNodes.get(i);
1775             node.boundsChanged = false;
1776             if (node.isVisible()) {
1777                 tmp = node.getTransformedBounds(
1778                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1779                 if (!tmp.isEmpty()) {
1780                     left = top = near = right = bottom = far = node;
1781                     break;
1782                 }
1783             }
1784         }
1785 
1786         if (i == nodeCount) {
1787             left = top = near = right = bottom = far = null;
1788             cachedBounds.makeEmpty();
1789             return;
1790         }
1791 
1792         minX = tmp.getMinX();
1793         minY = tmp.getMinY();
1794         minZ = tmp.getMinZ();
1795         maxX = tmp.getMaxX();
1796         maxY = tmp.getMaxY();
1797         maxZ = tmp.getMaxZ();
1798 
1799         // handle remaining visible non-empty nodes
1800         for (++i; i &lt; nodeCount; ++i) {
1801             final Node node = fromNodes.get(i);
1802             node.boundsChanged = false;
1803             if (node.isVisible()) {
1804                 tmp = node.getTransformedBounds(
1805                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1806                 if (!tmp.isEmpty()) {
1807                     final float tmpx = tmp.getMinX();
1808                     final float tmpy = tmp.getMinY();
1809                     final float tmpz = tmp.getMinZ();
1810                     final float tmpx2 = tmp.getMaxX();
1811                     final float tmpy2 = tmp.getMaxY();
1812                     final float tmpz2 = tmp.getMaxZ();
1813 
1814                     if (tmpx &lt; minX) { minX = tmpx; left = node; }
1815                     if (tmpy &lt; minY) { minY = tmpy; top = node; }
1816                     if (tmpz &lt; minZ) { minZ = tmpz; near = node; }
1817                     if (tmpx2 &gt; maxX) { maxX = tmpx2; right = node; }
1818                     if (tmpy2 &gt; maxY) { maxY = tmpy2; bottom = node; }
1819                     if (tmpz2 &gt; maxZ) { maxZ = tmpz2; far = node; }
1820                 }
1821             }
1822         }
1823 
1824         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1825                                                         maxX, maxY, maxZ);
1826     }
1827 
1828     /**
1829      * Updates the bounds of this {@code Parent} and its children.
1830      */
1831     @Override protected void updateBounds() {
1832         for (int i=0, max=children.size(); i&lt;max; i++) {
1833             children.get(i).updateBounds();
1834         }
1835         super.updateBounds();
1836     }
1837 
1838     // Note: this marks the currently processed child in terms of transformed bounds. In rare situations like
1839     // in RT-37879, it might happen that the child bounds will be marked as invalid. Due to optimizations,
1840     // the invalidation must *always* be propagated to the parent, because the parent with some transformation
1841     // calls child&#39;s getTransformedBounds non-idenitity transform and the child&#39;s transformed bounds are thus not validated.
1842     // This does not apply to the call itself however, because the call will yield the correct result even if something
1843     // was invalidated during the computation. We can safely ignore such invalidations from that Node in this case
1844     private Node currentlyProcessedChild;
1845 
1846     private BaseBounds getChildTransformedBounds(Node node, BaseTransform tx, BaseBounds bounds) {
1847         currentlyProcessedChild = node;
1848         bounds = node.getTransformedBounds(bounds, tx);
1849         currentlyProcessedChild = null;
1850         return bounds;
1851     }
1852 
1853     /**
1854      * Called by Node whenever its bounds have changed.
1855      */
1856     void childBoundsChanged(Node node) {
1857         // See comment above at &quot;currentlyProcessedChild&quot; field
1858         if (node == currentlyProcessedChild) {
1859             return;
1860         }
1861 
1862         cachedBoundsInvalid = true;
1863 
1864         // mark the node such that the parent knows that the child&#39;s bounds
1865         // are not in sync with this parent. In this way, when the bounds
1866         // need to be computed, we&#39;ll come back and figure out the new bounds
1867         // for all the children which have boundsChanged set to true
1868         setChildDirty(node, true);
1869 
1870         // go ahead and indicate that the geom has changed for this parent,
1871         // even though once we figure it all out it may be that the bounds
1872         // have not changed
1873         NodeHelper.geomChanged(this);
1874     }
1875 
1876     /**
1877      * Called by node whenever the visibility of the node changes.
1878      */
1879     void childVisibilityChanged(Node node) {
1880         if (node.isVisible()) {
1881             childIncluded(node);
1882         } else {
1883             childExcluded(node);
1884         }
1885 
1886         NodeHelper.geomChanged(this);
1887     }
1888 
1889     /*
1890      * Note: This method MUST only be called via its accessor method.
1891      */
1892     private boolean doComputeContains(double localX, double localY) {
1893         final Point2D tempPt = TempState.getInstance().point;
1894         for (int i=0, max=children.size(); i&lt;max; i++) {
1895             final Node node = children.get(i);
1896             tempPt.x = (float)localX;
1897             tempPt.y = (float)localY;
1898             try {
1899                 node.parentToLocal(tempPt);
1900             } catch (NoninvertibleTransformException e) {
1901                 continue;
1902             }
1903             if (node.contains(tempPt.x, tempPt.y)) {
1904                 return true;
1905             }
1906         }
1907         return false;
1908     }
1909 
1910     /** {@inheritDoc} */
1911     @Override
1912     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1913         switch (attribute) {
1914             case CHILDREN: return getChildrenUnmodifiable();
1915             default: return super.queryAccessibleAttribute(attribute, parameters);
1916         }
1917     }
1918 
1919     void releaseAccessible() {
1920         for (int i=0, max=children.size(); i&lt;max; i++) {
1921             final Node node = children.get(i);
1922             node.releaseAccessible();
1923         }
1924         super.releaseAccessible();
1925     }
1926 
1927     /**
1928      * Note: The only user of this method is in unit test: Parent_structure_sync_Test.
1929      */
1930     List&lt;Node&gt; test_getRemoved() {
1931         return removed;
1932     }
1933 
1934     /**
1935      * Note: The only user of this method is in unit test:
1936      * Parent_viewOrderChildren_sync_Test.
1937      */
1938     List&lt;Node&gt; test_getViewOrderChildren() {
1939         return viewOrderChildren;
1940     }
1941 }
    </pre>
  </body>
</html>