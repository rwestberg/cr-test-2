<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Accessible;
  30 import com.sun.javafx.util.Logging;
  31 import com.sun.javafx.util.Utils;
  32 import com.sun.javafx.application.PlatformImpl;
  33 import com.sun.javafx.collections.TrackableObservableList;
  34 import com.sun.javafx.css.StyleManager;
  35 import com.sun.javafx.cursor.CursorFrame;
  36 import com.sun.javafx.event.EventQueue;
  37 import com.sun.javafx.geom.PickRay;
  38 import com.sun.javafx.geom.Vec3d;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.scene.CssFlags;
  42 import com.sun.javafx.scene.LayoutFlags;
  43 import com.sun.javafx.scene.SceneEventDispatcher;
  44 import com.sun.javafx.scene.SceneHelper;
  45 import com.sun.javafx.scene.input.DragboardHelper;
  46 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  47 import com.sun.javafx.scene.input.InputEventUtils;
  48 import com.sun.javafx.scene.input.PickResultChooser;
  49 import com.sun.javafx.scene.traversal.Direction;
  50 import com.sun.javafx.scene.traversal.SceneTraversalEngine;
  51 import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
  52 import com.sun.javafx.sg.prism.NGCamera;
  53 import com.sun.javafx.sg.prism.NGLightBase;
  54 import com.sun.javafx.tk.*;
  55 import com.sun.prism.impl.PrismSettings;
  56 
  57 import javafx.animation.KeyFrame;
  58 import javafx.animation.Timeline;
  59 import javafx.application.ConditionalFeature;
  60 import javafx.application.Platform;
  61 import javafx.beans.DefaultProperty;
  62 import javafx.beans.InvalidationListener;
  63 import javafx.beans.NamedArg;
  64 import javafx.beans.property.*;
  65 import javafx.collections.FXCollections;
  66 import javafx.collections.ListChangeListener.Change;
  67 import javafx.collections.ObservableList;
  68 import javafx.collections.ObservableMap;
  69 import javafx.css.CssMetaData;
  70 import javafx.css.StyleableObjectProperty;
  71 import javafx.event.*;
  72 import javafx.geometry.*;
  73 import javafx.scene.image.WritableImage;
  74 import javafx.scene.input.*;
  75 import javafx.scene.paint.Color;
  76 import javafx.scene.paint.Paint;
  77 import javafx.stage.PopupWindow;
  78 import javafx.stage.Stage;
  79 import javafx.stage.StageStyle;
  80 import javafx.stage.Window;
  81 import javafx.util.Callback;
  82 import javafx.util.Duration;
  83 import com.sun.javafx.logging.PlatformLogger;
  84 import com.sun.javafx.logging.PlatformLogger.Level;
  85 
  86 import java.security.AccessControlContext;
  87 import java.security.AccessController;
  88 import java.security.PrivilegedAction;
  89 import java.util.*;
  90 import java.util.concurrent.CopyOnWriteArrayList;
  91 
  92 import com.sun.javafx.logging.PulseLogger;
  93 
  94 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  95 import com.sun.javafx.scene.NodeHelper;
  96 import com.sun.javafx.stage.WindowHelper;
  97 import com.sun.javafx.scene.input.ClipboardHelper;
  98 import com.sun.javafx.scene.input.TouchPointHelper;
  99 import java.lang.ref.WeakReference;
 100 
 101 /**
 102  * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 103  * The background of the scene is filled as specified by the {@code fill} property.
 104  * &lt;p&gt;
 105  * The application must specify the root {@code Node} for the scene graph by setting
 106  * the {@code root} property.   If a {@code Group} is used as the root, the
 107  * contents of the scene graph will be clipped by the scene&#39;s width and height and
 108  * changes to the scene&#39;s size (if user resizes the stage) will not alter the
 109  * layout of the scene graph. If a resizable node (layout {@code Region} or
 110  * {@code Control}) is set as the root, then the root&#39;s size will track the
 111  * scene&#39;s size, causing the contents to be relayed out as necessary.
 112  * &lt;p&gt;
 113  * The scene&#39;s size may be initialized by the application during construction.
 114  * If no size is specified, the scene will automatically compute its initial
 115  * size based on the preferred size of its content. If only one dimension is specified,
 116  * the other dimension is computed using the specified dimension, respecting content bias
 117  * of a root.
 118  * &lt;p&gt;
 119  * An application may request depth buffer support or scene anti-aliasing
 120  * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 121  * without any 3D transforms does not need a depth buffer nor scene
 122  * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 123  * transforms may use depth buffer support for proper depth sorted rendering; to
 124  * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 125  * shapes that have no 3D transforms. See
 126  * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 127  * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 128  * &lt;p&gt;
 129  * The depthBuffer and antiAliasing flags are conditional features. With the
 130  * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 131  * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 132  * for more information.
 133  * &lt;p&gt;
 134  * A default headlight will be added to a scene that contains one or more
 135  * {@code Shape3D} nodes, but no light nodes. This light source is a
 136  * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 137  *
 138  * &lt;p&gt;
 139  * A {@code Scene} may be created and modified on any thread until it is attached
 140  * to a {@link Window} that is {@link Window#isShowing() showing}.
 141  * After that, it must be modified only on the JavaFX Application Thread.
 142  * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 143  * multiple threads at the same time will lead to unpredictable results and
 144  * must be avoided.
 145  * &lt;/p&gt;
 146  *
 147  * &lt;p&gt;
 148  * The JavaFX Application Thread is created as part of the startup process for
 149  * the JavaFX runtime. See the {@link javafx.application.Application} class and
 150  * the {@link Platform#startup(Runnable)} method for more information.
 151  * &lt;/p&gt;
 152  *
 153  * &lt;p&gt;Example:&lt;/p&gt;
 154  *
 155  * &lt;pre&gt;
 156 import javafx.scene.*;
 157 import javafx.scene.paint.*;
 158 import javafx.scene.shape.*;
 159 
 160 Group root = new Group();
 161 Scene s = new Scene(root, 300, 300, Color.BLACK);
 162 
 163 Rectangle r = new Rectangle(25,25,250,250);
 164 r.setFill(Color.BLUE);
 165 
 166 root.getChildren().add(r);
 167  * &lt;/pre&gt;
 168  *
 169  * @since JavaFX 2.0
 170  */
 171 @DefaultProperty(&quot;root&quot;)
 172 public class Scene implements EventTarget {
 173 
 174     private double widthSetByUser = -1.0;
 175     private double heightSetByUser = -1.0;
 176     private boolean sizeInitialized = false;
 177     private final boolean depthBuffer;
 178     private final SceneAntialiasing antiAliasing;
 179 
 180     private EnumSet&lt;DirtyBits&gt; dirtyBits = EnumSet.noneOf(DirtyBits.class);
 181 
 182     final AccessControlContext acc = AccessController.getContext();
 183 
 184     private Camera defaultCamera;
 185 
 186     /**
 187      * A node that is temporarily responsible for the FOCUS_NODE
 188      * accessibility attribute. E.g. a currently active MenuBar.
 189      */
 190     private Node transientFocusContainer;
 191 
 192     //Neither width nor height are initialized and will be calculated according to content when this Scene
 193     //is shown for the first time.
 194 //    public Scene() {
 195 //        //this(-1, -1, (Parent) new Group());
 196 //        this(-1, -1, (Parent)null);
 197 //    }
 198 
 199     /**
 200      * Creates a Scene for a specific root Node.
 201      *
 202      * @param root The root node of the scene graph
 203      *
 204      * @throws NullPointerException if root is null
 205      */
 206     public Scene(@NamedArg(&quot;root&quot;) Parent root) {
 207         this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
 208     }
 209 
 210 //Public constructor initializing public-init properties
 211 //When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
 212 //Unitialized dimension is calculated when Scene is shown for the first time.
 213 //    public Scene(
 214 //            @Default(&quot;-1&quot;) double width,
 215 //            @Default(&quot;-1&quot;) double height) {
 216 //        //this(width, height, (Parent)new Group());
 217 //        this(width, height, (Parent)null);
 218 //    }
 219 //
 220 //    public Scene(double width, double height, Paint fill) {
 221 //        //this(width, height, (Parent) new Group());
 222 //        this(width, height, (Parent)null);
 223 //        setFill(fill);
 224 //    }
 225 
 226     /**
 227      * Creates a Scene for a specific root Node with a specific size.
 228      *
 229      * @param root The root node of the scene graph
 230      * @param width The width of the scene
 231      * @param height The height of the scene
 232      *
 233      * @throws NullPointerException if root is null
 234      */
 235     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
 236         this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
 237     }
 238 
 239     /**
 240      * Creates a Scene for a specific root Node with a fill.
 241      *
 242      * @param root The parent
 243      * @param fill The fill
 244      *
 245      * @throws NullPointerException if root is null
 246      */
 247     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 248         this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
 249     }
 250 
 251     /**
 252      * Creates a Scene for a specific root Node with a specific size and fill.
 253      *
 254      * @param root The root node of the scene graph
 255      * @param width The width of the scene
 256      * @param height The height of the scene
 257      * @param fill The fill
 258      *
 259      * @throws NullPointerException if root is null
 260      */
 261     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
 262             @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 263         this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
 264     }
 265 
 266     /**
 267      * Constructs a scene consisting of a root, with a dimension of width and
 268      * height, and specifies whether a depth buffer is created for this scene.
 269      * &lt;p&gt;
 270      * A scene with only 2D shapes and without any 3D transforms does not need a
 271      * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
 272      * transforms may use depth buffer support for proper depth sorted
 273      * rendering; to avoid depth fighting (also known as Z fighting), disable
 274      * depth testing on 2D shapes that have no 3D transforms. See
 275      * {@link Node#depthTestProperty() depthTest} for more information.
 276      *
 277      * @param root The root node of the scene graph
 278      * @param width The width of the scene
 279      * @param height The height of the scene
 280      * @param depthBuffer The depth buffer flag
 281      * &lt;p&gt;
 282      * The depthBuffer flag is a conditional feature and its default value is
 283      * false. See
 284      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 285      * for more information.
 286      *
 287      * @throws NullPointerException if root is null
 288      *
 289      * @see javafx.scene.Node#setDepthTest(DepthTest)
 290      */
 291     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
 292         this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
 293     }
 294 
 295     /**
 296      * Constructs a scene consisting of a root, with a dimension of width and
 297      * height, specifies whether a depth buffer is created for this scene and
 298      * specifies whether scene anti-aliasing is requested.
 299      * &lt;p&gt;
 300      * A scene with only 2D shapes and without any 3D transforms does not need a
 301      * depth buffer nor scene anti-aliasing support. A scene containing 3D
 302      * shapes or 2D shapes with 3D transforms may use depth buffer support for
 303      * proper depth sorted rendering; to avoid depth fighting (also known as Z
 304      * fighting), disable depth testing on 2D shapes that have no 3D transforms.
 305      * See {@link Node#depthTestProperty() depthTest} for more information. A
 306      * scene with 3D shapes may enable scene anti-aliasing to improve its
 307      * rendering quality.
 308      *
 309      * @param root The root node of the scene graph
 310      * @param width The width of the scene
 311      * @param height The height of the scene
 312      * @param depthBuffer The depth buffer flag
 313      * @param antiAliasing The scene anti-aliasing attribute. A value of
 314      * {@code null} is treated as DISABLED.
 315      * &lt;p&gt;
 316      * The depthBuffer and antiAliasing are conditional features. With the
 317      * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
 318      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 319      * for more information.
 320      *
 321      * @throws NullPointerException if root is null
 322      *
 323      * @see javafx.scene.Node#setDepthTest(DepthTest)
 324      * @since JavaFX 8.0
 325      */
 326     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
 327             @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
 328             @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
 329         this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);
 330 
 331         if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
 332                 !Toolkit.getToolkit().isMSAASupported())
 333         {
 334             String logname = Scene.class.getName();
 335             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 336                 + &quot;antiAliasing&quot;);
 337         }
 338     }
 339 
 340     private Scene(Parent root, double width, double height, Paint fill,
 341             boolean depthBuffer, SceneAntialiasing antiAliasing) {
 342         this.depthBuffer = depthBuffer;
 343         this.antiAliasing = antiAliasing;
 344         if (root == null) {
 345             throw new NullPointerException(&quot;Root cannot be null&quot;);
 346         }
 347 
 348         if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
 349                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
 350             String logname = Scene.class.getName();
 351             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 352                     + &quot;ConditionalFeature.SCENE3D&quot;);
 353         }
 354 
 355         init();
 356         setRoot(root);
 357         init(width, height);
 358         setFill(fill);
 359     }
 360 
 361     static {
 362             PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
 363                 public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
 364                     synchronized (trackerMonitor) {
 365                         scene.tracker = tracker;
 366                     }
 367                 }
 368                 public PerformanceTracker getPerfTracker(Scene scene) {
 369                     synchronized (trackerMonitor) {
 370                         return scene.tracker;
 371                     }
 372                 }
 373             });
 374             SceneHelper.setSceneAccessor(
 375                     new SceneHelper.SceneAccessor() {
 376                         @Override
 377                         public void enableInputMethodEvents(Scene scene, boolean enable) {
 378                             scene.enableInputMethodEvents(enable);
 379                         }
 380 
 381                         @Override
 382                         public void processKeyEvent(Scene scene, KeyEvent e) {
 383                             scene.processKeyEvent(e);
 384                         }
 385 
 386                         @Override
 387                         public void processMouseEvent(Scene scene, MouseEvent e) {
 388                             scene.processMouseEvent(e);
 389                         }
 390 
 391                         @Override
 392                         public void preferredSize(Scene scene) {
 393                             scene.preferredSize();
 394                         }
 395 
 396                         @Override
 397                         public void disposePeer(Scene scene) {
 398                             scene.disposePeer();
 399                         }
 400 
 401                         @Override
 402                         public void initPeer(Scene scene) {
 403                             scene.initPeer();
 404                         }
 405 
 406                         @Override
 407                         public void setWindow(Scene scene, Window window) {
 408                             scene.setWindow(window);
 409                         }
 410 
 411                         @Override
 412                         public TKScene getPeer(Scene scene) {
 413                             return scene.getPeer();
 414                         }
 415 
 416                         @Override
 417                         public void setAllowPGAccess(boolean flag) {
 418                             Scene.setAllowPGAccess(flag);
 419                         }
 420 
 421                         @Override
 422                         public void parentEffectiveOrientationInvalidated(
 423                                 final Scene scene) {
 424                             scene.parentEffectiveOrientationInvalidated();
 425                         }
 426 
 427                         @Override
 428                         public Camera getEffectiveCamera(Scene scene) {
 429                             return scene.getEffectiveCamera();
 430                         }
 431 
 432                         @Override
 433                         public Scene createPopupScene(Parent root) {
 434                             return new Scene(root) {
 435                                        @Override
 436                                        void doLayoutPass() {
 437                                            resizeRootToPreferredSize(getRoot());
 438                                            super.doLayoutPass();
 439                                        }
 440 
 441                                        @Override
 442                                        void resizeRootOnSceneSizeChange(
 443                                                double newWidth,
 444                                                double newHeight) {
 445                                            // don&#39;t resize
 446                                        }
 447                                    };
 448                         }
 449 
 450                         @Override
 451                         public void setTransientFocusContainer(Scene scene, Node node) {
 452                             if (scene != null) {
 453                                 scene.transientFocusContainer = node;
 454                             }
 455                         }
 456 
 457                         @Override
 458                         public Accessible getAccessible(Scene scene) {
 459                             return scene.getAccessible();
 460                         }
 461                     });
 462         }
 463 
 464         // Reserve space for 30 nodes in the dirtyNodes set.
 465         private static final int MIN_DIRTY_CAPACITY = 30;
 466 
 467         // For debugging
 468         private static boolean inSynchronizer = false;
 469         private static boolean inMousePick = false;
 470         private static boolean allowPGAccess = false;
 471         private static int pgAccessCount = 0;
 472 
 473         /**
 474          * Used for debugging purposes. Returns true if we are in either the
 475          * mouse event code (picking) or the synchronizer, or if the scene is
 476          * not yet initialized,
 477          *
 478          */
 479         static boolean isPGAccessAllowed() {
 480             return inSynchronizer || inMousePick || allowPGAccess;
 481         }
 482 
 483         static void setAllowPGAccess(boolean flag) {
 484             if (Utils.assertionEnabled()) {
 485                 if (flag) {
 486                     pgAccessCount++;
 487                     allowPGAccess = true;
 488                 }
 489                 else {
 490                     if (pgAccessCount &lt;= 0) {
 491                         throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
 492                     }
 493                     if (--pgAccessCount == 0) {
 494                         allowPGAccess = false;
 495                     }
 496                 }
 497             }
 498         }
 499 
 500         /**
 501          * If true, use the platform&#39;s drag gesture detection
 502          * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
 503          */
 504         private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
 505 
 506     /**
 507      * Set of dirty nodes; processed once per frame by the synchronizer.
 508      * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
 509      * to the graphics stack and requires synchronization, then that node
 510      * is added to this list. Note that if state on the Node changes, but it
 511      * was already dirty, then the Node doesn&#39;t add itself again.
 512      * &lt;p&gt;
 513      * Because at initialization time every node in the scene graph is dirty,
 514      * we have a special state and special code path during initialization
 515      * that does not involve adding each node to the dirtyNodes list. When
 516      * dirtyNodes is null, that means this Scene has not yet been synchronized.
 517      * A good default size is then created for the dirtyNodes list.
 518      * &lt;p&gt;
 519      * We double-buffer the set so that we can add new nodes to the
 520      * set while processing the existing set. This avoids our having to
 521      * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
 522      */
 523     private Node[] dirtyNodes;
 524     private int dirtyNodesSize;
 525 
 526     /**
 527      * Add the specified node to this scene&#39;s dirty list. Called by the
 528      * markDirty method in Node or when the Node&#39;s scene changes.
 529      */
 530     void addToDirtyList(Node n) {
 531         if (dirtyNodes == null || dirtyNodesSize == 0) {
 532             if (peer != null) {
 533                 Toolkit.getToolkit().requestNextPulse();
 534             }
 535         }
 536 
 537         if (dirtyNodes != null) {
 538             if (dirtyNodesSize == dirtyNodes.length) {
 539                 Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
 540                 System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
 541                 dirtyNodes = tmp;
 542             }
 543             dirtyNodes[dirtyNodesSize++] = n;
 544         }
 545     }
 546 
 547     private void doCSSPass() {
 548         final Parent sceneRoot = getRoot();
 549         //
 550         // RT-17547: when the tree is synchronized, the dirty bits are
 551         // are cleared but the cssFlag might still be something other than
 552         // clean.
 553         //
 554         // Before RT-17547, the code checked the dirty bit. But this is
 555         // superfluous since the dirty bit will be set if the flag is not clean,
 556         // but the flag will never be anything other than clean if the dirty
 557         // bit is not set. The dirty bit is still needed, however, since setting
 558         // it ensures a pulse if no other dirty bits have been set.
 559         //
 560         // For the purpose of showing the change, the dirty bit
 561         // check code was commented out and not removed.
 562         //
 563 //        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
 564         if (sceneRoot.cssFlag != CssFlags.CLEAN) {
 565             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 566             // The cssFlag is set to clean in either Node.processCSS or
 567             // NodeHelper.processCSS
 568             sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 569             sceneRoot.processCSS();
 570         }
 571     }
 572 
 573     void doLayoutPass() {
 574         final Parent r = getRoot();
 575         if (r != null) {
 576             r.layout();
 577         }
 578     }
 579 
 580     /**
 581      * The peer of this scene
 582      */
 583     private TKScene peer;
 584 
 585     /*
 586      * Get Scene&#39;s peer
 587      */
 588     TKScene getPeer() {
 589         return peer;
 590     }
 591 
 592     /**
 593      * The scene pulse listener that gets called on toolkit pulses
 594      */
 595     ScenePulseListener scenePulseListener = new ScenePulseListener();
 596 
 597     private List&lt;Runnable&gt; preLayoutPulseListeners;
 598     private List&lt;Runnable&gt; postLayoutPulseListeners;
 599 
 600     /**
 601      * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
 602      * this listener will be called on the JavaFX Application Thread directly
 603      * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
 604      * any rendering is done for
 605      * this frame. This scene pulse listener is suitable for knowing when a
 606      * scenegraph pulse is happening and also for modifying the scenegraph
 607      * (as it is called before CSS and layout, so any changes made will be properly
 608      * styled and positioned).
 609      *
 610      * This method must be called on the JavaFX Application thread.
 611      *
 612      * @param r The Runnable to be called when the pulse occurs.
 613      *
 614      * @throws IllegalStateException if this method is called on a thread
 615      * other than the JavaFX Application Thread.
 616      *
 617      * @throws NullPointerException if the provided Runnable is null.
 618      *
 619      * @since 9
 620      */
 621     public final void addPreLayoutPulseListener(Runnable r) {
 622         Toolkit.getToolkit().checkFxUserThread();
 623 
 624         if (r == null) {
 625             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 626         }
 627         if (preLayoutPulseListeners == null) {
 628             preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 629         }
 630         preLayoutPulseListeners.add(r);
 631     }
 632 
 633     /**
 634      * Removes a previously registered scene pre layout pulse listener from listening to
 635      * pulses in this scene. This method does nothing if the specified Runnable is
 636      * not already in the list.
 637      *
 638      * This method must be called on the JavaFX Application thread.
 639      *
 640      * @param r The Runnable that should no longer be called when the pulse
 641      * occurs for this scene.
 642      *
 643      * @throws IllegalStateException if this method is called on a thread
 644      * other than the JavaFX Application Thread.
 645      *
 646      * @since 9
 647      */
 648     public final void removePreLayoutPulseListener(Runnable r) {
 649         Toolkit.getToolkit().checkFxUserThread();
 650 
 651         if (preLayoutPulseListeners == null) {
 652             return;
 653         }
 654         preLayoutPulseListeners.remove(r);
 655     }
 656 
 657     /**
 658      * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
 659      * this listener will be called on the JavaFX Application Thread directly
 660      * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
 661      * this frame. This scene pulse listener is suitable for knowing when a
 662      * scenegraph pulse is happening, but it is not suited to use cases related
 663      * to modifying the scenegraph (as it is called after CSS and layout, so
 664      * any changes will possibly be incorrect until the next pulse is run).
 665      * An alternative (and better) solution for situations where a scenegraph
 666      * modification is required to happen is to use either the
 667      * {@link #addPreLayoutPulseListener(Runnable)} API or the the
 668      * {@link javafx.animation.AnimationTimer} API.
 669      *
 670      * This method must be called on the JavaFX Application thread.
 671      *
 672      * @param r The Runnable to be called when the pulse occurs.
 673      *
 674      * @throws IllegalStateException if this method is called on a thread
 675      * other than the JavaFX Application Thread.
 676      *
 677      * @throws NullPointerException if the provided Runnable is null.
 678      *
 679      * @since 9
 680      */
 681     public final void addPostLayoutPulseListener(Runnable r) {
 682         Toolkit.getToolkit().checkFxUserThread();
 683 
 684         if (r == null) {
 685             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 686         }
 687         if (postLayoutPulseListeners == null) {
 688             postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 689         }
 690         postLayoutPulseListeners.add(r);
 691     }
 692 
 693     /**
 694      * Removes a previously registered scene post layout pulse listener from listening to
 695      * pulses in this scene. This method does nothing if the specified Runnable is
 696      * not already in the list.
 697      *
 698      * This method must be called on the JavaFX Application thread.
 699      *
 700      * @param r The Runnable that should no longer be called when the pulse
 701      * occurs for this scene.
 702      *
 703      * @throws IllegalStateException if this method is called on a thread
 704      * other than the JavaFX Application Thread.
 705      *
 706      * @since 9
 707      */
 708     public final void removePostLayoutPulseListener(Runnable r) {
 709         Toolkit.getToolkit().checkFxUserThread();
 710 
 711         if (postLayoutPulseListeners == null) {
 712             return;
 713         }
 714         postLayoutPulseListeners.remove(r);
 715     }
 716 
 717     /**
 718      * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
 719      * &lt;p&gt;
 720      * Note: this is a conditional feature. See
 721      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 722      * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
 723      * for more information.
 724      * @return the SceneAntialiasing for this scene
 725      * @since JavaFX 8.0
 726      */
 727     public final SceneAntialiasing getAntiAliasing() {
 728         return antiAliasing;
 729     }
 730 
 731     private boolean getAntiAliasingInternal() {
 732         return (antiAliasing != null &amp;&amp;
 733                 Toolkit.getToolkit().isMSAASupported() &amp;&amp;
 734                 Platform.isSupported(ConditionalFeature.SCENE3D)) ?
 735                 antiAliasing != SceneAntialiasing.DISABLED : false;
 736     }
 737 
 738     /**
 739      * The {@code Window} for this {@code Scene}
 740      */
 741     private ReadOnlyObjectWrapper&lt;Window&gt; window;
 742 
 743     void setWindow(Window value) {
 744         windowPropertyImpl().set(value);
 745     }
 746 
 747     public final Window getWindow() {
 748         return window == null ? null : window.get();
 749     }
 750 
 751     public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
 752         return windowPropertyImpl().getReadOnlyProperty();
 753     }
 754 
 755     private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
 756         if (window == null) {
 757             window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
 758                 private Window oldWindow;
 759 
 760                 @Override protected void invalidated() {
 761                     final Window newWindow = get();
 762                     getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
 763                     if (oldWindow != null) {
 764                         disposePeer();
 765                     }
 766                     if (newWindow != null) {
 767                         initPeer();
 768                     }
 769                     parentEffectiveOrientationInvalidated();
 770 
 771                     oldWindow = newWindow;
 772                 }
 773 
 774                 @Override
 775                 public Object getBean() {
 776                     return Scene.this;
 777                 }
 778 
 779                 @Override
 780                 public String getName() {
 781                     return &quot;window&quot;;
 782                 }
 783             };
 784         }
 785         return window;
 786     }
 787 
 788     void initPeer() {
 789         assert peer == null;
 790 
 791         Window window = getWindow();
 792         // initPeer() is only called from Window, either when the window
 793         // is being shown, or the window scene is being changed. In any case
 794         // this scene&#39;s window cannot be null.
 795         assert window != null;
 796 
 797         TKStage windowPeer = WindowHelper.getPeer(window);
 798         if (windowPeer == null) {
 799             // This is fine, the window is not visible. initPeer() will
 800             // be called again later, when the window is being shown.
 801             return;
 802         }
 803 
 804         final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
 805         if (!isTransparentWindowsSupported) {
 806             PlatformImpl.addNoTransparencyStylesheetToScene(this);
 807         }
 808 
 809         PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);
 810 
 811         setAllowPGAccess(true);
 812 
 813         Toolkit tk = Toolkit.getToolkit();
 814         peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
 815         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
 816         peer.setTKSceneListener(new ScenePeerListener());
 817         peer.setTKScenePaintListener(new ScenePeerPaintListener());
 818         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
 819         peer.setRoot(getRoot().getPeer());
 820         peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
 821         NodeHelper.updatePeer(getEffectiveCamera());
 822         peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
 823         peer.markDirty();
 824         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);
 825 
 826         setAllowPGAccess(false);
 827 
 828         tk.addSceneTkPulseListener(scenePulseListener);
 829         // listen to dnd gestures coming from the platform
 830         if (PLATFORM_DRAG_GESTURE_INITIATION) {
 831             if (dragGestureListener == null) {
 832                 dragGestureListener = new DragGestureListener();
 833             }
 834             tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
 835         }
 836         tk.enableDrop(peer, new DropTargetListener());
 837         tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());
 838 
 839         PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
 840     }
 841 
 842     public void disposePeer() {
 843         if (peer == null) {
 844             // This is fine, the window is either not shown yet and there is no
 845             // need in disposing scene peer, or is hidden and disposePeer()
 846             // has already been called.
 847             return;
 848         }
 849 
 850         PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);
 851 
 852         Toolkit tk = Toolkit.getToolkit();
 853         tk.removeSceneTkPulseListener(scenePulseListener);
 854         if (accessible != null) {
 855             disposeAccessibles();
 856             Node root = getRoot();
 857             if (root != null) root.releaseAccessible();
 858             accessible.dispose();
 859             accessible = null;
 860         }
 861         peer.dispose();
 862         peer = null;
 863 
 864         PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
 865     }
 866 
 867     DnDGesture dndGesture = null;
 868     DragGestureListener dragGestureListener;
 869     /**
 870      * The horizontal location of this {@code Scene} on the {@code Window}.
 871      */
 872     private ReadOnlyDoubleWrapper x;
 873 
 874     private final void setX(double value) {
 875         xPropertyImpl().set(value);
 876     }
 877 
 878     public final double getX() {
 879         return x == null ? 0.0 : x.get();
 880     }
 881 
 882     public final ReadOnlyDoubleProperty xProperty() {
 883         return xPropertyImpl().getReadOnlyProperty();
 884     }
 885 
 886     private ReadOnlyDoubleWrapper xPropertyImpl() {
 887         if (x == null) {
 888             x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
 889         }
 890         return x;
 891     }
 892 
 893     /**
 894      * The vertical location of this {@code Scene} on the {@code Window}.
 895      */
 896     private ReadOnlyDoubleWrapper y;
 897 
 898     private final void setY(double value) {
 899         yPropertyImpl().set(value);
 900     }
 901 
 902     public final double getY() {
 903         return y == null ? 0.0 : y.get();
 904     }
 905 
 906     public final ReadOnlyDoubleProperty yProperty() {
 907         return yPropertyImpl().getReadOnlyProperty();
 908     }
 909 
 910     private ReadOnlyDoubleWrapper yPropertyImpl() {
 911         if (y == null) {
 912             y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
 913         }
 914         return y;
 915     }
 916 
 917     /**
 918      * The width of this {@code Scene}
 919      */
 920     private ReadOnlyDoubleWrapper width;
 921 
 922     private final void setWidth(double value) {
 923         widthPropertyImpl().set(value);
 924     }
 925 
 926     public final double getWidth() {
 927         return width == null ? 0.0 : width.get();
 928     }
 929 
 930     public final ReadOnlyDoubleProperty widthProperty() {
 931         return widthPropertyImpl().getReadOnlyProperty();
 932     }
 933 
 934     private ReadOnlyDoubleWrapper widthPropertyImpl() {
 935         if (width == null) {
 936             width = new ReadOnlyDoubleWrapper() {
 937 
 938                 @Override
 939                 protected void invalidated() {
 940                     final Parent _root = getRoot();
 941                     //TODO - use a better method to update mirroring
 942                     if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 943                         NodeHelper.transformsChanged(_root);
 944                     }
 945                     if (_root.isResizable()) {
 946                         resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
 947                     }
 948 
 949                     getEffectiveCamera().setViewWidth(get());
 950                 }
 951 
 952                 @Override
 953                 public Object getBean() {
 954                     return Scene.this;
 955                 }
 956 
 957                 @Override
 958                 public String getName() {
 959                     return &quot;width&quot;;
 960                 }
 961             };
 962         }
 963         return width;
 964     }
 965 
 966     /**
 967      * The height of this {@code Scene}
 968      */
 969     private ReadOnlyDoubleWrapper height;
 970 
 971     private final void setHeight(double value) {
 972         heightPropertyImpl().set(value);
 973     }
 974 
 975     public final double getHeight() {
 976         return height == null ? 0.0 : height.get();
 977     }
 978 
 979     public final ReadOnlyDoubleProperty heightProperty() {
 980         return heightPropertyImpl().getReadOnlyProperty();
 981     }
 982 
 983     private ReadOnlyDoubleWrapper heightPropertyImpl() {
 984         if (height == null) {
 985             height = new ReadOnlyDoubleWrapper() {
 986 
 987                 @Override
 988                 protected void invalidated() {
 989                     final Parent _root = getRoot();
 990                     if (_root.isResizable()) {
 991                         resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
 992                     }
 993 
 994                     getEffectiveCamera().setViewHeight(get());
 995                 }
 996 
 997                 @Override
 998                 public Object getBean() {
 999                     return Scene.this;
1000                 }
1001 
1002                 @Override
1003                 public String getName() {
1004                     return &quot;height&quot;;
1005                 }
1006             };
1007         }
1008         return height;
1009     }
1010 
1011     void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
1012         getRoot().resize(newWidth, newHeight);
1013     }
1014 
1015     // Reusable target wrapper (to avoid creating new one for each picking)
1016     private TargetWrapper tmpTargetWrapper = new TargetWrapper();
1017 
1018     /**
1019      * Specifies the type of camera use for rendering this {@code Scene}.
1020      * If {@code camera} is null, a parallel camera is used for rendering.
1021      * It is illegal to set a camera that belongs to other {@code Scene}
1022      * or {@code SubScene}.
1023      * &lt;p&gt;
1024      * Note: this is a conditional feature. See
1025      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
1026      * for more information.
1027      *
1028      * @defaultValue null
1029      */
1030     private ObjectProperty&lt;Camera&gt; camera;
1031 
1032     public final void setCamera(Camera value) {
1033         cameraProperty().set(value);
1034     }
1035 
1036     public final Camera getCamera() {
1037         return camera == null ? null : camera.get();
1038     }
1039 
1040     public final ObjectProperty&lt;Camera&gt; cameraProperty() {
1041         if (camera == null) {
1042             camera = new ObjectPropertyBase&lt;Camera&gt;() {
1043                 Camera oldCamera = null;
1044 
1045                 @Override
1046                 protected void invalidated() {
1047                     Camera _value = get();
1048                     if (_value != null) {
1049                         if (_value instanceof PerspectiveCamera
1050                                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
1051                             String logname = Scene.class.getName();
1052                             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
1053                                     + &quot;ConditionalFeature.SCENE3D&quot;);
1054                         }
1055                         // Illegal value if it belongs to other scene or any subscene
1056                         if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
1057                                 || _value.getSubScene() != null) {
1058                             throw new IllegalArgumentException(_value
1059                                     + &quot;is already part of other scene or subscene&quot;);
1060                         }
1061                         // throws exception if the camera already has a different owner
1062                         _value.setOwnerScene(Scene.this);
1063                         _value.setViewWidth(getWidth());
1064                         _value.setViewHeight(getHeight());
1065                     }
1066                     if (oldCamera != null &amp;&amp; oldCamera != _value) {
1067                         oldCamera.setOwnerScene(null);
1068                     }
1069                     oldCamera = _value;
1070                 }
1071 
1072                 @Override
1073                 public Object getBean() {
1074                     return Scene.this;
1075                 }
1076 
1077                 @Override
1078                 public String getName() {
1079                     return &quot;camera&quot;;
1080                 }
1081             };
1082         }
1083         return camera;
1084     }
1085 
1086     Camera getEffectiveCamera() {
1087         final Camera cam = getCamera();
1088         if (cam == null
1089                 || (cam instanceof PerspectiveCamera
1090                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
1091             if (defaultCamera == null) {
1092                 defaultCamera = new ParallelCamera();
1093                 defaultCamera.setOwnerScene(this);
1094                 defaultCamera.setViewWidth(getWidth());
1095                 defaultCamera.setViewHeight(getHeight());
1096             }
1097             return defaultCamera;
1098         }
1099 
1100         return cam;
1101     }
1102 
1103     // Used by the camera
1104     void markCameraDirty() {
1105         markDirty(DirtyBits.CAMERA_DIRTY);
1106         setNeedsRepaint();
1107     }
1108 
1109     void markCursorDirty() {
1110         markDirty(DirtyBits.CURSOR_DIRTY);
1111     }
1112 
1113     /**
1114      * Defines the background fill of this {@code Scene}. Both a {@code null}
1115      * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
1116      * with transparency are supported. The default fill of the Scene is
1117      * {@link Color#WHITE}, but it is more commonly the case that the initial
1118      * color shown to users is the background fill of the
1119      * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
1120      * stretched to take up all available space in the {@code Scene}. The
1121      * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
1122      * the default user agent stylesheets that ship with JavaFX (presently
1123      * Caspian and Modena) apply styling on to this root style class. In the
1124      * case of Caspian this does not impact the background fill color of the
1125      * root node, but in the case of Modena the default fill is set to be a
1126      * light gray color.
1127      *
1128      * @defaultValue WHITE
1129      */
1130     private ObjectProperty&lt;Paint&gt; fill;
1131 
1132     public final void setFill(Paint value) {
1133         fillProperty().set(value);
1134     }
1135 
1136     public final Paint getFill() {
1137         return fill == null ? Color.WHITE : fill.get();
1138     }
1139 
1140     public final ObjectProperty&lt;Paint&gt; fillProperty() {
1141         if (fill == null) {
1142             fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {
1143 
1144                 @Override
1145                 protected void invalidated() {
1146                     markDirty(DirtyBits.FILL_DIRTY);
1147                 }
1148 
1149                 @Override
1150                 public Object getBean() {
1151                     return Scene.this;
1152                 }
1153 
1154                 @Override
1155                 public String getName() {
1156                     return &quot;fill&quot;;
1157                 }
1158             };
1159         }
1160         return fill;
1161     }
1162 
1163     /**
1164      * Defines the root {@code Node} of the scene graph.
1165      * If a {@code Group} is used as the root, the
1166      * contents of the scene graph will be clipped by the scene&#39;s width and height and
1167      * changes to the scene&#39;s size (if user resizes the stage) will not alter the
1168      * layout of the scene graph.    If a resizable node (layout {@code Region} or
1169      * {@code Control}) is set as the root, then the root&#39;s size will track the
1170      * scene&#39;s size, causing the contents to be relayed out as necessary.
1171      *
1172      * Scene doesn&#39;t accept null root.
1173      *
1174      */
1175     private ObjectProperty&lt;Parent&gt; root;
1176 
1177     public final void setRoot(Parent value) {
1178         rootProperty().set(value);
1179     }
1180 
1181     public final Parent getRoot() {
1182         return root == null ? null : root.get();
1183     }
1184 
1185     Parent oldRoot;
1186     public final ObjectProperty&lt;Parent&gt; rootProperty() {
1187         if (root == null) {
1188             root = new ObjectPropertyBase&lt;Parent&gt;() {
1189 
1190                 private void forceUnbind() {
1191                     System.err.println(&quot;Unbinding illegal root.&quot;);
1192                     unbind();
1193                 }
1194 
1195                 @Override
1196                 protected void invalidated() {
1197                     Parent _value = get();
1198 
1199                     if (_value == null) {
1200                         if (isBound()) forceUnbind();
1201                         throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);
1202                     }
1203 
1204                     if (_value.getParent() != null) {
1205                         if (isBound()) forceUnbind();
1206                         throw new IllegalArgumentException(_value +
1207                                 &quot;is already inside a scene-graph and cannot be set as root&quot;);
1208                     }
1209                     if (_value.getClipParent() != null) {
1210                         if (isBound()) forceUnbind();
1211                         throw new IllegalArgumentException(_value +
1212                                 &quot;is set as a clip on another node, so cannot be set as root&quot;);
1213                     }
1214                     if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
1215                         if (isBound()) forceUnbind();
1216                         throw new IllegalArgumentException(_value +
1217                                 &quot;is already set as root of another scene&quot;);
1218                     }
1219 
1220                     if (oldRoot != null) {
1221                         oldRoot.setScenes(null, null);
1222                     }
1223                     oldRoot = _value;
1224                     _value.getStyleClass().add(0, &quot;root&quot;);
1225                     _value.setScenes(Scene.this, null);
1226                     markDirty(DirtyBits.ROOT_DIRTY);
1227                     _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
1228                     _value.requestLayout();
1229                 }
1230 
1231                 @Override
1232                 public Object getBean() {
1233                     return Scene.this;
1234                 }
1235 
1236                 @Override
1237                 public String getName() {
1238                     return &quot;root&quot;;
1239                 }
1240             };
1241         }
1242         return root;
1243     }
1244 
1245     void setNeedsRepaint() {
1246         if (this.peer != null) {
1247             peer.entireSceneNeedsRepaint();
1248         }
1249     }
1250 
1251     // Process CSS and layout and sync the scene prior to the snapshot
1252     // operation of the given node for this scene (currently the node
1253     // is unused but could possibly be used in the future to optimize this)
1254     void doCSSLayoutSyncForSnapshot(Node node) {
1255         if (!sizeInitialized) {
1256             preferredSize();
1257         } else {
1258             doCSSPass();
1259         }
1260 
1261         // we do not need pulse in the snapshot code
1262         // because this scene can be stage-less
1263         doLayoutPass();
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
1284             double x, double y, double w, double h,
1285             Node root, BaseTransform transform, boolean depthBuffer,
1286             Paint fill, Camera camera, WritableImage wimg) {
1287 
1288         Toolkit tk = Toolkit.getToolkit();
1289         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();
1290 
1291         int xMin = (int)Math.floor(x);
1292         int yMin = (int)Math.floor(y);
1293         int xMax = (int)Math.ceil(x + w);
1294         int yMax = (int)Math.ceil(y + h);
1295         int width = Math.max(xMax - xMin, 1);
1296         int height = Math.max(yMax - yMin, 1);
1297         if (wimg == null) {
1298             wimg = new WritableImage(width, height);
1299         } else {
1300             width = (int)wimg.getWidth();
1301             height = (int)wimg.getHeight();
1302         }
1303 
1304         setAllowPGAccess(true);
1305         context.x = xMin;
1306         context.y = yMin;
1307         context.width = width;
1308         context.height = height;
1309         context.transform = transform;
1310         context.depthBuffer = depthBuffer;
1311         context.root = root.getPeer();
1312         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1313         double cameraViewWidth = 1.0;
1314         double cameraViewHeight = 1.0;
1315         if (camera != null) {
1316             // temporarily adjust camera viewport to the snapshot size
1317             cameraViewWidth = camera.getViewWidth();
1318             cameraViewHeight = camera.getViewHeight();
1319             camera.setViewWidth(width);
1320             camera.setViewHeight(height);
1321             NodeHelper.updatePeer(camera);
1322             context.camera = camera.getPeer();
1323         } else {
1324             context.camera = null;
1325         }
1326 
1327         // Grab the lights from the scene
1328         context.lights = null;
1329         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1330             context.lights = new NGLightBase[scene.lights.size()];
1331             for (int i = 0; i &lt; scene.lights.size(); i++) {
1332                 context.lights[i] = scene.lights.get(i).getPeer();
1333             }
1334         }
1335 
1336         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
1337         context.platformImage = accessor.getTkImageLoader(wimg);
1338         setAllowPGAccess(false);
1339         Object tkImage = tk.renderToImage(context);
1340         accessor.loadTkImage(wimg, tkImage);
1341 
1342         if (camera != null) {
1343             setAllowPGAccess(true);
1344             camera.setViewWidth(cameraViewWidth);
1345             camera.setViewHeight(cameraViewHeight);
1346             NodeHelper.updatePeer(camera);
1347             setAllowPGAccess(false);
1348         }
1349 
1350         // if this scene belongs to some stage
1351         // we need to mark the entire scene as dirty
1352         // because dirty logic is buggy
1353         if (scene != null &amp;&amp; scene.peer != null) {
1354             scene.setNeedsRepaint();
1355         }
1356 
1357         return wimg;
1358     }
1359 
1360     /**
1361      * Implementation method for snapshot
1362      */
1363     private WritableImage doSnapshot(WritableImage img) {
1364         // TODO: no need to do CSS, layout or sync in the deferred case,
1365         // if this scene is attached to a visible stage
1366         doCSSLayoutSyncForSnapshot(getRoot());
1367 
1368         double w = getWidth();
1369         double h = getHeight();
1370         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1371 
1372         return doSnapshot(this, 0, 0, w, h,
1373                 getRoot(), transform, isDepthBufferInternal(),
1374                 getFill(), getEffectiveCamera(), img);
1375     }
1376 
1377     // Pulse listener used to run all deferred (async) snapshot requests
1378     private static TKPulseListener snapshotPulseListener = null;
1379 
1380     private static List&lt;Runnable&gt; snapshotRunnableListA;
1381     private static List&lt;Runnable&gt; snapshotRunnableListB;
1382     private static List&lt;Runnable&gt; snapshotRunnableList;
1383 
1384     static void addSnapshotRunnable(final Runnable runnable) {
1385         Toolkit.getToolkit().checkFxUserThread();
1386 
1387         if (snapshotPulseListener == null) {
1388             snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
1389             snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
1390             snapshotRunnableList = snapshotRunnableListA;
1391 
1392             snapshotPulseListener = () -&gt; {
1393                 if (snapshotRunnableList.size() &gt; 0) {
1394                     List&lt;Runnable&gt; runnables = snapshotRunnableList;
1395                     if (snapshotRunnableList == snapshotRunnableListA) {
1396                         snapshotRunnableList = snapshotRunnableListB;
1397                     } else {
1398                         snapshotRunnableList = snapshotRunnableListA;
1399                     }
1400                     for (Runnable r : runnables) {
1401                         try {
1402                             r.run();
1403                         } catch (Throwable th) {
1404                             System.err.println(&quot;Exception in snapshot runnable&quot;);
1405                             th.printStackTrace(System.err);
1406                         }
1407                     }
1408                     runnables.clear();
1409                 }
1410             };
1411 
1412             // Add listener that will be called after all of the scenes have
1413             // had layout and CSS processing, and have been synced
1414             Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
1415         }
1416 
1417         final AccessControlContext acc = AccessController.getContext();
1418         snapshotRunnableList.add(() -&gt; {
1419             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1420                 runnable.run();
1421                 return null;
1422             }, acc);
1423         });
1424         Toolkit.getToolkit().requestNextPulse();
1425     }
1426 
1427     /**
1428      * Takes a snapshot of this scene and returns the rendered image when
1429      * it is ready.
1430      * CSS and layout processing will be done for the scene prior to
1431      * rendering it.
1432      * The entire destination image is cleared using the fill {@code Paint}
1433      * of this scene. The nodes in the scene are then rendered to the image.
1434      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1435      * If the image is smaller than the size of the scene, then the rendering
1436      * will be clipped by the image.
1437      *
1438      * &lt;p&gt;
1439      * When taking a snapshot of a scene that is being animated, either
1440      * explicitly by the application or implicitly (such as chart animation),
1441      * the snapshot will be rendered based on the state of the scene graph at
1442      * the moment the snapshot is taken and will not reflect any subsequent
1443      * animation changes.
1444      * &lt;/p&gt;
1445      *
1446      * @param image the writable image that will be used to hold the rendered scene.
1447      * It may be null in which case a new WritableImage will be constructed.
1448      * If the image is non-null, the scene will be rendered into the
1449      * existing image.
1450      * In this case, the width and height of the image determine the area
1451      * that is rendered instead of the width and height of the scene.
1452      *
1453      * @throws IllegalStateException if this method is called on a thread
1454      *     other than the JavaFX Application Thread.
1455      *
1456      * @return the rendered image
1457      * @since JavaFX 2.2
1458      */
1459     public WritableImage snapshot(WritableImage image) {
1460         Toolkit.getToolkit().checkFxUserThread();
1461 
1462         return doSnapshot(image);
1463     }
1464 
1465     /**
1466      * Takes a snapshot of this scene at the next frame and calls the
1467      * specified callback method when the image is ready.
1468      * CSS and layout processing will be done for the scene prior to
1469      * rendering it.
1470      * The entire destination image is cleared using the fill {@code Paint}
1471      * of this scene. The nodes in the scene are then rendered to the image.
1472      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1473      * If the image is smaller than the size of the scene, then the rendering
1474      * will be clipped by the image.
1475      *
1476      * &lt;p&gt;
1477      * This is an asynchronous call, which means that other
1478      * events or animation might be processed before the scene is rendered.
1479      * If any such events modify a node in the scene that modification will
1480      * be reflected in the rendered image (as it will also be reflected in
1481      * the frame rendered to the Stage).
1482      * &lt;/p&gt;
1483      *
1484      * &lt;p&gt;
1485      * When taking a snapshot of a scene that is being animated, either
1486      * explicitly by the application or implicitly (such as chart animation),
1487      * the snapshot will be rendered based on the state of the scene graph at
1488      * the moment the snapshot is taken and will not reflect any subsequent
1489      * animation changes.
1490      * &lt;/p&gt;
1491      *
1492      * @param callback a class whose call method will be called when the image
1493      * is ready. The SnapshotResult that is passed into the call method of
1494      * the callback will contain the rendered image and the source scene
1495      * that was rendered. The callback parameter must not be null.
1496      *
1497      * @param image the writable image that will be used to hold the rendered scene.
1498      * It may be null in which case a new WritableImage will be constructed.
1499      * If the image is non-null, the scene will be rendered into the
1500      * existing image.
1501      * In this case, the width and height of the image determine the area
1502      * that is rendered instead of the width and height of the scene.
1503      *
1504      * @throws IllegalStateException if this method is called on a thread
1505      *     other than the JavaFX Application Thread.
1506      *
1507      * @throws NullPointerException if the callback parameter is null.
1508      * @since JavaFX 2.2
1509      */
1510     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
1511         Toolkit.getToolkit().checkFxUserThread();
1512         if (callback == null) {
1513             throw new NullPointerException(&quot;The callback must not be null&quot;);
1514         }
1515 
1516         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
1517         final WritableImage theImage = image;
1518 
1519         // Create a deferred runnable that will be run from a pulse listener
1520         // that is called after all of the scenes have been synced but before
1521         // any of them have been rendered.
1522         final Runnable snapshotRunnable = () -&gt; {
1523             WritableImage img = doSnapshot(theImage);
1524 //                System.err.println(&quot;Calling snapshot callback&quot;);
1525             SnapshotResult result = new SnapshotResult(img, Scene.this, null);
1526             try {
1527                 Void v = theCallback.call(result);
1528             } catch (Throwable th) {
1529                 System.err.println(&quot;Exception in snapshot callback&quot;);
1530                 th.printStackTrace(System.err);
1531             }
1532         };
1533 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
1534         addSnapshotRunnable(snapshotRunnable);
1535     }
1536 
1537     /**
1538      * Defines the mouse cursor for this {@code Scene}.
1539      */
1540     private ObjectProperty&lt;Cursor&gt; cursor;
1541 
1542     public final void setCursor(Cursor value) {
1543         cursorProperty().set(value);
1544     }
1545 
1546     public final Cursor getCursor() {
1547         return cursor == null ? null : cursor.get();
1548     }
1549 
1550     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
1551         if (cursor == null) {
1552             cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
1553                          @Override
1554                          protected void invalidated() {
1555                              markCursorDirty();
1556                          }
1557 
1558                          @Override
1559                          public Object getBean() {
1560                              return Scene.this;
1561                          }
1562 
1563                          @Override
1564                          public String getName() {
1565                              return &quot;cursor&quot;;
1566                          }
1567                      };
1568         }
1569         return cursor;
1570     }
1571 
1572     /**
1573      * Looks for any node within the scene graph based on the specified CSS selector.
1574      * If more than one node matches the specified selector, this function
1575      * returns the first of them.
1576      * If no nodes are found with this id, then null is returned.
1577      *
1578      * @param selector The css selector to look up
1579      * @return the {@code Node} in the scene which matches the CSS {@code selector},
1580      * or {@code null} if none is found.
1581      */
1582      public Node lookup(String selector) {
1583          return getRoot().lookup(selector);
1584      }
1585     /**
1586      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1587      * contents. For additional information about using CSS with the
1588      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1589      * Guide&lt;/a&gt;.
1590      */
1591     private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
1592         @Override
1593         protected void onChanged(Change&lt;String&gt; c) {
1594             StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
1595             // RT-9784 - if stylesheet is removed, reset styled properties to
1596             // their initial value.
1597             c.reset();
1598             while(c.next()) {
1599                 if (c.wasRemoved() == false) {
1600                     continue;
1601                 }
1602                 break; // no point in resetting more than once...
1603             }
1604             getRoot().reapplyCSS();
1605         }
1606     };
1607 
1608     /**
1609      * Gets an observable list of string URLs linking to the stylesheets to use
1610      * with this scene&#39;s contents.
1611      * &lt;p&gt;
1612      * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1613      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1614      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1615      * the root of the application&#39;s classpath.
1616      * &lt;/p&gt;
1617      * &lt;pre&gt;&lt;code&gt;
1618      *
1619      * package com.example.javafx.app;
1620      *
1621      * import javafx.application.Application;
1622      * import javafx.scene.Group;
1623      * import javafx.scene.Scene;
1624      * import javafx.stage.Stage;
1625      *
1626      * public class MyApp extends Application {
1627      *
1628      *     {@literal @}Override public void start(Stage stage) {
1629      *         Scene scene = new Scene(new Group());
1630      *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
1631      *         stage.setScene(scene);
1632      *         stage.show();
1633      *     }
1634      *
1635      *     public static void main(String[] args) {
1636      *         launch(args);
1637      *     }
1638      * }
1639      * &lt;/code&gt;&lt;/pre&gt;
1640      * For additional information about using CSS with the scene graph,
1641      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1642      *
1643      * @return the list of stylesheets to use with this scene
1644      */
1645     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1646 
1647     private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
1648 
1649     /**
1650      * @return the userAgentStylesheet property.
1651      * @see #getUserAgentStylesheet()
1652      * @see #setUserAgentStylesheet(String)
1653      * @since  JavaFX 8u20
1654      */
1655     public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
1656         if (userAgentStylesheet == null) {
1657             userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
1658                 @Override protected void invalidated() {
1659                     StyleManager.getInstance().forget(Scene.this);
1660                     getRoot().reapplyCSS();
1661                 }
1662             };
1663         }
1664         return userAgentStylesheet;
1665     }
1666 
1667     /**
1668      * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
1669      * the platform-default user-agent stylesheet will be used.
1670      * &lt;p&gt;
1671      * For additional information about using CSS with the scene graph,
1672      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1673      * &lt;/p&gt;
1674      * @return The URL of the user-agent stylesheet that will be used by this Scene,
1675      * or null if has not been set.
1676      * @since  JavaFX 8u20
1677      */
1678     public final String getUserAgentStylesheet() {
1679         return userAgentStylesheet == null ? null : userAgentStylesheet.get();
1680     }
1681 
1682     /**
1683      * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
1684      * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
1685      * the platform-default user-agent stylesheet will be used.
1686      * &lt;p&gt;
1687      * For additional information about using CSS with the scene graph,
1688      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1689      * &lt;/p&gt;
1690      * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1691      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1692      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1693      * the root of the application&#39;s classpath.
1694      * @since  JavaFX 8u20
1695      */
1696     public final void setUserAgentStylesheet(String url) {
1697         userAgentStylesheetProperty().set(url);
1698     }
1699 
1700     /**
1701      * Retrieves the depth buffer attribute for this scene.
1702      * @return the depth buffer attribute.
1703      */
1704     public final boolean isDepthBuffer() {
1705         return depthBuffer;
1706     }
1707 
1708     boolean isDepthBufferInternal() {
1709         if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
1710             return false;
1711         }
1712         return depthBuffer;
1713     }
1714 
1715     private void init(double width, double height) {
1716         if (width &gt;= 0) {
1717             widthSetByUser = width;
1718             setWidth((float)width);
1719         }
1720         if (height &gt;= 0) {
1721             heightSetByUser = height;
1722             setHeight((float)height);
1723         }
1724         sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
1725     }
1726 
1727     private void init() {
1728         if (PerformanceTracker.isLoggingEnabled()) {
1729             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
1730         }
1731         mouseHandler = new MouseHandler();
1732         clickGenerator = new ClickGenerator();
1733 
1734         if (PerformanceTracker.isLoggingEnabled()) {
1735             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
1736         }
1737     }
1738 
1739     void preferredSize() {
1740         final Parent root = getRoot();
1741 
1742         // one or the other isn&#39;t initialized, need to perform layout in
1743         // order to ensure we can properly measure the preferred size of the
1744         // scene
1745         doCSSPass();
1746 
1747         resizeRootToPreferredSize(root);
1748         doLayoutPass();
1749 
1750         if (widthSetByUser &lt; 0) {
1751             setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
1752                             root.getBoundsInParent().getMaxX());
1753         } else {
1754             setWidth(widthSetByUser);
1755         }
1756 
1757         if (heightSetByUser &lt; 0) {
1758             setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
1759                             root.getBoundsInParent().getMaxY());
1760         } else {
1761             setHeight(heightSetByUser);
1762         }
1763 
1764         sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);
1765 
1766         PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
1767     }
1768 
1769     final void resizeRootToPreferredSize(Parent root) {
1770         final double preferredWidth;
1771         final double preferredHeight;
1772 
1773         final Orientation contentBias = root.getContentBias();
1774         if (contentBias == null) {
1775             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1776             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1777         } else if (contentBias == Orientation.HORIZONTAL) {
1778             // height depends on width
1779             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1780             preferredHeight = getPreferredHeight(root, heightSetByUser,
1781                                                        preferredWidth);
1782         } else /* if (contentBias == Orientation.VERTICAL) */ {
1783             // width depends on height
1784             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1785             preferredWidth = getPreferredWidth(root, widthSetByUser,
1786                                                      preferredHeight);
1787         }
1788 
1789         root.resize(preferredWidth, preferredHeight);
1790     }
1791 
1792     private static double getPreferredWidth(Parent root,
1793                                             double forcedWidth,
1794                                             double height) {
1795         if (forcedWidth &gt;= 0) {
1796             return forcedWidth;
1797         }
1798         final double normalizedHeight = (height &gt;= 0) ? height : -1;
1799         return root.boundedSize(root.prefWidth(normalizedHeight),
1800                                 root.minWidth(normalizedHeight),
1801                                 root.maxWidth(normalizedHeight));
1802     }
1803 
1804     private static double getPreferredHeight(Parent root,
1805                                              double forcedHeight,
1806                                              double width) {
1807         if (forcedHeight &gt;= 0) {
1808             return forcedHeight;
1809         }
1810         final double normalizedWidth = (width &gt;= 0) ? width : -1;
1811         return root.boundedSize(root.prefHeight(normalizedWidth),
1812                                 root.minHeight(normalizedWidth),
1813                                 root.maxHeight(normalizedWidth));
1814     }
1815 
1816     private PerformanceTracker tracker;
1817     private static final Object trackerMonitor = new Object();
1818 
1819     // mouse events handling
1820     private MouseHandler mouseHandler;
1821     private ClickGenerator clickGenerator;
1822 
1823     // gesture events handling
1824     private Point2D cursorScreenPos;
1825     private Point2D cursorScenePos;
1826 
1827     private static class TouchGesture {
1828         WeakReference&lt;EventTarget&gt; target;
1829         Point2D sceneCoords;
1830         Point2D screenCoords;
1831         boolean finished;
1832     }
1833 
1834     private final TouchGesture scrollGesture = new TouchGesture();
1835     private final TouchGesture zoomGesture = new TouchGesture();
1836     private final TouchGesture rotateGesture = new TouchGesture();
1837     private final TouchGesture swipeGesture = new TouchGesture();
1838 
1839     // touch events handling
1840     private TouchMap touchMap = new TouchMap();
1841     private TouchEvent nextTouchEvent = null;
1842     private TouchPoint[] touchPoints = null;
1843     private int touchEventSetId = 0;
1844     private int touchPointIndex = 0;
1845     private Map&lt;Integer, EventTarget&gt; touchTargets =
1846             new HashMap&lt;Integer, EventTarget&gt;();
1847 
1848     void processMouseEvent(MouseEvent e) {
1849         mouseHandler.process(e, false);
1850     }
1851 
1852     private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
1853         EventTarget eventTarget = null;
1854         Scene.inMousePick = true;
1855         if (isKeyboardTrigger) {
1856             Node sceneFocusOwner = getFocusOwner();
1857 
1858             // for keyboard triggers set coordinates inside focus owner
1859             final double xOffset = xAbs - x2;
1860             final double yOffset = yAbs - y2;
1861             if (sceneFocusOwner != null) {
1862                 final Bounds bounds = sceneFocusOwner.localToScene(
1863                         sceneFocusOwner.getBoundsInLocal());
1864                 x2 = bounds.getMinX() + bounds.getWidth() / 4;
1865                 y2 = bounds.getMinY() + bounds.getHeight() / 2;
1866                 eventTarget = sceneFocusOwner;
1867             } else {
1868                 x2 = Scene.this.getWidth() / 4;
1869                 y2 = Scene.this.getWidth() / 2;
1870                 eventTarget = Scene.this;
1871             }
1872 
1873             xAbs = x2 + xOffset;
1874             yAbs = y2 + yOffset;
1875         }
1876 
1877         final PickResult res = pick(x2, y2);
1878 
1879         if (!isKeyboardTrigger) {
1880             eventTarget = res.getIntersectedNode();
1881             if (eventTarget == null) {
1882                 eventTarget = this;
1883             }
1884         }
1885 
1886         if (eventTarget != null) {
1887             ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
1888                     x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
1889             Event.fireEvent(eventTarget, context);
1890         }
1891         Scene.inMousePick = false;
1892     }
1893 
1894     private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
1895         EventTarget pickedTarget = null;
1896 
1897         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1898                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1899                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1900             gesture.target = null;
1901             gesture.finished = false;
1902         }
1903 
1904         if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
1905             pickedTarget = gesture.target.get();
1906         } else {
1907             pickedTarget = e.getPickResult().getIntersectedNode();
1908             if (pickedTarget == null) {
1909                 pickedTarget = this;
1910             }
1911         }
1912 
1913         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1914                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1915                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1916             gesture.target = new WeakReference&lt;&gt;(pickedTarget);
1917         }
1918         if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
1919                 e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
1920                 e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
1921                 !e.isInertia()) {
1922             gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
1923             gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
1924         }
1925 
1926         if (pickedTarget != null) {
1927             Event.fireEvent(pickedTarget, e);
1928         }
1929 
1930         if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
1931                 e.getEventType() == RotateEvent.ROTATION_FINISHED ||
1932                 e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
1933             gesture.finished = true;
1934         }
1935     }
1936 
1937     private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
1938         inMousePick = true;
1939         touchEventSetId++;
1940 
1941         List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);
1942 
1943         // fire all the events
1944         for (TouchPoint tp : touchPoints) {
1945             if (tp.getTarget() != null) {
1946                 EventType&lt;TouchEvent&gt; type = null;
1947                 switch (tp.getState()) {
1948                     case MOVED:
1949                         type = TouchEvent.TOUCH_MOVED;
1950                         break;
1951                     case PRESSED:
1952                         type = TouchEvent.TOUCH_PRESSED;
1953                         break;
1954                     case RELEASED:
1955                         type = TouchEvent.TOUCH_RELEASED;
1956                         break;
1957                     case STATIONARY:
1958                         type = TouchEvent.TOUCH_STATIONARY;
1959                         break;
1960                 }
1961 
1962                 for (TouchPoint t : touchPoints) {
1963                     TouchPointHelper.reset(t);
1964                 }
1965 
1966                 TouchEvent te = new TouchEvent(type, tp, touchList,
1967                         touchEventSetId, e.isShiftDown(), e.isControlDown(),
1968                         e.isAltDown(), e.isMetaDown());
1969 
1970                 Event.fireEvent(tp.getTarget(), te);
1971             }
1972         }
1973 
1974         // process grabbing
1975         for (TouchPoint tp : touchPoints) {
1976             EventTarget grabbed = tp.getGrabbed();
1977             if (grabbed != null) {
1978                 touchTargets.put(tp.getId(), grabbed);
1979             };
1980 
1981             if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
1982                 touchTargets.remove(tp.getId());
1983             }
1984         }
1985 
1986         inMousePick = false;
1987     }
1988 
1989     /**
1990      * Note: The only user of this method is in unit test: PickAndContainTest.
1991      */
1992     Node test_pick(double x, double y) {
1993         inMousePick = true;
1994         PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
1995                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
1996         inMousePick = false;
1997         if (result != null) {
1998             return result.getIntersectedNode();
1999         }
2000         return null;
2001     }
2002 
2003     private PickResult pick(final double x, final double y) {
2004         pick(tmpTargetWrapper, x, y);
2005         return tmpTargetWrapper.getResult();
2006     }
2007 
2008     private boolean isInScene(double x, double y) {
2009         if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
2010             return false;
2011         }
2012 
2013         Window w = getWindow();
2014         if (w instanceof Stage
2015                 &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
2016                 &amp;&amp; getFill() == null) {
2017             return false;
2018         }
2019 
2020         return true;
2021     }
2022 
2023     private void pick(TargetWrapper target, final double x, final double y) {
2024         final PickRay pickRay = getEffectiveCamera().computePickRay(
2025                 x, y, null);
2026 
2027         final double mag = pickRay.getDirectionNoClone().length();
2028         pickRay.getDirectionNoClone().normalize();
2029         final PickResult res = mouseHandler.pickNode(pickRay);
2030         if (res != null) {
2031             target.setNodeResult(res);
2032         } else {
2033             //TODO: is this the intersection with projection plane?
2034             Vec3d o = pickRay.getOriginNoClone();
2035             Vec3d d = pickRay.getDirectionNoClone();
2036             target.setSceneResult(new PickResult(
2037                     null, new Point3D(
2038                     o.x + mag * d.x,
2039                     o.y + mag * d.y,
2040                     o.z + mag * d.z),
2041                     mag),
2042                     isInScene(x, y) ? this : null);
2043         }
2044     }
2045 
2046     /***************************************************************************
2047      *                                                                         *
2048      * Key Events and Focus Traversal                                          *
2049      *                                                                         *
2050      **************************************************************************/
2051 
2052     /*
2053      * We cannot initialize keyHandler in init because some of the triggers
2054      * access it before the init block.
2055      * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
2056      * does not compile.
2057      */
2058     private KeyHandler keyHandler = null;
2059     private KeyHandler getKeyHandler() {
2060         if (keyHandler == null) {
2061             keyHandler = new KeyHandler();
2062         }
2063         return keyHandler;
2064     }
2065     /**
2066      * Set to true if something has happened to the focused node that makes
2067      * it no longer eligible to have the focus.
2068      *
2069      */
2070     private boolean focusDirty = true;
2071 
2072     final void setFocusDirty(boolean value) {
2073         if (!focusDirty) {
2074             Toolkit.getToolkit().requestNextPulse();
2075         }
2076         focusDirty = value;
2077     }
2078 
2079     final boolean isFocusDirty() {
2080         return focusDirty;
2081     }
2082 
2083     private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);
2084 
2085     /**
2086      * Traverses focus from the given node in the given direction.
2087      */
2088     boolean traverse(Node node, Direction dir) {
2089         if (node.getSubScene() != null) {
2090             return node.getSubScene().traverse(node, dir);
2091         }
2092         return traversalEngine.trav(node, dir) != null;
2093     }
2094 
2095     /**
2096      * Moves the focus to a reasonable initial location. Called when a scene&#39;s
2097      * focus is dirty and there&#39;s no current owner, or if the owner has been
2098      * removed from the scene.
2099      */
2100     private void focusInitial() {
2101         traversalEngine.traverseToFirst();
2102     }
2103 
2104     /**
2105      * Moves the focus to a reasonble location &quot;near&quot; the given node.
2106      * Called when the focused node is no longer eligible to have
2107      * the focus because it has become invisible or disabled. This
2108      * function assumes that it is still a member of the same scene.
2109      */
2110     private void focusIneligible(Node node) {
2111         traverse(node, Direction.NEXT);
2112     }
2113 
2114     public void processKeyEvent(KeyEvent e) {
2115         if (dndGesture != null) {
2116             if (!dndGesture.processKey(e)) {
2117                 dndGesture = null;
2118             }
2119         }
2120 
2121         getKeyHandler().process(e);
2122     }
2123 
2124     void requestFocus(Node node) {
2125         getKeyHandler().requestFocus(node);
2126     }
2127 
2128     private Node oldFocusOwner;
2129 
2130     /**
2131       * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
2132       * variable might be false if this scene has no window, or if the
2133       * window is inactive (window.focused == false).
2134       * @since JavaFX 2.2
2135       */
2136     private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {
2137 
2138         @Override
2139         protected void invalidated() {
2140             if (oldFocusOwner != null) {
2141                 ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
2142             }
2143             Node value = get();
2144             if (value != null) {
2145                 ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
2146                 if (value != oldFocusOwner) {
2147                     value.getScene().enableInputMethodEvents(
2148                             value.getInputMethodRequests() != null
2149                             &amp;&amp; value.getOnInputMethodTextChanged() != null);
2150                 }
2151             }
2152             // for the rest of the method we need to update the oldFocusOwner
2153             // and use a local copy of it because the user handlers can cause
2154             // recurrent calls of requestFocus
2155             Node localOldOwner = oldFocusOwner;
2156             oldFocusOwner = value;
2157             if (localOldOwner != null) {
2158                 ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
2159             }
2160             if (value != null) {
2161                 ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
2162             }
2163             PlatformLogger logger = Logging.getFocusLogger();
2164             if (logger.isLoggable(Level.FINE)) {
2165                 if (value == get()) {
2166                     logger.fine(&quot;Changed focus from &quot;
2167                             + localOldOwner + &quot; to &quot; + value);
2168                 } else {
2169                     logger.fine(&quot;Changing focus from &quot;
2170                             + localOldOwner + &quot; to &quot; + value
2171                             + &quot; canceled by nested requestFocus&quot;);
2172                 }
2173             }
2174             if (accessible != null) {
2175                 accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
2176             }
2177         }
2178     };
2179 
2180     public final Node getFocusOwner() {
2181         return focusOwner.get();
2182     }
2183 
2184     public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
2185         return focusOwner.getReadOnlyProperty();
2186     }
2187 
2188     // For testing.
2189     void focusCleanup() {
2190         scenePulseListener.focusCleanup();
2191     }
2192 
2193     private void processInputMethodEvent(InputMethodEvent e) {
2194         Node node = getFocusOwner();
2195         if (node != null) {
2196             node.fireEvent(e);
2197         }
2198     }
2199 
2200     public void enableInputMethodEvents(boolean enable) {
2201        if (peer != null) {
2202            peer.enableInputMethodEvents(enable);
2203        }
2204     }
2205 
2206     /**
2207      * Returns true if this scene is quiescent, i.e. it has no activity
2208      * pending on it such as CSS processing or layout requests.
2209      *
2210      * Intended to be used for tests only
2211      *
2212      * @return boolean indicating whether the scene is quiescent
2213      */
2214     boolean isQuiescent() {
2215         final Parent r = getRoot();
2216         return !isFocusDirty()
2217                &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
2218                 r.layoutFlag == LayoutFlags.CLEAN));
2219     }
2220 
2221     /**
2222      * A listener for pulses, used for testing. If non-null, this is called at
2223      * the very end of ScenePulseListener.pulse().
2224      *
2225      * Intended to be used for tests only
2226      */
2227     Runnable testPulseListener = null;
2228 
2229     /**
2230      * Set the specified dirty bit and mark the peer as dirty
2231      */
2232     private void markDirty(DirtyBits dirtyBit) {
2233         setDirty(dirtyBit);
2234         if (peer != null) {
2235             Toolkit.getToolkit().requestNextPulse();
2236         }
2237     }
2238 
2239     /**
2240      * Set the specified dirty bit
2241      */
2242     private void setDirty(DirtyBits dirtyBit) {
2243         dirtyBits.add(dirtyBit);
2244     }
2245 
2246     /**
2247      * Test the specified dirty bit
2248      */
2249     private boolean isDirty(DirtyBits dirtyBit) {
2250         return dirtyBits.contains(dirtyBit);
2251     }
2252 
2253     /**
2254      * Test whether the dirty bits are empty
2255      */
2256     private boolean isDirtyEmpty() {
2257         return dirtyBits.isEmpty();
2258     }
2259 
2260     /**
2261      * Clear all dirty bits
2262      */
2263     private void clearDirty() {
2264         dirtyBits.clear();
2265     }
2266 
2267     private enum DirtyBits {
2268         FILL_DIRTY,
2269         ROOT_DIRTY,
2270         CAMERA_DIRTY,
2271         LIGHTS_DIRTY,
2272         CURSOR_DIRTY;
2273     }
2274 
2275     private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();
2276 
2277     // @param light must not be null
2278     final void addLight(LightBase light) {
2279         if (!lights.contains(light)) {
2280             lights.add(light);
2281             markDirty(DirtyBits.LIGHTS_DIRTY);
2282         }
2283     }
2284 
2285     final void removeLight(LightBase light) {
2286         if (lights.remove(light)) {
2287             markDirty(DirtyBits.LIGHTS_DIRTY);
2288         }
2289     }
2290 
2291     /**
2292      * PG Light synchronizer.
2293      */
2294     private void syncLights() {
2295         if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
2296             return;
2297         }
2298         inSynchronizer = true;
2299         NGLightBase peerLights[] = peer.getLights();
2300         if (!lights.isEmpty() || (peerLights != null)) {
2301             if (lights.isEmpty()) {
2302                 peer.setLights(null);
2303             } else {
2304                 if (peerLights == null || peerLights.length &lt; lights.size()) {
2305                     peerLights = new NGLightBase[lights.size()];
2306                 }
2307                 int i = 0;
2308                 for (; i &lt; lights.size(); i++) {
2309                     peerLights[i] = lights.get(i).getPeer();
2310                 }
2311                 // Clear the rest of the list
2312                 while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
2313                     peerLights[i++] = null;
2314                 }
2315                 peer.setLights(peerLights);
2316             }
2317         }
2318         inSynchronizer = false;
2319     }
2320 
2321     //INNER CLASSES
2322 
2323     /*******************************************************************************
2324      *                                                                             *
2325      * Scene Pulse Listener                                                        *
2326      *                                                                             *
2327      ******************************************************************************/
2328 
2329     class ScenePulseListener implements TKPulseListener {
2330 
2331         private boolean firstPulse = true;
2332 
2333         /**
2334          * PG synchronizer. Called once per frame from the pulse listener.
2335          * This function calls the synchronizePGNode method on each node in
2336          * the dirty list.
2337          */
2338         private void synchronizeSceneNodes() {
2339             Toolkit.getToolkit().checkFxUserThread();
2340 
2341             Scene.inSynchronizer = true;
2342 
2343             // if dirtyNodes is null then that means this Scene has not yet been
2344             // synchronized, and so we will simply synchronize every node in the
2345             // scene and then create the dirty nodes array list
2346             if (Scene.this.dirtyNodes == null) {
2347                 // must do this recursively
2348                 syncAll(getRoot());
2349                 dirtyNodes = new Node[MIN_DIRTY_CAPACITY];
2350 
2351             } else {
2352                 // This is not the first time this scene has been synchronized,
2353                 // so we will only synchronize those nodes that need it
2354                 for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
2355                     Node node = dirtyNodes[i];
2356                     dirtyNodes[i] = null;
2357                     if (node.getScene() == Scene.this) {
2358                             node.syncPeer();
2359                         }
2360                     }
2361                 dirtyNodesSize = 0;
2362             }
2363 
2364             Scene.inSynchronizer = false;
2365         }
2366 
2367         /**
2368          * Recursive function for synchronizing every node in the scenegraph.
2369          * The return value is the number of nodes in the graph.
2370          */
2371         private int syncAll(Node node) {
2372             node.syncPeer();
2373             int size = 1;
2374             if (node instanceof Parent) {
2375                 Parent p = (Parent) node;
2376                 final int childrenCount = p.getChildren().size();
2377 
2378                 for (int i = 0; i &lt; childrenCount; i++) {
2379                     Node n = p.getChildren().get(i);
2380                     if (n != null) {
2381                         size += syncAll(n);
2382                     }
2383                 }
2384             } else if (node instanceof SubScene) {
2385                 SubScene subScene = (SubScene)node;
2386                 size += syncAll(subScene.getRoot());
2387             }
2388             if (node.getClip() != null) {
2389                 size += syncAll(node.getClip());
2390             }
2391 
2392             return size;
2393         }
2394 
2395         private void synchronizeSceneProperties() {
2396             inSynchronizer = true;
2397             if (isDirty(DirtyBits.ROOT_DIRTY)) {
2398                 peer.setRoot(getRoot().getPeer());
2399             }
2400 
2401             if (isDirty(DirtyBits.FILL_DIRTY)) {
2402                 Toolkit tk = Toolkit.getToolkit();
2403                 peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
2404             }
2405 
2406             // new camera was set on the scene or old camera changed
2407             final Camera cam = getEffectiveCamera();
2408             if (isDirty(DirtyBits.CAMERA_DIRTY)) {
2409                 NodeHelper.updatePeer(cam);
2410                 peer.setCamera((NGCamera) cam.getPeer());
2411             }
2412 
2413             if (isDirty(DirtyBits.CURSOR_DIRTY)) {
2414                 mouseHandler.updateCursor(getCursor());
2415                 mouseHandler.updateCursorFrame();
2416             }
2417 
2418             clearDirty();
2419             inSynchronizer = false;
2420         }
2421 
2422         /**
2423          * The focus is considered dirty if something happened to
2424          * the scene graph that may require the focus to be moved.
2425          * This must handle cases where (a) the focus owner may have
2426          * become ineligible to have the focus, and (b) where the focus
2427          * owner is null and a node may have become traversable and eligible.
2428          */
2429         private void focusCleanup() {
2430             if (Scene.this.isFocusDirty()) {
2431                 final Node oldOwner = Scene.this.getFocusOwner();
2432                 if (oldOwner == null) {
2433                     Scene.this.focusInitial();
2434                 } else if (oldOwner.getScene() != Scene.this) {
2435                     Scene.this.requestFocus(null);
2436                     Scene.this.focusInitial();
2437                 } else if (!oldOwner.isCanReceiveFocus()) {
2438                     Scene.this.requestFocus(null);
2439                     Scene.this.focusIneligible(oldOwner);
2440                 }
2441                 Scene.this.setFocusDirty(false);
2442             }
2443         }
2444 
2445         @Override
2446         public void pulse() {
2447             if (Scene.this.tracker != null) {
2448                 Scene.this.tracker.pulse();
2449             }
2450             if (firstPulse) {
2451                 PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
2452             }
2453 
2454             focusCleanup();
2455 
2456             disposeAccessibles();
2457 
2458             // run any scene pre pulse listeners immediately _before_ css / layout,
2459             // and before scene synchronization
2460             if (preLayoutPulseListeners != null) {
2461                 for (Runnable r : preLayoutPulseListeners) {
2462                     r.run();
2463                 }
2464             }
2465 
2466             if (PULSE_LOGGING_ENABLED) {
2467                 PulseLogger.newPhase(&quot;CSS Pass&quot;);
2468             }
2469             Scene.this.doCSSPass();
2470 
2471             if (PULSE_LOGGING_ENABLED) {
2472                 PulseLogger.newPhase(&quot;Layout Pass&quot;);
2473             }
2474             Scene.this.doLayoutPass();
2475 
2476             // run any scene post pulse listeners immediately _after_ css / layout,
2477             // and before scene synchronization
2478             if (postLayoutPulseListeners != null) {
2479                 for (Runnable r : postLayoutPulseListeners) {
2480                     r.run();
2481                 }
2482             }
2483 
2484             boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
2485             if (dirty) {
2486                 if (PULSE_LOGGING_ENABLED) {
2487                     PulseLogger.newPhase(&quot;Update bounds&quot;);
2488                 }
2489                 getRoot().updateBounds();
2490                 if (peer != null) {
2491                     try {
2492                         if (PULSE_LOGGING_ENABLED) {
2493                             PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
2494                         }
2495                         peer.waitForRenderingToComplete();
2496                         peer.waitForSynchronization();
2497                         // synchronize scene properties
2498                         if (PULSE_LOGGING_ENABLED) {
2499                             PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
2500                         }
2501                         syncLights();
2502                         synchronizeSceneProperties();
2503                         // Run the synchronizer
2504                         synchronizeSceneNodes();
2505                         Scene.this.mouseHandler.pulse();
2506                         // Tell the scene peer that it needs to repaint
2507                         peer.markDirty();
2508                     } finally {
2509                         peer.releaseSynchronization(true);
2510                     }
2511                 } else {
2512                     if (PULSE_LOGGING_ENABLED) {
2513                         PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
2514                     }
2515                     synchronizeSceneNodes();
2516                     Scene.this.mouseHandler.pulse();
2517                 }
2518 
2519                 if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
2520                     NodeHelper.markDirty(Scene.this.getRoot(),
2521                             com.sun.javafx.scene.DirtyBits.NODE_CSS);
2522                 }
2523             }
2524 
2525             // required for image cursor created from animated image
2526             Scene.this.mouseHandler.updateCursorFrame();
2527 
2528             if (firstPulse) {
2529                 if (PerformanceTracker.isLoggingEnabled()) {
2530                     PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
2531                     if (PrismSettings.perfLogFirstPaintFlush) {
2532                         PerformanceTracker.outputLog();
2533                     }
2534                     if (PrismSettings.perfLogFirstPaintExit) {
2535                         System.exit(0);
2536                     }
2537                 }
2538                 firstPulse = false;
2539             }
2540 
2541             if (testPulseListener != null) {
2542                 testPulseListener.run();
2543             }
2544         }
2545     }
2546 
2547     /*******************************************************************************
2548      *                                                                             *
2549      * Scene Peer Listener                                                         *
2550      *                                                                             *
2551      ******************************************************************************/
2552 
2553     class ScenePeerListener implements TKSceneListener {
2554         @Override
2555         public void changedLocation(float x, float y) {
2556             if (x != Scene.this.getX()) {
2557                 Scene.this.setX(x);
2558             }
2559             if (y != Scene.this.getY()) {
2560                 Scene.this.setY(y);
2561             }
2562         }
2563 
2564         @Override
2565         public void changedSize(float w, float h) {
2566             if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
2567             if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
2568         }
2569 
2570         @Override
2571         public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
2572                                MouseButton button, boolean popupTrigger, boolean synthesized,
2573                                boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
2574                                boolean primaryDown, boolean middleDown, boolean secondaryDown,
2575                                boolean backDown, boolean forwardDown)
2576         {
2577             MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
2578                     0, // click count will be adjusted by clickGenerator later anyway
2579                     shiftDown, controlDown, altDown, metaDown,
2580                     primaryDown, middleDown, secondaryDown, backDown, forwardDown,
2581                     synthesized, popupTrigger, false, null);
2582             processMouseEvent(mouseEvent);
2583         }
2584 
2585 
2586         @Override
2587         public void keyEvent(KeyEvent keyEvent)
2588         {
2589             processKeyEvent(keyEvent);
2590         }
2591 
2592         @Override
2593         public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
2594                                      ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
2595                                      int caretPosition)
2596         {
2597             InputMethodEvent inputMethodEvent = new InputMethodEvent(
2598                type, composed, committed, caretPosition);
2599             processInputMethodEvent(inputMethodEvent);
2600         }
2601 
2602         public void menuEvent(double x, double y, double xAbs, double yAbs,
2603                 boolean isKeyboardTrigger) {
2604             Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
2605         }
2606 
2607         @Override
2608         public void scrollEvent(
2609                 EventType&lt;ScrollEvent&gt; eventType,
2610                 double scrollX, double scrollY,
2611                 double totalScrollX, double totalScrollY,
2612                 double xMultiplier, double yMultiplier,
2613                 int touchCount,
2614                 int scrollTextX, int scrollTextY,
2615                 int defaultTextX, int defaultTextY,
2616                 double x, double y, double screenX, double screenY,
2617                 boolean _shiftDown, boolean _controlDown,
2618                 boolean _altDown, boolean _metaDown,
2619                 boolean _direct, boolean _inertia) {
2620 
2621             ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
2622                     ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
2623                     ScrollEvent.HorizontalTextScrollUnits.NONE;
2624 
2625             double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;
2626 
2627             ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
2628                     ScrollEvent.VerticalTextScrollUnits.LINES :
2629                     (scrollTextY &lt; 0 ?
2630                         ScrollEvent.VerticalTextScrollUnits.PAGES :
2631                         ScrollEvent.VerticalTextScrollUnits.NONE);
2632 
2633             double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;
2634 
2635             xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
2636                     ? Math.round(xMultiplier * scrollTextX / defaultTextX)
2637                     : xMultiplier;
2638 
2639             yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
2640                     ? Math.round(yMultiplier * scrollTextY / defaultTextY)
2641                     : yMultiplier;
2642 
2643             if (eventType == ScrollEvent.SCROLL_FINISHED) {
2644                 x = scrollGesture.sceneCoords.getX();
2645                 y = scrollGesture.sceneCoords.getY();
2646                 screenX = scrollGesture.screenCoords.getX();
2647                 screenY = scrollGesture.screenCoords.getY();
2648             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2649                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2650                 if (cursorScenePos == null || cursorScreenPos == null) {
2651                     return;
2652                 }
2653                 x = cursorScenePos.getX();
2654                 y = cursorScenePos.getY();
2655                 screenX = cursorScreenPos.getX();
2656                 screenY = cursorScreenPos.getY();
2657             }
2658 
2659             inMousePick = true;
2660             Scene.this.processGestureEvent(new ScrollEvent(
2661                     eventType,
2662                     x, y, screenX, screenY,
2663                     _shiftDown, _controlDown, _altDown, _metaDown,
2664                     _direct, _inertia,
2665                     scrollX * xMultiplier, scrollY * yMultiplier,
2666                     totalScrollX * xMultiplier, totalScrollY * yMultiplier,
2667                     xMultiplier, yMultiplier,
2668                     xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
2669                     scrollGesture);
2670             inMousePick = false;
2671         }
2672 
2673         @Override
2674         public void zoomEvent(
2675                 EventType&lt;ZoomEvent&gt; eventType,
2676                 double zoomFactor, double totalZoomFactor,
2677                 double x, double y, double screenX, double screenY,
2678                 boolean _shiftDown, boolean _controlDown,
2679                 boolean _altDown, boolean _metaDown,
2680                 boolean _direct, boolean _inertia) {
2681 
2682             if (eventType == ZoomEvent.ZOOM_FINISHED) {
2683                 x = zoomGesture.sceneCoords.getX();
2684                 y = zoomGesture.sceneCoords.getY();
2685                 screenX = zoomGesture.screenCoords.getX();
2686                 screenY = zoomGesture.screenCoords.getY();
2687             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2688                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2689                 if (cursorScenePos == null || cursorScreenPos == null) {
2690                     return;
2691                 }
2692                 x = cursorScenePos.getX();
2693                 y = cursorScenePos.getY();
2694                 screenX = cursorScreenPos.getX();
2695                 screenY = cursorScreenPos.getY();
2696             }
2697 
2698             inMousePick = true;
2699             Scene.this.processGestureEvent(new ZoomEvent(eventType,
2700                     x, y, screenX, screenY,
2701                     _shiftDown, _controlDown, _altDown, _metaDown,
2702                     _direct, _inertia,
2703                     zoomFactor, totalZoomFactor, pick(x, y)),
2704                     zoomGesture);
2705             inMousePick = false;
2706         }
2707 
2708         @Override
2709         public void rotateEvent(
2710                 EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
2711                 double x, double y, double screenX, double screenY,
2712                 boolean _shiftDown, boolean _controlDown,
2713                 boolean _altDown, boolean _metaDown,
2714                 boolean _direct, boolean _inertia) {
2715 
2716             if (eventType == RotateEvent.ROTATION_FINISHED) {
2717                 x = rotateGesture.sceneCoords.getX();
2718                 y = rotateGesture.sceneCoords.getY();
2719                 screenX = rotateGesture.screenCoords.getX();
2720                 screenY = rotateGesture.screenCoords.getY();
2721             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2722                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2723                 if (cursorScenePos == null || cursorScreenPos == null) {
2724                     return;
2725                 }
2726                 x = cursorScenePos.getX();
2727                 y = cursorScenePos.getY();
2728                 screenX = cursorScreenPos.getX();
2729                 screenY = cursorScreenPos.getY();
2730             }
2731 
2732             inMousePick = true;
2733             Scene.this.processGestureEvent(new RotateEvent(
2734                     eventType, x, y, screenX, screenY,
2735                     _shiftDown, _controlDown, _altDown, _metaDown,
2736                     _direct, _inertia, angle, totalAngle, pick(x, y)),
2737                     rotateGesture);
2738             inMousePick = false;
2739 
2740         }
2741 
2742         @Override
2743         public void swipeEvent(
2744                 EventType&lt;SwipeEvent&gt; eventType, int touchCount,
2745                 double x, double y, double screenX, double screenY,
2746                 boolean _shiftDown, boolean _controlDown,
2747                 boolean _altDown, boolean _metaDown, boolean _direct) {
2748 
2749             if (Double.isNaN(x) || Double.isNaN(y) ||
2750                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2751                 if (cursorScenePos == null || cursorScreenPos == null) {
2752                     return;
2753                 }
2754                 x = cursorScenePos.getX();
2755                 y = cursorScenePos.getY();
2756                 screenX = cursorScreenPos.getX();
2757                 screenY = cursorScreenPos.getY();
2758             }
2759 
2760             inMousePick = true;
2761             Scene.this.processGestureEvent(new SwipeEvent(
2762                     eventType, x, y, screenX, screenY,
2763                     _shiftDown, _controlDown, _altDown, _metaDown, _direct,
2764                     touchCount, pick(x, y)),
2765                     swipeGesture);
2766             inMousePick = false;
2767         }
2768 
2769         @Override
2770         public void touchEventBegin(
2771                 long time, int touchCount, boolean isDirect,
2772                 boolean _shiftDown, boolean _controlDown,
2773                 boolean _altDown, boolean _metaDown) {
2774 
2775             if (!isDirect) {
2776                 nextTouchEvent = null;
2777                 return;
2778             }
2779             nextTouchEvent = new TouchEvent(
2780                     TouchEvent.ANY, null, null, 0,
2781                     _shiftDown, _controlDown, _altDown, _metaDown);
2782             if (touchPoints == null || touchPoints.length != touchCount) {
2783                 touchPoints = new TouchPoint[touchCount];
2784             }
2785             touchPointIndex = 0;
2786         }
2787 
2788         @Override
2789         public void touchEventNext(
2790                 TouchPoint.State state, long touchId,
2791                 double x, double y, double screenX, double screenY) {
2792 
2793             inMousePick = true;
2794             if (nextTouchEvent == null) {
2795                 // ignore indirect touch events
2796                 return;
2797             }
2798             touchPointIndex++;
2799             int id = (state == TouchPoint.State.PRESSED
2800                     ? touchMap.add(touchId) :  touchMap.get(touchId));
2801             if (state == TouchPoint.State.RELEASED) {
2802                 touchMap.remove(touchId);
2803             }
2804             int order = touchMap.getOrder(id);
2805 
2806             if (order &gt;= touchPoints.length) {
2807                 throw new RuntimeException(&quot;Too many touch points reported&quot;);
2808             }
2809 
2810             // pick target
2811             boolean isGrabbed = false;
2812             PickResult pickRes = pick(x, y);
2813             EventTarget pickedTarget = touchTargets.get(id);
2814             if (pickedTarget == null) {
2815                 pickedTarget = pickRes.getIntersectedNode();
2816                 if (pickedTarget == null) {
2817                     pickedTarget = Scene.this;
2818                 }
2819             } else {
2820                 isGrabbed = true;
2821             }
2822 
2823             TouchPoint tp = new TouchPoint(id, state,
2824                     x, y, screenX, screenY, pickedTarget, pickRes);
2825 
2826             touchPoints[order] = tp;
2827 
2828             if (isGrabbed) {
2829                 tp.grab(pickedTarget);
2830             }
2831             if (tp.getState() == TouchPoint.State.PRESSED) {
2832                 tp.grab(pickedTarget);
2833                 touchTargets.put(tp.getId(), pickedTarget);
2834             } else if (tp.getState() == TouchPoint.State.RELEASED) {
2835                 touchTargets.remove(tp.getId());
2836             }
2837             inMousePick = false;
2838         }
2839 
2840         @Override
2841         public void touchEventEnd() {
2842             if (nextTouchEvent == null) {
2843                 // ignore indirect touch events
2844                 return;
2845             }
2846 
2847             if (touchPointIndex != touchPoints.length) {
2848                 throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
2849             }
2850 
2851             Scene.this.processTouchEvent(nextTouchEvent, touchPoints);
2852 
2853             if (touchMap.cleanup()) {
2854                 // gesture finished
2855                 touchEventSetId = 0;
2856             }
2857         }
2858 
2859         @Override
2860         public Accessible getSceneAccessible() {
2861             return getAccessible();
2862         }
2863     }
2864 
2865     private class ScenePeerPaintListener implements TKScenePaintListener {
2866         @Override
2867         public void frameRendered() {
2868             // must use tracker with synchronization since this method is called on render thread
2869             synchronized (trackerMonitor) {
2870                 if (Scene.this.tracker != null) {
2871                     Scene.this.tracker.frameRendered();
2872                 }
2873             }
2874         }
2875     }
2876 
2877     /*******************************************************************************
2878      *                                                                             *
2879      * Drag and Drop                                                               *
2880      *                                                                             *
2881      ******************************************************************************/
2882 
2883     class DropTargetListener implements TKDropTargetListener {
2884 
2885         /*
2886          * This function is called when an drag operation enters a valid drop target.
2887          * This may be from either an internal or external dnd operation.
2888          */
2889         @Override
2890         public TransferMode dragEnter(double x, double y, double screenX, double screenY,
2891                                       TransferMode transferMode, TKClipboard dragboard)
2892         {
2893             if (dndGesture == null) {
2894                 dndGesture = new DnDGesture();
2895             }
2896             Dragboard db = DragboardHelper.createDragboard(dragboard);
2897             dndGesture.dragboard = db;
2898             DragEvent dragEvent =
2899                     new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2900                             transferMode, null, null, pick(x, y));
2901             return dndGesture.processTargetEnterOver(dragEvent);
2902         }
2903 
2904         @Override
2905         public TransferMode dragOver(double x, double y, double screenX, double screenY,
2906                                      TransferMode transferMode)
2907         {
2908             if (Scene.this.dndGesture == null) {
2909                 System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
2910                 return null;
2911             } else {
2912                 if (dndGesture.dragboard == null) {
2913                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
2914                 }
2915                 DragEvent dragEvent =
2916                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2917                                 transferMode, null, null, pick(x, y));
2918                 return dndGesture.processTargetEnterOver(dragEvent);
2919             }
2920         }
2921 
2922         @Override
2923         public void dragExit(double x, double y, double screenX, double screenY) {
2924             if (dndGesture == null) {
2925                 System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
2926             } else {
2927                 if (dndGesture.dragboard == null) {
2928                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
2929                 }
2930                 DragEvent dragEvent =
2931                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2932                                 null, null, null, pick(x, y));
2933                 dndGesture.processTargetExit(dragEvent);
2934                 if (dndGesture.source == null) {
2935                     dndGesture.dragboard = null;
2936                     dndGesture = null;
2937                 }
2938             }
2939         }
2940 
2941 
2942         @Override
2943         public TransferMode drop(double x, double y, double screenX, double screenY,
2944                                   TransferMode transferMode)
2945         {
2946             if (dndGesture == null) {
2947                 System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
2948                 return null;
2949             } else {
2950                 if (dndGesture.dragboard == null) {
2951                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
2952                 }
2953                 DragEvent dragEvent =
2954                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2955                                 transferMode, null, null, pick(x, y));
2956                 // Data dropped to the app can be accessed without restriction
2957                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
2958 
2959                 TransferMode tm;
2960                 try {
2961                     tm = dndGesture.processTargetDrop(dragEvent);
2962                 } finally {
2963                     DragboardHelper.setDataAccessRestriction(
2964                             dndGesture.dragboard, true);
2965                 }
2966 
2967                 if (dndGesture.source == null) {
2968                     dndGesture.dragboard = null;
2969                     dndGesture = null;
2970                 }
2971                 return tm;
2972             }
2973         }
2974     }
2975 
2976     class DragGestureListener implements TKDragGestureListener {
2977 
2978        @Override
2979        public void dragGestureRecognized(double x, double y, double screenX, double screenY,
2980                                          int button, TKClipboard dragboard)
2981        {
2982            Dragboard db = DragboardHelper.createDragboard(dragboard);
2983            dndGesture = new DnDGesture();
2984            dndGesture.dragboard = db;
2985            // TODO: support mouse buttons in DragEvent
2986            DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
2987                    null, null, null, pick(x, y));
2988            dndGesture.processRecognized(dragEvent);
2989            dndGesture = null;
2990         }
2991     }
2992 
2993     /**
2994      * A Drag and Drop gesture has a lifespan that lasts from mouse
2995      * PRESSED event to mouse RELEASED event.
2996      */
2997     class DnDGesture {
2998         private final double hysteresisSizeX =
2999                 Toolkit.getToolkit().getMultiClickMaxX();
3000         private final double hysteresisSizeY =
3001                 Toolkit.getToolkit().getMultiClickMaxY();
3002 
3003         private EventTarget source = null;
3004         private Set&lt;TransferMode&gt; sourceTransferModes = null;
3005         private TransferMode acceptedTransferMode = null;
3006         private Dragboard dragboard = null;
3007         private EventTarget potentialTarget = null;
3008         private EventTarget target = null;
3009         private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
3010         private double pressedX;
3011         private double pressedY;
3012         private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
3013         private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
3014         private EventTarget fullPDRSource = null;
3015 
3016         /**
3017          * Fires event on a given target or on scene if the node is null
3018          */
3019         private void fireEvent(EventTarget target, Event e) {
3020             if (target != null) {
3021                 Event.fireEvent(target, e);
3022             }
3023         }
3024 
3025         /**
3026          * Called when DRAG_DETECTED event is going to be processed by
3027          * application
3028          */
3029         private void processingDragDetected() {
3030             dragDetected = DragDetectedState.PROCESSING;
3031         }
3032 
3033         /**
3034          * Called after DRAG_DETECTED event has been processed by application
3035          */
3036         private void dragDetectedProcessed() {
3037             dragDetected = DragDetectedState.DONE;
3038             final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
3039             if (hasContent) {
3040                 /* start DnD */
3041                 Toolkit.getToolkit().startDrag(Scene.this.peer,
3042                                                 sourceTransferModes,
3043                                                 new DragSourceListener(),
3044                                                 dragboard);
3045             } else if (fullPDRSource != null) {
3046                 /* start PDR */
3047                 Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
3048             }
3049 
3050             fullPDRSource = null;
3051         }
3052 
3053         /**
3054          * Sets the default dragDetect value
3055          */
3056         private void processDragDetection(MouseEvent mouseEvent) {
3057 
3058             if (dragDetected != DragDetectedState.NOT_YET) {
3059                 mouseEvent.setDragDetect(false);
3060                 return;
3061             }
3062 
3063             if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
3064                 pressedX = mouseEvent.getSceneX();
3065                 pressedY = mouseEvent.getSceneY();
3066 
3067                 mouseEvent.setDragDetect(false);
3068 
3069             } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3070 
3071                 double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
3072                 double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
3073                 mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
3074                                          deltaY &gt; hysteresisSizeY);
3075 
3076             }
3077         }
3078 
3079         /**
3080          * This function is useful for drag gesture recognition from
3081          * within this Scene (as opposed to in the TK implementation... by the platform)
3082          */
3083         private boolean process(MouseEvent mouseEvent, EventTarget target) {
3084             boolean continueProcessing = true;
3085             if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3086 
3087                 if (dragDetected != DragDetectedState.DONE &amp;&amp;
3088                         (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
3089                         mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
3090                         mouseEvent.isDragDetect()) {
3091 
3092                     processingDragDetected();
3093 
3094                     if (target != null) {
3095                         final MouseEvent detectedEvent = mouseEvent.copyFor(
3096                                 mouseEvent.getSource(), target,
3097                                 MouseEvent.DRAG_DETECTED);
3098 
3099                         try {
3100                             fireEvent(target, detectedEvent);
3101                         } finally {
3102                             // Putting data to dragboard finished, restrict access to them
3103                             if (dragboard != null) {
3104                                 DragboardHelper.setDataAccessRestriction(
3105                                         dragboard, true);
3106                             }
3107                         }
3108                     }
3109 
3110                     dragDetectedProcessed();
3111                 }
3112 
3113                 if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
3114                     continueProcessing = false;
3115                 }
3116             }
3117             return continueProcessing;
3118         }
3119 
3120         /*
3121          * Called when a drag source is recognized. This occurs at the very start of
3122          * the publicly visible drag and drop API, as it is responsible for calling
3123          * the Node.onDragSourceRecognized function.
3124          */
3125         private boolean processRecognized(DragEvent de) {
3126             MouseEvent me = new MouseEvent(
3127                     MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
3128                     de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
3129                     false, false, false, false, false, true, false, false, false,
3130                     false, de.getPickResult());
3131 
3132             processingDragDetected();
3133 
3134             final EventTarget target = de.getPickResult().getIntersectedNode();
3135             try {
3136                 fireEvent(target != null ? target : Scene.this, me);
3137             } finally {
3138                 // Putting data to dragboard finished, restrict access to them
3139                 if (dragboard != null) {
3140                     DragboardHelper.setDataAccessRestriction(
3141                             dragboard, true);
3142                 }
3143             }
3144 
3145             dragDetectedProcessed();
3146 
3147             final boolean hasContent = dragboard != null
3148                     &amp;&amp; !dragboard.getContentTypes().isEmpty();
3149             return hasContent;
3150         }
3151 
3152         private void processDropEnd(DragEvent de) {
3153             if (source == null) {
3154                 System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
3155                 return;
3156             }
3157 
3158             de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
3159                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3160                     de.getScreenX(), de.getScreenY(),
3161                     de.getTransferMode(), source, target, de.getPickResult());
3162 
3163             Event.fireEvent(source, de);
3164 
3165             tmpTargetWrapper.clear();
3166             handleExitEnter(de, tmpTargetWrapper);
3167 
3168             // at this point the drag and drop operation is completely over, so we
3169             // can tell the toolkit that it can clean up if needs be.
3170             Toolkit.getToolkit().stopDrag(dragboard);
3171         }
3172 
3173         private TransferMode processTargetEnterOver(DragEvent de) {
3174             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3175             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3176 
3177             if (dragboard == null) {
3178                 dragboard = createDragboard(de, false);
3179             }
3180 
3181             de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
3182                     dragboard, de.getSceneX(), de.getSceneY(),
3183                     de.getScreenX(), de.getScreenY(),
3184                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3185 
3186             handleExitEnter(de, tmpTargetWrapper);
3187 
3188             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
3189                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3190                     de.getScreenX(), de.getScreenY(),
3191                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3192 
3193             fireEvent(pickedTarget, de);
3194 
3195             Object acceptingObject = de.getAcceptingObject();
3196             potentialTarget = acceptingObject instanceof EventTarget
3197                     ? (EventTarget) acceptingObject : null;
3198             acceptedTransferMode = de.getAcceptedTransferMode();
3199             return acceptedTransferMode;
3200         }
3201 
3202         private void processTargetActionChanged(DragEvent de) {
3203             // Do we want DRAG_TRANSFER_MODE_CHANGED event?
3204 //            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
3205 //            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
3206 //                de = DragEvent.copy(de.getSource(), pickedNode, source,
3207 //                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
3208 //
3209 //                if (dragboard == null) {
3210 //                    dragboard = createDragboard(de);
3211 //                }
3212 //                dragboard = de.getPlatformDragboard();
3213 //
3214 //                fireEvent(pickedNode, de);
3215 //            }
3216         }
3217 
3218         private void processTargetExit(DragEvent de) {
3219             if (dragboard == null) {
3220                 // dragboard should have been created in processTargetEnterOver()
3221                 throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
3222             }
3223 
3224             if (currentTargets.size() &gt; 0) {
3225                 potentialTarget = null;
3226                 tmpTargetWrapper.clear();
3227                 handleExitEnter(de, tmpTargetWrapper);
3228             }
3229         }
3230 
3231         private TransferMode processTargetDrop(DragEvent de) {
3232             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3233             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3234 
3235             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
3236                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3237                     de.getScreenX(), de.getScreenY(),
3238                     acceptedTransferMode, source, potentialTarget, de.getPickResult());
3239 
3240             if (dragboard == null) {
3241                 // dragboard should have been created in processTargetEnterOver()
3242                 throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
3243             }
3244 
3245             handleExitEnter(de, tmpTargetWrapper);
3246 
3247             fireEvent(pickedTarget, de);
3248 
3249             Object acceptingObject = de.getAcceptingObject();
3250             potentialTarget = acceptingObject instanceof EventTarget
3251                     ? (EventTarget) acceptingObject : null;
3252             target = potentialTarget;
3253 
3254             TransferMode result = de.isDropCompleted() ?
3255                 de.getAcceptedTransferMode() : null;
3256 
3257             tmpTargetWrapper.clear();
3258             handleExitEnter(de, tmpTargetWrapper);
3259 
3260             return result;
3261         }
3262 
3263         private void handleExitEnter(DragEvent e, TargetWrapper target) {
3264             EventTarget currentTarget =
3265                     currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;
3266 
3267             if (target.getEventTarget() != currentTarget) {
3268 
3269                 target.fillHierarchy(newTargets);
3270 
3271                 int i = currentTargets.size() - 1;
3272                 int j = newTargets.size() - 1;
3273 
3274                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
3275                     i--;
3276                     j--;
3277                 }
3278 
3279                 for (; i &gt;= 0; i--) {
3280                     EventTarget t = currentTargets.get(i);
3281                     if (potentialTarget == t) {
3282                         potentialTarget = null;
3283                     }
3284                     e = e.copyFor(e.getSource(), t, source,
3285                             potentialTarget, DragEvent.DRAG_EXITED_TARGET);
3286                     Event.fireEvent(t, e);
3287                 }
3288 
3289                 potentialTarget = null;
3290                 for (; j &gt;= 0; j--) {
3291                     EventTarget t = newTargets.get(j);
3292                     e = e.copyFor(e.getSource(), t, source,
3293                             potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
3294                     Object acceptingObject = e.getAcceptingObject();
3295                     if (acceptingObject instanceof EventTarget) {
3296                         potentialTarget = (EventTarget) acceptingObject;
3297                     }
3298                     Event.fireEvent(t, e);
3299                 }
3300 
3301                 currentTargets.clear();
3302                 currentTargets.addAll(newTargets);
3303                 newTargets.clear();
3304             }
3305         }
3306 
3307 //        function getIntendedTransferMode(e:MouseEvent):TransferMode {
3308 //            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
3309 //        }
3310 
3311         /*
3312          * Function that hooks into the key processing code in Scene to handle the
3313          * situation where a drag and drop event is taking place and the user presses
3314          * the escape key to cancel the drag and drop operation.
3315          */
3316         private boolean processKey(KeyEvent e) {
3317             //note: this seems not to be called, the DnD cancelation is provided by platform
3318             if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {
3319 
3320                 // cancel drag and drop
3321                 DragEvent de = new DragEvent(
3322                         source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
3323                         null, source, null, null);
3324                 if (source != null) {
3325                     Event.fireEvent(source, de);
3326                 }
3327 
3328                 tmpTargetWrapper.clear();
3329                 handleExitEnter(de, tmpTargetWrapper);
3330 
3331                 return false;
3332             }
3333             return true;
3334         }
3335 
3336         /*
3337          * This starts the drag gesture running, creating the dragboard used for
3338          * the remainder of this drag and drop operation.
3339          */
3340         private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
3341             if (dragDetected != DragDetectedState.PROCESSING) {
3342                 throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
3343                         + &quot;outside of DRAG_DETECTED event handler&quot;);
3344             }
3345 
3346             if (t.isEmpty()) {
3347                 dragboard = null;
3348             } else if (dragboard == null) {
3349                 dragboard = createDragboard(null, true);
3350             }
3351 
3352             // The app can see what it puts to dragboard without restriction
3353             DragboardHelper.setDataAccessRestriction(dragboard, false);
3354 
3355             this.source = source;
3356             potentialTarget = source;
3357             sourceTransferModes = t;
3358             return dragboard;
3359         }
3360 
3361         /*
3362          * This starts the full PDR gesture.
3363          */
3364         private void startFullPDR(EventTarget source) {
3365             fullPDRSource = source;
3366         }
3367 
3368         private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
3369             Dragboard dragboard = null;
3370             if (de != null) {
3371                 dragboard = de.getDragboard();
3372                 if (dragboard != null) {
3373                     return dragboard;
3374                 }
3375             }
3376             TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
3377             return DragboardHelper.createDragboard(dragboardPeer);
3378         }
3379     }
3380 
3381     /**
3382      * State of a drag gesture with regards to DRAG_DETECTED event.
3383      */
3384     private enum DragDetectedState {
3385         NOT_YET,
3386         PROCESSING,
3387         DONE
3388     }
3389 
3390     class DragSourceListener implements TKDragSourceListener {
3391 
3392         @Override
3393         public void dragDropEnd(double x, double y, double screenX, double screenY,
3394                                 TransferMode transferMode)
3395         {
3396             if (dndGesture != null) {
3397                 if (dndGesture.dragboard == null) {
3398                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
3399                 }
3400                 DragEvent dragEvent =
3401                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
3402                         transferMode, null, null, null);
3403 
3404                 // DRAG_DONE event is delivered to gesture source, it can access
3405                 // its own data without restriction
3406                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
3407                 try {
3408                     dndGesture.processDropEnd(dragEvent);
3409                 } finally {
3410                     DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
3411                 }
3412                 dndGesture = null;
3413             }
3414         }
3415     }
3416 
3417     /*******************************************************************************
3418      *                                                                             *
3419      * Mouse Event Handling                                                        *
3420      *                                                                             *
3421      ******************************************************************************/
3422 
3423     static class ClickCounter {
3424         Toolkit toolkit = Toolkit.getToolkit();
3425         private int count;
3426         private boolean out;
3427         private boolean still;
3428         private Timeline timeout;
3429         private double pressedX, pressedY;
3430 
3431         private void inc() { count++; }
3432         private int get() { return count; }
3433         private boolean isStill() { return still; }
3434 
3435         private void clear() {
3436             count = 0;
3437             stopTimeout();
3438         }
3439 
3440         private void out() {
3441             out = true;
3442             stopTimeout();
3443         }
3444 
3445         private void applyOut() {
3446             if (out) clear();
3447             out = false;
3448         }
3449 
3450         private void moved(double x, double y) {
3451             if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
3452                     Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
3453                 out();
3454                 still = false;
3455             }
3456         }
3457 
3458         private void start(double x, double y) {
3459             pressedX = x;
3460             pressedY = y;
3461             out = false;
3462 
3463             if (timeout != null) {
3464                 timeout.stop();
3465             }
3466             timeout = new Timeline();
3467             timeout.getKeyFrames().add(
3468                     new KeyFrame(new Duration(toolkit.getMultiClickTime()),
3469                             event -&gt; {
3470                                 out = true;
3471                                 timeout = null;
3472                             }
3473                     ));
3474             timeout.play();
3475             still = true;
3476         }
3477 
3478         private void stopTimeout() {
3479             if (timeout != null) {
3480                 timeout.stop();
3481                 timeout = null;
3482             }
3483         }
3484     }
3485 
3486     static class ClickGenerator {
3487         private ClickCounter lastPress = null;
3488 
3489         private Map&lt;MouseButton, ClickCounter&gt; counters =
3490                 new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
3491         private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
3492         private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();
3493 
3494         public ClickGenerator() {
3495             for (MouseButton mb : MouseButton.values()) {
3496                 if (mb != MouseButton.NONE) {
3497                     counters.put(mb, new ClickCounter());
3498                 }
3499             }
3500         }
3501 
3502         private MouseEvent preProcess(MouseEvent e) {
3503             for (ClickCounter cc : counters.values()) {
3504                 cc.moved(e.getSceneX(), e.getSceneY());
3505             }
3506 
3507             ClickCounter cc = counters.get(e.getButton());
3508             boolean still = lastPress != null ? lastPress.isStill() : false;
3509 
3510             if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3511 
3512                 if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
3513                 if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
3514                 if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }
3515                 if (! e.isBackButtonDown()) { counters.get(MouseButton.BACK).clear(); }
3516                 if (! e.isForwardButtonDown()) { counters.get(MouseButton.FORWARD).clear(); }
3517                 cc.applyOut();
3518                 cc.inc();
3519                 cc.start(e.getSceneX(), e.getSceneY());
3520                 lastPress = cc;
3521             }
3522 
3523             return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3524                     e.getScreenX(), e.getScreenY(), e.getButton(),
3525                     cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
3526                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3527                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3528                     e.isBackButtonDown(), e.isForwardButtonDown(),
3529                     e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
3530         }
3531 
3532         private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
3533 
3534             if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3535                 ClickCounter cc = counters.get(e.getButton());
3536 
3537                 target.fillHierarchy(pressedTargets);
3538                 pickedTarget.fillHierarchy(releasedTargets);
3539                 int i = pressedTargets.size() - 1;
3540                 int j = releasedTargets.size() - 1;
3541 
3542                 EventTarget clickedTarget = null;
3543                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
3544                     clickedTarget = pressedTargets.get(i);
3545                     i--;
3546                     j--;
3547                 }
3548 
3549                 pressedTargets.clear();
3550                 releasedTargets.clear();
3551 
3552                 if (clickedTarget != null &amp;&amp; lastPress != null) {
3553                     MouseEvent click = new MouseEvent(null, clickedTarget,
3554                             MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
3555                             e.getScreenX(), e.getScreenY(), e.getButton(),
3556                             cc.get(),
3557                             e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3558                             e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3559                             e.isBackButtonDown(), e.isForwardButtonDown(),
3560                             e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
3561                     Event.fireEvent(clickedTarget, click);
3562                 }
3563             }
3564         }
3565     }
3566 
3567     /**
3568      * Generates mouse exited event for a node which is going to be removed
3569      * and its children, where appropriate.
3570      * @param removing Node which is going to be removed
3571      */
3572     void generateMouseExited(Node removing) {
3573         mouseHandler.handleNodeRemoval(removing);
3574     }
3575 
3576     class MouseHandler {
3577         private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
3578         private boolean pdrInProgress = false;
3579         private boolean fullPDREntered = false;
3580 
3581         private EventTarget currentEventTarget = null;
3582         private MouseEvent lastEvent;
3583         private boolean hover = false;
3584 
3585         private boolean primaryButtonDown = false;
3586         private boolean secondaryButtonDown = false;
3587         private boolean middleButtonDown = false;
3588         private boolean backButtonDown = false;
3589         private boolean forwardButtonDown = false;
3590 
3591         private EventTarget fullPDRSource = null;
3592         private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();
3593 
3594         /* lists needed for enter/exit events generation */
3595         private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
3596         private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
3597         private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();
3598 
3599         private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
3600         private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
3601         private EventTarget fullPDRCurrentTarget = null;
3602 
3603         private Cursor currCursor;
3604         private CursorFrame currCursorFrame;
3605         private EventQueue queue = new EventQueue();
3606 
3607         private Runnable pickProcess = new Runnable() {
3608 
3609             @Override
3610             public void run() {
3611                 // Make sure this is run only if the peer is still alive
3612                 // and there is an event to deliver
3613                 if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
3614                     process(lastEvent, true);
3615                 }
3616             }
3617         };
3618 
3619         private void pulse() {
3620             if (hover &amp;&amp; lastEvent != null) {
3621                 //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
3622                 Platform.runLater(pickProcess);
3623             }
3624         }
3625 
3626         private void clearPDREventTargets() {
3627             pdrInProgress = false;
3628             currentEventTarget = currentEventTargets.size() &gt; 0
3629                     ? currentEventTargets.get(0) : null;
3630             pdrEventTarget.clear();
3631         }
3632 
3633         public void enterFullPDR(EventTarget gestureSource) {
3634             fullPDREntered = true;
3635             fullPDRSource = gestureSource;
3636             fullPDRCurrentTarget = null;
3637             fullPDRCurrentEventTargets.clear();
3638         }
3639 
3640         public void exitFullPDR(MouseEvent e) {
3641             if (!fullPDREntered) {
3642                 return;
3643             }
3644             fullPDREntered = false;
3645             for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
3646                 EventTarget entered = fullPDRCurrentEventTargets.get(i);
3647                 Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
3648                         entered, entered,
3649                         MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3650                         fullPDRSource, e.getPickResult()));
3651             }
3652             fullPDRSource = null;
3653             fullPDRCurrentEventTargets.clear();
3654             fullPDRCurrentTarget = null;
3655         }
3656 
3657         private void handleNodeRemoval(Node removing) {
3658             if (lastEvent == null) {
3659                 // this can happen only if everything has been exited anyway
3660                 return;
3661             }
3662 
3663 
3664             if (currentEventTargets.contains(removing)) {
3665                 int i = 0;
3666                 EventTarget trg = null;
3667                 while(trg != removing) {
3668                     trg = currentEventTargets.get(i++);
3669 
3670                     queue.postEvent(lastEvent.copyFor(trg, trg,
3671                             MouseEvent.MOUSE_EXITED_TARGET));
3672                 }
3673                 currentEventTargets.subList(0, i).clear();
3674             }
3675 
3676             if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
3677                 int i = 0;
3678                 EventTarget trg = null;
3679                 while (trg != removing) {
3680                     trg = fullPDRCurrentEventTargets.get(i++);
3681 
3682                     queue.postEvent(
3683                             MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
3684                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3685                             fullPDRSource, lastEvent.getPickResult()));
3686                 }
3687 
3688                 fullPDRCurrentEventTargets.subList(0, i).clear();
3689             }
3690 
3691             queue.fire();
3692 
3693             if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
3694                 int i = 0;
3695                 EventTarget trg = null;
3696                 while (trg != removing) {
3697                     trg = pdrEventTargets.get(i++);
3698 
3699                     // trg.setHover(false) - already taken care of
3700                     // by the code above which sent a mouse exited event
3701                     ((Node) trg).setPressed(false);
3702                 }
3703                 pdrEventTargets.subList(0, i).clear();
3704 
3705                 trg = pdrEventTargets.get(0);
3706                 final PickResult res = pdrEventTarget.getResult();
3707                 if (trg instanceof Node) {
3708                     pdrEventTarget.setNodeResult(new PickResult((Node) trg,
3709                             res.getIntersectedPoint(), res.getIntersectedDistance()));
3710                 } else {
3711                     pdrEventTarget.setSceneResult(new PickResult(null,
3712                             res.getIntersectedPoint(), res.getIntersectedDistance()),
3713                             (Scene) trg);
3714                 }
3715             }
3716         }
3717 
3718         private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
3719             if (pickedTarget.getEventTarget() != currentEventTarget ||
3720                     e.getEventType() == MouseEvent.MOUSE_EXITED) {
3721 
3722                 if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3723                     newEventTargets.clear();
3724                 } else {
3725                     pickedTarget.fillHierarchy(newEventTargets);
3726                 }
3727 
3728                 int newTargetsSize = newEventTargets.size();
3729                 int i = currentEventTargets.size() - 1;
3730                 int j = newTargetsSize - 1;
3731                 int k = pdrEventTargets.size() - 1;
3732 
3733                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
3734                     i--;
3735                     j--;
3736                     k--;
3737                 }
3738 
3739                 final int memk = k;
3740                 for (; i &gt;= 0; i--, k--) {
3741                     final EventTarget exitedEventTarget = currentEventTargets.get(i);
3742                     if (pdrInProgress &amp;&amp;
3743                             (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
3744                          break;
3745                     }
3746                     queue.postEvent(e.copyFor(
3747                             exitedEventTarget, exitedEventTarget,
3748                             MouseEvent.MOUSE_EXITED_TARGET));
3749                 }
3750 
3751                 k = memk;
3752                 for (; j &gt;= 0; j--, k--) {
3753                     final EventTarget enteredEventTarget = newEventTargets.get(j);
3754                     if (pdrInProgress &amp;&amp;
3755                             (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
3756                         break;
3757                     }
3758                     queue.postEvent(e.copyFor(
3759                             enteredEventTarget, enteredEventTarget,
3760                             MouseEvent.MOUSE_ENTERED_TARGET));
3761                 }
3762 
3763                 currentEventTarget = pickedTarget.getEventTarget();
3764                 currentEventTargets.clear();
3765                 for (j++; j &lt; newTargetsSize; j++) {
3766                     currentEventTargets.add(newEventTargets.get(j));
3767                 }
3768             }
3769             queue.fire();
3770         }
3771 
3772         private void process(MouseEvent e, boolean onPulse) {
3773             Toolkit.getToolkit().checkFxUserThread();
3774             Scene.inMousePick = true;
3775 
3776             cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
3777             cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());
3778 
3779             boolean gestureStarted = false;
3780             if (!onPulse) {
3781                 if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3782                     if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3783                             backButtonDown || forwardButtonDown)) {
3784                         //old gesture ended and new one started
3785                         gestureStarted = true;
3786                         if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3787                             Scene.this.dndGesture = new DnDGesture();
3788                         }
3789                         clearPDREventTargets();
3790                     }
3791                 } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
3792                     // gesture ended
3793                     clearPDREventTargets();
3794                 } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
3795                     hover = true;
3796                 } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3797                     hover = false;
3798                 }
3799 
3800                 primaryButtonDown = e.isPrimaryButtonDown();
3801                 secondaryButtonDown = e.isSecondaryButtonDown();
3802                 middleButtonDown = e.isMiddleButtonDown();
3803                 backButtonDown = e.isBackButtonDown();
3804                 forwardButtonDown = e.isForwardButtonDown();
3805             }
3806 
3807             pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3808             PickResult res = tmpTargetWrapper.getResult();
3809             if (res != null) {
3810                 e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3811                     e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
3812                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3813                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3814                     e.isBackButtonDown(), e.isForwardButtonDown(),
3815                     e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
3816             }
3817 
3818             if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3819                 tmpTargetWrapper.clear();
3820             }
3821 
3822             TargetWrapper target;
3823             if (pdrInProgress) {
3824                 target = pdrEventTarget;
3825             } else {
3826                 target = tmpTargetWrapper;
3827             }
3828 
3829             if (gestureStarted) {
3830                 pdrEventTarget.copy(target);
3831                 pdrEventTarget.fillHierarchy(pdrEventTargets);
3832             }
3833 
3834             if (!onPulse) {
3835                 e = clickGenerator.preProcess(e);
3836             }
3837 
3838             // enter/exit handling
3839             handleEnterExit(e, tmpTargetWrapper);
3840 
3841             //deliver event to the target node
3842             if (Scene.this.dndGesture != null) {
3843                 Scene.this.dndGesture.processDragDetection(e);
3844             }
3845 
3846             if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3847                 processFullPDR(e, onPulse);
3848             }
3849 
3850             if (target.getEventTarget() != null) {
3851                 if (e.getEventType() != MouseEvent.MOUSE_ENTERED
3852                         &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
3853                         &amp;&amp; !onPulse) {
3854                     Event.fireEvent(target.getEventTarget(), e);
3855                 }
3856             }
3857 
3858             if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
3859                 processFullPDR(e, onPulse);
3860             }
3861 
3862             if (!onPulse) {
3863                 clickGenerator.postProcess(e, target, tmpTargetWrapper);
3864             }
3865 
3866             // handle drag and drop
3867 
3868             if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
3869                 if (Scene.this.dndGesture != null) {
3870                     if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
3871                         dndGesture = null;
3872                     }
3873                 }
3874             }
3875 
3876             Cursor cursor = target.getCursor();
3877             if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
3878                 if (cursor == null &amp;&amp; hover) {
3879                     cursor = Scene.this.getCursor();
3880                 }
3881 
3882                 updateCursor(cursor);
3883                 updateCursorFrame();
3884             }
3885 
3886             if (gestureStarted) {
3887                 pdrInProgress = true;
3888             }
3889 
3890             if (pdrInProgress &amp;&amp;
3891                     !(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3892                             backButtonDown || forwardButtonDown)) {
3893                 clearPDREventTargets();
3894                 exitFullPDR(e);
3895                 // we need to do new picking in case the originally picked node
3896                 // was moved or removed by the event handlers
3897                 pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3898                 handleEnterExit(e, tmpTargetWrapper);
3899             }
3900 
3901             lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
3902             Scene.inMousePick = false;
3903         }
3904 
3905         private void processFullPDR(MouseEvent e, boolean onPulse) {
3906 
3907             pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
3908             final PickResult result = fullPDRTmpTargetWrapper.getResult();
3909 
3910             final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();
3911 
3912             // enter/exit handling
3913             if (eventTarget != fullPDRCurrentTarget) {
3914 
3915                 fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);
3916 
3917                 int newTargetsSize = fullPDRNewEventTargets.size();
3918                 int i = fullPDRCurrentEventTargets.size() - 1;
3919                 int j = newTargetsSize - 1;
3920 
3921                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
3922                         fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
3923                     i--;
3924                     j--;
3925                 }
3926 
3927                 for (; i &gt;= 0; i--) {
3928                     final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
3929                     Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
3930                             exitedEventTarget, exitedEventTarget,
3931                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3932                             fullPDRSource, result));
3933                 }
3934 
3935                 for (; j &gt;= 0; j--) {
3936                     final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
3937                     Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
3938                             enteredEventTarget, enteredEventTarget,
3939                             MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
3940                             fullPDRSource, result));
3941                 }
3942 
3943                 fullPDRCurrentTarget = eventTarget;
3944                 fullPDRCurrentEventTargets.clear();
3945                 fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
3946                 fullPDRNewEventTargets.clear();
3947             }
3948             // done enter/exit handling
3949 
3950             // event delivery
3951             if (eventTarget != null &amp;&amp; !onPulse) {
3952                 if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3953                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3954                             eventTarget, eventTarget,
3955                             MouseDragEvent.MOUSE_DRAG_OVER,
3956                             fullPDRSource, result));
3957                 }
3958                 if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3959                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3960                             eventTarget, eventTarget,
3961                             MouseDragEvent.MOUSE_DRAG_RELEASED,
3962                             fullPDRSource, result));
3963                 }
3964             }
3965         }
3966 
3967         private void updateCursor(Cursor newCursor) {
3968             if (currCursor != newCursor) {
3969                 if (currCursor != null) {
3970                     currCursor.deactivate();
3971                 }
3972 
3973                 if (newCursor != null) {
3974                     newCursor.activate();
3975                 }
3976 
3977                 currCursor = newCursor;
3978             }
3979         }
3980 
3981         public void updateCursorFrame() {
3982             final CursorFrame newCursorFrame =
3983                     (currCursor != null)
3984                            ? currCursor.getCurrentFrame()
3985                            : Cursor.DEFAULT.getCurrentFrame();
3986             if (currCursorFrame != newCursorFrame) {
3987                 if (Scene.this.peer != null) {
3988                     Scene.this.peer.setCursor(newCursorFrame);
3989                 }
3990 
3991                 currCursorFrame = newCursorFrame;
3992             }
3993         }
3994 
3995         private PickResult pickNode(PickRay pickRay) {
3996             PickResultChooser r = new PickResultChooser();
3997             Scene.this.getRoot().pickNode(pickRay, r);
3998             return r.toPickResult();
3999         }
4000     }
4001 
4002     /*******************************************************************************
4003      *                                                                             *
4004      * Key Event Handling                                                          *
4005      *                                                                             *
4006      ******************************************************************************/
4007 
4008     class KeyHandler {
4009         private void setFocusOwner(final Node value) {
4010             // Cancel IM composition if there is one in progress.
4011             // This needs to be done before the focus owner is switched as it
4012             // generates event that needs to be delivered to the old focus owner.
4013             if (oldFocusOwner != null) {
4014                 final Scene s = oldFocusOwner.getScene();
4015                 if (s != null) {
4016                     final TKScene peer = s.getPeer();
4017                     if (peer != null) {
4018                         peer.finishInputMethodComposition();
4019                     }
4020                 }
4021             }
4022             focusOwner.set(value);
4023         }
4024 
4025         private boolean windowFocused;
4026         protected boolean isWindowFocused() { return windowFocused; }
4027         protected void setWindowFocused(boolean value) {
4028             windowFocused = value;
4029             if (getFocusOwner() != null) {
4030                 getFocusOwner().setFocused(windowFocused);
4031             }
4032             if (windowFocused) {
4033                 if (accessible != null) {
4034                     accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
4035                 }
4036             }
4037         }
4038 
4039         private void windowForSceneChanged(Window oldWindow, Window window) {
4040             if (oldWindow != null) {
4041                 oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
4042             }
4043 
4044             if (window != null) {
4045                 window.focusedProperty().addListener(sceneWindowFocusedListener);
4046                 setWindowFocused(window.isFocused());
4047             } else {
4048                 setWindowFocused(false);
4049             }
4050         }
4051 
4052         private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());
4053 
4054         private void process(KeyEvent e) {
4055             final Node sceneFocusOwner = getFocusOwner();
4056             final EventTarget eventTarget =
4057                     (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
4058                                               : Scene.this;
4059 
4060             // send the key event to the current focus owner or to scene if
4061             // the focus owner is not set
4062             Event.fireEvent(eventTarget, e);
4063         }
4064 
4065         private void requestFocus(Node node) {
4066             if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
4067                 return;
4068             }
4069             setFocusOwner(node);
4070         }
4071     }
4072     /***************************************************************************
4073      *                                                                         *
4074      *                         Event Dispatch                                  *
4075      *                                                                         *
4076      **************************************************************************/
4077     // PENDING_DOC_REVIEW
4078     /**
4079      * Specifies the event dispatcher for this scene. When replacing the value
4080      * with a new {@code EventDispatcher}, the new dispatcher should forward
4081      * events to the replaced dispatcher to keep the scene&#39;s default event
4082      * handling behavior.
4083      */
4084     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
4085 
4086     public final void setEventDispatcher(EventDispatcher value) {
4087         eventDispatcherProperty().set(value);
4088     }
4089 
4090     public final EventDispatcher getEventDispatcher() {
4091         return eventDispatcherProperty().get();
4092     }
4093 
4094     public final ObjectProperty&lt;EventDispatcher&gt;
4095             eventDispatcherProperty() {
4096         initializeInternalEventDispatcher();
4097         return eventDispatcher;
4098     }
4099 
4100     private SceneEventDispatcher internalEventDispatcher;
4101 
4102     // Delegates requests from platform input method to the focused
4103     // node&#39;s one, if any.
4104     class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
4105         @Override
4106         public Point2D getTextLocation(int offset) {
4107             InputMethodRequests requests = getClientRequests();
4108             if (requests != null) {
4109                 return requests.getTextLocation(offset);
4110             } else {
4111                 return new Point2D(0, 0);
4112             }
4113         }
4114 
4115         @Override
4116         public int getLocationOffset(int x, int y) {
4117             InputMethodRequests requests = getClientRequests();
4118             if (requests != null) {
4119                 return requests.getLocationOffset(x, y);
4120             } else {
4121                 return 0;
4122             }
4123         }
4124 
4125         @Override
4126         public void cancelLatestCommittedText() {
4127             InputMethodRequests requests = getClientRequests();
4128             if (requests != null) {
4129                 requests.cancelLatestCommittedText();
4130             }
4131         }
4132 
4133         @Override
4134         public String getSelectedText() {
4135             InputMethodRequests requests = getClientRequests();
4136             if (requests != null) {
4137                 return requests.getSelectedText();
4138             }
4139             return null;
4140         }
4141 
4142         @Override
4143         public int getInsertPositionOffset() {
4144             InputMethodRequests requests = getClientRequests();
4145             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4146                 return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
4147             }
4148             return 0;
4149         }
4150 
4151         @Override
4152         public String getCommittedText(int begin, int end) {
4153             InputMethodRequests requests = getClientRequests();
4154             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4155                 return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
4156             }
4157             return null;
4158         }
4159 
4160         @Override
4161         public int getCommittedTextLength() {
4162             InputMethodRequests requests = getClientRequests();
4163             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4164                 return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
4165             }
4166             return 0;
4167         }
4168 
4169         private InputMethodRequests getClientRequests() {
4170             Node focusOwner = getFocusOwner();
4171             if (focusOwner != null) {
4172                 return focusOwner.getInputMethodRequests();
4173             }
4174             return null;
4175         }
4176     }
4177 
4178     // PENDING_DOC_REVIEW
4179     /**
4180      * Registers an event handler to this scene. The handler is called when the
4181      * scene receives an {@code Event} of the specified type during the bubbling
4182      * phase of event delivery.
4183      *
4184      * @param &lt;T&gt; the specific event class of the handler
4185      * @param eventType the type of the events to receive by the handler
4186      * @param eventHandler the handler to register
4187      * @throws NullPointerException if the event type or handler is null
4188      */
4189     public final &lt;T extends Event&gt; void addEventHandler(
4190             final EventType&lt;T&gt; eventType,
4191             final EventHandler&lt;? super T&gt; eventHandler) {
4192         getInternalEventDispatcher().getEventHandlerManager()
4193                                     .addEventHandler(eventType, eventHandler);
4194     }
4195 
4196     // PENDING_DOC_REVIEW
4197     /**
4198      * Unregisters a previously registered event handler from this scene. One
4199      * handler might have been registered for different event types, so the
4200      * caller needs to specify the particular event type from which to
4201      * unregister the handler.
4202      *
4203      * @param &lt;T&gt; the specific event class of the handler
4204      * @param eventType the event type from which to unregister
4205      * @param eventHandler the handler to unregister
4206      * @throws NullPointerException if the event type or handler is null
4207      */
4208     public final &lt;T extends Event&gt; void removeEventHandler(
4209             final EventType&lt;T&gt; eventType,
4210             final EventHandler&lt;? super T&gt; eventHandler) {
4211         getInternalEventDispatcher().getEventHandlerManager()
4212                                     .removeEventHandler(eventType,
4213                                                         eventHandler);
4214     }
4215 
4216     // PENDING_DOC_REVIEW
4217     /**
4218      * Registers an event filter to this scene. The filter is called when the
4219      * scene receives an {@code Event} of the specified type during the
4220      * capturing phase of event delivery.
4221      *
4222      * @param &lt;T&gt; the specific event class of the filter
4223      * @param eventType the type of the events to receive by the filter
4224      * @param eventFilter the filter to register
4225      * @throws NullPointerException if the event type or filter is null
4226      */
4227     public final &lt;T extends Event&gt; void addEventFilter(
4228             final EventType&lt;T&gt; eventType,
4229             final EventHandler&lt;? super T&gt; eventFilter) {
4230         getInternalEventDispatcher().getEventHandlerManager()
4231                                     .addEventFilter(eventType, eventFilter);
4232     }
4233 
4234     // PENDING_DOC_REVIEW
4235     /**
4236      * Unregisters a previously registered event filter from this scene. One
4237      * filter might have been registered for different event types, so the
4238      * caller needs to specify the particular event type from which to
4239      * unregister the filter.
4240      *
4241      * @param &lt;T&gt; the specific event class of the filter
4242      * @param eventType the event type from which to unregister
4243      * @param eventFilter the filter to unregister
4244      * @throws NullPointerException if the event type or filter is null
4245      */
4246     public final &lt;T extends Event&gt; void removeEventFilter(
4247             final EventType&lt;T&gt; eventType,
4248             final EventHandler&lt;? super T&gt; eventFilter) {
4249         getInternalEventDispatcher().getEventHandlerManager()
4250                                     .removeEventFilter(eventType, eventFilter);
4251     }
4252 
4253     /**
4254      * Sets the handler to use for this event type. There can only be one such
4255      * handler specified at a time. This handler is guaranteed to be called
4256      * first. This is used for registering the user-defined onFoo event
4257      * handlers.
4258      *
4259      * @param &lt;T&gt; the specific event class of the handler
4260      * @param eventType the event type to associate with the given eventHandler
4261      * @param eventHandler the handler to register, or null to unregister
4262      * @throws NullPointerException if the event type is null
4263      */
4264     protected final &lt;T extends Event&gt; void setEventHandler(
4265             final EventType&lt;T&gt; eventType,
4266             final EventHandler&lt;? super T&gt; eventHandler) {
4267         getInternalEventDispatcher().getEventHandlerManager()
4268                                     .setEventHandler(eventType, eventHandler);
4269     }
4270 
4271     private SceneEventDispatcher getInternalEventDispatcher() {
4272         initializeInternalEventDispatcher();
4273         return internalEventDispatcher;
4274     }
4275 
4276     final void initializeInternalEventDispatcher() {
4277         if (internalEventDispatcher == null) {
4278             internalEventDispatcher = createInternalEventDispatcher();
4279             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
4280                                           this,
4281                                           &quot;eventDispatcher&quot;,
4282                                           internalEventDispatcher);
4283         }
4284     }
4285 
4286     private SceneEventDispatcher createInternalEventDispatcher() {
4287         return new SceneEventDispatcher(this);
4288     }
4289 
4290     /**
4291      * Registers the specified mnemonic.
4292      *
4293      * @param m The mnemonic
4294      */
4295     public void addMnemonic(Mnemonic m) {
4296         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4297                                     .addMnemonic(m);
4298     }
4299 
4300 
4301     /**
4302      * Unregisters the specified mnemonic.
4303      *
4304      * @param m The mnemonic
4305      */
4306     public void removeMnemonic(Mnemonic m) {
4307         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4308                                     .removeMnemonic(m);
4309     }
4310 
4311     final void clearNodeMnemonics(Node node) {
4312         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4313                 .clearNodeMnemonics(node);
4314     }
4315 
4316 
4317     /**
4318      * Gets the list of mnemonics for this {@code Scene}.
4319      *
4320      * @return the list of mnemonics
4321      */
4322     public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
4323         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4324                                            .getMnemonics();
4325     }
4326 
4327     /**
4328      * Gets the list of accelerators for this {@code Scene}.
4329      *
4330      * @return the list of accelerators
4331      */
4332     public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
4333         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4334                                            .getAccelerators();
4335     }
4336 
4337     // PENDING_DOC_REVIEW
4338     /**
4339      * Construct an event dispatch chain for this scene. The event dispatch
4340      * chain contains all event dispatchers from the stage to this scene.
4341      *
4342      * @param tail the initial chain to build from
4343      * @return the resulting event dispatch chain for this scene
4344      */
4345     @Override
4346     public EventDispatchChain buildEventDispatchChain(
4347             EventDispatchChain tail) {
4348         if (eventDispatcher != null) {
4349             final EventDispatcher eventDispatcherValue = eventDispatcher.get();
4350             if (eventDispatcherValue != null) {
4351                 tail = tail.prepend(eventDispatcherValue);
4352             }
4353         }
4354 
4355         if (getWindow() != null) {
4356             tail = getWindow().buildEventDispatchChain(tail);
4357         }
4358 
4359         return tail;
4360     }
4361 
4362     /***************************************************************************
4363      *                                                                         *
4364      *                             Context Menus                               *
4365      *                                                                         *
4366      **************************************************************************/
4367 
4368     /**
4369      * Defines a function to be called when a mouse button has been clicked
4370      * (pressed and released) on this {@code Scene}.
4371      * @since JavaFX 2.1
4372      */
4373 
4374     private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
4375 
4376     public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
4377         onContextMenuRequestedProperty().set(value);
4378     }
4379 
4380     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
4381         return onContextMenuRequested == null ? null : onContextMenuRequested.get();
4382     }
4383 
4384     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
4385         if (onContextMenuRequested == null) {
4386             onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {
4387 
4388                 @Override
4389                 protected void invalidated() {
4390                     setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
4391                 }
4392 
4393                 @Override
4394                 public Object getBean() {
4395                     return Scene.this;
4396                 }
4397 
4398                 @Override
4399                 public String getName() {
4400                     return &quot;onContextMenuRequested&quot;;
4401                 }
4402             };
4403         }
4404         return onContextMenuRequested;
4405     }
4406 
4407     /***************************************************************************
4408      *                                                                         *
4409      *                             Mouse Handling                              *
4410      *                                                                         *
4411      **************************************************************************/
4412 
4413     /**
4414      * Defines a function to be called when a mouse button has been clicked
4415      * (pressed and released) on this {@code Scene}.
4416      */
4417     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
4418 
4419     public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
4420         onMouseClickedProperty().set(value);
4421     }
4422 
4423     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
4424         return onMouseClicked == null ? null : onMouseClicked.get();
4425     }
4426 
4427     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
4428         if (onMouseClicked == null) {
4429             onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4430 
4431                 @Override
4432                 protected void invalidated() {
4433                     setEventHandler(MouseEvent.MOUSE_CLICKED, get());
4434                 }
4435 
4436                 @Override
4437                 public Object getBean() {
4438                     return Scene.this;
4439                 }
4440 
4441                 @Override
4442                 public String getName() {
4443                     return &quot;onMouseClicked&quot;;
4444                 }
4445             };
4446         }
4447         return onMouseClicked;
4448     }
4449 
4450     /**
4451      * Defines a function to be called when a mouse button is pressed
4452      * on this {@code Scene} and then dragged.
4453      */
4454     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
4455 
4456     public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
4457         onMouseDraggedProperty().set(value);
4458     }
4459 
4460     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
4461         return onMouseDragged == null ? null : onMouseDragged.get();
4462     }
4463 
4464     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
4465         if (onMouseDragged == null) {
4466             onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4467 
4468                 @Override
4469                 protected void invalidated() {
4470                     setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
4471                 }
4472 
4473                 @Override
4474                 public Object getBean() {
4475                     return Scene.this;
4476                 }
4477 
4478                 @Override
4479                 public String getName() {
4480                     return &quot;onMouseDragged&quot;;
4481                 }
4482             };
4483         }
4484         return onMouseDragged;
4485     }
4486 
4487     /**
4488      * Defines a function to be called when the mouse enters this {@code Scene}.
4489      */
4490     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
4491 
4492     public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
4493         onMouseEnteredProperty().set(value);
4494     }
4495 
4496     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
4497         return onMouseEntered == null ? null : onMouseEntered.get();
4498     }
4499 
4500     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
4501         if (onMouseEntered == null) {
4502             onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4503 
4504                 @Override
4505                 protected void invalidated() {
4506                     setEventHandler(MouseEvent.MOUSE_ENTERED, get());
4507                 }
4508 
4509                 @Override
4510                 public Object getBean() {
4511                     return Scene.this;
4512                 }
4513 
4514                 @Override
4515                 public String getName() {
4516                     return &quot;onMouseEntered&quot;;
4517                 }
4518             };
4519         }
4520         return onMouseEntered;
4521     }
4522 
4523     /**
4524      * Defines a function to be called when the mouse exits this {@code Scene}.
4525      */
4526     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
4527 
4528     public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
4529         onMouseExitedProperty().set(value);
4530     }
4531 
4532     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
4533         return onMouseExited == null ? null : onMouseExited.get();
4534     }
4535 
4536     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
4537         if (onMouseExited == null) {
4538             onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4539 
4540                 @Override
4541                 protected void invalidated() {
4542                     setEventHandler(MouseEvent.MOUSE_EXITED, get());
4543                 }
4544 
4545                 @Override
4546                 public Object getBean() {
4547                     return Scene.this;
4548                 }
4549 
4550                 @Override
4551                 public String getName() {
4552                     return &quot;onMouseExited&quot;;
4553                 }
4554             };
4555         }
4556         return onMouseExited;
4557     }
4558 
4559     /**
4560      * Defines a function to be called when mouse cursor moves within
4561      * this {@code Scene} but no buttons have been pushed.
4562      */
4563     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
4564 
4565     public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
4566         onMouseMovedProperty().set(value);
4567     }
4568 
4569     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
4570         return onMouseMoved == null ? null : onMouseMoved.get();
4571     }
4572 
4573     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
4574         if (onMouseMoved == null) {
4575             onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4576 
4577                 @Override
4578                 protected void invalidated() {
4579                     setEventHandler(MouseEvent.MOUSE_MOVED, get());
4580                 }
4581 
4582                 @Override
4583                 public Object getBean() {
4584                     return Scene.this;
4585                 }
4586 
4587                 @Override
4588                 public String getName() {
4589                     return &quot;onMouseMoved&quot;;
4590                 }
4591             };
4592         }
4593         return onMouseMoved;
4594     }
4595 
4596     /**
4597      * Defines a function to be called when a mouse button
4598      * has been pressed on this {@code Scene}.
4599      */
4600     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
4601 
4602     public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
4603         onMousePressedProperty().set(value);
4604     }
4605 
4606     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
4607         return onMousePressed == null ? null : onMousePressed.get();
4608     }
4609 
4610     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
4611         if (onMousePressed == null) {
4612             onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4613 
4614                 @Override
4615                 protected void invalidated() {
4616                     setEventHandler(MouseEvent.MOUSE_PRESSED, get());
4617                 }
4618 
4619                 @Override
4620                 public Object getBean() {
4621                     return Scene.this;
4622                 }
4623 
4624                 @Override
4625                 public String getName() {
4626                     return &quot;onMousePressed&quot;;
4627                 }
4628             };
4629         }
4630         return onMousePressed;
4631     }
4632 
4633     /**
4634      * Defines a function to be called when a mouse button
4635      * has been released on this {@code Scene}.
4636      */
4637     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
4638 
4639     public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
4640         onMouseReleasedProperty().set(value);
4641     }
4642 
4643     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
4644         return onMouseReleased == null ? null : onMouseReleased.get();
4645     }
4646 
4647     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
4648         if (onMouseReleased == null) {
4649             onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4650 
4651                 @Override
4652                 protected void invalidated() {
4653                     setEventHandler(MouseEvent.MOUSE_RELEASED, get());
4654                 }
4655 
4656                 @Override
4657                 public Object getBean() {
4658                     return Scene.this;
4659                 }
4660 
4661                 @Override
4662                 public String getName() {
4663                     return &quot;onMouseReleased&quot;;
4664                 }
4665             };
4666         }
4667         return onMouseReleased;
4668     }
4669 
4670     /**
4671      * Defines a function to be called when drag gesture has been
4672      * detected. This is the right place to start drag and drop operation.
4673      */
4674     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
4675 
4676     public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
4677         onDragDetectedProperty().set(value);
4678     }
4679 
4680     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
4681         return onDragDetected == null ? null : onDragDetected.get();
4682     }
4683 
4684     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
4685         if (onDragDetected == null) {
4686             onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4687 
4688                 @Override
4689                 protected void invalidated() {
4690                     setEventHandler(MouseEvent.DRAG_DETECTED, get());
4691                 }
4692 
4693                 @Override
4694                 public Object getBean() {
4695                     return Scene.this;
4696                 }
4697 
4698                 @Override
4699                 public String getName() {
4700                     return &quot;onDragDetected&quot;;
4701                 }
4702             };
4703         }
4704         return onDragDetected;
4705     }
4706 
4707     /**
4708      * Defines a function to be called when a full press-drag-release gesture
4709      * progresses within this {@code Scene}.
4710      * @since JavaFX 2.1
4711      */
4712     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
4713 
4714     public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
4715         onMouseDragOverProperty().set(value);
4716     }
4717 
4718     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
4719         return onMouseDragOver == null ? null : onMouseDragOver.get();
4720     }
4721 
4722     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
4723         if (onMouseDragOver == null) {
4724             onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4725 
4726                 @Override
4727                 protected void invalidated() {
4728                     setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
4729                 }
4730 
4731                 @Override
4732                 public Object getBean() {
4733                     return Scene.this;
4734                 }
4735 
4736                 @Override
4737                 public String getName() {
4738                     return &quot;onMouseDragOver&quot;;
4739                 }
4740             };
4741         }
4742         return onMouseDragOver;
4743     }
4744 
4745     /**
4746      * Defines a function to be called when a full press-drag-release gesture
4747      * ends within this {@code Scene}.
4748      * @since JavaFX 2.1
4749      */
4750     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
4751 
4752     public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
4753         onMouseDragReleasedProperty().set(value);
4754     }
4755 
4756     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
4757         return onMouseDragReleased == null ? null : onMouseDragReleased.get();
4758     }
4759 
4760     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
4761         if (onMouseDragReleased == null) {
4762             onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4763 
4764                 @Override
4765                 protected void invalidated() {
4766                     setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
4767                 }
4768 
4769                 @Override
4770                 public Object getBean() {
4771                     return Scene.this;
4772                 }
4773 
4774                 @Override
4775                 public String getName() {
4776                     return &quot;onMouseDragReleased&quot;;
4777                 }
4778             };
4779         }
4780         return onMouseDragReleased;
4781     }
4782 
4783     /**
4784      * Defines a function to be called when a full press-drag-release gesture
4785      * enters this {@code Scene}.
4786      * @since JavaFX 2.1
4787      */
4788     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
4789 
4790     public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
4791         onMouseDragEnteredProperty().set(value);
4792     }
4793 
4794     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
4795         return onMouseDragEntered == null ? null : onMouseDragEntered.get();
4796     }
4797 
4798     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
4799         if (onMouseDragEntered == null) {
4800             onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4801 
4802                 @Override
4803                 protected void invalidated() {
4804                     setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
4805                 }
4806 
4807                 @Override
4808                 public Object getBean() {
4809                     return Scene.this;
4810                 }
4811 
4812                 @Override
4813                 public String getName() {
4814                     return &quot;onMouseDragEntered&quot;;
4815                 }
4816             };
4817         }
4818         return onMouseDragEntered;
4819     }
4820 
4821     /**
4822      * Defines a function to be called when a full press-drag-release gesture
4823      * exits this {@code Scene}.
4824      * @since JavaFX 2.1
4825      */
4826     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
4827 
4828     public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
4829         onMouseDragExitedProperty().set(value);
4830     }
4831 
4832     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
4833         return onMouseDragExited == null ? null : onMouseDragExited.get();
4834     }
4835 
4836     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
4837         if (onMouseDragExited == null) {
4838             onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4839 
4840                 @Override
4841                 protected void invalidated() {
4842                     setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
4843                 }
4844 
4845                 @Override
4846                 public Object getBean() {
4847                     return Scene.this;
4848                 }
4849 
4850                 @Override
4851                 public String getName() {
4852                     return &quot;onMouseDragExited&quot;;
4853                 }
4854             };
4855         }
4856         return onMouseDragExited;
4857     }
4858 
4859 
4860     /***************************************************************************
4861      *                                                                         *
4862      *                           Gestures Handling                             *
4863      *                                                                         *
4864      **************************************************************************/
4865 
4866     /**
4867      * Defines a function to be called when a scrolling gesture is detected.
4868      * @since JavaFX 2.2
4869      */
4870     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
4871 
4872     public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
4873         onScrollStartedProperty().set(value);
4874     }
4875 
4876     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
4877         return onScrollStarted == null ? null : onScrollStarted.get();
4878     }
4879 
4880     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
4881         if (onScrollStarted == null) {
4882             onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4883 
4884                 @Override
4885                 protected void invalidated() {
4886                     setEventHandler(ScrollEvent.SCROLL_STARTED, get());
4887                 }
4888 
4889                 @Override
4890                 public Object getBean() {
4891                     return Scene.this;
4892                 }
4893 
4894                 @Override
4895                 public String getName() {
4896                     return &quot;onScrollStarted&quot;;
4897                 }
4898             };
4899         }
4900         return onScrollStarted;
4901     }
4902 
4903     /**
4904      * Defines a function to be called when user performs a scrolling action.
4905      */
4906     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
4907 
4908     public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
4909         onScrollProperty().set(value);
4910     }
4911 
4912     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
4913         return onScroll == null ? null : onScroll.get();
4914     }
4915 
4916     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
4917         if (onScroll == null) {
4918             onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4919 
4920                 @Override
4921                 protected void invalidated() {
4922                     setEventHandler(ScrollEvent.SCROLL, get());
4923                 }
4924 
4925                 @Override
4926                 public Object getBean() {
4927                     return Scene.this;
4928                 }
4929 
4930                 @Override
4931                 public String getName() {
4932                     return &quot;onScroll&quot;;
4933                 }
4934             };
4935         }
4936         return onScroll;
4937     }
4938 
4939     /**
4940      * Defines a function to be called when a scrolling gesture ends.
4941      * @since JavaFX 2.2
4942      */
4943     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
4944 
4945     public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
4946         onScrollFinishedProperty().set(value);
4947     }
4948 
4949     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
4950         return onScrollFinished == null ? null : onScrollFinished.get();
4951     }
4952 
4953     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
4954         if (onScrollFinished == null) {
4955             onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4956 
4957                 @Override
4958                 protected void invalidated() {
4959                     setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
4960                 }
4961 
4962                 @Override
4963                 public Object getBean() {
4964                     return Scene.this;
4965                 }
4966 
4967                 @Override
4968                 public String getName() {
4969                     return &quot;onScrollFinished&quot;;
4970                 }
4971             };
4972         }
4973         return onScrollFinished;
4974     }
4975 
4976     /**
4977      * Defines a function to be called when a rotating gesture is detected.
4978      * @since JavaFX 2.2
4979      */
4980     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
4981 
4982     public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
4983         onRotationStartedProperty().set(value);
4984     }
4985 
4986     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
4987         return onRotationStarted == null ? null : onRotationStarted.get();
4988     }
4989 
4990     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
4991         if (onRotationStarted == null) {
4992             onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
4993 
4994                 @Override
4995                 protected void invalidated() {
4996                     setEventHandler(RotateEvent.ROTATION_STARTED, get());
4997                 }
4998 
4999                 @Override
5000                 public Object getBean() {
5001                     return Scene.this;
5002                 }
5003 
5004                 @Override
5005                 public String getName() {
5006                     return &quot;onRotationStarted&quot;;
5007                 }
5008             };
5009         }
5010         return onRotationStarted;
5011     }
5012 
5013     /**
5014      * Defines a function to be called when user performs a rotating action.
5015      * @since JavaFX 2.2
5016      */
5017     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
5018 
5019     public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
5020         onRotateProperty().set(value);
5021     }
5022 
5023     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
5024         return onRotate == null ? null : onRotate.get();
5025     }
5026 
5027     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
5028         if (onRotate == null) {
5029             onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5030 
5031                 @Override
5032                 protected void invalidated() {
5033                     setEventHandler(RotateEvent.ROTATE, get());
5034                 }
5035 
5036                 @Override
5037                 public Object getBean() {
5038                     return Scene.this;
5039                 }
5040 
5041                 @Override
5042                 public String getName() {
5043                     return &quot;onRotate&quot;;
5044                 }
5045             };
5046         }
5047         return onRotate;
5048     }
5049 
5050     /**
5051      * Defines a function to be called when a rotating gesture ends.
5052      * @since JavaFX 2.2
5053      */
5054     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
5055 
5056     public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
5057         onRotationFinishedProperty().set(value);
5058     }
5059 
5060     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
5061         return onRotationFinished == null ? null : onRotationFinished.get();
5062     }
5063 
5064     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
5065         if (onRotationFinished == null) {
5066             onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5067 
5068                 @Override
5069                 protected void invalidated() {
5070                     setEventHandler(RotateEvent.ROTATION_FINISHED, get());
5071                 }
5072 
5073                 @Override
5074                 public Object getBean() {
5075                     return Scene.this;
5076                 }
5077 
5078                 @Override
5079                 public String getName() {
5080                     return &quot;onRotationFinished&quot;;
5081                 }
5082             };
5083         }
5084         return onRotationFinished;
5085     }
5086 
5087     /**
5088      * Defines a function to be called when a zooming gesture is detected.
5089      * @since JavaFX 2.2
5090      */
5091     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
5092 
5093     public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
5094         onZoomStartedProperty().set(value);
5095     }
5096 
5097     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
5098         return onZoomStarted == null ? null : onZoomStarted.get();
5099     }
5100 
5101     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
5102         if (onZoomStarted == null) {
5103             onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5104 
5105                 @Override
5106                 protected void invalidated() {
5107                     setEventHandler(ZoomEvent.ZOOM_STARTED, get());
5108                 }
5109 
5110                 @Override
5111                 public Object getBean() {
5112                     return Scene.this;
5113                 }
5114 
5115                 @Override
5116                 public String getName() {
5117                     return &quot;onZoomStarted&quot;;
5118                 }
5119             };
5120         }
5121         return onZoomStarted;
5122     }
5123 
5124     /**
5125      * Defines a function to be called when user performs a zooming action.
5126      * @since JavaFX 2.2
5127      */
5128     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
5129 
5130     public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
5131         onZoomProperty().set(value);
5132     }
5133 
5134     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
5135         return onZoom == null ? null : onZoom.get();
5136     }
5137 
5138     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
5139         if (onZoom == null) {
5140             onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5141 
5142                 @Override
5143                 protected void invalidated() {
5144                     setEventHandler(ZoomEvent.ZOOM, get());
5145                 }
5146 
5147                 @Override
5148                 public Object getBean() {
5149                     return Scene.this;
5150                 }
5151 
5152                 @Override
5153                 public String getName() {
5154                     return &quot;onZoom&quot;;
5155                 }
5156             };
5157         }
5158         return onZoom;
5159     }
5160 
5161     /**
5162      * Defines a function to be called when a zooming gesture ends.
5163      * @since JavaFX 2.2
5164      */
5165     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
5166 
5167     public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
5168         onZoomFinishedProperty().set(value);
5169     }
5170 
5171     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
5172         return onZoomFinished == null ? null : onZoomFinished.get();
5173     }
5174 
5175     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
5176         if (onZoomFinished == null) {
5177             onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5178 
5179                 @Override
5180                 protected void invalidated() {
5181                     setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
5182                 }
5183 
5184                 @Override
5185                 public Object getBean() {
5186                     return Scene.this;
5187                 }
5188 
5189                 @Override
5190                 public String getName() {
5191                     return &quot;onZoomFinished&quot;;
5192                 }
5193             };
5194         }
5195         return onZoomFinished;
5196     }
5197 
5198     /**
5199      * Defines a function to be called when an upward swipe gesture
5200      * happens in this scene.
5201      * @since JavaFX 2.2
5202      */
5203     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
5204 
5205     public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
5206         onSwipeUpProperty().set(value);
5207     }
5208 
5209     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
5210         return onSwipeUp == null ? null : onSwipeUp.get();
5211     }
5212 
5213     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
5214         if (onSwipeUp == null) {
5215             onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5216 
5217                 @Override
5218                 protected void invalidated() {
5219                     setEventHandler(SwipeEvent.SWIPE_UP, get());
5220                 }
5221 
5222                 @Override
5223                 public Object getBean() {
5224                     return Scene.this;
5225                 }
5226 
5227                 @Override
5228                 public String getName() {
5229                     return &quot;onSwipeUp&quot;;
5230                 }
5231             };
5232         }
5233         return onSwipeUp;
5234     }
5235 
5236     /**
5237      * Defines a function to be called when an downward swipe gesture
5238      * happens in this scene.
5239      * @since JavaFX 2.2
5240      */
5241     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
5242 
5243     public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
5244         onSwipeDownProperty().set(value);
5245     }
5246 
5247     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
5248         return onSwipeDown == null ? null : onSwipeDown.get();
5249     }
5250 
5251     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
5252         if (onSwipeDown == null) {
5253             onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5254 
5255                 @Override
5256                 protected void invalidated() {
5257                     setEventHandler(SwipeEvent.SWIPE_DOWN, get());
5258                 }
5259 
5260                 @Override
5261                 public Object getBean() {
5262                     return Scene.this;
5263                 }
5264 
5265                 @Override
5266                 public String getName() {
5267                     return &quot;onSwipeDown&quot;;
5268                 }
5269             };
5270         }
5271         return onSwipeDown;
5272     }
5273 
5274     /**
5275      * Defines a function to be called when an leftward swipe gesture
5276      * happens in this scene.
5277      * @since JavaFX 2.2
5278      */
5279     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
5280 
5281     public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
5282         onSwipeLeftProperty().set(value);
5283     }
5284 
5285     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
5286         return onSwipeLeft == null ? null : onSwipeLeft.get();
5287     }
5288 
5289     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
5290         if (onSwipeLeft == null) {
5291             onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5292 
5293                 @Override
5294                 protected void invalidated() {
5295                     setEventHandler(SwipeEvent.SWIPE_LEFT, get());
5296                 }
5297 
5298                 @Override
5299                 public Object getBean() {
5300                     return Scene.this;
5301                 }
5302 
5303                 @Override
5304                 public String getName() {
5305                     return &quot;onSwipeLeft&quot;;
5306                 }
5307             };
5308         }
5309         return onSwipeLeft;
5310     }
5311 
5312     /**
5313      * Defines a function to be called when an rightward swipe gesture
5314      * happens in this scene.
5315      * @since JavaFX 2.2
5316      */
5317     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
5318 
5319     public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
5320         onSwipeRightProperty().set(value);
5321     }
5322 
5323     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
5324         return onSwipeRight == null ? null : onSwipeRight.get();
5325     }
5326 
5327     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
5328         if (onSwipeRight == null) {
5329             onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5330 
5331                 @Override
5332                 protected void invalidated() {
5333                     setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
5334                 }
5335 
5336                 @Override
5337                 public Object getBean() {
5338                     return Scene.this;
5339                 }
5340 
5341                 @Override
5342                 public String getName() {
5343                     return &quot;onSwipeRight&quot;;
5344                 }
5345             };
5346         }
5347         return onSwipeRight;
5348     }
5349 
5350     /***************************************************************************
5351      *                                                                         *
5352      *                            Touch Handling                               *
5353      *                                                                         *
5354      **************************************************************************/
5355 
5356     /**
5357      * Defines a function to be called when a new touch point is pressed.
5358      * @since JavaFX 2.2
5359      */
5360     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
5361 
5362     public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
5363         onTouchPressedProperty().set(value);
5364     }
5365 
5366     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
5367         return onTouchPressed == null ? null : onTouchPressed.get();
5368     }
5369 
5370     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
5371         if (onTouchPressed == null) {
5372             onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5373 
5374                 @Override
5375                 protected void invalidated() {
5376                     setEventHandler(TouchEvent.TOUCH_PRESSED, get());
5377                 }
5378 
5379                 @Override
5380                 public Object getBean() {
5381                     return Scene.this;
5382                 }
5383 
5384                 @Override
5385                 public String getName() {
5386                     return &quot;onTouchPressed&quot;;
5387                 }
5388             };
5389         }
5390         return onTouchPressed;
5391     }
5392 
5393     /**
5394      * Defines a function to be called when a touch point is moved.
5395      * @since JavaFX 2.2
5396      */
5397     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
5398 
5399     public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
5400         onTouchMovedProperty().set(value);
5401     }
5402 
5403     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
5404         return onTouchMoved == null ? null : onTouchMoved.get();
5405     }
5406 
5407     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
5408         if (onTouchMoved == null) {
5409             onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5410 
5411                 @Override
5412                 protected void invalidated() {
5413                     setEventHandler(TouchEvent.TOUCH_MOVED, get());
5414                 }
5415 
5416                 @Override
5417                 public Object getBean() {
5418                     return Scene.this;
5419                 }
5420 
5421                 @Override
5422                 public String getName() {
5423                     return &quot;onTouchMoved&quot;;
5424                 }
5425             };
5426         }
5427         return onTouchMoved;
5428     }
5429 
5430     /**
5431      * Defines a function to be called when a new touch point is pressed.
5432      * @since JavaFX 2.2
5433      */
5434     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
5435 
5436     public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
5437         onTouchReleasedProperty().set(value);
5438     }
5439 
5440     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
5441         return onTouchReleased == null ? null : onTouchReleased.get();
5442     }
5443 
5444     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
5445         if (onTouchReleased == null) {
5446             onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5447 
5448                 @Override
5449                 protected void invalidated() {
5450                     setEventHandler(TouchEvent.TOUCH_RELEASED, get());
5451                 }
5452 
5453                 @Override
5454                 public Object getBean() {
5455                     return Scene.this;
5456                 }
5457 
5458                 @Override
5459                 public String getName() {
5460                     return &quot;onTouchReleased&quot;;
5461                 }
5462             };
5463         }
5464         return onTouchReleased;
5465     }
5466 
5467     /**
5468      * Defines a function to be called when a touch point stays pressed and
5469      * still.
5470      * @since JavaFX 2.2
5471      */
5472     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
5473 
5474     public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
5475         onTouchStationaryProperty().set(value);
5476     }
5477 
5478     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
5479         return onTouchStationary == null ? null : onTouchStationary.get();
5480     }
5481 
5482     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
5483         if (onTouchStationary == null) {
5484             onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5485 
5486                 @Override
5487                 protected void invalidated() {
5488                     setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
5489                 }
5490 
5491                 @Override
5492                 public Object getBean() {
5493                     return Scene.this;
5494                 }
5495 
5496                 @Override
5497                 public String getName() {
5498                     return &quot;onTouchStationary&quot;;
5499                 }
5500             };
5501         }
5502         return onTouchStationary;
5503     }
5504 
5505     /*
5506      * This class provides reordering and ID mapping of particular touch points.
5507      * Platform may report arbitrary touch point IDs and they may be reused
5508      * during one gesture. This class keeps track of it and provides
5509      * sequentially sorted IDs, unique in scope of a gesture.
5510      *
5511      * Some platforms report always small numbers, these take fast paths through
5512      * the algorithm, directly indexing an array. Bigger numbers take a slow
5513      * path using a hash map.
5514      *
5515      * The algorithm performance was measured and it doesn&#39;t impose
5516      * any significant slowdown on the event delivery.
5517      */
5518     private static class TouchMap {
5519         private static final int FAST_THRESHOLD = 10;
5520         int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
5521         Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
5522         List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
5523         List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
5524         int counter = 0;
5525         int active = 0;
5526 
5527         public int add(long id) {
5528             counter++;
5529             active++;
5530             if (id &lt; FAST_THRESHOLD) {
5531                 fastMap[(int) id] = counter;
5532             } else {
5533                 slowMap.put(id, counter);
5534             }
5535             order.add(counter);
5536             return counter;
5537         }
5538 
5539         public void remove(long id) {
5540             // book the removal - it needs to be done after all touch points
5541             // of an event are processed - see cleanup()
5542             removed.add(id);
5543         }
5544 
5545         public int get(long id) {
5546             if (id &lt; FAST_THRESHOLD) {
5547                 int result = fastMap[(int) id];
5548                 if (result == 0) {
5549                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5550                             + &quot;touch point ID&quot;);
5551                 }
5552                 return result;
5553             } else {
5554                 try {
5555                     return slowMap.get(id);
5556                 } catch (NullPointerException e) {
5557                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5558                             + &quot;touch point ID&quot;);
5559                 }
5560             }
5561         }
5562 
5563         public int getOrder(int id) {
5564             return order.indexOf(id);
5565         }
5566 
5567         // returns true if gesture finished (no finger is touched)
5568         public boolean cleanup() {
5569             for (long id : removed) {
5570                 active--;
5571                 order.remove(Integer.valueOf(get(id)));
5572                 if (id &lt; FAST_THRESHOLD) {
5573                     fastMap[(int) id] = 0;
5574                 } else {
5575                     slowMap.remove(id);
5576                 }
5577                 if (active == 0) {
5578                     // gesture finished
5579                     counter = 0;
5580                 }
5581             }
5582             removed.clear();
5583             return active == 0;
5584         }
5585     }
5586 
5587 
5588     /***************************************************************************
5589      *                                                                         *
5590      *                         Drag and Drop Handling                          *
5591      *                                                                         *
5592      **************************************************************************/
5593 
5594     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
5595 
5596     public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
5597         onDragEnteredProperty().set(value);
5598     }
5599 
5600     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
5601         return onDragEntered == null ? null : onDragEntered.get();
5602     }
5603 
5604     /**
5605      * Defines a function to be called when drag gesture
5606      * enters this {@code Scene}.
5607      * @return function to be called when drag gesture enters this scene
5608      */
5609     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
5610         if (onDragEntered == null) {
5611             onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5612 
5613                 @Override
5614                 protected void invalidated() {
5615                     setEventHandler(DragEvent.DRAG_ENTERED, get());
5616                 }
5617 
5618                 @Override
5619                 public Object getBean() {
5620                     return Scene.this;
5621                 }
5622 
5623                 @Override
5624                 public String getName() {
5625                     return &quot;onDragEntered&quot;;
5626                 }
5627             };
5628         }
5629         return onDragEntered;
5630     }
5631 
5632     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
5633 
5634     public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
5635         onDragExitedProperty().set(value);
5636     }
5637 
5638     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
5639         return onDragExited == null ? null : onDragExited.get();
5640     }
5641 
5642     /**
5643      * Defines a function to be called when drag gesture
5644      * exits this {@code Scene}.
5645      * @return the function to be called when drag gesture exits this scene
5646      */
5647     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
5648         if (onDragExited == null) {
5649             onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5650 
5651                 @Override
5652                 protected void invalidated() {
5653                     setEventHandler(DragEvent.DRAG_EXITED, get());
5654                 }
5655 
5656                 @Override
5657                 public Object getBean() {
5658                     return Scene.this;
5659                 }
5660 
5661                 @Override
5662                 public String getName() {
5663                     return &quot;onDragExited&quot;;
5664                 }
5665             };
5666         }
5667         return onDragExited;
5668     }
5669 
5670     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
5671 
5672     public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
5673         onDragOverProperty().set(value);
5674     }
5675 
5676     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
5677         return onDragOver == null ? null : onDragOver.get();
5678     }
5679 
5680     /**
5681      * Defines a function to be called when drag gesture progresses
5682      * within this {@code Scene}.
5683      * @return the function to be called when drag gesture progresses within
5684      * this scene
5685      */
5686     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
5687         if (onDragOver == null) {
5688             onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5689 
5690                 @Override
5691                 protected void invalidated() {
5692                     setEventHandler(DragEvent.DRAG_OVER, get());
5693                 }
5694 
5695                 @Override
5696                 public Object getBean() {
5697                     return Scene.this;
5698                 }
5699 
5700                 @Override
5701                 public String getName() {
5702                     return &quot;onDragOver&quot;;
5703                 }
5704             };
5705         }
5706         return onDragOver;
5707     }
5708 
5709     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
5710 //    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
5711 //
5712 //    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
5713 //        onDragTransferModeChangedProperty().set(value);
5714 //    }
5715 //
5716 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
5717 //        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
5718 //    }
5719 //
5720 //    /**
5721 //     * Defines a function to be called this {@code Scene} if it is a potential
5722 //     * drag-and-drop target when the user takes action to change the intended
5723 //     * {@code TransferMode}.
5724 //     * The user can change the intended {@link TransferMode} by holding down
5725 //     * or releasing key modifiers.
5726 //     */
5727 //    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
5728 //        if (onDragTransferModeChanged == null) {
5729 //            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5730 //
5731 //                @Override
5732 //                protected void invalidated() {
5733 //                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
5734 //                }
5735 //            };
5736 //        }
5737 //        return onDragTransferModeChanged;
5738 //    }
5739 
5740     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
5741 
5742     public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
5743         onDragDroppedProperty().set(value);
5744     }
5745 
5746     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
5747         return onDragDropped == null ? null : onDragDropped.get();
5748     }
5749 
5750     /**
5751      * Defines a function to be called when the mouse button is released
5752      * on this {@code Scene} during drag and drop gesture. Transfer of data from
5753      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
5754      * happen in this function.
5755      * @return the function to be called when the mouse button is released on
5756      * this scene during drag and drop gesture
5757      */
5758     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
5759         if (onDragDropped == null) {
5760             onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5761 
5762                 @Override
5763                 protected void invalidated() {
5764                     setEventHandler(DragEvent.DRAG_DROPPED, get());
5765                 }
5766 
5767                 @Override
5768                 public Object getBean() {
5769                     return Scene.this;
5770                 }
5771 
5772                 @Override
5773                 public String getName() {
5774                     return &quot;onDragDropped&quot;;
5775                 }
5776             };
5777         }
5778         return onDragDropped;
5779     }
5780 
5781     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
5782 
5783     public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
5784         onDragDoneProperty().set(value);
5785     }
5786 
5787     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
5788         return onDragDone == null ? null : onDragDone.get();
5789     }
5790 
5791     /**
5792      * Defines a function to be called when this {@code Scene} is a
5793      * drag and drop gesture source after its data has
5794      * been dropped on a drop target. The {@code transferMode} of the
5795      * event shows what just happened at the drop target.
5796      * If {@code transferMode} has the value {@code MOVE}, then the source can
5797      * clear out its data. Clearing the source&#39;s data gives the appropriate
5798      * appearance to a user that the data has been moved by the drag and drop
5799      * gesture. A {@code transferMode} that has the value {@code NONE}
5800      * indicates that no data was transferred during the drag and drop gesture.
5801      * Positional data for the {@code DragEvent} is invalid.  Valid positional
5802      * data for the {@code DragEvent} is presented in the
5803      * {@link #onDragDroppedProperty() onDragDropped} event handler.
5804      * @return the function to be called when this scene is a drag and drop
5805      * gesture source after its data has been dropped on a drop target
5806      */
5807     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
5808         if (onDragDone == null) {
5809             onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5810 
5811                 @Override
5812                 protected void invalidated() {
5813                     setEventHandler(DragEvent.DRAG_DONE, get());
5814                 }
5815 
5816                 @Override
5817                 public Object getBean() {
5818                     return Scene.this;
5819                 }
5820 
5821                 @Override
5822                 public String getName() {
5823                     return &quot;onDragDone&quot;;
5824                 }
5825             };
5826         }
5827         return onDragDone;
5828     }
5829 
5830     /**
5831      * Confirms a potential drag and drop gesture that is recognized over this
5832      * {@code Scene}.
5833      * Can be called only from a DRAG_DETECTED event handler. The returned
5834      * {@link Dragboard} is used to transfer data during
5835      * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
5836      * {@link Dragboard} also identifies this {@code Scene} as the source of
5837      * the drag and drop gesture.
5838      * More detail about drag and drop gestures is described in the overivew
5839      * of {@link DragEvent}.
5840      *
5841      * @see DragEvent
5842      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
5843      * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
5844      * @throws IllegalStateException if drag and drop cannot be started at this
5845      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
5846      */
5847     public Dragboard startDragAndDrop(TransferMode... transferModes) {
5848         return startDragAndDrop(this, transferModes);
5849     }
5850 
5851     /**
5852      * Starts a full press-drag-release gesture with this scene as gesture
5853      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
5854      * event handler. More detail about dragging gestures can be found
5855      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
5856      *
5857      * @see MouseEvent
5858      * @see MouseDragEvent
5859      * @throws IllegalStateException if the full press-drag-release gesture
5860      * cannot be started at this moment (it&#39;s called outside of
5861      * {@code DRAG_DETECTED} event handling).
5862      * @since JavaFX 2.1
5863      */
5864     public void startFullDrag() {
5865         startFullDrag(this);
5866     }
5867 
5868 
5869     Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
5870         Toolkit.getToolkit().checkFxUserThread();
5871         if (dndGesture == null ||
5872             (dndGesture.dragDetected != DragDetectedState.PROCESSING))
5873         {
5874             throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
5875                     &quot;outside of DRAG_DETECTED event handler&quot;);
5876         }
5877 
5878         Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
5879         for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
5880             set.add(tm);
5881         }
5882         return dndGesture.startDrag(source, set);
5883     }
5884 
5885     void startFullDrag(EventTarget source) {
5886         Toolkit.getToolkit().checkFxUserThread();
5887         if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
5888             throw new IllegalStateException(&quot;Cannot start full drag &quot; +
5889                     &quot;outside of DRAG_DETECTED event handler&quot;);
5890         }
5891 
5892         if (dndGesture != null) {
5893             dndGesture.startFullPDR(source);
5894             return;
5895         }
5896 
5897         throw new IllegalStateException(&quot;Cannot start full drag when &quot;
5898                 + &quot;mouse button is not pressed&quot;);
5899     }
5900 
5901     /***************************************************************************
5902      *                                                                         *
5903      *                           Keyboard Handling                             *
5904      *                                                                         *
5905      **************************************************************************/
5906 
5907     /**
5908      * Defines a function to be called when some {@code Node} of this
5909      * {@code Scene} has input focus and a key has been pressed. The function
5910      * is called only if the event hasn&#39;t been already consumed during its
5911      * capturing or bubbling phase.
5912      */
5913     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
5914 
5915     public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
5916         onKeyPressedProperty().set(value);
5917     }
5918 
5919     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
5920         return onKeyPressed == null ? null : onKeyPressed.get();
5921     }
5922 
5923     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
5924         if (onKeyPressed == null) {
5925             onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5926 
5927                 @Override
5928                 protected void invalidated() {
5929                     setEventHandler(KeyEvent.KEY_PRESSED, get());
5930                 }
5931 
5932                 @Override
5933                 public Object getBean() {
5934                     return Scene.this;
5935                 }
5936 
5937                 @Override
5938                 public String getName() {
5939                     return &quot;onKeyPressed&quot;;
5940                 }
5941             };
5942         }
5943         return onKeyPressed;
5944     }
5945 
5946     /**
5947      * Defines a function to be called when some {@code Node} of this
5948      * {@code Scene} has input focus and a key has been released. The function
5949      * is called only if the event hasn&#39;t been already consumed during its
5950      * capturing or bubbling phase.
5951      */
5952     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
5953 
5954     public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
5955         onKeyReleasedProperty().set(value);
5956     }
5957 
5958     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
5959         return onKeyReleased == null ? null : onKeyReleased.get();
5960     }
5961 
5962     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
5963         if (onKeyReleased == null) {
5964             onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5965 
5966                 @Override
5967                 protected void invalidated() {
5968                     setEventHandler(KeyEvent.KEY_RELEASED, get());
5969                 }
5970 
5971                 @Override
5972                 public Object getBean() {
5973                     return Scene.this;
5974                 }
5975 
5976                 @Override
5977                 public String getName() {
5978                     return &quot;onKeyReleased&quot;;
5979                 }
5980             };
5981         }
5982         return onKeyReleased;
5983     }
5984 
5985     /**
5986      * Defines a function to be called when some {@code Node} of this
5987      * {@code Scene} has input focus and a key has been typed. The function
5988      * is called only if the event hasn&#39;t been already consumed during its
5989      * capturing or bubbling phase.
5990      */
5991     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
5992 
5993     public final void setOnKeyTyped(
5994             EventHandler&lt;? super KeyEvent&gt; value) {
5995         onKeyTypedProperty().set( value);
5996 
5997     }
5998 
5999     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
6000             ) {
6001         return onKeyTyped == null ? null : onKeyTyped.get();
6002     }
6003 
6004     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
6005     ) {
6006         if (onKeyTyped == null) {
6007             onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6008 
6009                 @Override
6010                 protected void invalidated() {
6011                     setEventHandler(KeyEvent.KEY_TYPED, get());
6012                 }
6013 
6014                 @Override
6015                 public Object getBean() {
6016                     return Scene.this;
6017                 }
6018 
6019                 @Override
6020                 public String getName() {
6021                     return &quot;onKeyTyped&quot;;
6022                 }
6023             };
6024         }
6025         return onKeyTyped;
6026     }
6027 
6028     /***************************************************************************
6029      *                                                                         *
6030      *                           Input Method Handling                         *
6031      *                                                                         *
6032      **************************************************************************/
6033 
6034     /**
6035      * Defines a function to be called when this {@code Node}
6036      * has input focus and the input method text has changed.  If this
6037      * function is not defined in this {@code Node}, then it
6038      * receives the result string of the input method composition as a
6039      * series of {@code onKeyTyped} function calls.
6040      * &lt;p&gt;
6041      * When the {@code Node} loses the input focus, the JavaFX runtime
6042      * automatically commits the existing composed text if any.
6043      */
6044     private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
6045 
6046     public final void setOnInputMethodTextChanged(
6047             EventHandler&lt;? super InputMethodEvent&gt; value) {
6048         onInputMethodTextChangedProperty().set( value);
6049     }
6050 
6051     public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
6052         return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
6053     }
6054 
6055     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
6056         if (onInputMethodTextChanged == null) {
6057             onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {
6058 
6059                 @Override
6060                 protected void invalidated() {
6061                     setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
6062                 }
6063 
6064                 @Override
6065                 public Object getBean() {
6066                     return Scene.this;
6067                 }
6068 
6069                 @Override
6070                 public String getName() {
6071                     return &quot;onInputMethodTextChanged&quot;;
6072                 }
6073             };
6074         }
6075         return onInputMethodTextChanged;
6076     }
6077 
6078     /*
6079      * This class represents a picked target - either node, or scne, or null.
6080      * It provides functionality needed for the targets and covers the fact
6081      * that they are different kinds of animals.
6082      */
6083     private static class TargetWrapper {
6084         private Scene scene;
6085         private Node node;
6086         private PickResult result;
6087 
6088         /**
6089          * Fills the list with the target and all its parents (including scene)
6090          */
6091         public void fillHierarchy(final List&lt;EventTarget&gt; list) {
6092             list.clear();
6093             Node n = node;
6094             while(n != null) {
6095                 list.add(n);
6096                 final Parent p = n.getParent();
6097                 n = p != null ? p : n.getSubScene();
6098             }
6099 
6100             if (scene != null) {
6101                 list.add(scene);
6102             }
6103         }
6104 
6105         public EventTarget getEventTarget() {
6106             return node != null ? node : scene;
6107         }
6108 
6109         public Cursor getCursor() {
6110             Cursor cursor = null;
6111             if (node != null) {
6112                 cursor = node.getCursor();
6113                 Node n = node.getParent();
6114                 while (cursor == null &amp;&amp; n != null) {
6115                     cursor = n.getCursor();
6116 
6117                     final Parent p = n.getParent();
6118                     n = p != null ? p : n.getSubScene();
6119                 }
6120             }
6121             return cursor;
6122         }
6123 
6124         public void clear() {
6125             set(null, null);
6126             result = null;
6127         }
6128 
6129         public void setNodeResult(PickResult result) {
6130             if (result != null) {
6131                 this.result = result;
6132                 final Node n = result.getIntersectedNode();
6133                 set(n, n.getScene());
6134             }
6135         }
6136 
6137         // Pass null scene if the mouse is outside of the window content
6138         public void setSceneResult(PickResult result, Scene scene) {
6139             if (result != null) {
6140                 this.result = result;
6141                 set(null, scene);
6142             }
6143         }
6144 
6145         public PickResult getResult() {
6146             return result;
6147         }
6148 
6149         public void copy(TargetWrapper tw) {
6150             node = tw.node;
6151             scene = tw.scene;
6152             result = tw.result;
6153         }
6154 
6155         private void set(Node n, Scene s) {
6156             node = n;
6157             scene = s;
6158         }
6159     }
6160 
6161     /*************************************************************************
6162     *                                                                        *
6163     *                                                                        *
6164     *                                                                        *
6165     *************************************************************************/
6166 
6167     private static final Object USER_DATA_KEY = new Object();
6168     // A map containing a set of properties for this scene
6169     private ObservableMap&lt;Object, Object&gt; properties;
6170 
6171     /**
6172       * Returns an observable map of properties on this node for use primarily
6173       * by application developers.
6174       *
6175       * @return an observable map of properties on this node for use primarily
6176       * by application developers
6177       *
6178       * @since JavaFX 8u40
6179       */
6180      public final ObservableMap&lt;Object, Object&gt; getProperties() {
6181         if (properties == null) {
6182             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
6183         }
6184         return properties;
6185     }
6186 
6187     /**
6188      * Tests if Scene has properties.
6189      * @return true if node has properties.
6190      *
6191      * @since JavaFX 8u40
6192      */
6193      public boolean hasProperties() {
6194         return properties != null &amp;&amp; !properties.isEmpty();
6195     }
6196 
6197     /**
6198      * Convenience method for setting a single Object property that can be
6199      * retrieved at a later date. This is functionally equivalent to calling
6200      * the getProperties().put(Object key, Object value) method. This can later
6201      * be retrieved by calling {@link Scene#getUserData()}.
6202      *
6203      * @param value The value to be stored - this can later be retrieved by calling
6204      *          {@link Scene#getUserData()}.
6205      *
6206      * @since JavaFX 8u40
6207      */
6208     public void setUserData(Object value) {
6209         getProperties().put(USER_DATA_KEY, value);
6210     }
6211 
6212     /**
6213      * Returns a previously set Object property, or null if no such property
6214      * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
6215      *
6216      * @return The Object that was previously set, or null if no property
6217      *          has been set or if null was set.
6218      *
6219      * @since JavaFX 8u40
6220      */
6221     public Object getUserData() {
6222         return getProperties().get(USER_DATA_KEY);
6223     }
6224 
6225     /***************************************************************************
6226      *                                                                         *
6227      *                       Component Orientation Properties                  *
6228      *                                                                         *
6229      **************************************************************************/
6230 
6231     private static final NodeOrientation defaultNodeOrientation =
6232         AccessController.doPrivileged(
6233                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;
6234 
6235 
6236 
6237     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
6238     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
6239 
6240     private NodeOrientation effectiveNodeOrientation;
6241 
6242     public final void setNodeOrientation(NodeOrientation orientation) {
6243         nodeOrientationProperty().set(orientation);
6244     }
6245 
6246     public final NodeOrientation getNodeOrientation() {
6247         return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
6248     }
6249 
6250     /**
6251      * Property holding NodeOrientation.
6252      * &lt;p&gt;
6253      * Node orientation describes the flow of visual data within a node.
6254      * In the English speaking world, visual data normally flows from
6255      * left-to-right. In an Arabic or Hebrew world, visual data flows
6256      * from right-to-left.  This is consistent with the reading order
6257      * of text in both worlds.  The default value is left-to-right.
6258      * &lt;/p&gt;
6259      *
6260      * @return NodeOrientation
6261      * @since JavaFX 8.0
6262      */
6263     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
6264         if (nodeOrientation == null) {
6265             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
6266                 @Override
6267                 protected void invalidated() {
6268                     sceneEffectiveOrientationInvalidated();
6269                     getRoot().applyCss();
6270                 }
6271 
6272                 @Override
6273                 public Object getBean() {
6274                     return Scene.this;
6275                 }
6276 
6277                 @Override
6278                 public String getName() {
6279                     return &quot;nodeOrientation&quot;;
6280                 }
6281 
6282                 @Override
6283                 public CssMetaData getCssMetaData() {
6284                     //TODO - not yet supported
6285                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
6286                 }
6287             };
6288         }
6289         return nodeOrientation;
6290     }
6291 
6292     public final NodeOrientation getEffectiveNodeOrientation() {
6293         if (effectiveNodeOrientation == null) {
6294             effectiveNodeOrientation = calcEffectiveNodeOrientation();
6295         }
6296 
6297         return effectiveNodeOrientation;
6298     }
6299 
6300     /**
6301      * The effective node orientation of a scene resolves the inheritance of
6302      * node orientation, returning either left-to-right or right-to-left.
6303      * @return the effective node orientation of this scene
6304      * @since JavaFX 8.0
6305      */
6306     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
6307             effectiveNodeOrientationProperty() {
6308         if (effectiveNodeOrientationProperty == null) {
6309             effectiveNodeOrientationProperty =
6310                     new EffectiveOrientationProperty();
6311         }
6312 
6313         return effectiveNodeOrientationProperty;
6314     }
6315 
6316     private void parentEffectiveOrientationInvalidated() {
6317         if (getNodeOrientation() == NodeOrientation.INHERIT) {
6318             sceneEffectiveOrientationInvalidated();
6319         }
6320     }
6321 
6322     private void sceneEffectiveOrientationInvalidated() {
6323         effectiveNodeOrientation = null;
6324 
6325         if (effectiveNodeOrientationProperty != null) {
6326             effectiveNodeOrientationProperty.invalidate();
6327         }
6328 
6329         getRoot().parentResolvedOrientationInvalidated();
6330     }
6331 
6332     private NodeOrientation calcEffectiveNodeOrientation() {
6333         NodeOrientation orientation = getNodeOrientation();
6334         if (orientation == NodeOrientation.INHERIT) {
6335             Window window = getWindow();
6336             if (window != null) {
6337                 Window parent = null;
6338                 if (window instanceof Stage) {
6339                     parent = ((Stage)window).getOwner();
6340                 } else {
6341                     if (window instanceof PopupWindow) {
6342                         parent = ((PopupWindow)window).getOwnerWindow();
6343                     }
6344                 }
6345                 if (parent != null) {
6346                     Scene scene = parent.getScene();
6347                     if (scene != null) return scene.getEffectiveNodeOrientation();
6348                 }
6349             }
6350             return NodeOrientation.LEFT_TO_RIGHT;
6351         }
6352         return orientation;
6353     }
6354 
6355     private final class EffectiveOrientationProperty
6356             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
6357         @Override
6358         public NodeOrientation get() {
6359             return getEffectiveNodeOrientation();
6360         }
6361 
6362         @Override
6363         public Object getBean() {
6364             return Scene.this;
6365         }
6366 
6367         @Override
6368         public String getName() {
6369             return &quot;effectiveNodeOrientation&quot;;
6370         }
6371 
6372         public void invalidate() {
6373             fireValueChangedEvent();
6374         }
6375     }
6376 
6377     private Map&lt;Node, Accessible&gt; accMap;
6378     Accessible removeAccessible(Node node) {
6379         if (accMap == null) return null;
6380         return accMap.remove(node);
6381     }
6382 
6383     void addAccessible(Node node, Accessible acc) {
6384         if (accMap == null) {
6385             accMap = new HashMap&lt;Node, Accessible&gt;();
6386         }
6387         accMap.put(node, acc);
6388     }
6389 
6390     private void disposeAccessibles() {
6391         if (accMap != null) {
6392             for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
6393                 Node node = entry.getKey();
6394                 Accessible acc = entry.getValue();
6395                 if (node.accessible != null) {
6396                     /* This node has already been initialized to another scene.
6397                      * Note an accessible can be returned to the node before the
6398                      * pulse if getAccessible() is called. In which case it must
6399                      * already being removed from accMap.
6400                      */
6401                     if (node.accessible == acc) {
6402                         System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);
6403                     }
6404                     if (node.getScene() == this) {
6405                         System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);
6406                     }
6407                     acc.dispose();
6408                 } else {
6409                     if (node.getScene() == this) {
6410                         node.accessible = acc;
6411                     } else {
6412                         acc.dispose();
6413                     }
6414                 }
6415             }
6416             accMap.clear();
6417         }
6418     }
6419 
6420     private Accessible accessible;
6421     Accessible getAccessible() {
6422         /*
6423          * The accessible for the Scene should never be
6424          * requested when the peer is not set.
6425          * This can only happen in a error case where a
6426          * descender of this Scene was not disposed and
6427          * it still being used by the AT client and trying
6428          * to reach to the top level window.
6429          */
6430         if (peer == null) return null;
6431         if (accessible == null) {
6432             accessible = Application.GetApplication().createAccessible();
6433             accessible.setEventHandler(new Accessible.EventHandler() {
6434                 @Override public AccessControlContext getAccessControlContext() {
6435                     return getPeer().getAccessControlContext();
6436                 }
6437 
6438                 @Override public Object getAttribute(AccessibleAttribute attribute,
6439                                                      Object... parameters) {
6440                     switch (attribute) {
6441                         case CHILDREN: {
6442                             Parent root = getRoot();
6443                             if (root != null) {
6444                                 return FXCollections.observableArrayList(root);
6445                             }
6446                             break;
6447                         }
6448                         case TEXT: {
6449                             Window w = getWindow();
6450                             if (w instanceof Stage) {
6451                                 return ((Stage)w).getTitle();
6452                             }
6453                             break;
6454                         }
6455                         case NODE_AT_POINT: {
6456                             Window window = getWindow();
6457                             /* is this screen to scene translation correct ? not considering camera ? */
6458                             Point2D pt = (Point2D)parameters[0];
6459                             PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
6460                             if (res != null) {
6461                                 Node node = res.getIntersectedNode();
6462                                 if (node != null) return node;
6463                             }
6464                             return getRoot();//not sure
6465                         }
6466                         case ROLE: return AccessibleRole.PARENT;
6467                         case SCENE: return Scene.this;
6468                         case FOCUS_NODE: {
6469                             if (transientFocusContainer != null) {
6470                                 return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
6471                             }
6472                             return getFocusOwner();
6473                         }
6474                         default:
6475                     }
6476                     return super.getAttribute(attribute, parameters);
6477                 }
6478             });
6479             PlatformImpl.accessibilityActiveProperty().set(true);
6480         }
6481         return accessible;
6482     }
6483 }
    </pre>
  </body>
</html>