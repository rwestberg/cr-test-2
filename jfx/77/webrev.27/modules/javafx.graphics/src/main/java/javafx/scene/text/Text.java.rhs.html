<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/text/Text.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.text;
  27 
  28 import javafx.css.converter.BooleanConverter;
  29 import javafx.css.converter.EnumConverter;
  30 import javafx.css.converter.SizeConverter;
  31 import com.sun.javafx.geom.BaseBounds;
  32 import com.sun.javafx.geom.Path2D;
  33 import com.sun.javafx.geom.RectBounds;
  34 import com.sun.javafx.geom.TransformedShape;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.scene.DirtyBits;
  37 import com.sun.javafx.scene.NodeHelper;
  38 import com.sun.javafx.scene.shape.ShapeHelper;
  39 import com.sun.javafx.scene.shape.TextHelper;
  40 import com.sun.javafx.scene.text.GlyphList;
  41 import com.sun.javafx.scene.text.TextLayout;
  42 import com.sun.javafx.scene.text.TextLayoutFactory;
  43 import com.sun.javafx.scene.text.TextLine;
  44 import com.sun.javafx.scene.text.TextSpan;
  45 import com.sun.javafx.sg.prism.NGNode;
  46 import com.sun.javafx.sg.prism.NGShape;
  47 import com.sun.javafx.sg.prism.NGText;
  48 import com.sun.javafx.scene.text.FontHelper;
  49 import com.sun.javafx.tk.Toolkit;
  50 import javafx.beans.DefaultProperty;
  51 import javafx.beans.InvalidationListener;
  52 import javafx.beans.binding.DoubleBinding;
  53 import javafx.beans.binding.ObjectBinding;
  54 import javafx.scene.AccessibleAttribute;
  55 import javafx.scene.AccessibleRole;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.shape.LineTo;
  59 import javafx.scene.shape.MoveTo;
  60 import javafx.scene.shape.PathElement;
  61 import javafx.scene.shape.Shape;
  62 import javafx.scene.shape.StrokeType;
  63 import java.util.ArrayList;
  64 import java.util.Collections;
  65 import java.util.List;
  66 import javafx.beans.property.BooleanProperty;
  67 import javafx.beans.property.DoubleProperty;
  68 import javafx.beans.property.DoublePropertyBase;
  69 import javafx.beans.property.IntegerProperty;
  70 import javafx.beans.property.IntegerPropertyBase;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyDoubleProperty;
  74 import javafx.beans.property.ReadOnlyDoubleWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.property.StringProperty;
  79 import javafx.beans.property.StringPropertyBase;
  80 import javafx.css.CssMetaData;
  81 import javafx.css.FontCssMetaData;
  82 import javafx.css.Styleable;
  83 import javafx.css.StyleableBooleanProperty;
  84 import javafx.css.StyleableDoubleProperty;
  85 import javafx.css.StyleableIntegerProperty;
  86 import javafx.css.StyleableObjectProperty;
  87 import javafx.css.StyleableProperty;
  88 import javafx.geometry.BoundingBox;
  89 import javafx.geometry.Bounds;
  90 import javafx.geometry.NodeOrientation;
  91 import javafx.geometry.Point2D;
  92 import javafx.geometry.VPos;
  93 import javafx.scene.Node;
  94 
  95 /**
  96  * The {@code Text} class defines a node that displays a text.
  97  *
  98  * Paragraphs are separated by {@code &#39;\n&#39;} and the text is wrapped on
  99  * paragraph boundaries.
 100  *
 101 &lt;PRE&gt;
 102 import javafx.scene.text.*;
 103 
 104 Text t = new Text(10, 50, &quot;This is a test&quot;);
 105 t.setFont(new Font(20));
 106 &lt;/PRE&gt;
 107  *
 108 &lt;PRE&gt;
 109 import javafx.scene.text.*;
 110 
 111 Text t = new Text();
 112 text.setFont(new Font(20));
 113 text.setText(&quot;First row\nSecond row&quot;);
 114 &lt;/PRE&gt;
 115  *
 116 &lt;PRE&gt;
 117 import javafx.scene.text.*;
 118 
 119 Text t = new Text();
 120 text.setFont(new Font(20));
 121 text.setWrappingWidth(200);
 122 text.setTextAlignment(TextAlignment.JUSTIFY)
 123 text.setText(&quot;The quick brown fox jumps over the lazy dog&quot;);
 124 &lt;/PRE&gt;
 125  * @since JavaFX 2.0
 126  */
 127 @DefaultProperty(&quot;text&quot;)
 128 public class Text extends Shape {
 129     static {
 130         TextHelper.setTextAccessor(new TextHelper.TextAccessor() {
 131             @Override
 132             public NGNode doCreatePeer(Node node) {
 133                 return ((Text) node).doCreatePeer();
 134             }
 135 
 136             @Override
 137             public void doUpdatePeer(Node node) {
 138                 ((Text) node).doUpdatePeer();
 139             }
 140 
 141             @Override
 142             public Bounds doComputeLayoutBounds(Node node) {
 143                 return ((Text) node).doComputeLayoutBounds();
 144             }
 145 
 146             @Override
 147             public BaseBounds doComputeGeomBounds(Node node,
 148                     BaseBounds bounds, BaseTransform tx) {
 149                 return ((Text) node).doComputeGeomBounds(bounds, tx);
 150             }
 151 
 152             @Override
 153             public boolean doComputeContains(Node node, double localX, double localY) {
 154                 return ((Text) node).doComputeContains(localX, localY);
 155             }
 156 
 157             @Override
 158             public void doGeomChanged(Node node) {
 159                 ((Text) node).doGeomChanged();
 160             }
 161 
 162             @Override
 163             public com.sun.javafx.geom.Shape doConfigShape(Shape shape) {
 164                 return ((Text) shape).doConfigShape();
 165             }
 166         });
 167     }
 168 
 169     private TextLayout layout;
 170     private static final PathElement[] EMPTY_PATH_ELEMENT_ARRAY = new PathElement[0];
 171 
 172     {
 173         // To initialize the class helper at the begining each constructor of this class
 174         TextHelper.initHelper(this);
 175     }
 176 
 177     /**
 178      * Creates an empty instance of Text.
 179      */
 180     public Text() {
 181         setAccessibleRole(AccessibleRole.TEXT);
 182         InvalidationListener listener = observable -&gt; checkSpan();
 183         parentProperty().addListener(listener);
 184         managedProperty().addListener(listener);
 185         effectiveNodeOrientationProperty().addListener(observable -&gt; checkOrientation());
 186         setPickOnBounds(true);
 187     }
 188 
 189     /**
 190      * Creates an instance of Text containing the given string.
 191      * @param text text to be contained in the instance
 192      */
 193     public Text(String text) {
 194         this();
 195         setText(text);
 196     }
 197 
 198     /**
 199      * Creates an instance of Text on the given coordinates containing the
 200      * given string.
 201      * @param x the horizontal position of the text
 202      * @param y the vertical position of the text
 203      * @param text text to be contained in the instance
 204      */
 205     public Text(double x, double y, String text) {
 206         this(text);
 207         setX(x);
 208         setY(y);
 209     }
 210 
 211     /*
 212      * Note: This method MUST only be called via its accessor method.
 213      */
 214     private NGNode doCreatePeer() {
 215         return new NGText();
 216     }
 217 
 218     private boolean isSpan;
 219     private boolean isSpan() {
 220         return isSpan;
 221     }
 222 
 223     private void checkSpan() {
 224         isSpan = isManaged() &amp;&amp; getParent() instanceof TextFlow;
 225         if (isSpan() &amp;&amp; !pickOnBoundsProperty().isBound()) {
 226             /* Documented behavior. See class description for TextFlow */
 227             setPickOnBounds(false);
 228         }
 229     }
 230 
 231     private void checkOrientation() {
 232         if (!isSpan()) {
 233             NodeOrientation orientation = getEffectiveNodeOrientation();
 234             boolean rtl =  orientation == NodeOrientation.RIGHT_TO_LEFT;
 235             int dir = rtl ? TextLayout.DIRECTION_RTL : TextLayout.DIRECTION_LTR;
 236             TextLayout layout = getTextLayout();
 237             if (layout.setDirection(dir)) {
 238                 needsTextLayout();
 239             }
 240         }
 241     }
 242 
 243     @Override
 244     public boolean usesMirroring() {
 245         return false;
 246     }
 247 
 248     private void needsFullTextLayout() {
 249         if (isSpan()) {
 250             /* Create new text span every time the font or text changes
 251              * so the text layout can see that the content has changed.
 252              */
 253             textSpan = null;
 254 
 255             /* Relies on NodeHelper.geomChanged(this) to request text flow to relayout */
 256         } else {
 257             TextLayout layout = getTextLayout();
 258             String string = getTextInternal();
 259             Object font = getFontInternal();
 260             layout.setContent(string, font);
 261         }
 262         needsTextLayout();
 263     }
 264 
 265     private void needsTextLayout() {
 266         textRuns = null;
 267         NodeHelper.geomChanged(this);
 268         NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
 269     }
 270 
 271     private TextSpan textSpan;
 272     TextSpan getTextSpan() {
 273         if (textSpan == null) {
 274             textSpan = new TextSpan() {
 275                 @Override public String getText() {
 276                     return getTextInternal();
 277                 }
 278                 @Override public Object getFont() {
 279                     return getFontInternal();
 280                 }
 281                 @Override public RectBounds getBounds() {
 282                     return null;
 283                 }
 284             };
 285         }
 286         return textSpan;
 287     }
 288 
 289     private TextLayout getTextLayout() {
 290         if (isSpan()) {
 291             layout = null;
 292             TextFlow parent = (TextFlow)getParent();
 293             return parent.getTextLayout();
 294         }
 295         if (layout == null) {
 296             TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
 297             layout = factory.createLayout();
 298             String string = getTextInternal();
 299             Object font = getFontInternal();
 300             TextAlignment alignment = getTextAlignment();
 301             if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
 302             layout.setContent(string, font);
 303             layout.setAlignment(alignment.ordinal());
 304             layout.setLineSpacing((float)getLineSpacing());
 305             layout.setWrapWidth((float)getWrappingWidth());
 306             if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 307                 layout.setDirection(TextLayout.DIRECTION_RTL);
 308             } else {
 309                 layout.setDirection(TextLayout.DIRECTION_LTR);
 310             }
 311             layout.setTabSize(getTabSize());
 312         }
 313         return layout;
 314     }
 315 
 316     private GlyphList[] textRuns = null;
 317     private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
 318     private boolean spanBoundsInvalid = true;
 319 
 320     void layoutSpan(GlyphList[] runs) {
 321         TextSpan span = getTextSpan();
 322         int count = 0;
 323         for (int i = 0; i &lt; runs.length; i++) {
 324             GlyphList run = runs[i];
 325             if (run.getTextSpan() == span) {
 326                 count++;
 327             }
 328         }
 329         textRuns = new GlyphList[count];
 330         count = 0;
 331         for (int i = 0; i &lt; runs.length; i++) {
 332             GlyphList run = runs[i];
 333             if (run.getTextSpan() == span) {
 334                 textRuns[count++] = run;
 335             }
 336         }
 337         spanBoundsInvalid = true;
 338 
 339         /* Sometimes a property change in the text node will causes layout in
 340          * text flow. In this case all the dirty bits are already clear and no
 341          * extra work is necessary. Other times the layout is caused by changes
 342          * in the text flow object (wrapping width and text alignment for example).
 343          * In the second case the dirty bits must be set here using
 344          * NodeHelper.geomChanged(this) and NodeHelper.markDirty(). Note that NodeHelper.geomChanged(this)
 345          * causes another (undesired) layout request in the parent.
 346          * In general this is not a problem because shapes are not resizable and
 347          * region objects do not propagate layout changes to the parent.
 348          * This is a special case where a shape is resized by the parent during
 349          * layoutChildren(). See TextFlow#requestLayout() for information how
 350          * text flow deals with this situation.
 351          */
 352         NodeHelper.geomChanged(this);
 353         NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
 354     }
 355 
 356     BaseBounds getSpanBounds() {
 357         if (spanBoundsInvalid) {
 358             GlyphList[] runs = getRuns();
 359             if (runs.length != 0) {
 360                 float left = Float.POSITIVE_INFINITY;
 361                 float top = Float.POSITIVE_INFINITY;
 362                 float right = 0;
 363                 float bottom = 0;
 364                 for (int i = 0; i &lt; runs.length; i++) {
 365                     GlyphList run = runs[i];
 366                     com.sun.javafx.geom.Point2D location = run.getLocation();
 367                     float width = run.getWidth();
 368                     float height = run.getLineBounds().getHeight();
 369                     left = Math.min(location.x, left);
 370                     top = Math.min(location.y, top);
 371                     right = Math.max(location.x + width, right);
 372                     bottom = Math.max(location.y + height, bottom);
 373                 }
 374                 spanBounds = spanBounds.deriveWithNewBounds(left, top, 0,
 375                                                             right, bottom, 0);
 376             } else {
 377                 spanBounds = spanBounds.makeEmpty();
 378             }
 379             spanBoundsInvalid = false;
 380         }
 381         return spanBounds;
 382     }
 383 
 384     private GlyphList[] getRuns() {
 385         if (textRuns != null) return textRuns;
 386         if (isSpan()) {
 387             /* List of run is initialized when the TextFlow layout the children */
 388             getParent().layout();
 389         } else {
 390             TextLayout layout = getTextLayout();
 391             textRuns = layout.getRuns();
 392         }
 393         return textRuns;
 394     }
 395 
 396     private com.sun.javafx.geom.Shape getShape() {
 397         TextLayout layout = getTextLayout();
 398         /* TextLayout has the text shape cached */
 399         int type = TextLayout.TYPE_TEXT;
 400         if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
 401         if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
 402 
 403         TextSpan filter = null;
 404         if (isSpan()) {
 405             /* Spans are always relative to the top */
 406             type |= TextLayout.TYPE_TOP;
 407             filter = getTextSpan();
 408         } else {
 409             /* Relative to baseline (first line)
 410              * This shape can be translate in the y axis according
 411              * to text origin, see ShapeHelper.configShape().
 412              */
 413             type |= TextLayout.TYPE_BASELINE;
 414         }
 415         return layout.getShape(type, filter);
 416     }
 417 
 418     private BaseBounds getVisualBounds() {
 419         if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
 420             int type = TextLayout.TYPE_TEXT;
 421             if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
 422             if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
 423             return getTextLayout().getVisualBounds(type);
 424         } else {
 425             return getShape().getBounds();
 426         }
 427     }
 428 
 429     private BaseBounds getLogicalBounds() {
 430         TextLayout layout = getTextLayout();
 431         /* TextLayout has the bounds cached */
 432         return layout.getBounds();
 433     }
 434 
 435     /**
 436      * Defines text string that is to be displayed.
 437      *
 438      * @defaultValue empty string
 439      */
 440     private StringProperty text;
 441 
 442     public final void setText(String value) {
 443         if (value == null) value = &quot;&quot;;
 444         textProperty().set(value);
 445     }
 446 
 447     public final String getText() {
 448         return text == null ? &quot;&quot; : text.get();
 449     }
 450 
 451     private String getTextInternal() {
 452         // this might return null in case of bound property
 453         String localText = getText();
 454         return localText == null ? &quot;&quot; : localText;
 455     }
 456 
 457     public final StringProperty textProperty() {
 458         if (text == null) {
 459             text = new StringPropertyBase(&quot;&quot;) {
 460                 @Override public Object getBean() { return Text.this; }
 461                 @Override public String getName() { return &quot;text&quot;; }
 462                 @Override  public void invalidated() {
 463                     needsFullTextLayout();
 464                     setSelectionStart(-1);
 465                     setSelectionEnd(-1);
 466                     setCaretPosition(-1);
 467                     setCaretBias(true);
 468 
 469                     // MH: Functionality copied from store() method,
 470                     // which was removed.
 471                     // Wonder what should happen if text is bound
 472                     //  and becomes null?
 473                     final String value = get();
 474                     if ((value == null) &amp;&amp; !isBound()) {
 475                         set(&quot;&quot;);
 476                     }
 477                     notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
 478                 }
 479             };
 480         }
 481         return text;
 482     }
 483 
 484     /**
 485      * Defines the X coordinate of text origin.
 486      *
 487      * @defaultValue 0
 488      */
 489     private DoubleProperty x;
 490 
 491     public final void setX(double value) {
 492         xProperty().set(value);
 493     }
 494 
 495     public final double getX() {
 496         return x == null ? 0.0 : x.get();
 497     }
 498 
 499     public final DoubleProperty xProperty() {
 500         if (x == null) {
 501             x = new DoublePropertyBase() {
 502                 @Override public Object getBean() { return Text.this; }
 503                 @Override public String getName() { return &quot;x&quot;; }
 504                 @Override public void invalidated() {
 505                     NodeHelper.geomChanged(Text.this);
 506                 }
 507             };
 508         }
 509         return x;
 510     }
 511 
 512     /**
 513      * Defines the Y coordinate of text origin.
 514      *
 515      * @defaultValue 0
 516      */
 517     private DoubleProperty y;
 518 
 519     public final void setY(double value) {
 520         yProperty().set(value);
 521     }
 522 
 523     public final double getY() {
 524         return y == null ? 0.0 : y.get();
 525     }
 526 
 527     public final DoubleProperty yProperty() {
 528         if (y == null) {
 529             y = new DoublePropertyBase() {
 530                 @Override public Object getBean() { return Text.this; }
 531                 @Override public String getName() { return &quot;y&quot;; }
 532                 @Override public void invalidated() {
 533                     NodeHelper.geomChanged(Text.this);
 534                 }
 535             };
 536         }
 537         return y;
 538     }
 539 
 540     /**
 541      * Defines the font of text.
 542      *
 543      * @defaultValue Font{}
 544      */
 545     private ObjectProperty&lt;Font&gt; font;
 546 
 547     public final void setFont(Font value) {
 548         fontProperty().set(value);
 549     }
 550 
 551     public final Font getFont() {
 552         return font == null ? Font.getDefault() : font.get();
 553     }
 554 
 555     /**
 556      * Internally used safe version of getFont which never returns null.
 557      *
 558      * @return the font
 559      */
 560     private Object getFontInternal() {
 561         Font font = getFont();
 562         if (font == null) font = Font.getDefault();
 563         return FontHelper.getNativeFont(font);
 564     }
 565 
 566     public final ObjectProperty&lt;Font&gt; fontProperty() {
 567         if (font == null) {
 568             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 569                 @Override public Object getBean() { return Text.this; }
 570                 @Override public String getName() { return &quot;font&quot;; }
 571                 @Override public CssMetaData&lt;Text,Font&gt; getCssMetaData() {
 572                     return StyleableProperties.FONT;
 573                 }
 574                 @Override public void invalidated() {
 575                     needsFullTextLayout();
 576                     NodeHelper.markDirty(Text.this, DirtyBits.TEXT_FONT);
 577                 }
 578             };
 579         }
 580         return font;
 581     }
 582 
 583     public final void setTextOrigin(VPos value) {
 584         textOriginProperty().set(value);
 585     }
 586 
 587     public final VPos getTextOrigin() {
 588         if (attributes == null || attributes.textOrigin == null) {
 589             return DEFAULT_TEXT_ORIGIN;
 590         }
 591         return attributes.getTextOrigin();
 592     }
 593 
 594     /**
 595      * Defines the origin of text coordinate system in local coordinates.
 596      * Note: in case multiple rows are rendered {@code VPos.BASELINE} and
 597      * {@code VPos.TOP} define the origin of the top row while
 598      * {@code VPos.BOTTOM} defines the origin of the bottom row.
 599      *
 600      * @return the origin of text coordinate system in local coordinates
 601      * @defaultValue VPos.BASELINE
 602      */
 603     public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
 604         return getTextAttribute().textOriginProperty();
 605     }
 606 
 607     /**
 608      * Determines how the bounds of the text node are calculated.
 609      * Logical bounds is a more appropriate default for text than
 610      * the visual bounds. See {@code TextBoundsType} for more information.
 611      *
 612      * @defaultValue TextBoundsType.LOGICAL
 613      */
 614     private ObjectProperty&lt;TextBoundsType&gt; boundsType;
 615 
 616     public final void setBoundsType(TextBoundsType value) {
 617         boundsTypeProperty().set(value);
 618     }
 619 
 620     public final TextBoundsType getBoundsType() {
 621         return boundsType == null ?
 622             DEFAULT_BOUNDS_TYPE : boundsTypeProperty().get();
 623     }
 624 
 625     public final ObjectProperty&lt;TextBoundsType&gt; boundsTypeProperty() {
 626         if (boundsType == null) {
 627             boundsType =
 628                new StyleableObjectProperty&lt;TextBoundsType&gt;(DEFAULT_BOUNDS_TYPE) {
 629                    @Override public Object getBean() { return Text.this; }
 630                    @Override public String getName() { return &quot;boundsType&quot;; }
 631                    @Override public CssMetaData&lt;Text,TextBoundsType&gt; getCssMetaData() {
 632                        return StyleableProperties.BOUNDS_TYPE;
 633                    }
 634                    @Override public void invalidated() {
 635                        TextLayout layout = getTextLayout();
 636                        int type = 0;
 637                        if (boundsType.get() == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
 638                            type |= TextLayout.BOUNDS_CENTER;
 639                        }
 640                        if (layout.setBoundsType(type)) {
 641                            needsTextLayout();
 642                        } else {
 643                            NodeHelper.geomChanged(Text.this);
 644                        }
 645                    }
 646             };
 647         }
 648         return boundsType;
 649     }
 650 
 651     /**
 652      * Defines a width constraint for the text in user space coordinates.
 653      * The width is measured in pixels (and not glyph or character count).
 654      * If the value is {@code &gt; 0} text will be line wrapped as needed
 655      * to satisfy this constraint.
 656      *
 657      * @defaultValue 0
 658      */
 659     private DoubleProperty wrappingWidth;
 660 
 661     public final void setWrappingWidth(double value) {
 662         wrappingWidthProperty().set(value);
 663     }
 664 
 665     public final double getWrappingWidth() {
 666         return wrappingWidth == null ? 0 : wrappingWidth.get();
 667     }
 668 
 669     public final DoubleProperty wrappingWidthProperty() {
 670         if (wrappingWidth == null) {
 671             wrappingWidth = new DoublePropertyBase() {
 672                 @Override public Object getBean() { return Text.this; }
 673                 @Override public String getName() { return &quot;wrappingWidth&quot;; }
 674                 @Override public void invalidated() {
 675                     if (!isSpan()) {
 676                         TextLayout layout = getTextLayout();
 677                         if (layout.setWrapWidth((float)get())) {
 678                             needsTextLayout();
 679                         } else {
 680                             NodeHelper.geomChanged(Text.this);
 681                         }
 682                     }
 683                 }
 684             };
 685         }
 686         return wrappingWidth;
 687     }
 688 
 689     public final void setUnderline(boolean value) {
 690         underlineProperty().set(value);
 691     }
 692 
 693     public final boolean isUnderline() {
 694         if (attributes == null || attributes.underline == null) {
 695             return DEFAULT_UNDERLINE;
 696         }
 697         return attributes.isUnderline();
 698     }
 699 
 700     /**
 701      * Defines if each line of text should have a line below it.
 702      *
 703      * @return if each line of text should have a line below it
 704      * @defaultValue false
 705      */
 706     public final BooleanProperty underlineProperty() {
 707         return getTextAttribute().underlineProperty();
 708     }
 709 
 710     public final void setStrikethrough(boolean value) {
 711         strikethroughProperty().set(value);
 712     }
 713 
 714     public final boolean isStrikethrough() {
 715         if (attributes == null || attributes.strikethrough == null) {
 716             return DEFAULT_STRIKETHROUGH;
 717         }
 718         return attributes.isStrikethrough();
 719     }
 720 
 721     /**
 722      * Defines if each line of text should have a line through it.
 723      *
 724      * @return if each line of text should have a line through it
 725      * @defaultValue false
 726      */
 727     public final BooleanProperty strikethroughProperty() {
 728         return getTextAttribute().strikethroughProperty();
 729     }
 730 
 731     public final void setTextAlignment(TextAlignment value) {
 732         textAlignmentProperty().set(value);
 733     }
 734 
 735     public final TextAlignment getTextAlignment() {
 736         if (attributes == null || attributes.textAlignment == null) {
 737             return DEFAULT_TEXT_ALIGNMENT;
 738         }
 739         return attributes.getTextAlignment();
 740     }
 741 
 742     /**
 743      * Defines horizontal text alignment in the bounding box.
 744      *
 745      * The width of the bounding box is defined by the widest row.
 746      *
 747      * Note: In the case of a single line of text, where the width of the
 748      * node is determined by the width of the text, the alignment setting
 749      * has no effect.
 750      *
 751      * @return the horizontal text alignment in the bounding box
 752      * @defaultValue TextAlignment.LEFT
 753      */
 754     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 755         return getTextAttribute().textAlignmentProperty();
 756     }
 757 
 758     public final void setLineSpacing(double spacing) {
 759         lineSpacingProperty().set(spacing);
 760     }
 761 
 762     public final double getLineSpacing() {
 763         if (attributes == null || attributes.lineSpacing == null) {
 764             return DEFAULT_LINE_SPACING;
 765         }
 766         return attributes.getLineSpacing();
 767     }
 768 
 769     /**
 770      * Defines the vertical space in pixel between lines.
 771      *
 772      * @return the vertical space in pixel between lines
 773      * @defaultValue 0
 774      *
 775      * @since JavaFX 8.0
 776      */
 777     public final DoubleProperty lineSpacingProperty() {
 778         return getTextAttribute().lineSpacingProperty();
 779     }
 780 
 781     @Override
 782     public final double getBaselineOffset() {
 783         return baselineOffsetProperty().get();
 784     }
 785 
 786     /**
 787      * The &#39;alphabetic&#39; (or roman) baseline offset from the Text node&#39;s
 788      * layoutBounds.minY location.
 789      * The value typically corresponds to the max ascent of the font.
 790      * @return the baseline offset from this text node
 791      */
 792     public final ReadOnlyDoubleProperty baselineOffsetProperty() {
 793         return getTextAttribute().baselineOffsetProperty();
 794     }
 795 
 796     /**
 797      * Specifies a requested font smoothing type: gray or LCD.
 798      *
 799      * The width of the bounding box is defined by the widest row.
 800      *
 801      * Note: LCD mode doesn&#39;t apply in numerous cases, such as various
 802      * compositing modes, where effects are applied and very large glyphs.
 803      *
 804      * @defaultValue FontSmoothingType.GRAY
 805      * @since JavaFX 2.1
 806      */
 807     private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;
 808 
 809     public final void setFontSmoothingType(FontSmoothingType value) {
 810         fontSmoothingTypeProperty().set(value);
 811     }
 812 
 813     public final FontSmoothingType getFontSmoothingType() {
 814         return fontSmoothingType == null ?
 815             FontSmoothingType.GRAY : fontSmoothingType.get();
 816     }
 817 
 818     public final ObjectProperty&lt;FontSmoothingType&gt;
 819         fontSmoothingTypeProperty() {
 820         if (fontSmoothingType == null) {
 821             fontSmoothingType =
 822                 new StyleableObjectProperty&lt;FontSmoothingType&gt;
 823                                                (FontSmoothingType.GRAY) {
 824                 @Override public Object getBean() { return Text.this; }
 825                 @Override public String getName() { return &quot;fontSmoothingType&quot;; }
 826                 @Override public CssMetaData&lt;Text,FontSmoothingType&gt; getCssMetaData() {
 827                     return StyleableProperties.FONT_SMOOTHING_TYPE;
 828                 }
 829                 @Override public void invalidated() {
 830                     NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
 831                     NodeHelper.geomChanged(Text.this);
 832                 }
 833             };
 834         }
 835         return fontSmoothingType;
 836     }
 837 
 838     /*
 839      * Note: This method MUST only be called via its accessor method.
 840      */
 841     private void doGeomChanged() {
 842         if (attributes != null) {
 843             if (attributes.caretBinding != null) {
 844                 attributes.caretBinding.invalidate();
 845             }
 846             if (attributes.selectionBinding != null) {
 847                 attributes.selectionBinding.invalidate();
 848             }
 849         }
 850         NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
 851     }
 852 
 853     public final PathElement[] getSelectionShape() {
 854         return selectionShapeProperty().get();
 855     }
 856 
 857     /**
 858      * The shape of the selection in local coordinates.
 859      *
 860      * @return the {@code selectionShape} property
 861      *
 862      * @since 9
 863      */
 864     public final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
 865         return getTextAttribute().selectionShapeProperty();
 866     }
 867 
 868     public final void setSelectionStart(int value) {
 869         if (value == -1 &amp;&amp;
 870                 (attributes == null || attributes.selectionStart == null)) {
 871             return;
 872         }
 873         selectionStartProperty().set(value);
 874     }
 875 
 876     public final int getSelectionStart() {
 877         if (attributes == null || attributes.selectionStart == null) {
 878             return DEFAULT_SELECTION_START;
 879         }
 880         return attributes.getSelectionStart();
 881     }
 882 
 883     /**
 884      * The start index of the selection in the content.
 885      * If the value is -1, the selection is unset.
 886      *
 887      * @return the {@code selectionStart} property
 888      *
 889      * @defaultValue -1
 890      *
 891      * @since 9
 892      */
 893     public final IntegerProperty selectionStartProperty() {
 894         return getTextAttribute().selectionStartProperty();
 895     }
 896 
 897     public final void setSelectionEnd(int value) {
 898         if (value == -1 &amp;&amp;
 899                 (attributes == null || attributes.selectionEnd == null)) {
 900             return;
 901         }
 902         selectionEndProperty().set(value);
 903     }
 904 
 905     public final int getSelectionEnd() {
 906         if (attributes == null || attributes.selectionEnd == null) {
 907             return DEFAULT_SELECTION_END;
 908         }
 909         return attributes.getSelectionEnd();
 910     }
 911 
 912     /**
 913      * The end index of the selection in the content.
 914      * If the value is -1, the selection is unset.
 915      *
 916      * @return the {@code selectionEnd} property
 917      *
 918      * @defaultValue -1
 919      *
 920      * @since 9
 921      */
 922     public final IntegerProperty selectionEndProperty() {
 923         return getTextAttribute().selectionEndProperty();
 924     }
 925 
 926     /**
 927      * The fill color of selected text.
 928      *
 929      * @return the fill color of selected text
 930      * @since 9
 931      */
 932     public final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
 933         return getTextAttribute().selectionFillProperty();
 934     }
 935 
 936     public final void setSelectionFill(Paint paint) {
 937         selectionFillProperty().set(paint);
 938     }
 939     public final Paint getSelectionFill() {
 940         return selectionFillProperty().get();
 941     }
 942 
 943     public final PathElement[] getCaretShape() {
 944         return caretShapeProperty().get();
 945     }
 946 
 947     /**
 948      * The shape of caret, in local coordinates.
 949      *
 950      * @return the {@code caretShape} property
 951      *
 952      * @since 9
 953      */
 954     public final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
 955         return getTextAttribute().caretShapeProperty();
 956     }
 957 
 958     public final void setCaretPosition(int value) {
 959         if (value == -1 &amp;&amp;
 960                 (attributes == null || attributes.caretPosition == null)) {
 961             return;
 962         }
 963         caretPositionProperty().set(value);
 964     }
 965 
 966     public final int getCaretPosition() {
 967         if (attributes == null || attributes.caretPosition == null) {
 968             return DEFAULT_CARET_POSITION;
 969         }
 970         return attributes.getCaretPosition();
 971     }
 972 
 973     /**
 974      * The caret index in the content.
 975      * If the value is -1, the caret is unset.
 976      *
 977      * @return the {@code caretPosition} property
 978      *
 979      * @defaultValue -1
 980      *
 981      * @since 9
 982      */
 983     public final IntegerProperty caretPositionProperty() {
 984         return getTextAttribute().caretPositionProperty();
 985     }
 986 
 987     public final void setCaretBias(boolean value) {
 988         if (value &amp;&amp; (attributes == null || attributes.caretBias == null)) {
 989             return;
 990         }
 991         caretBiasProperty().set(value);
 992     }
 993 
 994     public final boolean isCaretBias() {
 995         if (attributes == null || attributes.caretBias == null) {
 996             return DEFAULT_CARET_BIAS;
 997         }
 998         return getTextAttribute().isCaretBias();
 999     }
1000 
1001     /**
1002      * The type of caret bias in the content. If {@code true}, the bias is towards the leading character edge,
1003      * otherwise, the bias is towards the trailing character edge.
1004      *
1005      * @return the {@code caretBias} property
1006      *
1007      * @defaultValue {@code true}
1008      *
1009      * @since 9
1010      */
1011     public final BooleanProperty caretBiasProperty() {
1012         return getTextAttribute().caretBiasProperty();
1013     }
1014 
1015     /**
1016      * Maps local point to index in the content.
1017      *
1018      * @param point the specified point to be tested
1019      * @return a {@code HitInfo} representing the character index found
1020      * @since 9
1021      */
1022     public final HitInfo hitTest(Point2D point) {
1023         if (point == null) return null;
1024         TextLayout layout = getTextLayout();
1025         double x = point.getX() - getX();
1026         double y = point.getY() - getY() + getYRendering();
1027         TextLayout.Hit layoutHit = layout.getHitInfo((float)x, (float)y);
1028         return new HitInfo(layoutHit.getCharIndex(), layoutHit.getInsertionIndex(),
1029                            layoutHit.isLeading(), getText());
1030     }
1031 
1032     private PathElement[] getRange(int start, int end, int type) {
1033         int length = getTextInternal().length();
1034         if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
1035             TextLayout layout = getTextLayout();
1036             float x = (float)getX();
1037             float y = (float)getY() - getYRendering();
1038             return layout.getRange(start, end, type, x, y);
1039         }
1040         return EMPTY_PATH_ELEMENT_ARRAY;
1041     }
1042 
1043     /**
1044      * Returns the shape for the caret at the given index and bias.
1045      *
1046      * @param charIndex the character index for the caret
1047      * @param caretBias whether the caret is biased on the leading edge of the character
1048      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1049      * @since 9
1050      */
1051     public final PathElement[] caretShape(int charIndex, boolean caretBias) {
1052         if (0 &lt;= charIndex &amp;&amp; charIndex &lt;= getTextInternal().length()) {
1053             float x = (float)getX();
1054             float y = (float)getY() - getYRendering();
1055             return getTextLayout().getCaretShape(charIndex, caretBias, x, y);
1056         } else {
1057             return null;
1058         }
1059     }
1060 
1061     /**
1062      * Returns the shape for the range of the text in local coordinates.
1063      *
1064      * @param start the beginning character index for the range
1065      * @param end the end character index (non-inclusive) for the range
1066      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1067      * @since 9
1068      */
1069     public final PathElement[] rangeShape(int start, int end) {
1070         return getRange(start, end, TextLayout.TYPE_TEXT);
1071     }
1072 
1073     /**
1074      * Returns the shape for the underline in local coordinates.
1075      *
1076      * @param start the beginning character index for the range
1077      * @param end the end character index (non-inclusive) for the range
1078      * @return an array of {@code PathElement} which can be used to create a {@code Shape}
1079      * @since 9
1080      */
1081     public final PathElement[] underlineShape(int start, int end) {
1082         return getRange(start, end, TextLayout.TYPE_UNDERLINE);
1083     }
1084 
1085     private float getYAdjustment(BaseBounds bounds) {
1086         VPos origin = getTextOrigin();
1087         if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
1088         switch (origin) {
1089         case TOP: return -bounds.getMinY();
1090         case BASELINE: return 0;
1091         case CENTER: return -bounds.getMinY() - bounds.getHeight() / 2;
1092         case BOTTOM: return -bounds.getMinY() - bounds.getHeight();
1093         default: return 0;
1094         }
1095     }
1096 
1097     private float getYRendering() {
1098         if (isSpan()) return 0;
1099 
1100         /* Always logical for rendering */
1101         BaseBounds bounds = getLogicalBounds();
1102 
1103         VPos origin = getTextOrigin();
1104         if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
1105         if (getBoundsType() == TextBoundsType.VISUAL) {
1106             BaseBounds vBounds = getVisualBounds();
1107             float delta = vBounds.getMinY() - bounds.getMinY();
1108             switch (origin) {
1109             case TOP: return delta;
1110             case BASELINE: return -vBounds.getMinY() + delta;
1111             case CENTER: return vBounds.getHeight() / 2 + delta;
1112             case BOTTOM: return vBounds.getHeight() + delta;
1113             default: return 0;
1114             }
1115         } else {
1116             switch (origin) {
1117             case TOP: return 0;
1118             case BASELINE: return -bounds.getMinY();
1119             case CENTER: return bounds.getHeight() / 2;
1120             case BOTTOM: return bounds.getHeight();
1121             default: return 0;
1122             }
1123         }
1124     }
1125 
1126     private Bounds doComputeLayoutBounds() {
1127         if (isSpan()) {
1128             BaseBounds bounds = getSpanBounds();
1129             double width = bounds.getWidth();
1130             double height = bounds.getHeight();
1131             return new BoundingBox(0, 0, width, height);
1132         }
1133 
1134         if (getBoundsType() == TextBoundsType.VISUAL) {
1135             /* In Node the layout bounds is computed based in the geom
1136              * bounds and in Shape the geom bounds is computed based
1137              * on the shape (generated here in #configShape()) */
1138             return TextHelper.superComputeLayoutBounds(this);
1139         }
1140         BaseBounds bounds = getLogicalBounds();
1141         double x = bounds.getMinX() + getX();
1142         double y = bounds.getMinY() + getY() + getYAdjustment(bounds);
1143         double width = bounds.getWidth();
1144         double height = bounds.getHeight();
1145         double wrappingWidth = getWrappingWidth();
1146         if (wrappingWidth != 0) width = wrappingWidth;
1147         return new BoundingBox(x, y, width, height);
1148     }
1149 
1150     /*
1151      * Note: This method MUST only be called via its accessor method.
1152      */
1153     private BaseBounds doComputeGeomBounds(BaseBounds bounds,
1154                                                    BaseTransform tx) {
1155         if (isSpan()) {
1156             if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
1157                 return TextHelper.superComputeGeomBounds(this, bounds, tx);
1158             }
1159             TextLayout layout = getTextLayout();
1160             bounds = layout.getBounds(getTextSpan(), bounds);
1161             BaseBounds spanBounds = getSpanBounds();
1162             float minX = bounds.getMinX() - spanBounds.getMinX();
1163             float minY = bounds.getMinY() - spanBounds.getMinY();
1164             float maxX = minX + bounds.getWidth();
1165             float maxY = minY + bounds.getHeight();
1166             bounds = bounds.deriveWithNewBounds(minX, minY, 0, maxX, maxY, 0);
1167             return tx.transform(bounds, bounds);
1168         }
1169 
1170        if (getBoundsType() == TextBoundsType.VISUAL) {
1171             if (getTextInternal().length() == 0 || ShapeHelper.getMode(this) == NGShape.Mode.EMPTY) {
1172                 return bounds.makeEmpty();
1173             }
1174             if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
1175                 /* Optimize for FILL and INNER STROKE: save the cost of shaping each glyph */
1176                 BaseBounds visualBounds = getVisualBounds();
1177                 float x = visualBounds.getMinX() + (float) getX();
1178                 float yadj = getYAdjustment(visualBounds);
1179                 float y = visualBounds.getMinY() + yadj + (float) getY();
1180                 bounds.deriveWithNewBounds(x, y, 0, x + visualBounds.getWidth(),
1181                         y + visualBounds.getHeight(), 0);
1182                 return tx.transform(bounds, bounds);
1183             } else {
1184                 /* Let the superclass compute the bounds using shape */
1185                 return TextHelper.superComputeGeomBounds(this, bounds, tx);
1186             }
1187         }
1188 
1189         BaseBounds textBounds = getLogicalBounds();
1190         float x = textBounds.getMinX() + (float)getX();
1191         float yadj = getYAdjustment(textBounds);
1192         float y = textBounds.getMinY() + yadj + (float)getY();
1193         float width = textBounds.getWidth();
1194         float height = textBounds.getHeight();
1195         float wrappingWidth = (float)getWrappingWidth();
1196         if (wrappingWidth &gt; width) {
1197             width = wrappingWidth;
1198         } else {
1199             /* The following adjustment is necessary for the text bounds to be
1200              * relative to the same location as the mirrored bounds returned
1201              * by layout.getBounds().
1202              */
1203             if (wrappingWidth &gt; 0) {
1204                 NodeOrientation orientation = getEffectiveNodeOrientation();
1205                 if (orientation == NodeOrientation.RIGHT_TO_LEFT) {
1206                     x -= width - wrappingWidth;
1207                 }
1208             }
1209         }
1210         textBounds = new RectBounds(x, y, x + width, y + height);
1211 
1212         /* handle stroked text */
1213         if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
1214             bounds = TextHelper.superComputeGeomBounds(this, bounds,
1215                     BaseTransform.IDENTITY_TRANSFORM);
1216         } else {
1217             TextLayout layout = getTextLayout();
1218             bounds = layout.getBounds(null, bounds);
1219             x = bounds.getMinX() + (float)getX();
1220             width = bounds.getWidth();
1221             bounds = bounds.deriveWithNewBounds(x, y, 0, x + width, y + height, 0);
1222         }
1223 
1224         bounds = bounds.deriveWithUnion(textBounds);
1225         return tx.transform(bounds, bounds);
1226     }
1227 
1228     /*
1229      * Note: This method MUST only be called via its accessor method.
1230      */
1231     private boolean doComputeContains(double localX, double localY) {
1232         /* Used for spans, regular text uses bounds based picking */
1233         double x = localX + getSpanBounds().getMinX();
1234         double y = localY + getSpanBounds().getMinY();
1235         GlyphList[] runs = getRuns();
1236         if (runs.length != 0) {
1237             for (int i = 0; i &lt; runs.length; i++) {
1238                 GlyphList run = runs[i];
1239                 com.sun.javafx.geom.Point2D location = run.getLocation();
1240                 float width = run.getWidth();
1241                 RectBounds lineBounds = run.getLineBounds();
1242                 float height = lineBounds.getHeight();
1243                 if (location.x &lt;= x &amp;&amp; x &lt; location.x + width &amp;&amp;
1244                     location.y &lt;= y &amp;&amp; y &lt; location.y + height) {
1245                         return true;
1246                 }
1247             }
1248         }
1249         return false;
1250     }
1251 
1252     /*
1253      * Note: This method MUST only be called via its accessor method.
1254      */
1255     private com.sun.javafx.geom.Shape doConfigShape() {
1256         if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
1257             return new Path2D();
1258         }
1259         com.sun.javafx.geom.Shape shape = getShape();
1260         float x, y;
1261         if (isSpan()) {
1262             BaseBounds bounds = getSpanBounds();
1263             x = -bounds.getMinX();
1264             y = -bounds.getMinY();
1265         } else {
1266             x = (float)getX();
1267             y = getYAdjustment(getVisualBounds()) + (float)getY();
1268         }
1269         return TransformedShape.translatedShape(shape, x, y);
1270     }
1271 
1272     /**
1273      * The size of a tab stop in spaces.
1274      * Values less than 1 are treated as 1.
1275      *
<a name="2" id="anc2"></a><span class="line-added">1276      * @return the {@code tabSize} property</span>
<span class="line-added">1277      *</span>
1278      * @defaultValue 8
1279      *
1280      * @since 14
1281      */
1282     public final IntegerProperty tabSizeProperty() {
1283         return getTextAttribute().tabSizeProperty();
1284     }
1285 
1286     public final int getTabSize() {
1287         if (attributes == null || attributes.tabSize == null) {
1288             return TextLayout.DEFAULT_TAB_SIZE;
1289         }
1290         return getTextAttribute().getTabSize();
1291     }
1292 
1293     public final void setTabSize(int spaces) {
1294         tabSizeProperty().set(spaces);
1295     }
1296 
1297 
1298    /***************************************************************************
1299     *                                                                         *
1300     *                            Stylesheet Handling                          *
1301     *                                                                         *
1302     **************************************************************************/
1303 
1304     /*
1305      * Super-lazy instantiation pattern from Bill Pugh.
1306      */
1307     private static class StyleableProperties {
1308 
1309         private static final CssMetaData&lt;Text,Font&gt; FONT =
1310             new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1311 
1312             @Override
1313             public boolean isSettable(Text node) {
1314                 return node.font == null || !node.font.isBound();
1315             }
1316 
1317             @Override
1318             public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
1319                 return (StyleableProperty&lt;Font&gt;)node.fontProperty();
1320             }
1321         };
1322 
1323         private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =
1324             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
1325                 BooleanConverter.getInstance(), Boolean.FALSE) {
1326 
1327             @Override
1328             public boolean isSettable(Text node) {
1329                 return node.attributes == null ||
1330                        node.attributes.underline == null ||
1331                       !node.attributes.underline.isBound();
1332             }
1333 
1334             @Override
1335             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1336                 return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
1337             }
1338         };
1339 
1340         private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =
1341             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
1342                 BooleanConverter.getInstance(), Boolean.FALSE) {
1343 
1344             @Override
1345             public boolean isSettable(Text node) {
1346                 return node.attributes == null ||
1347                        node.attributes.strikethrough == null ||
1348                       !node.attributes.strikethrough.isBound();
1349             }
1350 
1351             @Override
1352             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1353                 return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
1354             }
1355         };
1356 
1357         private static final
1358             CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =
1359                 new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
1360                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
1361                 TextAlignment.LEFT) {
1362 
1363             @Override
1364             public boolean isSettable(Text node) {
1365                 return node.attributes == null ||
1366                        node.attributes.textAlignment == null ||
1367                       !node.attributes.textAlignment.isBound();
1368             }
1369 
1370             @Override
1371             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
1372                 return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
1373             }
1374         };
1375 
1376         private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =
1377                 new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,
1378                 new EnumConverter&lt;VPos&gt;(VPos.class),
1379                 VPos.BASELINE) {
1380 
1381             @Override
1382             public boolean isSettable(Text node) {
1383                 return node.attributes == null ||
1384                        node.attributes.textOrigin == null ||
1385                       !node.attributes.textOrigin.isBound();
1386             }
1387 
1388             @Override
1389             public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
1390                 return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
1391             }
1392         };
1393 
1394         private static final CssMetaData&lt;Text,FontSmoothingType&gt;
1395             FONT_SMOOTHING_TYPE =
1396             new CssMetaData&lt;Text,FontSmoothingType&gt;(
1397                 &quot;-fx-font-smoothing-type&quot;,
1398                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
1399                 FontSmoothingType.GRAY) {
1400 
1401             @Override
1402             public boolean isSettable(Text node) {
1403                 return node.fontSmoothingType == null ||
1404                        !node.fontSmoothingType.isBound();
1405             }
1406 
1407             @Override
1408             public StyleableProperty&lt;FontSmoothingType&gt;
1409                                  getStyleableProperty(Text node) {
1410 
1411                 return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
1412             }
1413         };
1414 
1415         private static final
1416             CssMetaData&lt;Text,Number&gt; LINE_SPACING =
1417                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,
1418                 SizeConverter.getInstance(), 0) {
1419 
1420             @Override
1421             public boolean isSettable(Text node) {
1422                 return node.attributes == null ||
1423                        node.attributes.lineSpacing == null ||
1424                       !node.attributes.lineSpacing.isBound();
1425             }
1426 
1427             @Override
1428             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1429                 return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
1430             }
1431         };
1432 
1433         private static final CssMetaData&lt;Text, TextBoundsType&gt;
1434             BOUNDS_TYPE =
1435             new CssMetaData&lt;Text,TextBoundsType&gt;(
1436                 &quot;-fx-bounds-type&quot;,
1437                 new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),
1438                 DEFAULT_BOUNDS_TYPE) {
1439 
1440             @Override
1441             public boolean isSettable(Text node) {
1442                 return node.boundsType == null || !node.boundsType.isBound();
1443             }
1444 
1445             @Override
1446             public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
1447                 return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
1448             }
1449         };
1450 
1451         private static final CssMetaData&lt;Text, Number&gt; TAB_SIZE =
1452                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-tab-size&quot;,
1453                 SizeConverter.getInstance(), TextLayout.DEFAULT_TAB_SIZE) {
1454 
1455             @Override
1456             public boolean isSettable(Text node) {
1457                 return node.attributes == null ||
1458                        node.attributes.tabSize == null ||
1459                       !node.attributes.tabSize.isBound();
1460             }
1461 
1462             @Override
1463             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1464                 return (StyleableProperty&lt;Number&gt;)node.tabSizeProperty();
1465             }
1466         };
1467 
1468     private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1469         static {
1470             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1471                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
1472             styleables.add(FONT);
1473             styleables.add(UNDERLINE);
1474             styleables.add(STRIKETHROUGH);
1475             styleables.add(TEXT_ALIGNMENT);
1476             styleables.add(TEXT_ORIGIN);
1477             styleables.add(FONT_SMOOTHING_TYPE);
1478             styleables.add(LINE_SPACING);
1479             styleables.add(BOUNDS_TYPE);
1480             styleables.add(TAB_SIZE);
1481             STYLEABLES = Collections.unmodifiableList(styleables);
1482         }
1483     }
1484 
1485     /**
1486      * @return The CssMetaData associated with this class, which may include the
1487      * CssMetaData of its superclasses.
1488      * @since JavaFX 8.0
1489      */
1490     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1491         return StyleableProperties.STYLEABLES;
1492     }
1493 
1494     /**
1495      * {@inheritDoc}
1496      *
1497      * @since JavaFX 8.0
1498      */
1499 
1500 
1501     @Override
1502     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
1503         return getClassCssMetaData();
1504     }
1505 
1506     @SuppressWarnings(&quot;deprecation&quot;)
1507     private void updatePGText() {
1508         final NGText peer = NodeHelper.getPeer(this);
1509         if (NodeHelper.isDirty(this, DirtyBits.TEXT_ATTRS)) {
1510             peer.setUnderline(isUnderline());
1511             peer.setStrikethrough(isStrikethrough());
1512             FontSmoothingType smoothing = getFontSmoothingType();
1513             if (smoothing == null) smoothing = FontSmoothingType.GRAY;
1514             peer.setFontSmoothingType(smoothing.ordinal());
1515         }
1516         if (NodeHelper.isDirty(this, DirtyBits.TEXT_FONT)) {
1517             peer.setFont(getFontInternal());
1518         }
1519         if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
1520             peer.setGlyphs(getRuns());
1521         }
1522         if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
1523             if (isSpan()) {
1524                 BaseBounds spanBounds = getSpanBounds();
1525                 peer.setLayoutLocation(spanBounds.getMinX(), spanBounds.getMinY());
1526             } else {
1527                 float x = (float)getX();
1528                 float y = (float)getY();
1529                 float yadj = getYRendering();
1530                 peer.setLayoutLocation(-x, yadj - y);
1531             }
1532         }
1533         if (NodeHelper.isDirty(this, DirtyBits.TEXT_SELECTION)) {
1534             Object fillObj = null;
1535             int start = getSelectionStart();
1536             int end = getSelectionEnd();
1537             int length = getTextInternal().length();
1538             if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
1539                 Paint fill = selectionFillProperty().get();
1540                 fillObj = fill != null ? Toolkit.getPaintAccessor().getPlatformPaint(fill) : null;
1541             }
1542             peer.setSelection(start, end, fillObj);
1543         }
1544     }
1545 
1546     /*
1547      * Note: This method MUST only be called via its accessor method.
1548      */
1549     private void doUpdatePeer() {
1550         updatePGText();
1551     }
1552 
1553     /***************************************************************************
1554      *                                                                         *
1555      *                       Seldom Used Properties                            *
1556      *                                                                         *
1557      **************************************************************************/
1558 
1559     private TextAttribute attributes;
1560 
1561     private TextAttribute getTextAttribute() {
1562         if (attributes == null) {
1563             attributes = new TextAttribute();
1564         }
1565         return attributes;
1566     }
1567 
1568     private static final VPos DEFAULT_TEXT_ORIGIN = VPos.BASELINE;
1569     private static final TextBoundsType DEFAULT_BOUNDS_TYPE = TextBoundsType.LOGICAL;
1570     private static final boolean DEFAULT_UNDERLINE = false;
1571     private static final boolean DEFAULT_STRIKETHROUGH = false;
1572     private static final TextAlignment DEFAULT_TEXT_ALIGNMENT = TextAlignment.LEFT;
1573     private static final double DEFAULT_LINE_SPACING = 0;
1574     private static final int DEFAULT_CARET_POSITION = -1;
1575     private static final int DEFAULT_SELECTION_START = -1;
1576     private static final int DEFAULT_SELECTION_END = -1;
1577     private static final Color DEFAULT_SELECTION_FILL= Color.WHITE;
1578     private static final boolean DEFAULT_CARET_BIAS = true;
1579 
1580     private final class TextAttribute {
1581 
1582         private ObjectProperty&lt;VPos&gt; textOrigin;
1583 
1584         final VPos getTextOrigin() {
1585             return textOrigin == null ? DEFAULT_TEXT_ORIGIN : textOrigin.get();
1586         }
1587 
1588         public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
1589             if (textOrigin == null) {
1590                 textOrigin = new StyleableObjectProperty&lt;VPos&gt;(DEFAULT_TEXT_ORIGIN) {
1591                     @Override public Object getBean() { return Text.this; }
1592                     @Override public String getName() { return &quot;textOrigin&quot;; }
1593                     @Override public CssMetaData getCssMetaData() {
1594                         return StyleableProperties.TEXT_ORIGIN;
1595                     }
1596                     @Override public void invalidated() {
1597                         NodeHelper.geomChanged(Text.this);
1598                     }
1599                 };
1600             }
1601             return textOrigin;
1602         }
1603 
1604         private BooleanProperty underline;
1605 
1606         final boolean isUnderline() {
1607             return underline == null ? DEFAULT_UNDERLINE : underline.get();
1608         }
1609 
1610         final BooleanProperty underlineProperty() {
1611             if (underline == null) {
1612                 underline = new StyleableBooleanProperty() {
1613                     @Override public Object getBean() { return Text.this; }
1614                     @Override public String getName() { return &quot;underline&quot;; }
1615                     @Override public CssMetaData getCssMetaData() {
1616                         return StyleableProperties.UNDERLINE;
1617                     }
1618                     @Override public void invalidated() {
1619                         NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1620                         if (getBoundsType() == TextBoundsType.VISUAL) {
1621                             NodeHelper.geomChanged(Text.this);
1622                         }
1623                     }
1624                 };
1625             }
1626             return underline;
1627         }
1628 
1629         private BooleanProperty strikethrough;
1630 
1631         final boolean isStrikethrough() {
1632             return strikethrough == null ? DEFAULT_STRIKETHROUGH : strikethrough.get();
1633         }
1634 
1635         final BooleanProperty strikethroughProperty() {
1636             if (strikethrough == null) {
1637                 strikethrough = new StyleableBooleanProperty() {
1638                     @Override public Object getBean() { return Text.this; }
1639                     @Override public String getName() { return &quot;strikethrough&quot;; }
1640                     @Override public CssMetaData getCssMetaData() {
1641                         return StyleableProperties.STRIKETHROUGH;
1642                     }
1643                     @Override public void invalidated() {
1644                         NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1645                         if (getBoundsType() == TextBoundsType.VISUAL) {
1646                             NodeHelper.geomChanged(Text.this);
1647                         }
1648                     }
1649                 };
1650             }
1651             return strikethrough;
1652         }
1653 
1654         private ObjectProperty&lt;TextAlignment&gt; textAlignment;
1655 
1656         final TextAlignment getTextAlignment() {
1657             return textAlignment == null ? DEFAULT_TEXT_ALIGNMENT : textAlignment.get();
1658         }
1659 
1660         final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
1661             if (textAlignment == null) {
1662                 textAlignment =
1663                     new StyleableObjectProperty&lt;TextAlignment&gt;(DEFAULT_TEXT_ALIGNMENT) {
1664                     @Override public Object getBean() { return Text.this; }
1665                     @Override public String getName() { return &quot;textAlignment&quot;; }
1666                     @Override public CssMetaData getCssMetaData() {
1667                         return StyleableProperties.TEXT_ALIGNMENT;
1668                     }
1669                     @Override public void invalidated() {
1670                         if (!isSpan()) {
1671                             TextAlignment alignment = get();
1672                             if (alignment == null) {
1673                                 alignment = DEFAULT_TEXT_ALIGNMENT;
1674                             }
1675                             TextLayout layout = getTextLayout();
1676                             if (layout.setAlignment(alignment.ordinal())) {
1677                                 needsTextLayout();
1678                             }
1679                         }
1680                     }
1681                 };
1682             }
1683             return textAlignment;
1684         }
1685 
1686         private DoubleProperty lineSpacing;
1687 
1688         final double getLineSpacing() {
1689             return lineSpacing == null ? DEFAULT_LINE_SPACING : lineSpacing.get();
1690         }
1691 
1692         final DoubleProperty lineSpacingProperty() {
1693             if (lineSpacing == null) {
1694                 lineSpacing =
1695                     new StyleableDoubleProperty(DEFAULT_LINE_SPACING) {
1696                     @Override public Object getBean() { return Text.this; }
1697                     @Override public String getName() { return &quot;lineSpacing&quot;; }
1698                     @Override public CssMetaData getCssMetaData() {
1699                         return StyleableProperties.LINE_SPACING;
1700                     }
1701                     @Override public void invalidated() {
1702                         if (!isSpan()) {
1703                             TextLayout layout = getTextLayout();
1704                             if (layout.setLineSpacing((float)get())) {
1705                                 needsTextLayout();
1706                             }
1707                         }
1708                     }
1709                 };
1710             }
1711             return lineSpacing;
1712         }
1713 
1714         private ReadOnlyDoubleWrapper baselineOffset;
1715 
1716         final ReadOnlyDoubleProperty baselineOffsetProperty() {
1717             if (baselineOffset == null) {
1718                 baselineOffset = new ReadOnlyDoubleWrapper(Text.this, &quot;baselineOffset&quot;) {
1719                     {bind(new DoubleBinding() {
1720                         {bind(fontProperty());}
1721                         @Override protected double computeValue() {
1722                             /* This method should never be used for spans.
1723                              * If it is, it will still returns the ascent
1724                              * for the first line in the layout */
1725                             BaseBounds bounds = getLogicalBounds();
1726                             return -bounds.getMinY();
1727                         }
1728                     });}
1729                 };
1730             }
1731             return baselineOffset.getReadOnlyProperty();
1732         }
1733 
1734         private ObjectProperty&lt;PathElement[]&gt; selectionShape;
1735         private ObjectBinding&lt;PathElement[]&gt; selectionBinding;
1736 
1737         final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
1738             if (selectionShape == null) {
1739                 selectionBinding = new ObjectBinding&lt;PathElement[]&gt;() {
1740                     {bind(selectionStartProperty(), selectionEndProperty());}
1741                     @Override protected PathElement[] computeValue() {
1742                         int start = getSelectionStart();
1743                         int end = getSelectionEnd();
1744                         return getRange(start, end, TextLayout.TYPE_TEXT);
1745                     }
1746               };
1747               selectionShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;selectionShape&quot;);
1748               selectionShape.bind(selectionBinding);
1749             }
1750             return selectionShape;
1751         }
1752 
1753         private ObjectProperty&lt;Paint&gt; selectionFill;
1754 
1755         final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
1756             if (selectionFill == null) {
1757                 selectionFill =
1758                     new ObjectPropertyBase&lt;Paint&gt;(DEFAULT_SELECTION_FILL) {
1759                         @Override public Object getBean() { return Text.this; }
1760                         @Override public String getName() { return &quot;selectionFill&quot;; }
1761                         @Override protected void invalidated() {
1762                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1763                         }
1764                     };
1765             }
1766             return selectionFill;
1767         }
1768 
1769         private IntegerProperty selectionStart;
1770 
1771         final int getSelectionStart() {
1772             return selectionStart == null ? DEFAULT_SELECTION_START : selectionStart.get();
1773         }
1774 
1775         final IntegerProperty selectionStartProperty() {
1776             if (selectionStart == null) {
1777                 selectionStart =
1778                     new IntegerPropertyBase(DEFAULT_SELECTION_START) {
1779                         @Override public Object getBean() { return Text.this; }
1780                         @Override public String getName() { return &quot;selectionStart&quot;; }
1781                         @Override protected void invalidated() {
1782                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1783                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1784                         }
1785                 };
1786             }
1787             return selectionStart;
1788         }
1789 
1790         private IntegerProperty selectionEnd;
1791 
1792         final int getSelectionEnd() {
1793             return selectionEnd == null ? DEFAULT_SELECTION_END : selectionEnd.get();
1794         }
1795 
1796         final IntegerProperty selectionEndProperty() {
1797             if (selectionEnd == null) {
1798                 selectionEnd =
1799                     new IntegerPropertyBase(DEFAULT_SELECTION_END) {
1800                         @Override public Object getBean() { return Text.this; }
1801                         @Override public String getName() { return &quot;selectionEnd&quot;; }
1802                         @Override protected void invalidated() {
1803                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
1804                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1805                         }
1806                     };
1807             }
1808             return selectionEnd;
1809         }
1810 
1811         private ObjectProperty&lt;PathElement[]&gt; caretShape;
1812         private ObjectBinding&lt;PathElement[]&gt; caretBinding;
1813 
1814         final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
1815             if (caretShape == null) {
1816                 caretBinding = new ObjectBinding&lt;PathElement[]&gt;() {
1817                     {bind(caretPositionProperty(), caretBiasProperty());}
1818                     @Override protected PathElement[] computeValue() {
1819                         int pos = getCaretPosition();
1820                         int length = getTextInternal().length();
1821                         if (0 &lt;= pos &amp;&amp; pos &lt;= length) {
1822                             boolean bias = isCaretBias();
1823                             float x = (float)getX();
1824                             float y = (float)getY() - getYRendering();
1825                             TextLayout layout = getTextLayout();
1826                             return layout.getCaretShape(pos, bias, x, y);
1827                         }
1828                         return EMPTY_PATH_ELEMENT_ARRAY;
1829                     }
1830                 };
1831                 caretShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;caretShape&quot;);
1832                 caretShape.bind(caretBinding);
1833             }
1834             return caretShape;
1835         }
1836 
1837         private IntegerProperty caretPosition;
1838 
1839         final int getCaretPosition() {
1840             return caretPosition == null ? DEFAULT_CARET_POSITION : caretPosition.get();
1841         }
1842 
1843         final IntegerProperty caretPositionProperty() {
1844             if (caretPosition == null) {
1845                 caretPosition =
1846                     new IntegerPropertyBase(DEFAULT_CARET_POSITION) {
1847                         @Override public Object getBean() { return Text.this; }
1848                         @Override public String getName() { return &quot;caretPosition&quot;; }
1849                         @Override protected void invalidated() {
1850                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1851                         }
1852                     };
1853             }
1854             return caretPosition;
1855         }
1856 
1857         private BooleanProperty caretBias;
1858 
1859         final boolean isCaretBias() {
1860             return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
1861         }
1862 
1863         final BooleanProperty caretBiasProperty() {
1864             if (caretBias == null) {
1865                 caretBias =
1866                         new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
1867             }
1868             return caretBias;
1869         }
1870 
1871         private IntegerProperty tabSize;
1872 
1873         final int getTabSize() {
1874             return tabSize == null ? TextLayout.DEFAULT_TAB_SIZE : tabSize.get();
1875         }
1876 
1877         final IntegerProperty tabSizeProperty() {
1878             if (tabSize == null) {
1879                 tabSize = new StyleableIntegerProperty(TextLayout.DEFAULT_TAB_SIZE) {
1880                     @Override public Object getBean() { return Text.this; }
1881                     @Override public String getName() { return &quot;tabSize&quot;; }
1882                     @Override public CssMetaData getCssMetaData() {
1883                         return StyleableProperties.TAB_SIZE;
1884                     }
1885                     @Override protected void invalidated() {
1886                         if (!isSpan()) {
1887                             TextLayout layout = getTextLayout();
1888                             if (layout.setTabSize(get())) {
1889                                 needsTextLayout();
1890                             }
1891                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
1892                             if (getBoundsType() == TextBoundsType.VISUAL) {
1893                                 NodeHelper.geomChanged(Text.this);
1894                             }
1895                         }
1896                     }
1897                 };
1898             }
1899             return tabSize;
1900         }
1901     }
1902 
1903     /**
1904      * Returns a string representation of this {@code Text} object.
1905      * @return a string representation of this {@code Text} object.
1906      */
1907     @Override
1908     public String toString() {
1909         final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);
1910 
1911         String id = getId();
1912         if (id != null) {
1913             sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
1914         }
1915 
1916         sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
1917         sb.append(&quot;, x=&quot;).append(getX());
1918         sb.append(&quot;, y=&quot;).append(getY());
1919         sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
1920         sb.append(&quot;, origin=&quot;).append(getTextOrigin());
1921         sb.append(&quot;, boundsType=&quot;).append(getBoundsType());
1922 
1923         double spacing = getLineSpacing();
1924         if (spacing != DEFAULT_LINE_SPACING) {
1925             sb.append(&quot;, lineSpacing=&quot;).append(spacing);
1926         }
1927 
1928         double wrap = getWrappingWidth();
1929         if (wrap != 0) {
1930             sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
1931         }
1932 
1933         int tab = getTabSize();
1934         if (tab != TextLayout.DEFAULT_TAB_SIZE) {
1935             sb.append(&quot;, tabSize=&quot;).append(tab);
1936         }
1937 
1938         sb.append(&quot;, font=&quot;).append(getFont());
1939         sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());
1940 
1941         if (isStrikethrough()) {
1942             sb.append(&quot;, strikethrough&quot;);
1943         }
1944         if (isUnderline()) {
1945             sb.append(&quot;, underline&quot;);
1946         }
1947 
1948         sb.append(&quot;, fill=&quot;).append(getFill());
1949 
1950         Paint stroke = getStroke();
1951         if (stroke != null) {
1952             sb.append(&quot;, stroke=&quot;).append(stroke);
1953             sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
1954         }
1955 
1956         return sb.append(&quot;]&quot;).toString();
1957     }
1958 
1959     /** {@inheritDoc} */
1960     @Override
1961     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1962         switch (attribute) {
1963             case TEXT: {
1964                 String accText = getAccessibleText();
1965                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1966                 return getText();
1967             }
1968             case FONT: return getFont();
1969             case CARET_OFFSET: {
1970                 int sel = getCaretPosition();
1971                 if (sel &gt;=  0) return sel;
1972                 return getText().length();
1973             }
1974             case SELECTION_START: {
1975                 int sel = getSelectionStart();
1976                 if (sel &gt;=  0) return sel;
1977                 sel = getCaretPosition();
1978                 if (sel &gt;=  0) return sel;
1979                 return getText().length();
1980             }
1981             case SELECTION_END:  {
1982                 int sel = getSelectionEnd();
1983                 if (sel &gt;=  0) return sel;
1984                 sel = getCaretPosition();
1985                 if (sel &gt;=  0) return sel;
1986                 return getText().length();
1987             }
1988             case LINE_FOR_OFFSET: {
1989                 int offset = (Integer)parameters[0];
1990                 if (offset &gt; getTextInternal().length()) return null;
1991                 TextLine[] lines = getTextLayout().getLines();
1992                 int lineIndex = 0;
1993                 for (int i = 1; i &lt; lines.length; i++) {
1994                     TextLine line = lines[i];
1995                     if (line.getStart() &gt; offset) break;
1996                     lineIndex++;
1997                 }
1998                 return lineIndex;
1999             }
2000             case LINE_START: {
2001                 int lineIndex = (Integer)parameters[0];
2002                 TextLine[] lines = getTextLayout().getLines();
2003                 if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
2004                     TextLine line = lines[lineIndex];
2005                     return line.getStart();
2006                 }
2007                 return null;
2008             }
2009             case LINE_END: {
2010                 int lineIndex = (Integer)parameters[0];
2011                 TextLine[] lines = getTextLayout().getLines();
2012                 if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
2013                     TextLine line = lines[lineIndex];
2014                     return line.getStart() + line.getLength();
2015                 }
2016                 return null;
2017             }
2018             case OFFSET_AT_POINT: {
2019                 Point2D point = (Point2D)parameters[0];
2020                 point = screenToLocal(point);
2021                 return hitTest(point).getCharIndex();
2022             }
2023             case BOUNDS_FOR_RANGE: {
2024                 int start = (Integer)parameters[0];
2025                 int end = (Integer)parameters[1];
2026                 PathElement[] elements = rangeShape(start, end + 1);
2027                 /* Each bounds is defined by a MoveTo (top-left) followed by
2028                  * 4 LineTo (to top-right, bottom-right, bottom-left, back to top-left).
2029                  */
2030                 Bounds[] bounds = new Bounds[elements.length / 5];
2031                 int index = 0;
2032                 for (int i = 0; i &lt; bounds.length; i++) {
2033                     MoveTo topLeft = (MoveTo)elements[index];
2034                     LineTo topRight = (LineTo)elements[index+1];
2035                     LineTo bottomRight = (LineTo)elements[index+2];
2036                     BoundingBox b = new BoundingBox(topLeft.getX(), topLeft.getY(),
2037                                                     topRight.getX() - topLeft.getX(),
2038                                                     bottomRight.getY() - topRight.getY());
2039                     bounds[i] = localToScreen(b);
2040                     index += 5;
2041                 }
2042                 return bounds;
2043             }
2044             default: return super.queryAccessibleAttribute(attribute, parameters);
2045         }
2046     }
2047 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>