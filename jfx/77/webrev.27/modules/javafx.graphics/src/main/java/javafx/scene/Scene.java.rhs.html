<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Accessible;
  30 import com.sun.javafx.util.Logging;
  31 import com.sun.javafx.util.Utils;
  32 import com.sun.javafx.application.PlatformImpl;
  33 import com.sun.javafx.collections.TrackableObservableList;
  34 import com.sun.javafx.css.StyleManager;
  35 import com.sun.javafx.cursor.CursorFrame;
  36 import com.sun.javafx.event.EventQueue;
  37 import com.sun.javafx.geom.PickRay;
  38 import com.sun.javafx.geom.Vec3d;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.scene.CssFlags;
  42 import com.sun.javafx.scene.LayoutFlags;
  43 import com.sun.javafx.scene.SceneEventDispatcher;
  44 import com.sun.javafx.scene.SceneHelper;
  45 import com.sun.javafx.scene.input.DragboardHelper;
  46 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  47 import com.sun.javafx.scene.input.InputEventUtils;
  48 import com.sun.javafx.scene.input.PickResultChooser;
  49 import com.sun.javafx.scene.traversal.Direction;
  50 import com.sun.javafx.scene.traversal.SceneTraversalEngine;
  51 import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
  52 import com.sun.javafx.sg.prism.NGCamera;
  53 import com.sun.javafx.sg.prism.NGLightBase;
  54 import com.sun.javafx.tk.*;
  55 import com.sun.prism.impl.PrismSettings;
  56 
  57 import javafx.animation.KeyFrame;
  58 import javafx.animation.Timeline;
  59 import javafx.application.ConditionalFeature;
  60 import javafx.application.Platform;
  61 import javafx.beans.DefaultProperty;
  62 import javafx.beans.InvalidationListener;
  63 import javafx.beans.NamedArg;
  64 import javafx.beans.property.*;
  65 import javafx.collections.FXCollections;
  66 import javafx.collections.ListChangeListener.Change;
  67 import javafx.collections.ObservableList;
  68 import javafx.collections.ObservableMap;
  69 import javafx.css.CssMetaData;
  70 import javafx.css.StyleableObjectProperty;
  71 import javafx.event.*;
  72 import javafx.geometry.*;
  73 import javafx.scene.image.WritableImage;
  74 import javafx.scene.input.*;
  75 import javafx.scene.paint.Color;
  76 import javafx.scene.paint.Paint;
  77 import javafx.stage.PopupWindow;
  78 import javafx.stage.Stage;
  79 import javafx.stage.StageStyle;
  80 import javafx.stage.Window;
  81 import javafx.util.Callback;
  82 import javafx.util.Duration;
  83 import com.sun.javafx.logging.PlatformLogger;
  84 import com.sun.javafx.logging.PlatformLogger.Level;
  85 
  86 import java.security.AccessControlContext;
  87 import java.security.AccessController;
  88 import java.security.PrivilegedAction;
  89 import java.util.*;
  90 import java.util.concurrent.CopyOnWriteArrayList;
  91 
  92 import com.sun.javafx.logging.PulseLogger;
  93 
  94 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  95 import com.sun.javafx.scene.NodeHelper;
  96 import com.sun.javafx.stage.WindowHelper;
  97 import com.sun.javafx.scene.input.ClipboardHelper;
  98 import com.sun.javafx.scene.input.TouchPointHelper;
  99 import java.lang.ref.WeakReference;
 100 
 101 /**
 102  * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 103  * The background of the scene is filled as specified by the {@code fill} property.
 104  * &lt;p&gt;
 105  * The application must specify the root {@code Node} for the scene graph by setting
 106  * the {@code root} property.   If a {@code Group} is used as the root, the
 107  * contents of the scene graph will be clipped by the scene&#39;s width and height and
 108  * changes to the scene&#39;s size (if user resizes the stage) will not alter the
 109  * layout of the scene graph. If a resizable node (layout {@code Region} or
 110  * {@code Control}) is set as the root, then the root&#39;s size will track the
 111  * scene&#39;s size, causing the contents to be relayed out as necessary.
 112  * &lt;p&gt;
 113  * The scene&#39;s size may be initialized by the application during construction.
 114  * If no size is specified, the scene will automatically compute its initial
 115  * size based on the preferred size of its content. If only one dimension is specified,
 116  * the other dimension is computed using the specified dimension, respecting content bias
 117  * of a root.
 118  * &lt;p&gt;
 119  * An application may request depth buffer support or scene anti-aliasing
 120  * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 121  * without any 3D transforms does not need a depth buffer nor scene
 122  * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 123  * transforms may use depth buffer support for proper depth sorted rendering; to
 124  * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 125  * shapes that have no 3D transforms. See
 126  * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 127  * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 128  * &lt;p&gt;
 129  * The depthBuffer and antiAliasing flags are conditional features. With the
 130  * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 131  * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 132  * for more information.
 133  * &lt;p&gt;
 134  * A default headlight will be added to a scene that contains one or more
 135  * {@code Shape3D} nodes, but no light nodes. This light source is a
 136  * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 137  *
 138  * &lt;p&gt;
 139  * A {@code Scene} may be created and modified on any thread until it is attached
 140  * to a {@link Window} that is {@link Window#isShowing() showing}.
 141  * After that, it must be modified only on the JavaFX Application Thread.
 142  * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 143  * multiple threads at the same time will lead to unpredictable results and
 144  * must be avoided.
 145  * &lt;/p&gt;
 146  *
 147  * &lt;p&gt;
 148  * The JavaFX Application Thread is created as part of the startup process for
 149  * the JavaFX runtime. See the {@link javafx.application.Application} class and
 150  * the {@link Platform#startup(Runnable)} method for more information.
 151  * &lt;/p&gt;
 152  *
 153  * &lt;p&gt;Example:&lt;/p&gt;
 154  *
 155  * &lt;pre&gt;
 156 import javafx.scene.*;
 157 import javafx.scene.paint.*;
 158 import javafx.scene.shape.*;
 159 
 160 Group root = new Group();
 161 Scene s = new Scene(root, 300, 300, Color.BLACK);
 162 
 163 Rectangle r = new Rectangle(25,25,250,250);
 164 r.setFill(Color.BLUE);
 165 
 166 root.getChildren().add(r);
 167  * &lt;/pre&gt;
 168  *
 169  * @since JavaFX 2.0
 170  */
 171 @DefaultProperty(&quot;root&quot;)
 172 public class Scene implements EventTarget {
 173 
 174     private double widthSetByUser = -1.0;
 175     private double heightSetByUser = -1.0;
 176     private boolean sizeInitialized = false;
 177     private final boolean depthBuffer;
 178     private final SceneAntialiasing antiAliasing;
 179 
 180     private EnumSet&lt;DirtyBits&gt; dirtyBits = EnumSet.noneOf(DirtyBits.class);
 181 
 182     final AccessControlContext acc = AccessController.getContext();
 183 
 184     private Camera defaultCamera;
 185 
 186     /**
 187      * A node that is temporarily responsible for the FOCUS_NODE
 188      * accessibility attribute. E.g. a currently active MenuBar.
 189      */
 190     private Node transientFocusContainer;
 191 
 192     //Neither width nor height are initialized and will be calculated according to content when this Scene
 193     //is shown for the first time.
 194 //    public Scene() {
 195 //        //this(-1, -1, (Parent) new Group());
 196 //        this(-1, -1, (Parent)null);
 197 //    }
 198 
 199     /**
 200      * Creates a Scene for a specific root Node.
 201      *
 202      * @param root The root node of the scene graph
 203      *
 204      * @throws NullPointerException if root is null
 205      */
 206     public Scene(@NamedArg(&quot;root&quot;) Parent root) {
 207         this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
 208     }
 209 
 210 //Public constructor initializing public-init properties
 211 //When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
 212 //Unitialized dimension is calculated when Scene is shown for the first time.
 213 //    public Scene(
 214 //            @Default(&quot;-1&quot;) double width,
 215 //            @Default(&quot;-1&quot;) double height) {
 216 //        //this(width, height, (Parent)new Group());
 217 //        this(width, height, (Parent)null);
 218 //    }
 219 //
 220 //    public Scene(double width, double height, Paint fill) {
 221 //        //this(width, height, (Parent) new Group());
 222 //        this(width, height, (Parent)null);
 223 //        setFill(fill);
 224 //    }
 225 
 226     /**
 227      * Creates a Scene for a specific root Node with a specific size.
 228      *
 229      * @param root The root node of the scene graph
 230      * @param width The width of the scene
 231      * @param height The height of the scene
 232      *
 233      * @throws NullPointerException if root is null
 234      */
 235     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
 236         this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
 237     }
 238 
 239     /**
 240      * Creates a Scene for a specific root Node with a fill.
 241      *
 242      * @param root The parent
 243      * @param fill The fill
 244      *
 245      * @throws NullPointerException if root is null
 246      */
 247     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 248         this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
 249     }
 250 
 251     /**
 252      * Creates a Scene for a specific root Node with a specific size and fill.
 253      *
 254      * @param root The root node of the scene graph
 255      * @param width The width of the scene
 256      * @param height The height of the scene
 257      * @param fill The fill
 258      *
 259      * @throws NullPointerException if root is null
 260      */
 261     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
 262             @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 263         this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
 264     }
 265 
 266     /**
 267      * Constructs a scene consisting of a root, with a dimension of width and
 268      * height, and specifies whether a depth buffer is created for this scene.
 269      * &lt;p&gt;
 270      * A scene with only 2D shapes and without any 3D transforms does not need a
 271      * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
 272      * transforms may use depth buffer support for proper depth sorted
 273      * rendering; to avoid depth fighting (also known as Z fighting), disable
 274      * depth testing on 2D shapes that have no 3D transforms. See
 275      * {@link Node#depthTestProperty() depthTest} for more information.
 276      *
 277      * @param root The root node of the scene graph
 278      * @param width The width of the scene
 279      * @param height The height of the scene
 280      * @param depthBuffer The depth buffer flag
 281      * &lt;p&gt;
 282      * The depthBuffer flag is a conditional feature and its default value is
 283      * false. See
 284      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 285      * for more information.
 286      *
 287      * @throws NullPointerException if root is null
 288      *
 289      * @see javafx.scene.Node#setDepthTest(DepthTest)
 290      */
 291     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
 292         this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
 293     }
 294 
 295     /**
 296      * Constructs a scene consisting of a root, with a dimension of width and
 297      * height, specifies whether a depth buffer is created for this scene and
 298      * specifies whether scene anti-aliasing is requested.
 299      * &lt;p&gt;
 300      * A scene with only 2D shapes and without any 3D transforms does not need a
 301      * depth buffer nor scene anti-aliasing support. A scene containing 3D
 302      * shapes or 2D shapes with 3D transforms may use depth buffer support for
 303      * proper depth sorted rendering; to avoid depth fighting (also known as Z
 304      * fighting), disable depth testing on 2D shapes that have no 3D transforms.
 305      * See {@link Node#depthTestProperty() depthTest} for more information. A
 306      * scene with 3D shapes may enable scene anti-aliasing to improve its
 307      * rendering quality.
 308      *
 309      * @param root The root node of the scene graph
 310      * @param width The width of the scene
 311      * @param height The height of the scene
 312      * @param depthBuffer The depth buffer flag
 313      * @param antiAliasing The scene anti-aliasing attribute. A value of
 314      * {@code null} is treated as DISABLED.
 315      * &lt;p&gt;
 316      * The depthBuffer and antiAliasing are conditional features. With the
 317      * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
 318      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 319      * for more information.
 320      *
 321      * @throws NullPointerException if root is null
 322      *
 323      * @see javafx.scene.Node#setDepthTest(DepthTest)
 324      * @since JavaFX 8.0
 325      */
 326     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
 327             @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
 328             @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
 329         this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);
 330 
 331         if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
 332                 !Toolkit.getToolkit().isMSAASupported())
 333         {
 334             String logname = Scene.class.getName();
 335             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 336                 + &quot;antiAliasing&quot;);
 337         }
 338     }
 339 
 340     private Scene(Parent root, double width, double height, Paint fill,
 341             boolean depthBuffer, SceneAntialiasing antiAliasing) {
 342         this.depthBuffer = depthBuffer;
 343         this.antiAliasing = antiAliasing;
 344         if (root == null) {
 345             throw new NullPointerException(&quot;Root cannot be null&quot;);
 346         }
 347 
 348         if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
 349                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
 350             String logname = Scene.class.getName();
 351             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 352                     + &quot;ConditionalFeature.SCENE3D&quot;);
 353         }
 354 
 355         init();
 356         setRoot(root);
 357         init(width, height);
 358         setFill(fill);
 359     }
 360 
 361     static {
 362             PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
 363                 public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
 364                     synchronized (trackerMonitor) {
 365                         scene.tracker = tracker;
 366                     }
 367                 }
 368                 public PerformanceTracker getPerfTracker(Scene scene) {
 369                     synchronized (trackerMonitor) {
 370                         return scene.tracker;
 371                     }
 372                 }
 373             });
 374             SceneHelper.setSceneAccessor(
 375                     new SceneHelper.SceneAccessor() {
 376                         @Override
 377                         public void enableInputMethodEvents(Scene scene, boolean enable) {
 378                             scene.enableInputMethodEvents(enable);
 379                         }
 380 
 381                         @Override
 382                         public void processKeyEvent(Scene scene, KeyEvent e) {
 383                             scene.processKeyEvent(e);
 384                         }
 385 
 386                         @Override
 387                         public void processMouseEvent(Scene scene, MouseEvent e) {
 388                             scene.processMouseEvent(e);
 389                         }
 390 
 391                         @Override
 392                         public void preferredSize(Scene scene) {
 393                             scene.preferredSize();
 394                         }
 395 
 396                         @Override
 397                         public void disposePeer(Scene scene) {
 398                             scene.disposePeer();
 399                         }
 400 
 401                         @Override
 402                         public void initPeer(Scene scene) {
 403                             scene.initPeer();
 404                         }
 405 
 406                         @Override
 407                         public void setWindow(Scene scene, Window window) {
 408                             scene.setWindow(window);
 409                         }
 410 
 411                         @Override
 412                         public TKScene getPeer(Scene scene) {
 413                             return scene.getPeer();
 414                         }
 415 
 416                         @Override
 417                         public void setAllowPGAccess(boolean flag) {
 418                             Scene.setAllowPGAccess(flag);
 419                         }
 420 
 421                         @Override
 422                         public void parentEffectiveOrientationInvalidated(
 423                                 final Scene scene) {
 424                             scene.parentEffectiveOrientationInvalidated();
 425                         }
 426 
 427                         @Override
 428                         public Camera getEffectiveCamera(Scene scene) {
 429                             return scene.getEffectiveCamera();
 430                         }
 431 
 432                         @Override
 433                         public Scene createPopupScene(Parent root) {
 434                             return new Scene(root) {
 435                                        @Override
 436                                        void doLayoutPass() {
 437                                            resizeRootToPreferredSize(getRoot());
 438                                            super.doLayoutPass();
 439                                        }
 440 
 441                                        @Override
 442                                        void resizeRootOnSceneSizeChange(
 443                                                double newWidth,
 444                                                double newHeight) {
 445                                            // don&#39;t resize
 446                                        }
 447                                    };
 448                         }
 449 
 450                         @Override
 451                         public void setTransientFocusContainer(Scene scene, Node node) {
 452                             if (scene != null) {
 453                                 scene.transientFocusContainer = node;
 454                             }
 455                         }
 456 
 457                         @Override
 458                         public Accessible getAccessible(Scene scene) {
 459                             return scene.getAccessible();
 460                         }
 461                     });
 462         }
 463 
 464         // Reserve space for 30 nodes in the dirtyNodes set.
 465         private static final int MIN_DIRTY_CAPACITY = 30;
 466 
 467         // For debugging
 468         private static boolean inSynchronizer = false;
 469         private static boolean inMousePick = false;
 470         private static boolean allowPGAccess = false;
 471         private static int pgAccessCount = 0;
 472 
 473         /**
 474          * Used for debugging purposes. Returns true if we are in either the
 475          * mouse event code (picking) or the synchronizer, or if the scene is
 476          * not yet initialized,
 477          *
 478          */
 479         static boolean isPGAccessAllowed() {
 480             return inSynchronizer || inMousePick || allowPGAccess;
 481         }
 482 
 483         static void setAllowPGAccess(boolean flag) {
 484             if (Utils.assertionEnabled()) {
 485                 if (flag) {
 486                     pgAccessCount++;
 487                     allowPGAccess = true;
 488                 }
 489                 else {
 490                     if (pgAccessCount &lt;= 0) {
 491                         throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
 492                     }
 493                     if (--pgAccessCount == 0) {
 494                         allowPGAccess = false;
 495                     }
 496                 }
 497             }
 498         }
 499 
 500         /**
 501          * If true, use the platform&#39;s drag gesture detection
 502          * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
 503          */
 504         private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
 505 
 506     /**
 507      * Set of dirty nodes; processed once per frame by the synchronizer.
 508      * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
 509      * to the graphics stack and requires synchronization, then that node
 510      * is added to this list. Note that if state on the Node changes, but it
 511      * was already dirty, then the Node doesn&#39;t add itself again.
 512      * &lt;p&gt;
 513      * Because at initialization time every node in the scene graph is dirty,
 514      * we have a special state and special code path during initialization
 515      * that does not involve adding each node to the dirtyNodes list. When
 516      * dirtyNodes is null, that means this Scene has not yet been synchronized.
 517      * A good default size is then created for the dirtyNodes list.
 518      * &lt;p&gt;
 519      * We double-buffer the set so that we can add new nodes to the
 520      * set while processing the existing set. This avoids our having to
 521      * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
 522      */
 523     private Node[] dirtyNodes;
 524     private int dirtyNodesSize;
 525 
 526     /**
 527      * Add the specified node to this scene&#39;s dirty list. Called by the
 528      * markDirty method in Node or when the Node&#39;s scene changes.
 529      */
 530     void addToDirtyList(Node n) {
 531         if (dirtyNodes == null || dirtyNodesSize == 0) {
 532             if (peer != null) {
 533                 Toolkit.getToolkit().requestNextPulse();
 534             }
 535         }
 536 
 537         if (dirtyNodes != null) {
 538             if (dirtyNodesSize == dirtyNodes.length) {
 539                 Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
 540                 System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
 541                 dirtyNodes = tmp;
 542             }
 543             dirtyNodes[dirtyNodesSize++] = n;
 544         }
 545     }
 546 
 547     private void doCSSPass() {
 548         final Parent sceneRoot = getRoot();
 549         //
 550         // RT-17547: when the tree is synchronized, the dirty bits are
 551         // are cleared but the cssFlag might still be something other than
 552         // clean.
 553         //
 554         // Before RT-17547, the code checked the dirty bit. But this is
 555         // superfluous since the dirty bit will be set if the flag is not clean,
 556         // but the flag will never be anything other than clean if the dirty
 557         // bit is not set. The dirty bit is still needed, however, since setting
 558         // it ensures a pulse if no other dirty bits have been set.
 559         //
 560         // For the purpose of showing the change, the dirty bit
 561         // check code was commented out and not removed.
 562         //
 563 //        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
 564         if (sceneRoot.cssFlag != CssFlags.CLEAN) {
 565             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 566             // The cssFlag is set to clean in either Node.processCSS or
 567             // NodeHelper.processCSS
 568             sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 569             sceneRoot.processCSS();
 570         }
 571     }
 572 
 573     void doLayoutPass() {
 574         final Parent r = getRoot();
 575         if (r != null) {
 576             r.layout();
 577         }
 578     }
 579 
 580     /**
 581      * The peer of this scene
 582      */
 583     private TKScene peer;
 584 
 585     /*
 586      * Get Scene&#39;s peer
 587      */
 588     TKScene getPeer() {
 589         return peer;
 590     }
 591 
 592     /**
 593      * The scene pulse listener that gets called on toolkit pulses
 594      */
 595     ScenePulseListener scenePulseListener = new ScenePulseListener();
 596 
 597     private List&lt;Runnable&gt; preLayoutPulseListeners;
 598     private List&lt;Runnable&gt; postLayoutPulseListeners;
 599 
 600     /**
 601      * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
 602      * this listener will be called on the JavaFX Application Thread directly
 603      * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
 604      * any rendering is done for
 605      * this frame. This scene pulse listener is suitable for knowing when a
 606      * scenegraph pulse is happening and also for modifying the scenegraph
 607      * (as it is called before CSS and layout, so any changes made will be properly
 608      * styled and positioned).
 609      *
 610      * This method must be called on the JavaFX Application thread.
 611      *
 612      * @param r The Runnable to be called when the pulse occurs.
 613      *
 614      * @throws IllegalStateException if this method is called on a thread
 615      * other than the JavaFX Application Thread.
 616      *
 617      * @throws NullPointerException if the provided Runnable is null.
 618      *
 619      * @since 9
 620      */
 621     public final void addPreLayoutPulseListener(Runnable r) {
 622         Toolkit.getToolkit().checkFxUserThread();
 623 
 624         if (r == null) {
 625             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 626         }
 627         if (preLayoutPulseListeners == null) {
 628             preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 629         }
 630         preLayoutPulseListeners.add(r);
 631     }
 632 
 633     /**
 634      * Removes a previously registered scene pre layout pulse listener from listening to
 635      * pulses in this scene. This method does nothing if the specified Runnable is
 636      * not already in the list.
 637      *
 638      * This method must be called on the JavaFX Application thread.
 639      *
 640      * @param r The Runnable that should no longer be called when the pulse
 641      * occurs for this scene.
 642      *
 643      * @throws IllegalStateException if this method is called on a thread
 644      * other than the JavaFX Application Thread.
 645      *
 646      * @since 9
 647      */
 648     public final void removePreLayoutPulseListener(Runnable r) {
 649         Toolkit.getToolkit().checkFxUserThread();
 650 
 651         if (preLayoutPulseListeners == null) {
 652             return;
 653         }
 654         preLayoutPulseListeners.remove(r);
 655     }
 656 
 657     /**
 658      * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
 659      * this listener will be called on the JavaFX Application Thread directly
 660      * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
 661      * this frame. This scene pulse listener is suitable for knowing when a
 662      * scenegraph pulse is happening, but it is not suited to use cases related
 663      * to modifying the scenegraph (as it is called after CSS and layout, so
 664      * any changes will possibly be incorrect until the next pulse is run).
 665      * An alternative (and better) solution for situations where a scenegraph
 666      * modification is required to happen is to use either the
 667      * {@link #addPreLayoutPulseListener(Runnable)} API or the the
 668      * {@link javafx.animation.AnimationTimer} API.
 669      *
 670      * This method must be called on the JavaFX Application thread.
 671      *
 672      * @param r The Runnable to be called when the pulse occurs.
 673      *
 674      * @throws IllegalStateException if this method is called on a thread
 675      * other than the JavaFX Application Thread.
 676      *
 677      * @throws NullPointerException if the provided Runnable is null.
 678      *
 679      * @since 9
 680      */
 681     public final void addPostLayoutPulseListener(Runnable r) {
 682         Toolkit.getToolkit().checkFxUserThread();
 683 
 684         if (r == null) {
 685             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 686         }
 687         if (postLayoutPulseListeners == null) {
 688             postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 689         }
 690         postLayoutPulseListeners.add(r);
 691     }
 692 
 693     /**
 694      * Removes a previously registered scene post layout pulse listener from listening to
 695      * pulses in this scene. This method does nothing if the specified Runnable is
 696      * not already in the list.
 697      *
 698      * This method must be called on the JavaFX Application thread.
 699      *
 700      * @param r The Runnable that should no longer be called when the pulse
 701      * occurs for this scene.
 702      *
 703      * @throws IllegalStateException if this method is called on a thread
 704      * other than the JavaFX Application Thread.
 705      *
 706      * @since 9
 707      */
 708     public final void removePostLayoutPulseListener(Runnable r) {
 709         Toolkit.getToolkit().checkFxUserThread();
 710 
 711         if (postLayoutPulseListeners == null) {
 712             return;
 713         }
 714         postLayoutPulseListeners.remove(r);
 715     }
 716 
 717     /**
 718      * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
 719      * &lt;p&gt;
 720      * Note: this is a conditional feature. See
 721      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 722      * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
 723      * for more information.
 724      * @return the SceneAntialiasing for this scene
 725      * @since JavaFX 8.0
 726      */
 727     public final SceneAntialiasing getAntiAliasing() {
 728         return antiAliasing;
 729     }
 730 
 731     private boolean getAntiAliasingInternal() {
 732         return (antiAliasing != null &amp;&amp;
 733                 Toolkit.getToolkit().isMSAASupported() &amp;&amp;
 734                 Platform.isSupported(ConditionalFeature.SCENE3D)) ?
 735                 antiAliasing != SceneAntialiasing.DISABLED : false;
 736     }
 737 
 738     /**
 739      * The {@code Window} for this {@code Scene}
 740      */
 741     private ReadOnlyObjectWrapper&lt;Window&gt; window;
 742 
 743     void setWindow(Window value) {
 744         windowPropertyImpl().set(value);
 745     }
 746 
 747     public final Window getWindow() {
 748         return window == null ? null : window.get();
 749     }
 750 
 751     public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
 752         return windowPropertyImpl().getReadOnlyProperty();
 753     }
 754 
 755     private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
 756         if (window == null) {
 757             window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
 758                 private Window oldWindow;
 759 
 760                 @Override protected void invalidated() {
 761                     final Window newWindow = get();
 762                     getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
 763                     if (oldWindow != null) {
 764                         disposePeer();
 765                     }
 766                     if (newWindow != null) {
 767                         initPeer();
 768                     }
 769                     parentEffectiveOrientationInvalidated();
 770 
 771                     oldWindow = newWindow;
 772                 }
 773 
 774                 @Override
 775                 public Object getBean() {
 776                     return Scene.this;
 777                 }
 778 
 779                 @Override
 780                 public String getName() {
 781                     return &quot;window&quot;;
 782                 }
 783             };
 784         }
 785         return window;
 786     }
 787 
 788     void initPeer() {
 789         assert peer == null;
 790 
 791         Window window = getWindow();
 792         // initPeer() is only called from Window, either when the window
 793         // is being shown, or the window scene is being changed. In any case
 794         // this scene&#39;s window cannot be null.
 795         assert window != null;
 796 
 797         TKStage windowPeer = WindowHelper.getPeer(window);
 798         if (windowPeer == null) {
 799             // This is fine, the window is not visible. initPeer() will
 800             // be called again later, when the window is being shown.
 801             return;
 802         }
 803 
 804         final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
 805         if (!isTransparentWindowsSupported) {
 806             PlatformImpl.addNoTransparencyStylesheetToScene(this);
 807         }
 808 
 809         PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);
 810 
 811         setAllowPGAccess(true);
 812 
 813         Toolkit tk = Toolkit.getToolkit();
 814         peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
 815         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
 816         peer.setTKSceneListener(new ScenePeerListener());
 817         peer.setTKScenePaintListener(new ScenePeerPaintListener());
 818         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
 819         peer.setRoot(getRoot().getPeer());
 820         peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
 821         NodeHelper.updatePeer(getEffectiveCamera());
 822         peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
 823         peer.markDirty();
 824         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);
 825 
 826         setAllowPGAccess(false);
 827 
 828         tk.addSceneTkPulseListener(scenePulseListener);
 829         // listen to dnd gestures coming from the platform
 830         if (PLATFORM_DRAG_GESTURE_INITIATION) {
 831             if (dragGestureListener == null) {
 832                 dragGestureListener = new DragGestureListener();
 833             }
 834             tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
 835         }
 836         tk.enableDrop(peer, new DropTargetListener());
 837         tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());
 838 
 839         PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
 840     }
 841 
 842     public void disposePeer() {
 843         if (peer == null) {
 844             // This is fine, the window is either not shown yet and there is no
 845             // need in disposing scene peer, or is hidden and disposePeer()
 846             // has already been called.
 847             return;
 848         }
 849 
 850         PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);
 851 
 852         Toolkit tk = Toolkit.getToolkit();
 853         tk.removeSceneTkPulseListener(scenePulseListener);
 854         if (accessible != null) {
 855             disposeAccessibles();
 856             Node root = getRoot();
 857             if (root != null) root.releaseAccessible();
 858             accessible.dispose();
 859             accessible = null;
 860         }
 861         peer.dispose();
 862         peer = null;
 863 
 864         PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
 865     }
 866 
 867     DnDGesture dndGesture = null;
 868     DragGestureListener dragGestureListener;
 869     /**
 870      * The horizontal location of this {@code Scene} on the {@code Window}.
 871      */
 872     private ReadOnlyDoubleWrapper x;
 873 
 874     private final void setX(double value) {
 875         xPropertyImpl().set(value);
 876     }
 877 
 878     public final double getX() {
 879         return x == null ? 0.0 : x.get();
 880     }
 881 
 882     public final ReadOnlyDoubleProperty xProperty() {
 883         return xPropertyImpl().getReadOnlyProperty();
 884     }
 885 
 886     private ReadOnlyDoubleWrapper xPropertyImpl() {
 887         if (x == null) {
 888             x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
 889         }
 890         return x;
 891     }
 892 
 893     /**
 894      * The vertical location of this {@code Scene} on the {@code Window}.
 895      */
 896     private ReadOnlyDoubleWrapper y;
 897 
 898     private final void setY(double value) {
 899         yPropertyImpl().set(value);
 900     }
 901 
 902     public final double getY() {
 903         return y == null ? 0.0 : y.get();
 904     }
 905 
 906     public final ReadOnlyDoubleProperty yProperty() {
 907         return yPropertyImpl().getReadOnlyProperty();
 908     }
 909 
 910     private ReadOnlyDoubleWrapper yPropertyImpl() {
 911         if (y == null) {
 912             y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
 913         }
 914         return y;
 915     }
 916 
 917     /**
 918      * The width of this {@code Scene}
 919      */
 920     private ReadOnlyDoubleWrapper width;
 921 
 922     private final void setWidth(double value) {
 923         widthPropertyImpl().set(value);
 924     }
 925 
 926     public final double getWidth() {
 927         return width == null ? 0.0 : width.get();
 928     }
 929 
 930     public final ReadOnlyDoubleProperty widthProperty() {
 931         return widthPropertyImpl().getReadOnlyProperty();
 932     }
 933 
 934     private ReadOnlyDoubleWrapper widthPropertyImpl() {
 935         if (width == null) {
 936             width = new ReadOnlyDoubleWrapper() {
 937 
 938                 @Override
 939                 protected void invalidated() {
 940                     final Parent _root = getRoot();
 941                     //TODO - use a better method to update mirroring
 942                     if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 943                         NodeHelper.transformsChanged(_root);
 944                     }
 945                     if (_root.isResizable()) {
 946                         resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
 947                     }
 948 
 949                     getEffectiveCamera().setViewWidth(get());
 950                 }
 951 
 952                 @Override
 953                 public Object getBean() {
 954                     return Scene.this;
 955                 }
 956 
 957                 @Override
 958                 public String getName() {
 959                     return &quot;width&quot;;
 960                 }
 961             };
 962         }
 963         return width;
 964     }
 965 
 966     /**
 967      * The height of this {@code Scene}
 968      */
 969     private ReadOnlyDoubleWrapper height;
 970 
 971     private final void setHeight(double value) {
 972         heightPropertyImpl().set(value);
 973     }
 974 
 975     public final double getHeight() {
 976         return height == null ? 0.0 : height.get();
 977     }
 978 
 979     public final ReadOnlyDoubleProperty heightProperty() {
 980         return heightPropertyImpl().getReadOnlyProperty();
 981     }
 982 
 983     private ReadOnlyDoubleWrapper heightPropertyImpl() {
 984         if (height == null) {
 985             height = new ReadOnlyDoubleWrapper() {
 986 
 987                 @Override
 988                 protected void invalidated() {
 989                     final Parent _root = getRoot();
 990                     if (_root.isResizable()) {
 991                         resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
 992                     }
 993 
 994                     getEffectiveCamera().setViewHeight(get());
 995                 }
 996 
 997                 @Override
 998                 public Object getBean() {
 999                     return Scene.this;
1000                 }
1001 
1002                 @Override
1003                 public String getName() {
1004                     return &quot;height&quot;;
1005                 }
1006             };
1007         }
1008         return height;
1009     }
1010 
1011     void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
1012         getRoot().resize(newWidth, newHeight);
1013     }
1014 
1015     // Reusable target wrapper (to avoid creating new one for each picking)
1016     private TargetWrapper tmpTargetWrapper = new TargetWrapper();
1017 
1018     /**
1019      * Specifies the type of camera use for rendering this {@code Scene}.
1020      * If {@code camera} is null, a parallel camera is used for rendering.
1021      * It is illegal to set a camera that belongs to other {@code Scene}
1022      * or {@code SubScene}.
1023      * &lt;p&gt;
1024      * Note: this is a conditional feature. See
1025      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
1026      * for more information.
1027      *
1028      * @defaultValue null
1029      */
1030     private ObjectProperty&lt;Camera&gt; camera;
1031 
1032     public final void setCamera(Camera value) {
1033         cameraProperty().set(value);
1034     }
1035 
1036     public final Camera getCamera() {
1037         return camera == null ? null : camera.get();
1038     }
1039 
1040     public final ObjectProperty&lt;Camera&gt; cameraProperty() {
1041         if (camera == null) {
1042             camera = new ObjectPropertyBase&lt;Camera&gt;() {
1043                 Camera oldCamera = null;
1044 
1045                 @Override
1046                 protected void invalidated() {
1047                     Camera _value = get();
1048                     if (_value != null) {
1049                         if (_value instanceof PerspectiveCamera
1050                                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
1051                             String logname = Scene.class.getName();
1052                             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
1053                                     + &quot;ConditionalFeature.SCENE3D&quot;);
1054                         }
1055                         // Illegal value if it belongs to other scene or any subscene
1056                         if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
1057                                 || _value.getSubScene() != null) {
1058                             throw new IllegalArgumentException(_value
1059                                     + &quot;is already part of other scene or subscene&quot;);
1060                         }
1061                         // throws exception if the camera already has a different owner
1062                         _value.setOwnerScene(Scene.this);
1063                         _value.setViewWidth(getWidth());
1064                         _value.setViewHeight(getHeight());
1065                     }
1066                     if (oldCamera != null &amp;&amp; oldCamera != _value) {
1067                         oldCamera.setOwnerScene(null);
1068                     }
1069                     oldCamera = _value;
1070                 }
1071 
1072                 @Override
1073                 public Object getBean() {
1074                     return Scene.this;
1075                 }
1076 
1077                 @Override
1078                 public String getName() {
1079                     return &quot;camera&quot;;
1080                 }
1081             };
1082         }
1083         return camera;
1084     }
1085 
1086     Camera getEffectiveCamera() {
1087         final Camera cam = getCamera();
1088         if (cam == null
1089                 || (cam instanceof PerspectiveCamera
1090                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
1091             if (defaultCamera == null) {
1092                 defaultCamera = new ParallelCamera();
1093                 defaultCamera.setOwnerScene(this);
1094                 defaultCamera.setViewWidth(getWidth());
1095                 defaultCamera.setViewHeight(getHeight());
1096             }
1097             return defaultCamera;
1098         }
1099 
1100         return cam;
1101     }
1102 
1103     // Used by the camera
1104     void markCameraDirty() {
1105         markDirty(DirtyBits.CAMERA_DIRTY);
1106         setNeedsRepaint();
1107     }
1108 
1109     void markCursorDirty() {
1110         markDirty(DirtyBits.CURSOR_DIRTY);
1111     }
1112 
1113     /**
1114      * Defines the background fill of this {@code Scene}. Both a {@code null}
1115      * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
1116      * with transparency are supported. The default fill of the Scene is
1117      * {@link Color#WHITE}, but it is more commonly the case that the initial
1118      * color shown to users is the background fill of the
1119      * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
1120      * stretched to take up all available space in the {@code Scene}. The
1121      * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
1122      * the default user agent stylesheets that ship with JavaFX (presently
1123      * Caspian and Modena) apply styling on to this root style class. In the
1124      * case of Caspian this does not impact the background fill color of the
1125      * root node, but in the case of Modena the default fill is set to be a
1126      * light gray color.
1127      *
1128      * @defaultValue WHITE
1129      */
1130     private ObjectProperty&lt;Paint&gt; fill;
1131 
1132     public final void setFill(Paint value) {
1133         fillProperty().set(value);
1134     }
1135 
1136     public final Paint getFill() {
1137         return fill == null ? Color.WHITE : fill.get();
1138     }
1139 
1140     public final ObjectProperty&lt;Paint&gt; fillProperty() {
1141         if (fill == null) {
1142             fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {
1143 
1144                 @Override
1145                 protected void invalidated() {
1146                     markDirty(DirtyBits.FILL_DIRTY);
1147                 }
1148 
1149                 @Override
1150                 public Object getBean() {
1151                     return Scene.this;
1152                 }
1153 
1154                 @Override
1155                 public String getName() {
1156                     return &quot;fill&quot;;
1157                 }
1158             };
1159         }
1160         return fill;
1161     }
1162 
1163     /**
1164      * Defines the root {@code Node} of the scene graph.
1165      * If a {@code Group} is used as the root, the
1166      * contents of the scene graph will be clipped by the scene&#39;s width and height and
1167      * changes to the scene&#39;s size (if user resizes the stage) will not alter the
1168      * layout of the scene graph.    If a resizable node (layout {@code Region} or
1169      * {@code Control}) is set as the root, then the root&#39;s size will track the
1170      * scene&#39;s size, causing the contents to be relayed out as necessary.
1171      *
1172      * Scene doesn&#39;t accept null root.
1173      *
1174      */
1175     private ObjectProperty&lt;Parent&gt; root;
1176 
1177     public final void setRoot(Parent value) {
1178         rootProperty().set(value);
1179     }
1180 
1181     public final Parent getRoot() {
1182         return root == null ? null : root.get();
1183     }
1184 
1185     Parent oldRoot;
1186     public final ObjectProperty&lt;Parent&gt; rootProperty() {
1187         if (root == null) {
1188             root = new ObjectPropertyBase&lt;Parent&gt;() {
1189 
1190                 private void forceUnbind() {
1191                     System.err.println(&quot;Unbinding illegal root.&quot;);
1192                     unbind();
1193                 }
1194 
1195                 @Override
1196                 protected void invalidated() {
1197                     Parent _value = get();
1198 
1199                     if (_value == null) {
1200                         if (isBound()) forceUnbind();
1201                         throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);
1202                     }
1203 
1204                     if (_value.getParent() != null) {
1205                         if (isBound()) forceUnbind();
1206                         throw new IllegalArgumentException(_value +
1207                                 &quot;is already inside a scene-graph and cannot be set as root&quot;);
1208                     }
1209                     if (_value.getClipParent() != null) {
1210                         if (isBound()) forceUnbind();
1211                         throw new IllegalArgumentException(_value +
1212                                 &quot;is set as a clip on another node, so cannot be set as root&quot;);
1213                     }
1214                     if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
1215                         if (isBound()) forceUnbind();
1216                         throw new IllegalArgumentException(_value +
1217                                 &quot;is already set as root of another scene&quot;);
1218                     }
1219 
1220                     if (oldRoot != null) {
1221                         oldRoot.setScenes(null, null);
1222                     }
1223                     oldRoot = _value;
1224                     _value.getStyleClass().add(0, &quot;root&quot;);
1225                     _value.setScenes(Scene.this, null);
1226                     markDirty(DirtyBits.ROOT_DIRTY);
1227                     _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
1228                     _value.requestLayout();
1229                 }
1230 
1231                 @Override
1232                 public Object getBean() {
1233                     return Scene.this;
1234                 }
1235 
1236                 @Override
1237                 public String getName() {
1238                     return &quot;root&quot;;
1239                 }
1240             };
1241         }
1242         return root;
1243     }
1244 
1245     void setNeedsRepaint() {
1246         if (this.peer != null) {
1247             peer.entireSceneNeedsRepaint();
1248         }
1249     }
1250 
1251     // Process CSS and layout and sync the scene prior to the snapshot
1252     // operation of the given node for this scene (currently the node
1253     // is unused but could possibly be used in the future to optimize this)
1254     void doCSSLayoutSyncForSnapshot(Node node) {
1255         if (!sizeInitialized) {
1256             preferredSize();
1257         } else {
1258             doCSSPass();
1259         }
1260 
1261         // we do not need pulse in the snapshot code
1262         // because this scene can be stage-less
1263         doLayoutPass();
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
1284             double x, double y, double w, double h,
1285             Node root, BaseTransform transform, boolean depthBuffer,
1286             Paint fill, Camera camera, WritableImage wimg) {
1287 
<a name="2" id="anc2"></a>


1288         int xMin = (int)Math.floor(x);
1289         int yMin = (int)Math.floor(y);
<a name="3" id="anc3"></a><span class="line-modified">1290         int width;</span>
<span class="line-modified">1291         int height;</span>


1292         if (wimg == null) {
<a name="4" id="anc4"></a><span class="line-added">1293             int xMax = (int)Math.ceil(x + w);</span>
<span class="line-added">1294             int yMax = (int)Math.ceil(y + h);</span>
<span class="line-added">1295             width = Math.max(xMax - xMin, 1);</span>
<span class="line-added">1296             height = Math.max(yMax - yMin, 1);</span>
1297             wimg = new WritableImage(width, height);
1298         } else {
1299             width = (int)wimg.getWidth();
1300             height = (int)wimg.getHeight();
1301         }
1302 
<a name="5" id="anc5"></a><span class="line-added">1303         // Attempt to capture snapshot</span>
<span class="line-added">1304         try {</span>
<span class="line-added">1305             wimg = doSnapshotTile(scene, xMin, yMin, width, height, root, transform, depthBuffer, fill, camera, wimg);</span>
<span class="line-added">1306         } catch (Exception e) {</span>
<span class="line-added">1307             // A first attempt to capture a snapshot failed, most likely because it is larger than</span>
<span class="line-added">1308             // maxTextureSize: retry by taking several snapshot tiles and merge them into single image</span>
<span class="line-added">1309             // (Addresses JDK-8088198)</span>
<span class="line-added">1310             int maxTextureSize = PrismSettings.maxTextureSize;</span>
<span class="line-added">1311             int numVerticalTiles = (int) Math.ceil(height / (double) maxTextureSize);</span>
<span class="line-added">1312             int numHorizontalTiles = (int) Math.ceil(width / (double) maxTextureSize);</span>
<span class="line-added">1313             for (int i = 0; i &lt; numHorizontalTiles; i++) {</span>
<span class="line-added">1314                 int xOffset = i * maxTextureSize;</span>
<span class="line-added">1315                 int tileWidth = Math.min(maxTextureSize, width - xOffset);</span>
<span class="line-added">1316                 for (int j = 0; j &lt; numVerticalTiles; j++) {</span>
<span class="line-added">1317                     int yOffset = j * maxTextureSize;</span>
<span class="line-added">1318                     int tileHeight = Math.min(maxTextureSize, height - yOffset);</span>
<span class="line-added">1319                     WritableImage tile = doSnapshotTile(scene, xMin + xOffset, yMin + yOffset, tileWidth,</span>
<span class="line-added">1320                             tileHeight, root, transform, depthBuffer, fill, camera, null);</span>
<span class="line-added">1321                     wimg.getPixelWriter().setPixels(xOffset, yOffset, tileWidth, tileHeight, tile.getPixelReader(), 0, 0);</span>
<span class="line-added">1322                 }</span>
<span class="line-added">1323             }</span>
<span class="line-added">1324         }</span>
<span class="line-added">1325 </span>
<span class="line-added">1326         // if this scene belongs to some stage</span>
<span class="line-added">1327         // we need to mark the entire scene as dirty</span>
<span class="line-added">1328         // because dirty logic is buggy</span>
<span class="line-added">1329         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-added">1330             scene.setNeedsRepaint();</span>
<span class="line-added">1331         }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333         return wimg;</span>
<span class="line-added">1334     }</span>
<span class="line-added">1335 </span>
<span class="line-added">1336     /**</span>
<span class="line-added">1337      * Capture a single snapshot tile</span>
<span class="line-added">1338      */</span>
<span class="line-added">1339     private static WritableImage doSnapshotTile(Scene scene,</span>
<span class="line-added">1340                     int x, int y, int w, int h,</span>
<span class="line-added">1341                     Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-added">1342                     Paint fill, Camera camera, WritableImage tileImg) {</span>
<span class="line-added">1343         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-added">1344         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-added">1345         if (tileImg == null) {</span>
<span class="line-added">1346             tileImg = new WritableImage(w, h);</span>
<span class="line-added">1347         }</span>
1348         setAllowPGAccess(true);
<a name="6" id="anc6"></a><span class="line-modified">1349         context.x = x;</span>
<span class="line-modified">1350         context.y = y;</span>
<span class="line-modified">1351         context.width = w;</span>
<span class="line-modified">1352         context.height = h;</span>
1353         context.transform = transform;
1354         context.depthBuffer = depthBuffer;
1355         context.root = root.getPeer();
1356         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1357         double cameraViewWidth = 1.0;
1358         double cameraViewHeight = 1.0;
1359         if (camera != null) {
1360             // temporarily adjust camera viewport to the snapshot size
1361             cameraViewWidth = camera.getViewWidth();
1362             cameraViewHeight = camera.getViewHeight();
<a name="7" id="anc7"></a><span class="line-modified">1363             camera.setViewWidth(w);</span>
<span class="line-modified">1364             camera.setViewHeight(h);</span>
1365             NodeHelper.updatePeer(camera);
1366             context.camera = camera.getPeer();
1367         } else {
1368             context.camera = null;
1369         }
1370 
1371         // Grab the lights from the scene
1372         context.lights = null;
1373         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1374             context.lights = new NGLightBase[scene.lights.size()];
1375             for (int i = 0; i &lt; scene.lights.size(); i++) {
1376                 context.lights[i] = scene.lights.get(i).getPeer();
1377             }
1378         }
1379 
1380         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<a name="8" id="anc8"></a><span class="line-modified">1381         context.platformImage = accessor.getTkImageLoader(tileImg);</span>
1382         setAllowPGAccess(false);
1383         Object tkImage = tk.renderToImage(context);
<a name="9" id="anc9"></a><span class="line-modified">1384         accessor.loadTkImage(tileImg, tkImage);</span>
1385 
1386         if (camera != null) {
1387             setAllowPGAccess(true);
1388             camera.setViewWidth(cameraViewWidth);
1389             camera.setViewHeight(cameraViewHeight);
1390             NodeHelper.updatePeer(camera);
1391             setAllowPGAccess(false);
1392         }
<a name="10" id="anc10"></a><span class="line-modified">1393         return tileImg;</span>








1394     }
1395 
1396     /**
1397      * Implementation method for snapshot
1398      */
1399     private WritableImage doSnapshot(WritableImage img) {
1400         // TODO: no need to do CSS, layout or sync in the deferred case,
1401         // if this scene is attached to a visible stage
1402         doCSSLayoutSyncForSnapshot(getRoot());
1403 
1404         double w = getWidth();
1405         double h = getHeight();
1406         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1407 
1408         return doSnapshot(this, 0, 0, w, h,
1409                 getRoot(), transform, isDepthBufferInternal(),
1410                 getFill(), getEffectiveCamera(), img);
1411     }
1412 
1413     // Pulse listener used to run all deferred (async) snapshot requests
1414     private static TKPulseListener snapshotPulseListener = null;
1415 
1416     private static List&lt;Runnable&gt; snapshotRunnableListA;
1417     private static List&lt;Runnable&gt; snapshotRunnableListB;
1418     private static List&lt;Runnable&gt; snapshotRunnableList;
1419 
1420     static void addSnapshotRunnable(final Runnable runnable) {
1421         Toolkit.getToolkit().checkFxUserThread();
1422 
1423         if (snapshotPulseListener == null) {
1424             snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
1425             snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
1426             snapshotRunnableList = snapshotRunnableListA;
1427 
1428             snapshotPulseListener = () -&gt; {
1429                 if (snapshotRunnableList.size() &gt; 0) {
1430                     List&lt;Runnable&gt; runnables = snapshotRunnableList;
1431                     if (snapshotRunnableList == snapshotRunnableListA) {
1432                         snapshotRunnableList = snapshotRunnableListB;
1433                     } else {
1434                         snapshotRunnableList = snapshotRunnableListA;
1435                     }
1436                     for (Runnable r : runnables) {
1437                         try {
1438                             r.run();
1439                         } catch (Throwable th) {
1440                             System.err.println(&quot;Exception in snapshot runnable&quot;);
1441                             th.printStackTrace(System.err);
1442                         }
1443                     }
1444                     runnables.clear();
1445                 }
1446             };
1447 
1448             // Add listener that will be called after all of the scenes have
1449             // had layout and CSS processing, and have been synced
1450             Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
1451         }
1452 
1453         final AccessControlContext acc = AccessController.getContext();
1454         snapshotRunnableList.add(() -&gt; {
1455             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1456                 runnable.run();
1457                 return null;
1458             }, acc);
1459         });
1460         Toolkit.getToolkit().requestNextPulse();
1461     }
1462 
1463     /**
1464      * Takes a snapshot of this scene and returns the rendered image when
1465      * it is ready.
1466      * CSS and layout processing will be done for the scene prior to
1467      * rendering it.
1468      * The entire destination image is cleared using the fill {@code Paint}
1469      * of this scene. The nodes in the scene are then rendered to the image.
1470      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1471      * If the image is smaller than the size of the scene, then the rendering
1472      * will be clipped by the image.
1473      *
1474      * &lt;p&gt;
1475      * When taking a snapshot of a scene that is being animated, either
1476      * explicitly by the application or implicitly (such as chart animation),
1477      * the snapshot will be rendered based on the state of the scene graph at
1478      * the moment the snapshot is taken and will not reflect any subsequent
1479      * animation changes.
1480      * &lt;/p&gt;
1481      *
1482      * @param image the writable image that will be used to hold the rendered scene.
1483      * It may be null in which case a new WritableImage will be constructed.
1484      * If the image is non-null, the scene will be rendered into the
1485      * existing image.
1486      * In this case, the width and height of the image determine the area
1487      * that is rendered instead of the width and height of the scene.
1488      *
1489      * @throws IllegalStateException if this method is called on a thread
1490      *     other than the JavaFX Application Thread.
1491      *
1492      * @return the rendered image
1493      * @since JavaFX 2.2
1494      */
1495     public WritableImage snapshot(WritableImage image) {
1496         Toolkit.getToolkit().checkFxUserThread();
1497 
1498         return doSnapshot(image);
1499     }
1500 
1501     /**
1502      * Takes a snapshot of this scene at the next frame and calls the
1503      * specified callback method when the image is ready.
1504      * CSS and layout processing will be done for the scene prior to
1505      * rendering it.
1506      * The entire destination image is cleared using the fill {@code Paint}
1507      * of this scene. The nodes in the scene are then rendered to the image.
1508      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1509      * If the image is smaller than the size of the scene, then the rendering
1510      * will be clipped by the image.
1511      *
1512      * &lt;p&gt;
1513      * This is an asynchronous call, which means that other
1514      * events or animation might be processed before the scene is rendered.
1515      * If any such events modify a node in the scene that modification will
1516      * be reflected in the rendered image (as it will also be reflected in
1517      * the frame rendered to the Stage).
1518      * &lt;/p&gt;
1519      *
1520      * &lt;p&gt;
1521      * When taking a snapshot of a scene that is being animated, either
1522      * explicitly by the application or implicitly (such as chart animation),
1523      * the snapshot will be rendered based on the state of the scene graph at
1524      * the moment the snapshot is taken and will not reflect any subsequent
1525      * animation changes.
1526      * &lt;/p&gt;
1527      *
1528      * @param callback a class whose call method will be called when the image
1529      * is ready. The SnapshotResult that is passed into the call method of
1530      * the callback will contain the rendered image and the source scene
1531      * that was rendered. The callback parameter must not be null.
1532      *
1533      * @param image the writable image that will be used to hold the rendered scene.
1534      * It may be null in which case a new WritableImage will be constructed.
1535      * If the image is non-null, the scene will be rendered into the
1536      * existing image.
1537      * In this case, the width and height of the image determine the area
1538      * that is rendered instead of the width and height of the scene.
1539      *
1540      * @throws IllegalStateException if this method is called on a thread
1541      *     other than the JavaFX Application Thread.
1542      *
1543      * @throws NullPointerException if the callback parameter is null.
1544      * @since JavaFX 2.2
1545      */
1546     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
1547         Toolkit.getToolkit().checkFxUserThread();
1548         if (callback == null) {
1549             throw new NullPointerException(&quot;The callback must not be null&quot;);
1550         }
1551 
1552         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
1553         final WritableImage theImage = image;
1554 
1555         // Create a deferred runnable that will be run from a pulse listener
1556         // that is called after all of the scenes have been synced but before
1557         // any of them have been rendered.
1558         final Runnable snapshotRunnable = () -&gt; {
1559             WritableImage img = doSnapshot(theImage);
1560 //                System.err.println(&quot;Calling snapshot callback&quot;);
1561             SnapshotResult result = new SnapshotResult(img, Scene.this, null);
1562             try {
1563                 Void v = theCallback.call(result);
1564             } catch (Throwable th) {
1565                 System.err.println(&quot;Exception in snapshot callback&quot;);
1566                 th.printStackTrace(System.err);
1567             }
1568         };
1569 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
1570         addSnapshotRunnable(snapshotRunnable);
1571     }
1572 
1573     /**
1574      * Defines the mouse cursor for this {@code Scene}.
1575      */
1576     private ObjectProperty&lt;Cursor&gt; cursor;
1577 
1578     public final void setCursor(Cursor value) {
1579         cursorProperty().set(value);
1580     }
1581 
1582     public final Cursor getCursor() {
1583         return cursor == null ? null : cursor.get();
1584     }
1585 
1586     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
1587         if (cursor == null) {
1588             cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
1589                          @Override
1590                          protected void invalidated() {
1591                              markCursorDirty();
1592                          }
1593 
1594                          @Override
1595                          public Object getBean() {
1596                              return Scene.this;
1597                          }
1598 
1599                          @Override
1600                          public String getName() {
1601                              return &quot;cursor&quot;;
1602                          }
1603                      };
1604         }
1605         return cursor;
1606     }
1607 
1608     /**
1609      * Looks for any node within the scene graph based on the specified CSS selector.
1610      * If more than one node matches the specified selector, this function
1611      * returns the first of them.
1612      * If no nodes are found with this id, then null is returned.
1613      *
1614      * @param selector The css selector to look up
1615      * @return the {@code Node} in the scene which matches the CSS {@code selector},
1616      * or {@code null} if none is found.
1617      */
1618      public Node lookup(String selector) {
1619          return getRoot().lookup(selector);
1620      }
1621     /**
1622      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1623      * contents. For additional information about using CSS with the
1624      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1625      * Guide&lt;/a&gt;.
1626      */
1627     private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
1628         @Override
1629         protected void onChanged(Change&lt;String&gt; c) {
1630             StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
1631             // RT-9784 - if stylesheet is removed, reset styled properties to
1632             // their initial value.
1633             c.reset();
1634             while(c.next()) {
1635                 if (c.wasRemoved() == false) {
1636                     continue;
1637                 }
1638                 break; // no point in resetting more than once...
1639             }
1640             getRoot().reapplyCSS();
1641         }
1642     };
1643 
1644     /**
1645      * Gets an observable list of string URLs linking to the stylesheets to use
1646      * with this scene&#39;s contents.
1647      * &lt;p&gt;
1648      * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1649      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1650      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1651      * the root of the application&#39;s classpath.
1652      * &lt;/p&gt;
1653      * &lt;pre&gt;&lt;code&gt;
1654      *
1655      * package com.example.javafx.app;
1656      *
1657      * import javafx.application.Application;
1658      * import javafx.scene.Group;
1659      * import javafx.scene.Scene;
1660      * import javafx.stage.Stage;
1661      *
1662      * public class MyApp extends Application {
1663      *
1664      *     {@literal @}Override public void start(Stage stage) {
1665      *         Scene scene = new Scene(new Group());
1666      *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
1667      *         stage.setScene(scene);
1668      *         stage.show();
1669      *     }
1670      *
1671      *     public static void main(String[] args) {
1672      *         launch(args);
1673      *     }
1674      * }
1675      * &lt;/code&gt;&lt;/pre&gt;
1676      * For additional information about using CSS with the scene graph,
1677      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1678      *
1679      * @return the list of stylesheets to use with this scene
1680      */
1681     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1682 
1683     private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
1684 
1685     /**
1686      * @return the userAgentStylesheet property.
1687      * @see #getUserAgentStylesheet()
1688      * @see #setUserAgentStylesheet(String)
1689      * @since  JavaFX 8u20
1690      */
1691     public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
1692         if (userAgentStylesheet == null) {
1693             userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
1694                 @Override protected void invalidated() {
1695                     StyleManager.getInstance().forget(Scene.this);
1696                     getRoot().reapplyCSS();
1697                 }
1698             };
1699         }
1700         return userAgentStylesheet;
1701     }
1702 
1703     /**
1704      * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
1705      * the platform-default user-agent stylesheet will be used.
1706      * &lt;p&gt;
1707      * For additional information about using CSS with the scene graph,
1708      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1709      * &lt;/p&gt;
1710      * @return The URL of the user-agent stylesheet that will be used by this Scene,
1711      * or null if has not been set.
1712      * @since  JavaFX 8u20
1713      */
1714     public final String getUserAgentStylesheet() {
1715         return userAgentStylesheet == null ? null : userAgentStylesheet.get();
1716     }
1717 
1718     /**
1719      * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
1720      * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
1721      * the platform-default user-agent stylesheet will be used.
1722      * &lt;p&gt;
1723      * For additional information about using CSS with the scene graph,
1724      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1725      * &lt;/p&gt;
1726      * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1727      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1728      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1729      * the root of the application&#39;s classpath.
1730      * @since  JavaFX 8u20
1731      */
1732     public final void setUserAgentStylesheet(String url) {
1733         userAgentStylesheetProperty().set(url);
1734     }
1735 
1736     /**
1737      * Retrieves the depth buffer attribute for this scene.
1738      * @return the depth buffer attribute.
1739      */
1740     public final boolean isDepthBuffer() {
1741         return depthBuffer;
1742     }
1743 
1744     boolean isDepthBufferInternal() {
1745         if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
1746             return false;
1747         }
1748         return depthBuffer;
1749     }
1750 
1751     private void init(double width, double height) {
1752         if (width &gt;= 0) {
1753             widthSetByUser = width;
1754             setWidth((float)width);
1755         }
1756         if (height &gt;= 0) {
1757             heightSetByUser = height;
1758             setHeight((float)height);
1759         }
1760         sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
1761     }
1762 
1763     private void init() {
1764         if (PerformanceTracker.isLoggingEnabled()) {
1765             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
1766         }
1767         mouseHandler = new MouseHandler();
1768         clickGenerator = new ClickGenerator();
1769 
1770         if (PerformanceTracker.isLoggingEnabled()) {
1771             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
1772         }
1773     }
1774 
1775     void preferredSize() {
1776         final Parent root = getRoot();
1777 
1778         // one or the other isn&#39;t initialized, need to perform layout in
1779         // order to ensure we can properly measure the preferred size of the
1780         // scene
1781         doCSSPass();
1782 
1783         resizeRootToPreferredSize(root);
1784         doLayoutPass();
1785 
1786         if (widthSetByUser &lt; 0) {
1787             setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
1788                             root.getBoundsInParent().getMaxX());
1789         } else {
1790             setWidth(widthSetByUser);
1791         }
1792 
1793         if (heightSetByUser &lt; 0) {
1794             setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
1795                             root.getBoundsInParent().getMaxY());
1796         } else {
1797             setHeight(heightSetByUser);
1798         }
1799 
1800         sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);
1801 
1802         PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
1803     }
1804 
1805     final void resizeRootToPreferredSize(Parent root) {
1806         final double preferredWidth;
1807         final double preferredHeight;
1808 
1809         final Orientation contentBias = root.getContentBias();
1810         if (contentBias == null) {
1811             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1812             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1813         } else if (contentBias == Orientation.HORIZONTAL) {
1814             // height depends on width
1815             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1816             preferredHeight = getPreferredHeight(root, heightSetByUser,
1817                                                        preferredWidth);
1818         } else /* if (contentBias == Orientation.VERTICAL) */ {
1819             // width depends on height
1820             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1821             preferredWidth = getPreferredWidth(root, widthSetByUser,
1822                                                      preferredHeight);
1823         }
1824 
1825         root.resize(preferredWidth, preferredHeight);
1826     }
1827 
1828     private static double getPreferredWidth(Parent root,
1829                                             double forcedWidth,
1830                                             double height) {
1831         if (forcedWidth &gt;= 0) {
1832             return forcedWidth;
1833         }
1834         final double normalizedHeight = (height &gt;= 0) ? height : -1;
1835         return root.boundedSize(root.prefWidth(normalizedHeight),
1836                                 root.minWidth(normalizedHeight),
1837                                 root.maxWidth(normalizedHeight));
1838     }
1839 
1840     private static double getPreferredHeight(Parent root,
1841                                              double forcedHeight,
1842                                              double width) {
1843         if (forcedHeight &gt;= 0) {
1844             return forcedHeight;
1845         }
1846         final double normalizedWidth = (width &gt;= 0) ? width : -1;
1847         return root.boundedSize(root.prefHeight(normalizedWidth),
1848                                 root.minHeight(normalizedWidth),
1849                                 root.maxHeight(normalizedWidth));
1850     }
1851 
1852     private PerformanceTracker tracker;
1853     private static final Object trackerMonitor = new Object();
1854 
1855     // mouse events handling
1856     private MouseHandler mouseHandler;
1857     private ClickGenerator clickGenerator;
1858 
1859     // gesture events handling
1860     private Point2D cursorScreenPos;
1861     private Point2D cursorScenePos;
1862 
1863     private static class TouchGesture {
1864         WeakReference&lt;EventTarget&gt; target;
1865         Point2D sceneCoords;
1866         Point2D screenCoords;
1867         boolean finished;
1868     }
1869 
1870     private final TouchGesture scrollGesture = new TouchGesture();
1871     private final TouchGesture zoomGesture = new TouchGesture();
1872     private final TouchGesture rotateGesture = new TouchGesture();
1873     private final TouchGesture swipeGesture = new TouchGesture();
1874 
1875     // touch events handling
1876     private TouchMap touchMap = new TouchMap();
1877     private TouchEvent nextTouchEvent = null;
1878     private TouchPoint[] touchPoints = null;
1879     private int touchEventSetId = 0;
1880     private int touchPointIndex = 0;
1881     private Map&lt;Integer, EventTarget&gt; touchTargets =
1882             new HashMap&lt;Integer, EventTarget&gt;();
1883 
1884     void processMouseEvent(MouseEvent e) {
1885         mouseHandler.process(e, false);
1886     }
1887 
1888     private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
1889         EventTarget eventTarget = null;
1890         Scene.inMousePick = true;
1891         if (isKeyboardTrigger) {
1892             Node sceneFocusOwner = getFocusOwner();
1893 
1894             // for keyboard triggers set coordinates inside focus owner
1895             final double xOffset = xAbs - x2;
1896             final double yOffset = yAbs - y2;
1897             if (sceneFocusOwner != null) {
1898                 final Bounds bounds = sceneFocusOwner.localToScene(
1899                         sceneFocusOwner.getBoundsInLocal());
1900                 x2 = bounds.getMinX() + bounds.getWidth() / 4;
1901                 y2 = bounds.getMinY() + bounds.getHeight() / 2;
1902                 eventTarget = sceneFocusOwner;
1903             } else {
1904                 x2 = Scene.this.getWidth() / 4;
1905                 y2 = Scene.this.getWidth() / 2;
1906                 eventTarget = Scene.this;
1907             }
1908 
1909             xAbs = x2 + xOffset;
1910             yAbs = y2 + yOffset;
1911         }
1912 
1913         final PickResult res = pick(x2, y2);
1914 
1915         if (!isKeyboardTrigger) {
1916             eventTarget = res.getIntersectedNode();
1917             if (eventTarget == null) {
1918                 eventTarget = this;
1919             }
1920         }
1921 
1922         if (eventTarget != null) {
1923             ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
1924                     x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
1925             Event.fireEvent(eventTarget, context);
1926         }
1927         Scene.inMousePick = false;
1928     }
1929 
1930     private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
1931         EventTarget pickedTarget = null;
1932 
1933         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1934                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1935                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1936             gesture.target = null;
1937             gesture.finished = false;
1938         }
1939 
1940         if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
1941             pickedTarget = gesture.target.get();
1942         } else {
1943             pickedTarget = e.getPickResult().getIntersectedNode();
1944             if (pickedTarget == null) {
1945                 pickedTarget = this;
1946             }
1947         }
1948 
1949         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1950                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1951                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1952             gesture.target = new WeakReference&lt;&gt;(pickedTarget);
1953         }
1954         if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
1955                 e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
1956                 e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
1957                 !e.isInertia()) {
1958             gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
1959             gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
1960         }
1961 
1962         if (pickedTarget != null) {
1963             Event.fireEvent(pickedTarget, e);
1964         }
1965 
1966         if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
1967                 e.getEventType() == RotateEvent.ROTATION_FINISHED ||
1968                 e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
1969             gesture.finished = true;
1970         }
1971     }
1972 
1973     private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
1974         inMousePick = true;
1975         touchEventSetId++;
1976 
1977         List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);
1978 
1979         // fire all the events
1980         for (TouchPoint tp : touchPoints) {
1981             if (tp.getTarget() != null) {
1982                 EventType&lt;TouchEvent&gt; type = null;
1983                 switch (tp.getState()) {
1984                     case MOVED:
1985                         type = TouchEvent.TOUCH_MOVED;
1986                         break;
1987                     case PRESSED:
1988                         type = TouchEvent.TOUCH_PRESSED;
1989                         break;
1990                     case RELEASED:
1991                         type = TouchEvent.TOUCH_RELEASED;
1992                         break;
1993                     case STATIONARY:
1994                         type = TouchEvent.TOUCH_STATIONARY;
1995                         break;
1996                 }
1997 
1998                 for (TouchPoint t : touchPoints) {
1999                     TouchPointHelper.reset(t);
2000                 }
2001 
2002                 TouchEvent te = new TouchEvent(type, tp, touchList,
2003                         touchEventSetId, e.isShiftDown(), e.isControlDown(),
2004                         e.isAltDown(), e.isMetaDown());
2005 
2006                 Event.fireEvent(tp.getTarget(), te);
2007             }
2008         }
2009 
2010         // process grabbing
2011         for (TouchPoint tp : touchPoints) {
2012             EventTarget grabbed = tp.getGrabbed();
2013             if (grabbed != null) {
2014                 touchTargets.put(tp.getId(), grabbed);
2015             };
2016 
2017             if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
2018                 touchTargets.remove(tp.getId());
2019             }
2020         }
2021 
2022         inMousePick = false;
2023     }
2024 
2025     /**
2026      * Note: The only user of this method is in unit test: PickAndContainTest.
2027      */
2028     Node test_pick(double x, double y) {
2029         inMousePick = true;
2030         PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
2031                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
2032         inMousePick = false;
2033         if (result != null) {
2034             return result.getIntersectedNode();
2035         }
2036         return null;
2037     }
2038 
2039     private PickResult pick(final double x, final double y) {
2040         pick(tmpTargetWrapper, x, y);
2041         return tmpTargetWrapper.getResult();
2042     }
2043 
2044     private boolean isInScene(double x, double y) {
2045         if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
2046             return false;
2047         }
2048 
2049         Window w = getWindow();
2050         if (w instanceof Stage
2051                 &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
2052                 &amp;&amp; getFill() == null) {
2053             return false;
2054         }
2055 
2056         return true;
2057     }
2058 
2059     private void pick(TargetWrapper target, final double x, final double y) {
2060         final PickRay pickRay = getEffectiveCamera().computePickRay(
2061                 x, y, null);
2062 
2063         final double mag = pickRay.getDirectionNoClone().length();
2064         pickRay.getDirectionNoClone().normalize();
2065         final PickResult res = mouseHandler.pickNode(pickRay);
2066         if (res != null) {
2067             target.setNodeResult(res);
2068         } else {
2069             //TODO: is this the intersection with projection plane?
2070             Vec3d o = pickRay.getOriginNoClone();
2071             Vec3d d = pickRay.getDirectionNoClone();
2072             target.setSceneResult(new PickResult(
2073                     null, new Point3D(
2074                     o.x + mag * d.x,
2075                     o.y + mag * d.y,
2076                     o.z + mag * d.z),
2077                     mag),
2078                     isInScene(x, y) ? this : null);
2079         }
2080     }
2081 
2082     /***************************************************************************
2083      *                                                                         *
2084      * Key Events and Focus Traversal                                          *
2085      *                                                                         *
2086      **************************************************************************/
2087 
2088     /*
2089      * We cannot initialize keyHandler in init because some of the triggers
2090      * access it before the init block.
2091      * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
2092      * does not compile.
2093      */
2094     private KeyHandler keyHandler = null;
2095     private KeyHandler getKeyHandler() {
2096         if (keyHandler == null) {
2097             keyHandler = new KeyHandler();
2098         }
2099         return keyHandler;
2100     }
2101     /**
2102      * Set to true if something has happened to the focused node that makes
2103      * it no longer eligible to have the focus.
2104      *
2105      */
2106     private boolean focusDirty = true;
2107 
2108     final void setFocusDirty(boolean value) {
2109         if (!focusDirty) {
2110             Toolkit.getToolkit().requestNextPulse();
2111         }
2112         focusDirty = value;
2113     }
2114 
2115     final boolean isFocusDirty() {
2116         return focusDirty;
2117     }
2118 
2119     private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);
2120 
2121     /**
2122      * Traverses focus from the given node in the given direction.
2123      */
2124     boolean traverse(Node node, Direction dir) {
2125         if (node.getSubScene() != null) {
2126             return node.getSubScene().traverse(node, dir);
2127         }
2128         return traversalEngine.trav(node, dir) != null;
2129     }
2130 
2131     /**
2132      * Moves the focus to a reasonable initial location. Called when a scene&#39;s
2133      * focus is dirty and there&#39;s no current owner, or if the owner has been
2134      * removed from the scene.
2135      */
2136     private void focusInitial() {
2137         traversalEngine.traverseToFirst();
2138     }
2139 
2140     /**
2141      * Moves the focus to a reasonble location &quot;near&quot; the given node.
2142      * Called when the focused node is no longer eligible to have
2143      * the focus because it has become invisible or disabled. This
2144      * function assumes that it is still a member of the same scene.
2145      */
2146     private void focusIneligible(Node node) {
2147         traverse(node, Direction.NEXT);
2148     }
2149 
2150     public void processKeyEvent(KeyEvent e) {
2151         if (dndGesture != null) {
2152             if (!dndGesture.processKey(e)) {
2153                 dndGesture = null;
2154             }
2155         }
2156 
2157         getKeyHandler().process(e);
2158     }
2159 
2160     void requestFocus(Node node) {
2161         getKeyHandler().requestFocus(node);
2162     }
2163 
2164     private Node oldFocusOwner;
2165 
2166     /**
2167       * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
2168       * variable might be false if this scene has no window, or if the
2169       * window is inactive (window.focused == false).
2170       * @since JavaFX 2.2
2171       */
2172     private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {
2173 
2174         @Override
2175         protected void invalidated() {
2176             if (oldFocusOwner != null) {
2177                 ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
2178             }
2179             Node value = get();
2180             if (value != null) {
2181                 ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
2182                 if (value != oldFocusOwner) {
2183                     value.getScene().enableInputMethodEvents(
2184                             value.getInputMethodRequests() != null
2185                             &amp;&amp; value.getOnInputMethodTextChanged() != null);
2186                 }
2187             }
2188             // for the rest of the method we need to update the oldFocusOwner
2189             // and use a local copy of it because the user handlers can cause
2190             // recurrent calls of requestFocus
2191             Node localOldOwner = oldFocusOwner;
2192             oldFocusOwner = value;
2193             if (localOldOwner != null) {
2194                 ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
2195             }
2196             if (value != null) {
2197                 ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
2198             }
2199             PlatformLogger logger = Logging.getFocusLogger();
2200             if (logger.isLoggable(Level.FINE)) {
2201                 if (value == get()) {
2202                     logger.fine(&quot;Changed focus from &quot;
2203                             + localOldOwner + &quot; to &quot; + value);
2204                 } else {
2205                     logger.fine(&quot;Changing focus from &quot;
2206                             + localOldOwner + &quot; to &quot; + value
2207                             + &quot; canceled by nested requestFocus&quot;);
2208                 }
2209             }
2210             if (accessible != null) {
2211                 accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
2212             }
2213         }
2214     };
2215 
2216     public final Node getFocusOwner() {
2217         return focusOwner.get();
2218     }
2219 
2220     public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
2221         return focusOwner.getReadOnlyProperty();
2222     }
2223 
2224     // For testing.
2225     void focusCleanup() {
2226         scenePulseListener.focusCleanup();
2227     }
2228 
2229     private void processInputMethodEvent(InputMethodEvent e) {
2230         Node node = getFocusOwner();
2231         if (node != null) {
2232             node.fireEvent(e);
2233         }
2234     }
2235 
2236     public void enableInputMethodEvents(boolean enable) {
2237        if (peer != null) {
2238            peer.enableInputMethodEvents(enable);
2239        }
2240     }
2241 
2242     /**
2243      * Returns true if this scene is quiescent, i.e. it has no activity
2244      * pending on it such as CSS processing or layout requests.
2245      *
2246      * Intended to be used for tests only
2247      *
2248      * @return boolean indicating whether the scene is quiescent
2249      */
2250     boolean isQuiescent() {
2251         final Parent r = getRoot();
2252         return !isFocusDirty()
2253                &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
2254                 r.layoutFlag == LayoutFlags.CLEAN));
2255     }
2256 
2257     /**
2258      * A listener for pulses, used for testing. If non-null, this is called at
2259      * the very end of ScenePulseListener.pulse().
2260      *
2261      * Intended to be used for tests only
2262      */
2263     Runnable testPulseListener = null;
2264 
2265     /**
2266      * Set the specified dirty bit and mark the peer as dirty
2267      */
2268     private void markDirty(DirtyBits dirtyBit) {
2269         setDirty(dirtyBit);
2270         if (peer != null) {
2271             Toolkit.getToolkit().requestNextPulse();
2272         }
2273     }
2274 
2275     /**
2276      * Set the specified dirty bit
2277      */
2278     private void setDirty(DirtyBits dirtyBit) {
2279         dirtyBits.add(dirtyBit);
2280     }
2281 
2282     /**
2283      * Test the specified dirty bit
2284      */
2285     private boolean isDirty(DirtyBits dirtyBit) {
2286         return dirtyBits.contains(dirtyBit);
2287     }
2288 
2289     /**
2290      * Test whether the dirty bits are empty
2291      */
2292     private boolean isDirtyEmpty() {
2293         return dirtyBits.isEmpty();
2294     }
2295 
2296     /**
2297      * Clear all dirty bits
2298      */
2299     private void clearDirty() {
2300         dirtyBits.clear();
2301     }
2302 
2303     private enum DirtyBits {
2304         FILL_DIRTY,
2305         ROOT_DIRTY,
2306         CAMERA_DIRTY,
2307         LIGHTS_DIRTY,
2308         CURSOR_DIRTY;
2309     }
2310 
2311     private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();
2312 
2313     // @param light must not be null
2314     final void addLight(LightBase light) {
2315         if (!lights.contains(light)) {
2316             lights.add(light);
2317             markDirty(DirtyBits.LIGHTS_DIRTY);
2318         }
2319     }
2320 
2321     final void removeLight(LightBase light) {
2322         if (lights.remove(light)) {
2323             markDirty(DirtyBits.LIGHTS_DIRTY);
2324         }
2325     }
2326 
2327     /**
2328      * PG Light synchronizer.
2329      */
2330     private void syncLights() {
2331         if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
2332             return;
2333         }
2334         inSynchronizer = true;
2335         NGLightBase peerLights[] = peer.getLights();
2336         if (!lights.isEmpty() || (peerLights != null)) {
2337             if (lights.isEmpty()) {
2338                 peer.setLights(null);
2339             } else {
2340                 if (peerLights == null || peerLights.length &lt; lights.size()) {
2341                     peerLights = new NGLightBase[lights.size()];
2342                 }
2343                 int i = 0;
2344                 for (; i &lt; lights.size(); i++) {
2345                     peerLights[i] = lights.get(i).getPeer();
2346                 }
2347                 // Clear the rest of the list
2348                 while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
2349                     peerLights[i++] = null;
2350                 }
2351                 peer.setLights(peerLights);
2352             }
2353         }
2354         inSynchronizer = false;
2355     }
2356 
2357     //INNER CLASSES
2358 
2359     /*******************************************************************************
2360      *                                                                             *
2361      * Scene Pulse Listener                                                        *
2362      *                                                                             *
2363      ******************************************************************************/
2364 
2365     class ScenePulseListener implements TKPulseListener {
2366 
2367         private boolean firstPulse = true;
2368 
2369         /**
2370          * PG synchronizer. Called once per frame from the pulse listener.
2371          * This function calls the synchronizePGNode method on each node in
2372          * the dirty list.
2373          */
2374         private void synchronizeSceneNodes() {
2375             Toolkit.getToolkit().checkFxUserThread();
2376 
2377             Scene.inSynchronizer = true;
2378 
2379             // if dirtyNodes is null then that means this Scene has not yet been
2380             // synchronized, and so we will simply synchronize every node in the
2381             // scene and then create the dirty nodes array list
2382             if (Scene.this.dirtyNodes == null) {
2383                 // must do this recursively
2384                 syncAll(getRoot());
2385                 dirtyNodes = new Node[MIN_DIRTY_CAPACITY];
2386 
2387             } else {
2388                 // This is not the first time this scene has been synchronized,
2389                 // so we will only synchronize those nodes that need it
2390                 for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
2391                     Node node = dirtyNodes[i];
2392                     dirtyNodes[i] = null;
2393                     if (node.getScene() == Scene.this) {
2394                             node.syncPeer();
2395                         }
2396                     }
2397                 dirtyNodesSize = 0;
2398             }
2399 
2400             Scene.inSynchronizer = false;
2401         }
2402 
2403         /**
2404          * Recursive function for synchronizing every node in the scenegraph.
2405          * The return value is the number of nodes in the graph.
2406          */
2407         private int syncAll(Node node) {
2408             node.syncPeer();
2409             int size = 1;
2410             if (node instanceof Parent) {
2411                 Parent p = (Parent) node;
2412                 final int childrenCount = p.getChildren().size();
2413 
2414                 for (int i = 0; i &lt; childrenCount; i++) {
2415                     Node n = p.getChildren().get(i);
2416                     if (n != null) {
2417                         size += syncAll(n);
2418                     }
2419                 }
2420             } else if (node instanceof SubScene) {
2421                 SubScene subScene = (SubScene)node;
2422                 size += syncAll(subScene.getRoot());
2423             }
2424             if (node.getClip() != null) {
2425                 size += syncAll(node.getClip());
2426             }
2427 
2428             return size;
2429         }
2430 
2431         private void synchronizeSceneProperties() {
2432             inSynchronizer = true;
2433             if (isDirty(DirtyBits.ROOT_DIRTY)) {
2434                 peer.setRoot(getRoot().getPeer());
2435             }
2436 
2437             if (isDirty(DirtyBits.FILL_DIRTY)) {
2438                 Toolkit tk = Toolkit.getToolkit();
2439                 peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
2440             }
2441 
2442             // new camera was set on the scene or old camera changed
2443             final Camera cam = getEffectiveCamera();
2444             if (isDirty(DirtyBits.CAMERA_DIRTY)) {
2445                 NodeHelper.updatePeer(cam);
2446                 peer.setCamera((NGCamera) cam.getPeer());
2447             }
2448 
2449             if (isDirty(DirtyBits.CURSOR_DIRTY)) {
2450                 mouseHandler.updateCursor(getCursor());
2451                 mouseHandler.updateCursorFrame();
2452             }
2453 
2454             clearDirty();
2455             inSynchronizer = false;
2456         }
2457 
2458         /**
2459          * The focus is considered dirty if something happened to
2460          * the scene graph that may require the focus to be moved.
2461          * This must handle cases where (a) the focus owner may have
2462          * become ineligible to have the focus, and (b) where the focus
2463          * owner is null and a node may have become traversable and eligible.
2464          */
2465         private void focusCleanup() {
2466             if (Scene.this.isFocusDirty()) {
2467                 final Node oldOwner = Scene.this.getFocusOwner();
2468                 if (oldOwner == null) {
2469                     Scene.this.focusInitial();
2470                 } else if (oldOwner.getScene() != Scene.this) {
2471                     Scene.this.requestFocus(null);
2472                     Scene.this.focusInitial();
2473                 } else if (!oldOwner.isCanReceiveFocus()) {
2474                     Scene.this.requestFocus(null);
2475                     Scene.this.focusIneligible(oldOwner);
2476                 }
2477                 Scene.this.setFocusDirty(false);
2478             }
2479         }
2480 
2481         @Override
2482         public void pulse() {
2483             if (Scene.this.tracker != null) {
2484                 Scene.this.tracker.pulse();
2485             }
2486             if (firstPulse) {
2487                 PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
2488             }
2489 
2490             focusCleanup();
2491 
2492             disposeAccessibles();
2493 
2494             // run any scene pre pulse listeners immediately _before_ css / layout,
2495             // and before scene synchronization
2496             if (preLayoutPulseListeners != null) {
2497                 for (Runnable r : preLayoutPulseListeners) {
2498                     r.run();
2499                 }
2500             }
2501 
2502             if (PULSE_LOGGING_ENABLED) {
2503                 PulseLogger.newPhase(&quot;CSS Pass&quot;);
2504             }
2505             Scene.this.doCSSPass();
2506 
2507             if (PULSE_LOGGING_ENABLED) {
2508                 PulseLogger.newPhase(&quot;Layout Pass&quot;);
2509             }
2510             Scene.this.doLayoutPass();
2511 
2512             // run any scene post pulse listeners immediately _after_ css / layout,
2513             // and before scene synchronization
2514             if (postLayoutPulseListeners != null) {
2515                 for (Runnable r : postLayoutPulseListeners) {
2516                     r.run();
2517                 }
2518             }
2519 
2520             boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
2521             if (dirty) {
2522                 if (PULSE_LOGGING_ENABLED) {
2523                     PulseLogger.newPhase(&quot;Update bounds&quot;);
2524                 }
2525                 getRoot().updateBounds();
2526                 if (peer != null) {
2527                     try {
2528                         if (PULSE_LOGGING_ENABLED) {
2529                             PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
2530                         }
2531                         peer.waitForRenderingToComplete();
2532                         peer.waitForSynchronization();
2533                         // synchronize scene properties
2534                         if (PULSE_LOGGING_ENABLED) {
2535                             PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
2536                         }
2537                         syncLights();
2538                         synchronizeSceneProperties();
2539                         // Run the synchronizer
2540                         synchronizeSceneNodes();
2541                         Scene.this.mouseHandler.pulse();
2542                         // Tell the scene peer that it needs to repaint
2543                         peer.markDirty();
2544                     } finally {
2545                         peer.releaseSynchronization(true);
2546                     }
2547                 } else {
2548                     if (PULSE_LOGGING_ENABLED) {
2549                         PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
2550                     }
2551                     synchronizeSceneNodes();
2552                     Scene.this.mouseHandler.pulse();
2553                 }
2554 
2555                 if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
2556                     NodeHelper.markDirty(Scene.this.getRoot(),
2557                             com.sun.javafx.scene.DirtyBits.NODE_CSS);
2558                 }
2559             }
2560 
2561             // required for image cursor created from animated image
2562             Scene.this.mouseHandler.updateCursorFrame();
2563 
2564             if (firstPulse) {
2565                 if (PerformanceTracker.isLoggingEnabled()) {
2566                     PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
2567                     if (PrismSettings.perfLogFirstPaintFlush) {
2568                         PerformanceTracker.outputLog();
2569                     }
2570                     if (PrismSettings.perfLogFirstPaintExit) {
2571                         System.exit(0);
2572                     }
2573                 }
2574                 firstPulse = false;
2575             }
2576 
2577             if (testPulseListener != null) {
2578                 testPulseListener.run();
2579             }
2580         }
2581     }
2582 
2583     /*******************************************************************************
2584      *                                                                             *
2585      * Scene Peer Listener                                                         *
2586      *                                                                             *
2587      ******************************************************************************/
2588 
2589     class ScenePeerListener implements TKSceneListener {
2590         @Override
2591         public void changedLocation(float x, float y) {
2592             if (x != Scene.this.getX()) {
2593                 Scene.this.setX(x);
2594             }
2595             if (y != Scene.this.getY()) {
2596                 Scene.this.setY(y);
2597             }
2598         }
2599 
2600         @Override
2601         public void changedSize(float w, float h) {
2602             if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
2603             if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
2604         }
2605 
2606         @Override
2607         public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
2608                                MouseButton button, boolean popupTrigger, boolean synthesized,
2609                                boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
2610                                boolean primaryDown, boolean middleDown, boolean secondaryDown,
2611                                boolean backDown, boolean forwardDown)
2612         {
2613             MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
2614                     0, // click count will be adjusted by clickGenerator later anyway
2615                     shiftDown, controlDown, altDown, metaDown,
2616                     primaryDown, middleDown, secondaryDown, backDown, forwardDown,
2617                     synthesized, popupTrigger, false, null);
2618             processMouseEvent(mouseEvent);
2619         }
2620 
2621 
2622         @Override
2623         public void keyEvent(KeyEvent keyEvent)
2624         {
2625             processKeyEvent(keyEvent);
2626         }
2627 
2628         @Override
2629         public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
2630                                      ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
2631                                      int caretPosition)
2632         {
2633             InputMethodEvent inputMethodEvent = new InputMethodEvent(
2634                type, composed, committed, caretPosition);
2635             processInputMethodEvent(inputMethodEvent);
2636         }
2637 
2638         public void menuEvent(double x, double y, double xAbs, double yAbs,
2639                 boolean isKeyboardTrigger) {
2640             Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
2641         }
2642 
2643         @Override
2644         public void scrollEvent(
2645                 EventType&lt;ScrollEvent&gt; eventType,
2646                 double scrollX, double scrollY,
2647                 double totalScrollX, double totalScrollY,
2648                 double xMultiplier, double yMultiplier,
2649                 int touchCount,
2650                 int scrollTextX, int scrollTextY,
2651                 int defaultTextX, int defaultTextY,
2652                 double x, double y, double screenX, double screenY,
2653                 boolean _shiftDown, boolean _controlDown,
2654                 boolean _altDown, boolean _metaDown,
2655                 boolean _direct, boolean _inertia) {
2656 
2657             ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
2658                     ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
2659                     ScrollEvent.HorizontalTextScrollUnits.NONE;
2660 
2661             double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;
2662 
2663             ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
2664                     ScrollEvent.VerticalTextScrollUnits.LINES :
2665                     (scrollTextY &lt; 0 ?
2666                         ScrollEvent.VerticalTextScrollUnits.PAGES :
2667                         ScrollEvent.VerticalTextScrollUnits.NONE);
2668 
2669             double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;
2670 
2671             xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
2672                     ? Math.round(xMultiplier * scrollTextX / defaultTextX)
2673                     : xMultiplier;
2674 
2675             yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
2676                     ? Math.round(yMultiplier * scrollTextY / defaultTextY)
2677                     : yMultiplier;
2678 
2679             if (eventType == ScrollEvent.SCROLL_FINISHED) {
2680                 x = scrollGesture.sceneCoords.getX();
2681                 y = scrollGesture.sceneCoords.getY();
2682                 screenX = scrollGesture.screenCoords.getX();
2683                 screenY = scrollGesture.screenCoords.getY();
2684             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2685                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2686                 if (cursorScenePos == null || cursorScreenPos == null) {
2687                     return;
2688                 }
2689                 x = cursorScenePos.getX();
2690                 y = cursorScenePos.getY();
2691                 screenX = cursorScreenPos.getX();
2692                 screenY = cursorScreenPos.getY();
2693             }
2694 
2695             inMousePick = true;
2696             Scene.this.processGestureEvent(new ScrollEvent(
2697                     eventType,
2698                     x, y, screenX, screenY,
2699                     _shiftDown, _controlDown, _altDown, _metaDown,
2700                     _direct, _inertia,
2701                     scrollX * xMultiplier, scrollY * yMultiplier,
2702                     totalScrollX * xMultiplier, totalScrollY * yMultiplier,
2703                     xMultiplier, yMultiplier,
2704                     xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
2705                     scrollGesture);
2706             inMousePick = false;
2707         }
2708 
2709         @Override
2710         public void zoomEvent(
2711                 EventType&lt;ZoomEvent&gt; eventType,
2712                 double zoomFactor, double totalZoomFactor,
2713                 double x, double y, double screenX, double screenY,
2714                 boolean _shiftDown, boolean _controlDown,
2715                 boolean _altDown, boolean _metaDown,
2716                 boolean _direct, boolean _inertia) {
2717 
2718             if (eventType == ZoomEvent.ZOOM_FINISHED) {
2719                 x = zoomGesture.sceneCoords.getX();
2720                 y = zoomGesture.sceneCoords.getY();
2721                 screenX = zoomGesture.screenCoords.getX();
2722                 screenY = zoomGesture.screenCoords.getY();
2723             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2724                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2725                 if (cursorScenePos == null || cursorScreenPos == null) {
2726                     return;
2727                 }
2728                 x = cursorScenePos.getX();
2729                 y = cursorScenePos.getY();
2730                 screenX = cursorScreenPos.getX();
2731                 screenY = cursorScreenPos.getY();
2732             }
2733 
2734             inMousePick = true;
2735             Scene.this.processGestureEvent(new ZoomEvent(eventType,
2736                     x, y, screenX, screenY,
2737                     _shiftDown, _controlDown, _altDown, _metaDown,
2738                     _direct, _inertia,
2739                     zoomFactor, totalZoomFactor, pick(x, y)),
2740                     zoomGesture);
2741             inMousePick = false;
2742         }
2743 
2744         @Override
2745         public void rotateEvent(
2746                 EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
2747                 double x, double y, double screenX, double screenY,
2748                 boolean _shiftDown, boolean _controlDown,
2749                 boolean _altDown, boolean _metaDown,
2750                 boolean _direct, boolean _inertia) {
2751 
2752             if (eventType == RotateEvent.ROTATION_FINISHED) {
2753                 x = rotateGesture.sceneCoords.getX();
2754                 y = rotateGesture.sceneCoords.getY();
2755                 screenX = rotateGesture.screenCoords.getX();
2756                 screenY = rotateGesture.screenCoords.getY();
2757             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2758                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2759                 if (cursorScenePos == null || cursorScreenPos == null) {
2760                     return;
2761                 }
2762                 x = cursorScenePos.getX();
2763                 y = cursorScenePos.getY();
2764                 screenX = cursorScreenPos.getX();
2765                 screenY = cursorScreenPos.getY();
2766             }
2767 
2768             inMousePick = true;
2769             Scene.this.processGestureEvent(new RotateEvent(
2770                     eventType, x, y, screenX, screenY,
2771                     _shiftDown, _controlDown, _altDown, _metaDown,
2772                     _direct, _inertia, angle, totalAngle, pick(x, y)),
2773                     rotateGesture);
2774             inMousePick = false;
2775 
2776         }
2777 
2778         @Override
2779         public void swipeEvent(
2780                 EventType&lt;SwipeEvent&gt; eventType, int touchCount,
2781                 double x, double y, double screenX, double screenY,
2782                 boolean _shiftDown, boolean _controlDown,
2783                 boolean _altDown, boolean _metaDown, boolean _direct) {
2784 
2785             if (Double.isNaN(x) || Double.isNaN(y) ||
2786                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2787                 if (cursorScenePos == null || cursorScreenPos == null) {
2788                     return;
2789                 }
2790                 x = cursorScenePos.getX();
2791                 y = cursorScenePos.getY();
2792                 screenX = cursorScreenPos.getX();
2793                 screenY = cursorScreenPos.getY();
2794             }
2795 
2796             inMousePick = true;
2797             Scene.this.processGestureEvent(new SwipeEvent(
2798                     eventType, x, y, screenX, screenY,
2799                     _shiftDown, _controlDown, _altDown, _metaDown, _direct,
2800                     touchCount, pick(x, y)),
2801                     swipeGesture);
2802             inMousePick = false;
2803         }
2804 
2805         @Override
2806         public void touchEventBegin(
2807                 long time, int touchCount, boolean isDirect,
2808                 boolean _shiftDown, boolean _controlDown,
2809                 boolean _altDown, boolean _metaDown) {
2810 
2811             if (!isDirect) {
2812                 nextTouchEvent = null;
2813                 return;
2814             }
2815             nextTouchEvent = new TouchEvent(
2816                     TouchEvent.ANY, null, null, 0,
2817                     _shiftDown, _controlDown, _altDown, _metaDown);
2818             if (touchPoints == null || touchPoints.length != touchCount) {
2819                 touchPoints = new TouchPoint[touchCount];
2820             }
2821             touchPointIndex = 0;
2822         }
2823 
2824         @Override
2825         public void touchEventNext(
2826                 TouchPoint.State state, long touchId,
2827                 double x, double y, double screenX, double screenY) {
2828 
2829             inMousePick = true;
2830             if (nextTouchEvent == null) {
2831                 // ignore indirect touch events
2832                 return;
2833             }
2834             touchPointIndex++;
2835             int id = (state == TouchPoint.State.PRESSED
2836                     ? touchMap.add(touchId) :  touchMap.get(touchId));
2837             if (state == TouchPoint.State.RELEASED) {
2838                 touchMap.remove(touchId);
2839             }
2840             int order = touchMap.getOrder(id);
2841 
2842             if (order &gt;= touchPoints.length) {
2843                 throw new RuntimeException(&quot;Too many touch points reported&quot;);
2844             }
2845 
2846             // pick target
2847             boolean isGrabbed = false;
2848             PickResult pickRes = pick(x, y);
2849             EventTarget pickedTarget = touchTargets.get(id);
2850             if (pickedTarget == null) {
2851                 pickedTarget = pickRes.getIntersectedNode();
2852                 if (pickedTarget == null) {
2853                     pickedTarget = Scene.this;
2854                 }
2855             } else {
2856                 isGrabbed = true;
2857             }
2858 
2859             TouchPoint tp = new TouchPoint(id, state,
2860                     x, y, screenX, screenY, pickedTarget, pickRes);
2861 
2862             touchPoints[order] = tp;
2863 
2864             if (isGrabbed) {
2865                 tp.grab(pickedTarget);
2866             }
2867             if (tp.getState() == TouchPoint.State.PRESSED) {
2868                 tp.grab(pickedTarget);
2869                 touchTargets.put(tp.getId(), pickedTarget);
2870             } else if (tp.getState() == TouchPoint.State.RELEASED) {
2871                 touchTargets.remove(tp.getId());
2872             }
2873             inMousePick = false;
2874         }
2875 
2876         @Override
2877         public void touchEventEnd() {
2878             if (nextTouchEvent == null) {
2879                 // ignore indirect touch events
2880                 return;
2881             }
2882 
2883             if (touchPointIndex != touchPoints.length) {
2884                 throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
2885             }
2886 
2887             Scene.this.processTouchEvent(nextTouchEvent, touchPoints);
2888 
2889             if (touchMap.cleanup()) {
2890                 // gesture finished
2891                 touchEventSetId = 0;
2892             }
2893         }
2894 
2895         @Override
2896         public Accessible getSceneAccessible() {
2897             return getAccessible();
2898         }
2899     }
2900 
2901     private class ScenePeerPaintListener implements TKScenePaintListener {
2902         @Override
2903         public void frameRendered() {
2904             // must use tracker with synchronization since this method is called on render thread
2905             synchronized (trackerMonitor) {
2906                 if (Scene.this.tracker != null) {
2907                     Scene.this.tracker.frameRendered();
2908                 }
2909             }
2910         }
2911     }
2912 
2913     /*******************************************************************************
2914      *                                                                             *
2915      * Drag and Drop                                                               *
2916      *                                                                             *
2917      ******************************************************************************/
2918 
2919     class DropTargetListener implements TKDropTargetListener {
2920 
2921         /*
2922          * This function is called when an drag operation enters a valid drop target.
2923          * This may be from either an internal or external dnd operation.
2924          */
2925         @Override
2926         public TransferMode dragEnter(double x, double y, double screenX, double screenY,
2927                                       TransferMode transferMode, TKClipboard dragboard)
2928         {
2929             if (dndGesture == null) {
2930                 dndGesture = new DnDGesture();
2931             }
2932             Dragboard db = DragboardHelper.createDragboard(dragboard);
2933             dndGesture.dragboard = db;
2934             DragEvent dragEvent =
2935                     new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2936                             transferMode, null, null, pick(x, y));
2937             return dndGesture.processTargetEnterOver(dragEvent);
2938         }
2939 
2940         @Override
2941         public TransferMode dragOver(double x, double y, double screenX, double screenY,
2942                                      TransferMode transferMode)
2943         {
2944             if (Scene.this.dndGesture == null) {
2945                 System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
2946                 return null;
2947             } else {
2948                 if (dndGesture.dragboard == null) {
2949                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
2950                 }
2951                 DragEvent dragEvent =
2952                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2953                                 transferMode, null, null, pick(x, y));
2954                 return dndGesture.processTargetEnterOver(dragEvent);
2955             }
2956         }
2957 
2958         @Override
2959         public void dragExit(double x, double y, double screenX, double screenY) {
2960             if (dndGesture == null) {
2961                 System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
2962             } else {
2963                 if (dndGesture.dragboard == null) {
2964                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
2965                 }
2966                 DragEvent dragEvent =
2967                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2968                                 null, null, null, pick(x, y));
2969                 dndGesture.processTargetExit(dragEvent);
2970                 if (dndGesture.source == null) {
2971                     dndGesture.dragboard = null;
2972                     dndGesture = null;
2973                 }
2974             }
2975         }
2976 
2977 
2978         @Override
2979         public TransferMode drop(double x, double y, double screenX, double screenY,
2980                                   TransferMode transferMode)
2981         {
2982             if (dndGesture == null) {
2983                 System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
2984                 return null;
2985             } else {
2986                 if (dndGesture.dragboard == null) {
2987                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
2988                 }
2989                 DragEvent dragEvent =
2990                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2991                                 transferMode, null, null, pick(x, y));
2992                 // Data dropped to the app can be accessed without restriction
2993                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
2994 
2995                 TransferMode tm;
2996                 try {
2997                     tm = dndGesture.processTargetDrop(dragEvent);
2998                 } finally {
2999                     DragboardHelper.setDataAccessRestriction(
3000                             dndGesture.dragboard, true);
3001                 }
3002 
3003                 if (dndGesture.source == null) {
3004                     dndGesture.dragboard = null;
3005                     dndGesture = null;
3006                 }
3007                 return tm;
3008             }
3009         }
3010     }
3011 
3012     class DragGestureListener implements TKDragGestureListener {
3013 
3014        @Override
3015        public void dragGestureRecognized(double x, double y, double screenX, double screenY,
3016                                          int button, TKClipboard dragboard)
3017        {
3018            Dragboard db = DragboardHelper.createDragboard(dragboard);
3019            dndGesture = new DnDGesture();
3020            dndGesture.dragboard = db;
3021            // TODO: support mouse buttons in DragEvent
3022            DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
3023                    null, null, null, pick(x, y));
3024            dndGesture.processRecognized(dragEvent);
3025            dndGesture = null;
3026         }
3027     }
3028 
3029     /**
3030      * A Drag and Drop gesture has a lifespan that lasts from mouse
3031      * PRESSED event to mouse RELEASED event.
3032      */
3033     class DnDGesture {
3034         private final double hysteresisSizeX =
3035                 Toolkit.getToolkit().getMultiClickMaxX();
3036         private final double hysteresisSizeY =
3037                 Toolkit.getToolkit().getMultiClickMaxY();
3038 
3039         private EventTarget source = null;
3040         private Set&lt;TransferMode&gt; sourceTransferModes = null;
3041         private TransferMode acceptedTransferMode = null;
3042         private Dragboard dragboard = null;
3043         private EventTarget potentialTarget = null;
3044         private EventTarget target = null;
3045         private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
3046         private double pressedX;
3047         private double pressedY;
3048         private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
3049         private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
3050         private EventTarget fullPDRSource = null;
3051 
3052         /**
3053          * Fires event on a given target or on scene if the node is null
3054          */
3055         private void fireEvent(EventTarget target, Event e) {
3056             if (target != null) {
3057                 Event.fireEvent(target, e);
3058             }
3059         }
3060 
3061         /**
3062          * Called when DRAG_DETECTED event is going to be processed by
3063          * application
3064          */
3065         private void processingDragDetected() {
3066             dragDetected = DragDetectedState.PROCESSING;
3067         }
3068 
3069         /**
3070          * Called after DRAG_DETECTED event has been processed by application
3071          */
3072         private void dragDetectedProcessed() {
3073             dragDetected = DragDetectedState.DONE;
3074             final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
3075             if (hasContent) {
3076                 /* start DnD */
3077                 Toolkit.getToolkit().startDrag(Scene.this.peer,
3078                                                 sourceTransferModes,
3079                                                 new DragSourceListener(),
3080                                                 dragboard);
3081             } else if (fullPDRSource != null) {
3082                 /* start PDR */
3083                 Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
3084             }
3085 
3086             fullPDRSource = null;
3087         }
3088 
3089         /**
3090          * Sets the default dragDetect value
3091          */
3092         private void processDragDetection(MouseEvent mouseEvent) {
3093 
3094             if (dragDetected != DragDetectedState.NOT_YET) {
3095                 mouseEvent.setDragDetect(false);
3096                 return;
3097             }
3098 
3099             if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
3100                 pressedX = mouseEvent.getSceneX();
3101                 pressedY = mouseEvent.getSceneY();
3102 
3103                 mouseEvent.setDragDetect(false);
3104 
3105             } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3106 
3107                 double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
3108                 double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
3109                 mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
3110                                          deltaY &gt; hysteresisSizeY);
3111 
3112             }
3113         }
3114 
3115         /**
3116          * This function is useful for drag gesture recognition from
3117          * within this Scene (as opposed to in the TK implementation... by the platform)
3118          */
3119         private boolean process(MouseEvent mouseEvent, EventTarget target) {
3120             boolean continueProcessing = true;
3121             if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3122 
3123                 if (dragDetected != DragDetectedState.DONE &amp;&amp;
3124                         (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
3125                         mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
3126                         mouseEvent.isDragDetect()) {
3127 
3128                     processingDragDetected();
3129 
3130                     if (target != null) {
3131                         final MouseEvent detectedEvent = mouseEvent.copyFor(
3132                                 mouseEvent.getSource(), target,
3133                                 MouseEvent.DRAG_DETECTED);
3134 
3135                         try {
3136                             fireEvent(target, detectedEvent);
3137                         } finally {
3138                             // Putting data to dragboard finished, restrict access to them
3139                             if (dragboard != null) {
3140                                 DragboardHelper.setDataAccessRestriction(
3141                                         dragboard, true);
3142                             }
3143                         }
3144                     }
3145 
3146                     dragDetectedProcessed();
3147                 }
3148 
3149                 if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
3150                     continueProcessing = false;
3151                 }
3152             }
3153             return continueProcessing;
3154         }
3155 
3156         /*
3157          * Called when a drag source is recognized. This occurs at the very start of
3158          * the publicly visible drag and drop API, as it is responsible for calling
3159          * the Node.onDragSourceRecognized function.
3160          */
3161         private boolean processRecognized(DragEvent de) {
3162             MouseEvent me = new MouseEvent(
3163                     MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
3164                     de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
3165                     false, false, false, false, false, true, false, false, false,
3166                     false, de.getPickResult());
3167 
3168             processingDragDetected();
3169 
3170             final EventTarget target = de.getPickResult().getIntersectedNode();
3171             try {
3172                 fireEvent(target != null ? target : Scene.this, me);
3173             } finally {
3174                 // Putting data to dragboard finished, restrict access to them
3175                 if (dragboard != null) {
3176                     DragboardHelper.setDataAccessRestriction(
3177                             dragboard, true);
3178                 }
3179             }
3180 
3181             dragDetectedProcessed();
3182 
3183             final boolean hasContent = dragboard != null
3184                     &amp;&amp; !dragboard.getContentTypes().isEmpty();
3185             return hasContent;
3186         }
3187 
3188         private void processDropEnd(DragEvent de) {
3189             if (source == null) {
3190                 System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
3191                 return;
3192             }
3193 
3194             de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
3195                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3196                     de.getScreenX(), de.getScreenY(),
3197                     de.getTransferMode(), source, target, de.getPickResult());
3198 
3199             Event.fireEvent(source, de);
3200 
3201             tmpTargetWrapper.clear();
3202             handleExitEnter(de, tmpTargetWrapper);
3203 
3204             // at this point the drag and drop operation is completely over, so we
3205             // can tell the toolkit that it can clean up if needs be.
3206             Toolkit.getToolkit().stopDrag(dragboard);
3207         }
3208 
3209         private TransferMode processTargetEnterOver(DragEvent de) {
3210             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3211             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3212 
3213             if (dragboard == null) {
3214                 dragboard = createDragboard(de, false);
3215             }
3216 
3217             de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
3218                     dragboard, de.getSceneX(), de.getSceneY(),
3219                     de.getScreenX(), de.getScreenY(),
3220                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3221 
3222             handleExitEnter(de, tmpTargetWrapper);
3223 
3224             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
3225                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3226                     de.getScreenX(), de.getScreenY(),
3227                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3228 
3229             fireEvent(pickedTarget, de);
3230 
3231             Object acceptingObject = de.getAcceptingObject();
3232             potentialTarget = acceptingObject instanceof EventTarget
3233                     ? (EventTarget) acceptingObject : null;
3234             acceptedTransferMode = de.getAcceptedTransferMode();
3235             return acceptedTransferMode;
3236         }
3237 
3238         private void processTargetActionChanged(DragEvent de) {
3239             // Do we want DRAG_TRANSFER_MODE_CHANGED event?
3240 //            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
3241 //            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
3242 //                de = DragEvent.copy(de.getSource(), pickedNode, source,
3243 //                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
3244 //
3245 //                if (dragboard == null) {
3246 //                    dragboard = createDragboard(de);
3247 //                }
3248 //                dragboard = de.getPlatformDragboard();
3249 //
3250 //                fireEvent(pickedNode, de);
3251 //            }
3252         }
3253 
3254         private void processTargetExit(DragEvent de) {
3255             if (dragboard == null) {
3256                 // dragboard should have been created in processTargetEnterOver()
3257                 throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
3258             }
3259 
3260             if (currentTargets.size() &gt; 0) {
3261                 potentialTarget = null;
3262                 tmpTargetWrapper.clear();
3263                 handleExitEnter(de, tmpTargetWrapper);
3264             }
3265         }
3266 
3267         private TransferMode processTargetDrop(DragEvent de) {
3268             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3269             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3270 
3271             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
3272                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3273                     de.getScreenX(), de.getScreenY(),
3274                     acceptedTransferMode, source, potentialTarget, de.getPickResult());
3275 
3276             if (dragboard == null) {
3277                 // dragboard should have been created in processTargetEnterOver()
3278                 throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
3279             }
3280 
3281             handleExitEnter(de, tmpTargetWrapper);
3282 
3283             fireEvent(pickedTarget, de);
3284 
3285             Object acceptingObject = de.getAcceptingObject();
3286             potentialTarget = acceptingObject instanceof EventTarget
3287                     ? (EventTarget) acceptingObject : null;
3288             target = potentialTarget;
3289 
3290             TransferMode result = de.isDropCompleted() ?
3291                 de.getAcceptedTransferMode() : null;
3292 
3293             tmpTargetWrapper.clear();
3294             handleExitEnter(de, tmpTargetWrapper);
3295 
3296             return result;
3297         }
3298 
3299         private void handleExitEnter(DragEvent e, TargetWrapper target) {
3300             EventTarget currentTarget =
3301                     currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;
3302 
3303             if (target.getEventTarget() != currentTarget) {
3304 
3305                 target.fillHierarchy(newTargets);
3306 
3307                 int i = currentTargets.size() - 1;
3308                 int j = newTargets.size() - 1;
3309 
3310                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
3311                     i--;
3312                     j--;
3313                 }
3314 
3315                 for (; i &gt;= 0; i--) {
3316                     EventTarget t = currentTargets.get(i);
3317                     if (potentialTarget == t) {
3318                         potentialTarget = null;
3319                     }
3320                     e = e.copyFor(e.getSource(), t, source,
3321                             potentialTarget, DragEvent.DRAG_EXITED_TARGET);
3322                     Event.fireEvent(t, e);
3323                 }
3324 
3325                 potentialTarget = null;
3326                 for (; j &gt;= 0; j--) {
3327                     EventTarget t = newTargets.get(j);
3328                     e = e.copyFor(e.getSource(), t, source,
3329                             potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
3330                     Object acceptingObject = e.getAcceptingObject();
3331                     if (acceptingObject instanceof EventTarget) {
3332                         potentialTarget = (EventTarget) acceptingObject;
3333                     }
3334                     Event.fireEvent(t, e);
3335                 }
3336 
3337                 currentTargets.clear();
3338                 currentTargets.addAll(newTargets);
3339                 newTargets.clear();
3340             }
3341         }
3342 
3343 //        function getIntendedTransferMode(e:MouseEvent):TransferMode {
3344 //            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
3345 //        }
3346 
3347         /*
3348          * Function that hooks into the key processing code in Scene to handle the
3349          * situation where a drag and drop event is taking place and the user presses
3350          * the escape key to cancel the drag and drop operation.
3351          */
3352         private boolean processKey(KeyEvent e) {
3353             //note: this seems not to be called, the DnD cancelation is provided by platform
3354             if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {
3355 
3356                 // cancel drag and drop
3357                 DragEvent de = new DragEvent(
3358                         source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
3359                         null, source, null, null);
3360                 if (source != null) {
3361                     Event.fireEvent(source, de);
3362                 }
3363 
3364                 tmpTargetWrapper.clear();
3365                 handleExitEnter(de, tmpTargetWrapper);
3366 
3367                 return false;
3368             }
3369             return true;
3370         }
3371 
3372         /*
3373          * This starts the drag gesture running, creating the dragboard used for
3374          * the remainder of this drag and drop operation.
3375          */
3376         private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
3377             if (dragDetected != DragDetectedState.PROCESSING) {
3378                 throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
3379                         + &quot;outside of DRAG_DETECTED event handler&quot;);
3380             }
3381 
3382             if (t.isEmpty()) {
3383                 dragboard = null;
3384             } else if (dragboard == null) {
3385                 dragboard = createDragboard(null, true);
3386             }
3387 
3388             // The app can see what it puts to dragboard without restriction
3389             DragboardHelper.setDataAccessRestriction(dragboard, false);
3390 
3391             this.source = source;
3392             potentialTarget = source;
3393             sourceTransferModes = t;
3394             return dragboard;
3395         }
3396 
3397         /*
3398          * This starts the full PDR gesture.
3399          */
3400         private void startFullPDR(EventTarget source) {
3401             fullPDRSource = source;
3402         }
3403 
3404         private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
3405             Dragboard dragboard = null;
3406             if (de != null) {
3407                 dragboard = de.getDragboard();
3408                 if (dragboard != null) {
3409                     return dragboard;
3410                 }
3411             }
3412             TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
3413             return DragboardHelper.createDragboard(dragboardPeer);
3414         }
3415     }
3416 
3417     /**
3418      * State of a drag gesture with regards to DRAG_DETECTED event.
3419      */
3420     private enum DragDetectedState {
3421         NOT_YET,
3422         PROCESSING,
3423         DONE
3424     }
3425 
3426     class DragSourceListener implements TKDragSourceListener {
3427 
3428         @Override
3429         public void dragDropEnd(double x, double y, double screenX, double screenY,
3430                                 TransferMode transferMode)
3431         {
3432             if (dndGesture != null) {
3433                 if (dndGesture.dragboard == null) {
3434                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
3435                 }
3436                 DragEvent dragEvent =
3437                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
3438                         transferMode, null, null, null);
3439 
3440                 // DRAG_DONE event is delivered to gesture source, it can access
3441                 // its own data without restriction
3442                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
3443                 try {
3444                     dndGesture.processDropEnd(dragEvent);
3445                 } finally {
3446                     DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
3447                 }
3448                 dndGesture = null;
3449             }
3450         }
3451     }
3452 
3453     /*******************************************************************************
3454      *                                                                             *
3455      * Mouse Event Handling                                                        *
3456      *                                                                             *
3457      ******************************************************************************/
3458 
3459     static class ClickCounter {
3460         Toolkit toolkit = Toolkit.getToolkit();
3461         private int count;
3462         private boolean out;
3463         private boolean still;
3464         private Timeline timeout;
3465         private double pressedX, pressedY;
3466 
3467         private void inc() { count++; }
3468         private int get() { return count; }
3469         private boolean isStill() { return still; }
3470 
3471         private void clear() {
3472             count = 0;
3473             stopTimeout();
3474         }
3475 
3476         private void out() {
3477             out = true;
3478             stopTimeout();
3479         }
3480 
3481         private void applyOut() {
3482             if (out) clear();
3483             out = false;
3484         }
3485 
3486         private void moved(double x, double y) {
3487             if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
3488                     Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
3489                 out();
3490                 still = false;
3491             }
3492         }
3493 
3494         private void start(double x, double y) {
3495             pressedX = x;
3496             pressedY = y;
3497             out = false;
3498 
3499             if (timeout != null) {
3500                 timeout.stop();
3501             }
3502             timeout = new Timeline();
3503             timeout.getKeyFrames().add(
3504                     new KeyFrame(new Duration(toolkit.getMultiClickTime()),
3505                             event -&gt; {
3506                                 out = true;
3507                                 timeout = null;
3508                             }
3509                     ));
3510             timeout.play();
3511             still = true;
3512         }
3513 
3514         private void stopTimeout() {
3515             if (timeout != null) {
3516                 timeout.stop();
3517                 timeout = null;
3518             }
3519         }
3520     }
3521 
3522     static class ClickGenerator {
3523         private ClickCounter lastPress = null;
3524 
3525         private Map&lt;MouseButton, ClickCounter&gt; counters =
3526                 new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
3527         private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
3528         private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();
3529 
3530         public ClickGenerator() {
3531             for (MouseButton mb : MouseButton.values()) {
3532                 if (mb != MouseButton.NONE) {
3533                     counters.put(mb, new ClickCounter());
3534                 }
3535             }
3536         }
3537 
3538         private MouseEvent preProcess(MouseEvent e) {
3539             for (ClickCounter cc : counters.values()) {
3540                 cc.moved(e.getSceneX(), e.getSceneY());
3541             }
3542 
3543             ClickCounter cc = counters.get(e.getButton());
3544             boolean still = lastPress != null ? lastPress.isStill() : false;
3545 
3546             if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3547 
3548                 if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
3549                 if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
3550                 if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }
3551                 if (! e.isBackButtonDown()) { counters.get(MouseButton.BACK).clear(); }
3552                 if (! e.isForwardButtonDown()) { counters.get(MouseButton.FORWARD).clear(); }
3553                 cc.applyOut();
3554                 cc.inc();
3555                 cc.start(e.getSceneX(), e.getSceneY());
3556                 lastPress = cc;
3557             }
3558 
3559             return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3560                     e.getScreenX(), e.getScreenY(), e.getButton(),
3561                     cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
3562                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3563                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3564                     e.isBackButtonDown(), e.isForwardButtonDown(),
3565                     e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
3566         }
3567 
3568         private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
3569 
3570             if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3571                 ClickCounter cc = counters.get(e.getButton());
3572 
3573                 target.fillHierarchy(pressedTargets);
3574                 pickedTarget.fillHierarchy(releasedTargets);
3575                 int i = pressedTargets.size() - 1;
3576                 int j = releasedTargets.size() - 1;
3577 
3578                 EventTarget clickedTarget = null;
3579                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
3580                     clickedTarget = pressedTargets.get(i);
3581                     i--;
3582                     j--;
3583                 }
3584 
3585                 pressedTargets.clear();
3586                 releasedTargets.clear();
3587 
3588                 if (clickedTarget != null &amp;&amp; lastPress != null) {
3589                     MouseEvent click = new MouseEvent(null, clickedTarget,
3590                             MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
3591                             e.getScreenX(), e.getScreenY(), e.getButton(),
3592                             cc.get(),
3593                             e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3594                             e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3595                             e.isBackButtonDown(), e.isForwardButtonDown(),
3596                             e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
3597                     Event.fireEvent(clickedTarget, click);
3598                 }
3599             }
3600         }
3601     }
3602 
3603     /**
3604      * Generates mouse exited event for a node which is going to be removed
3605      * and its children, where appropriate.
3606      * @param removing Node which is going to be removed
3607      */
3608     void generateMouseExited(Node removing) {
3609         mouseHandler.handleNodeRemoval(removing);
3610     }
3611 
3612     class MouseHandler {
3613         private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
3614         private boolean pdrInProgress = false;
3615         private boolean fullPDREntered = false;
3616 
3617         private EventTarget currentEventTarget = null;
3618         private MouseEvent lastEvent;
3619         private boolean hover = false;
3620 
3621         private boolean primaryButtonDown = false;
3622         private boolean secondaryButtonDown = false;
3623         private boolean middleButtonDown = false;
3624         private boolean backButtonDown = false;
3625         private boolean forwardButtonDown = false;
3626 
3627         private EventTarget fullPDRSource = null;
3628         private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();
3629 
3630         /* lists needed for enter/exit events generation */
3631         private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
3632         private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
3633         private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();
3634 
3635         private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
3636         private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
3637         private EventTarget fullPDRCurrentTarget = null;
3638 
3639         private Cursor currCursor;
3640         private CursorFrame currCursorFrame;
3641         private EventQueue queue = new EventQueue();
3642 
3643         private Runnable pickProcess = new Runnable() {
3644 
3645             @Override
3646             public void run() {
3647                 // Make sure this is run only if the peer is still alive
3648                 // and there is an event to deliver
3649                 if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
3650                     process(lastEvent, true);
3651                 }
3652             }
3653         };
3654 
3655         private void pulse() {
3656             if (hover &amp;&amp; lastEvent != null) {
3657                 //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
3658                 Platform.runLater(pickProcess);
3659             }
3660         }
3661 
3662         private void clearPDREventTargets() {
3663             pdrInProgress = false;
3664             currentEventTarget = currentEventTargets.size() &gt; 0
3665                     ? currentEventTargets.get(0) : null;
3666             pdrEventTarget.clear();
3667         }
3668 
3669         public void enterFullPDR(EventTarget gestureSource) {
3670             fullPDREntered = true;
3671             fullPDRSource = gestureSource;
3672             fullPDRCurrentTarget = null;
3673             fullPDRCurrentEventTargets.clear();
3674         }
3675 
3676         public void exitFullPDR(MouseEvent e) {
3677             if (!fullPDREntered) {
3678                 return;
3679             }
3680             fullPDREntered = false;
3681             for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
3682                 EventTarget entered = fullPDRCurrentEventTargets.get(i);
3683                 Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
3684                         entered, entered,
3685                         MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3686                         fullPDRSource, e.getPickResult()));
3687             }
3688             fullPDRSource = null;
3689             fullPDRCurrentEventTargets.clear();
3690             fullPDRCurrentTarget = null;
3691         }
3692 
3693         private void handleNodeRemoval(Node removing) {
3694             if (lastEvent == null) {
3695                 // this can happen only if everything has been exited anyway
3696                 return;
3697             }
3698 
3699 
3700             if (currentEventTargets.contains(removing)) {
3701                 int i = 0;
3702                 EventTarget trg = null;
3703                 while(trg != removing) {
3704                     trg = currentEventTargets.get(i++);
3705 
3706                     queue.postEvent(lastEvent.copyFor(trg, trg,
3707                             MouseEvent.MOUSE_EXITED_TARGET));
3708                 }
3709                 currentEventTargets.subList(0, i).clear();
3710             }
3711 
3712             if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
3713                 int i = 0;
3714                 EventTarget trg = null;
3715                 while (trg != removing) {
3716                     trg = fullPDRCurrentEventTargets.get(i++);
3717 
3718                     queue.postEvent(
3719                             MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
3720                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3721                             fullPDRSource, lastEvent.getPickResult()));
3722                 }
3723 
3724                 fullPDRCurrentEventTargets.subList(0, i).clear();
3725             }
3726 
3727             queue.fire();
3728 
3729             if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
3730                 int i = 0;
3731                 EventTarget trg = null;
3732                 while (trg != removing) {
3733                     trg = pdrEventTargets.get(i++);
3734 
3735                     // trg.setHover(false) - already taken care of
3736                     // by the code above which sent a mouse exited event
3737                     ((Node) trg).setPressed(false);
3738                 }
3739                 pdrEventTargets.subList(0, i).clear();
3740 
3741                 trg = pdrEventTargets.get(0);
3742                 final PickResult res = pdrEventTarget.getResult();
3743                 if (trg instanceof Node) {
3744                     pdrEventTarget.setNodeResult(new PickResult((Node) trg,
3745                             res.getIntersectedPoint(), res.getIntersectedDistance()));
3746                 } else {
3747                     pdrEventTarget.setSceneResult(new PickResult(null,
3748                             res.getIntersectedPoint(), res.getIntersectedDistance()),
3749                             (Scene) trg);
3750                 }
3751             }
3752         }
3753 
3754         private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
3755             if (pickedTarget.getEventTarget() != currentEventTarget ||
3756                     e.getEventType() == MouseEvent.MOUSE_EXITED) {
3757 
3758                 if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3759                     newEventTargets.clear();
3760                 } else {
3761                     pickedTarget.fillHierarchy(newEventTargets);
3762                 }
3763 
3764                 int newTargetsSize = newEventTargets.size();
3765                 int i = currentEventTargets.size() - 1;
3766                 int j = newTargetsSize - 1;
3767                 int k = pdrEventTargets.size() - 1;
3768 
3769                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
3770                     i--;
3771                     j--;
3772                     k--;
3773                 }
3774 
3775                 final int memk = k;
3776                 for (; i &gt;= 0; i--, k--) {
3777                     final EventTarget exitedEventTarget = currentEventTargets.get(i);
3778                     if (pdrInProgress &amp;&amp;
3779                             (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
3780                          break;
3781                     }
3782                     queue.postEvent(e.copyFor(
3783                             exitedEventTarget, exitedEventTarget,
3784                             MouseEvent.MOUSE_EXITED_TARGET));
3785                 }
3786 
3787                 k = memk;
3788                 for (; j &gt;= 0; j--, k--) {
3789                     final EventTarget enteredEventTarget = newEventTargets.get(j);
3790                     if (pdrInProgress &amp;&amp;
3791                             (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
3792                         break;
3793                     }
3794                     queue.postEvent(e.copyFor(
3795                             enteredEventTarget, enteredEventTarget,
3796                             MouseEvent.MOUSE_ENTERED_TARGET));
3797                 }
3798 
3799                 currentEventTarget = pickedTarget.getEventTarget();
3800                 currentEventTargets.clear();
3801                 for (j++; j &lt; newTargetsSize; j++) {
3802                     currentEventTargets.add(newEventTargets.get(j));
3803                 }
3804             }
3805             queue.fire();
3806         }
3807 
3808         private void process(MouseEvent e, boolean onPulse) {
3809             Toolkit.getToolkit().checkFxUserThread();
3810             Scene.inMousePick = true;
3811 
3812             cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
3813             cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());
3814 
3815             boolean gestureStarted = false;
3816             if (!onPulse) {
3817                 if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3818                     if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3819                             backButtonDown || forwardButtonDown)) {
3820                         //old gesture ended and new one started
3821                         gestureStarted = true;
3822                         if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3823                             Scene.this.dndGesture = new DnDGesture();
3824                         }
3825                         clearPDREventTargets();
3826                     }
3827                 } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
3828                     // gesture ended
3829                     clearPDREventTargets();
3830                 } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
3831                     hover = true;
3832                 } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3833                     hover = false;
3834                 }
3835 
3836                 primaryButtonDown = e.isPrimaryButtonDown();
3837                 secondaryButtonDown = e.isSecondaryButtonDown();
3838                 middleButtonDown = e.isMiddleButtonDown();
3839                 backButtonDown = e.isBackButtonDown();
3840                 forwardButtonDown = e.isForwardButtonDown();
3841             }
3842 
3843             pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3844             PickResult res = tmpTargetWrapper.getResult();
3845             if (res != null) {
3846                 e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3847                     e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
3848                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3849                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3850                     e.isBackButtonDown(), e.isForwardButtonDown(),
3851                     e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
3852             }
3853 
3854             if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3855                 tmpTargetWrapper.clear();
3856             }
3857 
3858             TargetWrapper target;
3859             if (pdrInProgress) {
3860                 target = pdrEventTarget;
3861             } else {
3862                 target = tmpTargetWrapper;
3863             }
3864 
3865             if (gestureStarted) {
3866                 pdrEventTarget.copy(target);
3867                 pdrEventTarget.fillHierarchy(pdrEventTargets);
3868             }
3869 
3870             if (!onPulse) {
3871                 e = clickGenerator.preProcess(e);
3872             }
3873 
3874             // enter/exit handling
3875             handleEnterExit(e, tmpTargetWrapper);
3876 
3877             //deliver event to the target node
3878             if (Scene.this.dndGesture != null) {
3879                 Scene.this.dndGesture.processDragDetection(e);
3880             }
3881 
3882             if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3883                 processFullPDR(e, onPulse);
3884             }
3885 
3886             if (target.getEventTarget() != null) {
3887                 if (e.getEventType() != MouseEvent.MOUSE_ENTERED
3888                         &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
3889                         &amp;&amp; !onPulse) {
3890                     Event.fireEvent(target.getEventTarget(), e);
3891                 }
3892             }
3893 
3894             if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
3895                 processFullPDR(e, onPulse);
3896             }
3897 
3898             if (!onPulse) {
3899                 clickGenerator.postProcess(e, target, tmpTargetWrapper);
3900             }
3901 
3902             // handle drag and drop
3903 
3904             if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
3905                 if (Scene.this.dndGesture != null) {
3906                     if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
3907                         dndGesture = null;
3908                     }
3909                 }
3910             }
3911 
3912             Cursor cursor = target.getCursor();
3913             if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
3914                 if (cursor == null &amp;&amp; hover) {
3915                     cursor = Scene.this.getCursor();
3916                 }
3917 
3918                 updateCursor(cursor);
3919                 updateCursorFrame();
3920             }
3921 
3922             if (gestureStarted) {
3923                 pdrInProgress = true;
3924             }
3925 
3926             if (pdrInProgress &amp;&amp;
3927                     !(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3928                             backButtonDown || forwardButtonDown)) {
3929                 clearPDREventTargets();
3930                 exitFullPDR(e);
3931                 // we need to do new picking in case the originally picked node
3932                 // was moved or removed by the event handlers
3933                 pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3934                 handleEnterExit(e, tmpTargetWrapper);
3935             }
3936 
3937             lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
3938             Scene.inMousePick = false;
3939         }
3940 
3941         private void processFullPDR(MouseEvent e, boolean onPulse) {
3942 
3943             pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
3944             final PickResult result = fullPDRTmpTargetWrapper.getResult();
3945 
3946             final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();
3947 
3948             // enter/exit handling
3949             if (eventTarget != fullPDRCurrentTarget) {
3950 
3951                 fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);
3952 
3953                 int newTargetsSize = fullPDRNewEventTargets.size();
3954                 int i = fullPDRCurrentEventTargets.size() - 1;
3955                 int j = newTargetsSize - 1;
3956 
3957                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
3958                         fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
3959                     i--;
3960                     j--;
3961                 }
3962 
3963                 for (; i &gt;= 0; i--) {
3964                     final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
3965                     Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
3966                             exitedEventTarget, exitedEventTarget,
3967                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3968                             fullPDRSource, result));
3969                 }
3970 
3971                 for (; j &gt;= 0; j--) {
3972                     final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
3973                     Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
3974                             enteredEventTarget, enteredEventTarget,
3975                             MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
3976                             fullPDRSource, result));
3977                 }
3978 
3979                 fullPDRCurrentTarget = eventTarget;
3980                 fullPDRCurrentEventTargets.clear();
3981                 fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
3982                 fullPDRNewEventTargets.clear();
3983             }
3984             // done enter/exit handling
3985 
3986             // event delivery
3987             if (eventTarget != null &amp;&amp; !onPulse) {
3988                 if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3989                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3990                             eventTarget, eventTarget,
3991                             MouseDragEvent.MOUSE_DRAG_OVER,
3992                             fullPDRSource, result));
3993                 }
3994                 if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3995                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3996                             eventTarget, eventTarget,
3997                             MouseDragEvent.MOUSE_DRAG_RELEASED,
3998                             fullPDRSource, result));
3999                 }
4000             }
4001         }
4002 
4003         private void updateCursor(Cursor newCursor) {
4004             if (currCursor != newCursor) {
4005                 if (currCursor != null) {
4006                     currCursor.deactivate();
4007                 }
4008 
4009                 if (newCursor != null) {
4010                     newCursor.activate();
4011                 }
4012 
4013                 currCursor = newCursor;
4014             }
4015         }
4016 
4017         public void updateCursorFrame() {
4018             final CursorFrame newCursorFrame =
4019                     (currCursor != null)
4020                            ? currCursor.getCurrentFrame()
4021                            : Cursor.DEFAULT.getCurrentFrame();
4022             if (currCursorFrame != newCursorFrame) {
4023                 if (Scene.this.peer != null) {
4024                     Scene.this.peer.setCursor(newCursorFrame);
4025                 }
4026 
4027                 currCursorFrame = newCursorFrame;
4028             }
4029         }
4030 
4031         private PickResult pickNode(PickRay pickRay) {
4032             PickResultChooser r = new PickResultChooser();
4033             Scene.this.getRoot().pickNode(pickRay, r);
4034             return r.toPickResult();
4035         }
4036     }
4037 
4038     /*******************************************************************************
4039      *                                                                             *
4040      * Key Event Handling                                                          *
4041      *                                                                             *
4042      ******************************************************************************/
4043 
4044     class KeyHandler {
4045         private void setFocusOwner(final Node value) {
4046             // Cancel IM composition if there is one in progress.
4047             // This needs to be done before the focus owner is switched as it
4048             // generates event that needs to be delivered to the old focus owner.
4049             if (oldFocusOwner != null) {
4050                 final Scene s = oldFocusOwner.getScene();
4051                 if (s != null) {
4052                     final TKScene peer = s.getPeer();
4053                     if (peer != null) {
4054                         peer.finishInputMethodComposition();
4055                     }
4056                 }
4057             }
4058             focusOwner.set(value);
4059         }
4060 
4061         private boolean windowFocused;
4062         protected boolean isWindowFocused() { return windowFocused; }
4063         protected void setWindowFocused(boolean value) {
4064             windowFocused = value;
4065             if (getFocusOwner() != null) {
4066                 getFocusOwner().setFocused(windowFocused);
4067             }
4068             if (windowFocused) {
4069                 if (accessible != null) {
4070                     accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
4071                 }
4072             }
4073         }
4074 
4075         private void windowForSceneChanged(Window oldWindow, Window window) {
4076             if (oldWindow != null) {
4077                 oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
4078             }
4079 
4080             if (window != null) {
4081                 window.focusedProperty().addListener(sceneWindowFocusedListener);
4082                 setWindowFocused(window.isFocused());
4083             } else {
4084                 setWindowFocused(false);
4085             }
4086         }
4087 
4088         private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());
4089 
4090         private void process(KeyEvent e) {
4091             final Node sceneFocusOwner = getFocusOwner();
4092             final EventTarget eventTarget =
4093                     (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
4094                                               : Scene.this;
4095 
4096             // send the key event to the current focus owner or to scene if
4097             // the focus owner is not set
4098             Event.fireEvent(eventTarget, e);
4099         }
4100 
4101         private void requestFocus(Node node) {
4102             if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
4103                 return;
4104             }
4105             setFocusOwner(node);
4106         }
4107     }
4108     /***************************************************************************
4109      *                                                                         *
4110      *                         Event Dispatch                                  *
4111      *                                                                         *
4112      **************************************************************************/
4113     // PENDING_DOC_REVIEW
4114     /**
4115      * Specifies the event dispatcher for this scene. When replacing the value
4116      * with a new {@code EventDispatcher}, the new dispatcher should forward
4117      * events to the replaced dispatcher to keep the scene&#39;s default event
4118      * handling behavior.
4119      */
4120     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
4121 
4122     public final void setEventDispatcher(EventDispatcher value) {
4123         eventDispatcherProperty().set(value);
4124     }
4125 
4126     public final EventDispatcher getEventDispatcher() {
4127         return eventDispatcherProperty().get();
4128     }
4129 
4130     public final ObjectProperty&lt;EventDispatcher&gt;
4131             eventDispatcherProperty() {
4132         initializeInternalEventDispatcher();
4133         return eventDispatcher;
4134     }
4135 
4136     private SceneEventDispatcher internalEventDispatcher;
4137 
4138     // Delegates requests from platform input method to the focused
4139     // node&#39;s one, if any.
4140     class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
4141         @Override
4142         public Point2D getTextLocation(int offset) {
4143             InputMethodRequests requests = getClientRequests();
4144             if (requests != null) {
4145                 return requests.getTextLocation(offset);
4146             } else {
4147                 return new Point2D(0, 0);
4148             }
4149         }
4150 
4151         @Override
4152         public int getLocationOffset(int x, int y) {
4153             InputMethodRequests requests = getClientRequests();
4154             if (requests != null) {
4155                 return requests.getLocationOffset(x, y);
4156             } else {
4157                 return 0;
4158             }
4159         }
4160 
4161         @Override
4162         public void cancelLatestCommittedText() {
4163             InputMethodRequests requests = getClientRequests();
4164             if (requests != null) {
4165                 requests.cancelLatestCommittedText();
4166             }
4167         }
4168 
4169         @Override
4170         public String getSelectedText() {
4171             InputMethodRequests requests = getClientRequests();
4172             if (requests != null) {
4173                 return requests.getSelectedText();
4174             }
4175             return null;
4176         }
4177 
4178         @Override
4179         public int getInsertPositionOffset() {
4180             InputMethodRequests requests = getClientRequests();
4181             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4182                 return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
4183             }
4184             return 0;
4185         }
4186 
4187         @Override
4188         public String getCommittedText(int begin, int end) {
4189             InputMethodRequests requests = getClientRequests();
4190             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4191                 return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
4192             }
4193             return null;
4194         }
4195 
4196         @Override
4197         public int getCommittedTextLength() {
4198             InputMethodRequests requests = getClientRequests();
4199             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4200                 return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
4201             }
4202             return 0;
4203         }
4204 
4205         private InputMethodRequests getClientRequests() {
4206             Node focusOwner = getFocusOwner();
4207             if (focusOwner != null) {
4208                 return focusOwner.getInputMethodRequests();
4209             }
4210             return null;
4211         }
4212     }
4213 
4214     // PENDING_DOC_REVIEW
4215     /**
4216      * Registers an event handler to this scene. The handler is called when the
4217      * scene receives an {@code Event} of the specified type during the bubbling
4218      * phase of event delivery.
4219      *
4220      * @param &lt;T&gt; the specific event class of the handler
4221      * @param eventType the type of the events to receive by the handler
4222      * @param eventHandler the handler to register
4223      * @throws NullPointerException if the event type or handler is null
4224      */
4225     public final &lt;T extends Event&gt; void addEventHandler(
4226             final EventType&lt;T&gt; eventType,
4227             final EventHandler&lt;? super T&gt; eventHandler) {
4228         getInternalEventDispatcher().getEventHandlerManager()
4229                                     .addEventHandler(eventType, eventHandler);
4230     }
4231 
4232     // PENDING_DOC_REVIEW
4233     /**
4234      * Unregisters a previously registered event handler from this scene. One
4235      * handler might have been registered for different event types, so the
4236      * caller needs to specify the particular event type from which to
4237      * unregister the handler.
4238      *
4239      * @param &lt;T&gt; the specific event class of the handler
4240      * @param eventType the event type from which to unregister
4241      * @param eventHandler the handler to unregister
4242      * @throws NullPointerException if the event type or handler is null
4243      */
4244     public final &lt;T extends Event&gt; void removeEventHandler(
4245             final EventType&lt;T&gt; eventType,
4246             final EventHandler&lt;? super T&gt; eventHandler) {
4247         getInternalEventDispatcher().getEventHandlerManager()
4248                                     .removeEventHandler(eventType,
4249                                                         eventHandler);
4250     }
4251 
4252     // PENDING_DOC_REVIEW
4253     /**
4254      * Registers an event filter to this scene. The filter is called when the
4255      * scene receives an {@code Event} of the specified type during the
4256      * capturing phase of event delivery.
4257      *
4258      * @param &lt;T&gt; the specific event class of the filter
4259      * @param eventType the type of the events to receive by the filter
4260      * @param eventFilter the filter to register
4261      * @throws NullPointerException if the event type or filter is null
4262      */
4263     public final &lt;T extends Event&gt; void addEventFilter(
4264             final EventType&lt;T&gt; eventType,
4265             final EventHandler&lt;? super T&gt; eventFilter) {
4266         getInternalEventDispatcher().getEventHandlerManager()
4267                                     .addEventFilter(eventType, eventFilter);
4268     }
4269 
4270     // PENDING_DOC_REVIEW
4271     /**
4272      * Unregisters a previously registered event filter from this scene. One
4273      * filter might have been registered for different event types, so the
4274      * caller needs to specify the particular event type from which to
4275      * unregister the filter.
4276      *
4277      * @param &lt;T&gt; the specific event class of the filter
4278      * @param eventType the event type from which to unregister
4279      * @param eventFilter the filter to unregister
4280      * @throws NullPointerException if the event type or filter is null
4281      */
4282     public final &lt;T extends Event&gt; void removeEventFilter(
4283             final EventType&lt;T&gt; eventType,
4284             final EventHandler&lt;? super T&gt; eventFilter) {
4285         getInternalEventDispatcher().getEventHandlerManager()
4286                                     .removeEventFilter(eventType, eventFilter);
4287     }
4288 
4289     /**
4290      * Sets the handler to use for this event type. There can only be one such
4291      * handler specified at a time. This handler is guaranteed to be called
4292      * first. This is used for registering the user-defined onFoo event
4293      * handlers.
4294      *
4295      * @param &lt;T&gt; the specific event class of the handler
4296      * @param eventType the event type to associate with the given eventHandler
4297      * @param eventHandler the handler to register, or null to unregister
4298      * @throws NullPointerException if the event type is null
4299      */
4300     protected final &lt;T extends Event&gt; void setEventHandler(
4301             final EventType&lt;T&gt; eventType,
4302             final EventHandler&lt;? super T&gt; eventHandler) {
4303         getInternalEventDispatcher().getEventHandlerManager()
4304                                     .setEventHandler(eventType, eventHandler);
4305     }
4306 
4307     private SceneEventDispatcher getInternalEventDispatcher() {
4308         initializeInternalEventDispatcher();
4309         return internalEventDispatcher;
4310     }
4311 
4312     final void initializeInternalEventDispatcher() {
4313         if (internalEventDispatcher == null) {
4314             internalEventDispatcher = createInternalEventDispatcher();
4315             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
4316                                           this,
4317                                           &quot;eventDispatcher&quot;,
4318                                           internalEventDispatcher);
4319         }
4320     }
4321 
4322     private SceneEventDispatcher createInternalEventDispatcher() {
4323         return new SceneEventDispatcher(this);
4324     }
4325 
4326     /**
4327      * Registers the specified mnemonic.
4328      *
4329      * @param m The mnemonic
4330      */
4331     public void addMnemonic(Mnemonic m) {
4332         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4333                                     .addMnemonic(m);
4334     }
4335 
4336 
4337     /**
4338      * Unregisters the specified mnemonic.
4339      *
4340      * @param m The mnemonic
4341      */
4342     public void removeMnemonic(Mnemonic m) {
4343         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4344                                     .removeMnemonic(m);
4345     }
4346 
4347     final void clearNodeMnemonics(Node node) {
4348         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4349                 .clearNodeMnemonics(node);
4350     }
4351 
4352 
4353     /**
4354      * Gets the list of mnemonics for this {@code Scene}.
4355      *
4356      * @return the list of mnemonics
4357      */
4358     public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
4359         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4360                                            .getMnemonics();
4361     }
4362 
4363     /**
4364      * Gets the list of accelerators for this {@code Scene}.
4365      *
4366      * @return the list of accelerators
4367      */
4368     public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
4369         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4370                                            .getAccelerators();
4371     }
4372 
4373     // PENDING_DOC_REVIEW
4374     /**
4375      * Construct an event dispatch chain for this scene. The event dispatch
4376      * chain contains all event dispatchers from the stage to this scene.
4377      *
4378      * @param tail the initial chain to build from
4379      * @return the resulting event dispatch chain for this scene
4380      */
4381     @Override
4382     public EventDispatchChain buildEventDispatchChain(
4383             EventDispatchChain tail) {
4384         if (eventDispatcher != null) {
4385             final EventDispatcher eventDispatcherValue = eventDispatcher.get();
4386             if (eventDispatcherValue != null) {
4387                 tail = tail.prepend(eventDispatcherValue);
4388             }
4389         }
4390 
4391         if (getWindow() != null) {
4392             tail = getWindow().buildEventDispatchChain(tail);
4393         }
4394 
4395         return tail;
4396     }
4397 
4398     /***************************************************************************
4399      *                                                                         *
4400      *                             Context Menus                               *
4401      *                                                                         *
4402      **************************************************************************/
4403 
4404     /**
4405      * Defines a function to be called when a mouse button has been clicked
4406      * (pressed and released) on this {@code Scene}.
4407      * @since JavaFX 2.1
4408      */
4409 
4410     private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
4411 
4412     public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
4413         onContextMenuRequestedProperty().set(value);
4414     }
4415 
4416     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
4417         return onContextMenuRequested == null ? null : onContextMenuRequested.get();
4418     }
4419 
4420     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
4421         if (onContextMenuRequested == null) {
4422             onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {
4423 
4424                 @Override
4425                 protected void invalidated() {
4426                     setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
4427                 }
4428 
4429                 @Override
4430                 public Object getBean() {
4431                     return Scene.this;
4432                 }
4433 
4434                 @Override
4435                 public String getName() {
4436                     return &quot;onContextMenuRequested&quot;;
4437                 }
4438             };
4439         }
4440         return onContextMenuRequested;
4441     }
4442 
4443     /***************************************************************************
4444      *                                                                         *
4445      *                             Mouse Handling                              *
4446      *                                                                         *
4447      **************************************************************************/
4448 
4449     /**
4450      * Defines a function to be called when a mouse button has been clicked
4451      * (pressed and released) on this {@code Scene}.
4452      */
4453     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
4454 
4455     public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
4456         onMouseClickedProperty().set(value);
4457     }
4458 
4459     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
4460         return onMouseClicked == null ? null : onMouseClicked.get();
4461     }
4462 
4463     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
4464         if (onMouseClicked == null) {
4465             onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4466 
4467                 @Override
4468                 protected void invalidated() {
4469                     setEventHandler(MouseEvent.MOUSE_CLICKED, get());
4470                 }
4471 
4472                 @Override
4473                 public Object getBean() {
4474                     return Scene.this;
4475                 }
4476 
4477                 @Override
4478                 public String getName() {
4479                     return &quot;onMouseClicked&quot;;
4480                 }
4481             };
4482         }
4483         return onMouseClicked;
4484     }
4485 
4486     /**
4487      * Defines a function to be called when a mouse button is pressed
4488      * on this {@code Scene} and then dragged.
4489      */
4490     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
4491 
4492     public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
4493         onMouseDraggedProperty().set(value);
4494     }
4495 
4496     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
4497         return onMouseDragged == null ? null : onMouseDragged.get();
4498     }
4499 
4500     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
4501         if (onMouseDragged == null) {
4502             onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4503 
4504                 @Override
4505                 protected void invalidated() {
4506                     setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
4507                 }
4508 
4509                 @Override
4510                 public Object getBean() {
4511                     return Scene.this;
4512                 }
4513 
4514                 @Override
4515                 public String getName() {
4516                     return &quot;onMouseDragged&quot;;
4517                 }
4518             };
4519         }
4520         return onMouseDragged;
4521     }
4522 
4523     /**
4524      * Defines a function to be called when the mouse enters this {@code Scene}.
4525      */
4526     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
4527 
4528     public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
4529         onMouseEnteredProperty().set(value);
4530     }
4531 
4532     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
4533         return onMouseEntered == null ? null : onMouseEntered.get();
4534     }
4535 
4536     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
4537         if (onMouseEntered == null) {
4538             onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4539 
4540                 @Override
4541                 protected void invalidated() {
4542                     setEventHandler(MouseEvent.MOUSE_ENTERED, get());
4543                 }
4544 
4545                 @Override
4546                 public Object getBean() {
4547                     return Scene.this;
4548                 }
4549 
4550                 @Override
4551                 public String getName() {
4552                     return &quot;onMouseEntered&quot;;
4553                 }
4554             };
4555         }
4556         return onMouseEntered;
4557     }
4558 
4559     /**
4560      * Defines a function to be called when the mouse exits this {@code Scene}.
4561      */
4562     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
4563 
4564     public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
4565         onMouseExitedProperty().set(value);
4566     }
4567 
4568     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
4569         return onMouseExited == null ? null : onMouseExited.get();
4570     }
4571 
4572     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
4573         if (onMouseExited == null) {
4574             onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4575 
4576                 @Override
4577                 protected void invalidated() {
4578                     setEventHandler(MouseEvent.MOUSE_EXITED, get());
4579                 }
4580 
4581                 @Override
4582                 public Object getBean() {
4583                     return Scene.this;
4584                 }
4585 
4586                 @Override
4587                 public String getName() {
4588                     return &quot;onMouseExited&quot;;
4589                 }
4590             };
4591         }
4592         return onMouseExited;
4593     }
4594 
4595     /**
4596      * Defines a function to be called when mouse cursor moves within
4597      * this {@code Scene} but no buttons have been pushed.
4598      */
4599     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
4600 
4601     public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
4602         onMouseMovedProperty().set(value);
4603     }
4604 
4605     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
4606         return onMouseMoved == null ? null : onMouseMoved.get();
4607     }
4608 
4609     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
4610         if (onMouseMoved == null) {
4611             onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4612 
4613                 @Override
4614                 protected void invalidated() {
4615                     setEventHandler(MouseEvent.MOUSE_MOVED, get());
4616                 }
4617 
4618                 @Override
4619                 public Object getBean() {
4620                     return Scene.this;
4621                 }
4622 
4623                 @Override
4624                 public String getName() {
4625                     return &quot;onMouseMoved&quot;;
4626                 }
4627             };
4628         }
4629         return onMouseMoved;
4630     }
4631 
4632     /**
4633      * Defines a function to be called when a mouse button
4634      * has been pressed on this {@code Scene}.
4635      */
4636     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
4637 
4638     public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
4639         onMousePressedProperty().set(value);
4640     }
4641 
4642     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
4643         return onMousePressed == null ? null : onMousePressed.get();
4644     }
4645 
4646     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
4647         if (onMousePressed == null) {
4648             onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4649 
4650                 @Override
4651                 protected void invalidated() {
4652                     setEventHandler(MouseEvent.MOUSE_PRESSED, get());
4653                 }
4654 
4655                 @Override
4656                 public Object getBean() {
4657                     return Scene.this;
4658                 }
4659 
4660                 @Override
4661                 public String getName() {
4662                     return &quot;onMousePressed&quot;;
4663                 }
4664             };
4665         }
4666         return onMousePressed;
4667     }
4668 
4669     /**
4670      * Defines a function to be called when a mouse button
4671      * has been released on this {@code Scene}.
4672      */
4673     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
4674 
4675     public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
4676         onMouseReleasedProperty().set(value);
4677     }
4678 
4679     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
4680         return onMouseReleased == null ? null : onMouseReleased.get();
4681     }
4682 
4683     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
4684         if (onMouseReleased == null) {
4685             onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4686 
4687                 @Override
4688                 protected void invalidated() {
4689                     setEventHandler(MouseEvent.MOUSE_RELEASED, get());
4690                 }
4691 
4692                 @Override
4693                 public Object getBean() {
4694                     return Scene.this;
4695                 }
4696 
4697                 @Override
4698                 public String getName() {
4699                     return &quot;onMouseReleased&quot;;
4700                 }
4701             };
4702         }
4703         return onMouseReleased;
4704     }
4705 
4706     /**
4707      * Defines a function to be called when drag gesture has been
4708      * detected. This is the right place to start drag and drop operation.
4709      */
4710     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
4711 
4712     public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
4713         onDragDetectedProperty().set(value);
4714     }
4715 
4716     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
4717         return onDragDetected == null ? null : onDragDetected.get();
4718     }
4719 
4720     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
4721         if (onDragDetected == null) {
4722             onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4723 
4724                 @Override
4725                 protected void invalidated() {
4726                     setEventHandler(MouseEvent.DRAG_DETECTED, get());
4727                 }
4728 
4729                 @Override
4730                 public Object getBean() {
4731                     return Scene.this;
4732                 }
4733 
4734                 @Override
4735                 public String getName() {
4736                     return &quot;onDragDetected&quot;;
4737                 }
4738             };
4739         }
4740         return onDragDetected;
4741     }
4742 
4743     /**
4744      * Defines a function to be called when a full press-drag-release gesture
4745      * progresses within this {@code Scene}.
4746      * @since JavaFX 2.1
4747      */
4748     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
4749 
4750     public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
4751         onMouseDragOverProperty().set(value);
4752     }
4753 
4754     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
4755         return onMouseDragOver == null ? null : onMouseDragOver.get();
4756     }
4757 
4758     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
4759         if (onMouseDragOver == null) {
4760             onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4761 
4762                 @Override
4763                 protected void invalidated() {
4764                     setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
4765                 }
4766 
4767                 @Override
4768                 public Object getBean() {
4769                     return Scene.this;
4770                 }
4771 
4772                 @Override
4773                 public String getName() {
4774                     return &quot;onMouseDragOver&quot;;
4775                 }
4776             };
4777         }
4778         return onMouseDragOver;
4779     }
4780 
4781     /**
4782      * Defines a function to be called when a full press-drag-release gesture
4783      * ends within this {@code Scene}.
4784      * @since JavaFX 2.1
4785      */
4786     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
4787 
4788     public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
4789         onMouseDragReleasedProperty().set(value);
4790     }
4791 
4792     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
4793         return onMouseDragReleased == null ? null : onMouseDragReleased.get();
4794     }
4795 
4796     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
4797         if (onMouseDragReleased == null) {
4798             onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4799 
4800                 @Override
4801                 protected void invalidated() {
4802                     setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
4803                 }
4804 
4805                 @Override
4806                 public Object getBean() {
4807                     return Scene.this;
4808                 }
4809 
4810                 @Override
4811                 public String getName() {
4812                     return &quot;onMouseDragReleased&quot;;
4813                 }
4814             };
4815         }
4816         return onMouseDragReleased;
4817     }
4818 
4819     /**
4820      * Defines a function to be called when a full press-drag-release gesture
4821      * enters this {@code Scene}.
4822      * @since JavaFX 2.1
4823      */
4824     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
4825 
4826     public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
4827         onMouseDragEnteredProperty().set(value);
4828     }
4829 
4830     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
4831         return onMouseDragEntered == null ? null : onMouseDragEntered.get();
4832     }
4833 
4834     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
4835         if (onMouseDragEntered == null) {
4836             onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4837 
4838                 @Override
4839                 protected void invalidated() {
4840                     setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
4841                 }
4842 
4843                 @Override
4844                 public Object getBean() {
4845                     return Scene.this;
4846                 }
4847 
4848                 @Override
4849                 public String getName() {
4850                     return &quot;onMouseDragEntered&quot;;
4851                 }
4852             };
4853         }
4854         return onMouseDragEntered;
4855     }
4856 
4857     /**
4858      * Defines a function to be called when a full press-drag-release gesture
4859      * exits this {@code Scene}.
4860      * @since JavaFX 2.1
4861      */
4862     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
4863 
4864     public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
4865         onMouseDragExitedProperty().set(value);
4866     }
4867 
4868     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
4869         return onMouseDragExited == null ? null : onMouseDragExited.get();
4870     }
4871 
4872     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
4873         if (onMouseDragExited == null) {
4874             onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4875 
4876                 @Override
4877                 protected void invalidated() {
4878                     setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
4879                 }
4880 
4881                 @Override
4882                 public Object getBean() {
4883                     return Scene.this;
4884                 }
4885 
4886                 @Override
4887                 public String getName() {
4888                     return &quot;onMouseDragExited&quot;;
4889                 }
4890             };
4891         }
4892         return onMouseDragExited;
4893     }
4894 
4895 
4896     /***************************************************************************
4897      *                                                                         *
4898      *                           Gestures Handling                             *
4899      *                                                                         *
4900      **************************************************************************/
4901 
4902     /**
4903      * Defines a function to be called when a scrolling gesture is detected.
4904      * @since JavaFX 2.2
4905      */
4906     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
4907 
4908     public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
4909         onScrollStartedProperty().set(value);
4910     }
4911 
4912     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
4913         return onScrollStarted == null ? null : onScrollStarted.get();
4914     }
4915 
4916     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
4917         if (onScrollStarted == null) {
4918             onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4919 
4920                 @Override
4921                 protected void invalidated() {
4922                     setEventHandler(ScrollEvent.SCROLL_STARTED, get());
4923                 }
4924 
4925                 @Override
4926                 public Object getBean() {
4927                     return Scene.this;
4928                 }
4929 
4930                 @Override
4931                 public String getName() {
4932                     return &quot;onScrollStarted&quot;;
4933                 }
4934             };
4935         }
4936         return onScrollStarted;
4937     }
4938 
4939     /**
4940      * Defines a function to be called when user performs a scrolling action.
4941      */
4942     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
4943 
4944     public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
4945         onScrollProperty().set(value);
4946     }
4947 
4948     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
4949         return onScroll == null ? null : onScroll.get();
4950     }
4951 
4952     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
4953         if (onScroll == null) {
4954             onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4955 
4956                 @Override
4957                 protected void invalidated() {
4958                     setEventHandler(ScrollEvent.SCROLL, get());
4959                 }
4960 
4961                 @Override
4962                 public Object getBean() {
4963                     return Scene.this;
4964                 }
4965 
4966                 @Override
4967                 public String getName() {
4968                     return &quot;onScroll&quot;;
4969                 }
4970             };
4971         }
4972         return onScroll;
4973     }
4974 
4975     /**
4976      * Defines a function to be called when a scrolling gesture ends.
4977      * @since JavaFX 2.2
4978      */
4979     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
4980 
4981     public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
4982         onScrollFinishedProperty().set(value);
4983     }
4984 
4985     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
4986         return onScrollFinished == null ? null : onScrollFinished.get();
4987     }
4988 
4989     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
4990         if (onScrollFinished == null) {
4991             onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4992 
4993                 @Override
4994                 protected void invalidated() {
4995                     setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
4996                 }
4997 
4998                 @Override
4999                 public Object getBean() {
5000                     return Scene.this;
5001                 }
5002 
5003                 @Override
5004                 public String getName() {
5005                     return &quot;onScrollFinished&quot;;
5006                 }
5007             };
5008         }
5009         return onScrollFinished;
5010     }
5011 
5012     /**
5013      * Defines a function to be called when a rotating gesture is detected.
5014      * @since JavaFX 2.2
5015      */
5016     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
5017 
5018     public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
5019         onRotationStartedProperty().set(value);
5020     }
5021 
5022     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
5023         return onRotationStarted == null ? null : onRotationStarted.get();
5024     }
5025 
5026     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
5027         if (onRotationStarted == null) {
5028             onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5029 
5030                 @Override
5031                 protected void invalidated() {
5032                     setEventHandler(RotateEvent.ROTATION_STARTED, get());
5033                 }
5034 
5035                 @Override
5036                 public Object getBean() {
5037                     return Scene.this;
5038                 }
5039 
5040                 @Override
5041                 public String getName() {
5042                     return &quot;onRotationStarted&quot;;
5043                 }
5044             };
5045         }
5046         return onRotationStarted;
5047     }
5048 
5049     /**
5050      * Defines a function to be called when user performs a rotating action.
5051      * @since JavaFX 2.2
5052      */
5053     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
5054 
5055     public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
5056         onRotateProperty().set(value);
5057     }
5058 
5059     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
5060         return onRotate == null ? null : onRotate.get();
5061     }
5062 
5063     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
5064         if (onRotate == null) {
5065             onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5066 
5067                 @Override
5068                 protected void invalidated() {
5069                     setEventHandler(RotateEvent.ROTATE, get());
5070                 }
5071 
5072                 @Override
5073                 public Object getBean() {
5074                     return Scene.this;
5075                 }
5076 
5077                 @Override
5078                 public String getName() {
5079                     return &quot;onRotate&quot;;
5080                 }
5081             };
5082         }
5083         return onRotate;
5084     }
5085 
5086     /**
5087      * Defines a function to be called when a rotating gesture ends.
5088      * @since JavaFX 2.2
5089      */
5090     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
5091 
5092     public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
5093         onRotationFinishedProperty().set(value);
5094     }
5095 
5096     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
5097         return onRotationFinished == null ? null : onRotationFinished.get();
5098     }
5099 
5100     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
5101         if (onRotationFinished == null) {
5102             onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5103 
5104                 @Override
5105                 protected void invalidated() {
5106                     setEventHandler(RotateEvent.ROTATION_FINISHED, get());
5107                 }
5108 
5109                 @Override
5110                 public Object getBean() {
5111                     return Scene.this;
5112                 }
5113 
5114                 @Override
5115                 public String getName() {
5116                     return &quot;onRotationFinished&quot;;
5117                 }
5118             };
5119         }
5120         return onRotationFinished;
5121     }
5122 
5123     /**
5124      * Defines a function to be called when a zooming gesture is detected.
5125      * @since JavaFX 2.2
5126      */
5127     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
5128 
5129     public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
5130         onZoomStartedProperty().set(value);
5131     }
5132 
5133     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
5134         return onZoomStarted == null ? null : onZoomStarted.get();
5135     }
5136 
5137     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
5138         if (onZoomStarted == null) {
5139             onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5140 
5141                 @Override
5142                 protected void invalidated() {
5143                     setEventHandler(ZoomEvent.ZOOM_STARTED, get());
5144                 }
5145 
5146                 @Override
5147                 public Object getBean() {
5148                     return Scene.this;
5149                 }
5150 
5151                 @Override
5152                 public String getName() {
5153                     return &quot;onZoomStarted&quot;;
5154                 }
5155             };
5156         }
5157         return onZoomStarted;
5158     }
5159 
5160     /**
5161      * Defines a function to be called when user performs a zooming action.
5162      * @since JavaFX 2.2
5163      */
5164     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
5165 
5166     public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
5167         onZoomProperty().set(value);
5168     }
5169 
5170     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
5171         return onZoom == null ? null : onZoom.get();
5172     }
5173 
5174     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
5175         if (onZoom == null) {
5176             onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5177 
5178                 @Override
5179                 protected void invalidated() {
5180                     setEventHandler(ZoomEvent.ZOOM, get());
5181                 }
5182 
5183                 @Override
5184                 public Object getBean() {
5185                     return Scene.this;
5186                 }
5187 
5188                 @Override
5189                 public String getName() {
5190                     return &quot;onZoom&quot;;
5191                 }
5192             };
5193         }
5194         return onZoom;
5195     }
5196 
5197     /**
5198      * Defines a function to be called when a zooming gesture ends.
5199      * @since JavaFX 2.2
5200      */
5201     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
5202 
5203     public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
5204         onZoomFinishedProperty().set(value);
5205     }
5206 
5207     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
5208         return onZoomFinished == null ? null : onZoomFinished.get();
5209     }
5210 
5211     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
5212         if (onZoomFinished == null) {
5213             onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5214 
5215                 @Override
5216                 protected void invalidated() {
5217                     setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
5218                 }
5219 
5220                 @Override
5221                 public Object getBean() {
5222                     return Scene.this;
5223                 }
5224 
5225                 @Override
5226                 public String getName() {
5227                     return &quot;onZoomFinished&quot;;
5228                 }
5229             };
5230         }
5231         return onZoomFinished;
5232     }
5233 
5234     /**
5235      * Defines a function to be called when an upward swipe gesture
5236      * happens in this scene.
5237      * @since JavaFX 2.2
5238      */
5239     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
5240 
5241     public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
5242         onSwipeUpProperty().set(value);
5243     }
5244 
5245     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
5246         return onSwipeUp == null ? null : onSwipeUp.get();
5247     }
5248 
5249     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
5250         if (onSwipeUp == null) {
5251             onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5252 
5253                 @Override
5254                 protected void invalidated() {
5255                     setEventHandler(SwipeEvent.SWIPE_UP, get());
5256                 }
5257 
5258                 @Override
5259                 public Object getBean() {
5260                     return Scene.this;
5261                 }
5262 
5263                 @Override
5264                 public String getName() {
5265                     return &quot;onSwipeUp&quot;;
5266                 }
5267             };
5268         }
5269         return onSwipeUp;
5270     }
5271 
5272     /**
5273      * Defines a function to be called when an downward swipe gesture
5274      * happens in this scene.
5275      * @since JavaFX 2.2
5276      */
5277     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
5278 
5279     public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
5280         onSwipeDownProperty().set(value);
5281     }
5282 
5283     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
5284         return onSwipeDown == null ? null : onSwipeDown.get();
5285     }
5286 
5287     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
5288         if (onSwipeDown == null) {
5289             onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5290 
5291                 @Override
5292                 protected void invalidated() {
5293                     setEventHandler(SwipeEvent.SWIPE_DOWN, get());
5294                 }
5295 
5296                 @Override
5297                 public Object getBean() {
5298                     return Scene.this;
5299                 }
5300 
5301                 @Override
5302                 public String getName() {
5303                     return &quot;onSwipeDown&quot;;
5304                 }
5305             };
5306         }
5307         return onSwipeDown;
5308     }
5309 
5310     /**
5311      * Defines a function to be called when an leftward swipe gesture
5312      * happens in this scene.
5313      * @since JavaFX 2.2
5314      */
5315     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
5316 
5317     public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
5318         onSwipeLeftProperty().set(value);
5319     }
5320 
5321     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
5322         return onSwipeLeft == null ? null : onSwipeLeft.get();
5323     }
5324 
5325     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
5326         if (onSwipeLeft == null) {
5327             onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5328 
5329                 @Override
5330                 protected void invalidated() {
5331                     setEventHandler(SwipeEvent.SWIPE_LEFT, get());
5332                 }
5333 
5334                 @Override
5335                 public Object getBean() {
5336                     return Scene.this;
5337                 }
5338 
5339                 @Override
5340                 public String getName() {
5341                     return &quot;onSwipeLeft&quot;;
5342                 }
5343             };
5344         }
5345         return onSwipeLeft;
5346     }
5347 
5348     /**
5349      * Defines a function to be called when an rightward swipe gesture
5350      * happens in this scene.
5351      * @since JavaFX 2.2
5352      */
5353     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
5354 
5355     public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
5356         onSwipeRightProperty().set(value);
5357     }
5358 
5359     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
5360         return onSwipeRight == null ? null : onSwipeRight.get();
5361     }
5362 
5363     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
5364         if (onSwipeRight == null) {
5365             onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5366 
5367                 @Override
5368                 protected void invalidated() {
5369                     setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
5370                 }
5371 
5372                 @Override
5373                 public Object getBean() {
5374                     return Scene.this;
5375                 }
5376 
5377                 @Override
5378                 public String getName() {
5379                     return &quot;onSwipeRight&quot;;
5380                 }
5381             };
5382         }
5383         return onSwipeRight;
5384     }
5385 
5386     /***************************************************************************
5387      *                                                                         *
5388      *                            Touch Handling                               *
5389      *                                                                         *
5390      **************************************************************************/
5391 
5392     /**
5393      * Defines a function to be called when a new touch point is pressed.
5394      * @since JavaFX 2.2
5395      */
5396     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
5397 
5398     public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
5399         onTouchPressedProperty().set(value);
5400     }
5401 
5402     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
5403         return onTouchPressed == null ? null : onTouchPressed.get();
5404     }
5405 
5406     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
5407         if (onTouchPressed == null) {
5408             onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5409 
5410                 @Override
5411                 protected void invalidated() {
5412                     setEventHandler(TouchEvent.TOUCH_PRESSED, get());
5413                 }
5414 
5415                 @Override
5416                 public Object getBean() {
5417                     return Scene.this;
5418                 }
5419 
5420                 @Override
5421                 public String getName() {
5422                     return &quot;onTouchPressed&quot;;
5423                 }
5424             };
5425         }
5426         return onTouchPressed;
5427     }
5428 
5429     /**
5430      * Defines a function to be called when a touch point is moved.
5431      * @since JavaFX 2.2
5432      */
5433     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
5434 
5435     public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
5436         onTouchMovedProperty().set(value);
5437     }
5438 
5439     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
5440         return onTouchMoved == null ? null : onTouchMoved.get();
5441     }
5442 
5443     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
5444         if (onTouchMoved == null) {
5445             onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5446 
5447                 @Override
5448                 protected void invalidated() {
5449                     setEventHandler(TouchEvent.TOUCH_MOVED, get());
5450                 }
5451 
5452                 @Override
5453                 public Object getBean() {
5454                     return Scene.this;
5455                 }
5456 
5457                 @Override
5458                 public String getName() {
5459                     return &quot;onTouchMoved&quot;;
5460                 }
5461             };
5462         }
5463         return onTouchMoved;
5464     }
5465 
5466     /**
5467      * Defines a function to be called when a new touch point is pressed.
5468      * @since JavaFX 2.2
5469      */
5470     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
5471 
5472     public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
5473         onTouchReleasedProperty().set(value);
5474     }
5475 
5476     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
5477         return onTouchReleased == null ? null : onTouchReleased.get();
5478     }
5479 
5480     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
5481         if (onTouchReleased == null) {
5482             onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5483 
5484                 @Override
5485                 protected void invalidated() {
5486                     setEventHandler(TouchEvent.TOUCH_RELEASED, get());
5487                 }
5488 
5489                 @Override
5490                 public Object getBean() {
5491                     return Scene.this;
5492                 }
5493 
5494                 @Override
5495                 public String getName() {
5496                     return &quot;onTouchReleased&quot;;
5497                 }
5498             };
5499         }
5500         return onTouchReleased;
5501     }
5502 
5503     /**
5504      * Defines a function to be called when a touch point stays pressed and
5505      * still.
5506      * @since JavaFX 2.2
5507      */
5508     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
5509 
5510     public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
5511         onTouchStationaryProperty().set(value);
5512     }
5513 
5514     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
5515         return onTouchStationary == null ? null : onTouchStationary.get();
5516     }
5517 
5518     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
5519         if (onTouchStationary == null) {
5520             onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5521 
5522                 @Override
5523                 protected void invalidated() {
5524                     setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
5525                 }
5526 
5527                 @Override
5528                 public Object getBean() {
5529                     return Scene.this;
5530                 }
5531 
5532                 @Override
5533                 public String getName() {
5534                     return &quot;onTouchStationary&quot;;
5535                 }
5536             };
5537         }
5538         return onTouchStationary;
5539     }
5540 
5541     /*
5542      * This class provides reordering and ID mapping of particular touch points.
5543      * Platform may report arbitrary touch point IDs and they may be reused
5544      * during one gesture. This class keeps track of it and provides
5545      * sequentially sorted IDs, unique in scope of a gesture.
5546      *
5547      * Some platforms report always small numbers, these take fast paths through
5548      * the algorithm, directly indexing an array. Bigger numbers take a slow
5549      * path using a hash map.
5550      *
5551      * The algorithm performance was measured and it doesn&#39;t impose
5552      * any significant slowdown on the event delivery.
5553      */
5554     private static class TouchMap {
5555         private static final int FAST_THRESHOLD = 10;
5556         int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
5557         Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
5558         List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
5559         List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
5560         int counter = 0;
5561         int active = 0;
5562 
5563         public int add(long id) {
5564             counter++;
5565             active++;
5566             if (id &lt; FAST_THRESHOLD) {
5567                 fastMap[(int) id] = counter;
5568             } else {
5569                 slowMap.put(id, counter);
5570             }
5571             order.add(counter);
5572             return counter;
5573         }
5574 
5575         public void remove(long id) {
5576             // book the removal - it needs to be done after all touch points
5577             // of an event are processed - see cleanup()
5578             removed.add(id);
5579         }
5580 
5581         public int get(long id) {
5582             if (id &lt; FAST_THRESHOLD) {
5583                 int result = fastMap[(int) id];
5584                 if (result == 0) {
5585                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5586                             + &quot;touch point ID&quot;);
5587                 }
5588                 return result;
5589             } else {
5590                 try {
5591                     return slowMap.get(id);
5592                 } catch (NullPointerException e) {
5593                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5594                             + &quot;touch point ID&quot;);
5595                 }
5596             }
5597         }
5598 
5599         public int getOrder(int id) {
5600             return order.indexOf(id);
5601         }
5602 
5603         // returns true if gesture finished (no finger is touched)
5604         public boolean cleanup() {
5605             for (long id : removed) {
5606                 active--;
5607                 order.remove(Integer.valueOf(get(id)));
5608                 if (id &lt; FAST_THRESHOLD) {
5609                     fastMap[(int) id] = 0;
5610                 } else {
5611                     slowMap.remove(id);
5612                 }
5613                 if (active == 0) {
5614                     // gesture finished
5615                     counter = 0;
5616                 }
5617             }
5618             removed.clear();
5619             return active == 0;
5620         }
5621     }
5622 
5623 
5624     /***************************************************************************
5625      *                                                                         *
5626      *                         Drag and Drop Handling                          *
5627      *                                                                         *
5628      **************************************************************************/
5629 
5630     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
5631 
5632     public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
5633         onDragEnteredProperty().set(value);
5634     }
5635 
5636     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
5637         return onDragEntered == null ? null : onDragEntered.get();
5638     }
5639 
5640     /**
5641      * Defines a function to be called when drag gesture
5642      * enters this {@code Scene}.
5643      * @return function to be called when drag gesture enters this scene
5644      */
5645     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
5646         if (onDragEntered == null) {
5647             onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5648 
5649                 @Override
5650                 protected void invalidated() {
5651                     setEventHandler(DragEvent.DRAG_ENTERED, get());
5652                 }
5653 
5654                 @Override
5655                 public Object getBean() {
5656                     return Scene.this;
5657                 }
5658 
5659                 @Override
5660                 public String getName() {
5661                     return &quot;onDragEntered&quot;;
5662                 }
5663             };
5664         }
5665         return onDragEntered;
5666     }
5667 
5668     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
5669 
5670     public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
5671         onDragExitedProperty().set(value);
5672     }
5673 
5674     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
5675         return onDragExited == null ? null : onDragExited.get();
5676     }
5677 
5678     /**
5679      * Defines a function to be called when drag gesture
5680      * exits this {@code Scene}.
5681      * @return the function to be called when drag gesture exits this scene
5682      */
5683     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
5684         if (onDragExited == null) {
5685             onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5686 
5687                 @Override
5688                 protected void invalidated() {
5689                     setEventHandler(DragEvent.DRAG_EXITED, get());
5690                 }
5691 
5692                 @Override
5693                 public Object getBean() {
5694                     return Scene.this;
5695                 }
5696 
5697                 @Override
5698                 public String getName() {
5699                     return &quot;onDragExited&quot;;
5700                 }
5701             };
5702         }
5703         return onDragExited;
5704     }
5705 
5706     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
5707 
5708     public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
5709         onDragOverProperty().set(value);
5710     }
5711 
5712     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
5713         return onDragOver == null ? null : onDragOver.get();
5714     }
5715 
5716     /**
5717      * Defines a function to be called when drag gesture progresses
5718      * within this {@code Scene}.
5719      * @return the function to be called when drag gesture progresses within
5720      * this scene
5721      */
5722     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
5723         if (onDragOver == null) {
5724             onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5725 
5726                 @Override
5727                 protected void invalidated() {
5728                     setEventHandler(DragEvent.DRAG_OVER, get());
5729                 }
5730 
5731                 @Override
5732                 public Object getBean() {
5733                     return Scene.this;
5734                 }
5735 
5736                 @Override
5737                 public String getName() {
5738                     return &quot;onDragOver&quot;;
5739                 }
5740             };
5741         }
5742         return onDragOver;
5743     }
5744 
5745     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
5746 //    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
5747 //
5748 //    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
5749 //        onDragTransferModeChangedProperty().set(value);
5750 //    }
5751 //
5752 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
5753 //        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
5754 //    }
5755 //
5756 //    /**
5757 //     * Defines a function to be called this {@code Scene} if it is a potential
5758 //     * drag-and-drop target when the user takes action to change the intended
5759 //     * {@code TransferMode}.
5760 //     * The user can change the intended {@link TransferMode} by holding down
5761 //     * or releasing key modifiers.
5762 //     */
5763 //    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
5764 //        if (onDragTransferModeChanged == null) {
5765 //            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5766 //
5767 //                @Override
5768 //                protected void invalidated() {
5769 //                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
5770 //                }
5771 //            };
5772 //        }
5773 //        return onDragTransferModeChanged;
5774 //    }
5775 
5776     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
5777 
5778     public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
5779         onDragDroppedProperty().set(value);
5780     }
5781 
5782     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
5783         return onDragDropped == null ? null : onDragDropped.get();
5784     }
5785 
5786     /**
5787      * Defines a function to be called when the mouse button is released
5788      * on this {@code Scene} during drag and drop gesture. Transfer of data from
5789      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
5790      * happen in this function.
5791      * @return the function to be called when the mouse button is released on
5792      * this scene during drag and drop gesture
5793      */
5794     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
5795         if (onDragDropped == null) {
5796             onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5797 
5798                 @Override
5799                 protected void invalidated() {
5800                     setEventHandler(DragEvent.DRAG_DROPPED, get());
5801                 }
5802 
5803                 @Override
5804                 public Object getBean() {
5805                     return Scene.this;
5806                 }
5807 
5808                 @Override
5809                 public String getName() {
5810                     return &quot;onDragDropped&quot;;
5811                 }
5812             };
5813         }
5814         return onDragDropped;
5815     }
5816 
5817     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
5818 
5819     public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
5820         onDragDoneProperty().set(value);
5821     }
5822 
5823     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
5824         return onDragDone == null ? null : onDragDone.get();
5825     }
5826 
5827     /**
5828      * Defines a function to be called when this {@code Scene} is a
5829      * drag and drop gesture source after its data has
5830      * been dropped on a drop target. The {@code transferMode} of the
5831      * event shows what just happened at the drop target.
5832      * If {@code transferMode} has the value {@code MOVE}, then the source can
5833      * clear out its data. Clearing the source&#39;s data gives the appropriate
5834      * appearance to a user that the data has been moved by the drag and drop
5835      * gesture. A {@code transferMode} that has the value {@code NONE}
5836      * indicates that no data was transferred during the drag and drop gesture.
5837      * Positional data for the {@code DragEvent} is invalid.  Valid positional
5838      * data for the {@code DragEvent} is presented in the
5839      * {@link #onDragDroppedProperty() onDragDropped} event handler.
5840      * @return the function to be called when this scene is a drag and drop
5841      * gesture source after its data has been dropped on a drop target
5842      */
5843     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
5844         if (onDragDone == null) {
5845             onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5846 
5847                 @Override
5848                 protected void invalidated() {
5849                     setEventHandler(DragEvent.DRAG_DONE, get());
5850                 }
5851 
5852                 @Override
5853                 public Object getBean() {
5854                     return Scene.this;
5855                 }
5856 
5857                 @Override
5858                 public String getName() {
5859                     return &quot;onDragDone&quot;;
5860                 }
5861             };
5862         }
5863         return onDragDone;
5864     }
5865 
5866     /**
5867      * Confirms a potential drag and drop gesture that is recognized over this
5868      * {@code Scene}.
5869      * Can be called only from a DRAG_DETECTED event handler. The returned
5870      * {@link Dragboard} is used to transfer data during
5871      * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
5872      * {@link Dragboard} also identifies this {@code Scene} as the source of
5873      * the drag and drop gesture.
5874      * More detail about drag and drop gestures is described in the overivew
5875      * of {@link DragEvent}.
5876      *
5877      * @see DragEvent
5878      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
5879      * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
5880      * @throws IllegalStateException if drag and drop cannot be started at this
5881      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
5882      */
5883     public Dragboard startDragAndDrop(TransferMode... transferModes) {
5884         return startDragAndDrop(this, transferModes);
5885     }
5886 
5887     /**
5888      * Starts a full press-drag-release gesture with this scene as gesture
5889      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
5890      * event handler. More detail about dragging gestures can be found
5891      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
5892      *
5893      * @see MouseEvent
5894      * @see MouseDragEvent
5895      * @throws IllegalStateException if the full press-drag-release gesture
5896      * cannot be started at this moment (it&#39;s called outside of
5897      * {@code DRAG_DETECTED} event handling).
5898      * @since JavaFX 2.1
5899      */
5900     public void startFullDrag() {
5901         startFullDrag(this);
5902     }
5903 
5904 
5905     Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
5906         Toolkit.getToolkit().checkFxUserThread();
5907         if (dndGesture == null ||
5908             (dndGesture.dragDetected != DragDetectedState.PROCESSING))
5909         {
5910             throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
5911                     &quot;outside of DRAG_DETECTED event handler&quot;);
5912         }
5913 
5914         Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
5915         for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
5916             set.add(tm);
5917         }
5918         return dndGesture.startDrag(source, set);
5919     }
5920 
5921     void startFullDrag(EventTarget source) {
5922         Toolkit.getToolkit().checkFxUserThread();
5923         if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
5924             throw new IllegalStateException(&quot;Cannot start full drag &quot; +
5925                     &quot;outside of DRAG_DETECTED event handler&quot;);
5926         }
5927 
5928         if (dndGesture != null) {
5929             dndGesture.startFullPDR(source);
5930             return;
5931         }
5932 
5933         throw new IllegalStateException(&quot;Cannot start full drag when &quot;
5934                 + &quot;mouse button is not pressed&quot;);
5935     }
5936 
5937     /***************************************************************************
5938      *                                                                         *
5939      *                           Keyboard Handling                             *
5940      *                                                                         *
5941      **************************************************************************/
5942 
5943     /**
5944      * Defines a function to be called when some {@code Node} of this
5945      * {@code Scene} has input focus and a key has been pressed. The function
5946      * is called only if the event hasn&#39;t been already consumed during its
5947      * capturing or bubbling phase.
5948      */
5949     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
5950 
5951     public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
5952         onKeyPressedProperty().set(value);
5953     }
5954 
5955     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
5956         return onKeyPressed == null ? null : onKeyPressed.get();
5957     }
5958 
5959     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
5960         if (onKeyPressed == null) {
5961             onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5962 
5963                 @Override
5964                 protected void invalidated() {
5965                     setEventHandler(KeyEvent.KEY_PRESSED, get());
5966                 }
5967 
5968                 @Override
5969                 public Object getBean() {
5970                     return Scene.this;
5971                 }
5972 
5973                 @Override
5974                 public String getName() {
5975                     return &quot;onKeyPressed&quot;;
5976                 }
5977             };
5978         }
5979         return onKeyPressed;
5980     }
5981 
5982     /**
5983      * Defines a function to be called when some {@code Node} of this
5984      * {@code Scene} has input focus and a key has been released. The function
5985      * is called only if the event hasn&#39;t been already consumed during its
5986      * capturing or bubbling phase.
5987      */
5988     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
5989 
5990     public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
5991         onKeyReleasedProperty().set(value);
5992     }
5993 
5994     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
5995         return onKeyReleased == null ? null : onKeyReleased.get();
5996     }
5997 
5998     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
5999         if (onKeyReleased == null) {
6000             onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6001 
6002                 @Override
6003                 protected void invalidated() {
6004                     setEventHandler(KeyEvent.KEY_RELEASED, get());
6005                 }
6006 
6007                 @Override
6008                 public Object getBean() {
6009                     return Scene.this;
6010                 }
6011 
6012                 @Override
6013                 public String getName() {
6014                     return &quot;onKeyReleased&quot;;
6015                 }
6016             };
6017         }
6018         return onKeyReleased;
6019     }
6020 
6021     /**
6022      * Defines a function to be called when some {@code Node} of this
6023      * {@code Scene} has input focus and a key has been typed. The function
6024      * is called only if the event hasn&#39;t been already consumed during its
6025      * capturing or bubbling phase.
6026      */
6027     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
6028 
6029     public final void setOnKeyTyped(
6030             EventHandler&lt;? super KeyEvent&gt; value) {
6031         onKeyTypedProperty().set( value);
6032 
6033     }
6034 
6035     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
6036             ) {
6037         return onKeyTyped == null ? null : onKeyTyped.get();
6038     }
6039 
6040     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
6041     ) {
6042         if (onKeyTyped == null) {
6043             onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6044 
6045                 @Override
6046                 protected void invalidated() {
6047                     setEventHandler(KeyEvent.KEY_TYPED, get());
6048                 }
6049 
6050                 @Override
6051                 public Object getBean() {
6052                     return Scene.this;
6053                 }
6054 
6055                 @Override
6056                 public String getName() {
6057                     return &quot;onKeyTyped&quot;;
6058                 }
6059             };
6060         }
6061         return onKeyTyped;
6062     }
6063 
6064     /***************************************************************************
6065      *                                                                         *
6066      *                           Input Method Handling                         *
6067      *                                                                         *
6068      **************************************************************************/
6069 
6070     /**
6071      * Defines a function to be called when this {@code Node}
6072      * has input focus and the input method text has changed.  If this
6073      * function is not defined in this {@code Node}, then it
6074      * receives the result string of the input method composition as a
6075      * series of {@code onKeyTyped} function calls.
6076      * &lt;p&gt;
6077      * When the {@code Node} loses the input focus, the JavaFX runtime
6078      * automatically commits the existing composed text if any.
6079      */
6080     private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
6081 
6082     public final void setOnInputMethodTextChanged(
6083             EventHandler&lt;? super InputMethodEvent&gt; value) {
6084         onInputMethodTextChangedProperty().set( value);
6085     }
6086 
6087     public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
6088         return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
6089     }
6090 
6091     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
6092         if (onInputMethodTextChanged == null) {
6093             onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {
6094 
6095                 @Override
6096                 protected void invalidated() {
6097                     setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
6098                 }
6099 
6100                 @Override
6101                 public Object getBean() {
6102                     return Scene.this;
6103                 }
6104 
6105                 @Override
6106                 public String getName() {
6107                     return &quot;onInputMethodTextChanged&quot;;
6108                 }
6109             };
6110         }
6111         return onInputMethodTextChanged;
6112     }
6113 
6114     /*
6115      * This class represents a picked target - either node, or scne, or null.
6116      * It provides functionality needed for the targets and covers the fact
6117      * that they are different kinds of animals.
6118      */
6119     private static class TargetWrapper {
6120         private Scene scene;
6121         private Node node;
6122         private PickResult result;
6123 
6124         /**
6125          * Fills the list with the target and all its parents (including scene)
6126          */
6127         public void fillHierarchy(final List&lt;EventTarget&gt; list) {
6128             list.clear();
6129             Node n = node;
6130             while(n != null) {
6131                 list.add(n);
6132                 final Parent p = n.getParent();
6133                 n = p != null ? p : n.getSubScene();
6134             }
6135 
6136             if (scene != null) {
6137                 list.add(scene);
6138             }
6139         }
6140 
6141         public EventTarget getEventTarget() {
6142             return node != null ? node : scene;
6143         }
6144 
6145         public Cursor getCursor() {
6146             Cursor cursor = null;
6147             if (node != null) {
6148                 cursor = node.getCursor();
6149                 Node n = node.getParent();
6150                 while (cursor == null &amp;&amp; n != null) {
6151                     cursor = n.getCursor();
6152 
6153                     final Parent p = n.getParent();
6154                     n = p != null ? p : n.getSubScene();
6155                 }
6156             }
6157             return cursor;
6158         }
6159 
6160         public void clear() {
6161             set(null, null);
6162             result = null;
6163         }
6164 
6165         public void setNodeResult(PickResult result) {
6166             if (result != null) {
6167                 this.result = result;
6168                 final Node n = result.getIntersectedNode();
6169                 set(n, n.getScene());
6170             }
6171         }
6172 
6173         // Pass null scene if the mouse is outside of the window content
6174         public void setSceneResult(PickResult result, Scene scene) {
6175             if (result != null) {
6176                 this.result = result;
6177                 set(null, scene);
6178             }
6179         }
6180 
6181         public PickResult getResult() {
6182             return result;
6183         }
6184 
6185         public void copy(TargetWrapper tw) {
6186             node = tw.node;
6187             scene = tw.scene;
6188             result = tw.result;
6189         }
6190 
6191         private void set(Node n, Scene s) {
6192             node = n;
6193             scene = s;
6194         }
6195     }
6196 
6197     /*************************************************************************
6198     *                                                                        *
6199     *                                                                        *
6200     *                                                                        *
6201     *************************************************************************/
6202 
6203     private static final Object USER_DATA_KEY = new Object();
6204     // A map containing a set of properties for this scene
6205     private ObservableMap&lt;Object, Object&gt; properties;
6206 
6207     /**
6208       * Returns an observable map of properties on this node for use primarily
6209       * by application developers.
6210       *
6211       * @return an observable map of properties on this node for use primarily
6212       * by application developers
6213       *
6214       * @since JavaFX 8u40
6215       */
6216      public final ObservableMap&lt;Object, Object&gt; getProperties() {
6217         if (properties == null) {
6218             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
6219         }
6220         return properties;
6221     }
6222 
6223     /**
6224      * Tests if Scene has properties.
6225      * @return true if node has properties.
6226      *
6227      * @since JavaFX 8u40
6228      */
6229      public boolean hasProperties() {
6230         return properties != null &amp;&amp; !properties.isEmpty();
6231     }
6232 
6233     /**
6234      * Convenience method for setting a single Object property that can be
6235      * retrieved at a later date. This is functionally equivalent to calling
6236      * the getProperties().put(Object key, Object value) method. This can later
6237      * be retrieved by calling {@link Scene#getUserData()}.
6238      *
6239      * @param value The value to be stored - this can later be retrieved by calling
6240      *          {@link Scene#getUserData()}.
6241      *
6242      * @since JavaFX 8u40
6243      */
6244     public void setUserData(Object value) {
6245         getProperties().put(USER_DATA_KEY, value);
6246     }
6247 
6248     /**
6249      * Returns a previously set Object property, or null if no such property
6250      * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
6251      *
6252      * @return The Object that was previously set, or null if no property
6253      *          has been set or if null was set.
6254      *
6255      * @since JavaFX 8u40
6256      */
6257     public Object getUserData() {
6258         return getProperties().get(USER_DATA_KEY);
6259     }
6260 
6261     /***************************************************************************
6262      *                                                                         *
6263      *                       Component Orientation Properties                  *
6264      *                                                                         *
6265      **************************************************************************/
6266 
6267     private static final NodeOrientation defaultNodeOrientation =
6268         AccessController.doPrivileged(
6269                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;
6270 
6271 
6272 
6273     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
6274     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
6275 
6276     private NodeOrientation effectiveNodeOrientation;
6277 
6278     public final void setNodeOrientation(NodeOrientation orientation) {
6279         nodeOrientationProperty().set(orientation);
6280     }
6281 
6282     public final NodeOrientation getNodeOrientation() {
6283         return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
6284     }
6285 
6286     /**
6287      * Property holding NodeOrientation.
6288      * &lt;p&gt;
6289      * Node orientation describes the flow of visual data within a node.
6290      * In the English speaking world, visual data normally flows from
6291      * left-to-right. In an Arabic or Hebrew world, visual data flows
6292      * from right-to-left.  This is consistent with the reading order
6293      * of text in both worlds.  The default value is left-to-right.
6294      * &lt;/p&gt;
6295      *
6296      * @return NodeOrientation
6297      * @since JavaFX 8.0
6298      */
6299     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
6300         if (nodeOrientation == null) {
6301             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
6302                 @Override
6303                 protected void invalidated() {
6304                     sceneEffectiveOrientationInvalidated();
6305                     getRoot().applyCss();
6306                 }
6307 
6308                 @Override
6309                 public Object getBean() {
6310                     return Scene.this;
6311                 }
6312 
6313                 @Override
6314                 public String getName() {
6315                     return &quot;nodeOrientation&quot;;
6316                 }
6317 
6318                 @Override
6319                 public CssMetaData getCssMetaData() {
6320                     //TODO - not yet supported
6321                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
6322                 }
6323             };
6324         }
6325         return nodeOrientation;
6326     }
6327 
6328     public final NodeOrientation getEffectiveNodeOrientation() {
6329         if (effectiveNodeOrientation == null) {
6330             effectiveNodeOrientation = calcEffectiveNodeOrientation();
6331         }
6332 
6333         return effectiveNodeOrientation;
6334     }
6335 
6336     /**
6337      * The effective node orientation of a scene resolves the inheritance of
6338      * node orientation, returning either left-to-right or right-to-left.
6339      * @return the effective node orientation of this scene
6340      * @since JavaFX 8.0
6341      */
6342     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
6343             effectiveNodeOrientationProperty() {
6344         if (effectiveNodeOrientationProperty == null) {
6345             effectiveNodeOrientationProperty =
6346                     new EffectiveOrientationProperty();
6347         }
6348 
6349         return effectiveNodeOrientationProperty;
6350     }
6351 
6352     private void parentEffectiveOrientationInvalidated() {
6353         if (getNodeOrientation() == NodeOrientation.INHERIT) {
6354             sceneEffectiveOrientationInvalidated();
6355         }
6356     }
6357 
6358     private void sceneEffectiveOrientationInvalidated() {
6359         effectiveNodeOrientation = null;
6360 
6361         if (effectiveNodeOrientationProperty != null) {
6362             effectiveNodeOrientationProperty.invalidate();
6363         }
6364 
6365         getRoot().parentResolvedOrientationInvalidated();
6366     }
6367 
6368     private NodeOrientation calcEffectiveNodeOrientation() {
6369         NodeOrientation orientation = getNodeOrientation();
6370         if (orientation == NodeOrientation.INHERIT) {
6371             Window window = getWindow();
6372             if (window != null) {
6373                 Window parent = null;
6374                 if (window instanceof Stage) {
6375                     parent = ((Stage)window).getOwner();
6376                 } else {
6377                     if (window instanceof PopupWindow) {
6378                         parent = ((PopupWindow)window).getOwnerWindow();
6379                     }
6380                 }
6381                 if (parent != null) {
6382                     Scene scene = parent.getScene();
6383                     if (scene != null) return scene.getEffectiveNodeOrientation();
6384                 }
6385             }
6386             return NodeOrientation.LEFT_TO_RIGHT;
6387         }
6388         return orientation;
6389     }
6390 
6391     private final class EffectiveOrientationProperty
6392             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
6393         @Override
6394         public NodeOrientation get() {
6395             return getEffectiveNodeOrientation();
6396         }
6397 
6398         @Override
6399         public Object getBean() {
6400             return Scene.this;
6401         }
6402 
6403         @Override
6404         public String getName() {
6405             return &quot;effectiveNodeOrientation&quot;;
6406         }
6407 
6408         public void invalidate() {
6409             fireValueChangedEvent();
6410         }
6411     }
6412 
6413     private Map&lt;Node, Accessible&gt; accMap;
6414     Accessible removeAccessible(Node node) {
6415         if (accMap == null) return null;
6416         return accMap.remove(node);
6417     }
6418 
6419     void addAccessible(Node node, Accessible acc) {
6420         if (accMap == null) {
6421             accMap = new HashMap&lt;Node, Accessible&gt;();
6422         }
6423         accMap.put(node, acc);
6424     }
6425 
6426     private void disposeAccessibles() {
6427         if (accMap != null) {
6428             for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
6429                 Node node = entry.getKey();
6430                 Accessible acc = entry.getValue();
6431                 if (node.accessible != null) {
6432                     /* This node has already been initialized to another scene.
6433                      * Note an accessible can be returned to the node before the
6434                      * pulse if getAccessible() is called. In which case it must
6435                      * already being removed from accMap.
6436                      */
6437                     if (node.accessible == acc) {
6438                         System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);
6439                     }
6440                     if (node.getScene() == this) {
6441                         System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);
6442                     }
6443                     acc.dispose();
6444                 } else {
6445                     if (node.getScene() == this) {
6446                         node.accessible = acc;
6447                     } else {
6448                         acc.dispose();
6449                     }
6450                 }
6451             }
6452             accMap.clear();
6453         }
6454     }
6455 
6456     private Accessible accessible;
6457     Accessible getAccessible() {
6458         /*
6459          * The accessible for the Scene should never be
6460          * requested when the peer is not set.
6461          * This can only happen in a error case where a
6462          * descender of this Scene was not disposed and
6463          * it still being used by the AT client and trying
6464          * to reach to the top level window.
6465          */
6466         if (peer == null) return null;
6467         if (accessible == null) {
6468             accessible = Application.GetApplication().createAccessible();
6469             accessible.setEventHandler(new Accessible.EventHandler() {
6470                 @Override public AccessControlContext getAccessControlContext() {
6471                     return getPeer().getAccessControlContext();
6472                 }
6473 
6474                 @Override public Object getAttribute(AccessibleAttribute attribute,
6475                                                      Object... parameters) {
6476                     switch (attribute) {
6477                         case CHILDREN: {
6478                             Parent root = getRoot();
6479                             if (root != null) {
6480                                 return FXCollections.observableArrayList(root);
6481                             }
6482                             break;
6483                         }
6484                         case TEXT: {
6485                             Window w = getWindow();
6486                             if (w instanceof Stage) {
6487                                 return ((Stage)w).getTitle();
6488                             }
6489                             break;
6490                         }
6491                         case NODE_AT_POINT: {
6492                             Window window = getWindow();
6493                             /* is this screen to scene translation correct ? not considering camera ? */
6494                             Point2D pt = (Point2D)parameters[0];
6495                             PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
6496                             if (res != null) {
6497                                 Node node = res.getIntersectedNode();
6498                                 if (node != null) return node;
6499                             }
6500                             return getRoot();//not sure
6501                         }
6502                         case ROLE: return AccessibleRole.PARENT;
6503                         case SCENE: return Scene.this;
6504                         case FOCUS_NODE: {
6505                             if (transientFocusContainer != null) {
6506                                 return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
6507                             }
6508                             return getFocusOwner();
6509                         }
6510                         default:
6511                     }
6512                     return super.getAttribute(attribute, parameters);
6513                 }
6514             });
6515             PlatformImpl.accessibilityActiveProperty().set(true);
6516         }
6517         return accessible;
6518     }
6519 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>