<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/TabPaneSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TabObservableList;
  31 import com.sun.javafx.util.Utils;
  32 import javafx.animation.Animation;
  33 import javafx.animation.Interpolator;
  34 import javafx.animation.KeyFrame;
  35 import javafx.animation.KeyValue;
  36 import javafx.animation.Timeline;
  37 import javafx.animation.Transition;
  38 import javafx.beans.InvalidationListener;
  39 import javafx.beans.Observable;
  40 import javafx.beans.WeakInvalidationListener;
  41 import javafx.beans.property.DoubleProperty;
  42 import javafx.beans.property.ObjectProperty;
  43 import javafx.beans.property.SimpleDoubleProperty;
  44 import javafx.beans.value.WritableValue;
  45 import javafx.collections.FXCollections;
  46 import javafx.collections.ListChangeListener;
  47 import javafx.collections.ObservableList;
  48 import javafx.collections.WeakListChangeListener;
  49 import javafx.css.CssMetaData;
  50 import javafx.css.PseudoClass;
  51 import javafx.css.Styleable;
  52 import javafx.css.StyleableObjectProperty;
  53 import javafx.css.StyleableProperty;
  54 import javafx.event.ActionEvent;
  55 import javafx.event.EventHandler;
  56 import javafx.geometry.Bounds;
  57 import javafx.geometry.HPos;
  58 import javafx.geometry.NodeOrientation;
  59 import javafx.geometry.Point2D;
  60 import javafx.geometry.Pos;
  61 import javafx.geometry.Side;
  62 import javafx.geometry.VPos;
  63 import javafx.scene.AccessibleAction;
  64 import javafx.scene.AccessibleAttribute;
  65 import javafx.scene.AccessibleRole;
  66 import javafx.scene.Node;
  67 import javafx.scene.control.ContextMenu;
  68 import javafx.scene.control.Control;
  69 import javafx.scene.control.Label;
  70 import javafx.scene.control.MenuItem;
  71 import javafx.scene.control.RadioMenuItem;
  72 import javafx.scene.control.SkinBase;
  73 import javafx.scene.control.Tab;
  74 import javafx.scene.control.TabPane;
  75 import javafx.scene.control.TabPane.TabClosingPolicy;
  76 import javafx.scene.control.TabPane.TabDragPolicy;
  77 import javafx.scene.control.ToggleGroup;
  78 import javafx.scene.control.Tooltip;
  79 import javafx.scene.effect.DropShadow;
  80 import javafx.scene.image.ImageView;
  81 import javafx.scene.input.ContextMenuEvent;
  82 import javafx.scene.input.MouseButton;
  83 import javafx.scene.input.MouseEvent;
  84 import javafx.scene.input.ScrollEvent;
  85 import javafx.scene.input.SwipeEvent;
  86 import javafx.scene.layout.Pane;
  87 import javafx.scene.layout.Region;
  88 import javafx.scene.layout.StackPane;
  89 import javafx.scene.shape.Rectangle;
  90 import javafx.scene.transform.Rotate;
  91 import javafx.util.Duration;
  92 import javafx.util.Pair;
  93 
  94 import java.util.ArrayList;
  95 import java.util.Collections;
  96 import java.util.Iterator;
  97 import java.util.List;
  98 
  99 import javafx.css.converter.EnumConverter;
 100 import com.sun.javafx.scene.control.behavior.TabPaneBehavior;
 101 
 102 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 103 
 104 /**
 105  * Default skin implementation for the {@link TabPane} control.
 106  *
 107  * @see TabPane
 108  * @since 9
 109  */
 110 public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {
 111 
 112     /***************************************************************************
 113      *                                                                         *
 114      * Enums                                                                   *
 115      *                                                                         *
 116      **************************************************************************/
 117 
 118     private enum TabAnimation {
 119         NONE,
 120         GROW
 121         // In future we could add FADE, ...
 122     }
 123 
 124     private enum TabAnimationState {
 125         SHOWING, HIDING, NONE;
 126     }
 127 
 128 
 129 
 130     /***************************************************************************
 131      *                                                                         *
 132      * Static fields                                                           *
 133      *                                                                         *
 134      **************************************************************************/
 135 
 136     static int CLOSE_BTN_SIZE = 16;
 137 
 138 
 139 
 140     /***************************************************************************
 141      *                                                                         *
 142      * Private fields                                                          *
 143      *                                                                         *
 144      **************************************************************************/
 145 
 146     private static final double ANIMATION_SPEED = 150;
 147     private static final int SPACER = 10;
 148 
 149     private TabHeaderArea tabHeaderArea;
 150     private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
 151     private Rectangle clipRect;
 152     private Rectangle tabHeaderAreaClipRect;
 153     private Tab selectedTab;
 154     private boolean isSelectingTab;
 155 
 156     private final TabPaneBehavior behavior;
 157 
 158 
 159 
 160     /***************************************************************************
 161      *                                                                         *
 162      * Constructors                                                            *
 163      *                                                                         *
 164      **************************************************************************/
 165 
 166     /**
 167      * Creates a new TabPaneSkin instance, installing the necessary child
 168      * nodes into the Control {@link Control#getChildren() children} list, as
 169      * well as the necessary input mappings for handling key, mouse, etc events.
 170      *
 171      * @param control The control that this skin should be installed onto.
 172      */
 173     public TabPaneSkin(TabPane control) {
 174         super(control);
 175 
 176         // install default input map for the TabPane control
 177         this.behavior = new TabPaneBehavior(control);
 178 //        control.setInputMap(behavior.getInputMap());
 179 
 180         clipRect = new Rectangle(control.getWidth(), control.getHeight());
 181         getSkinnable().setClip(clipRect);
 182 
 183         tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();
 184 
 185         for (Tab tab : getSkinnable().getTabs()) {
 186             addTabContent(tab);
 187         }
 188 
 189         tabHeaderAreaClipRect = new Rectangle();
 190         tabHeaderArea = new TabHeaderArea();
 191         tabHeaderArea.setClip(tabHeaderAreaClipRect);
 192         getChildren().add(tabHeaderArea);
 193         if (getSkinnable().getTabs().size() == 0) {
 194             tabHeaderArea.setVisible(false);
 195         }
 196 
 197         initializeTabListener();
 198 
 199         registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
 200             isSelectingTab = true;
 201             selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 202             getSkinnable().requestLayout();
 203         });
 204         registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
 205         registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
 206         registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));
 207 
 208         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 209         // Could not find the selected tab try and get the selected tab using the selected index
 210         if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
 211             getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
 212             selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 213         }
 214         if (selectedTab == null) {
 215             // getSelectedItem and getSelectedIndex failed select the first.
 216             getSkinnable().getSelectionModel().selectFirst();
 217         }
 218         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 219         isSelectingTab = false;
 220 
 221         initializeSwipeHandlers();
 222     }
 223 
 224 
 225 
 226     /***************************************************************************
 227      *                                                                         *
 228      * Properties                                                              *
 229      *                                                                         *
 230      **************************************************************************/
 231 
 232     private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 233         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 234             return StyleableProperties.OPEN_TAB_ANIMATION;
 235         }
 236 
 237         @Override public Object getBean() {
 238             return TabPaneSkin.this;
 239         }
 240 
 241         @Override public String getName() {
 242             return &quot;openTabAnimation&quot;;
 243         }
 244     };
 245 
 246     private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 247         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 248             return StyleableProperties.CLOSE_TAB_ANIMATION;
 249         }
 250 
 251         @Override public Object getBean() {
 252             return TabPaneSkin.this;
 253         }
 254 
 255         @Override public String getName() {
 256             return &quot;closeTabAnimation&quot;;
 257         }
 258     };
 259 
 260 
 261 
 262     /***************************************************************************
 263      *                                                                         *
 264      * Public API                                                              *
 265      *                                                                         *
 266      **************************************************************************/
 267 
 268     /** {@inheritDoc} */
 269     @Override public void dispose() {
 270         super.dispose();
 271 
 272         if (behavior != null) {
 273             behavior.dispose();
 274         }
 275     }
 276 
 277     /** {@inheritDoc} */
 278     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 279         // The TabPane can only be as wide as it widest content width.
 280         double maxw = 0.0;
 281         for (TabContentRegion contentRegion: tabContentRegions) {
 282             maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
 283         }
 284 
 285         final boolean isHorizontal = isHorizontal();
 286         final double tabHeaderAreaSize = isHorizontal
 287                 ? snapSizeX(tabHeaderArea.prefWidth(-1))
 288                 : snapSizeY(tabHeaderArea.prefHeight(-1));
 289 
 290         double prefWidth = isHorizontal ?
 291                 Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
 292         return snapSizeX(prefWidth) + rightInset + leftInset;
 293     }
 294 
 295     /** {@inheritDoc} */
 296     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 297         // The TabPane can only be as high as it highest content height.
 298         double maxh = 0.0;
 299         for (TabContentRegion contentRegion: tabContentRegions) {
 300             maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
 301         }
 302 
 303         final boolean isHorizontal = isHorizontal();
 304         final double tabHeaderAreaSize = isHorizontal
 305                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 306                 : snapSizeX(tabHeaderArea.prefWidth(-1));
 307 
 308         double prefHeight = isHorizontal ?
 309                 maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
 310         return snapSizeY(prefHeight) + topInset + bottomInset;
 311     }
 312 
 313     /** {@inheritDoc} */
 314     @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
 315         Side tabPosition = getSkinnable().getSide();
 316         if (tabPosition == Side.TOP) {
 317             return tabHeaderArea.getBaselineOffset() + topInset;
 318         }
 319         return 0;
 320     }
 321 
 322     /** {@inheritDoc} */
 323     @Override protected void layoutChildren(final double x, final double y,
 324                                             final double w, final double h) {
 325         TabPane tabPane = getSkinnable();
 326         Side tabPosition = tabPane.getSide();
 327 
 328         double headerHeight = tabPosition.isHorizontal()
 329                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 330                 : snapSizeX(tabHeaderArea.prefHeight(-1));
 331         double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
 332         double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;
 333 
 334         final double leftInset = snappedLeftInset();
 335         final double topInset = snappedTopInset();
 336 
 337         if (tabPosition == Side.TOP) {
 338             tabHeaderArea.resize(w, headerHeight);
 339             tabHeaderArea.relocate(tabsStartX, tabsStartY);
 340             tabHeaderArea.getTransforms().clear();
 341             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
 342         } else if (tabPosition == Side.BOTTOM) {
 343             tabHeaderArea.resize(w, headerHeight);
 344             tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
 345             tabHeaderArea.getTransforms().clear();
 346             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
 347         } else if (tabPosition == Side.LEFT) {
 348             tabHeaderArea.resize(h, headerHeight);
 349             tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
 350             tabHeaderArea.getTransforms().clear();
 351             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
 352         } else if (tabPosition == Side.RIGHT) {
 353             tabHeaderArea.resize(h, headerHeight);
 354             tabHeaderArea.relocate(tabsStartX, y - headerHeight);
 355             tabHeaderArea.getTransforms().clear();
 356             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
 357         }
 358 
 359         tabHeaderAreaClipRect.setX(0);
 360         tabHeaderAreaClipRect.setY(0);
 361         if (isHorizontal()) {
 362             tabHeaderAreaClipRect.setWidth(w);
 363         } else {
 364             tabHeaderAreaClipRect.setWidth(h);
 365         }
 366         tabHeaderAreaClipRect.setHeight(headerHeight);
 367 
 368         // ==================================
 369         // position the tab content for the selected tab only
 370         // ==================================
 371         // if the tabs are on the left, the content needs to be indented
 372         double contentStartX = 0;
 373         double contentStartY = 0;
 374 
 375         if (tabPosition == Side.TOP) {
 376             contentStartX = x;
 377             contentStartY = y + headerHeight;
 378             if (isFloatingStyleClass()) {
 379                 // This is to hide the top border content
 380                 contentStartY -= 1;
 381             }
 382         } else if (tabPosition == Side.BOTTOM) {
 383             contentStartX = x;
 384             contentStartY = y + topInset;
 385             if (isFloatingStyleClass()) {
 386                 // This is to hide the bottom border content
 387                 contentStartY = 1 + topInset;
 388             }
 389         } else if (tabPosition == Side.LEFT) {
 390             contentStartX = x + headerHeight;
 391             contentStartY = y;
 392             if (isFloatingStyleClass()) {
 393                 // This is to hide the left border content
 394                 contentStartX -= 1;
 395             }
 396         } else if (tabPosition == Side.RIGHT) {
 397             contentStartX = x + leftInset;
 398             contentStartY = y;
 399             if (isFloatingStyleClass()) {
 400                 // This is to hide the right border content
 401                 contentStartX = 1 + leftInset;
 402             }
 403         }
 404 
 405         double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
 406         double contentHeight = h - (isHorizontal() ? headerHeight: 0);
 407 
 408         for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
 409             TabContentRegion tabContent = tabContentRegions.get(i);
 410 
 411             tabContent.setAlignment(Pos.TOP_LEFT);
 412             if (tabContent.getClip() != null) {
 413                 ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
 414                 ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
 415             }
 416 
 417             // we need to size all tabs, even if they aren&#39;t visible. For example,
 418             // see RT-29167
 419             tabContent.resize(contentWidth, contentHeight);
 420             tabContent.relocate(contentStartX, contentStartY);
 421         }
 422     }
 423 
 424 
 425 
 426     /***************************************************************************
 427      *                                                                         *
 428      * Private implementation                                                  *
 429      *                                                                         *
 430      **************************************************************************/
 431 
 432     private static int getRotation(Side pos) {
 433         switch (pos) {
 434             case TOP:
 435                 return 0;
 436             case BOTTOM:
 437                 return 180;
 438             case LEFT:
 439                 return -90;
 440             case RIGHT:
 441                 return 90;
 442             default:
 443                 return 0;
 444         }
 445     }
 446 
 447     /**
 448      * VERY HACKY - this lets us &#39;duplicate&#39; Label and ImageView nodes to be used in a
 449      * Tab and the tabs menu at the same time.
 450      */
 451     private static Node clone(Node n) {
 452         if (n == null) {
 453             return null;
 454         }
 455         if (n instanceof ImageView) {
 456             ImageView iv = (ImageView) n;
 457             ImageView imageview = new ImageView();
 458             imageview.imageProperty().bind(iv.imageProperty());
 459             return imageview;
 460         }
 461         if (n instanceof Label) {
 462             Label l = (Label)n;
 463             Label label = new Label(l.getText(), clone(l.getGraphic()));
 464             label.textProperty().bind(l.textProperty());
 465             return label;
 466         }
 467         return null;
 468     }
 469 
 470     private void removeTabs(List&lt;? extends Tab&gt; removedList) {
 471         for (final Tab tab : removedList) {
 472             stopCurrentAnimation(tab);
 473             // Animate the tab removal
 474             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 475             if (tabRegion != null) {
 476                 tabRegion.isClosing = true;
 477 
 478                 tabRegion.removeListeners(tab);
 479                 removeTabContent(tab);
 480 
 481                 EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
 482                     tabRegion.animationState = TabAnimationState.NONE;
 483 
 484                     tabHeaderArea.removeTab(tab);
 485                     tabHeaderArea.requestLayout();
 486                     if (getSkinnable().getTabs().isEmpty()) {
 487                         tabHeaderArea.setVisible(false);
 488                     }
 489                 };
 490 
 491                 if (closeTabAnimation.get() == TabAnimation.GROW) {
 492                     tabRegion.animationState = TabAnimationState.HIDING;
 493                     Timeline closedTabTimeline = tabRegion.currentAnimation =
 494                             createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
 495                     closedTabTimeline.play();
 496                 } else {
 497                     cleanup.handle(null);
 498                 }
 499             }
 500         }
 501     }
 502 
 503     private void stopCurrentAnimation(Tab tab) {
 504         final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 505         if (tabRegion != null) {
 506             // Execute the code immediately, don&#39;t wait for the animation to finish.
 507             Timeline timeline = tabRegion.currentAnimation;
 508             if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
 509                 timeline.getOnFinished().handle(null);
 510                 timeline.stop();
 511                 tabRegion.currentAnimation = null;
 512             }
 513         }
 514     }
 515 
 516     private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
 517         int i = 0;
 518 
 519         // RT-39984: check if any other tabs are animating - they must be completed first.
 520         List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
 521         for (Node n : headers) {
 522             TabHeaderSkin header = (TabHeaderSkin) n;
 523             if (header.animationState == TabAnimationState.HIDING) {
 524                 stopCurrentAnimation(header.tab);
 525             }
 526         }
 527         // end of fix for RT-39984
 528 
 529         for (final Tab tab : addedList) {
 530             stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
 531             // A new tab was added - animate it out
 532             if (!tabHeaderArea.isVisible()) {
 533                 tabHeaderArea.setVisible(true);
 534             }
 535             int index = from + i++;
 536             tabHeaderArea.addTab(tab, index);
 537             addTabContent(tab);
 538             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 539             if (tabRegion != null) {
 540                 if (openTabAnimation.get() == TabAnimation.GROW) {
 541                     tabRegion.animationState = TabAnimationState.SHOWING;
 542                     tabRegion.animationTransition.setValue(0.0);
 543                     tabRegion.setVisible(true);
 544                     tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
 545                         tabRegion.animationState = TabAnimationState.NONE;
 546                         tabRegion.setVisible(true);
 547                         tabRegion.inner.requestLayout();
 548                     });
 549                     tabRegion.currentAnimation.play();
 550                 } else {
 551                     tabRegion.setVisible(true);
 552                     tabRegion.inner.requestLayout();
 553                 }
 554             }
 555         }
 556     }
 557 
 558     private void initializeTabListener() {
 559         getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
 560             List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
 561             List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
 562             int insertPos = -1;
 563 
 564             while (c.next()) {
 565                 if (c.wasPermutated()) {
 566                     if (dragState != DragState.REORDER) {
 567                         TabPane tabPane = getSkinnable();
 568                         List&lt;Tab&gt; tabs = tabPane.getTabs();
 569 
 570                         // tabs sorted : create list of permutated tabs.
 571                         // clear selection, set tab animation to NONE
 572                         // remove permutated tabs, add them back in correct order.
 573                         // restore old selection, and old tab animation states.
 574                         int size = c.getTo() - c.getFrom();
 575                         Tab selTab = tabPane.getSelectionModel().getSelectedItem();
 576                         List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
 577                         getSkinnable().getSelectionModel().clearSelection();
 578 
 579                         // save and set tab animation to none - as it is not a good idea
 580                         // to animate on the same data for open and close.
 581                         TabAnimation prevOpenAnimation = openTabAnimation.get();
 582                         TabAnimation prevCloseAnimation = closeTabAnimation.get();
 583                         openTabAnimation.set(TabAnimation.NONE);
 584                         closeTabAnimation.set(TabAnimation.NONE);
 585                         for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
 586                             permutatedTabs.add(tabs.get(i));
 587                         }
 588 
 589                         removeTabs(permutatedTabs);
 590                         addTabs(permutatedTabs, c.getFrom());
 591                         openTabAnimation.set(prevOpenAnimation);
 592                         closeTabAnimation.set(prevCloseAnimation);
 593                         getSkinnable().getSelectionModel().select(selTab);
 594                     }
 595                 }
 596 
 597                 if (c.wasRemoved()) {
 598                     tabsToRemove.addAll(c.getRemoved());
 599                 }
 600                 if (c.wasAdded()) {
 601                     tabsToAdd.addAll(c.getAddedSubList());
 602                     insertPos = c.getFrom();
 603                 }
 604             }
 605 
 606             // now only remove the tabs that are not in the tabsToAdd list
 607             tabsToRemove.removeAll(tabsToAdd);
 608             removeTabs(tabsToRemove);
 609 
 610             // and add in any new tabs (that we don&#39;t already have showing)
 611             List&lt;Pair&lt;Integer, TabHeaderSkin&gt;&gt; headersToMove = new ArrayList();
 612             if (!tabsToAdd.isEmpty()) {
 613                 for (TabContentRegion tabContentRegion : tabContentRegions) {
 614                     Tab tab = tabContentRegion.getTab();
 615                     TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
 616                     if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
 617                         tabsToAdd.remove(tabContentRegion.getTab());
 618 
 619                         // If a tab is removed and added back at the same time,
 620                         // then we must ensure that the index of tabHeader in
 621                         // headersRegion is same as index of tab in getTabs().
 622                         int tabIndex = getSkinnable().getTabs().indexOf(tab);
 623                         int tabHeaderIndex = tabHeaderArea.headersRegion.getChildren().indexOf(tabHeader);
 624                         if (tabIndex != tabHeaderIndex) {
 625                             headersToMove.add(new Pair(tabIndex, tabHeader));
 626                         }
 627                     }
 628                 }
 629 
 630                 addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
 631                 for (Pair&lt;Integer, TabHeaderSkin&gt; move : headersToMove) {
 632                     tabHeaderArea.moveTab(move.getKey(), move.getValue());
 633                 }
 634             }
 635 
 636             // Fix for RT-34692
 637             getSkinnable().requestLayout();
 638         });
 639     }
 640 
 641     private void addTabContent(Tab tab) {
 642         TabContentRegion tabContentRegion = new TabContentRegion(tab);
 643         tabContentRegion.setClip(new Rectangle());
 644         tabContentRegions.add(tabContentRegion);
 645         // We want the tab content to always sit below the tab headers
 646         getChildren().add(0, tabContentRegion);
 647     }
 648 
 649     private void removeTabContent(Tab tab) {
 650         for (TabContentRegion contentRegion : tabContentRegions) {
 651             if (contentRegion.getTab().equals(tab)) {
 652                 contentRegion.removeListeners(tab);
 653                 getChildren().remove(contentRegion);
 654                 tabContentRegions.remove(contentRegion);
 655                 break;
 656             }
 657         }
 658     }
 659 
 660     private void updateTabPosition() {
 661         tabHeaderArea.setScrollOffset(0.0F);
 662         getSkinnable().applyCss();
 663         getSkinnable().requestLayout();
 664     }
 665 
 666     private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
 667         Timeline timeline = new Timeline();
 668         timeline.setCycleCount(1);
 669 
 670         KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
 671         timeline.getKeyFrames().clear();
 672         timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));
 673 
 674         timeline.setOnFinished(func);
 675         return timeline;
 676     }
 677 
 678     private boolean isHorizontal() {
 679         Side tabPosition = getSkinnable().getSide();
 680         return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
 681     }
 682 
 683     private void initializeSwipeHandlers() {
 684         if (Properties.IS_TOUCH_SUPPORTED) {
 685             getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
 686                 behavior.selectNextTab();
 687             });
 688 
 689             getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
 690                 behavior.selectPreviousTab();
 691             });
 692         }
 693     }
 694 
 695     //TODO need to cache this.
 696     private boolean isFloatingStyleClass() {
 697         return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
 698     }
 699 
 700 
 701 
 702     /***************************************************************************
 703      *                                                                         *
 704      * CSS                                                                     *
 705      *                                                                         *
 706      **************************************************************************/
 707 
 708    /*
 709     * Super-lazy instantiation pattern from Bill Pugh.
 710     */
 711    private static class StyleableProperties {
 712         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 713 
 714         private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
 715                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
 716                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 717 
 718             @Override public boolean isSettable(TabPane node) {
 719                 return true;
 720             }
 721 
 722             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 723                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 724                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
 725             }
 726         };
 727 
 728         private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
 729                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
 730                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 731 
 732             @Override public boolean isSettable(TabPane node) {
 733                 return true;
 734             }
 735 
 736             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 737                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 738                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
 739             }
 740         };
 741 
 742         static {
 743 
 744            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 745                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
 746            styleables.add(OPEN_TAB_ANIMATION);
 747            styleables.add(CLOSE_TAB_ANIMATION);
 748            STYLEABLES = Collections.unmodifiableList(styleables);
 749 
 750         }
 751     }
 752 
 753     /**
 754      * Returns the CssMetaData associated with this class, which may include the
 755      * CssMetaData of its superclasses.
 756      * @return the CssMetaData associated with this class, which may include the
 757      * CssMetaData of its superclasses
 758      */
 759     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 760         return StyleableProperties.STYLEABLES;
 761     }
 762 
 763     /**
 764      * {@inheritDoc}
 765      */
 766     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 767         return getClassCssMetaData();
 768     }
 769 
 770 
 771 
 772     /***************************************************************************
 773      *                                                                         *
 774      * Support classes                                                         *
 775      *                                                                         *
 776      **************************************************************************/
 777 
 778     /**************************************************************************
 779      *
 780      * TabHeaderArea: Area responsible for painting all tabs
 781      *
 782      **************************************************************************/
 783     class TabHeaderArea extends StackPane {
 784         private Rectangle headerClip;
 785         private StackPane headersRegion;
 786         private StackPane headerBackground;
 787         private TabControlButtons controlButtons;
 788 
 789         private boolean measureClosingTabs = false;
 790 
 791         private double scrollOffset;
 792 
 793         public TabHeaderArea() {
 794             getStyleClass().setAll(&quot;tab-header-area&quot;);
 795             setManaged(false);
 796             final TabPane tabPane = getSkinnable();
 797 
 798             headerClip = new Rectangle();
 799 
 800             headersRegion = new StackPane() {
 801                 @Override protected double computePrefWidth(double height) {
 802                     double width = 0.0F;
 803                     for (Node child : getChildren()) {
 804                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 805                         if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
 806                             width += tabHeaderSkin.prefWidth(height);
 807                         }
 808                     }
 809                     return snapSize(width) + snappedLeftInset() + snappedRightInset();
 810                 }
 811 
 812                 @Override protected double computePrefHeight(double width) {
 813                     double height = 0.0F;
 814                     for (Node child : getChildren()) {
 815                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 816                         height = Math.max(height, tabHeaderSkin.prefHeight(width));
 817                     }
 818                     return snapSize(height) + snappedTopInset() + snappedBottomInset();
 819                 }
 820 
 821                 @Override protected void layoutChildren() {
 822                     if (tabsFit()) {
 823                         setScrollOffset(0.0);
 824                     } else {
 825                         if (isSelectingTab) {
 826                             ensureSelectedTabIsVisible();
 827                         } else {
 828                             validateScrollOffset();
 829                         }
 830                     }
 831                     isSelectingTab = false;
 832 
 833                     Side tabPosition = getSkinnable().getSide();
 834                     double tabBackgroundHeight = snapSize(prefHeight(-1));
 835                     double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
 836                         snapSize(getWidth()) - getScrollOffset() : getScrollOffset();
 837 
 838                     updateHeaderClip();
 839                     for (Node node : getChildren()) {
 840                         TabHeaderSkin tabHeader = (TabHeaderSkin)node;
 841 
 842                         // size and position the header relative to the other headers
 843                         double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
 844                         double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
 845                         tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);
 846 
 847                         // This ensures that the tabs are located in the correct position
 848                         // when there are tabs of differing heights.
 849                         double startY = tabPosition.equals(Side.BOTTOM) ?
 850                             0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
 851                         if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 852                             // build from the right
 853                             tabX -= tabHeaderPrefWidth;
 854                             if (dragState != DragState.REORDER ||
 855                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 856                                 tabHeader.relocate(tabX, startY);
 857                             }
 858                         } else {
 859                             // build from the left
 860                             if (dragState != DragState.REORDER ||
 861                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 862                                 tabHeader.relocate(tabX, startY);
 863                             }
 864                             tabX += tabHeaderPrefWidth;
 865                         }
 866                     }
 867                 }
 868 
 869             };
 870             headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
 871             headersRegion.setClip(headerClip);
 872             setupReordering(headersRegion);
 873 
 874             headerBackground = new StackPane();
 875             headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);
 876 
 877             int i = 0;
 878             for (Tab tab: tabPane.getTabs()) {
 879                 addTab(tab, i++);
 880             }
 881 
 882             controlButtons = new TabControlButtons();
 883             controlButtons.setVisible(false);
 884             if (controlButtons.isVisible()) {
 885                 controlButtons.setVisible(true);
 886             }
 887             getChildren().addAll(headerBackground, headersRegion, controlButtons);
 888 
 889             // support for mouse scroll of header area (for when the tabs exceed
 890             // the available space).
 891             // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
 892             // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
 893             addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
 894                 Side side = getSkinnable().getSide();
 895                 side = side == null ? Side.TOP : side;
 896                 switch (side) {
 897                     default:
 898                     case TOP:
 899                     case BOTTOM:
 900                         setScrollOffset(scrollOffset + e.getDeltaY());
 901                         break;
 902                     case LEFT:
 903                     case RIGHT:
 904                         setScrollOffset(scrollOffset - e.getDeltaY());
 905                         break;
 906                 }
 907 
 908             });
 909         }
 910 
 911         private void updateHeaderClip() {
 912             Side tabPosition = getSkinnable().getSide();
 913 
 914             double x = 0;
 915             double y = 0;
 916             double clipWidth = 0;
 917             double clipHeight = 0;
 918             double maxWidth = 0;
 919             double shadowRadius = 0;
 920             double clipOffset = firstTabIndent();
 921             double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));
 922 
 923             measureClosingTabs = true;
 924             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
 925             measureClosingTabs = false;
 926 
 927             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
 928 
 929             // Add the spacer if isShowTabsMenu is true.
 930             if (controlButtonPrefWidth &gt; 0) {
 931                 controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
 932             }
 933 
 934             if (headersRegion.getEffect() instanceof DropShadow) {
 935                 DropShadow shadow = (DropShadow)headersRegion.getEffect();
 936                 shadowRadius = shadow.getRadius();
 937             }
 938 
 939             maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
 940             if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 941                 if (headersPrefWidth &lt; maxWidth) {
 942                     clipWidth = headersPrefWidth + shadowRadius;
 943                 } else {
 944                     x = headersPrefWidth - maxWidth;
 945                     clipWidth = maxWidth + shadowRadius;
 946                 }
 947                 clipHeight = headersPrefHeight;
 948             } else {
 949                 // If x = 0 the header region&#39;s drop shadow is clipped.
 950                 x = -shadowRadius;
 951                 clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
 952                 clipHeight = headersPrefHeight;
 953             }
 954 
 955             headerClip.setX(x);
 956             headerClip.setY(y);
 957             headerClip.setWidth(clipWidth);
 958             headerClip.setHeight(clipHeight);
 959         }
 960 
 961         private void addTab(Tab tab, int addToIndex) {
 962             TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
 963             headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
 964         }
 965 
 966         private void removeTab(Tab tab) {
 967             TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
 968             if (tabHeaderSkin != null) {
 969                 headersRegion.getChildren().remove(tabHeaderSkin);
 970             }
 971         }
 972 
 973         private void moveTab(int moveToIndex, TabHeaderSkin tabHeaderSkin) {
 974             headersRegion.getChildren().remove(tabHeaderSkin);
 975             headersRegion.getChildren().add(moveToIndex, tabHeaderSkin);
 976         }
 977 
 978         private TabHeaderSkin getTabHeaderSkin(Tab tab) {
 979             for (Node child: headersRegion.getChildren()) {
 980                 TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 981                 if (tabHeaderSkin.getTab().equals(tab)) {
 982                     return tabHeaderSkin;
 983                 }
 984             }
 985             return null;
 986         }
 987 
 988         private boolean tabsFit() {
 989             double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
 990             double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
 991             double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
 992             return visibleWidth &lt; getWidth();
 993         }
 994 
 995         private void ensureSelectedTabIsVisible() {
 996             // work out the visible width of the tab header
 997             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
 998             double controlTabWidth = snapSize(controlButtons.getWidth());
 999             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1000 
1001             // and get where the selected tab is in the header area
1002             double offset = 0.0;
1003             double selectedTabOffset = 0.0;
1004             double selectedTabWidth = 0.0;
1005             for (Node node : headersRegion.getChildren()) {
1006                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1007 
1008                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1009 
1010                 if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
1011                     selectedTabOffset = offset;
1012                     selectedTabWidth = tabHeaderPrefWidth;
1013                 }
1014                 offset += tabHeaderPrefWidth;
1015             }
1016 
1017             final double scrollOffset = getScrollOffset();
1018             final double selectedTabStartX = selectedTabOffset;
1019             final double selectedTabEndX = selectedTabOffset + selectedTabWidth;
1020 
1021             final double visibleAreaEndX = visibleWidth;
1022 
1023             if (selectedTabStartX &lt; -scrollOffset) {
1024                 setScrollOffset(-selectedTabStartX);
1025             } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
1026                 setScrollOffset(visibleAreaEndX - selectedTabEndX);
1027             }
1028         }
1029 
1030         public double getScrollOffset() {
1031             return scrollOffset;
1032         }
1033 
1034         private void validateScrollOffset() {
1035             setScrollOffset(getScrollOffset());
1036         }
1037 
1038         private void setScrollOffset(double newScrollOffset) {
1039             // work out the visible width of the tab header
1040             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
1041             double controlTabWidth = snapSize(controlButtons.getWidth());
1042             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1043 
1044             // measure the width of all tabs
1045             double offset = 0.0;
1046             for (Node node : headersRegion.getChildren()) {
1047                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1048                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1049                 offset += tabHeaderPrefWidth;
1050             }
1051 
1052             double actualNewScrollOffset;
1053 
1054             if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
1055                 // need to make sure the right-most tab is attached to the
1056                 // right-hand side of the tab header (e.g. if the tab header area width
1057                 // is expanded), and if it isn&#39;t modify the scroll offset to bring
1058                 // it into line. See RT-35194 for a test case.
1059                 actualNewScrollOffset = visibleWidth - offset;
1060             } else if (newScrollOffset &gt; 0) {
1061                 // need to prevent the left-most tab from becoming detached
1062                 // from the left-hand side of the tab header.
1063                 actualNewScrollOffset = 0;
1064             } else {
1065                 actualNewScrollOffset = newScrollOffset;
1066             }
1067 
1068             if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
1069                 scrollOffset = actualNewScrollOffset;
1070                 headersRegion.requestLayout();
1071             }
1072         }
1073 
1074         private double firstTabIndent() {
1075             switch (getSkinnable().getSide()) {
1076                 case TOP:
1077                 case BOTTOM:
1078                     return snappedLeftInset();
1079                 case RIGHT:
1080                 case LEFT:
1081                     return snappedTopInset();
1082                 default:
1083                     return 0;
1084             }
1085         }
1086 
1087         @Override protected double computePrefWidth(double height) {
1088             double padding = isHorizontal() ?
1089                 snappedLeftInset() + snappedRightInset() :
1090                 snappedTopInset() + snappedBottomInset();
1091             return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
1092                     firstTabIndent() + SPACER + padding;
1093         }
1094 
1095         @Override protected double computePrefHeight(double width) {
1096             double padding = isHorizontal() ?
1097                 snappedTopInset() + snappedBottomInset() :
1098                 snappedLeftInset() + snappedRightInset();
1099             return snapSize(headersRegion.prefHeight(-1)) + padding;
1100         }
1101 
1102         @Override public double getBaselineOffset() {
1103             if (getSkinnable().getSide() == Side.TOP) {
1104                 return headersRegion.getBaselineOffset() + snappedTopInset();
1105             }
1106             return 0;
1107         }
1108 
1109         @Override protected void layoutChildren() {
1110             final double leftInset = snappedLeftInset();
1111             final double rightInset = snappedRightInset();
1112             final double topInset = snappedTopInset();
1113             final double bottomInset = snappedBottomInset();
1114             double w = snapSize(getWidth()) - (isHorizontal() ?
1115                     leftInset + rightInset : topInset + bottomInset);
1116             double h = snapSize(getHeight()) - (isHorizontal() ?
1117                     topInset + bottomInset : leftInset + rightInset);
1118             double tabBackgroundHeight = snapSize(prefHeight(-1));
1119             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
1120             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
1121 
1122             controlButtons.showTabsMenu(! tabsFit());
1123 
1124             updateHeaderClip();
1125             headersRegion.requestLayout();
1126 
1127             // RESIZE CONTROL BUTTONS
1128             double btnWidth = snapSize(controlButtons.prefWidth(-1));
1129             final double btnHeight = controlButtons.prefHeight(btnWidth);
1130             controlButtons.resize(btnWidth, btnHeight);
1131 
1132             // POSITION TABS
1133             headersRegion.resize(headersPrefWidth, headersPrefHeight);
1134 
1135             if (isFloatingStyleClass()) {
1136                 headerBackground.setVisible(false);
1137             } else {
1138                 headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
1139                 headerBackground.setVisible(true);
1140             }
1141 
1142             double startX = 0;
1143             double startY = 0;
1144             double controlStartX = 0;
1145             double controlStartY = 0;
1146             Side tabPosition = getSkinnable().getSide();
1147 
1148             if (tabPosition.equals(Side.TOP)) {
1149                 startX = leftInset;
1150                 startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
1151                 controlStartX = w - btnWidth + leftInset;
1152                 controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
1153             } else if (tabPosition.equals(Side.RIGHT)) {
1154                 startX = topInset;
1155                 startY = tabBackgroundHeight - headersPrefHeight - leftInset;
1156                 controlStartX = w - btnWidth + topInset;
1157                 controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
1158             } else if (tabPosition.equals(Side.BOTTOM)) {
1159                 startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
1160                 startY = tabBackgroundHeight - headersPrefHeight - topInset;
1161                 controlStartX = rightInset;
1162                 controlStartY = snapSize(getHeight()) - btnHeight - topInset;
1163             } else if (tabPosition.equals(Side.LEFT)) {
1164                 startX = snapSize(getWidth()) - headersPrefWidth - topInset;
1165                 startY = tabBackgroundHeight - headersPrefHeight - rightInset;
1166                 controlStartX = leftInset;
1167                 controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
1168             }
1169             if (headerBackground.isVisible()) {
1170                 positionInArea(headerBackground, 0, 0,
1171                         snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1172             }
1173             positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
1174             positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
1175                         /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1176         }
1177     } /* End TabHeaderArea */
1178 
1179 
1180 
1181 
1182     /**************************************************************************
1183      *
1184      * TabHeaderSkin: skin for each tab
1185      *
1186      **************************************************************************/
1187 
1188     class TabHeaderSkin extends StackPane {
1189         private final Tab tab;
1190         public Tab getTab() {
1191             return tab;
1192         }
1193         private Label label;
1194         private StackPane closeBtn;
1195         private StackPane inner;
1196         private Tooltip oldTooltip;
1197         private Tooltip tooltip;
1198         private Rectangle clip;
1199 
1200         private boolean isClosing = false;
1201 
1202         private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();
1203 
1204         private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
1205             @Override
1206             public void onChanged(Change&lt;? extends String&gt; c) {
1207                 getStyleClass().setAll(tab.getStyleClass());
1208             }
1209         };
1210 
1211         private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
1212                 new WeakListChangeListener&lt;&gt;(styleClassListener);
1213 
1214         public TabHeaderSkin(final Tab tab) {
1215             getStyleClass().setAll(tab.getStyleClass());
1216             setId(tab.getId());
1217             setStyle(tab.getStyle());
1218             setAccessibleRole(AccessibleRole.TAB_ITEM);
1219             setViewOrder(1);
1220 
1221             this.tab = tab;
1222             clip = new Rectangle();
1223             setClip(clip);
1224 
1225             label = new Label(tab.getText(), tab.getGraphic());
1226             label.getStyleClass().setAll(&quot;tab-label&quot;);
1227 
1228             closeBtn = new StackPane() {
1229                 @Override protected double computePrefWidth(double h) {
1230                     return CLOSE_BTN_SIZE;
1231                 }
1232                 @Override protected double computePrefHeight(double w) {
1233                     return CLOSE_BTN_SIZE;
1234                 }
1235                 @Override
1236                 public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1237                     switch (action) {
1238                         case FIRE: {
1239                             Tab tab = getTab();
1240                             if (behavior.canCloseTab(tab)) {
1241                                 behavior.closeTab(tab);
1242                                 setOnMousePressed(null);
1243                             }
1244                             break;
1245                         }
1246                         default: super.executeAccessibleAction(action, parameters);
1247                     }
1248                 }
1249             };
1250             closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
1251             closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
1252             closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
1253             closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1254                 @Override
1255                 public void handle(MouseEvent me) {
1256                     Tab tab = getTab();
1257                     if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
1258                         behavior.closeTab(tab);
1259                         setOnMousePressed(null);
1260                         me.consume();
1261                     }
1262                 }
1263             });
1264 
1265             updateGraphicRotation();
1266 
1267             final Region focusIndicator = new Region();
1268             focusIndicator.setMouseTransparent(true);
1269             focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);
1270 
1271             inner = new StackPane() {
1272                 @Override protected void layoutChildren() {
1273                     final TabPane skinnable = getSkinnable();
1274 
1275                     final double paddingTop = snappedTopInset();
1276                     final double paddingRight = snappedRightInset();
1277                     final double paddingBottom = snappedBottomInset();
1278                     final double paddingLeft = snappedLeftInset();
1279                     final double w = getWidth() - (paddingLeft + paddingRight);
1280                     final double h = getHeight() - (paddingTop + paddingBottom);
1281 
1282                     final double prefLabelWidth = snapSize(label.prefWidth(-1));
1283                     final double prefLabelHeight = snapSize(label.prefHeight(-1));
1284 
1285                     final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
1286                     final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
1287                     final double minWidth = snapSize(skinnable.getTabMinWidth());
1288                     final double maxWidth = snapSize(skinnable.getTabMaxWidth());
1289                     final double maxHeight = snapSize(skinnable.getTabMaxHeight());
1290 
1291                     double labelAreaWidth = prefLabelWidth;
1292                     double labelWidth = prefLabelWidth;
1293                     double labelHeight = prefLabelHeight;
1294 
1295                     final double childrenWidth = labelAreaWidth + closeBtnWidth;
1296                     final double childrenHeight = Math.max(labelHeight, closeBtnHeight);
1297 
1298                     if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
1299                         labelAreaWidth = maxWidth - closeBtnWidth;
1300                         labelWidth = maxWidth - closeBtnWidth;
1301                     } else if (childrenWidth &lt; minWidth) {
1302                         labelAreaWidth = minWidth - closeBtnWidth;
1303                     }
1304 
1305                     if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
1306                         labelHeight = maxHeight;
1307                     }
1308 
1309                     if (animationState != TabAnimationState.NONE) {
1310 //                        if (prefWidth.getValue() &lt; labelAreaWidth) {
1311 //                            labelAreaWidth = prefWidth.getValue();
1312 //                        }
1313                         labelAreaWidth *= animationTransition.get();
1314                         closeBtn.setVisible(false);
1315                     } else {
1316                         closeBtn.setVisible(showCloseButton());
1317                     }
1318 
1319 
1320                     label.resize(labelWidth, labelHeight);
1321 
1322 
1323                     double labelStartX = paddingLeft;
1324 
1325                     // If maxWidth is less than Double.MAX_VALUE, the user has
1326                     // clamped the max width, but we should
1327                     // position the close button at the end of the tab,
1328                     // which may not necessarily be the entire width of the
1329                     // provided max width.
1330                     double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;
1331 
1332                     positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
1333                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1334 
1335                     if (closeBtn.isVisible()) {
1336                         closeBtn.resize(closeBtnWidth, closeBtnHeight);
1337                         positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
1338                                 /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1339                     }
1340 
1341                     // Magic numbers regretfully introduced for RT-28944 (so that
1342                     // the focus rect appears as expected on Windows and Mac).
1343                     // In short we use the vPadding to shift the focus rect down
1344                     // into the content area (whereas previously it was being clipped
1345                     // on Windows, whilst it still looked fine on Mac). In the
1346                     // future we may want to improve this code to remove the
1347                     // magic number. Similarly, the hPadding differs on Mac.
1348                     final int vPadding = Utils.isMac() ? 2 : 3;
1349                     final int hPadding = Utils.isMac() ? 2 : 1;
1350                     focusIndicator.resizeRelocate(
1351                             paddingLeft - hPadding,
1352                             paddingTop + vPadding,
1353                             w + 2 * hPadding,
1354                             h - 2 * vPadding);
1355                 }
1356             };
1357             inner.getStyleClass().add(&quot;tab-container&quot;);
1358             inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1359             inner.getChildren().addAll(label, closeBtn, focusIndicator);
1360 
1361             getChildren().addAll(inner);
1362 
1363             tooltip = tab.getTooltip();
1364             if (tooltip != null) {
1365                 Tooltip.install(this, tooltip);
1366                 oldTooltip = tooltip;
1367             }
1368 
1369             listener.registerChangeListener(tab.closableProperty(), e -&gt; {
1370                 inner.requestLayout();
1371                 requestLayout();
1372             });
1373             listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
1374                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1375                 // Need to request a layout pass for inner because if the width
1376                 // and height didn&#39;t not change the label or close button may have
1377                 // changed.
1378                 inner.requestLayout();
1379                 requestLayout();
1380             });
1381             listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
1382             listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
1383             listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
1384                 // uninstall the old tooltip
1385                 if (oldTooltip != null) {
1386                     Tooltip.uninstall(this, oldTooltip);
1387                 }
1388                 tooltip = tab.getTooltip();
1389                 if (tooltip != null) {
1390                     // install new tooltip and save as old tooltip.
1391                     Tooltip.install(this, tooltip);
1392                     oldTooltip = tooltip;
1393                 }
1394             });
1395             listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
1396                 updateTabDisabledState();
1397             });
1398             listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
1399                 updateTabDisabledState();
1400             });
1401             listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));
1402 
1403             tab.getStyleClass().addListener(weakStyleClassListener);
1404 
1405             listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
1406                 inner.requestLayout();
1407                 requestLayout();
1408             });
1409             listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
1410                 final Side side = getSkinnable().getSide();
1411                 pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1412                 pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1413                 pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1414                 pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1415                 inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
1416                 if (getSkinnable().isRotateGraphic()) {
1417                     updateGraphicRotation();
1418                 }
1419             });
1420             listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
1421             listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
1422                 requestLayout();
1423                 getSkinnable().requestLayout();
1424             });
1425             listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
1426                 requestLayout();
1427                 getSkinnable().requestLayout();
1428             });
1429             listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
1430                 requestLayout();
1431                 getSkinnable().requestLayout();
1432             });
1433             listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
1434                 requestLayout();
1435                 getSkinnable().requestLayout();
1436             });
1437 
1438             getProperties().put(Tab.class, tab);
1439             getProperties().put(ContextMenu.class, tab.getContextMenu());
1440 
1441             setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
1442                if (getTab().getContextMenu() != null) {
1443                     getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
1444                     me.consume();
1445                 }
1446             });
1447             setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1448                 @Override public void handle(MouseEvent me) {
1449                     Tab tab = getTab();
1450                     if (tab.isDisable()) {
1451                         return;
1452                     }
1453                     if (me.getButton().equals(MouseButton.MIDDLE)
1454                         || me.getButton().equals(MouseButton.PRIMARY)) {
1455 
1456                         if (tab.getContextMenu() != null
1457                             &amp;&amp; tab.getContextMenu().isShowing()) {
1458                             tab.getContextMenu().hide();
1459                         }
1460                     }
1461                     if (me.getButton().equals(MouseButton.MIDDLE)) {
1462                         if (showCloseButton()) {
1463                             if (behavior.canCloseTab(tab)) {
1464                                 removeListeners(tab);
1465                                 behavior.closeTab(tab);
1466                             }
1467                         }
1468                     } else if (me.getButton().equals(MouseButton.PRIMARY)) {
1469                         behavior.selectTab(tab);
1470                     }
1471                 }
1472             });
1473 
1474             // initialize pseudo-class state
1475             pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1476             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1477             final Side side = getSkinnable().getSide();
1478             pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1479             pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1480             pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1481             pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1482         }
1483 
1484         private void updateTabDisabledState() {
1485             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1486             inner.requestLayout();
1487             requestLayout();
1488         }
1489 
1490         private void updateGraphicRotation() {
1491             if (label.getGraphic() != null) {
1492                 label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
1493                     (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
1494                         (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
1495             }
1496         }
1497 
1498         private boolean showCloseButton() {
1499             return tab.isClosable() &amp;&amp;
1500                     (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
1501                     getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
1502         }
1503 
1504         private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
1505             @Override protected void invalidated() {
1506                 requestLayout();
1507             }
1508         };
1509 
1510         private void removeListeners(Tab tab) {
1511             listener.dispose();
1512             inner.getChildren().clear();
1513             getChildren().clear();
1514             setOnContextMenuRequested(null);
1515             setOnMousePressed(null);
1516         }
1517 
1518         private TabAnimationState animationState = TabAnimationState.NONE;
1519         private Timeline currentAnimation;
1520 
1521         @Override protected double computePrefWidth(double height) {
1522 //            if (animating) {
1523 //                return prefWidth.getValue();
1524 //            }
1525             double minWidth = snapSize(getSkinnable().getTabMinWidth());
1526             double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
1527             double paddingRight = snappedRightInset();
1528             double paddingLeft = snappedLeftInset();
1529             double tmpPrefWidth = snapSize(label.prefWidth(-1));
1530 
1531             // only include the close button width if it is relevant
1532             if (showCloseButton()) {
1533                 tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
1534             }
1535 
1536             if (tmpPrefWidth &gt; maxWidth) {
1537                 tmpPrefWidth = maxWidth;
1538             } else if (tmpPrefWidth &lt; minWidth) {
1539                 tmpPrefWidth = minWidth;
1540             }
1541             tmpPrefWidth += paddingRight + paddingLeft;
1542 //            prefWidth.setValue(tmpPrefWidth);
1543             return tmpPrefWidth;
1544         }
1545 
1546         @Override protected double computePrefHeight(double width) {
1547             double minHeight = snapSize(getSkinnable().getTabMinHeight());
1548             double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
1549             double paddingTop = snappedTopInset();
1550             double paddingBottom = snappedBottomInset();
1551             double tmpPrefHeight = snapSize(label.prefHeight(width));
1552 
1553             if (tmpPrefHeight &gt; maxHeight) {
1554                 tmpPrefHeight = maxHeight;
1555             } else if (tmpPrefHeight &lt; minHeight) {
1556                 tmpPrefHeight = minHeight;
1557             }
1558             tmpPrefHeight += paddingTop + paddingBottom;
1559             return tmpPrefHeight;
1560         }
1561 
1562         @Override protected void layoutChildren() {
1563             double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
1564             inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
1565             inner.relocate(snappedLeftInset(), snappedTopInset());
1566         }
1567 
1568         @Override protected void setWidth(double value) {
1569             super.setWidth(value);
1570             clip.setWidth(value);
1571         }
1572 
1573         @Override protected void setHeight(double value) {
1574             super.setHeight(value);
1575             clip.setHeight(value);
1576         }
1577 
1578         /** {@inheritDoc} */
1579         @Override
1580         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1581             switch (attribute) {
1582                 case TEXT: return getTab().getText();
1583                 case SELECTED: return selectedTab == getTab();
1584                 default: return super.queryAccessibleAttribute(attribute, parameters);
1585             }
1586         }
1587 
1588         /** {@inheritDoc} */
1589         @Override
1590         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1591             switch (action) {
1592                 case REQUEST_FOCUS:
1593                     getSkinnable().getSelectionModel().select(getTab());
1594                     break;
1595                 default: super.executeAccessibleAction(action, parameters);
1596             }
1597         }
1598 
1599     } /* End TabHeaderSkin */
1600 
1601     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1602             PseudoClass.getPseudoClass(&quot;selected&quot;);
1603     private static final PseudoClass TOP_PSEUDOCLASS_STATE =
1604             PseudoClass.getPseudoClass(&quot;top&quot;);
1605     private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
1606             PseudoClass.getPseudoClass(&quot;bottom&quot;);
1607     private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
1608             PseudoClass.getPseudoClass(&quot;left&quot;);
1609     private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
1610             PseudoClass.getPseudoClass(&quot;right&quot;);
1611     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1612             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1613 
1614 
1615     /**************************************************************************
1616      *
1617      * TabContentRegion: each tab has one to contain the tab&#39;s content node
1618      *
1619      **************************************************************************/
1620     static class TabContentRegion extends StackPane {
1621 
1622         private Tab tab;
1623 
1624         private InvalidationListener tabContentListener = valueModel -&gt; {
1625             updateContent();
1626         };
1627         private InvalidationListener tabSelectedListener = new InvalidationListener() {
1628             @Override public void invalidated(Observable valueModel) {
1629                 setVisible(tab.isSelected());
1630             }
1631         };
1632 
1633         private WeakInvalidationListener weakTabContentListener =
1634                 new WeakInvalidationListener(tabContentListener);
1635         private WeakInvalidationListener weakTabSelectedListener =
1636                 new WeakInvalidationListener(tabSelectedListener);
1637 
1638         public Tab getTab() {
1639             return tab;
1640         }
1641 
1642         public TabContentRegion(Tab tab) {
1643             getStyleClass().setAll(&quot;tab-content-area&quot;);
1644             setManaged(false);
1645             this.tab = tab;
1646             updateContent();
1647             setVisible(tab.isSelected());
1648 
1649             tab.selectedProperty().addListener(weakTabSelectedListener);
1650             tab.contentProperty().addListener(weakTabContentListener);
1651         }
1652 
1653         private void updateContent() {
1654             Node newContent = getTab().getContent();
1655             if (newContent == null) {
1656                 getChildren().clear();
1657             } else {
1658                 getChildren().setAll(newContent);
1659             }
1660         }
1661 
1662         private void removeListeners(Tab tab) {
1663             tab.selectedProperty().removeListener(weakTabSelectedListener);
1664             tab.contentProperty().removeListener(weakTabContentListener);
1665         }
1666 
1667     } /* End TabContentRegion */
1668 
1669     /**************************************************************************
1670      *
1671      * TabControlButtons: controls to manipulate tab interaction
1672      *
1673      **************************************************************************/
1674     class TabControlButtons extends StackPane {
1675         private StackPane inner;
1676         private StackPane downArrow;
1677         private Pane downArrowBtn;
1678         private boolean showControlButtons;
1679         private ContextMenu popup;
1680 
1681         public TabControlButtons() {
1682             getStyleClass().setAll(&quot;control-buttons-tab&quot;);
1683 
1684             TabPane tabPane = getSkinnable();
1685 
1686             downArrowBtn = new Pane();
1687             downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
1688             downArrowBtn.setVisible(isShowTabsMenu());
1689             downArrow = new StackPane();
1690             downArrow.setManaged(false);
1691             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
1692             downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1693             downArrowBtn.getChildren().add(downArrow);
1694             downArrowBtn.setOnMouseClicked(me -&gt; {
1695                 showPopupMenu();
1696             });
1697 
1698             setupPopupMenu();
1699 
1700             inner = new StackPane() {
1701                 @Override protected double computePrefWidth(double height) {
1702                     double pw;
1703                     double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
1704                     pw = 0.0F;
1705                     if (isShowTabsMenu()) {
1706                         pw += maxArrowWidth;
1707                     }
1708                     if (pw &gt; 0) {
1709                         pw += snappedLeftInset() + snappedRightInset();
1710                     }
1711                     return pw;
1712                 }
1713 
1714                 @Override protected double computePrefHeight(double width) {
1715                     double height = 0.0F;
1716                     if (isShowTabsMenu()) {
1717                         height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
1718                     }
1719                     if (height &gt; 0) {
1720                         height += snappedTopInset() + snappedBottomInset();
1721                     }
1722                     return height;
1723                 }
1724 
1725                 @Override protected void layoutChildren() {
1726                     if (isShowTabsMenu()) {
1727                         double x = 0;
1728                         double y = snappedTopInset();
1729                         double w = snapSize(getWidth()) - x + snappedLeftInset();
1730                         double h = snapSize(getHeight()) - y + snappedBottomInset();
1731                         positionArrow(downArrowBtn, downArrow, x, y, w, h);
1732                     }
1733                 }
1734 
1735                 private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
1736                     btn.resize(width, height);
1737                     positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
1738                             HPos.CENTER, VPos.CENTER);
1739                     // center arrow region within arrow button
1740                     double arrowWidth = snapSize(arrow.prefWidth(-1));
1741                     double arrowHeight = snapSize(arrow.prefHeight(-1));
1742                     arrow.resize(arrowWidth, arrowHeight);
1743                     positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
1744                             width - btn.snappedLeftInset() - btn.snappedRightInset(),
1745                             height - btn.snappedTopInset() - btn.snappedBottomInset(),
1746                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1747                 }
1748             };
1749             inner.getStyleClass().add(&quot;container&quot;);
1750             inner.getChildren().add(downArrowBtn);
1751 
1752             getChildren().add(inner);
1753 
1754             tabPane.sideProperty().addListener(valueModel -&gt; {
1755                 Side tabPosition = getSkinnable().getSide();
1756                 downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
1757             });
1758             tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
1759             showControlButtons = false;
1760             if (isShowTabsMenu()) {
1761                 showControlButtons = true;
1762                 requestLayout();
1763             }
1764             getProperties().put(ContextMenu.class, popup);
1765         }
1766 
1767         private boolean showTabsMenu = false;
1768 
1769         private void showTabsMenu(boolean value) {
1770             final boolean wasTabsMenuShowing = isShowTabsMenu();
1771             this.showTabsMenu = value;
1772 
1773             if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
1774                 downArrowBtn.setVisible(true);
1775                 showControlButtons = true;
1776                 inner.requestLayout();
1777                 tabHeaderArea.requestLayout();
1778             } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
1779                 hideControlButtons();
1780             }
1781         }
1782 
1783         private boolean isShowTabsMenu() {
1784             return showTabsMenu;
1785         }
1786 
1787         @Override protected double computePrefWidth(double height) {
1788             double pw = snapSize(inner.prefWidth(height));
1789             if (pw &gt; 0) {
1790                 pw += snappedLeftInset() + snappedRightInset();
1791             }
1792             return pw;
1793         }
1794 
1795         @Override protected double computePrefHeight(double width) {
1796             return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
1797                     snappedTopInset() + snappedBottomInset();
1798         }
1799 
1800         @Override protected void layoutChildren() {
1801             double x = snappedLeftInset();
1802             double y = snappedTopInset();
1803             double w = snapSize(getWidth()) - x + snappedRightInset();
1804             double h = snapSize(getHeight()) - y + snappedBottomInset();
1805 
1806             if (showControlButtons) {
1807                 showControlButtons();
1808                 showControlButtons = false;
1809             }
1810 
1811             inner.resize(w, h);
1812             positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
1813         }
1814 
1815         private void showControlButtons() {
1816             setVisible(true);
1817             if (popup == null) {
1818                 setupPopupMenu();
1819             }
1820         }
1821 
1822         private void hideControlButtons() {
1823             // If the scroll arrows or tab menu is still visible we don&#39;t want
1824             // to hide it animate it back it.
1825             if (isShowTabsMenu()) {
1826                 showControlButtons = true;
1827             } else {
1828                 setVisible(false);
1829                 clearPopupMenu();
1830                 popup = null;
1831             }
1832 
1833             // This needs to be called when we are in the left tabPosition
1834             // to allow for the clip offset to move properly (otherwise
1835             // it jumps too early - before the animation is done).
1836             requestLayout();
1837         }
1838 
1839         private void setupPopupMenu() {
1840             if (popup == null) {
1841                 popup = new ContextMenu();
1842             }
1843             clearPopupMenu();
1844             ToggleGroup group = new ToggleGroup();
1845             ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
1846             for (final Tab tab : getSkinnable().getTabs()) {
1847                 TabMenuItem item = new TabMenuItem(tab);
1848                 item.setToggleGroup(group);
1849                 item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
1850                 menuitems.add(item);
1851             }
1852             popup.getItems().addAll(menuitems);
1853         }
1854 
1855         private void clearPopupMenu() {
1856             for (MenuItem item : popup.getItems()) {
1857                 ((TabMenuItem) item).dispose();
1858             }
1859             popup.getItems().clear();
1860         }
1861 
1862         private void showPopupMenu() {
1863             for (MenuItem mi: popup.getItems()) {
1864                 TabMenuItem tmi = (TabMenuItem)mi;
1865                 if (selectedTab.equals(tmi.getTab())) {
1866                     tmi.setSelected(true);
1867                     break;
1868                 }
1869             }
1870             popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
1871         }
1872     } /* End TabControlButtons*/
1873 
1874     static class TabMenuItem extends RadioMenuItem {
1875         Tab tab;
1876 
1877         private InvalidationListener disableListener = new InvalidationListener() {
1878             @Override public void invalidated(Observable o) {
1879                 setDisable(tab.isDisable());
1880             }
1881         };
1882 
1883         private WeakInvalidationListener weakDisableListener =
1884                 new WeakInvalidationListener(disableListener);
1885 
1886         public TabMenuItem(final Tab tab) {
1887             super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
1888             this.tab = tab;
1889             setDisable(tab.isDisable());
1890             tab.disableProperty().addListener(weakDisableListener);
1891             textProperty().bind(tab.textProperty());
1892         }
1893 
1894         public Tab getTab() {
1895             return tab;
1896         }
1897 
1898         public void dispose() {
1899             textProperty().unbind();
1900             tab.disableProperty().removeListener(weakDisableListener);
1901             tab = null;
1902         }
1903     }
1904 
1905     @Override
1906     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1907         switch (attribute) {
1908             case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
1909             case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
1910             case ITEM_AT_INDEX: {
1911                 Integer index = (Integer)parameters[0];
1912                 if (index == null) return null;
1913                 return tabHeaderArea.headersRegion.getChildren().get(index);
1914             }
1915             default: return super.queryAccessibleAttribute(attribute, parameters);
1916         }
1917     }
1918 
1919     // --------------------------
1920     // Tab Reordering
1921     // --------------------------
1922     private enum DragState {
1923         NONE,
1924         START,
1925         REORDER
1926     }
1927     private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
1928     private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
1929     private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;
1930 
1931     private int dragTabHeaderStartIndex;
1932     private int dragTabHeaderIndex;
1933     private TabHeaderSkin dragTabHeader;
1934     private TabHeaderSkin dropTabHeader;
1935     private StackPane headersRegion;
1936     private DragState dragState;
1937     private final int MIN_TO_MAX = 1;
1938     private final int MAX_TO_MIN = -1;
1939     private int xLayoutDirection;
1940     private double dragEventPrevLoc;
1941     private int prevDragDirection = MIN_TO_MAX;
1942     private final double DRAG_DIST_THRESHOLD = 0.75;
1943 
1944     // Reordering Animation
1945     private final double ANIM_DURATION = 120;
1946     private TabHeaderSkin dropAnimHeader;
1947     private double dropHeaderSourceX;
1948     private double dropHeaderTransitionX;
1949     private final Animation dropHeaderAnim = new Transition() {
1950         {
1951             setInterpolator(Interpolator.EASE_BOTH);
1952             setCycleDuration(Duration.millis(ANIM_DURATION));
1953             setOnFinished(event -&gt; {
1954                 completeHeaderReordering();
1955             });
1956         }
1957         protected void interpolate(double frac) {
1958             dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
1959         }
1960     };
1961     private double dragHeaderDestX;
1962     private double dragHeaderSourceX;
1963     private double dragHeaderTransitionX;
1964     private final Animation dragHeaderAnim = new Transition() {
1965         {
1966             setInterpolator(Interpolator.EASE_OUT);
1967             setCycleDuration(Duration.millis(ANIM_DURATION));
1968             setOnFinished(event -&gt; {
1969                 reorderTabs();
1970                 resetDrag();
1971             });
1972         }
1973         protected void interpolate(double frac) {
1974             dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
1975         }
1976     };
1977 
1978     // Helper methods for managing the listeners based on TabDragPolicy.
1979     private void addReorderListeners(Node n) {
1980         n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
1981         n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
1982         n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
1983     }
1984 
1985     private void removeReorderListeners(Node n) {
1986         n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
1987         n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
1988         n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
1989     }
1990 
1991     private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
1992         public void onChanged(Change&lt;? extends Node&gt; change) {
1993             while (change.next()) {
1994                 if (change.wasAdded()) {
1995                     for(Node n : change.getAddedSubList()) {
1996                         addReorderListeners(n);
1997                     }
1998                 }
1999                 if (change.wasRemoved()) {
2000                     for(Node n : change.getRemoved()) {
2001                         removeReorderListeners(n);
2002                     }
2003                 }
2004             }
2005         }
2006     };
2007 
2008     private void updateListeners() {
2009         if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
2010                 getSkinnable().getTabDragPolicy() == null) {
2011             for (Node n : headersRegion.getChildren()) {
2012                 removeReorderListeners(n);
2013             }
2014             headersRegion.getChildren().removeListener(childListener);
2015         } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
2016             for (Node n : headersRegion.getChildren()) {
2017                 addReorderListeners(n);
2018             }
2019             headersRegion.getChildren().addListener(childListener);
2020         }
2021     }
2022 
2023     private void setupReordering(StackPane headersRegion) {
2024         dragState = DragState.NONE;
2025         this.headersRegion = headersRegion;
2026         updateListeners();
2027         getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
2028             if (oldValue != newValue) {
2029                 updateListeners();
2030             }
2031         });
2032     }
2033 
2034     private void handleHeaderMousePressed(MouseEvent event) {
2035         if (event.getButton().equals(MouseButton.PRIMARY)) {
2036             ((StackPane) event.getSource()).setMouseTransparent(true);
2037             startDrag(event);
2038         }
2039     }
2040 
2041     private void handleHeaderMouseReleased(MouseEvent event) {
2042         if (event.getButton().equals(MouseButton.PRIMARY)) {
2043             ((StackPane) event.getSource()).setMouseTransparent(false);
2044             stopDrag();
2045             event.consume();
2046         }
2047     }
2048 
2049     private void handleHeaderDragged(MouseEvent event) {
2050         if (event.getButton().equals(MouseButton.PRIMARY)) {
2051             perfromDrag(event);
2052         }
2053     }
2054 
2055     private double getDragDelta(double curr, double prev) {
2056         if (getSkinnable().getSide().equals(Side.TOP) ||
2057                 getSkinnable().getSide().equals(Side.RIGHT)) {
2058             return curr - prev;
2059         } else {
2060             return prev - curr;
2061         }
2062     }
2063 
2064     private int deriveTabHeaderLayoutXDirection() {
2065         if (getSkinnable().getSide().equals(Side.TOP) ||
2066                 getSkinnable().getSide().equals(Side.RIGHT)) {
2067             // TabHeaderSkin are laid out in left to right direction inside headersRegion
2068             return MIN_TO_MAX;
2069         }
2070         // TabHeaderSkin are laid out in right to left direction inside headersRegion
2071         return MAX_TO_MIN;
2072     }
2073 
2074     private void perfromDrag(MouseEvent event) {
2075         int dragDirection;
2076         double dragHeaderNewLayoutX;
2077         Bounds dragHeaderBounds;
2078         Bounds dropHeaderBounds;
2079         double draggedDist;
2080         double mouseCurrentLoc = getHeaderRegionLocalX(event);
2081         double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);
2082 
2083         if (dragDelta &gt; 0) {
2084             // Dragging the tab header towards higher indexed tab headers inside headersRegion.
2085             dragDirection = MIN_TO_MAX;
2086         } else {
2087             // Dragging the tab header towards lower indexed tab headers inside headersRegion.
2088             dragDirection = MAX_TO_MIN;
2089         }
2090         // Stop dropHeaderAnim if direction of drag is changed
2091         if (prevDragDirection != dragDirection) {
2092             stopAnim(dropHeaderAnim);
2093             prevDragDirection = dragDirection;
2094         }
2095 
2096         dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;
2097 
2098         if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
2099                 dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {
2100 
2101             dragState = DragState.REORDER;
2102             dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
2103             dragHeaderBounds = dragTabHeader.getBoundsInParent();
2104 
2105             if (dragDirection == MIN_TO_MAX) {
2106                 // Dragging the tab header towards higher indexed tab headers
2107                 // Last tab header can not be dragged outside headersRegion.
2108 
2109                 // When the mouse is moved too fast, sufficient number of events
2110                 // are not generated. Hence it is required to check all possible
2111                 // headers to be reordered.
2112                 for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
2113                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2114 
2115                     // dropTabHeader should not be already reordering.
2116                     if (dropAnimHeader != dropTabHeader) {
2117                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2118 
2119                         if (xLayoutDirection == MIN_TO_MAX) {
2120                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2121                         } else {
2122                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2123                         }
2124 
2125                         // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2126                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2127                             stopAnim(dropHeaderAnim);
2128                             // Distance by which tab header should be animated.
2129                             dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
2130                             if (xLayoutDirection == MIN_TO_MAX) {
2131                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2132                             } else {
2133                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2134                             }
2135                             startHeaderReorderingAnim();
2136                         } else {
2137                             break;
2138                         }
2139                     }
2140                 }
2141             } else {
2142                 // dragDirection is MAX_TO_MIN
2143                 // Dragging the tab header towards lower indexed tab headers.
2144                 // First tab header can not be dragged outside headersRegion.
2145 
2146                 // When the mouse is moved too fast, sufficient number of events
2147                 // are not generated. Hence it is required to check all possible
2148                 // tab headers to be reordered.
2149                 for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
2150                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2151 
2152                     // dropTabHeader should not be already reordering.
2153                     if (dropAnimHeader != dropTabHeader) {
2154                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2155 
2156                         if (xLayoutDirection == MIN_TO_MAX) {
2157                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2158                         } else {
2159                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2160                         }
2161 
2162                         // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2163                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2164                             stopAnim(dropHeaderAnim);
2165                             // Distance by which tab header should be animated.
2166                             dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
2167                             if (xLayoutDirection == MIN_TO_MAX) {
2168                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2169                             } else {
2170                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2171                             }
2172                             startHeaderReorderingAnim();
2173                         } else {
2174                             break;
2175                         }
2176                     }
2177                 }
2178             }
2179         }
2180         dragEventPrevLoc = mouseCurrentLoc;
2181         event.consume();
2182     }
2183 
2184     private void startDrag(MouseEvent event) {
2185         // Stop the animations if any are running from previous reorder.
2186         stopAnim(dropHeaderAnim);
2187         stopAnim(dragHeaderAnim);
2188 
2189         dragTabHeader = (TabHeaderSkin) event.getSource();
2190         if (dragTabHeader != null) {
2191             dragState = DragState.START;
2192             xLayoutDirection = deriveTabHeaderLayoutXDirection();
2193             dragEventPrevLoc = getHeaderRegionLocalX(event);
2194             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2195             dragTabHeaderStartIndex = dragTabHeaderIndex;
2196             dragTabHeader.setViewOrder(0);
2197             dragHeaderDestX = dragTabHeader.getLayoutX();
2198         }
2199     }
2200 
2201     private double getHeaderRegionLocalX(MouseEvent ev) {
2202         // The event is converted to tab header&#39;s parent i.e. headersRegion&#39;s local space.
2203         // This will provide a value of X co-ordinate with all transformations of TabPane
2204         // and transformations of all nodes in the TabPane&#39;s parent hierarchy.
2205         Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
2206         return sceneToLocalHR.getX();
2207     }
2208 
2209     private void stopDrag() {
2210         if (dragState == DragState.START) {
2211             // No drag action was performed.
2212             resetDrag();
2213         } else if (dragState == DragState.REORDER) {
2214             // Animate tab header being dragged to its final position.
2215             dragHeaderSourceX = dragTabHeader.getLayoutX();
2216             dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
2217             dragHeaderAnim.playFromStart();
2218         }
2219     }
2220 
2221     private void reorderTabs() {
2222         if (dragTabHeaderIndex != dragTabHeaderStartIndex) {
2223             ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(
2224                     getSkinnable().getTabs().get(dragTabHeaderStartIndex),
2225                     getSkinnable().getTabs().get(dragTabHeaderIndex));
2226         }
2227     }
2228 
2229     private void resetDrag() {
2230         dragState = DragState.NONE;
2231         dragTabHeader.setViewOrder(1);
2232         dragTabHeader = null;
2233         dropTabHeader = null;
2234         headersRegion.requestLayout();
2235     }
2236 
2237     // Animate tab header being dropped-on to its new position.
2238     private void startHeaderReorderingAnim() {
2239         dropAnimHeader = dropTabHeader;
2240         dropHeaderSourceX = dropAnimHeader.getLayoutX();
2241         dropHeaderAnim.playFromStart();
2242     }
2243 
2244     // Remove dropAnimHeader and add at the index position of dragTabHeader.
2245     private void completeHeaderReordering() {
2246         if (dropAnimHeader != null) {
2247             headersRegion.getChildren().remove(dropAnimHeader);
2248             headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
2249             dropAnimHeader = null;
2250             headersRegion.requestLayout();
2251             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2252         }
2253     }
2254 
2255     // Helper method to stop an animation.
2256     private void stopAnim(Animation anim) {
2257         if (anim.getStatus() == Animation.Status.RUNNING) {
2258             anim.getOnFinished().handle(null);
2259             anim.stop();
2260         }
2261     }
2262 
2263     // For testing purpose.
2264     ContextMenu test_getTabsMenu() {
2265         return tabHeaderArea.controlButtons.popup;
2266     }
2267 }
    </pre>
  </body>
</html>