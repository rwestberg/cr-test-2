<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/AudioUnits/AUPublic/AUBase/AUBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2 Copyright (C) 2016 Apple Inc. All Rights Reserved.
   3 See LICENSE.txt for this sampleâ€™s licensing information
   4 
   5 Abstract:
   6 Part of Core Audio AUBase Classes
   7 */
   8 
   9 #include &quot;AUBase.h&quot;
  10 #if !CA_USE_AUDIO_PLUGIN_ONLY
  11     #include &quot;AUDispatch.h&quot;
  12 #endif
  13 #include &quot;AUInputElement.h&quot;
  14 #include &quot;AUOutputElement.h&quot;
  15 #include &lt;algorithm&gt;
  16 #include &lt;syslog.h&gt;
  17 #include &quot;CAAudioChannelLayout.h&quot;
  18 #include &quot;CAHostTimeBase.h&quot;
  19 #include &quot;CAVectorUnit.h&quot;
  20 #include &quot;CAXException.h&quot;
  21 
  22 #if TARGET_OS_MAC &amp;&amp; (TARGET_CPU_X86 || TARGET_CPU_X86_64)
  23     // our compiler does ALL floating point with SSE
  24     inline int  GETCSR ()    { int _result; asm volatile (&quot;stmxcsr %0&quot; : &quot;=m&quot; (*&amp;_result) ); return _result; }
  25     inline void SETCSR (int a)    { int _temp = a; asm volatile( &quot;ldmxcsr %0&quot; : : &quot;m&quot; (*&amp;_temp ) ); }
  26 
  27     #define DISABLE_DENORMALS int _savemxcsr = GETCSR(); SETCSR(_savemxcsr | 0x8040);
  28     #define RESTORE_DENORMALS SETCSR(_savemxcsr);
  29 #else
  30     #define DISABLE_DENORMALS
  31     #define RESTORE_DENORMALS
  32 #endif
  33 
  34 static bool sAUBaseCFStringsInitialized = false;
  35 // this is used for the presets
  36 static CFStringRef kUntitledString = NULL;
  37 //these are the current keys for the class info document
  38 static CFStringRef kVersionString = NULL;
  39 static CFStringRef kTypeString = NULL;
  40 static CFStringRef kSubtypeString = NULL;
  41 static CFStringRef kManufacturerString = NULL;
  42 static CFStringRef kDataString = NULL;
  43 static CFStringRef kNameString = NULL;
  44 static CFStringRef kRenderQualityString = NULL;
  45 static CFStringRef kCPULoadString = NULL;
  46 static CFStringRef kElementNameString = NULL;
  47 static CFStringRef kPartString = NULL;
  48 
  49 SInt32 AUBase::sVectorUnitType = kVecUninitialized;
  50 
  51 //_____________________________________________________________________________
  52 //
  53 AUBase::AUBase( AudioComponentInstance          inInstance,
  54                 UInt32                          numInputElements,
  55                 UInt32                          numOutputElements,
  56                 UInt32                          numGroupElements) :
  57     ComponentBase(inInstance),
  58     mElementsCreated(false),
  59     mInitialized(false),
  60     mHasBegunInitializing(false),
  61     mInitNumInputEls(numInputElements), mInitNumOutputEls(numOutputElements),
  62 #if !CA_BASIC_AU_FEATURES
  63     mInitNumGroupEls(numGroupElements),
  64 #endif
  65     mRenderCallbacksTouched(false),
  66     mRenderThreadID (NULL),
  67     mWantsRenderThreadID (false),
  68     mLastRenderError(0),
  69     mUsesFixedBlockSize(false),
  70     mBuffersAllocated(false),
  71     mLogString (NULL),
  72     mNickName (NULL),
  73     mAUMutex(NULL)
  74     #if !CA_NO_AU_UI_FEATURES
  75         ,
  76         mContextName(NULL)
  77     #endif
  78 {
  79     ResetRenderTime ();
  80 
  81     if(!sAUBaseCFStringsInitialized)
  82     {
  83         kUntitledString = CFSTR(&quot;Untitled&quot;);
  84         kVersionString = CFSTR(kAUPresetVersionKey);
  85         kTypeString = CFSTR(kAUPresetTypeKey);
  86         kSubtypeString = CFSTR(kAUPresetSubtypeKey);
  87         kManufacturerString = CFSTR(kAUPresetManufacturerKey);
  88         kDataString = CFSTR(kAUPresetDataKey);
  89         kNameString = CFSTR(kAUPresetNameKey);
  90         kRenderQualityString = CFSTR(kAUPresetRenderQualityKey);
  91         kCPULoadString = CFSTR(kAUPresetCPULoadKey);
  92         kElementNameString = CFSTR(kAUPresetElementNameKey);
  93         kPartString = CFSTR(kAUPresetPartKey);
  94         sAUBaseCFStringsInitialized = true;
  95     }
  96 
  97     if (sVectorUnitType == kVecUninitialized) {
  98         sVectorUnitType = CAVectorUnit::GetVectorUnitType() ;
  99     }
 100 
 101     mAudioUnitAPIVersion = 2;
 102 
 103     SetMaxFramesPerSlice(kAUDefaultMaxFramesPerSlice);
 104 
 105     GlobalScope().Initialize(this, kAudioUnitScope_Global, 1);
 106 
 107 #if !CA_NO_AU_UI_FEATURES
 108     memset (&amp;mHostCallbackInfo, 0, sizeof (mHostCallbackInfo));
 109 #endif
 110 
 111 
 112     mCurrentPreset.presetNumber = -1;
 113     mCurrentPreset.presetName = kUntitledString;
 114     CFRetain (mCurrentPreset.presetName);
 115 }
 116 
 117 //_____________________________________________________________________________
 118 //
 119 AUBase::~AUBase()
 120 {
 121     if (mCurrentPreset.presetName) CFRelease (mCurrentPreset.presetName);
 122 #if !CA_NO_AU_UI_FEATURES
 123     if (mContextName) CFRelease (mContextName);
 124 #endif
 125     if (mLogString) delete [] mLogString;
 126     if (mNickName) CFRelease(mNickName);
 127 }
 128 
 129 //_____________________________________________________________________________
 130 //
 131 void    AUBase::CreateElements()
 132 {
 133     if (!mElementsCreated) {
 134         Inputs().Initialize(this, kAudioUnitScope_Input, mInitNumInputEls);
 135         Outputs().Initialize(this, kAudioUnitScope_Output, mInitNumOutputEls);
 136 #if !CA_BASIC_AU_FEATURES
 137         Groups().Initialize(this, kAudioUnitScope_Group, mInitNumGroupEls);
 138 #endif
 139         CreateExtendedElements();
 140 
 141         mElementsCreated = true;
 142     }
 143 }
 144 
 145 //_____________________________________________________________________________
 146 //
 147 void    AUBase::SetMaxFramesPerSlice(UInt32 nFrames)
 148 {
 149     mMaxFramesPerSlice = nFrames;
 150     if (mBuffersAllocated)
 151         ReallocateBuffers();
 152     PropertyChanged(kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0);
 153 }
 154 
 155 //_____________________________________________________________________________
 156 //
 157 OSStatus            AUBase::CanSetMaxFrames() const
 158 {
 159     return IsInitialized() ? kAudioUnitErr_Initialized : OSStatus(noErr);
 160 }
 161 
 162 //_____________________________________________________________________________
 163 //
 164 void                AUBase::ReallocateBuffers()
 165 {
 166     CreateElements();
 167 
 168     UInt32 nOutputs = Outputs().GetNumberOfElements();
 169     for (UInt32 i = 0; i &lt; nOutputs; ++i) {
 170         AUOutputElement *output = GetOutput(i);
 171         output-&gt;AllocateBuffer();   // does no work if already allocated
 172     }
 173     UInt32 nInputs = Inputs().GetNumberOfElements();
 174     for (UInt32 i = 0; i &lt; nInputs; ++i) {
 175         AUInputElement *input = GetInput(i);
 176         input-&gt;AllocateBuffer();    // does no work if already allocated
 177     }
 178     mBuffersAllocated = true;
 179 }
 180 
 181 //_____________________________________________________________________________
 182 //
 183 void                AUBase::DeallocateIOBuffers()
 184 {
 185     if (!mBuffersAllocated)
 186         return;
 187 
 188     UInt32 nOutputs = Outputs().GetNumberOfElements();
 189     for (UInt32 i = 0; i &lt; nOutputs; ++i) {
 190         AUOutputElement *output = GetOutput(i);
 191         output-&gt;DeallocateBuffer();
 192     }
 193     UInt32 nInputs = Inputs().GetNumberOfElements();
 194     for (UInt32 i = 0; i &lt; nInputs; ++i) {
 195         AUInputElement *input = GetInput(i);
 196         input-&gt;DeallocateBuffer();
 197     }
 198     mBuffersAllocated = false;
 199 }
 200 
 201 //_____________________________________________________________________________
 202 //
 203 OSStatus            AUBase::DoInitialize()
 204 {
 205     OSStatus result = noErr;
 206 
 207     if (!mInitialized) {
 208         result = Initialize();
 209         if (result == noErr) {
 210             if (CanScheduleParameters())
 211                 mParamList.reserve(24);
 212             mHasBegunInitializing = true;
 213             ReallocateBuffers();    // calls CreateElements()
 214             mInitialized = true;    // signal that it&#39;s okay to render
 215             CAMemoryBarrier();
 216         }
 217     }
 218 
 219     return result;
 220 }
 221 
 222 //_____________________________________________________________________________
 223 //
 224 OSStatus            AUBase::Initialize()
 225 {
 226     return noErr;
 227 }
 228 
 229 //_____________________________________________________________________________
 230 //
 231 void                AUBase::PreDestructor()
 232 {
 233     // this is called from the ComponentBase dispatcher, which doesn&#39;t know anything about our (optional) lock
 234     CAMutex::Locker lock(mAUMutex);
 235     DoCleanup();
 236 }
 237 
 238 //_____________________________________________________________________________
 239 //
 240 void                AUBase::DoCleanup()
 241 {
 242     if (mInitialized)
 243         Cleanup();
 244 
 245     DeallocateIOBuffers();
 246     ResetRenderTime ();
 247 
 248     mInitialized = false;
 249     mHasBegunInitializing = false;
 250 }
 251 
 252 //_____________________________________________________________________________
 253 //
 254 void                AUBase::Cleanup()
 255 {
 256 }
 257 
 258 //_____________________________________________________________________________
 259 //
 260 OSStatus            AUBase::Reset(                  AudioUnitScope                  inScope,
 261                                                     AudioUnitElement                inElement)
 262 {
 263     ResetRenderTime ();
 264     return noErr;
 265 }
 266 
 267 //_____________________________________________________________________________
 268 //
 269 OSStatus            AUBase::DispatchGetPropertyInfo(AudioUnitPropertyID             inID,
 270                                                     AudioUnitScope                  inScope,
 271                                                     AudioUnitElement                inElement,
 272                                                     UInt32 &amp;                        outDataSize,
 273                                                     Boolean &amp;                       outWritable)
 274 {
 275     OSStatus result = noErr;
 276     bool validateElement = true;
 277 
 278     switch (inID) {
 279     case kAudioUnitProperty_MakeConnection:
 280         ca_require(inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Global, InvalidScope);
 281         outDataSize = sizeof(AudioUnitConnection);
 282         outWritable = true;
 283         break;
 284 
 285 
 286     case kAudioUnitProperty_SetRenderCallback:
 287         ca_require(AudioUnitAPIVersion() &gt; 1, InvalidProperty);
 288         ca_require(inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Global, InvalidScope);
 289         outDataSize = sizeof(AURenderCallbackStruct);
 290         outWritable = true;
 291         break;
 292 
 293     case kAudioUnitProperty_StreamFormat:
 294         outDataSize = sizeof(CAStreamBasicDescription);
 295         outWritable = IsStreamFormatWritable(inScope, inElement);
 296         break;
 297 
 298     case kAudioUnitProperty_SampleRate:
 299         outDataSize = sizeof(Float64);
 300         outWritable = IsStreamFormatWritable(inScope, inElement);
 301         break;
 302 
 303     case kAudioUnitProperty_ClassInfo:
 304         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 305         outDataSize = sizeof(CFPropertyListRef);
 306         outWritable = true;
 307         break;
 308 
 309     case kAudioUnitProperty_FactoryPresets:
 310         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 311         result = GetPresets(NULL);
 312         if (!result) {
 313             outDataSize = sizeof(CFArrayRef);
 314             outWritable = false;
 315         }
 316         break;
 317 
 318     case kAudioUnitProperty_PresentPreset:
 319 #if !CA_USE_AUDIO_PLUGIN_ONLY
 320 #ifndef __LP64__
 321     case kAudioUnitProperty_CurrentPreset:
 322 #endif
 323 #endif
 324         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 325         outDataSize = sizeof(AUPreset);
 326         outWritable = true;
 327         break;
 328 
 329     case kAudioUnitProperty_ElementName:
 330         outDataSize = sizeof (CFStringRef);
 331         outWritable = true;
 332         break;
 333 
 334     case kAudioUnitProperty_ParameterList:
 335         {
 336             UInt32 nparams = 0;
 337             result = GetParameterList(inScope, NULL, nparams);
 338 
 339             outDataSize = sizeof(AudioUnitParameterID) * nparams;
 340             outWritable = false;
 341             validateElement = false;
 342         }
 343         break;
 344 
 345     case kAudioUnitProperty_ParameterInfo:
 346         outDataSize = sizeof(AudioUnitParameterInfo);
 347         outWritable = false;
 348         validateElement = false;
 349         break;
 350 
 351     case kAudioUnitProperty_ParameterHistoryInfo:
 352         outDataSize = sizeof(AudioUnitParameterHistoryInfo);
 353         outWritable = false;
 354         validateElement = false;
 355         break;
 356 
 357     case kAudioUnitProperty_ElementCount:
 358         outDataSize = sizeof(UInt32);
 359         outWritable = BusCountWritable(inScope);
 360         validateElement = false;
 361         break;
 362 
 363     case kAudioUnitProperty_Latency:
 364         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 365         outDataSize = sizeof(Float64);
 366         outWritable = false;
 367         break;
 368 
 369     case kAudioUnitProperty_TailTime:
 370         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 371         if (SupportsTail()) {
 372             outDataSize = sizeof(Float64);
 373             outWritable = false;
 374         } else
 375             goto InvalidProperty;
 376         break;
 377 
 378     case kAudioUnitProperty_MaximumFramesPerSlice:
 379         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 380         outDataSize = sizeof(UInt32);
 381         outWritable = true;
 382         break;
 383 
 384     case kAudioUnitProperty_LastRenderError:
 385         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 386         outDataSize = sizeof(OSStatus);
 387         outWritable = false;
 388         break;
 389 
 390     case kAudioUnitProperty_SupportedNumChannels:
 391     {
 392         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 393         UInt32 num = SupportedNumChannels (NULL);
 394         if (num) {
 395             outDataSize = sizeof (AUChannelInfo) * num;
 396             result = noErr;
 397         } else
 398             goto InvalidProperty;
 399         outWritable = false;
 400         break;
 401     }
 402 
 403     case kAudioUnitProperty_SupportedChannelLayoutTags:
 404     {
 405         UInt32 numLayouts = GetChannelLayoutTags(inScope, inElement, NULL);
 406         if (numLayouts) {
 407             outDataSize = numLayouts * sizeof(AudioChannelLayoutTag);
 408             result = noErr;
 409         } else
 410             goto InvalidProperty;
 411         outWritable = false;
 412         validateElement = false; //already done it
 413         break;
 414     }
 415 
 416     case kAudioUnitProperty_AudioChannelLayout:
 417     {
 418         outWritable = false;
 419         outDataSize = GetAudioChannelLayout(inScope, inElement, NULL, outWritable);
 420         if (outDataSize) {
 421             result = noErr;
 422         } else {
 423             if (GetChannelLayoutTags(inScope, inElement, NULL) == 0)
 424                 goto InvalidProperty;
 425             else
 426                 result = kAudioUnitErr_InvalidPropertyValue;
 427         }
 428         validateElement = false; //already done it
 429         break;
 430     }
 431 
 432 #if (MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
 433     case kAudioUnitProperty_ShouldAllocateBuffer:
 434         ca_require((inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Output), InvalidScope);
 435         outWritable = true;
 436         outDataSize = sizeof(UInt32);
 437         break;
 438 #endif
 439 
 440 #if !CA_USE_AUDIO_PLUGIN_ONLY
 441     case kAudioUnitProperty_FastDispatch:
 442         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 443         if (!IsCMgrObject()) goto InvalidProperty;
 444         outDataSize = sizeof(void *);
 445         outWritable = false;
 446         validateElement = false;
 447         break;
 448 
 449     case kAudioUnitProperty_GetUIComponentList:
 450         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 451         outDataSize = GetNumCustomUIComponents();
 452         if (outDataSize == 0)
 453             goto InvalidProperty;
 454         outDataSize *= sizeof (AudioComponentDescription);
 455 
 456         outWritable = false;
 457         break;
 458 #endif
 459 
 460     case kAudioUnitProperty_ParameterValueStrings:
 461         result = GetParameterValueStrings(inScope, inElement, NULL);
 462         if (result == noErr) {
 463             outDataSize = sizeof(CFArrayRef);
 464             outWritable = false;
 465             validateElement = false;
 466         }
 467         break;
 468 
 469 #if !CA_NO_AU_HOST_CALLBACKS
 470     case kAudioUnitProperty_HostCallbacks:
 471         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 472         outDataSize = sizeof(mHostCallbackInfo);
 473         outWritable = true;
 474         break;
 475 #endif
 476 #if !CA_NO_AU_UI_FEATURES
 477     case kAudioUnitProperty_ContextName:
 478         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 479         outDataSize = sizeof(CFStringRef);
 480         outWritable = true;
 481         break;
 482 
 483     case kAudioUnitProperty_IconLocation:
 484         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 485         outWritable = false;
 486         if (!HasIcon())
 487             goto InvalidProperty;
 488         outDataSize = sizeof(CFURLRef);
 489         break;
 490 
 491     case kAudioUnitProperty_ParameterClumpName:
 492         outDataSize = sizeof(AudioUnitParameterNameInfo );
 493         outWritable = false;
 494         break;
 495 
 496 #endif // !CA_NO_AU_UI_FEATURES
 497 
 498     case &#39;lrst&#39; :  // kAudioUnitProperty_LastRenderedSampleTime
 499         outDataSize = sizeof(Float64);
 500         outWritable = false;
 501         break;
 502 
 503     case kAudioUnitProperty_NickName:
 504         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 505         outDataSize = sizeof(CFStringRef);
 506         outWritable = true;
 507         break;
 508 
 509     default:
 510         result = GetPropertyInfo(inID, inScope, inElement, outDataSize, outWritable);
 511         validateElement = false;
 512         break;
 513     }
 514 
 515     if (result == noErr &amp;&amp; validateElement) {
 516         ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
 517     }
 518 
 519     return result;
 520 InvalidProperty:
 521     return kAudioUnitErr_InvalidProperty;
 522 InvalidScope:
 523     return kAudioUnitErr_InvalidScope;
 524 InvalidElement:
 525     return kAudioUnitErr_InvalidElement;
 526 }
 527 
 528 //_____________________________________________________________________________
 529 //
 530 OSStatus            AUBase::DispatchGetProperty(    AudioUnitPropertyID             inID,
 531                                                     AudioUnitScope                  inScope,
 532                                                     AudioUnitElement                inElement,
 533                                                     void *                          outData)
 534 {
 535     // NOTE: We&#39;re currently only called from AUBase::ComponentEntryDispatch, which
 536     // calls DispatchGetPropertyInfo first, which performs validation of the scope/element,
 537     // and ensures that the outData buffer is non-null and large enough.
 538     OSStatus result = noErr;
 539 
 540     switch (inID) {
 541     case kAudioUnitProperty_StreamFormat:
 542         *(CAStreamBasicDescription *)outData = GetStreamFormat(inScope, inElement);
 543         break;
 544 
 545     case kAudioUnitProperty_SampleRate:
 546         *(Float64 *)outData = GetStreamFormat(inScope, inElement).mSampleRate;
 547         break;
 548 
 549     case kAudioUnitProperty_ParameterList:
 550         {
 551             UInt32 nparams = 0;
 552             result = GetParameterList(inScope, (AudioUnitParameterID *)outData, nparams);
 553         }
 554         break;
 555 
 556     case kAudioUnitProperty_ParameterInfo:
 557         result = GetParameterInfo(inScope, inElement, *(AudioUnitParameterInfo *)outData);
 558         break;
 559 
 560     case kAudioUnitProperty_ParameterHistoryInfo:
 561         {
 562             AudioUnitParameterHistoryInfo* info = (AudioUnitParameterHistoryInfo*)outData;
 563             result = GetParameterHistoryInfo(inScope, inElement, info-&gt;updatesPerSecond, info-&gt;historyDurationInSeconds);
 564         }
 565         break;
 566 
 567     case kAudioUnitProperty_ClassInfo:
 568         {
 569             *(CFPropertyListRef *)outData = NULL;
 570             result = SaveState((CFPropertyListRef *)outData);
 571         }
 572         break;
 573 
 574     case kAudioUnitProperty_FactoryPresets:
 575         {
 576             *(CFArrayRef *)outData = NULL;
 577             result = GetPresets ((CFArrayRef *)outData);
 578         }
 579         break;
 580 
 581     case kAudioUnitProperty_PresentPreset:
 582 #if !CA_USE_AUDIO_PLUGIN_ONLY
 583 #ifndef __LP64__
 584     case kAudioUnitProperty_CurrentPreset:
 585 #endif
 586 #endif
 587         {
 588             *(AUPreset *)outData = mCurrentPreset;
 589 
 590                 // retain current string (as client owns a reference to it and will release it)
 591             if (inID == kAudioUnitProperty_PresentPreset &amp;&amp; mCurrentPreset.presetName)
 592                 CFRetain (mCurrentPreset.presetName);
 593 
 594             result = noErr;
 595         }
 596         break;
 597 
 598     case kAudioUnitProperty_ElementName:
 599         {
 600             AUElement * element = GetElement(inScope, inElement);
 601             if (element-&gt;HasName()) {
 602                 *(CFStringRef *)outData = element-&gt;GetName();
 603                 CFRetain (element-&gt;GetName());
 604                 result = noErr;
 605             } else
 606                 result = kAudioUnitErr_InvalidPropertyValue;
 607         }
 608         break;
 609 
 610     case kAudioUnitProperty_ElementCount:
 611         *(UInt32 *)outData = GetScope(inScope).GetNumberOfElements();
 612         break;
 613 
 614     case kAudioUnitProperty_Latency:
 615         *(Float64 *)outData = GetLatency();
 616         break;
 617 
 618     case kAudioUnitProperty_TailTime:
 619         if (SupportsTail())
 620             *(Float64 *)outData = GetTailTime();
 621         else
 622             result = kAudioUnitErr_InvalidProperty;
 623         break;
 624 
 625     case kAudioUnitProperty_MaximumFramesPerSlice:
 626         *(UInt32 *)outData = mMaxFramesPerSlice;
 627         break;
 628 
 629     case kAudioUnitProperty_LastRenderError:
 630         *(OSStatus *)outData = mLastRenderError;
 631         mLastRenderError = 0;
 632         break;
 633 
 634     case kAudioUnitProperty_SupportedNumChannels:
 635         {
 636             const AUChannelInfo* infoPtr = NULL;
 637             UInt32 num = SupportedNumChannels (&amp;infoPtr);
 638             if(num != 0 &amp;&amp; infoPtr != NULL)
 639                 memcpy (outData, infoPtr, num * sizeof (AUChannelInfo));
 640         }
 641         break;
 642 
 643     case kAudioUnitProperty_SupportedChannelLayoutTags:
 644         {
 645             AudioChannelLayoutTag* ptr = outData ? static_cast&lt;AudioChannelLayoutTag*&gt;(outData) : NULL;
 646             UInt32 numLayouts = GetChannelLayoutTags (inScope, inElement, ptr);
 647             if (numLayouts == 0)
 648                 result = kAudioUnitErr_InvalidProperty;
 649         }
 650         break;
 651 
 652     case kAudioUnitProperty_AudioChannelLayout:
 653     {
 654         AudioChannelLayout* ptr = outData ? static_cast&lt;AudioChannelLayout*&gt;(outData) : NULL;
 655         Boolean writable;
 656         UInt32 dataSize = GetAudioChannelLayout(inScope, inElement, ptr, writable);
 657         if (!dataSize) {
 658             result = kAudioUnitErr_InvalidProperty;
 659         }
 660         break;
 661     }
 662 
 663 #if (MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
 664     case kAudioUnitProperty_ShouldAllocateBuffer:
 665     {
 666         AUIOElement * element = GetIOElement(inScope, inElement);
 667         *(UInt32*)outData = element-&gt;WillAllocateBuffer();
 668         break;
 669     }
 670 #endif
 671 
 672     case kAudioUnitProperty_ParameterValueStrings:
 673         result = GetParameterValueStrings(inScope, inElement, (CFArrayRef *)outData);
 674         break;
 675 
 676 #if !CA_USE_AUDIO_PLUGIN_ONLY
 677     case kAudioUnitProperty_FastDispatch:
 678         if (!IsCMgrObject()) result = kAudioUnitErr_InvalidProperty;
 679         else {
 680             switch (inElement) {
 681             case kAudioUnitGetParameterSelect:
 682                 *(AudioUnitGetParameterProc *)outData = (AudioUnitGetParameterProc)CMgr_AudioUnitBaseGetParameter;
 683                 break;
 684             case kAudioUnitSetParameterSelect:
 685                 *(AudioUnitSetParameterProc *)outData = (AudioUnitSetParameterProc)CMgr_AudioUnitBaseSetParameter;
 686                 break;
 687             case kAudioUnitRenderSelect:
 688                 if (AudioUnitAPIVersion() &gt; 1)
 689                     *(AudioUnitRenderProc *)outData = (AudioUnitRenderProc)CMgr_AudioUnitBaseRender;
 690                 else result = kAudioUnitErr_InvalidElement;
 691                 break;
 692             default:
 693                 result = GetProperty(inID, inScope, inElement, outData);
 694                 break;
 695             }
 696         }
 697         break;
 698 
 699     case kAudioUnitProperty_GetUIComponentList:
 700         GetUIComponentDescs ((ComponentDescription*)outData);
 701         break;
 702 #endif
 703 
 704 #if !CA_NO_AU_HOST_CALLBACKS
 705     case kAudioUnitProperty_HostCallbacks:
 706         memcpy(outData, &amp;mHostCallbackInfo, sizeof(mHostCallbackInfo));
 707         break;
 708 #endif
 709 #if !CA_NO_AU_UI_FEATURES
 710     case kAudioUnitProperty_ContextName:
 711         *(CFStringRef *)outData = mContextName;
 712         if (mContextName) {
 713             CFRetain(mContextName);
 714             // retain CFString (if exists) since client will be responsible for its release
 715             result = noErr;
 716         } else {
 717             result = kAudioUnitErr_InvalidPropertyValue;
 718         }
 719         break;
 720 
 721     case kAudioUnitProperty_IconLocation:
 722         {
 723             CFURLRef iconLocation = CopyIconLocation();
 724             if (iconLocation) {
 725                 *(CFURLRef*)outData = iconLocation;
 726             } else
 727                 result = kAudioUnitErr_InvalidProperty;
 728         }
 729         break;
 730 
 731     case kAudioUnitProperty_ParameterClumpName:
 732         {
 733             AudioUnitParameterNameInfo * ioClumpInfo = (AudioUnitParameterNameInfo*) outData;
 734             if (ioClumpInfo-&gt;inID == kAudioUnitClumpID_System)  // this ID value is reserved
 735                 result = kAudioUnitErr_InvalidPropertyValue;
 736             else
 737             {
 738                 result = CopyClumpName(inScope, ioClumpInfo-&gt;inID, ioClumpInfo-&gt;inDesiredLength, &amp;ioClumpInfo-&gt;outName);
 739 
 740                     // this is provided for compatbility with existing implementations that don&#39;t know
 741                     // about this new mechanism
 742                 if (result == kAudioUnitErr_InvalidProperty)
 743                     result = GetProperty (inID, inScope, inElement, outData);
 744             }
 745         }
 746         break;
 747 
 748 #endif  // !CA_NO_AU_UI_FEATURES
 749 
 750     case &#39;lrst&#39; : // kAudioUnitProperty_LastRenderedSampleTime
 751         *(Float64*)outData = mCurrentRenderTime.mSampleTime;
 752         break;
 753 
 754     case kAudioUnitProperty_NickName:
 755         // Ownership follows Core Foundation&#39;s &#39;Copy Rule&#39;
 756         if (mNickName) CFRetain(mNickName);
 757         *(CFStringRef*)outData = mNickName;
 758         break;
 759 
 760     default:
 761         result = GetProperty(inID, inScope, inElement, outData);
 762         break;
 763     }
 764     return result;
 765 }
 766 
 767 
 768 //_____________________________________________________________________________
 769 //
 770 OSStatus            AUBase::DispatchSetProperty(    AudioUnitPropertyID             inID,
 771                                                     AudioUnitScope                  inScope,
 772                                                     AudioUnitElement                inElement,
 773                                                     const void *                    inData,
 774                                                     UInt32                          inDataSize)
 775 {
 776     OSStatus result = noErr;
 777 
 778     switch (inID) {
 779     case kAudioUnitProperty_MakeConnection:
 780         ca_require(inDataSize &gt;= sizeof(AudioUnitConnection), InvalidPropertyValue);
 781         {
 782             AudioUnitConnection &amp;connection = *(AudioUnitConnection *)inData;
 783             result = SetConnection(connection);
 784         }
 785         break;
 786 
 787 
 788     case kAudioUnitProperty_SetRenderCallback:
 789         {
 790             ca_require(inDataSize &gt;= sizeof(AURenderCallbackStruct), InvalidPropertyValue);
 791             ca_require(AudioUnitAPIVersion() &gt; 1, InvalidProperty);
 792             AURenderCallbackStruct &amp;callback = *(AURenderCallbackStruct*)inData;
 793             result = SetInputCallback(kAudioUnitProperty_SetRenderCallback, inElement, callback.inputProc, callback.inputProcRefCon);
 794         }
 795         break;
 796 
 797     case kAudioUnitProperty_ElementCount:
 798         ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
 799         ca_require(BusCountWritable(inScope), NotWritable);
 800         result = SetBusCount(inScope, *(UInt32*)inData);
 801         if (result == noErr) {
 802             PropertyChanged(inID, inScope, inElement);
 803         }
 804         break;
 805 
 806     case kAudioUnitProperty_MaximumFramesPerSlice:
 807         ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
 808         result = CanSetMaxFrames();
 809         if (result) return result;
 810         SetMaxFramesPerSlice(*(UInt32 *)inData);
 811         break;
 812 
 813     case kAudioUnitProperty_StreamFormat:
 814         {
 815             if (inDataSize &lt; 36) goto InvalidPropertyValue;
 816             ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
 817 
 818             CAStreamBasicDescription newDesc;
 819                 // now we&#39;re going to be ultra conservative! because of discrepancies between
 820                 // sizes of this struct based on aligment padding inconsistencies
 821             memset (&amp;newDesc, 0, sizeof(newDesc));
 822             memcpy (&amp;newDesc, inData, 36);
 823 
 824             ca_require(SanityCheck(newDesc), InvalidFormat);
 825 
 826             ca_require(ValidFormat(inScope, inElement, newDesc), InvalidFormat);
 827 
 828             const CAStreamBasicDescription curDesc = GetStreamFormat(inScope, inElement);
 829 
 830             if ( !curDesc.IsExactlyEqual(newDesc) ) {
 831                 ca_require(IsStreamFormatWritable(inScope, inElement), NotWritable);
 832                 result = ChangeStreamFormat(inScope, inElement, curDesc, newDesc);
 833             }
 834         }
 835         break;
 836 
 837     case kAudioUnitProperty_SampleRate:
 838         {
 839             ca_require(inDataSize == sizeof(Float64), InvalidPropertyValue);
 840             ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
 841 
 842             const CAStreamBasicDescription curDesc = GetStreamFormat(inScope, inElement);
 843             CAStreamBasicDescription newDesc = curDesc;
 844             newDesc.mSampleRate = *(Float64 *)inData;
 845 
 846             ca_require(ValidFormat(inScope, inElement, newDesc), InvalidFormat);
 847 
 848             if ( !curDesc.IsExactlyEqual(newDesc) ) {
 849                 ca_require(IsStreamFormatWritable(inScope, inElement), NotWritable);
 850                 result = ChangeStreamFormat(inScope, inElement, curDesc, newDesc);
 851             }
 852         }
 853         break;
 854 
 855     case kAudioUnitProperty_AudioChannelLayout:
 856         {
 857             const AudioChannelLayout *layout = static_cast&lt;const AudioChannelLayout *&gt;(inData);
 858             size_t headerSize = sizeof(AudioChannelLayout) - sizeof(AudioChannelDescription);
 859 
 860             ca_require(inDataSize &gt;= headerSize + layout-&gt;mNumberChannelDescriptions * sizeof(AudioChannelDescription), InvalidPropertyValue);
 861             result = SetAudioChannelLayout(inScope, inElement, layout);
 862             if (result == noErr)
 863                 PropertyChanged(inID, inScope, inElement);
 864             break;
 865         }
 866 
 867     case kAudioUnitProperty_ClassInfo:
 868         ca_require(inDataSize == sizeof(CFPropertyListRef *), InvalidPropertyValue);
 869         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 870         result = RestoreState(*(CFPropertyListRef *)inData);
 871         break;
 872 
 873     case kAudioUnitProperty_PresentPreset:
 874 #if !CA_USE_AUDIO_PLUGIN_ONLY
 875 #ifndef __LP64__
 876     case kAudioUnitProperty_CurrentPreset:
 877 #endif
 878 #endif
 879         {
 880             ca_require(inDataSize == sizeof(AUPreset), InvalidPropertyValue);
 881             ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 882             AUPreset &amp; newPreset = *(AUPreset *)inData;
 883 
 884             if (newPreset.presetNumber &gt;= 0)
 885             {
 886                 result = NewFactoryPresetSet(newPreset);
 887                 // NewFactoryPresetSet SHOULD call SetAFactoryPreset if the preset is valid
 888                 // from its own list of preset number-&gt;name
 889                 if (!result)
 890                     PropertyChanged(inID, inScope, inElement);
 891             }
 892             else if (newPreset.presetName)
 893             {
 894                 result = NewCustomPresetSet(newPreset);
 895                 if (!result)
 896                     PropertyChanged(inID, inScope, inElement);
 897             }
 898             else
 899                 result = kAudioUnitErr_InvalidPropertyValue;
 900         }
 901         break;
 902 
 903     case kAudioUnitProperty_ElementName:
 904         {
 905             ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
 906             ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
 907             AUElement * element = GetScope(inScope).GetElement (inElement);
 908             element-&gt;SetName (*(CFStringRef *)inData);
 909             PropertyChanged(inID, inScope, inElement);
 910         }
 911         break;
 912 
 913 #if (MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5) || TARGET_OS_IPHONE
 914     case kAudioUnitProperty_ShouldAllocateBuffer:
 915         {
 916             ca_require((inScope == kAudioUnitScope_Input || inScope == kAudioUnitScope_Output), InvalidScope);
 917             ca_require(GetElement(inScope, inElement) != NULL, InvalidElement);
 918             ca_require(inDataSize == sizeof(UInt32), InvalidPropertyValue);
 919             ca_require(!IsInitialized(), Initialized);
 920 
 921             AUIOElement * element = GetIOElement(inScope, inElement);
 922             element-&gt;SetWillAllocateBuffer(*(UInt32 *)inData != 0);
 923         }
 924         break;
 925 #endif
 926 
 927 #if !CA_NO_AU_HOST_CALLBACKS
 928     case kAudioUnitProperty_HostCallbacks:
 929     {
 930         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 931         UInt32 availSize = std::min(inDataSize, (UInt32)sizeof(HostCallbackInfo));
 932         bool hasChanged = !memcmp (&amp;mHostCallbackInfo, inData, availSize);
 933         memset (&amp;mHostCallbackInfo, 0, sizeof (mHostCallbackInfo));
 934         memcpy (&amp;mHostCallbackInfo, inData, availSize);
 935         if (hasChanged)
 936             PropertyChanged(inID, inScope, inElement);
 937         break;
 938     }
 939 #endif
 940 #if !CA_NO_AU_UI_FEATURES
 941     case kAudioUnitProperty_SetExternalBuffer:
 942         ca_require(inDataSize &gt;= sizeof(AudioUnitExternalBuffer), InvalidPropertyValue);
 943         ca_require(IsInitialized(), Uninitialized);
 944         {
 945             AudioUnitExternalBuffer &amp;buf = *(AudioUnitExternalBuffer*)inData;
 946             if (intptr_t(buf.buffer) &amp; 0x0F) result = kAudio_ParamError;
 947             else if (inScope == kAudioUnitScope_Input) {
 948                 AUInputElement *input = GetInput(inElement);
 949                 input-&gt;UseExternalBuffer(buf);
 950             } else {
 951                 AUOutputElement *output = GetOutput(inElement);
 952                 output-&gt;UseExternalBuffer(buf);
 953             }
 954         }
 955         break;
 956 
 957     case kAudioUnitProperty_ContextName:
 958         {
 959             ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
 960             ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 961             CFStringRef inStr = *(CFStringRef *)inData;
 962             if (mContextName) CFRelease(mContextName);
 963             if (inStr) CFRetain(inStr);
 964             mContextName = inStr;
 965             PropertyChanged(inID, inScope, inElement);
 966         }
 967         break;
 968 
 969 #endif // !CA_NO_AU_UI_FEATURES
 970 
 971     case kAudioUnitProperty_NickName:
 972     {
 973         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
 974         ca_require(inDataSize == sizeof(CFStringRef), InvalidPropertyValue);
 975         CFStringRef inStr = *(CFStringRef *)inData;
 976         if (mNickName) CFRelease(mNickName);
 977         if (inStr) CFRetain(inStr);
 978         mNickName = inStr;
 979         PropertyChanged(inID, inScope, inElement);
 980         break;
 981     }
 982 
 983     default:
 984         result = SetProperty(inID, inScope, inElement, inData, inDataSize);
 985         if (result == noErr)
 986             PropertyChanged(inID, inScope, inElement);
 987 
 988         break;
 989     }
 990     return result;
 991 NotWritable:
 992     return kAudioUnitErr_PropertyNotWritable;
 993 InvalidFormat:
 994     return kAudioUnitErr_FormatNotSupported;
 995 #if !CA_NO_AU_UI_FEATURES
 996 Uninitialized:
 997     return kAudioUnitErr_Uninitialized;
 998 #endif
 999 #if (MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5) || CA_USE_AUDIO_PLUGIN_ONLY
1000 Initialized:
1001     return kAudioUnitErr_Initialized;
1002 #endif
1003 InvalidScope:
1004     return kAudioUnitErr_InvalidScope;
1005 InvalidProperty:
1006     return kAudioUnitErr_InvalidProperty;
1007 InvalidPropertyValue:
1008     return kAudioUnitErr_InvalidPropertyValue;
1009 InvalidElement:
1010     return kAudioUnitErr_InvalidElement;
1011 }
1012 
1013 //_____________________________________________________________________________
1014 //
1015 OSStatus            AUBase::DispatchRemovePropertyValue (AudioUnitPropertyID        inID,
1016                                                     AudioUnitScope                  inScope,
1017                                                     AudioUnitElement                inElement)
1018 {
1019     OSStatus result = noErr;
1020     switch (inID)
1021     {
1022     case kAudioUnitProperty_AudioChannelLayout:
1023     {
1024         result = RemoveAudioChannelLayout(inScope, inElement);
1025         if (result == noErr)
1026             PropertyChanged(inID, inScope, inElement);
1027         break;
1028     }
1029 
1030 #if !CA_NO_AU_HOST_CALLBACKS
1031     case kAudioUnitProperty_HostCallbacks:
1032     {
1033         ca_require(inScope == kAudioUnitScope_Global, InvalidScope);
1034         bool hasValue = false;
1035         void* ptr = &amp;mHostCallbackInfo;
1036         for (unsigned int i = 0; i &lt;  sizeof (HostCallbackInfo); ++i) {
1037             if (static_cast&lt;char*&gt;(ptr)[i]) {
1038                 hasValue = true;
1039                 break;
1040             }
1041         }
1042         if (hasValue) {
1043             memset (&amp;mHostCallbackInfo, 0, sizeof (HostCallbackInfo));
1044             PropertyChanged(inID, inScope, inElement);
1045         }
1046         break;
1047     }
1048 #endif
1049 #if !CA_NO_AU_UI_FEATURES
1050     case kAudioUnitProperty_ContextName:
1051         if (mContextName) CFRelease(mContextName);
1052         mContextName = NULL;
1053         result = noErr;
1054         break;
1055 
1056 #endif // !CA_NO_AU_UI_FEATURES
1057 
1058     case kAudioUnitProperty_NickName:
1059     {
1060         if(inScope == kAudioUnitScope_Global) {
1061             if (mNickName) CFRelease(mNickName);
1062             mNickName = NULL;
1063             PropertyChanged(inID, inScope, inElement);
1064         } else {
1065             result = kAudioUnitErr_InvalidScope;
1066         }
1067         break;
1068     }
1069 
1070     default:
1071         result = RemovePropertyValue (inID, inScope, inElement);
1072         break;
1073     }
1074 
1075     return result;
1076 #if !CA_NO_AU_UI_FEATURES || !CA_NO_AU_HOST_CALLBACKS
1077 InvalidScope:
1078     return kAudioUnitErr_InvalidScope;
1079 #endif
1080 }
1081 
1082 //_____________________________________________________________________________
1083 //
1084 OSStatus            AUBase::GetPropertyInfo(        AudioUnitPropertyID             inID,
1085                                                     AudioUnitScope                  inScope,
1086                                                     AudioUnitElement                inElement,
1087                                                     UInt32 &amp;                        outDataSize,
1088                                                     Boolean &amp;                       outWritable)
1089 {
1090     return kAudioUnitErr_InvalidProperty;
1091 }
1092 
1093 
1094 //_____________________________________________________________________________
1095 //
1096 OSStatus            AUBase::GetProperty(            AudioUnitPropertyID             inID,
1097                                                     AudioUnitScope                  inScope,
1098                                                     AudioUnitElement                inElement,
1099                                                     void *                          outData)
1100 {
1101     return kAudioUnitErr_InvalidProperty;
1102 }
1103 
1104 
1105 //_____________________________________________________________________________
1106 //
1107 OSStatus            AUBase::SetProperty(            AudioUnitPropertyID             inID,
1108                                                     AudioUnitScope                  inScope,
1109                                                     AudioUnitElement                inElement,
1110                                                     const void *                    inData,
1111                                                     UInt32                          inDataSize)
1112 {
1113     return kAudioUnitErr_InvalidProperty;
1114 }
1115 
1116 //_____________________________________________________________________________
1117 //
1118 OSStatus            AUBase::RemovePropertyValue (   AudioUnitPropertyID             inID,
1119                                                     AudioUnitScope                  inScope,
1120                                                     AudioUnitElement                inElement)
1121 {
1122     return kAudioUnitErr_InvalidPropertyValue;
1123 }
1124 
1125 //_____________________________________________________________________________
1126 //
1127 OSStatus            AUBase::AddPropertyListener(    AudioUnitPropertyID             inID,
1128                                                     AudioUnitPropertyListenerProc   inProc,
1129                                                     void *                          inProcRefCon)
1130 {
1131     PropertyListener pl;
1132 
1133     pl.propertyID = inID;
1134     pl.listenerProc = inProc;
1135     pl.listenerRefCon = inProcRefCon;
1136 
1137     if (mPropertyListeners.empty())
1138         mPropertyListeners.reserve(32);
1139     mPropertyListeners.push_back(pl);
1140 
1141     return noErr;
1142 }
1143 
1144 //_____________________________________________________________________________
1145 //
1146 OSStatus            AUBase::RemovePropertyListener(     AudioUnitPropertyID             inID,
1147                                                         AudioUnitPropertyListenerProc   inProc,
1148                                                         void *                          inProcRefCon,
1149                                                         bool                            refConSpecified)
1150 {
1151     // iterate in reverse so that it&#39;s safe to erase in the middle of the vector
1152     for (int i = (int)mPropertyListeners.size(); --i &gt;=0; ) {
1153         PropertyListeners::iterator it = mPropertyListeners.begin() + i;
1154         if ((*it).propertyID == inID &amp;&amp; (*it).listenerProc == inProc &amp;&amp; (!refConSpecified || (*it).listenerRefCon == inProcRefCon))
1155             mPropertyListeners.erase(it);
1156     }
1157     return noErr;
1158 }
1159 
1160 //_____________________________________________________________________________
1161 //
1162 void                AUBase::PropertyChanged(            AudioUnitPropertyID             inID,
1163                                                         AudioUnitScope                  inScope,
1164                                                         AudioUnitElement                inElement)
1165 {
1166     for (PropertyListeners::iterator it = mPropertyListeners.begin(); it != mPropertyListeners.end(); ++it)
1167         if ((*it).propertyID == inID)
1168             ((*it).listenerProc)((*it).listenerRefCon, mComponentInstance, inID, inScope, inElement);
1169 }
1170 
1171 //_____________________________________________________________________________
1172 //
1173 OSStatus            AUBase::SetRenderNotification(  AURenderCallback                inProc,
1174                                                     void *                          inRefCon)
1175 {
1176     if (inProc == NULL)
1177         return kAudio_ParamError;
1178 
1179     mRenderCallbacksTouched = true;
1180     mRenderCallbacks.deferred_add(RenderCallback(inProc, inRefCon));
1181             // this will do nothing if it&#39;s already in the list
1182     return noErr;
1183 }
1184 
1185 //_____________________________________________________________________________
1186 //
1187 OSStatus            AUBase::RemoveRenderNotification(   AURenderCallback            inProc,
1188                                                         void *                      inRefCon)
1189 {
1190     mRenderCallbacks.deferred_remove(RenderCallback(inProc, inRefCon));
1191     return noErr;   // error?
1192 }
1193 
1194 //_____________________________________________________________________________
1195 //
1196 OSStatus    AUBase::GetParameter(           AudioUnitParameterID            inID,
1197                                                     AudioUnitScope                  inScope,
1198                                                     AudioUnitElement                inElement,
1199                                                     AudioUnitParameterValue &amp;       outValue)
1200 {
1201     AUElement *elem = SafeGetElement(inScope, inElement);
1202     outValue = elem-&gt;GetParameter(inID);
1203     return noErr;
1204 }
1205 
1206 
1207 //_____________________________________________________________________________
1208 //
1209 OSStatus    AUBase::SetParameter(           AudioUnitParameterID            inID,
1210                                                     AudioUnitScope                  inScope,
1211                                                     AudioUnitElement                inElement,
1212                                                     AudioUnitParameterValue         inValue,
1213                                                     UInt32                          inBufferOffsetInFrames)
1214 {
1215     AUElement *elem = SafeGetElement(inScope, inElement);
1216     elem-&gt;SetParameter(inID, inValue);
1217     return noErr;
1218 }
1219 
1220 //_____________________________________________________________________________
1221 //
1222 OSStatus    AUBase::ScheduleParameter ( const AudioUnitParameterEvent       *inParameterEvent,
1223                                                     UInt32                          inNumEvents)
1224 {
1225     bool canScheduleParameters = CanScheduleParameters();
1226 
1227     for (UInt32 i = 0; i &lt; inNumEvents; ++i)
1228     {
1229         if (inParameterEvent[i].eventType == kParameterEvent_Immediate)
1230         {
1231             SetParameter (inParameterEvent[i].parameter,
1232                             inParameterEvent[i].scope,
1233                             inParameterEvent[i].element,
1234                             inParameterEvent[i].eventValues.immediate.value,
1235                             inParameterEvent[i].eventValues.immediate.bufferOffset);
1236         }
1237         if (canScheduleParameters) {
1238             mParamList.push_back (inParameterEvent[i]);
1239         }
1240     }
1241 
1242     return noErr;
1243 }
1244 
1245 // ____________________________________________________________________________
1246 //
1247 static bool SortParameterEventList(const AudioUnitParameterEvent &amp;ev1, const AudioUnitParameterEvent &amp;ev2 )
1248 {
1249     int offset1 = ev1.eventType == kParameterEvent_Immediate ?  ev1.eventValues.immediate.bufferOffset : ev1.eventValues.ramp.startBufferOffset;
1250     int offset2 = ev2.eventType == kParameterEvent_Immediate ?  ev2.eventValues.immediate.bufferOffset : ev2.eventValues.ramp.startBufferOffset;
1251 
1252     if(offset1 &lt; offset2) return true;
1253     return false;
1254 }
1255 
1256 
1257 // ____________________________________________________________________________
1258 //
1259 OSStatus    AUBase::ProcessForScheduledParams(  ParameterEventList      &amp;inParamList,
1260                                                         UInt32                  inFramesToProcess,
1261                                                         void                    *inUserData )
1262 {
1263     OSStatus result = noErr;
1264 
1265     int totalFramesToProcess = inFramesToProcess;
1266 
1267     int framesRemaining = totalFramesToProcess;
1268 
1269     unsigned int currentStartFrame = 0; // start of the whole buffer
1270 
1271 
1272 
1273     // sort the ParameterEventList by startBufferOffset
1274     std::sort(inParamList.begin(), inParamList.end(), SortParameterEventList);
1275 
1276     ParameterEventList::iterator iter = inParamList.begin();
1277 
1278 
1279     while(framesRemaining &gt; 0 )
1280     {
1281         // first of all, go through the ramped automation events and find out where the next
1282         // division of our whole buffer will be
1283 
1284         int currentEndFrame = totalFramesToProcess; // start out assuming we&#39;ll process all the way to
1285                                                     // the end of the buffer
1286 
1287         iter = inParamList.begin();
1288 
1289         // find the next break point
1290         while(iter != inParamList.end() )
1291         {
1292             AudioUnitParameterEvent &amp;event = *iter;
1293 
1294             int offset = event.eventType == kParameterEvent_Immediate ?  event.eventValues.immediate.bufferOffset : event.eventValues.ramp.startBufferOffset;
1295 
1296             if(offset &gt; (int)currentStartFrame &amp;&amp; offset &lt; currentEndFrame )
1297             {
1298                 currentEndFrame = offset;
1299                 break;
1300             }
1301 
1302             // consider ramp end to be a possible choice (there may be gaps in the supplied ramp events)
1303             if(event.eventType == kParameterEvent_Ramped )
1304             {
1305                 offset = event.eventValues.ramp.startBufferOffset + event.eventValues.ramp.durationInFrames;
1306 
1307                 if(offset &gt; (int)currentStartFrame &amp;&amp; offset &lt; currentEndFrame )
1308                 {
1309                     currentEndFrame = offset;
1310                 }
1311             }
1312 
1313             iter++;
1314         }
1315 
1316         int framesThisTime = currentEndFrame - currentStartFrame;
1317 
1318         // next, setup the parameter maps to be current for the ramp parameters active during
1319         // this time segment...
1320 
1321         for(ParameterEventList::iterator iter2 = inParamList.begin(); iter2 != inParamList.end(); iter2++ )
1322         {
1323             AudioUnitParameterEvent &amp;event = *iter2;
1324 
1325             bool eventFallsInSlice;
1326 
1327 
1328             if(event.eventType == kParameterEvent_Ramped)
1329                 eventFallsInSlice = event.eventValues.ramp.startBufferOffset &lt; currentEndFrame
1330                     &amp;&amp; event.eventValues.ramp.startBufferOffset + event.eventValues.ramp.durationInFrames &gt; currentStartFrame;
1331             else /* kParameterEvent_Immediate */
1332                 // actually, for the same parameter, there may be future immediate events which override this one,
1333                 // but it&#39;s OK since the event list is sorted in time order, we&#39;re guaranteed to end up with the current one
1334                 eventFallsInSlice = event.eventValues.immediate.bufferOffset &lt;= currentStartFrame;
1335 
1336             if(eventFallsInSlice)
1337             {
1338                 AUElement *element = GetElement(event.scope, event.element );
1339 
1340                 if(element) element-&gt;SetScheduledEvent( event.parameter,
1341                                                         event,
1342                                                         currentStartFrame,
1343                                                         currentEndFrame - currentStartFrame );
1344             }
1345         }
1346 
1347 
1348 
1349         // Finally, actually do the processing for this slice.....
1350 
1351         result = ProcessScheduledSlice( inUserData,
1352                                         currentStartFrame,
1353                                         framesThisTime,
1354                                         inFramesToProcess );
1355 
1356         if(result != noErr) break;
1357 
1358         framesRemaining -= framesThisTime;
1359         currentStartFrame = currentEndFrame;    // now start from where we left off last time
1360     }
1361 
1362     return result;
1363 }
1364 
1365 //_____________________________________________________________________________
1366 //
1367 void                AUBase::SetWantsRenderThreadID (bool inFlag)
1368 {
1369     if (inFlag == mWantsRenderThreadID)
1370         return;
1371 
1372     mWantsRenderThreadID = inFlag;
1373     if (!mWantsRenderThreadID)
1374         mRenderThreadID = NULL;
1375 }
1376 
1377 //_____________________________________________________________________________
1378 //
1379 
1380 //_____________________________________________________________________________
1381 //
1382 OSStatus            AUBase::DoRender(       AudioUnitRenderActionFlags &amp;    ioActionFlags,
1383                                             const AudioTimeStamp &amp;          inTimeStamp,
1384                                             UInt32                          inBusNumber,
1385                                             UInt32                          inFramesToProcess,
1386                                             AudioBufferList &amp;               ioData)
1387 {
1388     OSStatus theError;
1389     RenderCallbackList::iterator rcit;
1390 
1391     AUTRACE(kCATrace_AUBaseRenderStart, mComponentInstance, (uintptr_t)this, inBusNumber, inFramesToProcess, (uintptr_t)ioData.mBuffers[0].mData);
1392     DISABLE_DENORMALS
1393 
1394     try {
1395         ca_require(IsInitialized(), Uninitialized);
1396         ca_require(mAudioUnitAPIVersion &gt;= 2, ParamErr);
1397         if (inFramesToProcess &gt; mMaxFramesPerSlice) {
1398             static UInt64 lastTimeMessagePrinted = 0;
1399             UInt64 now = CAHostTimeBase::GetCurrentTime();
1400             if (now - lastTimeMessagePrinted &gt; CAHostTimeBase::GetFrequency()) { // not more than once per second.
1401                 lastTimeMessagePrinted = now;
1402                 syslog(LOG_ERR, &quot;kAudioUnitErr_TooManyFramesToProcess : inFramesToProcess=%u, mMaxFramesPerSlice=%u&quot;, (unsigned)inFramesToProcess, (unsigned)mMaxFramesPerSlice);
1403                 DebugMessageN4(&quot;%s:%d inFramesToProcess=%u, mMaxFramesPerSlice=%u; TooManyFrames&quot;, __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)mMaxFramesPerSlice);
1404             }
1405             goto TooManyFrames;
1406         }
1407         ca_require (!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
1408 
1409         AUOutputElement *output = GetOutput(inBusNumber);   // will throw if non-existant
1410         if (output-&gt;GetStreamFormat().NumberChannelStreams() != ioData.mNumberBuffers) {
1411             DebugMessageN4(&quot;%s:%d ioData.mNumberBuffers=%u, output-&gt;GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError&quot;,
1412                 __FILE__, __LINE__, (unsigned)ioData.mNumberBuffers, (unsigned)output-&gt;GetStreamFormat().NumberChannelStreams());
1413             goto ParamErr;
1414         }
1415 
1416         unsigned expectedBufferByteSize = inFramesToProcess * output-&gt;GetStreamFormat().mBytesPerFrame;
1417         for (unsigned ibuf = 0; ibuf &lt; ioData.mNumberBuffers; ++ibuf) {
1418             AudioBuffer &amp;buf = ioData.mBuffers[ibuf];
1419             if (buf.mData != NULL) {
1420                 // only care about the size if the buffer is non-null
1421                 if (buf.mDataByteSize &lt; expectedBufferByteSize) {
1422                     // if the buffer is too small, we cannot render safely. kAudio_ParamError.
1423                     DebugMessageN7(&quot;%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError&quot;,
1424                         __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)output-&gt;GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibuf, (unsigned)buf.mDataByteSize);
1425                     goto ParamErr;
1426                 }
1427                 // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
1428                 // We will generally set the buffer size at the end of rendering, before we return.
1429                 // However we should ensure that no one, DURING rendering, READS a
1430                 // potentially incorrect size. This can lead to doing too much work, or
1431                 // reading past the end of an input buffer into unmapped memory.
1432                 buf.mDataByteSize = expectedBufferByteSize;
1433             }
1434         }
1435 
1436         if (WantsRenderThreadID())
1437         {
1438             #if TARGET_OS_MAC
1439                 mRenderThreadID = pthread_self();
1440             #elif TARGET_OS_WIN32
1441                 mRenderThreadID = GetCurrentThreadId();
1442             #endif
1443         }
1444 
1445         AudioUnitRenderActionFlags flags;
1446         if (mRenderCallbacksTouched) {
1447             mRenderCallbacks.update();
1448             flags = ioActionFlags | kAudioUnitRenderAction_PreRender;
1449             for (rcit = mRenderCallbacks.begin(); rcit != mRenderCallbacks.end(); ++rcit) {
1450                 RenderCallback &amp;rc = *rcit;
1451                 AUTRACE(kCATrace_AUBaseRenderCallbackStart, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 1, 0);
1452                 (*(AURenderCallback)rc.mRenderNotify)(rc.mRenderNotifyRefCon,
1453                                 &amp;flags,
1454                                 &amp;inTimeStamp, inBusNumber, inFramesToProcess, &amp;ioData);
1455                 AUTRACE(kCATrace_AUBaseRenderCallbackEnd, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 1, 0);
1456             }
1457         }
1458 
1459         theError = DoRenderBus(ioActionFlags, inTimeStamp, inBusNumber, output, inFramesToProcess, ioData);
1460 
1461         if (mRenderCallbacksTouched) {
1462             flags = ioActionFlags | kAudioUnitRenderAction_PostRender;
1463 
1464             if (SetRenderError (theError)) {
1465                 flags |= kAudioUnitRenderAction_PostRenderError;
1466             }
1467 
1468             for (rcit = mRenderCallbacks.begin(); rcit != mRenderCallbacks.end(); ++rcit) {
1469                 RenderCallback &amp;rc = *rcit;
1470                 AUTRACE(kCATrace_AUBaseRenderCallbackStart, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 2, 0);
1471                 (*(AURenderCallback)rc.mRenderNotify)(rc.mRenderNotifyRefCon,
1472                                 &amp;flags,
1473                                 &amp;inTimeStamp, inBusNumber, inFramesToProcess, &amp;ioData);
1474                 AUTRACE(kCATrace_AUBaseRenderCallbackEnd, mComponentInstance, (intptr_t)this, (intptr_t)rc.mRenderNotify, 2, 0);
1475             }
1476         }
1477 
1478         // The vector&#39;s being emptied
1479         // because these events should only apply to this Render cycle, so anything
1480         // left over is from a preceding cycle and should be dumped.  New scheduled
1481         // parameters must be scheduled from the next pre-render callback.
1482         if (!mParamList.empty())
1483             mParamList.clear();
1484 
1485     }
1486     catch (OSStatus err) {
1487         theError = err;
1488         goto errexit;
1489     }
1490     catch (...) {
1491         theError = -1;
1492         goto errexit;
1493     }
1494 done:
1495     RESTORE_DENORMALS
1496     AUTRACE(kCATrace_AUBaseRenderEnd, mComponentInstance, (intptr_t)this, theError, ioActionFlags, CATrace_ablData(ioData));
1497 
1498     return theError;
1499 
1500 Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
1501 ParamErr:       theError = kAudio_ParamError;                       goto errexit;
1502 TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
1503 errexit:
1504     DebugMessageN2 (&quot;  from %s, render err: %d&quot;, GetLoggingString(), (int)theError);
1505     SetRenderError(theError);
1506     goto done;
1507 }
1508 
1509 //_____________________________________________________________________________
1510 //
1511 OSStatus    AUBase::DoProcess ( AudioUnitRenderActionFlags  &amp;       ioActionFlags,
1512                                 const AudioTimeStamp &amp;              inTimeStamp,
1513                                 UInt32                              inFramesToProcess,
1514                                 AudioBufferList &amp;                   ioData)
1515 {
1516     OSStatus theError;
1517     AUTRACE(kCATrace_AUBaseRenderStart, mComponentInstance, (intptr_t)this, -1, inFramesToProcess, 0);
1518     DISABLE_DENORMALS
1519 
1520     try {
1521 
1522         if (!(ioActionFlags &amp; (1 &lt;&lt; 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)) {
1523             ca_require(IsInitialized(), Uninitialized);
1524             ca_require(inFramesToProcess &lt;= mMaxFramesPerSlice, TooManyFrames);
1525             ca_require(!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
1526 
1527             AUInputElement *input = GetInput(0);    // will throw if non-existant
1528             if (input-&gt;GetStreamFormat().NumberChannelStreams() != ioData.mNumberBuffers) {
1529                 DebugMessageN4(&quot;%s:%d ioData.mNumberBuffers=%u, input-&gt;GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError&quot;,
1530                     __FILE__, __LINE__, (unsigned)ioData.mNumberBuffers, (unsigned)input-&gt;GetStreamFormat().NumberChannelStreams());
1531                 goto ParamErr;
1532             }
1533 
1534             unsigned expectedBufferByteSize = inFramesToProcess * input-&gt;GetStreamFormat().mBytesPerFrame;
1535             for (unsigned ibuf = 0; ibuf &lt; ioData.mNumberBuffers; ++ibuf) {
1536                 AudioBuffer &amp;buf = ioData.mBuffers[ibuf];
1537                 if (buf.mData != NULL) {
1538                     // only care about the size if the buffer is non-null
1539                     if (buf.mDataByteSize &lt; expectedBufferByteSize) {
1540                         // if the buffer is too small, we cannot render safely. kAudio_ParamError.
1541                         DebugMessageN7(&quot;%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioData.mBuffers[%u].mDataByteSize=%u; kAudio_ParamError&quot;,
1542                             __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)input-&gt;GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibuf, (unsigned)buf.mDataByteSize);
1543                         goto ParamErr;
1544                     }
1545                     // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
1546                     // We will generally set the buffer size at the end of rendering, before we return.
1547                     // However we should ensure that no one, DURING rendering, READS a
1548                     // potentially incorrect size. This can lead to doing too much work, or
1549                     // reading past the end of an input buffer into unmapped memory.
1550                     buf.mDataByteSize = expectedBufferByteSize;
1551                 }
1552             }
1553         }
1554 
1555         if (WantsRenderThreadID())
1556         {
1557             #if TARGET_OS_MAC
1558                 mRenderThreadID = pthread_self();
1559             #elif TARGET_OS_WIN32
1560                 mRenderThreadID = GetCurrentThreadId();
1561             #endif
1562         }
1563 
1564         if (NeedsToRender (inTimeStamp)) {
1565             theError = ProcessBufferLists (ioActionFlags, ioData, ioData, inFramesToProcess);
1566         } else
1567             theError = noErr;
1568 
1569     }
1570     catch (OSStatus err) {
1571         theError = err;
1572         goto errexit;
1573     }
1574     catch (...) {
1575         theError = -1;
1576         goto errexit;
1577     }
1578 done:
1579     RESTORE_DENORMALS
1580     AUTRACE(kCATrace_AUBaseRenderEnd, mComponentInstance, (intptr_t)this, theError, ioActionFlags, CATrace_ablData(ioData));
1581 
1582     return theError;
1583 
1584 Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
1585 ParamErr:       theError = kAudio_ParamError;                       goto errexit;
1586 TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
1587 errexit:
1588     DebugMessageN2 (&quot;  from %s, process err: %d&quot;, GetLoggingString(), (int)theError);
1589     SetRenderError(theError);
1590     goto done;
1591 }
1592 
1593 OSStatus    AUBase::DoProcessMultiple ( AudioUnitRenderActionFlags  &amp; ioActionFlags,
1594                                const AudioTimeStamp &amp;               inTimeStamp,
1595                                UInt32                               inFramesToProcess,
1596                                UInt32                               inNumberInputBufferLists,
1597                                const AudioBufferList **             inInputBufferLists,
1598                                UInt32                               inNumberOutputBufferLists,
1599                                AudioBufferList **                   ioOutputBufferLists)
1600 {
1601     OSStatus theError;
1602     DISABLE_DENORMALS
1603 
1604     try {
1605 
1606         if (!(ioActionFlags &amp; (1 &lt;&lt; 9)/*kAudioUnitRenderAction_DoNotCheckRenderArgs*/)) {
1607             ca_require(IsInitialized(), Uninitialized);
1608             ca_require(inFramesToProcess &lt;= mMaxFramesPerSlice, TooManyFrames);
1609             ca_require (!UsesFixedBlockSize() || inFramesToProcess == GetMaxFramesPerSlice(), ParamErr);
1610 
1611             for (unsigned ibl = 0; ibl &lt; inNumberInputBufferLists; ++ibl) {
1612                 if (inInputBufferLists[ibl] != NULL) {
1613                     AUInputElement *input = GetInput(ibl);  // will throw if non-existant
1614                     unsigned expectedBufferByteSize = inFramesToProcess * input-&gt;GetStreamFormat().mBytesPerFrame;
1615 
1616                     if (input-&gt;GetStreamFormat().NumberChannelStreams() != inInputBufferLists[ibl]-&gt;mNumberBuffers) {
1617                         DebugMessageN5(&quot;%s:%d inInputBufferLists[%u]-&gt;mNumberBuffers=%u, input-&gt;GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError&quot;,
1618                                        __FILE__, __LINE__, ibl, (unsigned)inInputBufferLists[ibl]-&gt;mNumberBuffers, (unsigned)input-&gt;GetStreamFormat().NumberChannelStreams());
1619                         goto ParamErr;
1620                     }
1621 
1622                     for (unsigned ibuf = 0; ibuf &lt; inInputBufferLists[ibl]-&gt;mNumberBuffers; ++ibuf) {
1623                         const AudioBuffer &amp;buf = inInputBufferLists[ibl]-&gt;mBuffers[ibuf];
1624                         if (buf.mData != NULL) {
1625                             if (buf.mDataByteSize &lt; expectedBufferByteSize) {
1626                                 // the buffer is too small
1627                                 DebugMessageN8(&quot;%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; inInputBufferLists[%u].mBuffers[%u].mDataByteSize=%u; kAudio_ParamError&quot;,
1628                                                __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)input-&gt;GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, ibl, ibuf, (unsigned)buf.mDataByteSize);
1629                                 goto ParamErr;
1630                             }
1631                         } else {
1632                             // the buffer must exist
1633                             goto ParamErr;
1634                         }
1635                     }
1636                 } else {
1637                     // skip NULL input audio buffer list
1638                 }
1639             }
1640 
1641             for (unsigned obl = 0; obl &lt; inNumberOutputBufferLists; ++obl) {
1642                 if (ioOutputBufferLists[obl] != NULL) {
1643                     AUOutputElement *output = GetOutput(obl);   // will throw if non-existant
1644                     unsigned expectedBufferByteSize = inFramesToProcess * output-&gt;GetStreamFormat().mBytesPerFrame;
1645 
1646                     if (output-&gt;GetStreamFormat().NumberChannelStreams() != ioOutputBufferLists[obl]-&gt;mNumberBuffers) {
1647                         DebugMessageN5(&quot;%s:%d ioOutputBufferLists[%u]-&gt;mNumberBuffers=%u, output-&gt;GetStreamFormat().NumberChannelStreams()=%u; kAudio_ParamError&quot;,
1648                                        __FILE__, __LINE__, obl, (unsigned)ioOutputBufferLists[obl]-&gt;mNumberBuffers, (unsigned)output-&gt;GetStreamFormat().NumberChannelStreams());
1649                         goto ParamErr;
1650                     }
1651 
1652                     for (unsigned obuf = 0; obuf &lt; ioOutputBufferLists[obl]-&gt;mNumberBuffers; ++obuf) {
1653                         AudioBuffer &amp;buf = ioOutputBufferLists[obl]-&gt;mBuffers[obuf];
1654                         if (buf.mData != NULL) {
1655                             // only care about the size if the buffer is non-null
1656                             if (buf.mDataByteSize &lt; expectedBufferByteSize) {
1657                                 // if the buffer is too small, we cannot render safely. kAudio_ParamError.
1658                                 DebugMessageN8(&quot;%s:%d %u frames, %u bytes/frame, expected %u-byte buffer; ioOutputBufferLists[%u]-&gt;mBuffers[%u].mDataByteSize=%u; kAudio_ParamError&quot;,
1659                                                __FILE__, __LINE__, (unsigned)inFramesToProcess, (unsigned)output-&gt;GetStreamFormat().mBytesPerFrame, expectedBufferByteSize, obl, obuf, (unsigned)buf.mDataByteSize);
1660                                 goto ParamErr;
1661                             }
1662                             // Some clients incorrectly pass bigger buffers than expectedBufferByteSize.
1663                             // We will generally set the buffer size at the end of rendering, before we return.
1664                             // However we should ensure that no one, DURING rendering, READS a
1665                             // potentially incorrect size. This can lead to doing too much work, or
1666                             // reading past the end of an input buffer into unmapped memory.
1667                             buf.mDataByteSize = expectedBufferByteSize;
1668                         }
1669                     }
1670                 } else {
1671                     // skip NULL output audio buffer list
1672                 }
1673             }
1674         }
1675 
1676         if (WantsRenderThreadID())
1677         {
1678 #if TARGET_OS_MAC
1679             mRenderThreadID = pthread_self();
1680 #elif TARGET_OS_WIN32
1681             mRenderThreadID = GetCurrentThreadId();
1682 #endif
1683         }
1684 
1685         if (NeedsToRender (inTimeStamp)) {
1686             theError = ProcessMultipleBufferLists (ioActionFlags, inFramesToProcess, inNumberInputBufferLists, inInputBufferLists, inNumberOutputBufferLists, ioOutputBufferLists);
1687         } else
1688             theError = noErr;
1689     }
1690     catch (OSStatus err) {
1691         theError = err;
1692         goto errexit;
1693     }
1694     catch (...) {
1695         theError = -1;
1696         goto errexit;
1697     }
1698 done:
1699     RESTORE_DENORMALS
1700 
1701     return theError;
1702 
1703 Uninitialized:  theError = kAudioUnitErr_Uninitialized;             goto errexit;
1704 ParamErr:       theError = kAudio_ParamError;                       goto errexit;
1705 TooManyFrames:  theError = kAudioUnitErr_TooManyFramesToProcess;    goto errexit;
1706 errexit:
1707     DebugMessageN2 (&quot;  from %s, processmultiple err: %d&quot;, GetLoggingString(), (int)theError);
1708     SetRenderError(theError);
1709     goto done;
1710 }
1711 
1712 //_____________________________________________________________________________
1713 //
1714 OSStatus            AUBase::SetInputCallback(       UInt32                          inPropertyID,
1715                                                     AudioUnitElement                inElement,
1716                                                     AURenderCallback                inProc,
1717                                                     void *                          inRefCon)
1718 {
1719     AUInputElement *input = GetInput(inElement);    // may throw
1720 
1721     input-&gt;SetInputCallback(inProc, inRefCon);
1722     PropertyChanged(inPropertyID, kAudioUnitScope_Input, inElement);
1723 
1724     return noErr;
1725 }
1726 
1727 //_____________________________________________________________________________
1728 //
1729 OSStatus            AUBase::SetConnection(          const AudioUnitConnection &amp;     inConnection)
1730 {
1731 
1732     OSStatus err;
1733     AUInputElement *input = GetInput(inConnection.destInputNumber); // may throw
1734 
1735     if (inConnection.sourceAudioUnit) {
1736         // connecting, not disconnecting
1737         CAStreamBasicDescription sourceDesc;
1738         UInt32 size = sizeof(CAStreamBasicDescription);
1739         ca_require_noerr(err = AudioUnitGetProperty(
1740                                         inConnection.sourceAudioUnit,
1741                                         kAudioUnitProperty_StreamFormat,
1742                                         kAudioUnitScope_Output,
1743                                         inConnection.sourceOutputNumber,
1744                                         &amp;sourceDesc,
1745                                         &amp;size), errexit);
1746         ca_require_noerr(err = DispatchSetProperty (kAudioUnitProperty_StreamFormat,
1747                                 kAudioUnitScope_Input, inConnection.destInputNumber,
1748                                 &amp;sourceDesc, sizeof(CAStreamBasicDescription)), errexit);
1749     }
1750     input-&gt;SetConnection(inConnection);
1751 
1752     PropertyChanged(kAudioUnitProperty_MakeConnection, kAudioUnitScope_Input, inConnection.destInputNumber);
1753     return noErr;
1754 
1755 errexit:
1756     return err;
1757 }
1758 
1759 //_____________________________________________________________________________
1760 //
1761 UInt32              AUBase::SupportedNumChannels (  const AUChannelInfo**           outInfo)
1762 {
1763     return 0;
1764 }
1765 
1766 //_____________________________________________________________________________
1767 //
1768 bool                AUBase::ValidFormat(            AudioUnitScope                  inScope,
1769                                                     AudioUnitElement                inElement,
1770                                                     const CAStreamBasicDescription &amp;        inNewFormat)
1771 {
1772     bool isInterleaved = false;
1773 
1774     return inNewFormat.IsCommonFloat32(&amp;isInterleaved) &amp;&amp; !isInterleaved;
1775 }
1776 
1777 //_____________________________________________________________________________
1778 //
1779 bool                AUBase::IsStreamFormatWritable( AudioUnitScope                  scope,
1780                                                     AudioUnitElement                element)
1781 {
1782     switch (scope) {
1783     case kAudioUnitScope_Input:
1784         {
1785             AUInputElement *input = GetInput(element);
1786             if (input-&gt;HasConnection()) return false;   // can&#39;t write format when input comes from connection
1787         }
1788         // ... fall ...
1789     case kAudioUnitScope_Output:
1790         return StreamFormatWritable(scope, element);
1791 
1792 //#warning &quot;aliasing of global scope format should be pushed to subclasses&quot;
1793     case kAudioUnitScope_Global:
1794         return StreamFormatWritable(kAudioUnitScope_Output, 0);
1795     }
1796     return false;
1797 }
1798 
1799 //_____________________________________________________________________________
1800 //
1801 const CAStreamBasicDescription &amp;
1802                     AUBase::GetStreamFormat(        AudioUnitScope                  inScope,
1803                                                     AudioUnitElement                inElement)
1804 {
1805 //#warning &quot;aliasing of global scope format should be pushed to subclasses&quot;
1806     AUIOElement *element;
1807 
1808     switch (inScope) {
1809     case kAudioUnitScope_Input:
1810         element = Inputs().GetIOElement(inElement);
1811         break;
1812     case kAudioUnitScope_Output:
1813         element = Outputs().GetIOElement(inElement);
1814         break;
1815     case kAudioUnitScope_Global:    // global stream description is an alias for that of output 0
1816         element = Outputs().GetIOElement(0);
1817         break;
1818     default:
1819         COMPONENT_THROW(kAudioUnitErr_InvalidScope);
1820     }
1821     return element-&gt;GetStreamFormat();
1822 }
1823 
1824 OSStatus            AUBase::SetBusCount(    AudioUnitScope                  inScope,
1825                                             UInt32                          inCount)
1826 {
1827     if (IsInitialized())
1828         return kAudioUnitErr_Initialized;
1829 
1830     GetScope(inScope).SetNumberOfElements(inCount);
1831     return noErr;
1832 }
1833 
1834 //_____________________________________________________________________________
1835 //
1836 OSStatus            AUBase::ChangeStreamFormat(     AudioUnitScope                  inScope,
1837                                                     AudioUnitElement                inElement,
1838                                                     const CAStreamBasicDescription &amp; inPrevFormat,
1839                                                     const CAStreamBasicDescription &amp; inNewFormat)
1840 {
1841     if (inNewFormat.IsExactlyEqual(inPrevFormat))
1842         return noErr;
1843 
1844 //#warning &quot;aliasing of global scope format should be pushed to subclasses&quot;
1845     AUIOElement *element;
1846 
1847     switch (inScope) {
1848     case kAudioUnitScope_Input:
1849         element = Inputs().GetIOElement(inElement);
1850         break;
1851     case kAudioUnitScope_Output:
1852         element = Outputs().GetIOElement(inElement);
1853         break;
1854     case kAudioUnitScope_Global:
1855         element = Outputs().GetIOElement(0);
1856         break;
1857     default:
1858         COMPONENT_THROW(kAudioUnitErr_InvalidScope);
1859     }
1860     element-&gt;SetStreamFormat(inNewFormat);
1861     PropertyChanged(kAudioUnitProperty_StreamFormat, inScope, inElement);
1862     return noErr;
1863 }
1864 
1865 UInt32      AUBase::GetChannelLayoutTags(   AudioUnitScope              inScope,
1866                                             AudioUnitElement            inElement,
1867                                             AudioChannelLayoutTag *     outLayoutTags)
1868 {
1869     return GetIOElement(inScope, inElement)-&gt;GetChannelLayoutTags(outLayoutTags);
1870 }
1871 
1872 UInt32      AUBase::GetAudioChannelLayout(  AudioUnitScope              scope,
1873                                             AudioUnitElement            element,
1874                                             AudioChannelLayout *        outLayoutPtr,
1875                                             Boolean &amp;                   outWritable)
1876 {
1877     AUIOElement * el = GetIOElement(scope, element);
1878     return el-&gt;GetAudioChannelLayout(outLayoutPtr, outWritable);
1879 }
1880 
1881 OSStatus    AUBase::RemoveAudioChannelLayout(           AudioUnitScope              inScope,
1882                                                         AudioUnitElement            inElement)
1883 {
1884     OSStatus result = noErr;
1885     AUIOElement * el = GetIOElement(inScope, inElement);
1886     Boolean writable;
1887     if (el-&gt;GetAudioChannelLayout(NULL, writable)) {
1888         result = el-&gt;RemoveAudioChannelLayout();
1889     }
1890     return result;
1891 }
1892 
1893 OSStatus    AUBase::SetAudioChannelLayout(              AudioUnitScope              inScope,
1894                                                         AudioUnitElement            inElement,
1895                                                         const AudioChannelLayout *  inLayout)
1896 {
1897     AUIOElement* ioEl = GetIOElement (inScope, inElement);
1898 
1899     // the num channels of the layout HAS TO MATCH the current channels of the Element&#39;s stream format
1900     UInt32 currentChannels = ioEl-&gt;GetStreamFormat().NumberChannels();
1901     UInt32 numChannelsInLayout = CAAudioChannelLayout::NumberChannels(*inLayout);
1902     if (currentChannels != numChannelsInLayout)
1903         return kAudioUnitErr_InvalidPropertyValue;
1904 
1905     UInt32 numLayouts = GetChannelLayoutTags (inScope, inElement, NULL);
1906     if (numLayouts == 0)
1907         return kAudioUnitErr_InvalidProperty;
1908     AudioChannelLayoutTag *tags = (AudioChannelLayoutTag *)CA_malloc (numLayouts * sizeof (AudioChannelLayoutTag));
1909     GetChannelLayoutTags (inScope, inElement, tags);
1910     bool foundTag = false;
1911     for (unsigned int i = 0; i &lt; numLayouts; ++i) {
1912         if (tags[i] == inLayout-&gt;mChannelLayoutTag || tags[i] == kAudioChannelLayoutTag_UseChannelDescriptions) {
1913             foundTag = true;
1914             break;
1915         }
1916     }
1917     free(tags);
1918 
1919     if (foundTag == false)
1920         return kAudioUnitErr_InvalidPropertyValue;
1921 
1922     return ioEl-&gt;SetAudioChannelLayout(*inLayout);
1923 }
1924 
1925 static void AddNumToDictionary (CFMutableDictionaryRef dict, CFStringRef key, SInt32 value)
1926 {
1927     CFNumberRef num = CFNumberCreate (NULL, kCFNumberSInt32Type, &amp;value);
1928     CFDictionarySetValue (dict, key, num);
1929     CFRelease (num);
1930 }
1931 
1932 #define kCurrentSavedStateVersion 0
1933 
1934 OSStatus            AUBase::SaveState(      CFPropertyListRef * outData)
1935 {
1936     AudioComponentDescription desc = GetComponentDescription();
1937 
1938     CFMutableDictionaryRef dict = CFDictionaryCreateMutable (NULL, 0,
1939                                 &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
1940 
1941 // first step -&gt; save the version to the data ref
1942     SInt32 value = kCurrentSavedStateVersion;
1943     AddNumToDictionary (dict, kVersionString, value);
1944 
1945 // second step -&gt; save the component type, subtype, manu to the data ref
1946     value = desc.componentType;
1947     AddNumToDictionary (dict, kTypeString, value);
1948 
1949     value = desc.componentSubType;
1950     AddNumToDictionary (dict, kSubtypeString, value);
1951 
1952     value = desc.componentManufacturer;
1953     AddNumToDictionary (dict, kManufacturerString, value);
1954 
1955 // fourth step -&gt; save the state of all parameters on all scopes and elements
1956     CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
1957     for (AudioUnitScope iscope = 0; iscope &lt; 3; ++iscope) {
1958         AUScope &amp;scope = GetScope(iscope);
1959         scope.SaveState (data);
1960     }
1961 
1962     SaveExtendedScopes(data);
1963 
1964 // save all this in the data section of the dictionary
1965     CFDictionarySetValue(dict, kDataString, data);
1966     CFRelease (data);
1967 
1968 //OK - now we&#39;re going to do some properties
1969 //save the preset name...
1970     CFDictionarySetValue (dict, kNameString, mCurrentPreset.presetName);
1971 
1972 // Does the unit support the RenderQuality property - if so, save it...
1973     value = 0;
1974     OSStatus result = DispatchGetProperty (kAudioUnitProperty_RenderQuality,
1975                                 kAudioUnitScope_Global,
1976                                 0,
1977                                 &amp;value);
1978 
1979     if (result == noErr) {
1980         AddNumToDictionary (dict, kRenderQualityString, value);
1981     }
1982 
1983 // Does the unit support the CPULoad Quality property - if so, save it...
1984     Float32 cpuLoad;
1985     result = DispatchGetProperty (6/*kAudioUnitProperty_CPULoad*/,
1986                                 kAudioUnitScope_Global,
1987                                 0,
1988                                 &amp;cpuLoad);
1989 
1990     if (result == noErr) {
1991         CFNumberRef num = CFNumberCreate (NULL, kCFNumberFloatType, &amp;cpuLoad);
1992         CFDictionarySetValue (dict, kCPULoadString, num);
1993         CFRelease (num);
1994     }
1995 
1996 // Do we have any element names for any of our scopes?
1997     // first check to see if we have any names...
1998     bool foundName = false;
1999     for (AudioUnitScope i = 0; i &lt; kNumScopes; ++i) {
2000         foundName = GetScope (i).HasElementWithName();
2001         if (foundName)
2002             break;
2003     }
2004         // OK - we found a name away we go...
2005     if (foundName) {
2006         CFMutableDictionaryRef nameDict = CFDictionaryCreateMutable (NULL, 0,
2007                                 &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
2008         for (AudioUnitScope i = 0; i &lt; kNumScopes; ++i) {
2009             GetScope (i).AddElementNamesToDict (nameDict);
2010         }
2011 
2012         CFDictionarySetValue (dict, kElementNameString, nameDict);
2013         CFRelease (nameDict);
2014     }
2015 
2016 // we&#39;re done!!!
2017     *outData = dict;
2018 
2019     return noErr;
2020 }
2021 
2022 //_____________________________________________________________________________
2023 //
2024 OSStatus            AUBase::RestoreState(   CFPropertyListRef   plist)
2025 {
2026     if (CFGetTypeID(plist) != CFDictionaryGetTypeID()) return kAudioUnitErr_InvalidPropertyValue;
2027 
2028     AudioComponentDescription desc = GetComponentDescription();
2029 
2030     CFDictionaryRef dict = static_cast&lt;CFDictionaryRef&gt;(plist);
2031 
2032 // zeroeth step - make sure the Part key is NOT present, as this method is used
2033 // to restore the GLOBAL state of the dictionary
2034     if (CFDictionaryContainsKey (dict, kPartString))
2035         return kAudioUnitErr_InvalidPropertyValue;
2036 
2037 // first step -&gt; check the saved version in the data ref
2038 // at this point we&#39;re only dealing with version==0
2039     CFNumberRef cfnum = reinterpret_cast&lt;CFNumberRef&gt;(CFDictionaryGetValue (dict, kVersionString));
2040     if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
2041     SInt32 value;
2042     CFNumberGetValue (cfnum, kCFNumberSInt32Type, &amp;value);
2043     if (value != kCurrentSavedStateVersion) return kAudioUnitErr_InvalidPropertyValue;
2044 
2045 // second step -&gt; check that this data belongs to this kind of audio unit
2046 // by checking the component subtype and manuID
2047 // We&#39;re not checking the type, since there may be different versions (effect, format-converter, offline)
2048 // of essentially the same AU
2049     cfnum = reinterpret_cast&lt;CFNumberRef&gt;(CFDictionaryGetValue (dict, kSubtypeString));
2050     if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
2051     CFNumberGetValue (cfnum, kCFNumberSInt32Type, &amp;value);
2052     if (UInt32(value) != desc.componentSubType) return kAudioUnitErr_InvalidPropertyValue;
2053 
2054     cfnum = reinterpret_cast&lt;CFNumberRef&gt;(CFDictionaryGetValue (dict, kManufacturerString));
2055     if (cfnum == NULL) return kAudioUnitErr_InvalidPropertyValue;
2056     CFNumberGetValue (cfnum, kCFNumberSInt32Type, &amp;value);
2057     if (UInt32(value) != desc.componentManufacturer) return kAudioUnitErr_InvalidPropertyValue;
2058 
2059 // fourth step -&gt; restore the state of all of the parameters for each scope and element
2060     CFDataRef data = reinterpret_cast&lt;CFDataRef&gt;(CFDictionaryGetValue (dict, kDataString));
2061     if (data != NULL)
2062     {
2063         const UInt8 *p, *pend;
2064 
2065         p = CFDataGetBytePtr(data);
2066         pend = p + CFDataGetLength(data);
2067 
2068         // we have a zero length data, which may just mean there were no parameters to save!
2069         //  if (p &gt;= pend) return noErr;
2070 
2071         while (p &lt; pend) {
2072             UInt32 scopeIdx = CFSwapInt32BigToHost(*(UInt32 *)p);
2073             p += sizeof(UInt32);
2074 
2075             AUScope &amp;scope = GetScope(scopeIdx);
2076             p = scope.RestoreState(p);
2077         }
2078     }
2079 
2080 //OK - now we&#39;re going to do some properties
2081 //restore the preset name...
2082     CFStringRef name = reinterpret_cast&lt;CFStringRef&gt;(CFDictionaryGetValue (dict, kNameString));
2083     if (mCurrentPreset.presetName) CFRelease (mCurrentPreset.presetName);
2084     if (name)
2085     {
2086         mCurrentPreset.presetName = name;
2087         mCurrentPreset.presetNumber = -1;
2088     }
2089     else { // no name entry make the default one
2090         mCurrentPreset.presetName = kUntitledString;
2091         mCurrentPreset.presetNumber = -1;
2092     }
2093 
2094     CFRetain (mCurrentPreset.presetName);
2095 #if !CA_USE_AUDIO_PLUGIN_ONLY
2096 #ifndef __LP64__
2097     PropertyChanged(kAudioUnitProperty_CurrentPreset, kAudioUnitScope_Global, 0);
2098 #endif
2099 #endif
2100     PropertyChanged(kAudioUnitProperty_PresentPreset, kAudioUnitScope_Global, 0);
2101 
2102 // Does the dict contain render quality information?
2103     if (CFDictionaryGetValueIfPresent (dict, kRenderQualityString, reinterpret_cast&lt;const void**&gt;(&amp;cfnum)))
2104     {
2105         CFNumberGetValue (cfnum, kCFNumberSInt32Type, &amp;value);
2106         DispatchSetProperty (kAudioUnitProperty_RenderQuality,
2107                                 kAudioUnitScope_Global,
2108                                 0,
2109                                 &amp;value,
2110                                 sizeof(value));
2111     }
2112 
2113 // Does the unit support the CPULoad Quality property - if so, save it...
2114     if (CFDictionaryGetValueIfPresent (dict, kCPULoadString, reinterpret_cast&lt;const void**&gt;(&amp;cfnum)))
2115     {
2116         Float32 floatValue;
2117         CFNumberGetValue (cfnum, kCFNumberFloatType, &amp;floatValue);
2118         DispatchSetProperty (6/*kAudioUnitProperty_CPULoad*/,
2119                                 kAudioUnitScope_Global,
2120                                 0,
2121                                 &amp;floatValue,
2122                                 sizeof(floatValue));
2123     }
2124 
2125 // Do we have any element names for any of our scopes?
2126     CFDictionaryRef nameDict;
2127     if (CFDictionaryGetValueIfPresent (dict, kElementNameString, reinterpret_cast&lt;const void**&gt;(&amp;nameDict)))
2128     {
2129         char string[64];
2130         for (int i = 0; i &lt; kNumScopes; ++i)
2131         {
2132             snprintf (string, sizeof(string), &quot;%d&quot;, i);
2133             CFStringRef key = CFStringCreateWithCString (NULL, string, kCFStringEncodingASCII);
2134             CFDictionaryRef elementDict;
2135             if (CFDictionaryGetValueIfPresent (nameDict, key, reinterpret_cast&lt;const void**&gt;(&amp;elementDict)))
2136             {
2137                 bool didAddElements = GetScope (i).RestoreElementNames (elementDict);
2138                 if (didAddElements)
2139                     PropertyChanged (kAudioUnitProperty_ElementCount, i, 0);
2140             }
2141             CFRelease (key);
2142         }
2143     }
2144 
2145     return noErr;
2146 }
2147 
2148 OSStatus            AUBase::GetPresets (            CFArrayRef *                    outData) const
2149 {
2150     return kAudioUnitErr_InvalidProperty;
2151 }
2152 
2153 OSStatus            AUBase::NewFactoryPresetSet (const AUPreset &amp; inNewFactoryPreset)
2154 {
2155     return kAudioUnitErr_InvalidProperty;
2156 }
2157 
2158 OSStatus            AUBase::NewCustomPresetSet (const AUPreset &amp; inNewCustomPreset)
2159 {
2160     CFRelease (mCurrentPreset.presetName);
2161     mCurrentPreset = inNewCustomPreset;
2162     CFRetain (mCurrentPreset.presetName);
2163     return noErr;
2164 }
2165 
2166         // set the default preset for the unit -&gt; the number of the preset MUST be &gt;= 0
2167         // and the name should be valid, or the preset WON&#39;T take
2168 bool                AUBase::SetAFactoryPresetAsCurrent (const AUPreset &amp; inPreset)
2169 {
2170     if (inPreset.presetNumber &lt; 0 || inPreset.presetName == NULL) return false;
2171     CFRelease (mCurrentPreset.presetName);
2172     mCurrentPreset = inPreset;
2173     CFRetain (mCurrentPreset.presetName);
2174     return true;
2175 }
2176 
2177 #if !CA_USE_AUDIO_PLUGIN_ONLY
2178 int         AUBase::GetNumCustomUIComponents ()
2179 {
2180     return 0;
2181 }
2182 
2183 void        AUBase::GetUIComponentDescs (ComponentDescription* inDescArray) {}
2184 #endif
2185 
2186 bool        AUBase::HasIcon ()
2187 {
2188 #if !CA_NO_AU_UI_FEATURES
2189     CFURLRef url = CopyIconLocation();
2190     if (url) {
2191         CFRelease (url);
2192         return true;
2193     }
2194 #endif
2195     return false;
2196 }
2197 
2198 CFURLRef    AUBase::CopyIconLocation ()
2199 {
2200     return NULL;
2201 }
2202 
2203 //_____________________________________________________________________________
2204 //
2205 OSStatus            AUBase::GetParameterList(       AudioUnitScope                  inScope,
2206                                                     AudioUnitParameterID *          outParameterList,
2207                                                     UInt32 &amp;                        outNumParameters)
2208 {
2209     AUScope &amp;scope = GetScope(inScope);
2210     AUElement *elementWithMostParameters = NULL;
2211     UInt32 maxNumParams = 0;
2212 
2213     int nElems = scope.GetNumberOfElements();
2214     for (int ielem = 0; ielem &lt; nElems; ++ielem) {
2215         AUElement *element = scope.GetElement(ielem);
2216         UInt32 nParams = element-&gt;GetNumberOfParameters();
2217         if (nParams &gt; maxNumParams) {
2218             maxNumParams = nParams;
2219             elementWithMostParameters = element;
2220         }
2221     }
2222 
2223     if (outParameterList != NULL &amp;&amp; elementWithMostParameters != NULL)
2224         elementWithMostParameters-&gt;GetParameterList(outParameterList);
2225 
2226     outNumParameters = maxNumParams;
2227     return noErr;
2228 }
2229 
2230 //_____________________________________________________________________________
2231 //
2232 OSStatus            AUBase::GetParameterInfo(       AudioUnitScope          inScope,
2233                                                     AudioUnitParameterID    inParameterID,
2234                                                     AudioUnitParameterInfo  &amp;outParameterInfo )
2235 {
2236     return kAudioUnitErr_InvalidParameter;
2237 }
2238 
2239 //_____________________________________________________________________________
2240 //
2241 OSStatus            AUBase::GetParameterValueStrings(AudioUnitScope         inScope,
2242                                                     AudioUnitParameterID    inParameterID,
2243                                                     CFArrayRef *            outStrings)
2244 {
2245     return kAudioUnitErr_InvalidProperty;
2246 }
2247 
2248 //_____________________________________________________________________________
2249 //
2250 OSStatus            AUBase::GetParameterHistoryInfo(    AudioUnitScope                  inScope,
2251                                                         AudioUnitParameterID            inParameterID,
2252                                                         Float32 &amp;                       outUpdatesPerSecond,
2253                                                         Float32 &amp;                       outHistoryDurationInSeconds)
2254 {
2255     return kAudioUnitErr_InvalidProperty;
2256 }
2257 
2258 
2259 //_____________________________________________________________________________
2260 //
2261 OSStatus            AUBase::CopyClumpName(          AudioUnitScope          inScope,
2262                                                     UInt32                  inClumpID,
2263                                                     UInt32                  inDesiredNameLength,
2264                                                     CFStringRef *           outClumpName)
2265 {
2266     return kAudioUnitErr_InvalidProperty;
2267 }
2268 
2269 //_____________________________________________________________________________
2270 //
2271 void                AUBase::SetNumberOfElements(    AudioUnitScope                  inScope,
2272                                                     UInt32                          numElements)
2273 {
2274     if (inScope == kAudioUnitScope_Global &amp;&amp; numElements != 1)
2275         COMPONENT_THROW(kAudioUnitErr_InvalidScope);
2276 
2277     GetScope(inScope).SetNumberOfElements(numElements);
2278 }
2279 
2280 //_____________________________________________________________________________
2281 //
2282 AUElement *         AUBase::CreateElement(          AudioUnitScope                  scope,
2283                                                     AudioUnitElement                element)
2284 {
2285     switch (scope) {
2286     case kAudioUnitScope_Global:
2287         return new AUElement(this);
2288     case kAudioUnitScope_Input:
2289         return new AUInputElement(this);
2290     case kAudioUnitScope_Output:
2291         return new AUOutputElement(this);
2292 #if !CA_BASIC_AU_FEATURES
2293     case kAudioUnitScope_Group:
2294         return new AUElement(this);
2295     case kAudioUnitScope_Part:
2296         return new AUElement(this);
2297 #endif
2298     }
2299     COMPONENT_THROW(kAudioUnitErr_InvalidScope);
2300 
2301     return NULL;    // get rid of compiler warning
2302 }
2303 
2304 //_____________________________________________________________________________
2305 //
2306 bool    AUBase::FormatIsCanonical(      const CAStreamBasicDescription &amp;f)
2307 {
2308     return (f.mFormatID == kAudioFormatLinearPCM
2309         &amp;&amp;  f.mFramesPerPacket == 1
2310         &amp;&amp;  f.mBytesPerPacket == f.mBytesPerFrame
2311 //      &amp;&amp;  f.mChannelsPerFrame &gt;= 0    -- this is always true since it&#39;s unsigned
2312         // so far, it&#39;s a valid PCM format
2313 #if CA_PREFER_FIXED_POINT
2314         &amp;&amp;  (f.mFormatFlags &amp; kLinearPCMFormatFlagIsFloat) == 0
2315         &amp;&amp;  (((f.mFormatFlags &amp; kLinearPCMFormatFlagsSampleFractionMask) &gt;&gt; kLinearPCMFormatFlagsSampleFractionShift) == kAudioUnitSampleFractionBits)
2316 #else
2317         &amp;&amp;  (f.mFormatFlags &amp; kLinearPCMFormatFlagIsFloat) != 0
2318 #endif
2319         &amp;&amp;  ((f.mChannelsPerFrame == 1) || ((f.mFormatFlags &amp; kAudioFormatFlagIsNonInterleaved) == 0) == (mAudioUnitAPIVersion == 1))
2320 #if TARGET_RT_BIG_ENDIAN
2321         &amp;&amp;  (f.mFormatFlags &amp; kLinearPCMFormatFlagIsBigEndian) != 0
2322 #else
2323         &amp;&amp;  (f.mFormatFlags &amp; kLinearPCMFormatFlagIsBigEndian) == 0
2324 #endif
2325         &amp;&amp;  f.mBitsPerChannel == 8 * sizeof(AudioUnitSampleType)
2326         &amp;&amp;  f.mBytesPerFrame == f.NumberInterleavedChannels() * sizeof(AudioUnitSampleType)
2327         );
2328 }
2329 
2330 //_____________________________________________________________________________
2331 //
2332 void    AUBase::MakeCanonicalFormat(    CAStreamBasicDescription &amp;      f,
2333                                         int                             nChannels)
2334 {
2335     f.SetAUCanonical(nChannels, mAudioUnitAPIVersion &lt; 2);  // interleaved for v1, non for v2
2336     f.mSampleRate = 0.0;
2337 }
2338 
2339 const Float64 AUBase::kNoLastRenderedSampleTime = -1.;
2340 
2341 #include &quot;AUBaseHelper.h&quot;
2342 
2343 char*   AUBase::GetLoggingString () const
2344 {
2345     if (mLogString) return mLogString;
2346 
2347     AudioComponentDescription desc = GetComponentDescription();
2348 
2349     const size_t logStringSize = 256;
2350     const_cast&lt;AUBase*&gt;(this)-&gt;mLogString = new char[logStringSize];
2351     char str[24];
2352     char str1[24];
2353     char str2[24];
2354     snprintf (const_cast&lt;AUBase*&gt;(this)-&gt;mLogString, logStringSize, &quot;AU (%p): %s %s %s&quot;,
2355         GetComponentInstance(),
2356         CAStringForOSType(desc.componentType, str, sizeof(str)),
2357         CAStringForOSType(desc.componentSubType, str1, sizeof(str1)),
2358         CAStringForOSType(desc.componentManufacturer, str2, sizeof(str2)));
2359 
2360     return mLogString;
2361 }
2362 
    </pre>
  </body>
</html>