<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/jfxmedia/platform/osx/CoreAudioUtilityClasses/CoreAudio/PublicUtility/CAStreamBasicDescription.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2 Copyright (C) 2016 Apple Inc. All Rights Reserved.
  3 See LICENSE.txt for this sampleâ€™s licensing information
  4 
  5 Abstract:
  6 Part of Core Audio Public Utility Classes
  7 */
  8 
  9 #include &quot;CAStreamBasicDescription.h&quot;
 10 #include &quot;CAMath.h&quot;
 11 
 12 #if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)
 13     #include &lt;CoreFoundation/CFByteOrder.h&gt;
 14 #else
 15     #include &lt;CFByteOrder.h&gt;
 16 #endif
 17 
 18 #pragma mark    This file needs to compile on earlier versions of the OS, so please keep that in mind when editing it
 19 
 20 char *CAStringForOSType (OSType t, char *writeLocation, size_t bufsize)
 21 {
 22     if (bufsize &gt; 0) {
 23         char *p = writeLocation, *pend = writeLocation + bufsize;
 24         union { UInt32 i; unsigned char str[4]; } u;
 25         unsigned char *q = u.str;
 26         u.i = CFSwapInt32HostToBig(t);
 27 
 28         bool hasNonPrint = false;
 29         for (int i = 0; i &lt; 4; ++i) {
 30             if (!(isprint(*q) &amp;&amp; *q != &#39;\\&#39;)) {
 31                 hasNonPrint = true;
 32                 break;
 33             }
 34             q++;
 35         }
 36         q = u.str;
 37 
 38         if (hasNonPrint)
 39             p += snprintf (p, pend - p, &quot;0x&quot;);
 40         else if (p &lt; pend)
 41             *p++ = &#39;\&#39;&#39;;
 42 
 43         for (int i = 0; i &lt; 4 &amp;&amp; p &lt; pend; ++i) {
 44             if (hasNonPrint) {
 45                 p += snprintf(p, pend - p, &quot;%02X&quot;, *q++);
 46             } else {
 47                 *p++ = *q++;
 48             }
 49         }
 50         if (!hasNonPrint &amp;&amp; p &lt; pend)
 51             *p++ = &#39;\&#39;&#39;;
 52         if (p &gt;= pend) p -= 1;
 53         *p = &#39;\0&#39;;
 54     }
 55     return writeLocation;
 56 }
 57 
 58 
 59 const AudioStreamBasicDescription   CAStreamBasicDescription::sEmpty = { 0.0, 0, 0, 0, 0, 0, 0, 0, 0 };
 60 
 61 CAStreamBasicDescription::CAStreamBasicDescription()
 62 {
 63     memset (this, 0, sizeof(AudioStreamBasicDescription));
 64 }
 65 
 66 CAStreamBasicDescription::CAStreamBasicDescription(const AudioStreamBasicDescription &amp;desc)
 67 {
 68     SetFrom(desc);
 69 }
 70 
 71 
 72 CAStreamBasicDescription::CAStreamBasicDescription(double inSampleRate,     UInt32 inFormatID,
 73                                     UInt32 inBytesPerPacket,    UInt32 inFramesPerPacket,
 74                                     UInt32 inBytesPerFrame,     UInt32 inChannelsPerFrame,
 75                                     UInt32 inBitsPerChannel,    UInt32 inFormatFlags)
 76 {
 77     mSampleRate = inSampleRate;
 78     mFormatID = inFormatID;
 79     mBytesPerPacket = inBytesPerPacket;
 80     mFramesPerPacket = inFramesPerPacket;
 81     mBytesPerFrame = inBytesPerFrame;
 82     mChannelsPerFrame = inChannelsPerFrame;
 83     mBitsPerChannel = inBitsPerChannel;
 84     mFormatFlags = inFormatFlags;
 85     mReserved = 0;
 86 }
 87 
 88 char *CAStreamBasicDescription::AsString(char *buf, size_t _bufsize, bool brief /*=false*/) const
 89 {
 90     int bufsize = (int)_bufsize;    // must be signed to protect against overflow
 91     char *theBuffer = buf;
 92     int nc;
 93     char formatID[24];
 94     CAStringForOSType(mFormatID, formatID, sizeof(formatID));
 95     if (brief) {
 96         CommonPCMFormat com;
 97         bool interleaved;
 98         if (IdentifyCommonPCMFormat(com, &amp;interleaved) &amp;&amp; com != kPCMFormatOther) {
 99             const char *desc;
100             switch (com) {
101             case kPCMFormatInt16:
102                 desc = &quot;Int16&quot;;
103                 break;
104             case kPCMFormatInt32:
105                 desc = &quot;Int32&quot;;
106                 break;
107             case kPCMFormatFixed824:
108                 desc = &quot;Int8.24&quot;;
109                 break;
110             case kPCMFormatFloat32:
111                 desc = &quot;Float32&quot;;
112                 break;
113             case kPCMFormatFloat64:
114                 desc = &quot;Float64&quot;;
115                 break;
116             default:
117                 desc = NULL;
118                 break;
119             }
120             if (desc) {
121                 const char *inter =&quot;&quot;;
122                 if (mChannelsPerFrame &gt; 1)
123                     inter = !interleaved ? &quot;, non-inter&quot; : &quot;, inter&quot;;
124                 snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%2d ch, %6.0f Hz, %s%s&quot;, (int)mChannelsPerFrame, mSampleRate, desc, inter);
125                 return theBuffer;
126             }
127         }
128         if (mChannelsPerFrame == 0 &amp;&amp; mSampleRate == 0.0 &amp;&amp; mFormatID == 0) {
129             snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%2d ch, %6.0f Hz&quot;, (int)mChannelsPerFrame, mSampleRate);
130             return theBuffer;
131         }
132     }
133 
134     nc = snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%2d ch, %6.0f Hz, %s (0x%08X) &quot;, (int)NumberChannels(), mSampleRate, formatID, (int)mFormatFlags);
135     buf += nc; if ((bufsize -= nc) &lt;= 0) goto exit;
136     if (mFormatID == kAudioFormatLinearPCM) {
137         bool isInt = !(mFormatFlags &amp; kLinearPCMFormatFlagIsFloat);
138         int wordSize = static_cast&lt;int&gt;(SampleWordSize());
139         const char *endian = (wordSize &gt; 1) ?
140             ((mFormatFlags &amp; kLinearPCMFormatFlagIsBigEndian) ? &quot; big-endian&quot; : &quot; little-endian&quot; ) : &quot;&quot;;
141         const char *sign = isInt ?
142             ((mFormatFlags &amp; kLinearPCMFormatFlagIsSignedInteger) ? &quot; signed&quot; : &quot; unsigned&quot;) : &quot;&quot;;
143         const char *floatInt = isInt ? &quot;integer&quot; : &quot;float&quot;;
144         char packed[32];
145         if (wordSize &gt; 0 &amp;&amp; PackednessIsSignificant()) {
146             if (mFormatFlags &amp; kLinearPCMFormatFlagIsPacked)
147                 snprintf(packed, sizeof(packed), &quot;packed in %d bytes&quot;, wordSize);
148             else
149                 snprintf(packed, sizeof(packed), &quot;unpacked in %d bytes&quot;, wordSize);
150         } else
151             packed[0] = &#39;\0&#39;;
152         const char *align = (wordSize &gt; 0 &amp;&amp; AlignmentIsSignificant()) ?
153             ((mFormatFlags &amp; kLinearPCMFormatFlagIsAlignedHigh) ? &quot; high-aligned&quot; : &quot; low-aligned&quot;) : &quot;&quot;;
154         const char *deinter = (mFormatFlags &amp; kAudioFormatFlagIsNonInterleaved) ? &quot;, deinterleaved&quot; : &quot;&quot;;
155         const char *commaSpace = (packed[0]!=&#39;\0&#39;) || (align[0]!=&#39;\0&#39;) ? &quot;, &quot; : &quot;&quot;;
156         char bitdepth[20];
157 
158         int fracbits = (mFormatFlags &amp; kLinearPCMFormatFlagsSampleFractionMask) &gt;&gt; kLinearPCMFormatFlagsSampleFractionShift;
159         if (fracbits &gt; 0)
160             snprintf(bitdepth, sizeof(bitdepth), &quot;%d.%d&quot;, (int)mBitsPerChannel - fracbits, fracbits);
161         else
162             snprintf(bitdepth, sizeof(bitdepth), &quot;%d&quot;, (int)mBitsPerChannel);
163 
164         /*nc =*/ snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%s-bit%s%s %s%s%s%s%s&quot;,
165             bitdepth, endian, sign, floatInt,
166             commaSpace, packed, align, deinter);
167         // buf += nc; if ((bufsize -= nc) &lt;= 0) goto exit;
168     } else if (mFormatID == kAudioFormatAppleLossless) {
169         int sourceBits = 0;
170         switch (mFormatFlags)
171         {
172             case 1: //  kAppleLosslessFormatFlag_16BitSourceData
173                 sourceBits = 16;
174                 break;
175             case 2: //  kAppleLosslessFormatFlag_20BitSourceData
176                 sourceBits = 20;
177                 break;
178             case 3: //  kAppleLosslessFormatFlag_24BitSourceData
179                 sourceBits = 24;
180                 break;
181             case 4: //  kAppleLosslessFormatFlag_32BitSourceData
182                 sourceBits = 32;
183                 break;
184         }
185         if (sourceBits)
186             nc = snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;from %d-bit source, &quot;, sourceBits);
187         else
188             nc = snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;from UNKNOWN source bit depth, &quot;);
189         buf += nc; if ((bufsize -= nc) &lt;= 0) goto exit;
190         /*nc =*/ snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%d frames/packet&quot;, (int)mFramesPerPacket);
191         //  buf += nc; if ((bufsize -= nc) &lt;= 0) goto exit;
192     }
193     else
194         /*nc =*/ snprintf(buf, static_cast&lt;size_t&gt;(bufsize), &quot;%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame&quot;,
195             (int)mBitsPerChannel, (int)mBytesPerPacket, (int)mFramesPerPacket, (int)mBytesPerFrame);
196 exit:
197     return theBuffer;
198 }
199 
200 void    CAStreamBasicDescription::NormalizeLinearPCMFormat(AudioStreamBasicDescription&amp; ioDescription)
201 {
202     //  the only thing that changes is to make mixable linear PCM into the canonical linear PCM format
203     if((ioDescription.mFormatID == kAudioFormatLinearPCM) &amp;&amp; ((ioDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0))
204     {
205         //  the canonical linear PCM format
206         ioDescription.mFormatFlags = kAudioFormatFlagsCanonical;
207         ioDescription.mBytesPerPacket = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
208         ioDescription.mFramesPerPacket = 1;
209         ioDescription.mBytesPerFrame = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
210         ioDescription.mBitsPerChannel = 8 * SizeOf32(AudioSampleType);
211     }
212 }
213 
214 void    CAStreamBasicDescription::NormalizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription&amp; ioDescription)
215 {
216     //  the only thing that changes is to make mixable linear PCM into the canonical linear PCM format
217     if((ioDescription.mFormatID == kAudioFormatLinearPCM) &amp;&amp; ((ioDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0))
218     {
219         //  the canonical linear PCM format
220         ioDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;
221         if(inNativeEndian)
222         {
223 #if TARGET_RT_BIG_ENDIAN
224             ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
225 #endif
226         }
227         else
228         {
229 #if TARGET_RT_LITTLE_ENDIAN
230             ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
231 #endif
232         }
233         ioDescription.mBytesPerPacket = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
234         ioDescription.mFramesPerPacket = 1;
235         ioDescription.mBytesPerFrame = SizeOf32(AudioSampleType) * ioDescription.mChannelsPerFrame;
236         ioDescription.mBitsPerChannel = 8 * SizeOf32(AudioSampleType);
237     }
238 }
239 
240 void    CAStreamBasicDescription::VirtualizeLinearPCMFormat(AudioStreamBasicDescription&amp; ioDescription)
241 {
242     //  the only thing that changes is to make mixable linear PCM into the HAL&#39;s virtual linear PCM format, which is Float32 currently
243     if((ioDescription.mFormatID == kAudioFormatLinearPCM) &amp;&amp; ((ioDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0))
244     {
245         //  the virtual linear PCM format
246         ioDescription.mFormatFlags = kAudioFormatFlagsNativeFloatPacked;
247         ioDescription.mBytesPerPacket = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
248         ioDescription.mFramesPerPacket = 1;
249         ioDescription.mBytesPerFrame = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
250         ioDescription.mBitsPerChannel = 8 * SizeOf32(Float32);
251     }
252 }
253 
254 void    CAStreamBasicDescription::VirtualizeLinearPCMFormat(bool inNativeEndian, AudioStreamBasicDescription&amp; ioDescription)
255 {
256     //  the only thing that changes is to make mixable linear PCM into the HAL&#39;s virtual linear PCM format, which is Float32 currently
257     if((ioDescription.mFormatID == kAudioFormatLinearPCM) &amp;&amp; ((ioDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0))
258     {
259         //  the virtual linear PCM format
260         ioDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;
261         if(inNativeEndian)
262         {
263 #if TARGET_RT_BIG_ENDIAN
264             ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
265 #endif
266         }
267         else
268         {
269 #if TARGET_RT_LITTLE_ENDIAN
270             ioDescription.mFormatFlags |= kAudioFormatFlagIsBigEndian;
271 #endif
272         }
273         ioDescription.mBytesPerPacket = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
274         ioDescription.mFramesPerPacket = 1;
275         ioDescription.mBytesPerFrame = SizeOf32(Float32) * ioDescription.mChannelsPerFrame;
276         ioDescription.mBitsPerChannel = 8 * SizeOf32(Float32);
277     }
278 }
279 
280 void    CAStreamBasicDescription::ResetFormat(AudioStreamBasicDescription&amp; ioDescription)
281 {
282     ioDescription.mSampleRate = 0;
283     ioDescription.mFormatID = 0;
284     ioDescription.mBytesPerPacket = 0;
285     ioDescription.mFramesPerPacket = 0;
286     ioDescription.mBytesPerFrame = 0;
287     ioDescription.mChannelsPerFrame = 0;
288     ioDescription.mBitsPerChannel = 0;
289     ioDescription.mFormatFlags = 0;
290 }
291 
292 void    CAStreamBasicDescription::FillOutFormat(AudioStreamBasicDescription&amp; ioDescription, const AudioStreamBasicDescription&amp; inTemplateDescription)
293 {
294     if(fiszero(ioDescription.mSampleRate))
295     {
296         ioDescription.mSampleRate = inTemplateDescription.mSampleRate;
297     }
298     if(ioDescription.mFormatID == 0)
299     {
300         ioDescription.mFormatID = inTemplateDescription.mFormatID;
301     }
302     if(ioDescription.mFormatFlags == 0)
303     {
304         ioDescription.mFormatFlags = inTemplateDescription.mFormatFlags;
305     }
306     if(ioDescription.mBytesPerPacket == 0)
307     {
308         ioDescription.mBytesPerPacket = inTemplateDescription.mBytesPerPacket;
309     }
310     if(ioDescription.mFramesPerPacket == 0)
311     {
312         ioDescription.mFramesPerPacket = inTemplateDescription.mFramesPerPacket;
313     }
314     if(ioDescription.mBytesPerFrame == 0)
315     {
316         ioDescription.mBytesPerFrame = inTemplateDescription.mBytesPerFrame;
317     }
318     if(ioDescription.mChannelsPerFrame == 0)
319     {
320         ioDescription.mChannelsPerFrame = inTemplateDescription.mChannelsPerFrame;
321     }
322     if(ioDescription.mBitsPerChannel == 0)
323     {
324         ioDescription.mBitsPerChannel = inTemplateDescription.mBitsPerChannel;
325     }
326 }
327 
328 void    CAStreamBasicDescription::GetSimpleName(const AudioStreamBasicDescription&amp; inDescription, char* outName, UInt32 inMaxNameLength, bool inAbbreviate, bool inIncludeSampleRate)
329 {
330     if(inIncludeSampleRate)
331     {
332         int theCharactersWritten = snprintf(outName, inMaxNameLength, &quot;%.0f &quot;, inDescription.mSampleRate);
333         outName += theCharactersWritten;
334         inMaxNameLength -= static_cast&lt;UInt32&gt;(theCharactersWritten);
335     }
336 
337     switch(inDescription.mFormatID)
338     {
339         case kAudioFormatLinearPCM:
340             {
341                 const char* theEndianString = NULL;
342                 if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsBigEndian) != 0)
343                 {
344                     #if TARGET_RT_LITTLE_ENDIAN
345                         theEndianString = &quot;Big Endian&quot;;
346                     #endif
347                 }
348                 else
349                 {
350                     #if TARGET_RT_BIG_ENDIAN
351                         theEndianString = &quot;Little Endian&quot;;
352                     #endif
353                 }
354 
355                 const char* theKindString = NULL;
356                 if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsFloat) != 0)
357                 {
358                     theKindString = (inAbbreviate ? &quot;Float&quot; : &quot;Floating Point&quot;);
359                 }
360                 else if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsSignedInteger) != 0)
361                 {
362                     theKindString = (inAbbreviate ? &quot;SInt&quot; : &quot;Signed Integer&quot;);
363                 }
364                 else
365                 {
366                     theKindString = (inAbbreviate ? &quot;UInt&quot; : &quot;Unsigned Integer&quot;);
367                 }
368 
369                 const char* thePackingString = NULL;
370                 if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsPacked) == 0)
371                 {
372                     if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsAlignedHigh) != 0)
373                     {
374                         thePackingString = &quot;High&quot;;
375                     }
376                     else
377                     {
378                         thePackingString = &quot;Low&quot;;
379                     }
380                 }
381 
382                 const char* theMixabilityString = NULL;
383                 if((inDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0)
384                 {
385                     theMixabilityString = &quot;Mixable&quot;;
386                 }
387                 else
388                 {
389                     theMixabilityString = &quot;Unmixable&quot;;
390                 }
391 
392                 if(inAbbreviate)
393                 {
394                     if(theEndianString != NULL)
395                     {
396                         if(thePackingString != NULL)
397                         {
398                             snprintf(outName, inMaxNameLength, &quot;%s %d Ch %s %s %s%d/%s%d&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
399                         }
400                         else
401                         {
402                             snprintf(outName, inMaxNameLength, &quot;%s %d Ch %s %s%d&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, theKindString, (int)inDescription.mBitsPerChannel);
403                         }
404                     }
405                     else
406                     {
407                         if(thePackingString != NULL)
408                         {
409                             snprintf(outName, inMaxNameLength, &quot;%s %d Ch %s %s%d/%s%d&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)((inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8));
410                         }
411                         else
412                         {
413                             snprintf(outName, inMaxNameLength, &quot;%s %d Ch %s%d&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, theKindString, (int)inDescription.mBitsPerChannel);
414                         }
415                     }
416                 }
417                 else
418                 {
419                     if(theEndianString != NULL)
420                     {
421                         if(thePackingString != NULL)
422                         {
423                             snprintf(outName, inMaxNameLength, &quot;%s %d Channel %d Bit %s %s Aligned %s in %d Bits&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
424                         }
425                         else
426                         {
427                             snprintf(outName, inMaxNameLength, &quot;%s %d Channel %d Bit %s %s&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString);
428                         }
429                     }
430                     else
431                     {
432                         if(thePackingString != NULL)
433                         {
434                             snprintf(outName, inMaxNameLength, &quot;%s %d Channel %d Bit %s Aligned %s in %d Bits&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);
435                         }
436                         else
437                         {
438                             snprintf(outName, inMaxNameLength, &quot;%s %d Channel %d Bit %s&quot;, theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString);
439                         }
440                     }
441                 }
442             }
443             break;
444 
445         case kAudioFormatAC3:
446             strlcpy(outName, &quot;AC-3&quot;, sizeof(outName));
447             break;
448 
449         case kAudioFormat60958AC3:
450             strlcpy(outName, &quot;AC-3 for SPDIF&quot;, sizeof(outName));
451             break;
452 
453         default:
454             CACopy4CCToCString(outName, inDescription.mFormatID);
455             break;
456     };
457 }
458 
459 #if CoreAudio_Debug
460 #include &quot;CALogMacros.h&quot;
461 
462 void    CAStreamBasicDescription::PrintToLog(const AudioStreamBasicDescription&amp; inDesc)
463 {
464     PrintFloat      (&quot;  Sample Rate:        &quot;, inDesc.mSampleRate);
465     Print4CharCode  (&quot;  Format ID:          &quot;, inDesc.mFormatID);
466     PrintHex        (&quot;  Format Flags:       &quot;, inDesc.mFormatFlags);
467     PrintInt        (&quot;  Bytes per Packet:   &quot;, inDesc.mBytesPerPacket);
468     PrintInt        (&quot;  Frames per Packet:  &quot;, inDesc.mFramesPerPacket);
469     PrintInt        (&quot;  Bytes per Frame:    &quot;, inDesc.mBytesPerFrame);
470     PrintInt        (&quot;  Channels per Frame: &quot;, inDesc.mChannelsPerFrame);
471     PrintInt        (&quot;  Bits per Channel:   &quot;, inDesc.mBitsPerChannel);
472 }
473 #endif
474 
475 bool    operator&lt;(const AudioStreamBasicDescription&amp; x, const AudioStreamBasicDescription&amp; y)
476 {
477     bool theAnswer = false;
478     bool isDone = false;
479 
480     //  note that if either side is 0, that field is skipped
481 
482     //  format ID is the first order sort
483     if((!isDone) &amp;&amp; ((x.mFormatID != 0) &amp;&amp; (y.mFormatID != 0)))
484     {
485         if(x.mFormatID != y.mFormatID)
486         {
487             //  formats are sorted numerically except that linear
488             //  PCM is always first
489             if(x.mFormatID == kAudioFormatLinearPCM)
490             {
491                 theAnswer = true;
492             }
493             else if(y.mFormatID == kAudioFormatLinearPCM)
494             {
495                 theAnswer = false;
496             }
497             else
498             {
499                 theAnswer = x.mFormatID &lt; y.mFormatID;
500             }
501             isDone = true;
502         }
503     }
504 
505 
506     //  mixable is always better than non-mixable for linear PCM and should be the second order sort item
507     if((!isDone) &amp;&amp; ((x.mFormatID == kAudioFormatLinearPCM) &amp;&amp; (y.mFormatID == kAudioFormatLinearPCM)))
508     {
509         if(((x.mFormatFlags &amp; kIsNonMixableFlag) == 0) &amp;&amp; ((y.mFormatFlags &amp; kIsNonMixableFlag) != 0))
510         {
511             theAnswer = true;
512             isDone = true;
513         }
514         else if(((x.mFormatFlags &amp; kIsNonMixableFlag) != 0) &amp;&amp; ((y.mFormatFlags &amp; kIsNonMixableFlag) == 0))
515         {
516             theAnswer = false;
517             isDone = true;
518         }
519     }
520 
521     //  floating point vs integer for linear PCM only
522     if((!isDone) &amp;&amp; ((x.mFormatID == kAudioFormatLinearPCM) &amp;&amp; (y.mFormatID == kAudioFormatLinearPCM)))
523     {
524         if((x.mFormatFlags &amp; kAudioFormatFlagIsFloat) != (y.mFormatFlags &amp; kAudioFormatFlagIsFloat))
525         {
526             //  floating point is better than integer
527             theAnswer = y.mFormatFlags &amp; kAudioFormatFlagIsFloat;
528             isDone = true;
529         }
530     }
531 
532     //  bit depth
533     if((!isDone) &amp;&amp; ((x.mBitsPerChannel != 0) &amp;&amp; (y.mBitsPerChannel != 0)))
534     {
535         if(x.mBitsPerChannel != y.mBitsPerChannel)
536         {
537             //  deeper bit depths are higher quality
538             theAnswer = x.mBitsPerChannel &lt; y.mBitsPerChannel;
539             isDone = true;
540         }
541     }
542 
543     //  sample rate
544     if((!isDone) &amp;&amp; fnonzero(x.mSampleRate) &amp;&amp; fnonzero(y.mSampleRate))
545     {
546         if(fnotequal(x.mSampleRate, y.mSampleRate))
547         {
548             //  higher sample rates are higher quality
549             theAnswer = x.mSampleRate &lt; y.mSampleRate;
550             isDone = true;
551         }
552     }
553 
554     //  number of channels
555     if((!isDone) &amp;&amp; ((x.mChannelsPerFrame != 0) &amp;&amp; (y.mChannelsPerFrame != 0)))
556     {
557         if(x.mChannelsPerFrame != y.mChannelsPerFrame)
558         {
559             //  more channels is higher quality
560             theAnswer = x.mChannelsPerFrame &lt; y.mChannelsPerFrame;
561             //isDone = true;
562         }
563     }
564 
565     return theAnswer;
566 }
567 
568 UInt32 CAStreamBasicDescription::GetRegularizedFormatFlags(bool forHardware) const
569 {
570     UInt32 result = mFormatFlags;
571 
572     if (IsPCM()) {
573         // First, if there are bits other than AllClear set, clear it because it&#39;s lying.
574         if (result &amp; ~kAudioFormatFlagsAreAllClear)
575             result &amp;= ~kAudioFormatFlagsAreAllClear;
576 
577         // If not forHardware, remove the mixability flag.
578         if (!forHardware)
579             result &amp;= ~kLinearPCMFormatFlagIsNonMixable;
580 
581         // If the format has no extra bits, then it is packed.
582         if (!PackednessIsSignificant())
583             result |= kLinearPCMFormatFlagIsPacked;
584 
585         // Remove the high-aligned flag if alignment is irrelevant.
586         if (!AlignmentIsSignificant())
587             result &amp;= ~kLinearPCMFormatFlagIsAlignedHigh;
588 
589         // Remove the signed integer bit if it&#39;s float
590         if (result &amp; kLinearPCMFormatFlagIsFloat)
591             result &amp;= ~kLinearPCMFormatFlagIsSignedInteger;
592 
593         // If the bit depth is 8 bits or less and the format is packed, we don&#39;t care about endianness
594         if (mBitsPerChannel &lt;= 8 &amp;&amp; (result &amp; kLinearPCMFormatFlagIsPacked))
595             result &amp;= kAudioFormatFlagIsBigEndian;
596 
597         // If there is 1 channel, we don&#39;t care about non-interleavedness.
598         if (mChannelsPerFrame == 1)
599             result &amp;= ~kLinearPCMFormatFlagIsNonInterleaved;
600 
601         // Finally, if the bits really are all 0, set the AllClear flag.
602         if (result == 0)
603             result = kAudioFormatFlagsAreAllClear;
604     }
605     return result;
606 }
607 
608 // private
609 bool CAStreamBasicDescription::EquivalentFormatFlags(const AudioStreamBasicDescription &amp;x, const AudioStreamBasicDescription &amp;y, bool forHardware, bool usingWildcards)
610 {
611     if (usingWildcards)
612     {
613         // if either of the formats is a wildcard, we don&#39;t care about the flags
614         // if either of the flags is a wildcard, we have matched
615         if (x.mFormatID == 0 || y.mFormatID == 0 || x.mFormatFlags == 0 || y.mFormatFlags == 0)
616         {
617             return true;
618         }
619     }
620 
621     if (x.mFormatID != kAudioFormatLinearPCM) // we already know the formatID&#39;s match and have taken wildcards out of the picture.
622         return x.mFormatFlags == y.mFormatFlags;
623 
624     // It is safe to down-cast from AudioStreamBasicDescription to its C++ wrapper.
625     // The cast could be avoided with a copy, but here, efficiency matters.
626     const CAStreamBasicDescription &amp;a = *static_cast&lt;const CAStreamBasicDescription *&gt;(&amp;x);
627     const CAStreamBasicDescription &amp;b = *static_cast&lt;const CAStreamBasicDescription *&gt;(&amp;y);
628 
629     return a.GetRegularizedFormatFlags(forHardware) == b.GetRegularizedFormatFlags(forHardware);
630 }
631 
632 bool    CAStreamBasicDescription::IsExactlyEqual(const AudioStreamBasicDescription &amp;x, const AudioStreamBasicDescription &amp;y)
633 {
634     // mReserved didn&#39;t exist in early versions of OS X; we want to ignore differences there.
635     // The structure is properly packed up until that point, so the shortcut of using memcmp()
636     // instead of individual field comparisons is safe.
637     return memcmp(&amp;x, &amp;y, offsetof(AudioStreamBasicDescription, mReserved)) == 0;
638 }
639 
640 #define MATCH_WITH_WILDCARD(name) ((x.name) == 0 || (y.name) == 0 || (x.name) == (y.name))
641 
642 bool    CAStreamBasicDescription::IsEquivalent(const AudioStreamBasicDescription &amp;x, const AudioStreamBasicDescription &amp;y, ComparisonOptions options)
643 {
644     if (options &amp; kCompareUsingWildcards) {
645         return
646             //  check the sample rate
647             (fiszero(x.mSampleRate) || fiszero(y.mSampleRate) || fequal(x.mSampleRate, y.mSampleRate))
648 
649             //  check the format ids
650             &amp;&amp; MATCH_WITH_WILDCARD(mFormatID)
651 
652             //  check the bytes per packet
653             &amp;&amp; MATCH_WITH_WILDCARD(mBytesPerPacket)
654 
655             //  check the frames per packet
656             &amp;&amp; MATCH_WITH_WILDCARD(mFramesPerPacket)
657 
658             //  check the bytes per frame
659             &amp;&amp; MATCH_WITH_WILDCARD(mBytesPerFrame)
660 
661             //  check the channels per frame
662             &amp;&amp; MATCH_WITH_WILDCARD(mChannelsPerFrame)
663 
664             //  check the bits per channel
665             &amp;&amp; MATCH_WITH_WILDCARD(mBitsPerChannel)
666 
667             // Only if we get this far, do the work of matching the format flags
668             &amp;&amp; EquivalentFormatFlags(x, y, options &amp; kCompareForHardware, /*usingWildcards=*/true);
669     } else {
670         return  x.mSampleRate == y.mSampleRate
671             &amp;&amp;  x.mFormatID == y.mFormatID
672             &amp;&amp;  x.mBytesPerPacket == y.mBytesPerPacket
673             &amp;&amp;  x.mFramesPerPacket == y.mFramesPerPacket
674             &amp;&amp;  x.mChannelsPerFrame == y.mChannelsPerFrame
675             &amp;&amp;  x.mBitsPerChannel == y.mBitsPerChannel
676             &amp;&amp;  EquivalentFormatFlags(x, y, options &amp; kCompareForHardware, /*usingWildcards=*/false);
677     }
678 }
679 
680 // DEPRECATED.
681 bool    operator==(const AudioStreamBasicDescription&amp; x, const AudioStreamBasicDescription&amp; y)
682 {
683     return CAStreamBasicDescription::IsEquivalent(x, y, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
684 }
685 
686 // To be deprecated.
687 bool    CAStreamBasicDescription::IsEqual(const AudioStreamBasicDescription &amp;other, bool interpretingWildcards) const
688 {
689     if (interpretingWildcards)
690         return CAStreamBasicDescription::IsEquivalent(*this, other, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
691     return IsExactlyEqual(*this, other);
692 }
693 
694 // DEPRECATED.
695 bool    CAStreamBasicDescription::IsEqual(const AudioStreamBasicDescription &amp;other) const
696 {
697     return CAStreamBasicDescription::IsEquivalent(*this, other, CAStreamBasicDescription::kCompareUsingWildcards | CAStreamBasicDescription::kCompareForHardware);
698 }
699 
700 bool SanityCheck(const AudioStreamBasicDescription&amp; x)
701 {
702     // This function returns false if there are sufficiently insane values in any field.
703     // It is very conservative so even some very unlikely values will pass.
704     // This is just meant to catch the case where the data from a file is corrupted.
705 
706     return
707         (x.mSampleRate &gt;= 0.)
708         &amp;&amp; (x.mSampleRate &lt; 3e6)    // SACD sample rate is 2.8224 MHz
709         &amp;&amp; (x.mBytesPerPacket &lt; 1000000)
710         &amp;&amp; (x.mFramesPerPacket &lt; 1000000)
711         &amp;&amp; (x.mBytesPerFrame &lt; 1000000)
712         &amp;&amp; (x.mChannelsPerFrame &gt; 0)
713         &amp;&amp; (x.mChannelsPerFrame &lt;= 1024)
714         &amp;&amp; (x.mBitsPerChannel &lt;= 1024)
715         &amp;&amp; (x.mFormatID != 0)
716         &amp;&amp; !(x.mFormatID == kAudioFormatLinearPCM &amp;&amp; (x.mFramesPerPacket != 1 || x.mBytesPerPacket != x.mBytesPerFrame));
717 }
718 
719 bool CAStreamBasicDescription::FromText(const char *inTextDesc, AudioStreamBasicDescription &amp;fmt)
720 {
721     const char *p = inTextDesc;
722 
723     memset(&amp;fmt, 0, sizeof(fmt));
724 
725     bool isPCM = true;  // until proven otherwise
726     UInt32 pcmFlags = kAudioFormatFlagIsPacked | kAudioFormatFlagIsSignedInteger;
727 
728     if (p[0] == &#39;-&#39;)    // previously we required a leading dash on PCM formats
729         ++p;
730 
731     if (p[0] == &#39;B&#39; &amp;&amp; p[1] == &#39;E&#39;) {
732         pcmFlags |= kLinearPCMFormatFlagIsBigEndian;
733         p += 2;
734     } else if (p[0] == &#39;L&#39; &amp;&amp; p[1] == &#39;E&#39;) {
735         p += 2;
736     } else {
737         // default is native-endian
738 #if TARGET_RT_BIG_ENDIAN
739         pcmFlags |= kLinearPCMFormatFlagIsBigEndian;
740 #endif
741     }
742     if (p[0] == &#39;F&#39;) {
743         pcmFlags = (pcmFlags &amp; ~static_cast&lt;UInt32&gt;(kAudioFormatFlagIsSignedInteger)) | kAudioFormatFlagIsFloat;
744         ++p;
745     } else {
746         if (p[0] == &#39;U&#39;) {
747             pcmFlags &amp;= ~static_cast&lt;UInt32&gt;(kAudioFormatFlagIsSignedInteger);
748             ++p;
749         }
750         if (p[0] == &#39;I&#39;)
751             ++p;
752         else {
753             // it&#39;s not PCM; presumably some other format (NOT VALIDATED; use AudioFormat for that)
754             isPCM = false;
755             p = inTextDesc; // go back to the beginning
756             char buf[4] = { &#39; &#39;,&#39; &#39;,&#39; &#39;,&#39; &#39; };
757             for (int i = 0; i &lt; 4; ++i) {
758                 if (*p != &#39;\\&#39;) {
759                     if ((buf[i] = *p++) == &#39;\0&#39;) {
760                         // special-case for &#39;aac&#39;
761                         if (i != 3) return false;
762                         --p;    // keep pointing at the terminating null
763                         buf[i] = &#39; &#39;;
764                         break;
765                     }
766                 } else {
767                     // &quot;\xNN&quot; is a hex byte
768                     if (*++p != &#39;x&#39;) return false;
769                     int x;
770                     if (sscanf(++p, &quot;%02X&quot;, &amp;x) != 1) return false;
771                     buf[i] = static_cast&lt;char&gt;(x);
772                     p += 2;
773                 }
774             }
775 
776             if (strchr(&quot;-@/#&quot;, buf[3])) {
777                 // further special-casing for &#39;aac&#39;
778                 buf[3] = &#39; &#39;;
779                 --p;
780             }
781 
782             memcpy(&amp;fmt.mFormatID, buf, 4);
783             fmt.mFormatID = CFSwapInt32BigToHost(fmt.mFormatID);
784         }
785     }
786 
787     if (isPCM) {
788         fmt.mFormatID = kAudioFormatLinearPCM;
789         fmt.mFormatFlags = pcmFlags;
790         fmt.mFramesPerPacket = 1;
791         fmt.mChannelsPerFrame = 1;
792         UInt32 bitdepth = 0, fracbits = 0;
793         while (isdigit(*p))
794             bitdepth = 10 * bitdepth + static_cast&lt;UInt32&gt;(*p++ - &#39;0&#39;);
795         if (*p == &#39;.&#39;) {
796             ++p;
797             if (!isdigit(*p)) {
798                 fprintf(stderr, &quot;Expected fractional bits following &#39;.&#39;\n&quot;);
799                 goto Bail;
800             }
801             while (isdigit(*p))
802                 fracbits = 10 * fracbits + static_cast&lt;UInt32&gt;(*p++ - &#39;0&#39;);
803             bitdepth += fracbits;
804             fmt.mFormatFlags |= (fracbits &lt;&lt; kLinearPCMFormatFlagsSampleFractionShift);
805         }
806         fmt.mBitsPerChannel = bitdepth;
807         fmt.mBytesPerPacket = fmt.mBytesPerFrame = (bitdepth + 7) / 8;
808         if (bitdepth &amp; 7) {
809             // assume unpacked. (packed odd bit depths are describable but not supported in AudioConverter.)
810             fmt.mFormatFlags &amp;= ~static_cast&lt;UInt32&gt;(kLinearPCMFormatFlagIsPacked);
811             // alignment matters; default to high-aligned. use &#39;:L_&#39; for low.
812             fmt.mFormatFlags |= kLinearPCMFormatFlagIsAlignedHigh;
813         }
814     }
815     if (*p == &#39;@&#39;) {
816         ++p;
817         while (isdigit(*p))
818             fmt.mSampleRate = 10 * fmt.mSampleRate + (*p++ - &#39;0&#39;);
819     }
820     if (*p == &#39;/&#39;) {
821         UInt32 flags = 0;
822         while (true) {
823             char c = *++p;
824             if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
825                 flags = (flags &lt;&lt; 4) | static_cast&lt;UInt32&gt;(c - &#39;0&#39;);
826             else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
827                 flags = (flags &lt;&lt; 4) | static_cast&lt;UInt32&gt;(c - &#39;A&#39; + 10);
828             else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
829                 flags = (flags &lt;&lt; 4) | static_cast&lt;UInt32&gt;(c - &#39;a&#39; + 10);
830             else break;
831         }
832         fmt.mFormatFlags = flags;
833     }
834     if (*p == &#39;#&#39;) {
835         ++p;
836         while (isdigit(*p))
837             fmt.mFramesPerPacket = 10 * fmt.mFramesPerPacket + static_cast&lt;UInt32&gt;(*p++ - &#39;0&#39;);
838     }
839     if (*p == &#39;:&#39;) {
840         ++p;
841         fmt.mFormatFlags &amp;= ~static_cast&lt;UInt32&gt;(kLinearPCMFormatFlagIsPacked);
842         if (*p == &#39;L&#39;)
843             fmt.mFormatFlags &amp;= ~static_cast&lt;UInt32&gt;(kLinearPCMFormatFlagIsAlignedHigh);
844         else if (*p == &#39;H&#39;)
845             fmt.mFormatFlags |= kLinearPCMFormatFlagIsAlignedHigh;
846         else
847             goto Bail;
848         ++p;
849         UInt32 bytesPerFrame = 0;
850         while (isdigit(*p))
851             bytesPerFrame = 10 * bytesPerFrame + static_cast&lt;UInt32&gt;(*p++ - &#39;0&#39;);
852         fmt.mBytesPerFrame = fmt.mBytesPerPacket = bytesPerFrame;
853     }
854     if (*p == &#39;,&#39;) {
855         ++p;
856         int ch = 0;
857         while (isdigit(*p))
858             ch = 10 * ch + (*p++ - &#39;0&#39;);
859         fmt.mChannelsPerFrame = static_cast&lt;UInt32&gt;(ch);
860         if (*p == &#39;D&#39;) {
861             ++p;
862             if (fmt.mFormatID != kAudioFormatLinearPCM) {
863                 fprintf(stderr, &quot;non-interleaved flag invalid for non-PCM formats\n&quot;);
864                 goto Bail;
865             }
866             fmt.mFormatFlags |= kAudioFormatFlagIsNonInterleaved;
867         } else {
868             if (*p == &#39;I&#39;) ++p; // default
869             if (fmt.mFormatID == kAudioFormatLinearPCM)
870                 fmt.mBytesPerPacket = fmt.mBytesPerFrame *= static_cast&lt;UInt32&gt;(ch);
871         }
872     }
873     if (*p != &#39;\0&#39;) {
874         fprintf(stderr, &quot;extra characters at end of format string: %s\n&quot;, p);
875         goto Bail;
876     }
877     return true;
878 
879 Bail:
880     fprintf(stderr, &quot;Invalid format string: %s\n&quot;, inTextDesc);
881     fprintf(stderr, &quot;Syntax of format strings is: \n&quot;);
882     return false;
883 }
884 
885 const char *CAStreamBasicDescription::sTextParsingUsageString =
886     &quot;format[@sample_rate_hz][/format_flags][#frames_per_packet][:LHbytesPerFrame][,channelsDI].\n&quot;
887     &quot;Format for PCM is [-][BE|LE]{F|I|UI}{bitdepth}; else a 4-char format code (e.g. aac, alac).\n&quot;;
    </pre>
  </body>
</html>