<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   5  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   6  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;HTMLElement.h&quot;
  27 
  28 #include &quot;CSSMarkup.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSValueKeywords.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;DOMTokenList.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;ElementAncestorIterator.h&quot;
  37 #include &quot;Event.h&quot;
  38 #include &quot;EventListener.h&quot;
  39 #include &quot;EventNames.h&quot;
  40 #include &quot;Frame.h&quot;
  41 #include &quot;FrameLoader.h&quot;
  42 #include &quot;FrameView.h&quot;
  43 #include &quot;HTMLBDIElement.h&quot;
  44 #include &quot;HTMLBRElement.h&quot;
  45 #include &quot;HTMLButtonElement.h&quot;
  46 #include &quot;HTMLCollection.h&quot;
  47 #include &quot;HTMLDocument.h&quot;
  48 #include &quot;HTMLElementFactory.h&quot;
  49 #include &quot;HTMLFieldSetElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLNames.h&quot;
  53 #include &quot;HTMLOptGroupElement.h&quot;
  54 #include &quot;HTMLOptionElement.h&quot;
  55 #include &quot;HTMLParserIdioms.h&quot;
  56 #include &quot;HTMLSelectElement.h&quot;
  57 #include &quot;HTMLTextAreaElement.h&quot;
  58 #include &quot;HTMLTextFormControlElement.h&quot;
  59 #include &quot;NodeTraversal.h&quot;
  60 #include &quot;RenderElement.h&quot;
  61 #include &quot;ScriptController.h&quot;
  62 #include &quot;ShadowRoot.h&quot;
  63 #include &quot;SimulatedClick.h&quot;
  64 #include &quot;StyleProperties.h&quot;
  65 #include &quot;SubframeLoader.h&quot;
  66 #include &quot;Text.h&quot;
  67 #include &quot;XMLNames.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/IsoMallocInlines.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/StdLibExtras.h&gt;
  72 #include &lt;wtf/text/CString.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLElement);
  77 
  78 using namespace HTMLNames;
  79 
  80 Ref&lt;HTMLElement&gt; HTMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  81 {
  82     return adoptRef(*new HTMLElement(tagName, document));
  83 }
  84 
  85 String HTMLElement::nodeName() const
  86 {
<a name="1" id="anc1"></a><span class="line-modified">  87     // FIXME: Would be nice to have an AtomString lookup based off uppercase</span>
  88     // ASCII characters that does not have to copy the string on a hit in the hash.
  89     if (document().isHTMLDocument()) {
  90         if (LIKELY(!tagQName().hasPrefix()))
  91             return tagQName().localNameUpper();
  92         return Element::nodeName().convertToASCIIUppercase();
  93     }
  94     return Element::nodeName();
  95 }
  96 
  97 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  98 {
  99     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 100         return CSSValuePlaintext;
 101     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 102     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 103     return CSSValueIsolate;
 104 }
 105 
<a name="2" id="anc2"></a><span class="line-modified"> 106 unsigned HTMLElement::parseBorderWidthAttribute(const AtomString&amp; value) const</span>
 107 {
 108     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 109         return optionalBorderWidth.value();
 110 
 111     return hasTagName(tableTag) ? 1 : 0;
 112 }
 113 
<a name="3" id="anc3"></a><span class="line-modified"> 114 void HTMLElement::applyBorderAttributeToStyle(const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 115 {
 116     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 118 }
 119 
<a name="4" id="anc4"></a><span class="line-modified"> 120 void HTMLElement::mapLanguageAttributeToLocale(const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 121 {
 122     if (!value.isEmpty()) {
 123         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 124         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 125     } else {
 126         // The empty string means the language is explicitly unknown.
 127         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 128     }
 129 }
 130 
 131 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 132 {
 133     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 134         return true;
 135     return StyledElement::isPresentationAttribute(name);
 136 }
 137 
<a name="5" id="anc5"></a><span class="line-modified"> 138 static bool isLTROrRTLIgnoringCase(const AtomString&amp; dirAttributeValue)</span>
 139 {
 140     return equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;);
 141 }
 142 
 143 enum class ContentEditableType {
 144     Inherit,
 145     True,
 146     False,
 147     PlaintextOnly
 148 };
 149 
<a name="6" id="anc6"></a><span class="line-modified"> 150 static inline ContentEditableType contentEditableType(const AtomString&amp; value)</span>
 151 {
 152     if (value.isNull())
 153         return ContentEditableType::Inherit;
 154     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
 155         return ContentEditableType::True;
 156     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 157         return ContentEditableType::False;
 158     if (equalLettersIgnoringASCIICase(value, &quot;plaintext-only&quot;))
 159         return ContentEditableType::PlaintextOnly;
 160 
 161     return ContentEditableType::Inherit;
 162 }
 163 
 164 static ContentEditableType contentEditableType(const HTMLElement&amp; element)
 165 {
 166     return contentEditableType(element.attributeWithoutSynchronization(contenteditableAttr));
 167 }
 168 
<a name="7" id="anc7"></a><span class="line-modified"> 169 void HTMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 170 {
 171     if (name == alignAttr) {
 172         if (equalLettersIgnoringASCIICase(value, &quot;middle&quot;))
 173             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, CSSValueCenter);
 174         else
 175             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, value);
 176     } else if (name == contenteditableAttr) {
 177         CSSValueID userModifyValue = CSSValueReadWrite;
 178         switch (contentEditableType(value)) {
 179         case ContentEditableType::Inherit:
 180             return;
 181         case ContentEditableType::False:
 182             userModifyValue = CSSValueReadOnly;
 183             break;
 184         case ContentEditableType::PlaintextOnly:
 185             userModifyValue = CSSValueReadWritePlaintextOnly;
 186             FALLTHROUGH;
 187         case ContentEditableType::True:
 188             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
 189             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitNbspMode, CSSValueSpace);
 190             addPropertyToPresentationAttributeStyle(style, CSSPropertyLineBreak, CSSValueAfterWhiteSpace);
 191 #if PLATFORM(IOS_FAMILY)
 192             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitTextSizeAdjust, CSSValueNone);
 193 #endif
 194             break;
 195         }
 196         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserModify, userModifyValue);
 197     } else if (name == hiddenAttr) {
 198         addPropertyToPresentationAttributeStyle(style, CSSPropertyDisplay, CSSValueNone);
 199     } else if (name == draggableAttr) {
 200         if (equalLettersIgnoringASCIICase(value, &quot;true&quot;)) {
 201             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueElement);
 202             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserSelect, CSSValueNone);
 203         } else if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 204             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueNone);
 205     } else if (name == dirAttr) {
 206         if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 207             addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, unicodeBidiAttributeForDirAuto(*this));
 208         else {
 209             if (isLTROrRTLIgnoringCase(value))
 210                 addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
 211             if (!hasTagName(bdiTag) &amp;&amp; !hasTagName(bdoTag) &amp;&amp; !hasTagName(outputTag))
 212                 addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, CSSValueEmbed);
 213         }
 214     } else if (name.matches(XMLNames::langAttr))
 215         mapLanguageAttributeToLocale(value, style);
 216     else if (name == langAttr) {
 217         // xml:lang has a higher priority than lang.
 218         if (!hasAttributeWithoutSynchronization(XMLNames::langAttr))
 219             mapLanguageAttributeToLocale(value, style);
 220     } else
 221         StyledElement::collectStyleForPresentationAttribute(name, value, style);
 222 }
 223 
 224 HTMLElement::EventHandlerNameMap HTMLElement::createEventHandlerNameMap()
 225 {
 226     EventHandlerNameMap map;
 227 
 228     static const QualifiedName* const table[] = {
 229         &amp;onabortAttr.get(),
<a name="8" id="anc8"></a>








 230         &amp;onanimationendAttr.get(),
 231         &amp;onanimationiterationAttr.get(),
 232         &amp;onanimationstartAttr.get(),
 233         &amp;onanimationcancelAttr.get(),
 234         &amp;onautocompleteAttr.get(),
 235         &amp;onautocompleteerrorAttr.get(),
 236         &amp;onbeforecopyAttr.get(),
 237         &amp;onbeforecutAttr.get(),
 238         &amp;onbeforeinputAttr.get(),
 239         &amp;onbeforeloadAttr.get(),
 240         &amp;onbeforepasteAttr.get(),
 241         &amp;onblurAttr.get(),
 242         &amp;oncanplayAttr.get(),
 243         &amp;oncanplaythroughAttr.get(),
 244         &amp;onchangeAttr.get(),
 245         &amp;onclickAttr.get(),
 246         &amp;oncontextmenuAttr.get(),
 247         &amp;oncopyAttr.get(),
 248         &amp;oncutAttr.get(),
 249         &amp;ondblclickAttr.get(),
 250         &amp;ondragAttr.get(),
 251         &amp;ondragendAttr.get(),
 252         &amp;ondragenterAttr.get(),
 253         &amp;ondragleaveAttr.get(),
 254         &amp;ondragoverAttr.get(),
 255         &amp;ondragstartAttr.get(),
 256         &amp;ondropAttr.get(),
 257         &amp;ondurationchangeAttr.get(),
 258         &amp;onemptiedAttr.get(),
 259         &amp;onendedAttr.get(),
 260         &amp;onerrorAttr.get(),
 261         &amp;onfocusAttr.get(),
 262         &amp;onfocusinAttr.get(),
 263         &amp;onfocusoutAttr.get(),
 264         &amp;ongesturechangeAttr.get(),
 265         &amp;ongestureendAttr.get(),
 266         &amp;ongesturestartAttr.get(),
<a name="9" id="anc9"></a><span class="line-added"> 267         &amp;ongotpointercaptureAttr.get(),</span>
 268         &amp;oninputAttr.get(),
 269         &amp;oninvalidAttr.get(),
 270         &amp;onkeydownAttr.get(),
 271         &amp;onkeypressAttr.get(),
 272         &amp;onkeyupAttr.get(),
 273         &amp;onloadAttr.get(),
 274         &amp;onloadeddataAttr.get(),
 275         &amp;onloadedmetadataAttr.get(),
 276         &amp;onloadstartAttr.get(),
<a name="10" id="anc10"></a><span class="line-added"> 277         &amp;onlostpointercaptureAttr.get(),</span>
 278         &amp;onmousedownAttr.get(),
 279         &amp;onmouseenterAttr.get(),
 280         &amp;onmouseleaveAttr.get(),
 281         &amp;onmousemoveAttr.get(),
 282         &amp;onmouseoutAttr.get(),
 283         &amp;onmouseoverAttr.get(),
 284         &amp;onmouseupAttr.get(),
 285         &amp;onmousewheelAttr.get(),
 286         &amp;onpasteAttr.get(),
 287         &amp;onpauseAttr.get(),
 288         &amp;onplayAttr.get(),
 289         &amp;onplayingAttr.get(),
<a name="11" id="anc11"></a><span class="line-added"> 290         &amp;onpointerdownAttr.get(),</span>
<span class="line-added"> 291         &amp;onpointermoveAttr.get(),</span>
<span class="line-added"> 292         &amp;onpointerupAttr.get(),</span>
<span class="line-added"> 293         &amp;onpointercancelAttr.get(),</span>
<span class="line-added"> 294         &amp;onpointeroverAttr.get(),</span>
<span class="line-added"> 295         &amp;onpointeroutAttr.get(),</span>
<span class="line-added"> 296         &amp;onpointerenterAttr.get(),</span>
<span class="line-added"> 297         &amp;onpointerleaveAttr.get(),</span>
 298         &amp;onprogressAttr.get(),
 299         &amp;onratechangeAttr.get(),
 300         &amp;onresetAttr.get(),
 301         &amp;onresizeAttr.get(),
 302         &amp;onscrollAttr.get(),
 303         &amp;onsearchAttr.get(),
 304         &amp;onseekedAttr.get(),
 305         &amp;onseekingAttr.get(),
 306         &amp;onselectAttr.get(),
 307         &amp;onselectstartAttr.get(),
 308         &amp;onstalledAttr.get(),
 309         &amp;onsubmitAttr.get(),
 310         &amp;onsuspendAttr.get(),
 311         &amp;ontimeupdateAttr.get(),
 312         &amp;ontoggleAttr.get(),
 313         &amp;ontouchcancelAttr.get(),
 314         &amp;ontouchendAttr.get(),
 315         &amp;ontouchforcechangeAttr.get(),
 316         &amp;ontouchmoveAttr.get(),
 317         &amp;ontouchstartAttr.get(),
 318         &amp;ontransitioncancelAttr.get(),
 319         &amp;ontransitionendAttr.get(),
 320         &amp;ontransitionrunAttr.get(),
 321         &amp;ontransitionstartAttr.get(),
 322         &amp;onvolumechangeAttr.get(),
 323         &amp;onwaitingAttr.get(),
 324         &amp;onwebkitbeginfullscreenAttr.get(),
 325         &amp;onwebkitcurrentplaybacktargetiswirelesschangedAttr.get(),
 326         &amp;onwebkitendfullscreenAttr.get(),
 327         &amp;onwebkitfullscreenchangeAttr.get(),
 328         &amp;onwebkitfullscreenerrorAttr.get(),
 329         &amp;onwebkitkeyaddedAttr.get(),
 330         &amp;onwebkitkeyerrorAttr.get(),
 331         &amp;onwebkitkeymessageAttr.get(),
 332         &amp;onwebkitmouseforcechangedAttr.get(),
 333         &amp;onwebkitmouseforcedownAttr.get(),
 334         &amp;onwebkitmouseforcewillbeginAttr.get(),
 335         &amp;onwebkitmouseforceupAttr.get(),
 336         &amp;onwebkitneedkeyAttr.get(),
 337         &amp;onwebkitplaybacktargetavailabilitychangedAttr.get(),
 338         &amp;onwebkitpresentationmodechangedAttr.get(),
 339         &amp;onwebkitwillrevealbottomAttr.get(),
 340         &amp;onwebkitwillrevealleftAttr.get(),
 341         &amp;onwebkitwillrevealrightAttr.get(),
 342         &amp;onwebkitwillrevealtopAttr.get(),
 343         &amp;onwheelAttr.get(),
 344     };
 345 
 346     populateEventHandlerNameMap(map, table);
 347 
 348     struct UnusualMapping {
 349         const QualifiedName&amp; attributeName;
<a name="12" id="anc12"></a><span class="line-modified"> 350         const AtomString&amp; eventName;</span>
 351     };
 352 
 353     const UnusualMapping unusualPairsTable[] = {
 354         { onwebkitanimationendAttr, eventNames().webkitAnimationEndEvent },
 355         { onwebkitanimationiterationAttr, eventNames().webkitAnimationIterationEvent },
 356         { onwebkitanimationstartAttr, eventNames().webkitAnimationStartEvent },
 357         { onwebkittransitionendAttr, eventNames().webkitTransitionEndEvent },
 358     };
 359 
 360     for (auto&amp; entry : unusualPairsTable)
 361         map.add(entry.attributeName.localName().impl(), entry.eventName);
 362 
 363     return map;
 364 }
 365 
 366 void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const table[], size_t tableSize)
 367 {
 368     for (size_t i = 0; i &lt; tableSize; ++i) {
 369         auto* entry = table[i];
 370 
 371         // FIXME: Would be nice to check these against the actual event names in eventNames().
 372         // Not obvious how to do that simply, though.
 373         auto&amp; attributeName = entry-&gt;localName();
 374 
 375         // Remove the &quot;on&quot; prefix. Requires some memory allocation and computing a hash, but by not
 376         // using pointers from eventNames(), the passed-in table can be initialized at compile time.
<a name="13" id="anc13"></a><span class="line-modified"> 377         AtomString eventName = attributeName.string().substring(2);</span>
 378 
 379         map.add(attributeName.impl(), WTFMove(eventName));
 380     }
 381 }
 382 
<a name="14" id="anc14"></a><span class="line-modified"> 383 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp; map)</span>
 384 {
 385     ASSERT(!attributeName.localName().isNull());
 386 
 387     // Event handler attributes have no namespace.
 388     if (!attributeName.namespaceURI().isNull())
 389         return nullAtom();
 390 
 391     // Fast early return for names that don&#39;t start with &quot;on&quot;.
<a name="15" id="anc15"></a><span class="line-modified"> 392     AtomStringImpl&amp; localName = *attributeName.localName().impl();</span>
 393     if (localName.length() &lt; 3 || localName[0] != &#39;o&#39; || localName[1] != &#39;n&#39;)
 394         return nullAtom();
 395 
 396     auto it = map.find(&amp;localName);
 397     return it == map.end() ? nullAtom() : it-&gt;value;
 398 }
 399 
<a name="16" id="anc16"></a><span class="line-modified"> 400 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName)</span>
 401 {
 402     static NeverDestroyed&lt;EventHandlerNameMap&gt; map = createEventHandlerNameMap();
 403     return eventNameForEventHandlerAttribute(attributeName, map.get());
 404 }
 405 
 406 Node::Editability HTMLElement::editabilityFromContentEditableAttr(const Node&amp; node)
 407 {
 408     if (auto* startElement = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement()) {
 409         for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*startElement)) {
 410             switch (contentEditableType(element)) {
 411             case ContentEditableType::True:
 412                 return Editability::CanEditRichly;
 413             case ContentEditableType::PlaintextOnly:
 414                 return Editability::CanEditPlainText;
 415             case ContentEditableType::False:
 416                 return Editability::ReadOnly;
 417             case ContentEditableType::Inherit:
 418                 break;
 419             }
 420         }
 421     }
 422 
 423     auto containingShadowRoot = makeRefPtr(node.containingShadowRoot());
 424     if (containingShadowRoot &amp;&amp; containingShadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
 425         return Editability::ReadOnly;
 426 
 427     auto&amp; document = node.document();
 428     if (is&lt;HTMLDocument&gt;(document))
 429         return downcast&lt;HTMLDocument&gt;(document).inDesignMode() ? Editability::CanEditRichly : Editability::ReadOnly;
 430 
 431     return Editability::ReadOnly;
 432 }
 433 
 434 bool HTMLElement::matchesReadWritePseudoClass() const
 435 {
 436     return editabilityFromContentEditableAttr(*this) != Editability::ReadOnly;
 437 }
 438 
<a name="17" id="anc17"></a><span class="line-modified"> 439 void HTMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 440 {
 441     if (name == dirAttr) {
 442         dirAttributeChanged(value);
 443         return;
 444     }
 445 
 446     if (name == tabindexAttr) {
 447         if (value.isEmpty())
 448             clearTabIndexExplicitlyIfNeeded();
 449         else if (auto optionalTabIndex = parseHTMLInteger(value))
 450             setTabIndexExplicitly(optionalTabIndex.value());
 451         return;
 452     }
 453 
 454     if (name == inputmodeAttr) {
 455         auto&amp; document = this-&gt;document();
 456         if (this == document.focusedElement()) {
 457             if (auto* page = document.page())
 458                 page-&gt;chrome().client().focusedElementDidChangeInputMode(*this, canonicalInputMode());
 459         }
 460     }
 461 
 462     auto&amp; eventName = eventNameForEventHandlerAttribute(name);
 463     if (!eventName.isNull())
 464         setAttributeEventListener(eventName, name, value);
 465 }
 466 
 467 static Ref&lt;DocumentFragment&gt; textToFragment(Document&amp; document, const String&amp; text)
 468 {
 469     auto fragment = DocumentFragment::create(document);
 470 
 471     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 472     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment);
 473 
 474     for (unsigned start = 0, length = text.length(); start &lt; length; ) {
 475         // Find next line break.
 476         UChar c = 0;
 477         unsigned i;
 478         for (i = start; i &lt; length; i++) {
 479             c = text[i];
 480             if (c == &#39;\r&#39; || c == &#39;\n&#39;)
 481                 break;
 482         }
 483 
 484         // If text is not the empty string, then append a new Text node whose data is text and node document is document to fragment.
 485         if (i &gt; start)
 486             fragment-&gt;appendChild(Text::create(document, text.substring(start, i - start)));
 487 
 488         if (i == length)
 489             break;
 490 
 491         fragment-&gt;appendChild(HTMLBRElement::create(document));
 492         // Make sure \r\n doesn&#39;t result in two line breaks.
 493         if (c == &#39;\r&#39; &amp;&amp; i + 1 &lt; length &amp;&amp; text[i + 1] == &#39;\n&#39;)
 494             ++i;
 495 
 496         start = i + 1; // Character after line break.
 497     }
 498 
 499     return fragment;
 500 }
 501 
 502 // Returns the conforming &#39;dir&#39; value associated with the state the attribute is in (in its canonical case), if any,
 503 // or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is
 504 // not in a defined state (e.g. the attribute is missing and there is no missing value default).
 505 // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#limited-to-only-known-values
<a name="18" id="anc18"></a><span class="line-modified"> 506 static inline const AtomString&amp; toValidDirValue(const AtomString&amp; value)</span>
 507 {
<a name="19" id="anc19"></a><span class="line-modified"> 508     static NeverDestroyed&lt;AtomString&gt; ltrValue(&quot;ltr&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified"> 509     static NeverDestroyed&lt;AtomString&gt; rtlValue(&quot;rtl&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified"> 510     static NeverDestroyed&lt;AtomString&gt; autoValue(&quot;auto&quot;, AtomString::ConstructFromLiteral);</span>
 511     if (equalLettersIgnoringASCIICase(value, &quot;ltr&quot;))
 512         return ltrValue;
 513     if (equalLettersIgnoringASCIICase(value, &quot;rtl&quot;))
 514         return rtlValue;
 515     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 516         return autoValue;
 517     return nullAtom();
 518 }
 519 
<a name="20" id="anc20"></a><span class="line-modified"> 520 const AtomString&amp; HTMLElement::dir() const</span>
 521 {
 522     return toValidDirValue(attributeWithoutSynchronization(dirAttr));
 523 }
 524 
<a name="21" id="anc21"></a><span class="line-modified"> 525 void HTMLElement::setDir(const AtomString&amp; value)</span>
 526 {
 527     setAttributeWithoutSynchronization(dirAttr, value);
 528 }
 529 
 530 ExceptionOr&lt;void&gt; HTMLElement::setInnerText(const String&amp; text)
 531 {
 532     // FIXME: This doesn&#39;t take whitespace collapsing into account at all.
 533 
 534     if (!text.contains(&#39;\n&#39;) &amp;&amp; !text.contains(&#39;\r&#39;)) {
 535         if (text.isEmpty())
 536             replaceAllChildren(nullptr);
 537         else
 538             replaceAllChildren(document().createTextNode(text));
 539         return { };
 540     }
 541 
 542     // FIXME: Do we need to be able to detect preserveNewline style even when there&#39;s no renderer?
 543     // FIXME: Can the renderer be out of date here? Do we need to call updateStyleIfNeeded?
 544     // For example, for the contents of textarea elements that are display:none?
 545     auto* r = renderer();
 546     if ((r &amp;&amp; r-&gt;style().preserveNewline()) || (isConnected() &amp;&amp; isTextControlInnerTextElement())) {
 547         if (!text.contains(&#39;\r&#39;)) {
 548             replaceAllChildren(document().createTextNode(text));
 549             return { };
 550         }
 551         String textWithConsistentLineBreaks = text;
 552         textWithConsistentLineBreaks.replace(&quot;\r\n&quot;, &quot;\n&quot;);
 553         textWithConsistentLineBreaks.replace(&#39;\r&#39;, &#39;\n&#39;);
 554         replaceAllChildren(document().createTextNode(textWithConsistentLineBreaks));
 555         return { };
 556     }
 557 
 558     // Add text nodes and &lt;br&gt; elements.
 559     auto fragment = textToFragment(document(), text);
 560     // FIXME: This should use replaceAllChildren() once it accepts DocumentFragments as input.
 561     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 562     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment.get());
 563     return replaceChildrenWithFragment(*this, WTFMove(fragment));
 564 }
 565 
 566 ExceptionOr&lt;void&gt; HTMLElement::setOuterText(const String&amp; text)
 567 {
 568     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 569     if (!parent)
 570         return Exception { NoModificationAllowedError };
 571 
 572     RefPtr&lt;Node&gt; prev = previousSibling();
 573     RefPtr&lt;Node&gt; next = nextSibling();
 574     RefPtr&lt;Node&gt; newChild;
 575 
 576     // Convert text to fragment with &lt;br&gt; tags instead of linebreaks if needed.
 577     if (text.contains(&#39;\r&#39;) || text.contains(&#39;\n&#39;))
 578         newChild = textToFragment(document(), text);
 579     else
 580         newChild = Text::create(document(), text);
 581 
 582     if (!parentNode())
 583         return Exception { HierarchyRequestError };
 584 
 585     auto replaceResult = parent-&gt;replaceChild(*newChild, *this);
 586     if (replaceResult.hasException())
 587         return replaceResult.releaseException();
 588 
 589     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
 590     if (is&lt;Text&gt;(node)) {
 591         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
 592         if (result.hasException())
 593             return result.releaseException();
 594     }
 595     if (is&lt;Text&gt;(prev)) {
 596         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
 597         if (result.hasException())
 598             return result.releaseException();
 599     }
 600     return { };
 601 }
 602 
<a name="22" id="anc22"></a><span class="line-modified"> 603 void HTMLElement::applyAlignmentAttributeToStyle(const AtomString&amp; alignment, MutableStyleProperties&amp; style)</span>
 604 {
 605     // Vertical alignment with respect to the current baseline of the text
 606     // right or left means floating images.
 607     CSSValueID floatValue = CSSValueInvalid;
 608     CSSValueID verticalAlignValue = CSSValueInvalid;
 609 
 610     if (equalLettersIgnoringASCIICase(alignment, &quot;absmiddle&quot;))
 611         verticalAlignValue = CSSValueMiddle;
 612     else if (equalLettersIgnoringASCIICase(alignment, &quot;absbottom&quot;))
 613         verticalAlignValue = CSSValueBottom;
 614     else if (equalLettersIgnoringASCIICase(alignment, &quot;left&quot;)) {
 615         floatValue = CSSValueLeft;
 616         verticalAlignValue = CSSValueTop;
 617     } else if (equalLettersIgnoringASCIICase(alignment, &quot;right&quot;)) {
 618         floatValue = CSSValueRight;
 619         verticalAlignValue = CSSValueTop;
 620     } else if (equalLettersIgnoringASCIICase(alignment, &quot;top&quot;))
 621         verticalAlignValue = CSSValueTop;
 622     else if (equalLettersIgnoringASCIICase(alignment, &quot;middle&quot;))
 623         verticalAlignValue = CSSValueWebkitBaselineMiddle;
 624     else if (equalLettersIgnoringASCIICase(alignment, &quot;center&quot;))
 625         verticalAlignValue = CSSValueMiddle;
 626     else if (equalLettersIgnoringASCIICase(alignment, &quot;bottom&quot;))
 627         verticalAlignValue = CSSValueBaseline;
 628     else if (equalLettersIgnoringASCIICase(alignment, &quot;texttop&quot;))
 629         verticalAlignValue = CSSValueTextTop;
 630 
 631     if (floatValue != CSSValueInvalid)
 632         addPropertyToPresentationAttributeStyle(style, CSSPropertyFloat, floatValue);
 633 
 634     if (verticalAlignValue != CSSValueInvalid)
 635         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, verticalAlignValue);
 636 }
 637 
 638 bool HTMLElement::hasCustomFocusLogic() const
 639 {
 640     return false;
 641 }
 642 
 643 bool HTMLElement::supportsFocus() const
 644 {
 645     return Element::supportsFocus() || (hasEditableStyle() &amp;&amp; parentNode() &amp;&amp; !parentNode()-&gt;hasEditableStyle());
 646 }
 647 
 648 String HTMLElement::contentEditable() const
 649 {
 650     switch (contentEditableType(*this)) {
 651     case ContentEditableType::Inherit:
 652         return &quot;inherit&quot;_s;
 653     case ContentEditableType::True:
 654         return &quot;true&quot;_s;
 655     case ContentEditableType::False:
 656         return &quot;false&quot;_s;
 657     case ContentEditableType::PlaintextOnly:
 658         return &quot;plaintext-only&quot;_s;
 659     }
 660     return &quot;inherit&quot;_s;
 661 }
 662 
 663 ExceptionOr&lt;void&gt; HTMLElement::setContentEditable(const String&amp; enabled)
 664 {
 665     if (equalLettersIgnoringASCIICase(enabled, &quot;true&quot;))
<a name="23" id="anc23"></a><span class="line-modified"> 666         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral));</span>
 667     else if (equalLettersIgnoringASCIICase(enabled, &quot;false&quot;))
<a name="24" id="anc24"></a><span class="line-modified"> 668         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 669     else if (equalLettersIgnoringASCIICase(enabled, &quot;plaintext-only&quot;))
<a name="25" id="anc25"></a><span class="line-modified"> 670         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;plaintext-only&quot;, AtomString::ConstructFromLiteral));</span>
 671     else if (equalLettersIgnoringASCIICase(enabled, &quot;inherit&quot;))
 672         removeAttribute(contenteditableAttr);
 673     else
 674         return Exception { SyntaxError };
 675     return { };
 676 }
 677 
 678 bool HTMLElement::draggable() const
 679 {
 680     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;true&quot;);
 681 }
 682 
 683 void HTMLElement::setDraggable(bool value)
 684 {
 685     setAttributeWithoutSynchronization(draggableAttr, value
<a name="26" id="anc26"></a><span class="line-modified"> 686         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)</span>
<span class="line-modified"> 687         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 688 }
 689 
 690 bool HTMLElement::spellcheck() const
 691 {
 692     return isSpellCheckingEnabled();
 693 }
 694 
 695 void HTMLElement::setSpellcheck(bool enable)
 696 {
 697     setAttributeWithoutSynchronization(spellcheckAttr, enable
<a name="27" id="anc27"></a><span class="line-modified"> 698         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)</span>
<span class="line-modified"> 699         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 700 }
 701 
 702 void HTMLElement::click()
 703 {
 704     simulateClick(*this, nullptr, SendNoEvents, DoNotShowPressedLook, SimulatedClickSource::Bindings);
 705 }
 706 
 707 void HTMLElement::accessKeyAction(bool sendMouseEvents)
 708 {
 709     dispatchSimulatedClick(nullptr, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 710 }
 711 
 712 String HTMLElement::title() const
 713 {
 714     return attributeWithoutSynchronization(titleAttr);
 715 }
 716 
<a name="28" id="anc28"></a>






 717 bool HTMLElement::translate() const
 718 {
 719     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
<a name="29" id="anc29"></a><span class="line-modified"> 720         const AtomString&amp; value = element.attributeWithoutSynchronization(translateAttr);</span>
 721         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 722             return true;
 723         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 724             return false;
 725     }
 726     // Default on the root element is translate=yes.
 727     return true;
 728 }
 729 
 730 void HTMLElement::setTranslate(bool enable)
 731 {
 732     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 733 }
 734 
 735 bool HTMLElement::rendererIsNeeded(const RenderStyle&amp; style)
 736 {
 737     if (hasTagName(noscriptTag)) {
 738         RefPtr&lt;Frame&gt; frame = document().frame();
 739         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 740             return false;
 741     } else if (hasTagName(noembedTag)) {
 742         RefPtr&lt;Frame&gt; frame = document().frame();
 743         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 744             return false;
 745     }
 746     return StyledElement::rendererIsNeeded(style);
 747 }
 748 
 749 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 750 {
 751     return RenderElement::createFor(*this, WTFMove(style));
 752 }
 753 
 754 HTMLFormElement* HTMLElement::form() const
 755 {
 756     return HTMLFormElement::findClosestFormAncestor(*this);
 757 }
 758 
<a name="30" id="anc30"></a><span class="line-added"> 759 FormNamedItem* HTMLElement::asFormNamedItem()</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     return nullptr;</span>
<span class="line-added"> 762 }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764 FormAssociatedElement* HTMLElement::asFormAssociatedElement()</span>
<span class="line-added"> 765 {</span>
<span class="line-added"> 766     return nullptr;</span>
<span class="line-added"> 767 }</span>
<span class="line-added"> 768 </span>
 769 static inline bool elementAffectsDirectionality(const Node&amp; node)
 770 {
 771     if (!is&lt;HTMLElement&gt;(node))
 772         return false;
 773     const HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 774     return is&lt;HTMLBDIElement&gt;(element) || element.hasAttributeWithoutSynchronization(dirAttr);
 775 }
 776 
 777 static void setHasDirAutoFlagRecursively(Node* firstNode, bool flag, Node* lastNode = nullptr)
 778 {
 779     firstNode-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 780 
 781     RefPtr&lt;Node&gt; node = firstNode-&gt;firstChild();
 782 
 783     while (node) {
 784         if (node-&gt;selfOrAncestorHasDirAutoAttribute() == flag)
 785             return;
 786 
 787         if (elementAffectsDirectionality(*node)) {
 788             if (node == lastNode)
 789                 return;
 790             node = NodeTraversal::nextSkippingChildren(*node, firstNode);
 791             continue;
 792         }
 793         node-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 794         if (node == lastNode)
 795             return;
 796         node = NodeTraversal::next(*node, firstNode);
 797     }
 798 }
 799 
 800 void HTMLElement::childrenChanged(const ChildChange&amp; change)
 801 {
 802     StyledElement::childrenChanged(change);
 803     adjustDirectionalityIfNeededAfterChildrenChanged(change.previousSiblingElement, change.type);
 804 }
 805 
 806 bool HTMLElement::hasDirectionAuto() const
 807 {
<a name="31" id="anc31"></a><span class="line-modified"> 808     const AtomString&amp; direction = attributeWithoutSynchronization(dirAttr);</span>
 809     return (hasTagName(bdiTag) &amp;&amp; direction.isNull()) || equalLettersIgnoringASCIICase(direction, &quot;auto&quot;);
 810 }
 811 
 812 TextDirection HTMLElement::directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const
 813 {
 814     if (!(selfOrAncestorHasDirAutoAttribute() &amp;&amp; hasDirectionAuto())) {
 815         isAuto = false;
 816         return TextDirection::LTR;
 817     }
 818 
 819     isAuto = true;
 820     return directionality();
 821 }
 822 
 823 TextDirection HTMLElement::directionality(Node** strongDirectionalityTextNode) const
 824 {
 825     if (isTextField()) {
 826         HTMLTextFormControlElement&amp; textElement = downcast&lt;HTMLTextFormControlElement&gt;(const_cast&lt;HTMLElement&amp;&gt;(*this));
 827         bool hasStrongDirectionality;
 828         UCharDirection textDirection = textElement.value().defaultWritingDirection(&amp;hasStrongDirectionality);
 829         if (strongDirectionalityTextNode)
 830             *strongDirectionalityTextNode = hasStrongDirectionality ? &amp;textElement : nullptr;
 831         return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 832     }
 833 
 834     RefPtr&lt;Node&gt; node = firstChild();
 835     while (node) {
 836         // Skip bdi, script, style and text form controls.
 837         if (equalLettersIgnoringASCIICase(node-&gt;nodeName(), &quot;bdi&quot;) || node-&gt;hasTagName(scriptTag) || node-&gt;hasTagName(styleTag)
 838             || (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())) {
 839             node = NodeTraversal::nextSkippingChildren(*node, this);
 840             continue;
 841         }
 842 
 843         // Skip elements with valid dir attribute
 844         if (is&lt;Element&gt;(*node)) {
 845             auto&amp; dirAttributeValue = downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(dirAttr);
 846             if (isLTROrRTLIgnoringCase(dirAttributeValue) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;auto&quot;)) {
 847                 node = NodeTraversal::nextSkippingChildren(*node, this);
 848                 continue;
 849             }
 850         }
 851 
 852         if (node-&gt;isTextNode()) {
 853             bool hasStrongDirectionality;
 854             UCharDirection textDirection = node-&gt;textContent(true).defaultWritingDirection(&amp;hasStrongDirectionality);
 855             if (hasStrongDirectionality) {
 856                 if (strongDirectionalityTextNode)
 857                     *strongDirectionalityTextNode = node.get();
 858                 return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 859             }
 860         }
 861         node = NodeTraversal::next(*node, this);
 862     }
 863     if (strongDirectionalityTextNode)
 864         *strongDirectionalityTextNode = nullptr;
 865     return TextDirection::LTR;
 866 }
 867 
<a name="32" id="anc32"></a><span class="line-modified"> 868 void HTMLElement::dirAttributeChanged(const AtomString&amp; value)</span>
 869 {
 870     RefPtr&lt;Element&gt; parent = parentElement();
 871 
 872     if (is&lt;HTMLElement&gt;(parent) &amp;&amp; parent-&gt;selfOrAncestorHasDirAutoAttribute())
 873         downcast&lt;HTMLElement&gt;(*parent).adjustDirectionalityIfNeededAfterChildAttributeChanged(this);
 874 
 875     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 876         calculateAndAdjustDirectionality();
 877 }
 878 
 879 void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)
 880 {
 881     ASSERT(selfOrAncestorHasDirAutoAttribute());
 882     Node* strongDirectionalityTextNode;
 883     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 884     setHasDirAutoFlagRecursively(child, false);
 885     if (!renderer() || renderer()-&gt;style().direction() == textDirection)
 886         return;
 887     for (auto&amp; elementToAdjust : elementLineage(this)) {
 888         if (elementAffectsDirectionality(elementToAdjust)) {
 889             elementToAdjust.invalidateStyleForSubtree();
 890             return;
 891         }
 892     }
 893 }
 894 
 895 void HTMLElement::calculateAndAdjustDirectionality()
 896 {
 897     Node* strongDirectionalityTextNode;
 898     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 899     setHasDirAutoFlagRecursively(this, true, strongDirectionalityTextNode);
 900     if (renderer() &amp;&amp; renderer()-&gt;style().direction() != textDirection)
 901         invalidateStyleForSubtree();
 902 }
 903 
 904 void HTMLElement::adjustDirectionalityIfNeededAfterChildrenChanged(Element* beforeChange, ChildChangeType changeType)
 905 {
 906     // FIXME: This function looks suspicious.
 907 
 908     if (!selfOrAncestorHasDirAutoAttribute())
 909         return;
 910 
 911     RefPtr&lt;Node&gt; oldMarkedNode;
 912     if (beforeChange)
 913         oldMarkedNode = changeType == ElementInserted ? ElementTraversal::nextSibling(*beforeChange) : beforeChange-&gt;nextSibling();
 914 
 915     while (oldMarkedNode &amp;&amp; elementAffectsDirectionality(*oldMarkedNode))
 916         oldMarkedNode = oldMarkedNode-&gt;nextSibling();
 917     if (oldMarkedNode)
 918         setHasDirAutoFlagRecursively(oldMarkedNode.get(), false);
 919 
 920     for (auto&amp; elementToAdjust : lineageOfType&lt;HTMLElement&gt;(*this)) {
 921         if (elementAffectsDirectionality(elementToAdjust)) {
 922             elementToAdjust.calculateAndAdjustDirectionality();
 923             return;
 924         }
 925     }
 926 }
 927 
 928 void HTMLElement::addHTMLLengthToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; value)
 929 {
 930     // FIXME: This function should not spin up the CSS parser, but should instead just figure out the correct
 931     // length unit and make the appropriate parsed value.
 932 
 933     if (StringImpl* string = value.impl()) {
 934         unsigned parsedLength = 0;
 935 
 936         while (parsedLength &lt; string-&gt;length() &amp;&amp; (*string)[parsedLength] &lt;= &#39; &#39;)
 937             ++parsedLength;
 938 
 939         for (; parsedLength &lt; string-&gt;length(); ++parsedLength) {
 940             UChar cc = (*string)[parsedLength];
 941             if (cc &gt; &#39;9&#39;)
 942                 break;
 943             if (cc &lt; &#39;0&#39;) {
 944                 if (cc == &#39;%&#39; || cc == &#39;*&#39;)
 945                     ++parsedLength;
 946                 if (cc != &#39;.&#39;)
 947                     break;
 948             }
 949         }
 950 
 951         if (parsedLength != string-&gt;length()) {
 952             addPropertyToPresentationAttributeStyle(style, propertyID, string-&gt;substring(0, parsedLength));
 953             return;
 954         }
 955     }
 956 
 957     addPropertyToPresentationAttributeStyle(style, propertyID, value);
 958 }
 959 
 960 static RGBA32 parseColorStringWithCrazyLegacyRules(const String&amp; colorString)
 961 {
 962     // Per spec, only look at the first 128 digits of the string.
 963     const size_t maxColorLength = 128;
 964     // We&#39;ll pad the buffer with two extra 0s later, so reserve two more than the max.
 965     Vector&lt;char, maxColorLength+2&gt; digitBuffer;
 966 
 967     size_t i = 0;
 968     // Skip a leading #.
 969     if (colorString[0] == &#39;#&#39;)
 970         i = 1;
 971 
 972     // Grab the first 128 characters, replacing non-hex characters with 0.
 973     // Non-BMP characters are replaced with &quot;00&quot; due to them appearing as two &quot;characters&quot; in the String.
 974     for (; i &lt; colorString.length() &amp;&amp; digitBuffer.size() &lt; maxColorLength; i++) {
 975         if (!isASCIIHexDigit(colorString[i]))
 976             digitBuffer.append(&#39;0&#39;);
 977         else
 978             digitBuffer.append(colorString[i]);
 979     }
 980 
 981     if (!digitBuffer.size())
 982         return Color::black;
 983 
 984     // Pad the buffer out to at least the next multiple of three in size.
 985     digitBuffer.append(&#39;0&#39;);
 986     digitBuffer.append(&#39;0&#39;);
 987 
 988     if (digitBuffer.size() &lt; 6)
 989         return makeRGB(toASCIIHexValue(digitBuffer[0]), toASCIIHexValue(digitBuffer[1]), toASCIIHexValue(digitBuffer[2]));
 990 
 991     // Split the digits into three components, then search the last 8 digits of each component.
 992     ASSERT(digitBuffer.size() &gt;= 6);
 993     size_t componentLength = digitBuffer.size() / 3;
 994     size_t componentSearchWindowLength = std::min&lt;size_t&gt;(componentLength, 8);
 995     size_t redIndex = componentLength - componentSearchWindowLength;
 996     size_t greenIndex = componentLength * 2 - componentSearchWindowLength;
 997     size_t blueIndex = componentLength * 3 - componentSearchWindowLength;
 998     // Skip digits until one of them is non-zero, or we&#39;ve only got two digits left in the component.
 999     while (digitBuffer[redIndex] == &#39;0&#39; &amp;&amp; digitBuffer[greenIndex] == &#39;0&#39; &amp;&amp; digitBuffer[blueIndex] == &#39;0&#39; &amp;&amp; (componentLength - redIndex) &gt; 2) {
1000         redIndex++;
1001         greenIndex++;
1002         blueIndex++;
1003     }
1004     ASSERT(redIndex + 1 &lt; componentLength);
1005     ASSERT(greenIndex &gt;= componentLength);
1006     ASSERT(greenIndex + 1 &lt; componentLength * 2);
1007     ASSERT(blueIndex &gt;= componentLength * 2);
1008     ASSERT_WITH_SECURITY_IMPLICATION(blueIndex + 1 &lt; digitBuffer.size());
1009 
1010     int redValue = toASCIIHexValue(digitBuffer[redIndex], digitBuffer[redIndex + 1]);
1011     int greenValue = toASCIIHexValue(digitBuffer[greenIndex], digitBuffer[greenIndex + 1]);
1012     int blueValue = toASCIIHexValue(digitBuffer[blueIndex], digitBuffer[blueIndex + 1]);
1013     return makeRGB(redValue, greenValue, blueValue);
1014 }
1015 
1016 // Color parsing that matches HTML&#39;s &quot;rules for parsing a legacy color value&quot;
1017 void HTMLElement::addHTMLColorToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; attributeValue)
1018 {
1019     // An empty string doesn&#39;t apply a color. (One containing only whitespace does, which is why this check occurs before stripping.)
1020     if (attributeValue.isEmpty())
1021         return;
1022 
1023     String colorString = attributeValue.stripWhiteSpace();
1024 
1025     // &quot;transparent&quot; doesn&#39;t apply a color either.
1026     if (equalLettersIgnoringASCIICase(colorString, &quot;transparent&quot;))
1027         return;
1028 
1029     Color color;
1030     // We can&#39;t always use the default Color constructor because it accepts
1031     // 4/8-digit hex, which conflict with some legacy HTML content using attributes.
1032     if ((colorString.length() != 5 &amp;&amp; colorString.length() != 9) || colorString[0] != &#39;#&#39;)
1033         color = Color(colorString);
1034     if (!color.isValid())
1035         color = Color(parseColorStringWithCrazyLegacyRules(colorString));
1036 
1037     style.setProperty(propertyID, CSSValuePool::singleton().createColorValue(color.rgb()));
1038 }
1039 
1040 bool HTMLElement::willRespondToMouseMoveEvents()
1041 {
1042     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseMoveEvents();
1043 }
1044 
1045 bool HTMLElement::willRespondToMouseWheelEvents()
1046 {
1047     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseWheelEvents();
1048 }
1049 
1050 bool HTMLElement::willRespondToMouseClickEvents()
1051 {
1052     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseClickEvents();
1053 }
1054 
1055 bool HTMLElement::canBeActuallyDisabled() const
1056 {
1057     return is&lt;HTMLButtonElement&gt;(*this)
1058         || is&lt;HTMLInputElement&gt;(*this)
1059         || is&lt;HTMLSelectElement&gt;(*this)
1060         || is&lt;HTMLTextAreaElement&gt;(*this)
1061         || is&lt;HTMLOptGroupElement&gt;(*this)
1062         || is&lt;HTMLOptionElement&gt;(*this)
1063         || is&lt;HTMLFieldSetElement&gt;(*this);
1064 }
1065 
1066 bool HTMLElement::isActuallyDisabled() const
1067 {
1068     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1069 }
1070 
1071 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)
1072 
<a name="33" id="anc33"></a><span class="line-modified">1073 const AtomString&amp; HTMLElement::autocapitalize() const</span>
1074 {
1075     return stringForAutocapitalizeType(autocapitalizeType());
1076 }
1077 
1078 AutocapitalizeType HTMLElement::autocapitalizeType() const
1079 {
1080     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1081 }
1082 
<a name="34" id="anc34"></a><span class="line-modified">1083 void HTMLElement::setAutocapitalize(const AtomString&amp; value)</span>
1084 {
1085     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1086 }
1087 
1088 bool HTMLElement::shouldAutocorrect() const
1089 {
1090     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1091     // Unrecognized values fall back to &quot;on&quot;.
1092     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1093 }
1094 
1095 void HTMLElement::setAutocorrect(bool autocorrect)
1096 {
<a name="35" id="anc35"></a><span class="line-modified">1097     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomString(&quot;on&quot;, AtomString::ConstructFromLiteral) : AtomString(&quot;off&quot;, AtomString::ConstructFromLiteral));</span>
1098 }
1099 
1100 #endif
1101 
1102 InputMode HTMLElement::canonicalInputMode() const
1103 {
<a name="36" id="anc36"></a><span class="line-modified">1104     auto mode = inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));</span>
<span class="line-added">1105     if (mode == InputMode::Unspecified) {</span>
<span class="line-added">1106         if (document().quirks().needsInputModeNoneImplicitly(*this))</span>
<span class="line-added">1107             return InputMode::None;</span>
<span class="line-added">1108     }</span>
<span class="line-added">1109     return mode;</span>
1110 }
1111 
<a name="37" id="anc37"></a><span class="line-modified">1112 const AtomString&amp; HTMLElement::inputMode() const</span>
1113 {
1114     return stringForInputMode(canonicalInputMode());
1115 }
1116 
<a name="38" id="anc38"></a><span class="line-modified">1117 void HTMLElement::setInputMode(const AtomString&amp; value)</span>
1118 {
1119     setAttributeWithoutSynchronization(inputmodeAttr, value);
1120 }
1121 
1122 } // namespace WebCore
1123 
1124 #ifndef NDEBUG
1125 
1126 // For use in the debugger
1127 void dumpInnerHTML(WebCore::HTMLElement*);
1128 
1129 void dumpInnerHTML(WebCore::HTMLElement* element)
1130 {
1131     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1132 }
1133 
1134 #endif
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>