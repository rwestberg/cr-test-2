<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingStateTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ScrollingTree.h&quot;
 28 
 29 #if ENABLE(ASYNC_SCROLLING)
 30 
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;PlatformWheelEvent.h&quot;
 34 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 35 #include &quot;ScrollingStateTree.h&quot;
 36 #include &quot;ScrollingTreeFrameScrollingNode.h&quot;
 37 #include &quot;ScrollingTreeNode.h&quot;



 38 #include &quot;ScrollingTreeScrollingNode.h&quot;
 39 #include &lt;wtf/SetForScope.h&gt;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 ScrollingTree::ScrollingTree() = default;
 45 
 46 ScrollingTree::~ScrollingTree() = default;
 47 
 48 bool ScrollingTree::shouldHandleWheelEventSynchronously(const PlatformWheelEvent&amp; wheelEvent)
 49 {
 50     // This method is invoked by the event handling thread
<span class="line-modified"> 51     LockHolder lock(m_mutex);</span>
 52 
 53     bool shouldSetLatch = wheelEvent.shouldConsiderLatching();
 54 
 55     if (hasLatchedNode() &amp;&amp; !shouldSetLatch)
 56         return false;
 57 
 58     if (shouldSetLatch)
<span class="line-modified"> 59         m_latchedNodeID = 0;</span>
 60 
<span class="line-modified"> 61     if (!m_eventTrackingRegions.isEmpty() &amp;&amp; m_rootNode) {</span>
<span class="line-removed"> 62         auto&amp; frameScrollingNode = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(*m_rootNode);</span>
 63         FloatPoint position = wheelEvent.position();
<span class="line-modified"> 64         position.move(frameScrollingNode.viewToContentsOffset(m_mainFrameScrollPosition));</span>
 65 
 66         const EventNames&amp; names = eventNames();
 67         IntPoint roundedPosition = roundedIntPoint(position);
 68 
 69         // Event regions are affected by page scale, so no need to map through scale.
<span class="line-modified"> 70         bool isSynchronousDispatchRegion = m_eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous</span>
<span class="line-modified"> 71             || m_eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;</span>
 72         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent at &quot; &lt;&lt; wheelEvent.position() &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);
 73 
 74         if (isSynchronousDispatchRegion)
 75             return true;
 76     }
 77     return false;
 78 }
 79 
 80 void ScrollingTree::setOrClearLatchedNode(const PlatformWheelEvent&amp; wheelEvent, ScrollingNodeID nodeID)
 81 {
<span class="line-modified"> 82     if (wheelEvent.shouldConsiderLatching())</span>

 83         setLatchedNode(nodeID);
<span class="line-modified"> 84     else if (wheelEvent.shouldResetLatching())</span>

 85         clearLatchedNode();

 86 }
 87 
 88 ScrollingEventResult ScrollingTree::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)
 89 {
 90     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; handleWheelEvent (async scrolling enabled: &quot; &lt;&lt; asyncFrameOrOverflowScrollingEnabled() &lt;&lt; &quot;)&quot;);
 91 


 92     if (!asyncFrameOrOverflowScrollingEnabled()) {
 93         if (m_rootNode)
<span class="line-modified"> 94             downcast&lt;ScrollingTreeScrollingNode&gt;(*m_rootNode).handleWheelEvent(wheelEvent);</span>
 95         return ScrollingEventResult::DidNotHandleEvent;
 96     }
 97 
 98     if (hasLatchedNode()) {

 99         auto* node = nodeForID(latchedNode());
100         if (is&lt;ScrollingTreeScrollingNode&gt;(node))
101             return downcast&lt;ScrollingTreeScrollingNode&gt;(*node).handleWheelEvent(wheelEvent);
102     }
103 
104     if (m_rootNode) {
<span class="line-removed">105         auto&amp; frameScrollingNode = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(*m_rootNode);</span>
<span class="line-removed">106 </span>
107         FloatPoint position = wheelEvent.position();
<span class="line-modified">108         ScrollingTreeNode* node = frameScrollingNode.scrollingNodeForPoint(LayoutPoint(position));</span>
109 
110         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::handleWheelEvent found node &quot; &lt;&lt; (node ? node-&gt;scrollingNodeID() : 0) &lt;&lt; &quot; for point &quot; &lt;&lt; position &lt;&lt; &quot;\n&quot;);
111 
112         while (node) {
113             if (is&lt;ScrollingTreeScrollingNode&gt;(*node)) {
114                 auto&amp; scrollingNode = downcast&lt;ScrollingTreeScrollingNode&gt;(*node);
115                 // FIXME: this needs to consult latching logic.
116                 if (scrollingNode.handleWheelEvent(wheelEvent) == ScrollingEventResult::DidHandleEvent)
117                     return ScrollingEventResult::DidHandleEvent;
118             }
119             node = node-&gt;parent();
120         }
121     }
122     return ScrollingEventResult::DidNotHandleEvent;
123 }
124 
<span class="line-modified">125 void ScrollingTree::viewportChangedViaDelegatedScrolling(ScrollingNodeID nodeID, const FloatRect&amp; fixedPositionRect, double scale)</span>
126 {
<span class="line-modified">127     auto* node = nodeForID(nodeID);</span>
<span class="line-removed">128     if (!is&lt;ScrollingTreeScrollingNode&gt;(node))</span>
<span class="line-removed">129         return;</span>
<span class="line-removed">130 </span>
<span class="line-removed">131     downcast&lt;ScrollingTreeScrollingNode&gt;(*node).updateLayersAfterViewportChange(fixedPositionRect, scale);</span>
<span class="line-removed">132 }</span>
133 
<span class="line-modified">134 void ScrollingTree::scrollPositionChangedViaDelegatedScrolling(ScrollingNodeID nodeID, const WebCore::FloatPoint&amp; scrollPosition, bool inUserInteraction)</span>
<span class="line-removed">135 {</span>
<span class="line-removed">136     auto* node = nodeForID(nodeID);</span>
<span class="line-removed">137     if (!is&lt;ScrollingTreeScrollingNode&gt;(node))</span>
138         return;
139 
<span class="line-modified">140     // Update descendant nodes</span>
<span class="line-removed">141     downcast&lt;ScrollingTreeScrollingNode&gt;(*node).updateLayersAfterDelegatedScroll(scrollPosition);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143     // Update GraphicsLayers and scroll state.</span>
<span class="line-removed">144     scrollingTreeNodeDidScroll(nodeID, scrollPosition, WTF::nullopt, inUserInteraction ? ScrollingLayerPositionAction::Sync : ScrollingLayerPositionAction::Set);</span>
145 }
146 
147 void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
148 {


149     bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
150 
151     LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
152 
153     auto* rootNode = scrollingStateTree-&gt;rootStateNode();
154     if (rootNode
155         &amp;&amp; (rootStateNodeChanged
156             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
157             || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<span class="line-removed">158             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::VisualViewportEnabled)</span>
159             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))) {
<span class="line-modified">160         LockHolder lock(m_mutex);</span>
161 
162         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
<span class="line-modified">163             m_mainFrameScrollPosition = FloatPoint();</span>
164 
165         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
<span class="line-modified">166             m_eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();</span>
<span class="line-removed">167 </span>
<span class="line-removed">168         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::VisualViewportEnabled))</span>
<span class="line-removed">169             m_visualViewportEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;visualViewportEnabled();</span>
170 
171         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
172             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
173     }
174 
<span class="line-removed">175     bool scrollRequestIsProgammatic = rootNode ? rootNode-&gt;requestedScrollPositionRepresentsProgrammaticScroll() : false;</span>
<span class="line-removed">176     SetForScope&lt;bool&gt; changeHandlingProgrammaticScroll(m_isHandlingProgrammaticScroll, scrollRequestIsProgammatic);</span>
<span class="line-removed">177 </span>
178     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
179     // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
180     HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
181     for (auto nodeID : m_nodeMap.keys())
182         unvisitedNodes.add(nodeID);
183 




184     // orphanNodes keeps child nodes alive while we rebuild child lists.
185     OrphanScrollingNodeMap orphanNodes;
186     updateTreeFromStateNode(rootNode, orphanNodes, unvisitedNodes);
187 
188     for (auto nodeID : unvisitedNodes) {
<span class="line-modified">189         if (nodeID == m_latchedNodeID)</span>
190             clearLatchedNode();
191 
192         LOG(Scrolling, &quot;ScrollingTree::commitTreeState - removing unvisited node %&quot; PRIu64, nodeID);
193         m_nodeMap.remove(nodeID);
194     }


195 }
196 
197 void ScrollingTree::updateTreeFromStateNode(const ScrollingStateNode* stateNode, OrphanScrollingNodeMap&amp; orphanNodes, HashSet&lt;ScrollingNodeID&gt;&amp; unvisitedNodes)
198 {
199     if (!stateNode) {
200         m_nodeMap.clear();
201         m_rootNode = nullptr;
202         return;
203     }
204 
205     ScrollingNodeID nodeID = stateNode-&gt;scrollingNodeID();
206     ScrollingNodeID parentNodeID = stateNode-&gt;parentNodeID();
207 
208     auto it = m_nodeMap.find(nodeID);
209 
210     RefPtr&lt;ScrollingTreeNode&gt; node;
211     if (it != m_nodeMap.end()) {
212         node = it-&gt;value;
213         unvisitedNodes.remove(nodeID);
214     } else {
215         node = createScrollingTreeNode(stateNode-&gt;nodeType(), nodeID);
216         if (!parentNodeID) {
217             // This is the root node. Clear the node map.
218             ASSERT(stateNode-&gt;isFrameScrollingNode());
<span class="line-modified">219             m_rootNode = node;</span>
220             m_nodeMap.clear();
221         }
222         m_nodeMap.set(nodeID, node.get());
223     }
224 
225     if (parentNodeID) {
226         auto parentIt = m_nodeMap.find(parentNodeID);
227         ASSERT_WITH_SECURITY_IMPLICATION(parentIt != m_nodeMap.end());
228         if (parentIt != m_nodeMap.end()) {
<span class="line-modified">229             auto* parent = parentIt-&gt;value;</span>
<span class="line-modified">230             node-&gt;setParent(parent);</span>







231             parent-&gt;appendChild(*node);
232         } else {
233             // FIXME: Use WeakPtr in m_nodeMap.
234             m_nodeMap.remove(nodeID);
235         }
236     }
237 
238     node-&gt;commitStateBeforeChildren(*stateNode);
239 
240     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
241     if (auto nodeChildren = node-&gt;children()) {
242         for (auto&amp; childScrollingNode : *nodeChildren) {
243             childScrollingNode-&gt;setParent(nullptr);
244             orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.get());
245         }
246         nodeChildren-&gt;clear();
247     }
248 
249     // Now update the children if we have any.
250     if (auto children = stateNode-&gt;children()) {
251         for (auto&amp; child : *children)
252             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
253     }
254 
255     node-&gt;commitStateAfterChildren(*stateNode);
256 }
257 
<span class="line-modified">258 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const</span>
259 {
<span class="line-modified">260     if (!nodeID)</span>
<span class="line-modified">261         return nullptr;</span>


262 
<span class="line-modified">263     return m_nodeMap.get(nodeID);</span>
264 }
265 
<span class="line-modified">266 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)</span>
267 {
<span class="line-modified">268     LockHolder lock(m_mutex);</span>
<span class="line-modified">269     m_asyncFrameOrOverflowScrollingEnabled = enabled;</span>
<span class="line-removed">270 }</span>
271 
<span class="line-modified">272 void ScrollingTree::setMainFramePinState(bool pinnedToTheLeft, bool pinnedToTheRight, bool pinnedToTheTop, bool pinnedToTheBottom)</span>
<span class="line-modified">273 {</span>
<span class="line-removed">274     LockHolder locker(m_swipeStateMutex);</span>
275 
<span class="line-modified">276     m_mainFramePinnedToTheLeft = pinnedToTheLeft;</span>
<span class="line-removed">277     m_mainFramePinnedToTheRight = pinnedToTheRight;</span>
<span class="line-removed">278     m_mainFramePinnedToTheTop = pinnedToTheTop;</span>
<span class="line-removed">279     m_mainFramePinnedToTheBottom = pinnedToTheBottom;</span>
<span class="line-removed">280 }</span>
281 
<span class="line-modified">282 FloatPoint ScrollingTree::mainFrameScrollPosition()</span>
<span class="line-removed">283 {</span>
<span class="line-removed">284     LockHolder lock(m_mutex);</span>
<span class="line-removed">285     return m_mainFrameScrollPosition;</span>
<span class="line-removed">286 }</span>
287 
<span class="line-modified">288 void ScrollingTree::setMainFrameScrollPosition(FloatPoint position)</span>
<span class="line-removed">289 {</span>
<span class="line-removed">290     LockHolder lock(m_mutex);</span>
<span class="line-removed">291     m_mainFrameScrollPosition = position;</span>
292 }
293 
<span class="line-modified">294 TrackingType ScrollingTree::eventTrackingTypeForPoint(const AtomicString&amp; eventName, IntPoint p)</span>
295 {
<span class="line-modified">296     LockHolder lock(m_mutex);</span>
297 
<span class="line-modified">298     return m_eventTrackingRegions.trackingTypeForPoint(eventName, p);</span>



299 }
300 
<span class="line-modified">301 bool ScrollingTree::isRubberBandInProgress()</span>
302 {
<span class="line-modified">303     LockHolder lock(m_mutex);</span>

304 
<span class="line-modified">305     return m_mainFrameIsRubberBanding;</span>
306 }
307 
<span class="line-modified">308 void ScrollingTree::setMainFrameIsRubberBanding(bool isRubberBanding)</span>
309 {
<span class="line-modified">310     LockHolder locker(m_mutex);</span>
311 
<span class="line-modified">312     m_mainFrameIsRubberBanding = isRubberBanding;</span>
<span class="line-modified">313 }</span>
314 
<span class="line-modified">315 bool ScrollingTree::isScrollSnapInProgress()</span>
<span class="line-removed">316 {</span>
<span class="line-removed">317     LockHolder lock(m_mutex);</span>
318 
<span class="line-modified">319     return m_mainFrameIsScrollSnapping;</span>




320 }
321 
<span class="line-modified">322 void ScrollingTree::setMainFrameIsScrollSnapping(bool isScrollSnapping)</span>
323 {
<span class="line-modified">324     LockHolder locker(m_mutex);</span>








325 
<span class="line-modified">326     m_mainFrameIsScrollSnapping = isScrollSnapping;</span>

327 }
328 
<span class="line-modified">329 void ScrollingTree::setCanRubberBandState(bool canRubberBandAtLeft, bool canRubberBandAtRight, bool canRubberBandAtTop, bool canRubberBandAtBottom)</span>
330 {
<span class="line-modified">331     LockHolder locker(m_swipeStateMutex);</span>
<span class="line-removed">332 </span>
<span class="line-removed">333     m_rubberBandsAtLeft = canRubberBandAtLeft;</span>
<span class="line-removed">334     m_rubberBandsAtRight = canRubberBandAtRight;</span>
<span class="line-removed">335     m_rubberBandsAtTop = canRubberBandAtTop;</span>
<span class="line-removed">336     m_rubberBandsAtBottom = canRubberBandAtBottom;</span>
337 }
338 
<span class="line-modified">339 bool ScrollingTree::rubberBandsAtLeft()</span>
340 {
<span class="line-modified">341     LockHolder lock(m_swipeStateMutex);</span>


342 
<span class="line-modified">343     return m_rubberBandsAtLeft;</span>



344 }
345 
<span class="line-modified">346 bool ScrollingTree::rubberBandsAtRight()</span>

347 {
<span class="line-modified">348     LockHolder lock(m_swipeStateMutex);</span>


349 
<span class="line-modified">350     return m_rubberBandsAtRight;</span>



351 }
352 
<span class="line-modified">353 bool ScrollingTree::rubberBandsAtBottom()</span>

354 {
<span class="line-modified">355     LockHolder lock(m_swipeStateMutex);</span>


356 
<span class="line-modified">357     return m_rubberBandsAtBottom;</span>



358 }
359 
<span class="line-modified">360 bool ScrollingTree::rubberBandsAtTop()</span>
361 {
<span class="line-modified">362     LockHolder lock(m_swipeStateMutex);</span>
363 
<span class="line-modified">364     return m_rubberBandsAtTop;</span>



365 }
366 
<span class="line-modified">367 bool ScrollingTree::isHandlingProgrammaticScroll()</span>
368 {
<span class="line-modified">369     return m_isHandlingProgrammaticScroll;</span>





370 }
371 

372 void ScrollingTree::setScrollPinningBehavior(ScrollPinningBehavior pinning)
373 {
374     LockHolder locker(m_swipeStateMutex);
375 
<span class="line-modified">376     m_scrollPinningBehavior = pinning;</span>
377 }
378 
379 ScrollPinningBehavior ScrollingTree::scrollPinningBehavior()
380 {
381     LockHolder lock(m_swipeStateMutex);
382 
<span class="line-modified">383     return m_scrollPinningBehavior;</span>
384 }
385 
386 bool ScrollingTree::willWheelEventStartSwipeGesture(const PlatformWheelEvent&amp; wheelEvent)
387 {
388     if (wheelEvent.phase() != PlatformWheelEventPhaseBegan)
389         return false;
390 
391     LockHolder lock(m_swipeStateMutex);
392 
<span class="line-modified">393     if (wheelEvent.deltaX() &gt; 0 &amp;&amp; m_mainFramePinnedToTheLeft &amp;&amp; !m_rubberBandsAtLeft)</span>
394         return true;
<span class="line-modified">395     if (wheelEvent.deltaX() &lt; 0 &amp;&amp; m_mainFramePinnedToTheRight &amp;&amp; !m_rubberBandsAtRight)</span>
396         return true;
<span class="line-modified">397     if (wheelEvent.deltaY() &gt; 0 &amp;&amp; m_mainFramePinnedToTheTop &amp;&amp; !m_rubberBandsAtTop)</span>
398         return true;
<span class="line-modified">399     if (wheelEvent.deltaY() &lt; 0 &amp;&amp; m_mainFramePinnedToTheBottom &amp;&amp; !m_rubberBandsAtBottom)</span>
400         return true;
401 
402     return false;
403 }
404 
405 void ScrollingTree::setScrollingPerformanceLoggingEnabled(bool flag)
406 {
407     m_scrollingPerformanceLoggingEnabled = flag;
408 }
409 
410 bool ScrollingTree::scrollingPerformanceLoggingEnabled()
411 {
412     return m_scrollingPerformanceLoggingEnabled;
413 }
414 
415 ScrollingNodeID ScrollingTree::latchedNode()
416 {
<span class="line-modified">417     LockHolder locker(m_mutex);</span>
<span class="line-modified">418     return m_latchedNodeID;</span>
419 }
420 
421 void ScrollingTree::setLatchedNode(ScrollingNodeID node)
422 {
<span class="line-modified">423     LockHolder locker(m_mutex);</span>
<span class="line-modified">424     m_latchedNodeID = node;</span>
425 }
426 
427 void ScrollingTree::clearLatchedNode()
428 {
<span class="line-modified">429     LockHolder locker(m_mutex);</span>
<span class="line-modified">430     m_latchedNodeID = 0;</span>
431 }
432 
<span class="line-modified">433 String ScrollingTree::scrollingTreeAsText()</span>
434 {
435     TextStream ts(TextStream::LineMode::MultipleLine);
436 
<span class="line-modified">437     TextStream::GroupScope scope(ts);</span>
<span class="line-modified">438     ts &lt;&lt; &quot;scrolling tree&quot;;</span>

439 
<span class="line-modified">440     if (m_latchedNodeID)</span>
<span class="line-removed">441         ts.dumpProperty(&quot;latched node&quot;, m_latchedNodeID);</span>
442 
<span class="line-modified">443     if (m_mainFrameScrollPosition != IntPoint())</span>
<span class="line-modified">444         ts.dumpProperty(&quot;main frame scroll position&quot;, m_mainFrameScrollPosition);</span>



445 
<span class="line-removed">446     {</span>
<span class="line-removed">447         LockHolder lock(m_mutex);</span>
448         if (m_rootNode) {
449             TextStream::GroupScope scope(ts);
<span class="line-modified">450             m_rootNode-&gt;dump(ts, ScrollingStateTreeAsTextBehaviorIncludeLayerPositions);</span>
451         }
<span class="line-removed">452     }</span>
<span class="line-removed">453 </span>
<span class="line-removed">454     return ts.release();</span>
<span class="line-removed">455 }</span>
456 
<span class="line-modified">457 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">458 Optional&lt;TouchActionData&gt; ScrollingTree::touchActionDataAtPoint(IntPoint p) const</span>
<span class="line-modified">459 {</span>
<span class="line-modified">460     // FIXME: This does not handle the case where there are multiple regions matching this point.</span>
<span class="line-modified">461     for (auto&amp; touchActionData : m_eventTrackingRegions.touchActionData) {</span>
<span class="line-modified">462         if (touchActionData.region.contains(p))</span>
<span class="line-modified">463             return touchActionData;</span>


464     }
<span class="line-modified">465 </span>
<span class="line-removed">466     return WTF::nullopt;</span>
467 }
<span class="line-removed">468 #endif</span>
469 
470 } // namespace WebCore
471 
472 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ScrollingTree.h&quot;
 28 
 29 #if ENABLE(ASYNC_SCROLLING)
 30 
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;PlatformWheelEvent.h&quot;
 34 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 35 #include &quot;ScrollingStateTree.h&quot;
 36 #include &quot;ScrollingTreeFrameScrollingNode.h&quot;
 37 #include &quot;ScrollingTreeNode.h&quot;
<span class="line-added"> 38 #include &quot;ScrollingTreeOverflowScrollProxyNode.h&quot;</span>
<span class="line-added"> 39 #include &quot;ScrollingTreeOverflowScrollingNode.h&quot;</span>
<span class="line-added"> 40 #include &quot;ScrollingTreePositionedNode.h&quot;</span>
 41 #include &quot;ScrollingTreeScrollingNode.h&quot;
 42 #include &lt;wtf/SetForScope.h&gt;
 43 #include &lt;wtf/text/TextStream.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 ScrollingTree::ScrollingTree() = default;
 48 
 49 ScrollingTree::~ScrollingTree() = default;
 50 
 51 bool ScrollingTree::shouldHandleWheelEventSynchronously(const PlatformWheelEvent&amp; wheelEvent)
 52 {
 53     // This method is invoked by the event handling thread
<span class="line-modified"> 54     LockHolder lock(m_treeStateMutex);</span>
 55 
 56     bool shouldSetLatch = wheelEvent.shouldConsiderLatching();
 57 
 58     if (hasLatchedNode() &amp;&amp; !shouldSetLatch)
 59         return false;
 60 
 61     if (shouldSetLatch)
<span class="line-modified"> 62         m_treeState.latchedNodeID = 0;</span>
 63 
<span class="line-modified"> 64     if (!m_treeState.eventTrackingRegions.isEmpty() &amp;&amp; m_rootNode) {</span>

 65         FloatPoint position = wheelEvent.position();
<span class="line-modified"> 66         position.move(m_rootNode-&gt;viewToContentsOffset(m_treeState.mainFrameScrollPosition));</span>
 67 
 68         const EventNames&amp; names = eventNames();
 69         IntPoint roundedPosition = roundedIntPoint(position);
 70 
 71         // Event regions are affected by page scale, so no need to map through scale.
<span class="line-modified"> 72         bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous</span>
<span class="line-modified"> 73             || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;</span>
 74         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent at &quot; &lt;&lt; wheelEvent.position() &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);
 75 
 76         if (isSynchronousDispatchRegion)
 77             return true;
 78     }
 79     return false;
 80 }
 81 
 82 void ScrollingTree::setOrClearLatchedNode(const PlatformWheelEvent&amp; wheelEvent, ScrollingNodeID nodeID)
 83 {
<span class="line-modified"> 84     if (wheelEvent.shouldConsiderLatching()) {</span>
<span class="line-added"> 85         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: setting latched node &quot; &lt;&lt; nodeID);</span>
 86         setLatchedNode(nodeID);
<span class="line-modified"> 87     } else if (wheelEvent.shouldResetLatching()) {</span>
<span class="line-added"> 88         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: clearing latched node (was &quot; &lt;&lt; latchedNode() &lt;&lt; &quot;)&quot;);</span>
 89         clearLatchedNode();
<span class="line-added"> 90     }</span>
 91 }
 92 
 93 ScrollingEventResult ScrollingTree::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)
 94 {
 95     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; handleWheelEvent (async scrolling enabled: &quot; &lt;&lt; asyncFrameOrOverflowScrollingEnabled() &lt;&lt; &quot;)&quot;);
 96 
<span class="line-added"> 97     LockHolder locker(m_treeMutex);</span>
<span class="line-added"> 98 </span>
 99     if (!asyncFrameOrOverflowScrollingEnabled()) {
100         if (m_rootNode)
<span class="line-modified">101             m_rootNode-&gt;handleWheelEvent(wheelEvent);</span>
102         return ScrollingEventResult::DidNotHandleEvent;
103     }
104 
105     if (hasLatchedNode()) {
<span class="line-added">106         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; has latched node &quot; &lt;&lt; latchedNode());</span>
107         auto* node = nodeForID(latchedNode());
108         if (is&lt;ScrollingTreeScrollingNode&gt;(node))
109             return downcast&lt;ScrollingTreeScrollingNode&gt;(*node).handleWheelEvent(wheelEvent);
110     }
111 
112     if (m_rootNode) {


113         FloatPoint position = wheelEvent.position();
<span class="line-modified">114         ScrollingTreeNode* node = m_rootNode-&gt;scrollingNodeForPoint(LayoutPoint(position));</span>
115 
116         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::handleWheelEvent found node &quot; &lt;&lt; (node ? node-&gt;scrollingNodeID() : 0) &lt;&lt; &quot; for point &quot; &lt;&lt; position &lt;&lt; &quot;\n&quot;);
117 
118         while (node) {
119             if (is&lt;ScrollingTreeScrollingNode&gt;(*node)) {
120                 auto&amp; scrollingNode = downcast&lt;ScrollingTreeScrollingNode&gt;(*node);
121                 // FIXME: this needs to consult latching logic.
122                 if (scrollingNode.handleWheelEvent(wheelEvent) == ScrollingEventResult::DidHandleEvent)
123                     return ScrollingEventResult::DidHandleEvent;
124             }
125             node = node-&gt;parent();
126         }
127     }
128     return ScrollingEventResult::DidNotHandleEvent;
129 }
130 
<span class="line-modified">131 void ScrollingTree::mainFrameViewportChangedViaDelegatedScrolling(const FloatPoint&amp; scrollPosition, const FloatRect&amp; layoutViewport, double)</span>
132 {
<span class="line-modified">133     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::viewportChangedViaDelegatedScrolling - layoutViewport &quot; &lt;&lt; layoutViewport);</span>





134 
<span class="line-modified">135     if (!m_rootNode)</span>



136         return;
137 
<span class="line-modified">138     m_rootNode-&gt;wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);</span>




139 }
140 
141 void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
142 {
<span class="line-added">143     LockHolder locker(m_treeMutex);</span>
<span class="line-added">144 </span>
145     bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
146 
147     LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
148 
149     auto* rootNode = scrollingStateTree-&gt;rootStateNode();
150     if (rootNode
151         &amp;&amp; (rootStateNodeChanged
152             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
153             || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)

154             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))) {
<span class="line-modified">155         LockHolder lock(m_treeStateMutex);</span>
156 
157         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
<span class="line-modified">158             m_treeState.mainFrameScrollPosition = { };</span>
159 
160         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
<span class="line-modified">161             m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();</span>



162 
163         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
164             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
165     }
166 



167     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
168     // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
169     HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
170     for (auto nodeID : m_nodeMap.keys())
171         unvisitedNodes.add(nodeID);
172 
<span class="line-added">173     m_overflowRelatedNodesMap.clear();</span>
<span class="line-added">174     m_activeOverflowScrollProxyNodes.clear();</span>
<span class="line-added">175     m_activePositionedNodes.clear();</span>
<span class="line-added">176 </span>
177     // orphanNodes keeps child nodes alive while we rebuild child lists.
178     OrphanScrollingNodeMap orphanNodes;
179     updateTreeFromStateNode(rootNode, orphanNodes, unvisitedNodes);
180 
181     for (auto nodeID : unvisitedNodes) {
<span class="line-modified">182         if (nodeID == m_treeState.latchedNodeID)</span>
183             clearLatchedNode();
184 
185         LOG(Scrolling, &quot;ScrollingTree::commitTreeState - removing unvisited node %&quot; PRIu64, nodeID);
186         m_nodeMap.remove(nodeID);
187     }
<span class="line-added">188 </span>
<span class="line-added">189     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;committed ScrollingTree&quot; &lt;&lt; scrollingTreeAsText(ScrollingStateTreeAsTextBehaviorDebug));</span>
190 }
191 
192 void ScrollingTree::updateTreeFromStateNode(const ScrollingStateNode* stateNode, OrphanScrollingNodeMap&amp; orphanNodes, HashSet&lt;ScrollingNodeID&gt;&amp; unvisitedNodes)
193 {
194     if (!stateNode) {
195         m_nodeMap.clear();
196         m_rootNode = nullptr;
197         return;
198     }
199 
200     ScrollingNodeID nodeID = stateNode-&gt;scrollingNodeID();
201     ScrollingNodeID parentNodeID = stateNode-&gt;parentNodeID();
202 
203     auto it = m_nodeMap.find(nodeID);
204 
205     RefPtr&lt;ScrollingTreeNode&gt; node;
206     if (it != m_nodeMap.end()) {
207         node = it-&gt;value;
208         unvisitedNodes.remove(nodeID);
209     } else {
210         node = createScrollingTreeNode(stateNode-&gt;nodeType(), nodeID);
211         if (!parentNodeID) {
212             // This is the root node. Clear the node map.
213             ASSERT(stateNode-&gt;isFrameScrollingNode());
<span class="line-modified">214             m_rootNode = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(node.get());</span>
215             m_nodeMap.clear();
216         }
217         m_nodeMap.set(nodeID, node.get());
218     }
219 
220     if (parentNodeID) {
221         auto parentIt = m_nodeMap.find(parentNodeID);
222         ASSERT_WITH_SECURITY_IMPLICATION(parentIt != m_nodeMap.end());
223         if (parentIt != m_nodeMap.end()) {
<span class="line-modified">224             auto* parent = parentIt-&gt;value.get();</span>
<span class="line-modified">225 </span>
<span class="line-added">226             auto* oldParent = node-&gt;parent();</span>
<span class="line-added">227             if (oldParent)</span>
<span class="line-added">228                 oldParent-&gt;removeChild(*node);</span>
<span class="line-added">229 </span>
<span class="line-added">230             if (oldParent != parent)</span>
<span class="line-added">231                 node-&gt;setParent(parent);</span>
<span class="line-added">232 </span>
233             parent-&gt;appendChild(*node);
234         } else {
235             // FIXME: Use WeakPtr in m_nodeMap.
236             m_nodeMap.remove(nodeID);
237         }
238     }
239 
240     node-&gt;commitStateBeforeChildren(*stateNode);
241 
242     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
243     if (auto nodeChildren = node-&gt;children()) {
244         for (auto&amp; childScrollingNode : *nodeChildren) {
245             childScrollingNode-&gt;setParent(nullptr);
246             orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.get());
247         }
248         nodeChildren-&gt;clear();
249     }
250 
251     // Now update the children if we have any.
252     if (auto children = stateNode-&gt;children()) {
253         for (auto&amp; child : *children)
254             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
255     }
256 
257     node-&gt;commitStateAfterChildren(*stateNode);
258 }
259 
<span class="line-modified">260 void ScrollingTree::applyLayerPositionsAfterCommit()</span>
261 {
<span class="line-modified">262     // Scrolling tree needs to make adjustments only if the UI side positions have changed.</span>
<span class="line-modified">263     if (!m_wasScrolledByDelegatedScrollingSincePreviousCommit)</span>
<span class="line-added">264         return;</span>
<span class="line-added">265     m_wasScrolledByDelegatedScrollingSincePreviousCommit = false;</span>
266 
<span class="line-modified">267     applyLayerPositions();</span>
268 }
269 
<span class="line-modified">270 void ScrollingTree::applyLayerPositions()</span>
271 {
<span class="line-modified">272     ASSERT(isMainThread());</span>
<span class="line-modified">273     LockHolder locker(m_treeMutex);</span>

274 
<span class="line-modified">275     if (!m_rootNode)</span>
<span class="line-modified">276         return;</span>

277 
<span class="line-modified">278     LOG(Scrolling, &quot;\nScrollingTree %p applyLayerPositions&quot;, this);</span>




279 
<span class="line-modified">280     applyLayerPositionsRecursive(*m_rootNode);</span>




281 
<span class="line-modified">282     LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);</span>



283 }
284 
<span class="line-modified">285 void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; currNode)</span>
286 {
<span class="line-modified">287     currNode.applyLayerPositions();</span>
288 
<span class="line-modified">289     if (auto children = currNode.children()) {</span>
<span class="line-added">290         for (auto&amp; child : *children)</span>
<span class="line-added">291             applyLayerPositionsRecursive(*child);</span>
<span class="line-added">292     }</span>
293 }
294 
<span class="line-modified">295 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const</span>
296 {
<span class="line-modified">297     if (!nodeID)</span>
<span class="line-added">298         return nullptr;</span>
299 
<span class="line-modified">300     return m_nodeMap.get(nodeID);</span>
301 }
302 
<span class="line-modified">303 void ScrollingTree::notifyRelatedNodesAfterScrollPositionChange(ScrollingTreeScrollingNode&amp; changedNode)</span>
304 {
<span class="line-modified">305     Vector&lt;ScrollingNodeID&gt; additionalUpdateRoots;</span>
306 
<span class="line-modified">307     if (is&lt;ScrollingTreeOverflowScrollingNode&gt;(changedNode))</span>
<span class="line-modified">308         additionalUpdateRoots = overflowRelatedNodes().get(changedNode.scrollingNodeID());</span>
309 
<span class="line-modified">310     notifyRelatedNodesRecursive(changedNode);</span>


311 
<span class="line-modified">312     for (auto positionedNodeID : additionalUpdateRoots) {</span>
<span class="line-added">313         auto* positionedNode = nodeForID(positionedNodeID);</span>
<span class="line-added">314         if (positionedNode)</span>
<span class="line-added">315             notifyRelatedNodesRecursive(*positionedNode);</span>
<span class="line-added">316     }</span>
317 }
318 
<span class="line-modified">319 void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)</span>
320 {
<span class="line-modified">321     node.applyLayerPositions();</span>
<span class="line-added">322 </span>
<span class="line-added">323     if (!node.children())</span>
<span class="line-added">324         return;</span>
<span class="line-added">325 </span>
<span class="line-added">326     for (auto&amp; child : *node.children()) {</span>
<span class="line-added">327         // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.</span>
<span class="line-added">328         if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))</span>
<span class="line-added">329             continue;</span>
330 
<span class="line-modified">331         notifyRelatedNodesRecursive(*child);</span>
<span class="line-added">332     }</span>
333 }
334 
<span class="line-modified">335 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)</span>
336 {
<span class="line-modified">337     m_asyncFrameOrOverflowScrollingEnabled = enabled;</span>





338 }
339 
<span class="line-modified">340 void ScrollingTree::setMainFrameScrollPosition(FloatPoint position)</span>
341 {
<span class="line-modified">342     LockHolder lock(m_treeStateMutex);</span>
<span class="line-added">343     m_treeState.mainFrameScrollPosition = position;</span>
<span class="line-added">344 }</span>
345 
<span class="line-modified">346 TrackingType ScrollingTree::eventTrackingTypeForPoint(const AtomString&amp; eventName, IntPoint p)</span>
<span class="line-added">347 {</span>
<span class="line-added">348     LockHolder lock(m_treeStateMutex);</span>
<span class="line-added">349     return m_treeState.eventTrackingRegions.trackingTypeForPoint(eventName, p);</span>
350 }
351 
<span class="line-modified">352 // Can be called from the main thread.</span>
<span class="line-added">353 bool ScrollingTree::isRubberBandInProgress()</span>
354 {
<span class="line-modified">355     LockHolder lock(m_treeStateMutex);</span>
<span class="line-added">356     return m_treeState.mainFrameIsRubberBanding;</span>
<span class="line-added">357 }</span>
358 
<span class="line-modified">359 void ScrollingTree::setMainFrameIsRubberBanding(bool isRubberBanding)</span>
<span class="line-added">360 {</span>
<span class="line-added">361     LockHolder locker(m_treeStateMutex);</span>
<span class="line-added">362     m_treeState.mainFrameIsRubberBanding = isRubberBanding;</span>
363 }
364 
<span class="line-modified">365 // Can be called from the main thread.</span>
<span class="line-added">366 bool ScrollingTree::isScrollSnapInProgress()</span>
367 {
<span class="line-modified">368     LockHolder lock(m_treeStateMutex);</span>
<span class="line-added">369     return m_treeState.mainFrameIsScrollSnapping;</span>
<span class="line-added">370 }</span>
371 
<span class="line-modified">372 void ScrollingTree::setMainFrameIsScrollSnapping(bool isScrollSnapping)</span>
<span class="line-added">373 {</span>
<span class="line-added">374     LockHolder locker(m_treeStateMutex);</span>
<span class="line-added">375     m_treeState.mainFrameIsScrollSnapping = isScrollSnapping;</span>
376 }
377 
<span class="line-modified">378 void ScrollingTree::setMainFramePinState(bool pinnedToTheLeft, bool pinnedToTheRight, bool pinnedToTheTop, bool pinnedToTheBottom)</span>
379 {
<span class="line-modified">380     LockHolder locker(m_swipeStateMutex);</span>
381 
<span class="line-modified">382     m_swipeState.mainFramePinnedToTheLeft = pinnedToTheLeft;</span>
<span class="line-added">383     m_swipeState.mainFramePinnedToTheRight = pinnedToTheRight;</span>
<span class="line-added">384     m_swipeState.mainFramePinnedToTheTop = pinnedToTheTop;</span>
<span class="line-added">385     m_swipeState.mainFramePinnedToTheBottom = pinnedToTheBottom;</span>
386 }
387 
<span class="line-modified">388 void ScrollingTree::setCanRubberBandState(bool canRubberBandAtLeft, bool canRubberBandAtRight, bool canRubberBandAtTop, bool canRubberBandAtBottom)</span>
389 {
<span class="line-modified">390     LockHolder locker(m_swipeStateMutex);</span>
<span class="line-added">391 </span>
<span class="line-added">392     m_swipeState.rubberBandsAtLeft = canRubberBandAtLeft;</span>
<span class="line-added">393     m_swipeState.rubberBandsAtRight = canRubberBandAtRight;</span>
<span class="line-added">394     m_swipeState.rubberBandsAtTop = canRubberBandAtTop;</span>
<span class="line-added">395     m_swipeState.rubberBandsAtBottom = canRubberBandAtBottom;</span>
396 }
397 
<span class="line-added">398 // Can be called from the main thread.</span>
399 void ScrollingTree::setScrollPinningBehavior(ScrollPinningBehavior pinning)
400 {
401     LockHolder locker(m_swipeStateMutex);
402 
<span class="line-modified">403     m_swipeState.scrollPinningBehavior = pinning;</span>
404 }
405 
406 ScrollPinningBehavior ScrollingTree::scrollPinningBehavior()
407 {
408     LockHolder lock(m_swipeStateMutex);
409 
<span class="line-modified">410     return m_swipeState.scrollPinningBehavior;</span>
411 }
412 
413 bool ScrollingTree::willWheelEventStartSwipeGesture(const PlatformWheelEvent&amp; wheelEvent)
414 {
415     if (wheelEvent.phase() != PlatformWheelEventPhaseBegan)
416         return false;
417 
418     LockHolder lock(m_swipeStateMutex);
419 
<span class="line-modified">420     if (wheelEvent.deltaX() &gt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheLeft &amp;&amp; !m_swipeState.rubberBandsAtLeft)</span>
421         return true;
<span class="line-modified">422     if (wheelEvent.deltaX() &lt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheRight &amp;&amp; !m_swipeState.rubberBandsAtRight)</span>
423         return true;
<span class="line-modified">424     if (wheelEvent.deltaY() &gt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheTop &amp;&amp; !m_swipeState.rubberBandsAtTop)</span>
425         return true;
<span class="line-modified">426     if (wheelEvent.deltaY() &lt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheBottom &amp;&amp; !m_swipeState.rubberBandsAtBottom)</span>
427         return true;
428 
429     return false;
430 }
431 
432 void ScrollingTree::setScrollingPerformanceLoggingEnabled(bool flag)
433 {
434     m_scrollingPerformanceLoggingEnabled = flag;
435 }
436 
437 bool ScrollingTree::scrollingPerformanceLoggingEnabled()
438 {
439     return m_scrollingPerformanceLoggingEnabled;
440 }
441 
442 ScrollingNodeID ScrollingTree::latchedNode()
443 {
<span class="line-modified">444     LockHolder locker(m_treeStateMutex);</span>
<span class="line-modified">445     return m_treeState.latchedNodeID;</span>
446 }
447 
448 void ScrollingTree::setLatchedNode(ScrollingNodeID node)
449 {
<span class="line-modified">450     LockHolder locker(m_treeStateMutex);</span>
<span class="line-modified">451     m_treeState.latchedNodeID = node;</span>
452 }
453 
454 void ScrollingTree::clearLatchedNode()
455 {
<span class="line-modified">456     LockHolder locker(m_treeStateMutex);</span>
<span class="line-modified">457     m_treeState.latchedNodeID = 0;</span>
458 }
459 
<span class="line-modified">460 String ScrollingTree::scrollingTreeAsText(ScrollingStateTreeAsTextBehavior behavior)</span>
461 {
462     TextStream ts(TextStream::LineMode::MultipleLine);
463 
<span class="line-modified">464     {</span>
<span class="line-modified">465         TextStream::GroupScope scope(ts);</span>
<span class="line-added">466         ts &lt;&lt; &quot;scrolling tree&quot;;</span>
467 
<span class="line-modified">468         LockHolder locker(m_treeStateMutex);</span>

469 
<span class="line-modified">470         if (m_treeState.latchedNodeID)</span>
<span class="line-modified">471             ts.dumpProperty(&quot;latched node&quot;, m_treeState.latchedNodeID);</span>
<span class="line-added">472 </span>
<span class="line-added">473         if (!m_treeState.mainFrameScrollPosition.isZero())</span>
<span class="line-added">474             ts.dumpProperty(&quot;main frame scroll position&quot;, m_treeState.mainFrameScrollPosition);</span>
475 


476         if (m_rootNode) {
477             TextStream::GroupScope scope(ts);
<span class="line-modified">478             m_rootNode-&gt;dump(ts, behavior | ScrollingStateTreeAsTextBehaviorIncludeLayerPositions);</span>
479         }




480 
<span class="line-modified">481         if (behavior &amp; ScrollingStateTreeAsTextBehaviorIncludeNodeIDs &amp;&amp; !m_overflowRelatedNodesMap.isEmpty()) {</span>
<span class="line-modified">482             TextStream::GroupScope scope(ts);</span>
<span class="line-modified">483             ts &lt;&lt; &quot;overflow related nodes&quot;;</span>
<span class="line-modified">484             {</span>
<span class="line-modified">485                 TextStream::IndentScope indentScope(ts);</span>
<span class="line-modified">486                 for (auto&amp; it : m_overflowRelatedNodesMap)</span>
<span class="line-modified">487                     ts &lt;&lt; &quot;\n&quot; &lt;&lt; indent &lt;&lt; it.key &lt;&lt; &quot; -&gt; &quot; &lt;&lt; it.value;</span>
<span class="line-added">488             }</span>
<span class="line-added">489         }</span>
490     }
<span class="line-modified">491     return ts.release();</span>

492 }

493 
494 } // namespace WebCore
495 
496 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingStateTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>