<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LayoutUnits.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="blockformatting/BlockFormattingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;InlineTextBox.h&quot;
 33 #include &quot;LayoutBox.h&quot;
 34 #include &quot;LayoutContainer.h&quot;
 35 #include &quot;LayoutTreeBuilder.h&quot;
 36 #include &quot;RenderBox.h&quot;
 37 #include &quot;RenderInline.h&quot;

 38 #include &quot;RenderView.h&quot;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 
 41 namespace WebCore {
 42 namespace Layout {
 43 
<span class="line-modified"> 44 static bool areEssentiallyEqual(float a, LayoutUnit b)</span>
 45 {
<span class="line-modified"> 46     if (a == b.toFloat())</span>
 47         return true;




 48 
<span class="line-modified"> 49     return fabs(a - b.toFloat()) &lt;= 8 * LayoutUnit::epsilon();</span>










 50 }
 51 
 52 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 53 {
 54     auto* lineLayoutData = blockFlow.simpleLineLayout();
 55     if (!lineLayoutData) {
 56         ASSERT_NOT_REACHED();
 57         return true;
 58     }
 59 
 60     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
 61     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));
 62     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();
 63 
 64     if (inlineRunList.size() != lineLayoutData-&gt;runCount()) {
 65         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;
 66         stream.nextLine();
 67         return true;
 68     }
 69 
 70     auto mismatched = false;
 71     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 72         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
 73         auto&amp; inlineRun = inlineRunList[i];
 74 
<span class="line-modified"> 75         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, inlineRun.logicalLeft()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, inlineRun.logicalRight());</span>
<span class="line-modified"> 76         if (matchingRuns)</span>
<span class="line-modified"> 77             matchingRuns = (simpleRun.start == inlineRun.textContext()-&gt;start() &amp;&amp; simpleRun.end == (inlineRun.textContext()-&gt;start() + inlineRun.textContext()-&gt;length()));</span>




 78         if (matchingRuns)
 79             continue;
 80 
<span class="line-modified"> 81         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;) layout run(&quot; &lt;&lt; inlineRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun.textContext()-&gt;start() + inlineRun.textContext()-&gt;length() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun.logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun.logicalRight() &lt;&lt; &quot;)&quot;;</span>
 82         stream.nextLine();
 83         mismatched = true;
 84     }
 85     return mismatched;
 86 }
 87 
<span class="line-modified"> 88 static bool checkForMatchingNonTextRuns(const InlineRun&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)</span>
 89 {
 90     return areEssentiallyEqual(inlineBox.logicalLeft(), inlineRun.logicalLeft())
 91         &amp;&amp; areEssentiallyEqual(inlineBox.logicalRight(), inlineRun.logicalRight())
<span class="line-modified"> 92         &amp;&amp; areEssentiallyEqual(inlineBox.logicalHeight(), inlineRun.logicalHeight());</span>

 93 }
 94 
<span class="line-modified"> 95 static bool checkForMatchingTextRuns(const InlineRun&amp; inlineRun, float logicalLeft, float logicalRight, unsigned start, unsigned end, float logicalHeight)</span>

 96 {
<span class="line-modified"> 97     return areEssentiallyEqual(logicalLeft, inlineRun.logicalLeft())</span>
<span class="line-modified"> 98         &amp;&amp; areEssentiallyEqual(logicalRight, inlineRun.logicalRight())</span>
<span class="line-modified"> 99         &amp;&amp; start == inlineRun.textContext()-&gt;start()</span>
<span class="line-modified">100         &amp;&amp; (end == (inlineRun.textContext()-&gt;start() + inlineRun.textContext()-&gt;length()))</span>
<span class="line-modified">101         &amp;&amp; areEssentiallyEqual(logicalHeight, inlineRun.logicalHeight());</span>

102 }
103 
104 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
105 {
106     auto* inlineBox = flowbox.firstLeafChild();
107     auto* lastLeafChild = flowbox.lastLeafChild();
108     while (inlineBox) {
109         inlineBoxes.append(inlineBox);
110         if (inlineBox == lastLeafChild)
111             break;
112         inlineBox = inlineBox-&gt;nextLeafChild();
113     }
114 }
115 
116 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
117 {
118     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
119         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
120             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
121                 inlineBoxes.append(inlineBox);
122                 continue;
123             }
124             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
125         }
126     }
127 }
128 
<span class="line-removed">129 static LayoutUnit resolveForRelativePositionIfNeeded(const InlineTextBox&amp; inlineTextBox)</span>
<span class="line-removed">130 {</span>
<span class="line-removed">131     LayoutUnit xOffset;</span>
<span class="line-removed">132     auto* parent = inlineTextBox.parent();</span>
<span class="line-removed">133     while (is&lt;InlineFlowBox&gt;(parent)) {</span>
<span class="line-removed">134         auto&amp; renderer = parent-&gt;renderer();</span>
<span class="line-removed">135         if (renderer.isInFlowPositioned())</span>
<span class="line-removed">136             xOffset = renderer.offsetForInFlowPosition().width();</span>
<span class="line-removed">137         parent = parent-&gt;parent();</span>
<span class="line-removed">138     }</span>
<span class="line-removed">139     return xOffset;</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
142 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
143 {
144     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
145     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));
146     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();
147 
148     // Collect inlineboxes.
149     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
150     collectInlineBoxes(blockFlow, inlineBoxes);
151 
152     auto mismatched = false;
153     unsigned runIndex = 0;
154 
155     if (inlineBoxes.size() != inlineRunList.size()) {
156         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;
157         stream.nextLine();
158     }
159 
160     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; inlineRunList.size(); ++inlineBoxIndex) {

161         auto* inlineBox = inlineBoxes[inlineBoxIndex];
162         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;

163 
<span class="line-modified">164         auto&amp; inlineRun = inlineRunList[runIndex];</span>
<span class="line-removed">165         auto matchingRuns = false;</span>
<span class="line-removed">166         if (inlineTextBox) {</span>
<span class="line-removed">167             auto xOffset = resolveForRelativePositionIfNeeded(*inlineTextBox);</span>
<span class="line-removed">168             matchingRuns = checkForMatchingTextRuns(inlineRun, inlineTextBox-&gt;logicalLeft() + xOffset,</span>
<span class="line-removed">169                 inlineTextBox-&gt;logicalRight() + xOffset,</span>
<span class="line-removed">170                 inlineTextBox-&gt;start(),</span>
<span class="line-removed">171                 inlineTextBox-&gt;end() + 1,</span>
<span class="line-removed">172                 inlineTextBox-&gt;logicalHeight());</span>
<span class="line-removed">173 </span>
<span class="line-removed">174             // &lt;span&gt;foobar&lt;/span&gt;foobar generates 2 inline text boxes while we only generate one inline run.</span>
<span class="line-removed">175             // also &lt;div&gt;foo&lt;img style=&quot;float: left;&quot;&gt;bar&lt;/div&gt; too.</span>
<span class="line-removed">176             auto inlineRunEnd = inlineRun.textContext()-&gt;start() + inlineRun.textContext()-&gt;length();</span>
<span class="line-removed">177             auto textRunMightBeExtended = !matchingRuns &amp;&amp; inlineTextBox-&gt;end() &lt; inlineRunEnd &amp;&amp; inlineBoxIndex &lt; inlineBoxes.size() - 1;</span>
<span class="line-removed">178 </span>
<span class="line-removed">179             if (textRunMightBeExtended) {</span>
<span class="line-removed">180                 auto logicalLeft = inlineTextBox-&gt;logicalLeft() + xOffset;</span>
<span class="line-removed">181                 auto logicalRight = inlineTextBox-&gt;logicalRight() + xOffset;</span>
<span class="line-removed">182                 auto start = inlineTextBox-&gt;start();</span>
<span class="line-removed">183                 auto end = inlineTextBox-&gt;end() + 1;</span>
<span class="line-removed">184                 auto index = ++inlineBoxIndex;</span>
<span class="line-removed">185                 for (; index &lt; inlineBoxes.size(); ++index) {</span>
<span class="line-removed">186                     auto* inlineBox = inlineBoxes[index];</span>
<span class="line-removed">187                     auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;</span>
<span class="line-removed">188                     // Can&#39;t mix different inline boxes.</span>
<span class="line-removed">189                     if (!inlineTextBox)</span>
<span class="line-removed">190                         break;</span>
<span class="line-removed">191 </span>
<span class="line-removed">192                     auto xOffset = resolveForRelativePositionIfNeeded(*inlineTextBox);</span>
<span class="line-removed">193                     logicalRight = inlineTextBox-&gt;logicalRight() + xOffset;</span>
<span class="line-removed">194                     end += (inlineTextBox-&gt;end() + 1);</span>
<span class="line-removed">195                     if (checkForMatchingTextRuns(inlineRun, logicalLeft, logicalRight, start, end, inlineTextBox-&gt;logicalHeight())) {</span>
<span class="line-removed">196                         matchingRuns = true;</span>
<span class="line-removed">197                         inlineBoxIndex = index;</span>
<span class="line-removed">198                         break;</span>
<span class="line-removed">199                     }</span>
<span class="line-removed">200 </span>
<span class="line-removed">201                     // Went too far?</span>
<span class="line-removed">202                     if (end &gt;= inlineRunEnd)</span>
<span class="line-removed">203                         break;</span>
<span class="line-removed">204                 }</span>
<span class="line-removed">205             }</span>
<span class="line-removed">206         } else</span>
<span class="line-removed">207             matchingRuns = checkForMatchingNonTextRuns(inlineRun, *inlineBox);</span>
208 






209 
<span class="line-modified">210         if (!matchingRuns) {</span>
<span class="line-removed">211             stream &lt;&lt; &quot;Mismatching: run &quot;;</span>
212 
213             if (inlineTextBox)
<span class="line-modified">214                 stream &lt;&lt; &quot;(&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() + 1 &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">215             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalRight() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;</span>
216 
<span class="line-modified">217             stream &lt;&lt; &quot;inline run &quot;;</span>
<span class="line-modified">218             if (inlineRun.textContext())</span>
<span class="line-modified">219                 stream &lt;&lt; &quot;(&quot; &lt;&lt; inlineRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun.textContext()-&gt;start() + inlineRun.textContext()-&gt;length() &lt;&lt; &quot;) &quot;;</span>
<span class="line-modified">220             stream &lt;&lt; &quot;(&quot; &lt;&lt; inlineRun.logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun.logicalRight() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun.logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineRun.logicalHeight() &lt;&lt; &quot;)&quot;;</span>
221             stream.nextLine();
222             mismatched = true;
223         }
224         ++runIndex;
225     }
226     return mismatched;
227 }
228 
229 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
230 {
231     bool firstMismatchingRect = true;
232     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
233         if (firstMismatchingRect) {
234             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
235             stream.nextLine();
236             firstMismatchingRect = false;
237         }
238 
239         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
240             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
241         stream.nextLine();
242     };
243 
244     auto renderBoxLikeMarginBox = [](auto&amp; displayBox) {
245         // Produce a RenderBox matching margin box.
246         auto borderBox = displayBox.borderBox();
247 
<span class="line-modified">248         return Display::Box::Rect {</span>
249             borderBox.top() - displayBox.nonCollapsedMarginBefore(),
250             borderBox.left() - displayBox.computedMarginStart().valueOr(0),
251             displayBox.computedMarginStart().valueOr(0) + borderBox.width() + displayBox.computedMarginEnd().valueOr(0),
252             displayBox.nonCollapsedMarginBefore() + borderBox.height() + displayBox.nonCollapsedMarginAfter()
253         };
254     };
255 
256     auto&amp; displayBox = context.displayBoxForLayoutBox(layoutBox);
257 
258     auto frameRect = renderer.frameRect();
259     // rendering does not offset for relative positioned boxes.
260     if (renderer.isInFlowPositioned())
261         frameRect.move(renderer.offsetForInFlowPosition());
262 
<span class="line-modified">263     if (frameRect != displayBox.rect()) {</span>
264         outputRect(&quot;frameBox&quot;, renderer.frameRect(), displayBox.rect());
265         return true;
266     }
267 
<span class="line-modified">268     if (renderer.borderBoxRect() != displayBox.borderBox()) {</span>
269         outputRect(&quot;borderBox&quot;, renderer.borderBoxRect(), displayBox.borderBox());
270         return true;
271     }
272 
<span class="line-modified">273     if (renderer.paddingBoxRect() != displayBox.paddingBox()) {</span>
274         outputRect(&quot;paddingBox&quot;, renderer.paddingBoxRect(), displayBox.paddingBox());
275         return true;
276     }
277 
<span class="line-modified">278     if (renderer.contentBoxRect() != displayBox.contentBox()) {</span>
279         outputRect(&quot;contentBox&quot;, renderer.contentBoxRect(), displayBox.contentBox());
280         return true;
281     }
282 
<span class="line-modified">283     if (renderer.marginBoxRect() != renderBoxLikeMarginBox(displayBox)) {</span>
284         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
285         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
286         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
287             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
288             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
289             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
290 
291         if (!marginsMatch) {
292             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
293             return true;
294         }
295     }
296 
297     return false;
298 }
299 
300 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
301 {
302     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
303 
304     if (!is&lt;Container&gt;(layoutBox))
305         return mismtachingGeometry;
306 
307     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
<span class="line-modified">308     auto* childBox = container.firstChild();</span>
309     auto* childRenderer = renderer.firstChild();
310 
311     while (childRenderer) {
312         if (!is&lt;RenderBox&gt;(*childRenderer)) {
313             childRenderer = childRenderer-&gt;nextSibling();
314             continue;
315         }
316 
<span class="line-modified">317         if (!childBox) {</span>
318             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
319             stream.nextLine();
320             return true;
321         }
322 
<span class="line-modified">323         if (is&lt;RenderBlockFlow&gt;(*childRenderer) &amp;&amp; childBox-&gt;establishesInlineFormattingContext()) {</span>
324             ASSERT(childRenderer-&gt;childrenInline());




325             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
<span class="line-modified">326             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childBox);</span>
327             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
328         } else {
<span class="line-modified">329             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childBox);</span>
330             mismtachingGeometry |= mismatchingSubtreeGeometry;
331         }
332 
<span class="line-modified">333         childBox = childBox-&gt;nextSibling();</span>
334         childRenderer = childRenderer-&gt;nextSibling();
335     }
336 
337     return mismtachingGeometry;
338 }
339 
340 void LayoutState::verifyAndOutputMismatchingLayoutTree(const RenderView&amp; renderView) const
341 {
342     TextStream stream;
343     auto mismatchingGeometry = verifyAndOutputSubtree(stream, *this, renderView, initialContainingBlock());
344     if (!mismatchingGeometry)
345         return;
346 #if ENABLE(TREE_DEBUGGING)
347     showRenderTree(&amp;renderView);
348     showLayoutTree(initialContainingBlock(), this);
349 #endif
350     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
351     ASSERT_NOT_REACHED();
352 }
353 
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;InlineTextBox.h&quot;
 33 #include &quot;LayoutBox.h&quot;
 34 #include &quot;LayoutContainer.h&quot;
 35 #include &quot;LayoutTreeBuilder.h&quot;
 36 #include &quot;RenderBox.h&quot;
 37 #include &quot;RenderInline.h&quot;
<span class="line-added"> 38 #include &quot;RenderLineBreak.h&quot;</span>
 39 #include &quot;RenderView.h&quot;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
<span class="line-modified"> 45 static bool areEssentiallyEqual(LayoutUnit a, LayoutUnit b)</span>
 46 {
<span class="line-modified"> 47     if (a == b)</span>
 48         return true;
<span class="line-added"> 49     // 1/4th CSS pixel.</span>
<span class="line-added"> 50     constexpr float epsilon = kFixedPointDenominator / 4;</span>
<span class="line-added"> 51     return abs(a.rawValue() - b.rawValue()) &lt;= epsilon;</span>
<span class="line-added"> 52 }</span>
 53 
<span class="line-modified"> 54 static bool areEssentiallyEqual(float a, LayoutUnit b)</span>
<span class="line-added"> 55 {</span>
<span class="line-added"> 56     return areEssentiallyEqual(LayoutUnit { a }, b);</span>
<span class="line-added"> 57 }</span>
<span class="line-added"> 58 </span>
<span class="line-added"> 59 static bool areEssentiallyEqual(LayoutRect a, LayoutRect b)</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61     return areEssentiallyEqual(a.x(), b.x())</span>
<span class="line-added"> 62         &amp;&amp; areEssentiallyEqual(a.y(), b.y())</span>
<span class="line-added"> 63         &amp;&amp; areEssentiallyEqual(a.width(), b.width())</span>
<span class="line-added"> 64         &amp;&amp; areEssentiallyEqual(a.height(), b.height());</span>
 65 }
 66 
 67 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 68 {
 69     auto* lineLayoutData = blockFlow.simpleLineLayout();
 70     if (!lineLayoutData) {
 71         ASSERT_NOT_REACHED();
 72         return true;
 73     }
 74 
 75     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
 76     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));
 77     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();
 78 
 79     if (inlineRunList.size() != lineLayoutData-&gt;runCount()) {
 80         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;
 81         stream.nextLine();
 82         return true;
 83     }
 84 
 85     auto mismatched = false;
 86     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 87         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
 88         auto&amp; inlineRun = inlineRunList[i];
 89 
<span class="line-modified"> 90         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, inlineRun-&gt;logicalLeft()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, inlineRun-&gt;logicalRight());</span>
<span class="line-modified"> 91         if (matchingRuns &amp;&amp; inlineRun-&gt;textContext()) {</span>
<span class="line-modified"> 92             matchingRuns = simpleRun.start == inlineRun-&gt;textContext()-&gt;start() &amp;&amp; simpleRun.end == inlineRun-&gt;textContext()-&gt;end();</span>
<span class="line-added"> 93             // SLL handles strings in a more concatenated format &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; -&gt; foo -&gt; 0,3 bar -&gt; 3,6 vs. 0,3 and 0,3</span>
<span class="line-added"> 94             if (!matchingRuns)</span>
<span class="line-added"> 95                 matchingRuns = (simpleRun.end - simpleRun.start) == (inlineRun-&gt;textContext()-&gt;end() - inlineRun-&gt;textContext()-&gt;start());</span>
<span class="line-added"> 96         }</span>
 97         if (matchingRuns)
 98             continue;
 99 
<span class="line-modified">100         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;) layout run(&quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;end() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;logicalRight() &lt;&lt; &quot;)&quot;;</span>
101         stream.nextLine();
102         mismatched = true;
103     }
104     return mismatched;
105 }
106 
<span class="line-modified">107 static bool checkForMatchingNonTextRuns(const Display::Run&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)</span>
108 {
109     return areEssentiallyEqual(inlineBox.logicalLeft(), inlineRun.logicalLeft())
110         &amp;&amp; areEssentiallyEqual(inlineBox.logicalRight(), inlineRun.logicalRight())
<span class="line-modified">111         &amp;&amp; areEssentiallyEqual(inlineBox.logicalTop(), inlineRun.logicalTop())</span>
<span class="line-added">112         &amp;&amp; areEssentiallyEqual(inlineBox.logicalBottom(), inlineRun.logicalBottom());</span>
113 }
114 
<span class="line-modified">115 </span>
<span class="line-added">116 static bool checkForMatchingTextRuns(const Display::Run&amp; inlineRun, const InlineTextBox&amp; inlineTextBox)</span>
117 {
<span class="line-modified">118     return areEssentiallyEqual(inlineTextBox.logicalLeft(), inlineRun.logicalLeft())</span>
<span class="line-modified">119         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalRight(), inlineRun.logicalRight())</span>
<span class="line-modified">120         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalTop(), inlineRun.logicalTop())</span>
<span class="line-modified">121         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalBottom(), inlineRun.logicalBottom())</span>
<span class="line-modified">122         &amp;&amp; inlineTextBox.start() == inlineRun.textContext()-&gt;start()</span>
<span class="line-added">123         &amp;&amp; (inlineTextBox.end() + 1) == inlineRun.textContext()-&gt;end();</span>
124 }
125 
126 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
127 {
128     auto* inlineBox = flowbox.firstLeafChild();
129     auto* lastLeafChild = flowbox.lastLeafChild();
130     while (inlineBox) {
131         inlineBoxes.append(inlineBox);
132         if (inlineBox == lastLeafChild)
133             break;
134         inlineBox = inlineBox-&gt;nextLeafChild();
135     }
136 }
137 
138 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
139 {
140     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
141         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
142             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
143                 inlineBoxes.append(inlineBox);
144                 continue;
145             }
146             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
147         }
148     }
149 }
150 













151 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
152 {
153     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
154     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));
155     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();
156 
157     // Collect inlineboxes.
158     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
159     collectInlineBoxes(blockFlow, inlineBoxes);
160 
161     auto mismatched = false;
162     unsigned runIndex = 0;
163 
164     if (inlineBoxes.size() != inlineRunList.size()) {
165         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;
166         stream.nextLine();
167     }
168 
169     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; inlineRunList.size(); ++inlineBoxIndex) {
<span class="line-added">170         auto&amp; inlineRun = inlineRunList[runIndex];</span>
171         auto* inlineBox = inlineBoxes[inlineBoxIndex];
172         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;
<span class="line-added">173         bool matchingRuns = inlineTextBox ? checkForMatchingTextRuns(*inlineRun, *inlineTextBox) : matchingRuns = checkForMatchingNonTextRuns(*inlineRun, *inlineBox);</span>
174 
<span class="line-modified">175         if (!matchingRuns) {</span>











































176 
<span class="line-added">177             if (is&lt;RenderLineBreak&gt;(inlineBox-&gt;renderer())) {</span>
<span class="line-added">178                 // &lt;br&gt; positioning is weird at this point. It needs proper baseline.</span>
<span class="line-added">179                 matchingRuns = true;</span>
<span class="line-added">180                 ++runIndex;</span>
<span class="line-added">181                 continue;</span>
<span class="line-added">182             }</span>
183 
<span class="line-modified">184             stream &lt;&lt; &quot;Mismatching: run&quot;;</span>

185 
186             if (inlineTextBox)
<span class="line-modified">187                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() + 1 &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">188             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;</span>
189 
<span class="line-modified">190             stream &lt;&lt; &quot; inline run&quot;;</span>
<span class="line-modified">191             if (inlineRun-&gt;textContext())</span>
<span class="line-modified">192                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">193             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineRun-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineRun-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;</span>
194             stream.nextLine();
195             mismatched = true;
196         }
197         ++runIndex;
198     }
199     return mismatched;
200 }
201 
202 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
203 {
204     bool firstMismatchingRect = true;
205     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
206         if (firstMismatchingRect) {
207             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
208             stream.nextLine();
209             firstMismatchingRect = false;
210         }
211 
212         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
213             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
214         stream.nextLine();
215     };
216 
217     auto renderBoxLikeMarginBox = [](auto&amp; displayBox) {
218         // Produce a RenderBox matching margin box.
219         auto borderBox = displayBox.borderBox();
220 
<span class="line-modified">221         return Display::Rect {</span>
222             borderBox.top() - displayBox.nonCollapsedMarginBefore(),
223             borderBox.left() - displayBox.computedMarginStart().valueOr(0),
224             displayBox.computedMarginStart().valueOr(0) + borderBox.width() + displayBox.computedMarginEnd().valueOr(0),
225             displayBox.nonCollapsedMarginBefore() + borderBox.height() + displayBox.nonCollapsedMarginAfter()
226         };
227     };
228 
229     auto&amp; displayBox = context.displayBoxForLayoutBox(layoutBox);
230 
231     auto frameRect = renderer.frameRect();
232     // rendering does not offset for relative positioned boxes.
233     if (renderer.isInFlowPositioned())
234         frameRect.move(renderer.offsetForInFlowPosition());
235 
<span class="line-modified">236     if (!areEssentiallyEqual(frameRect, displayBox.rect())) {</span>
237         outputRect(&quot;frameBox&quot;, renderer.frameRect(), displayBox.rect());
238         return true;
239     }
240 
<span class="line-modified">241     if (!areEssentiallyEqual(renderer.borderBoxRect(), displayBox.borderBox())) {</span>
242         outputRect(&quot;borderBox&quot;, renderer.borderBoxRect(), displayBox.borderBox());
243         return true;
244     }
245 
<span class="line-modified">246     if (!areEssentiallyEqual(renderer.paddingBoxRect(), displayBox.paddingBox())) {</span>
247         outputRect(&quot;paddingBox&quot;, renderer.paddingBoxRect(), displayBox.paddingBox());
248         return true;
249     }
250 
<span class="line-modified">251     if (!areEssentiallyEqual(renderer.contentBoxRect(), displayBox.contentBox())) {</span>
252         outputRect(&quot;contentBox&quot;, renderer.contentBoxRect(), displayBox.contentBox());
253         return true;
254     }
255 
<span class="line-modified">256     if (!areEssentiallyEqual(renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox))) {</span>
257         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
258         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
259         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
260             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
261             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
262             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
263 
264         if (!marginsMatch) {
265             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
266             return true;
267         }
268     }
269 
270     return false;
271 }
272 
273 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
274 {
275     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
276 
277     if (!is&lt;Container&gt;(layoutBox))
278         return mismtachingGeometry;
279 
280     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
<span class="line-modified">281     auto* childLayoutBox = container.firstChild();</span>
282     auto* childRenderer = renderer.firstChild();
283 
284     while (childRenderer) {
285         if (!is&lt;RenderBox&gt;(*childRenderer)) {
286             childRenderer = childRenderer-&gt;nextSibling();
287             continue;
288         }
289 
<span class="line-modified">290         if (!childLayoutBox) {</span>
291             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
292             stream.nextLine();
293             return true;
294         }
295 
<span class="line-modified">296         if (is&lt;RenderBlockFlow&gt;(*childRenderer) &amp;&amp; childLayoutBox-&gt;establishesInlineFormattingContext()) {</span>
297             ASSERT(childRenderer-&gt;childrenInline());
<span class="line-added">298             auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);</span>
<span class="line-added">299             if (mismtachingGeometry)</span>
<span class="line-added">300                 return true;</span>
<span class="line-added">301 </span>
302             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
<span class="line-modified">303             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childLayoutBox);</span>
304             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
305         } else {
<span class="line-modified">306             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);</span>
307             mismtachingGeometry |= mismatchingSubtreeGeometry;
308         }
309 
<span class="line-modified">310         childLayoutBox = childLayoutBox-&gt;nextSibling();</span>
311         childRenderer = childRenderer-&gt;nextSibling();
312     }
313 
314     return mismtachingGeometry;
315 }
316 
317 void LayoutState::verifyAndOutputMismatchingLayoutTree(const RenderView&amp; renderView) const
318 {
319     TextStream stream;
320     auto mismatchingGeometry = verifyAndOutputSubtree(stream, *this, renderView, initialContainingBlock());
321     if (!mismatchingGeometry)
322         return;
323 #if ENABLE(TREE_DEBUGGING)
324     showRenderTree(&amp;renderView);
325     showLayoutTree(initialContainingBlock(), this);
326 #endif
327     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
328     ASSERT_NOT_REACHED();
329 }
330 
</pre>
</td>
</tr>
</table>
<center><a href="LayoutUnits.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="blockformatting/BlockFormattingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>