<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 # Copyright (C) 2013 Digia Plc. and/or its subsidiary(-ies)
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23 # THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &quot;config&quot;
  26 
  27 # GPR conventions, to match the baseline JIT:
  28 #
  29 #
  30 # On x86-32 bits (windows and non-windows)
  31 # a0, a1, a2, a3 are only there for ease-of-use of offlineasm; they are not
  32 # actually considered as such by the ABI and we need to push/pop our arguments
  33 # on the stack. a0 and a1 are ecx and edx to follow fastcall.
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
  52 # r10 =&gt; t5
  53 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  54 # r12 =&gt;             csr1 (callee-save)
  55 # r13 =&gt;             csr2 (callee-save)
  56 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  57 # r15 =&gt;             csr4 (callee-save, tagMask)
  58 # rsp =&gt; sp
  59 # rbp =&gt; cfr
  60 # r11 =&gt;                  (scratch)
  61 #
  62 # On x86-64 windows
  63 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  64 # the registers. Also, &gt;8 return types are returned in a weird way.
  65 #
  66 # rax =&gt; t0,     r0
  67 # rcx =&gt;     a0
  68 # rdx =&gt; t1, a1, r1
  69 #  r8 =&gt; t2, a2
  70 #  r9 =&gt; t3, a3
  71 # r10 =&gt; t4
  72 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  73 # rsi =&gt;             csr1 (callee-save)
  74 # rdi =&gt;             csr2 (callee-save)
  75 # r12 =&gt;             csr3 (callee-save)
  76 # r13 =&gt;             csr4 (callee-save)
  77 # r14 =&gt;             csr5 (callee-save, tagTypeNumber)
  78 # r15 =&gt;             csr6 (callee-save, tagMask)
  79 # rsp =&gt; sp
  80 # rbp =&gt; cfr
  81 # r11 =&gt;                  (scratch)
  82 
  83 def isX64
  84     case $activeBackend
  85     when &quot;X86&quot;
  86         false
  87     when &quot;X86_WIN&quot;
  88         false
  89     when &quot;X86_64&quot;
  90         true
  91     when &quot;X86_64_WIN&quot;
  92         true
  93     else
  94         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  95     end
  96 end
  97 
  98 def isWin
  99     case $activeBackend
 100     when &quot;X86&quot;
 101         false
 102     when &quot;X86_WIN&quot;
 103         true
 104     when &quot;X86_64&quot;
 105         false
 106     when &quot;X86_64_WIN&quot;
 107         true
 108     else
 109         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 110     end
 111 end
 112 
 113 def useX87
 114     case $activeBackend
 115     when &quot;X86&quot;
 116         true
 117     when &quot;X86_WIN&quot;
 118         true
 119     when &quot;X86_64&quot;
 120         false
 121     when &quot;X86_64_WIN&quot;
 122         false
 123     else
 124         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 125     end
 126 end
 127 
 128 def isMSVC
 129     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 130 end
 131 
 132 def isIntelSyntax
 133     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 134 end
 135 
 136 def register(name)
 137     isIntelSyntax ? name : &quot;%&quot; + name
 138 end
 139 
 140 def offsetRegister(off, register)
 141     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 142 end
 143 
 144 def callPrefix
 145     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 146 end
 147 
 148 def orderOperands(opA, opB)
 149     isIntelSyntax ? &quot;#{opB}, #{opA}&quot; : &quot;#{opA}, #{opB}&quot;
 150 end
 151 
 152 def const(c)
 153     isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
 154 end
 155 
 156 def getSizeString(kind)
 157     if !isIntelSyntax
 158         return &quot;&quot;
 159     end
 160 
 161     size = &quot;&quot;
 162     case kind
 163     when :byte
 164         size = &quot;byte&quot;
 165     when :half
 166         size = &quot;word&quot;
 167     when :int
 168         size = &quot;dword&quot;
 169     when :ptr
 170         size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;
 171     when :double
 172         size = &quot;qword&quot;
 173     when :quad
 174         size = &quot;qword&quot;
 175     else
 176         raise &quot;Invalid kind #{kind}&quot;
 177     end
 178 
 179     return size + &quot; &quot; + &quot;ptr&quot; + &quot; &quot;;
 180 end
 181 
 182 class SpecialRegister &lt; NoChildren
 183     def x86Operand(kind)
 184         raise unless @name =~ /^r/
 185         raise unless isX64
 186         case kind
 187         when :half
 188             register(@name + &quot;w&quot;)
 189         when :int
 190             register(@name + &quot;d&quot;)
 191         when :ptr
 192             register(@name)
 193         when :quad
 194             register(@name)
 195         else
 196             raise
 197         end
 198     end
 199     def x86CallOperand(kind)
 200         # Call operands are not allowed to be partial registers.
 201         &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
 202     end
 203 end
 204 
 205 X64_SCRATCH_REGISTER = SpecialRegister.new(&quot;r11&quot;)
 206 
 207 def x86GPRName(name, kind)
 208     case name
 209     when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
 210         name8 = name[1] + &#39;l&#39;
 211         name16 = name[1..2]
 212     when &quot;esi&quot;, &quot;edi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 213         name16 = name[1..2]
 214         name8 = name16 + &#39;l&#39;
 215     when &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;
 216         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 217         name8 = name[1] + &#39;l&#39;
 218         name16 = name[1..2]
 219     when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 220         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
 221         case kind
 222         when :half
 223             return register(name + &quot;w&quot;)
 224         when :int
 225             return register(name + &quot;d&quot;)
 226         when :ptr
 227             return register(name)
 228         when :quad
 229             return register(name)
 230         end
 231     else
 232         raise &quot;bad GPR name #{name}&quot;
 233     end
 234     case kind
 235     when :byte
 236         register(name8)
 237     when :half
 238         register(name16)
 239     when :int
 240         register(&quot;e&quot; + name16)
 241     when :ptr
 242         register((isX64 ? &quot;r&quot; : &quot;e&quot;) + name16)
 243     when :quad
 244         isX64 ? register(&quot;r&quot; + name16) : raise
 245     else
 246         raise &quot;invalid kind #{kind} for GPR #{name} in X86&quot;
 247     end
 248 end
 249 
 250 class Node
 251     def x86LoadOperand(type, dst)
 252         x86Operand(type)
 253     end
 254 end
 255 
 256 class RegisterID
 257     def supports8BitOnX86
 258         case x86GPR
 259         when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;edi&quot;, &quot;esi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 260             true
 261         when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 262             false
 263         else
 264             raise
 265         end
 266     end
 267 
 268     def x86GPR
 269         if isX64
 270             case name
 271             when &quot;t0&quot;, &quot;r0&quot;
 272                 &quot;eax&quot;
 273             when &quot;r1&quot;
 274                 &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
 275             when &quot;a0&quot;
 276                 isWin ? &quot;ecx&quot; : &quot;edi&quot;
 277             when &quot;t1&quot;, &quot;a1&quot;
 278                 isWin ? &quot;edx&quot; : &quot;esi&quot;
 279             when &quot;t2&quot;, &quot;a2&quot;
 280                 isWin ? &quot;r8&quot; : &quot;edx&quot;
 281             when &quot;t3&quot;, &quot;a3&quot;
 282                 isWin ? &quot;r9&quot; : &quot;ecx&quot;
 283             when &quot;t4&quot;
 284                 isWin ? &quot;r10&quot; : &quot;r8&quot;
 285             when &quot;t5&quot;
 286                 isWin ? &quot;ecx&quot; : &quot;r10&quot;
 287             when &quot;csr0&quot;
 288                 &quot;ebx&quot;
 289             when &quot;csr1&quot;
 290                 isWin ? &quot;esi&quot; : &quot;r12&quot;
 291             when &quot;csr2&quot;
 292                 isWin ? &quot;edi&quot; : &quot;r13&quot;
 293             when &quot;csr3&quot;
 294                 isWin ? &quot;r12&quot; : &quot;r14&quot;
 295             when &quot;csr4&quot;
 296                 isWin ? &quot;r13&quot; : &quot;r15&quot;
 297             when &quot;csr5&quot;
 298                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 299                 &quot;r14&quot;
 300             when &quot;csr6&quot;
 301                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 302                 &quot;r15&quot;
 303             when &quot;cfr&quot;
 304                 &quot;ebp&quot;
 305             when &quot;sp&quot;
 306                 &quot;esp&quot;
 307             else
 308                 raise &quot;cannot use register #{name} on X86&quot;
 309             end
 310         else
 311             case name
 312             when &quot;t0&quot;, &quot;r0&quot;, &quot;a2&quot;
 313                 &quot;eax&quot;
 314             when &quot;t1&quot;, &quot;r1&quot;, &quot;a1&quot;
 315                 &quot;edx&quot;
 316             when &quot;t2&quot;, &quot;a0&quot;
 317                 &quot;ecx&quot;
 318             when &quot;t3&quot;, &quot;a3&quot;
 319                 &quot;ebx&quot;
 320             when &quot;t4&quot;
 321                 &quot;esi&quot;
 322             when &quot;t5&quot;
 323                 &quot;edi&quot;
 324             when &quot;cfr&quot;
 325                 &quot;ebp&quot;
 326             when &quot;sp&quot;
 327                 &quot;esp&quot;
 328             end
 329         end
 330     end
 331 
 332     def x86Operand(kind)
 333         x86GPRName(x86GPR, kind)
 334     end
 335 
 336     def x86CallOperand(kind)
 337         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 338     end
 339 end
 340 
 341 class FPRegisterID
 342     def x86Operand(kind)
 343         raise unless kind == :double
 344         raise if useX87
 345         case name
 346         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;
 347             register(&quot;xmm0&quot;)
 348         when &quot;ft1&quot;, &quot;fa1&quot;
 349             register(&quot;xmm1&quot;)
 350         when &quot;ft2&quot;, &quot;fa2&quot;
 351             register(&quot;xmm2&quot;)
 352         when &quot;ft3&quot;, &quot;fa3&quot;
 353             register(&quot;xmm3&quot;)
 354         when &quot;ft4&quot;
 355             register(&quot;xmm4&quot;)
 356         when &quot;ft5&quot;
 357             register(&quot;xmm5&quot;)
 358         else
 359             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 360         end
 361     end
 362     def x87DefaultStackPosition
 363         case name
 364         when &quot;ft0&quot;, &quot;fr&quot;
 365             0
 366         when &quot;ft1&quot;
 367             1
 368         when &quot;ft2&quot;, &quot;ft3&quot;, &quot;ft4&quot;, &quot;ft5&quot;
 369             raise &quot;Unimplemented register #{name} for X86 at #{codeOriginString}&quot;
 370         else
 371             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 372         end
 373     end
 374     def x87Operand(offset)
 375         raise unless useX87
 376         raise unless offset == 0 or offset == 1
 377         &quot;#{register(&quot;st&quot;)}(#{x87DefaultStackPosition + offset})&quot;
 378     end
 379     def x86CallOperand(kind)
 380         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 381     end
 382 end
 383 
 384 class Immediate
 385     def validX86Immediate?
 386         if isX64
 387             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 388         else
 389             true
 390         end
 391     end
 392     def x86Operand(kind)
 393         &quot;#{const(value)}&quot;
 394     end
 395     def x86CallOperand(kind)
 396         &quot;#{value}&quot;
 397     end
 398 end
 399 
 400 class Address
 401     def supports8BitOnX86
 402         true
 403     end
 404     
 405     def x86AddressOperand(addressKind)
 406         &quot;#{offsetRegister(offset.value, base.x86Operand(addressKind))}&quot;
 407     end
 408     def x86Operand(kind)
 409         &quot;#{getSizeString(kind)}#{x86AddressOperand(:ptr)}&quot;
 410     end
 411     def x86CallOperand(kind)
 412         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 413     end
 414 end
 415 
 416 class BaseIndex
 417     def supports8BitOnX86
 418         true
 419     end
 420     
 421     def x86AddressOperand(addressKind)
 422         if !isIntelSyntax
 423             &quot;#{offset.value}(#{base.x86Operand(addressKind)}, #{index.x86Operand(addressKind)}, #{scaleValue})&quot;
 424         else
 425             &quot;#{getSizeString(addressKind)}[#{offset.value} + #{base.x86Operand(addressKind)} + #{index.x86Operand(addressKind)} * #{scaleValue}]&quot;
 426         end
 427     end
 428     
 429     def x86Operand(kind)
 430         if !isIntelSyntax
 431             x86AddressOperand(:ptr)
 432         else
 433             &quot;#{getSizeString(kind)}[#{offset.value} + #{base.x86Operand(:ptr)} + #{index.x86Operand(:ptr)} * #{scaleValue}]&quot;
 434         end
 435     end
 436 
 437     def x86CallOperand(kind)
 438         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 439     end
 440 end
 441 
 442 class AbsoluteAddress
 443     def supports8BitOnX86
 444         true
 445     end
 446     
 447     def x86AddressOperand(addressKind)
 448         &quot;#{address.value}&quot;
 449     end
 450     
 451     def x86Operand(kind)
 452         &quot;#{address.value}&quot;
 453     end
 454 
 455     def x86CallOperand(kind)
 456         &quot;#{callPrefix}#{address.value}&quot;
 457     end
 458 end
 459 
 460 class LabelReference
 461     def x86CallOperand(kind)
 462         asmLabel
 463     end
 464     def x86LoadOperand(kind, dst)
 465         # FIXME: Implement this on platforms that aren&#39;t Mach-O.
 466         # https://bugs.webkit.org/show_bug.cgi?id=175104
 467         used
 468         if !isIntelSyntax
 469             $asm.puts &quot;movq #{asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 470         else
 471             $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{asmLabel}&quot;
 472         end
 473         &quot;#{offset}(#{dst.x86Operand(kind)})&quot;
 474     end
 475 end
 476 
 477 class LocalLabelReference
 478     def x86Operand(kind)
 479         asmLabel
 480     end
 481     def x86CallOperand(kind)
 482         asmLabel
 483     end
 484 end
 485 
 486 class Sequence
 487     def getModifiedListX86_64
 488         newList = []
 489         
 490         @list.each {
 491             | node |
 492             newNode = node
 493             if node.is_a? Instruction
 494                 unless node.opcode == &quot;move&quot;
 495                     usedScratch = false
 496                     newOperands = node.operands.map {
 497                         | operand |
 498                         if operand.immediate? and not operand.validX86Immediate?
 499                             if usedScratch
 500                                 raise &quot;Attempt to use scratch register twice at #{operand.codeOriginString}&quot;
 501                             end
 502                             newList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, X64_SCRATCH_REGISTER])
 503                             usedScratch = true
 504                             X64_SCRATCH_REGISTER
 505                         else
 506                             operand
 507                         end
 508                     }
 509                     newNode = Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
 510                 end
 511             else
 512                 unless node.is_a? Label or
 513                         node.is_a? LocalLabel or
 514                         node.is_a? Skip
 515                     raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 516                 end
 517             end
 518             if newNode
 519                 newList &lt;&lt; newNode
 520             end
 521         }
 522         
 523         return newList
 524     end
 525     def getModifiedListX86_64_WIN
 526         getModifiedListX86_64
 527     end
 528 end
 529 
 530 class Instruction
 531     
 532     def x86Operands(*kinds)
 533         raise unless kinds.size == operands.size
 534         result = []
 535         kinds.size.times {
 536             | idx |
 537             i = isIntelSyntax ? (kinds.size - idx - 1) : idx
 538             result &lt;&lt; operands[i].x86Operand(kinds[i])
 539         }
 540         result.join(&quot;, &quot;)
 541     end
 542     
 543     def x86LoadOperands(srcKind, dstKind)
 544         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 545     end
 546 
 547     def x86Suffix(kind)
 548         if isIntelSyntax
 549             return &quot;&quot;
 550         end
 551 
 552         case kind
 553         when :byte
 554             &quot;b&quot;
 555         when :half
 556             &quot;w&quot;
 557         when :int
 558             &quot;l&quot;
 559         when :ptr
 560             isX64 ? &quot;q&quot; : &quot;l&quot;
 561         when :quad
 562             isX64 ? &quot;q&quot; : raise
 563         when :double
 564             not useX87 ? &quot;sd&quot; : raise
 565         else
 566             raise
 567         end
 568     end
 569     
 570     def x86Bytes(kind)
 571         case kind
 572         when :byte
 573             1
 574         when :half
 575             2
 576         when :int
 577             4
 578         when :ptr
 579             isX64 ? 8 : 4
 580         when :quad
 581             isX64 ? 8 : raise
 582         when :double
 583             8
 584         else
 585             raise
 586         end
 587     end
 588 
 589     def emitX86Lea(src, dst, kind)
 590         if src.is_a? LabelReference
 591             src.used
 592             if !isIntelSyntax
 593                 $asm.puts &quot;movq #{src.asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 594             else
 595                 $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{src.asmLabel}&quot;
 596             end
 597         else
 598             $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(src.x86AddressOperand(kind), dst.x86Operand(kind))}&quot;
 599         end
 600     end
 601 
 602     def getImplicitOperandString
 603         isIntelSyntax ? &quot;st(0), &quot; : &quot;&quot;
 604     end
 605     
 606     def handleX86OpWithNumOperands(opcode, kind, numOperands)
 607         if numOperands == 3
 608             if operands[0] == operands[2]
 609                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 610             elsif operands[1] == operands[2]
 611                 $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 612             else
 613                 $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 614                 $asm.puts &quot;#{opcode} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 615             end
 616         else
 617             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 618         end
 619     end
 620     
 621     def handleX86Op(opcode, kind)
 622         handleX86OpWithNumOperands(opcode, kind, operands.size)
 623     end
 624     
 625     def handleX86Shift(opcode, kind)
 626         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 627             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 628         else
 629             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 630             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 631             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 632         end
 633     end
 634     
 635     def handleX86DoubleBranch(branchOpcode, mode)
 636         if useX87
 637             handleX87Compare(mode)
 638         else
 639             case mode
 640             when :normal
 641                 $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;
 642             when :reverse
 643                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
 644             else
 645                 raise mode.inspect
 646             end
 647         end
 648         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 649     end
 650     
 651     def handleX86IntCompare(opcodeSuffix, kind)
 652         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 653             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 654         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 655             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 656         else
 657             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 658         end
 659     end
 660     
 661     def handleX86IntBranch(branchOpcode, kind)
 662         handleX86IntCompare(branchOpcode[1..-1], kind)
 663         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 664     end
 665     
 666     def handleX86Set(setOpcode, operand)
 667         if operand.supports8BitOnX86
 668             $asm.puts &quot;#{setOpcode} #{operand.x86Operand(:byte)}&quot;
 669             if !isIntelSyntax
 670                 $asm.puts &quot;movzbl #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 671             else
 672                 $asm.puts &quot;movzx #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 673             end
 674         else
 675             ax = RegisterID.new(nil, &quot;r0&quot;)
 676             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 677             $asm.puts &quot;#{setOpcode} #{ax.x86Operand(:byte)}&quot;
 678             if !isIntelSyntax
 679                 $asm.puts &quot;movzbl #{ax.x86Operand(:byte)}, #{ax.x86Operand(:int)}&quot;
 680             else
 681                 $asm.puts &quot;movzx #{ax.x86Operand(:int)}, #{ax.x86Operand(:byte)}&quot;
 682             end
 683             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 684         end
 685     end
 686     
 687     def handleX86IntCompareSet(setOpcode, kind)
 688         handleX86IntCompare(setOpcode[3..-1], kind)
 689         handleX86Set(setOpcode, operands[2])
 690     end
 691     
 692     def handleX86Test(kind)
 693         value = operands[0]
 694         case operands.size
 695         when 2
 696             mask = Immediate.new(codeOrigin, -1)
 697         when 3
 698             mask = operands[1]
 699         else
 700             raise &quot;Expected 2 or 3 operands, but got #{operands.size} at #{codeOriginString}&quot;
 701         end
 702         
 703         if mask.is_a? Immediate and mask.value == -1
 704             if value.is_a? RegisterID
 705                 $asm.puts &quot;test#{x86Suffix(kind)} #{value.x86Operand(kind)}, #{value.x86Operand(kind)}&quot;
 706             else
 707                 $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(const(0), value.x86Operand(kind))}&quot;
 708             end
 709         else
 710             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(mask.x86Operand(kind), value.x86Operand(kind))}&quot;
 711         end
 712     end
 713     
 714     def handleX86BranchTest(branchOpcode, kind)
 715         handleX86Test(kind)
 716         $asm.puts &quot;#{branchOpcode} #{operands.last.asmLabel}&quot;
 717     end
 718     
 719     def handleX86SetTest(setOpcode, kind)
 720         handleX86Test(kind)
 721         handleX86Set(setOpcode, operands.last)
 722     end
 723     
 724     def handleX86OpBranch(opcode, branchOpcode, kind)
 725         handleX86OpWithNumOperands(opcode, kind, operands.size - 1)
 726         case operands.size
 727         when 4
 728             jumpTarget = operands[3]
 729         when 3
 730             jumpTarget = operands[2]
 731         else
 732             raise self.inspect
 733         end
 734         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 735     end
 736     
 737     def handleX86SubBranch(branchOpcode, kind)
 738         if operands.size == 4 and operands[1] == operands[2]
 739             $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 740             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 741         else
 742             handleX86OpWithNumOperands(&quot;sub#{x86Suffix(kind)}&quot;, kind, operands.size - 1)
 743         end
 744         case operands.size
 745         when 4
 746             jumpTarget = operands[3]
 747         when 3
 748             jumpTarget = operands[2]
 749         else
 750             raise self.inspect
 751         end
 752         $asm.puts &quot;#{branchOpcode} #{jumpTarget.asmLabel}&quot;
 753     end
 754 
 755     def handleX86Add(kind)
 756         if operands.size == 3 and operands[1] == operands[2]
 757             unless Immediate.new(nil, 0) == operands[0]
 758                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 759             end
 760         elsif operands.size == 3 and operands[0].is_a? Immediate
 761             raise unless operands[1].is_a? RegisterID
 762             raise unless operands[2].is_a? RegisterID
 763             if operands[0].value == 0
 764                 if operands[1] != operands[2]
 765                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 766                 end
 767             else
 768                 $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(offsetRegister(operands[0].value, operands[1].x86Operand(kind)), operands[2].x86Operand(kind))}&quot;
 769             end
 770         elsif operands.size == 3 and operands[0].is_a? RegisterID
 771             raise unless operands[1].is_a? RegisterID
 772             raise unless operands[2].is_a? RegisterID
 773             if operands[0] == operands[2]
 774                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 775             else
 776                 if !isIntelSyntax
 777                     $asm.puts &quot;lea#{x86Suffix(kind)} (#{operands[0].x86Operand(kind)}, #{operands[1].x86Operand(kind)}), #{operands[2].x86Operand(kind)}&quot;
 778                 else
 779                     $asm.puts &quot;lea#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}, [#{operands[0].x86Operand(kind)} + #{operands[1].x86Operand(kind)}]&quot;
 780                 end
 781             end
 782         else
 783             unless Immediate.new(nil, 0) == operands[0]
 784                 $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 785             end
 786         end
 787     end
 788     
 789     def handleX86Sub(kind)
 790         if operands.size == 3
 791             if Immediate.new(nil, 0) == operands[1]
 792                 raise unless operands[0].is_a? RegisterID
 793                 raise unless operands[2].is_a? RegisterID
 794                 if operands[0] != operands[2]
 795                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 796                 end
 797                 return
 798             end
 799             if operands[1] == operands[2]
 800                 $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 801                 if Immediate.new(nil, 0) != operands[0]
 802                     $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 803                 end
 804                 return
 805             end
 806         end
 807 
 808         if operands.size == 2
 809             if Immediate.new(nil, 0) == operands[0]
 810                 return
 811             end
 812         end
 813 
 814         handleX86Op(&quot;sub#{x86Suffix(kind)}&quot;, kind)
 815     end
 816     
 817     def handleX86Mul(kind)
 818         if operands.size == 3 and operands[0].is_a? Immediate
 819             $asm.puts &quot;imul#{x86Suffix(kind)} #{x86Operands(kind, kind, kind)}&quot;
 820             return
 821         end
 822 
 823         if operands.size == 2 and operands[0].is_a? Immediate
 824             imm = operands[0].value
 825             if imm &gt; 0 and isPowerOfTwo(imm)
 826                 $asm.puts &quot;sal#{x86Suffix(kind)} #{orderOperands(Immediate.new(nil, Math.log2(imm).to_i).x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 827                 return
 828             end
 829         end
 830 
 831         handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
 832     end
 833     
 834     def handleX86Peek()
 835         sp = RegisterID.new(nil, &quot;sp&quot;)
 836         opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 837         opB = operands[1].x86Operand(:ptr)
 838         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 839     end
 840 
 841     def handleX86Poke()
 842         sp = RegisterID.new(nil, &quot;sp&quot;)
 843         opA = operands[0].x86Operand(:ptr)
 844         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 845         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 846     end
 847 
 848     def handleMove
 849         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 850             if isX64
 851                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 852             else
 853                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 854             end
 855         elsif operands[0] != operands[1]
 856             if isX64
 857                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 858             else
 859                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 860             end
 861         end
 862     end
 863 
 864     def handleX87Compare(mode)
 865         floatingPointCompareImplicitOperand = getImplicitOperandString
 866         case mode
 867         when :normal
 868             if (operands[0].x87DefaultStackPosition == 0)
 869                 $asm.puts &quot;fucomi #{floatingPointCompareImplicitOperand}#{operands[1].x87Operand(0)}&quot;
 870             else
 871                 $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
 872                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[1].x87Operand(1)}&quot;
 873             end
 874         when :reverse
 875             if (operands[1].x87DefaultStackPosition == 0)
 876                 $asm.puts &quot;fucomi #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(0)}&quot;
 877             else
 878                 $asm.puts &quot;fld #{operands[1].x87Operand(0)}&quot;
 879                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(1)}&quot;
 880             end
 881         else
 882             raise mode.inspect
 883         end
 884     end
 885 
 886     def handleX87BinOp(opcode, opcodereverse)
 887         if (operands[1].x87DefaultStackPosition == 0)
 888             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x87Operand(0), register(&quot;st&quot;))}&quot;
 889         elsif (operands[0].x87DefaultStackPosition == 0)
 890             if !isIntelSyntax
 891                 $asm.puts &quot;#{opcodereverse} #{register(&quot;st&quot;)}, #{operands[1].x87Operand(0)}&quot;
 892             else
 893                 $asm.puts &quot;#{opcode} #{operands[1].x87Operand(0)}, #{register(&quot;st&quot;)}&quot;
 894             end
 895         else
 896             $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
 897             $asm.puts &quot;#{opcodereverse}p #{orderOperands(register(&quot;st&quot;), operands[1].x87Operand(1))}&quot;
 898         end
 899     end
 900 
 901     def lowerX86
 902         raise unless $activeBackend == &quot;X86&quot;
 903         lowerX86Common
 904     end
 905 
 906     def lowerX86_WIN
 907         raise unless $activeBackend == &quot;X86_WIN&quot; 
 908         lowerX86Common
 909     end
 910     
 911     def lowerX86_64
 912         raise unless $activeBackend == &quot;X86_64&quot;
 913         lowerX86Common
 914     end
 915 
 916     def lowerX86_64_WIN
 917         raise unless $activeBackend == &quot;X86_64_WIN&quot;
 918         lowerX86Common
 919     end
 920 
 921     def lowerX86Common
 922         case opcode
 923         when &quot;addi&quot;
 924             handleX86Add(:int)
 925         when &quot;addp&quot;
 926             handleX86Add(:ptr)
 927         when &quot;addq&quot;
 928             handleX86Add(:quad)
 929         when &quot;andi&quot;
 930             handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
 931         when &quot;andp&quot;
 932             handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
 933         when &quot;andq&quot;
 934             handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)
 935         when &quot;lshifti&quot;
 936             handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
 937         when &quot;lshiftp&quot;
 938             handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
 939         when &quot;lshiftq&quot;
 940             handleX86Shift(&quot;sal#{x86Suffix(:quad)}&quot;, :quad)
 941         when &quot;muli&quot;
 942             handleX86Mul(:int)
 943         when &quot;mulp&quot;
 944             handleX86Mul(:ptr)
 945         when &quot;mulq&quot;
 946             handleX86Mul(:quad)
 947         when &quot;negi&quot;
 948             $asm.puts &quot;neg#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 949         when &quot;negp&quot;
 950             $asm.puts &quot;neg#{x86Suffix(:ptr)} #{x86Operands(:ptr)}&quot;
 951         when &quot;negq&quot;
 952             $asm.puts &quot;neg#{x86Suffix(:quad)} #{x86Operands(:quad)}&quot;
 953         when &quot;noti&quot;
 954             $asm.puts &quot;not#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 955         when &quot;ori&quot;
 956             handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
 957         when &quot;orp&quot;
 958             handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
 959         when &quot;orq&quot;
 960             handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)
 961         when &quot;rshifti&quot;
 962             handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
 963         when &quot;rshiftp&quot;
 964             handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
 965         when &quot;rshiftq&quot;
 966             handleX86Shift(&quot;sar#{x86Suffix(:quad)}&quot;, :quad)
 967         when &quot;urshifti&quot;
 968             handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
 969         when &quot;urshiftp&quot;
 970             handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
 971         when &quot;urshiftq&quot;
 972             handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)
 973         when &quot;subi&quot;
 974             handleX86Sub(:int)
 975         when &quot;subp&quot;
 976             handleX86Sub(:ptr)
 977         when &quot;subq&quot;
 978             handleX86Sub(:quad)
 979         when &quot;xori&quot;
 980             handleX86Op(&quot;xor#{x86Suffix(:int)}&quot;, :int)
 981         when &quot;xorp&quot;
 982             handleX86Op(&quot;xor#{x86Suffix(:ptr)}&quot;, :ptr)
 983         when &quot;xorq&quot;
 984             handleX86Op(&quot;xor#{x86Suffix(:quad)}&quot;, :quad)
 985         when &quot;leap&quot;
 986             emitX86Lea(operands[0], operands[1], :ptr)
 987         when &quot;loadi&quot;
 988             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
 989         when &quot;storei&quot;
 990             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
 991         when &quot;loadis&quot;
 992             if isX64
 993                 if !isIntelSyntax
 994                     $asm.puts &quot;movslq #{x86LoadOperands(:int, :quad)}&quot;
 995                 else
 996                     $asm.puts &quot;movsxd #{x86LoadOperands(:int, :quad)}&quot;
 997                 end
 998             else
 999                 $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
1000             end
1001         when &quot;loadp&quot;
1002             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86LoadOperands(:ptr, :ptr)}&quot;
1003         when &quot;storep&quot;
1004             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
1005         when &quot;loadq&quot;
1006             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86LoadOperands(:quad, :quad)}&quot;
1007         when &quot;storeq&quot;
1008             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
1009         when &quot;loadb&quot;
1010             if !isIntelSyntax
1011                 $asm.puts &quot;movzbl #{x86LoadOperands(:byte, :int)}&quot;
1012             else
1013                 $asm.puts &quot;movzx #{x86LoadOperands(:byte, :int)}&quot;
1014             end
1015         when &quot;loadbs&quot;
1016             if !isIntelSyntax
1017                 $asm.puts &quot;movsbl #{x86LoadOperands(:byte, :int)}&quot;
1018             else
1019                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :int)}&quot;
1020             end
1021         when &quot;loadbsp&quot;
1022             if !isIntelSyntax
1023                 $asm.puts &quot;movsb#{x86Suffix(:ptr)} #{x86LoadOperands(:byte, :ptr)}&quot;
1024             else
1025                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :ptr)}&quot;
1026             end
1027         when &quot;loadh&quot;
1028             if !isIntelSyntax
1029                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
1030             else
1031                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
1032             end
1033         when &quot;loadhs&quot;
1034             if !isIntelSyntax
1035                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
1036             else
1037                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
1038             end
1039         when &quot;storeb&quot;
1040             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
1041         when &quot;loadd&quot;
1042             if useX87
1043                 if !isIntelSyntax
1044                     $asm.puts &quot;fldl #{operands[0].x86Operand(:double)}&quot;
1045                 else
1046                     $asm.puts &quot;fld #{operands[0].x86Operand(:double)}&quot;
1047                 end
1048                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;
1049             else
1050                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1051             end
1052         when &quot;moved&quot;
1053             if useX87
1054                 if (operands[0].x87DefaultStackPosition == 0)
1055                     $asm.puts &quot;fst #{operands[1].x87Operand(0)}&quot;
1056                 else
1057                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1058                     $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;
1059                 end
1060             else
1061                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1062             end
1063         when &quot;stored&quot;
1064             if useX87
1065                 if (operands[0].x87DefaultStackPosition == 0)
1066                     $asm.puts &quot;fst#{x86Suffix(:int)} #{operands[1].x86Operand(:double)}&quot;
1067                 else
1068                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1069                     if !isIntelSyntax
1070                         $asm.puts &quot;fstpl #{operands[1].x86Operand(:double)}&quot;
1071                     else
1072                         $asm.puts &quot;fstp #{operands[1].x86Operand(:double)}&quot;
1073                     end
1074                 end
1075             else
1076                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1077             end
1078         when &quot;addd&quot;
1079             if useX87
1080                 handleX87BinOp(&quot;fadd&quot;, &quot;fadd&quot;)
1081             else
1082                 $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;
1083             end
1084         when &quot;muld&quot;
1085             if useX87
1086                 handleX87BinOp(&quot;fmul&quot;, &quot;fmul&quot;)
1087             else
1088                 $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;
1089             end
1090         when &quot;subd&quot;
1091             if useX87
1092                 handleX87BinOp(&quot;fsub&quot;, &quot;fsubr&quot;)
1093             else
1094                 $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;
1095             end
1096         when &quot;divd&quot;
1097             if useX87
1098                 handleX87BinOp(&quot;fdiv&quot;, &quot;fdivr&quot;)
1099             else
1100                 $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;
1101             end
1102         when &quot;sqrtd&quot;
1103             if useX87
1104                 $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1105                 $asm.puts &quot;fsqrtl&quot;
1106                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;
1107             else
1108                 $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
1109             end
1110         when &quot;ci2d&quot;
1111             if useX87
1112                 sp = RegisterID.new(nil, &quot;sp&quot;)
1113                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), offsetRegister(-4, sp.x86Operand(:ptr)))}&quot;
1114                 $asm.puts &quot;fild#{x86Suffix(:ptr)} #{getSizeString(:ptr)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;
1115                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;
1116             else
1117                 $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
1118             end
1119         when &quot;bdeq&quot;
1120             if useX87
1121                 handleX87Compare(:normal)
1122             else
1123                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1124             end
1125             if operands[0] == operands[1]
1126                 # This is just a jump ordered, which is a jnp.
1127                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
1128             else
1129                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
1130                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1131                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1132                 isUnordered.lower(&quot;X86&quot;)
1133             end
1134         when &quot;bdneq&quot;
1135             handleX86DoubleBranch(&quot;jne&quot;, :normal)
1136         when &quot;bdgt&quot;
1137             handleX86DoubleBranch(&quot;ja&quot;, :normal)
1138         when &quot;bdgteq&quot;
1139             handleX86DoubleBranch(&quot;jae&quot;, :normal)
1140         when &quot;bdlt&quot;
1141             handleX86DoubleBranch(&quot;ja&quot;, :reverse)
1142         when &quot;bdlteq&quot;
1143             handleX86DoubleBranch(&quot;jae&quot;, :reverse)
1144         when &quot;bdequn&quot;
1145             handleX86DoubleBranch(&quot;je&quot;, :normal)
1146         when &quot;bdnequn&quot;
1147             if useX87
1148                 handleX87Compare(:normal)
1149             else
1150                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1151             end
1152             if operands[0] == operands[1]
1153                 # This is just a jump unordered, which is a jp.
1154                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1155             else
1156                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1157                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
1158                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1159                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;
1160                 isUnordered.lower(&quot;X86&quot;)
1161                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
1162                 isEqual.lower(&quot;X86&quot;)
1163             end
1164         when &quot;bdgtun&quot;
1165             handleX86DoubleBranch(&quot;jb&quot;, :reverse)
1166         when &quot;bdgtequn&quot;
1167             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)
1168         when &quot;bdltun&quot;
1169             handleX86DoubleBranch(&quot;jb&quot;, :normal)
1170         when &quot;bdltequn&quot;
1171             handleX86DoubleBranch(&quot;jbe&quot;, :normal)
1172         when &quot;btd2i&quot;
1173             # FIXME: unused and unimplemented for x87
1174             raise if useX87
1175             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1176             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1177             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1178         when &quot;td2i&quot;
1179             # FIXME: unused and unimplemented for x87
1180             raise if useX87
1181             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1182         when &quot;bcd2i&quot;
1183             if useX87
1184                 floatingPointCompareImplicitOperand = getImplicitOperandString
1185                 sp = RegisterID.new(nil, &quot;sp&quot;)
1186                 if (operands[0].x87DefaultStackPosition == 0)
1187                     $asm.puts &quot;fistl -4(#{sp.x86Operand(:ptr)})&quot;
1188                 else
1189                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1190                     $asm.puts &quot;fistp#{x86Suffix(:ptr)} #{getSizeString(:ptr)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;
1191                 end
1192                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-4, sp.x86Operand(:ptr)), operands[1].x86Operand(:int))}&quot;
1193                 $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1194                 $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1195                 $asm.puts &quot;fild#{x86Suffix(:int)} #{getSizeString(:int)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;
1196                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(1)}&quot;
1197                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1198                 $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1199             else
1200                 $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1201                 $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1202                 $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1203                 $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1204                 $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1205                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1206                 $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1207             end
1208         when &quot;movdz&quot;
1209             if useX87
1210                 $asm.puts &quot;fldzl&quot;
1211                 $asm.puts &quot;fstp #{operands[0].x87Operand(1)}&quot;
1212             else
1213                 $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;
1214             end
1215         when &quot;pop&quot;
1216             operands.each {
1217                 | op |
1218                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
1219             }
1220         when &quot;push&quot;
1221             operands.each {
1222                 | op |
1223                 $asm.puts &quot;push #{op.x86Operand(:ptr)}&quot;
1224             }
1225         when &quot;move&quot;
1226             handleMove
1227         when &quot;sxi2q&quot;
1228             if !isIntelSyntax
1229                 $asm.puts &quot;movslq #{operands[0].x86Operand(:int)}, #{operands[1].x86Operand(:quad)}&quot;
1230             else
1231                 $asm.puts &quot;movsxd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:quad))}&quot;
1232             end
1233         when &quot;zxi2q&quot;
1234             $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:int))}&quot;
1235         when &quot;nop&quot;
1236             $asm.puts &quot;nop&quot;
1237         when &quot;bieq&quot;
1238             handleX86IntBranch(&quot;je&quot;, :int)
1239         when &quot;bpeq&quot;
1240             handleX86IntBranch(&quot;je&quot;, :ptr)
1241         when &quot;bqeq&quot;
1242             handleX86IntBranch(&quot;je&quot;, :quad)
1243         when &quot;bineq&quot;
1244             handleX86IntBranch(&quot;jne&quot;, :int)
1245         when &quot;bpneq&quot;
1246             handleX86IntBranch(&quot;jne&quot;, :ptr)
1247         when &quot;bqneq&quot;
1248             handleX86IntBranch(&quot;jne&quot;, :quad)
1249         when &quot;bia&quot;
1250             handleX86IntBranch(&quot;ja&quot;, :int)
1251         when &quot;bpa&quot;
1252             handleX86IntBranch(&quot;ja&quot;, :ptr)
1253         when &quot;bqa&quot;
1254             handleX86IntBranch(&quot;ja&quot;, :quad)
1255         when &quot;biaeq&quot;
1256             handleX86IntBranch(&quot;jae&quot;, :int)
1257         when &quot;bpaeq&quot;
1258             handleX86IntBranch(&quot;jae&quot;, :ptr)
1259         when &quot;bqaeq&quot;
1260             handleX86IntBranch(&quot;jae&quot;, :quad)
1261         when &quot;bib&quot;
1262             handleX86IntBranch(&quot;jb&quot;, :int)
1263         when &quot;bpb&quot;
1264             handleX86IntBranch(&quot;jb&quot;, :ptr)
1265         when &quot;bqb&quot;
1266             handleX86IntBranch(&quot;jb&quot;, :quad)
1267         when &quot;bibeq&quot;
1268             handleX86IntBranch(&quot;jbe&quot;, :int)
1269         when &quot;bpbeq&quot;
1270             handleX86IntBranch(&quot;jbe&quot;, :ptr)
1271         when &quot;bqbeq&quot;
1272             handleX86IntBranch(&quot;jbe&quot;, :quad)
1273         when &quot;bigt&quot;
1274             handleX86IntBranch(&quot;jg&quot;, :int)
1275         when &quot;bpgt&quot;
1276             handleX86IntBranch(&quot;jg&quot;, :ptr)
1277         when &quot;bqgt&quot;
1278             handleX86IntBranch(&quot;jg&quot;, :quad)
1279         when &quot;bigteq&quot;
1280             handleX86IntBranch(&quot;jge&quot;, :int)
1281         when &quot;bpgteq&quot;
1282             handleX86IntBranch(&quot;jge&quot;, :ptr)
1283         when &quot;bqgteq&quot;
1284             handleX86IntBranch(&quot;jge&quot;, :quad)
1285         when &quot;bilt&quot;
1286             handleX86IntBranch(&quot;jl&quot;, :int)
1287         when &quot;bplt&quot;
1288             handleX86IntBranch(&quot;jl&quot;, :ptr)
1289         when &quot;bqlt&quot;
1290             handleX86IntBranch(&quot;jl&quot;, :quad)
1291         when &quot;bilteq&quot;
1292             handleX86IntBranch(&quot;jle&quot;, :int)
1293         when &quot;bplteq&quot;
1294             handleX86IntBranch(&quot;jle&quot;, :ptr)
1295         when &quot;bqlteq&quot;
1296             handleX86IntBranch(&quot;jle&quot;, :quad)
1297         when &quot;bbeq&quot;
1298             handleX86IntBranch(&quot;je&quot;, :byte)
1299         when &quot;bbneq&quot;
1300             handleX86IntBranch(&quot;jne&quot;, :byte)
1301         when &quot;bba&quot;
1302             handleX86IntBranch(&quot;ja&quot;, :byte)
1303         when &quot;bbaeq&quot;
1304             handleX86IntBranch(&quot;jae&quot;, :byte)
1305         when &quot;bbb&quot;
1306             handleX86IntBranch(&quot;jb&quot;, :byte)
1307         when &quot;bbbeq&quot;
1308             handleX86IntBranch(&quot;jbe&quot;, :byte)
1309         when &quot;bbgt&quot;
1310             handleX86IntBranch(&quot;jg&quot;, :byte)
1311         when &quot;bbgteq&quot;
1312             handleX86IntBranch(&quot;jge&quot;, :byte)
1313         when &quot;bblt&quot;
1314             handleX86IntBranch(&quot;jl&quot;, :byte)
1315         when &quot;bblteq&quot;
1316             handleX86IntBranch(&quot;jlteq&quot;, :byte)
1317         when &quot;btis&quot;
1318             handleX86BranchTest(&quot;js&quot;, :int)
1319         when &quot;btps&quot;
1320             handleX86BranchTest(&quot;js&quot;, :ptr)
1321         when &quot;btqs&quot;
1322             handleX86BranchTest(&quot;js&quot;, :quad)
1323         when &quot;btiz&quot;
1324             handleX86BranchTest(&quot;jz&quot;, :int)
1325         when &quot;btpz&quot;
1326             handleX86BranchTest(&quot;jz&quot;, :ptr)
1327         when &quot;btqz&quot;
1328             handleX86BranchTest(&quot;jz&quot;, :quad)
1329         when &quot;btinz&quot;
1330             handleX86BranchTest(&quot;jnz&quot;, :int)
1331         when &quot;btpnz&quot;
1332             handleX86BranchTest(&quot;jnz&quot;, :ptr)
1333         when &quot;btqnz&quot;
1334             handleX86BranchTest(&quot;jnz&quot;, :quad)
1335         when &quot;btbs&quot;
1336             handleX86BranchTest(&quot;js&quot;, :byte)
1337         when &quot;btbz&quot;
1338             handleX86BranchTest(&quot;jz&quot;, :byte)
1339         when &quot;btbnz&quot;
1340             handleX86BranchTest(&quot;jnz&quot;, :byte)
1341         when &quot;jmp&quot;
1342             $asm.puts &quot;jmp #{operands[0].x86CallOperand(:ptr)}&quot;
1343         when &quot;baddio&quot;
1344             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1345         when &quot;baddpo&quot;
1346             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jo&quot;, :ptr)
1347         when &quot;baddqo&quot;
1348             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jo&quot;, :quad)
1349         when &quot;baddis&quot;
1350             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1351         when &quot;baddps&quot;
1352             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;js&quot;, :ptr)
1353         when &quot;baddqs&quot;
1354             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;js&quot;, :quad)
1355         when &quot;baddiz&quot;
1356             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1357         when &quot;baddpz&quot;
1358             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jz&quot;, :ptr)
1359         when &quot;baddqz&quot;
1360             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jz&quot;, :quad)
1361         when &quot;baddinz&quot;
1362             handleX86OpBranch(&quot;add#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1363         when &quot;baddpnz&quot;
1364             handleX86OpBranch(&quot;add#{x86Suffix(:ptr)}&quot;, &quot;jnz&quot;, :ptr)
1365         when &quot;baddqnz&quot;
1366             handleX86OpBranch(&quot;add#{x86Suffix(:quad)}&quot;, &quot;jnz&quot;, :quad)
1367         when &quot;bsubio&quot;
1368             handleX86SubBranch(&quot;jo&quot;, :int)
1369         when &quot;bsubis&quot;
1370             handleX86SubBranch(&quot;js&quot;, :int)
1371         when &quot;bsubiz&quot;
1372             handleX86SubBranch(&quot;jz&quot;, :int)
1373         when &quot;bsubinz&quot;
1374             handleX86SubBranch(&quot;jnz&quot;, :int)
1375         when &quot;bmulio&quot;
1376             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1377         when &quot;bmulis&quot;
1378             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1379         when &quot;bmuliz&quot;
1380             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1381         when &quot;bmulinz&quot;
1382             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1383         when &quot;borio&quot;
1384             handleX86OpBranch(&quot;orl&quot;, &quot;jo&quot;, :int)
1385         when &quot;boris&quot;
1386             handleX86OpBranch(&quot;orl&quot;, &quot;js&quot;, :int)
1387         when &quot;boriz&quot;
1388             handleX86OpBranch(&quot;orl&quot;, &quot;jz&quot;, :int)
1389         when &quot;borinz&quot;
1390             handleX86OpBranch(&quot;orl&quot;, &quot;jnz&quot;, :int)
1391         when &quot;break&quot;
1392             $asm.puts &quot;int #{const(3)}&quot;
1393         when &quot;call&quot;
1394             if useX87
1395                 2.times {
1396                     | offset |
1397                     $asm.puts &quot;ffree #{register(&quot;st&quot;)}(#{offset})&quot;
1398                 }
1399             end
1400             op = operands[0].x86CallOperand(:ptr)
1401             if operands[0].is_a? LabelReference
1402                 operands[0].used
1403             end
1404             $asm.puts &quot;call #{op}&quot;
1405         when &quot;ret&quot;
1406             $asm.puts &quot;ret&quot;
1407         when &quot;cieq&quot;
1408             handleX86IntCompareSet(&quot;sete&quot;, :int)
1409         when &quot;cbeq&quot;
1410             handleX86IntCompareSet(&quot;sete&quot;, :byte)
1411         when &quot;cpeq&quot;
1412             handleX86IntCompareSet(&quot;sete&quot;, :ptr)
1413         when &quot;cqeq&quot;
1414             handleX86IntCompareSet(&quot;sete&quot;, :quad)
1415         when &quot;cineq&quot;
1416             handleX86IntCompareSet(&quot;setne&quot;, :int)
1417         when &quot;cbneq&quot;
1418             handleX86IntCompareSet(&quot;setne&quot;, :byte)
1419         when &quot;cpneq&quot;
1420             handleX86IntCompareSet(&quot;setne&quot;, :ptr)
1421         when &quot;cqneq&quot;
1422             handleX86IntCompareSet(&quot;setne&quot;, :quad)
1423         when &quot;cia&quot;
1424             handleX86IntCompareSet(&quot;seta&quot;, :int)
1425         when &quot;cba&quot;
1426             handleX86IntCompareSet(&quot;seta&quot;, :byte)
1427         when &quot;cpa&quot;
1428             handleX86IntCompareSet(&quot;seta&quot;, :ptr)
1429         when &quot;cqa&quot;
1430             handleX86IntCompareSet(&quot;seta&quot;, :quad)
1431         when &quot;ciaeq&quot;
1432             handleX86IntCompareSet(&quot;setae&quot;, :int)
1433         when &quot;cbaeq&quot;
1434             handleX86IntCompareSet(&quot;setae&quot;, :byte)
1435         when &quot;cpaeq&quot;
1436             handleX86IntCompareSet(&quot;setae&quot;, :ptr)
1437         when &quot;cqaeq&quot;
1438             handleX86IntCompareSet(&quot;setae&quot;, :quad)
1439         when &quot;cib&quot;
1440             handleX86IntCompareSet(&quot;setb&quot;, :int)
1441         when &quot;cbb&quot;
1442             handleX86IntCompareSet(&quot;setb&quot;, :byte)
1443         when &quot;cpb&quot;
1444             handleX86IntCompareSet(&quot;setb&quot;, :ptr)
1445         when &quot;cqb&quot;
1446             handleX86IntCompareSet(&quot;setb&quot;, :quad)
1447         when &quot;cibeq&quot;
1448             handleX86IntCompareSet(&quot;setbe&quot;, :int)
1449         when &quot;cbbeq&quot;
1450             handleX86IntCompareSet(&quot;setbe&quot;, :byte)
1451         when &quot;cpbeq&quot;
1452             handleX86IntCompareSet(&quot;setbe&quot;, :ptr)
1453         when &quot;cqbeq&quot;
1454             handleX86IntCompareSet(&quot;setbe&quot;, :quad)
1455         when &quot;cigt&quot;
1456             handleX86IntCompareSet(&quot;setg&quot;, :int)
1457         when &quot;cbgt&quot;
1458             handleX86IntCompareSet(&quot;setg&quot;, :byte)
1459         when &quot;cpgt&quot;
1460             handleX86IntCompareSet(&quot;setg&quot;, :ptr)
1461         when &quot;cqgt&quot;
1462             handleX86IntCompareSet(&quot;setg&quot;, :quad)
1463         when &quot;cigteq&quot;
1464             handleX86IntCompareSet(&quot;setge&quot;, :int)
1465         when &quot;cbgteq&quot;
1466             handleX86IntCompareSet(&quot;setge&quot;, :byte)
1467         when &quot;cpgteq&quot;
1468             handleX86IntCompareSet(&quot;setge&quot;, :ptr)
1469         when &quot;cqgteq&quot;
1470             handleX86IntCompareSet(&quot;setge&quot;, :quad)
1471         when &quot;cilt&quot;
1472             handleX86IntCompareSet(&quot;setl&quot;, :int)
1473         when &quot;cblt&quot;
1474             handleX86IntCompareSet(&quot;setl&quot;, :byte)
1475         when &quot;cplt&quot;
1476             handleX86IntCompareSet(&quot;setl&quot;, :ptr)
1477         when &quot;cqlt&quot;
1478             handleX86IntCompareSet(&quot;setl&quot;, :quad)
1479         when &quot;cilteq&quot;
1480             handleX86IntCompareSet(&quot;setle&quot;, :int)
1481         when &quot;cblteq&quot;
1482             handleX86IntCompareSet(&quot;setle&quot;, :byte)
1483         when &quot;cplteq&quot;
1484             handleX86IntCompareSet(&quot;setle&quot;, :ptr)
1485         when &quot;cqlteq&quot;
1486             handleX86IntCompareSet(&quot;setle&quot;, :quad)
1487         when &quot;tis&quot;
1488             handleX86SetTest(&quot;sets&quot;, :int)
1489         when &quot;tiz&quot;
1490             handleX86SetTest(&quot;setz&quot;, :int)
1491         when &quot;tinz&quot;
1492             handleX86SetTest(&quot;setnz&quot;, :int)
1493         when &quot;tps&quot;
1494             handleX86SetTest(&quot;sets&quot;, :ptr)
1495         when &quot;tpz&quot;
1496             handleX86SetTest(&quot;setz&quot;, :ptr)
1497         when &quot;tpnz&quot;
1498             handleX86SetTest(&quot;setnz&quot;, :ptr)
1499         when &quot;tqs&quot;
1500             handleX86SetTest(&quot;sets&quot;, :quad)
1501         when &quot;tqz&quot;
1502             handleX86SetTest(&quot;setz&quot;, :quad)
1503         when &quot;tqnz&quot;
1504             handleX86SetTest(&quot;setnz&quot;, :quad)
1505         when &quot;tbs&quot;
1506             handleX86SetTest(&quot;sets&quot;, :byte)
1507         when &quot;tbz&quot;
1508             handleX86SetTest(&quot;setz&quot;, :byte)
1509         when &quot;tbnz&quot;
1510             handleX86SetTest(&quot;setnz&quot;, :byte)
1511         when &quot;peek&quot;
1512             handleX86Peek()
1513         when &quot;poke&quot;
1514             handleX86Poke()
1515         when &quot;cdqi&quot;
1516             $asm.puts &quot;cdq&quot;
1517         when &quot;idivi&quot;
1518             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1519         when &quot;fii2d&quot;
1520             if useX87
1521                 sp = RegisterID.new(nil, &quot;sp&quot;)
1522                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), offsetRegister(-8, sp.x86Operand(:ptr)))}&quot;
1523                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[1].x86Operand(:int), offsetRegister(-4, sp.x86Operand(:ptr)))}&quot;
1524                 $asm.puts &quot;fld#{x86Suffix(:ptr)} #{getSizeString(:double)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;
1525                 $asm.puts &quot;fstp #{operands[2].x87Operand(1)}&quot;
1526             else
1527                 $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
1528                 $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1529                 $asm.puts &quot;psllq $32, %xmm7&quot;
1530                 $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
1531             end
1532         when &quot;fd2ii&quot;
1533             if useX87
1534                 sp = RegisterID.new(nil, &quot;sp&quot;)
1535                 if (operands[0].x87DefaultStackPosition == 0)
1536                     $asm.puts &quot;fst#{x86Suffix(:ptr)} #{getSizeString(:double)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;
1537                 else
1538                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1539                     $asm.puts &quot;fstpl -8(#{sp.x86Operand(:ptr)})&quot;
1540                 end
1541                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-8, sp.x86Operand(:ptr)), operands[1].x86Operand(:int))}&quot;
1542                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-4, sp.x86Operand(:ptr)), operands[2].x86Operand(:int))}&quot;
1543             else
1544                 $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1545                 $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1546                 $asm.puts &quot;psrlq $32, %xmm7&quot;
1547                 $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;
1548             end
1549         when &quot;fq2d&quot;
1550             if useX87
1551                 sp = RegisterID.new(nil, &quot;sp&quot;)
1552                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, -8(#{sp.x86Operand(:ptr)})&quot;
1553                 $asm.puts &quot;fldl -8(#{sp.x86Operand(:ptr)})&quot;
1554                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;
1555             else
1556                 if !isIntelSyntax
1557                     $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;
1558                 else
1559                     # MASM does not accept register operands with movq.
1560                     # Debugging shows that movd actually moves a qword when using MASM.
1561                     $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;
1562                 end
1563             end
1564         when &quot;fd2q&quot;
1565             if useX87
1566                 sp = RegisterID.new(nil, &quot;sp&quot;)
1567                 if (operands[0].x87DefaultStackPosition == 0)
1568                     $asm.puts &quot;fst#{x86Suffix(:int)} #{getSizeString(:int)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;
1569                 else
1570                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;
1571                     $asm.puts &quot;fstpl -8(#{sp.x86Operand(:ptr)})&quot;
1572                 end
1573                 $asm.puts &quot;movq -8(#{sp.x86Operand(:ptr)}), #{operands[1].x86Operand(:quad)}&quot;
1574             else
1575                 if !isIntelSyntax
1576                     $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1577                 else
1578                     # MASM does not accept register operands with movq.
1579                     # Debugging shows that movd actually moves a qword when using MASM.
1580                     $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
1581                 end
1582             end
1583         when &quot;bo&quot;
1584             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1585         when &quot;bs&quot;
1586             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1587         when &quot;bz&quot;
1588             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1589         when &quot;bnz&quot;
1590             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1591         when &quot;leai&quot;
1592             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1593         when &quot;leap&quot;
1594             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1595         when &quot;memfence&quot;
1596             sp = RegisterID.new(nil, &quot;sp&quot;)
1597             if isIntelSyntax
1598                 $asm.puts &quot;mfence&quot;
1599             else
1600                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1601             end
1602         else
1603             lowerDefault
1604         end
1605     end
1606 end
1607 
    </pre>
  </body>
</html>