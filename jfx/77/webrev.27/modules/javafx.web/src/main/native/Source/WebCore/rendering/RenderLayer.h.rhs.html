<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2003, 2009, 2012, 2015 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #pragma once
  45 
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;
<a name="1" id="anc1"></a><span class="line-added">  66 class EventRegionContext;</span>
  67 class HitTestRequest;
  68 class HitTestResult;
  69 class HitTestingTransformState;
<a name="2" id="anc2"></a><span class="line-added">  70 class Region;</span>
  71 class RenderFragmentedFlow;
  72 class RenderGeometryMap;
  73 class RenderLayerBacking;
  74 class RenderLayerCompositor;
  75 class RenderLayerFilters;
  76 class RenderMarquee;
  77 class RenderReplica;
  78 class RenderScrollbarPart;
  79 class RenderStyle;
  80 class RenderView;
  81 class Scrollbar;
  82 class TransformationMatrix;
  83 
  84 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  85 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  86 
  87 enum RepaintStatus {
  88     NeedsNormalRepaint,
  89     NeedsFullRepaint,
  90     NeedsFullRepaintForPositionedMovementLayout
  91 };
  92 
  93 enum ClipRectsType {
  94     PaintingClipRects, // Relative to painting ancestor. Used for painting.
  95     RootRelativeClipRects, // Relative to the ancestor treated as the root (e.g. transformed layer). Used for hit testing.
  96     AbsoluteClipRects, // Relative to the RenderView&#39;s layer. Used for compositing overlap testing.
  97     NumCachedClipRectsTypes,
  98     AllClipRectTypes,
  99     TemporaryClipRects
 100 };
 101 
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
<a name="3" id="anc3"></a><span class="line-added"> 120 enum class IndirectCompositingReason {</span>
<span class="line-added"> 121     None,</span>
<span class="line-added"> 122     Stacking,</span>
<span class="line-added"> 123     OverflowScrollPositioning,</span>
<span class="line-added"> 124     Overlap,</span>
<span class="line-added"> 125     BackgroundLayer,</span>
<span class="line-added"> 126     GraphicalEffect, // opacity, mask, filter, transform etc.</span>
<span class="line-added"> 127     Perspective,</span>
<span class="line-added"> 128     Preserve3D</span>
<span class="line-added"> 129 };</span>
<span class="line-added"> 130 </span>
 131 struct ScrollRectToVisibleOptions {
 132     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 133     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 134     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 135     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 136 };
 137 
 138 class RenderLayer final : public ScrollableArea {
 139     WTF_MAKE_FAST_ALLOCATED;
 140 public:
 141     friend class RenderReplica;
 142     friend class RenderLayerFilters;
<a name="4" id="anc4"></a><span class="line-added"> 143     friend class RenderLayerBacking;</span>
<span class="line-added"> 144     friend class RenderLayerCompositor;</span>
 145 
 146     explicit RenderLayer(RenderLayerModelObject&amp;);
 147     virtual ~RenderLayer();
 148 
 149 #if PLATFORM(IOS_FAMILY)
 150     // Called before the renderer&#39;s widget (if any) has been nulled out.
 151     void willBeDestroyed();
 152 #endif
 153     String name() const;
 154 
 155     Page&amp; page() const { return renderer().page(); }
 156     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 157     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 158 
 159     RenderLayer* parent() const { return m_parent; }
 160     RenderLayer* previousSibling() const { return m_previous; }
 161     RenderLayer* nextSibling() const { return m_next; }
 162     RenderLayer* firstChild() const { return m_first; }
 163     RenderLayer* lastChild() const { return m_last; }
 164     bool isDescendantOf(const RenderLayer&amp;) const;
 165 
 166     // This does an ancestor tree walk. Avoid it!
 167     const RenderLayer* root() const
 168     {
 169         const RenderLayer* curr = this;
 170         while (curr-&gt;parent())
 171             curr = curr-&gt;parent();
 172         return curr;
 173     }
 174 
 175     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 176     void removeChild(RenderLayer&amp;);
 177 
 178     void insertOnlyThisLayer();
 179     void removeOnlyThisLayer();
 180 
 181     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
<a name="5" id="anc5"></a><span class="line-modified"> 182 </span>
<span class="line-added"> 183     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.</span>
<span class="line-added"> 184     // Not all stacking contexts are CSS stacking contexts.</span>
<span class="line-added"> 185     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.</span>
<span class="line-added"> 188     // isCSSStackingContext() =&gt; isStackingContext().</span>
<span class="line-added"> 189     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.</span>
<span class="line-added"> 190     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }</span>
 191 
 192     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 193     RenderLayer* stackingContext() const;
 194 
 195     // Gets the enclosing stacking container for this layer, possibly the layer
 196     // itself, if it is a stacking container.
 197     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 198 
 199     RenderLayer* paintOrderParent() const;
 200 
 201     void dirtyNormalFlowList();
 202     void dirtyZOrderLists();
 203     void dirtyStackingContextZOrderLists();
 204 
 205     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 206     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 207 
 208 #if !ASSERT_DISABLED
 209     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 210     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 211 #endif
 212 
 213 private:
 214     // These flags propagate in paint order (z-order tree).
 215     enum class Compositing {
 216         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 217         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 218 
 219         // Things that trigger HasDescendantNeedingRequirementsTraversal
 220         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 221         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 222         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 223         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 224 
 225         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 226         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 227         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 228         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
 229         NeedsLayerConnection                                = 1 &lt;&lt; 9, // This layer needs hookup with its parents or children.
 230         ChildrenNeedGeometryUpdate                          = 1 &lt;&lt; 10, // This layer&#39;s composited children need a geometry update.
 231         DescendantsNeedBackingAndHierarchyTraversal         = 1 &lt;&lt; 11, // Something changed that forces us to traverse all descendant layers in updateBackingAndHierarchy.
 232     };
 233 
 234     static constexpr OptionSet&lt;Compositing&gt; computeCompositingRequirementsFlags()
 235     {
 236         return {
 237             Compositing::NeedsPaintOrderChildrenUpdate,
 238             Compositing::NeedsPostLayoutUpdate,
 239             Compositing::DescendantsNeedRequirementsTraversal,
 240             Compositing::SubsequentLayersNeedRequirementsTraversal,
 241         };
 242     }
 243 
 244     static constexpr OptionSet&lt;Compositing&gt; updateBackingOrHierarchyFlags()
 245     {
 246         return {
 247             Compositing::NeedsLayerConnection,
 248             Compositing::NeedsGeometryUpdate,
 249             Compositing::NeedsConfigurationUpdate,
 250             Compositing::NeedsScrollingTreeUpdate,
 251             Compositing::ChildrenNeedGeometryUpdate,
 252             Compositing::DescendantsNeedBackingAndHierarchyTraversal,
 253         };
 254     }
 255 
 256     void setAncestorsHaveCompositingDirtyFlag(Compositing);
 257 
 258 public:
 259     bool hasDescendantNeedingCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingRequirementsTraversal); }
 260     bool hasDescendantNeedingUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal); }
 261 
 262     bool needsCompositingPaintOrderChildrenUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPaintOrderChildrenUpdate); }
 263     bool needsPostLayoutCompositingUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPostLayoutUpdate); }
 264     bool descendantsNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedRequirementsTraversal); }
 265     bool subsequentLayersNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::SubsequentLayersNeedRequirementsTraversal); }
 266 
 267     bool needsCompositingLayerConnection() const { return m_compositingDirtyBits.contains(Compositing::NeedsLayerConnection); }
 268     bool needsCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsGeometryUpdate); }
 269     bool needsCompositingConfigurationUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsConfigurationUpdate); }
 270     bool needsScrollingTreeUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsScrollingTreeUpdate); }
 271     bool childrenNeedCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::ChildrenNeedGeometryUpdate); }
 272     bool descendantsNeedUpdateBackingAndHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedBackingAndHierarchyTraversal); }
 273 
 274     template&lt;Compositing V&gt;
 275     void setRequirementsTraversalDirtyBit()
 276     {
 277         m_compositingDirtyBits.add(V);
 278         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 279     }
 280 
 281     void setNeedsCompositingPaintOrderChildrenUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPaintOrderChildrenUpdate&gt;(); }
 282     void setNeedsPostLayoutCompositingUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPostLayoutUpdate&gt;(); }
 283     void setDescendantsNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::DescendantsNeedRequirementsTraversal&gt;(); }
 284     void setSubsequentLayersNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::SubsequentLayersNeedRequirementsTraversal&gt;(); }
 285 
 286     void setNeedsPostLayoutCompositingUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsPostLayoutUpdate); }
 287 
 288     template&lt;Compositing V&gt;
 289     void setBackingAndHierarchyTraversalDirtyBit()
 290     {
 291         m_compositingDirtyBits.add(V);
 292         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 293     }
 294 
 295     void setNeedsCompositingLayerConnection() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsLayerConnection&gt;(); }
 296     void setNeedsCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsGeometryUpdate&gt;(); }
 297     void setNeedsCompositingConfigurationUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsConfigurationUpdate&gt;(); }
 298     void setNeedsScrollingTreeUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsScrollingTreeUpdate&gt;(); }
 299     void setChildrenNeedCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::ChildrenNeedGeometryUpdate&gt;(); }
 300     void setDescendantsNeedUpdateBackingAndHierarchyTraversal() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::DescendantsNeedBackingAndHierarchyTraversal&gt;(); }
 301 
 302     void setNeedsCompositingGeometryUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsGeometryUpdate); }
 303 
 304     bool needsCompositingRequirementsTraversal() const { return m_compositingDirtyBits.containsAny(computeCompositingRequirementsFlags()); }
 305     void clearCompositingRequirementsTraversalState()
 306     {
 307         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingRequirementsTraversal);
 308         m_compositingDirtyBits.remove(computeCompositingRequirementsFlags());
 309     }
 310 
 311     bool needsUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.containsAny(updateBackingOrHierarchyFlags()); }
 312     void clearUpdateBackingOrHierarchyTraversalState()
 313     {
 314         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 315         m_compositingDirtyBits.remove(updateBackingOrHierarchyFlags());
 316     }
 317 
 318     bool needsAnyCompositingTraversal() const { return !m_compositingDirtyBits.isEmpty(); }
 319     void clearCompositingPaintOrderState() { m_compositingDirtyBits = { }; }
 320 
 321     class LayerList {
 322         friend class RenderLayer;
 323     public:
 324         using iterator = RenderLayer**;
 325         using const_iterator = RenderLayer * const *;
 326         using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
 327         using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
 328 
 329         iterator begin() { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 330         iterator end() { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 331 
 332         reverse_iterator rbegin() { return reverse_iterator(end()); }
 333         reverse_iterator rend() { return reverse_iterator(begin()); }
 334 
 335         const_iterator begin() const { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 336         const_iterator end() const { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 337 
 338         const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 339         const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 340 
 341         size_t size() const { return m_layerList ? m_layerList-&gt;size() : 0; }
 342 
 343     private:
 344         LayerList(Vector&lt;RenderLayer*&gt;* layerList)
 345             : m_layerList(layerList)
 346         {
 347         }
 348 
 349         Vector&lt;RenderLayer*&gt;* m_layerList;
 350     };
 351 
 352     LayerList normalFlowLayers() const
 353     {
 354         ASSERT(!m_normalFlowListDirty);
 355         return LayerList(m_normalFlowList.get());
 356     }
 357 
 358     LayerList positiveZOrderLayers() const
 359     {
 360         ASSERT(!m_zOrderListsDirty);
 361         ASSERT(isStackingContext() || !m_posZOrderList);
 362         return LayerList(m_posZOrderList.get());
 363     }
 364 
 365     bool hasNegativeZOrderLayers() const
 366     {
 367         return m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 368     }
 369 
 370     LayerList negativeZOrderLayers() const
 371     {
 372         ASSERT(!m_zOrderListsDirty);
 373         ASSERT(isStackingContext() || !m_negZOrderList);
 374         return LayerList(m_negZOrderList.get());
 375     }
 376 
 377     // Update our normal and z-index lists.
 378     void updateLayerListsIfNeeded();
 379     void updateDescendantDependentFlags();
 380     bool descendantDependentFlagsAreDirty() const
 381     {
 382         return m_visibleDescendantStatusDirty || m_visibleContentStatusDirty || m_hasSelfPaintingLayerDescendantDirty
 383 #if ENABLE(CSS_COMPOSITING)
 384             || m_hasNotIsolatedBlendingDescendantsStatusDirty
 385 #endif
 386         ;
 387     }
 388 
 389     void repaintIncludingDescendants();
 390 
 391     // Indicate that the layer contents need to be repainted. Only has an effect
 392     // if layer compositing is being used.
 393     void setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 394 
 395     // The rect is in the coordinate space of the layer&#39;s render object.
 396     void setBackingNeedsRepaintInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 397     void repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer);
 398 
 399     void styleChanged(StyleDifference, const RenderStyle* oldStyle);
 400 
 401     RenderMarquee* marquee() const { return m_marquee.get(); }
 402 
 403     bool isSelfPaintingLayer() const { return m_isSelfPaintingLayer; }
 404 
 405     bool cannotBlitToWindow() const;
 406 
 407     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 408 
 409     bool hasReflection() const { return renderer().hasReflection(); }
 410     bool isReflection() const { return renderer().isReplica(); }
 411     RenderReplica* reflection() const { return m_reflection.get(); }
 412     RenderLayer* reflectionLayer() const;
 413     bool isReflectionLayer(const RenderLayer&amp;) const;
 414 
 415     const LayoutPoint&amp; location() const { return m_topLeft; }
 416     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 417 
 418     const IntSize&amp; size() const { return m_layerSize; }
 419     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 420 
 421     LayoutRect rect() const { return LayoutRect(location(), size()); }
 422 
 423     IntSize visibleSize() const override;
 424     IntSize contentsSize() const override;
<a name="6" id="anc6"></a><span class="line-added"> 425     IntSize reachableTotalContentsSize() const override;</span>
 426 
 427     int scrollWidth() const;
 428     int scrollHeight() const;
 429 
 430     void panScrollFromPoint(const IntPoint&amp;);
 431 
 432     // Scrolling methods for layers that can scroll their overflow.
 433     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 434 
<a name="7" id="anc7"></a><span class="line-modified"> 435     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);</span>


 436 
<a name="8" id="anc8"></a><span class="line-modified"> 437     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified"> 438     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440     // These are only used by marquee.</span>
<span class="line-added"> 441     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
<span class="line-added"> 442     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
 443 
 444     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 445     void applyPostLayoutScrollPositionIfNeeded();
 446 
<a name="9" id="anc9"></a>


 447     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 448 
 449     // &quot;absoluteRect&quot; is in scaled document coordinates.
 450     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 451 
 452     bool scrollsOverflow() const;
<a name="10" id="anc10"></a><span class="line-added"> 453     bool hasScrollableHorizontalOverflow() const;</span>
<span class="line-added"> 454     bool hasScrollableVerticalOverflow() const;</span>
 455     bool hasScrollbars() const { return m_hBar || m_vBar; }
 456     void setHasHorizontalScrollbar(bool);
 457     void setHasVerticalScrollbar(bool);
 458 
 459     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 460     void destroyScrollbar(ScrollbarOrientation);
 461 
 462     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 463     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 464 
<a name="11" id="anc11"></a><span class="line-added"> 465     bool horizontalScrollbarHiddenByStyle() const override;</span>
<span class="line-added"> 466     bool verticalScrollbarHiddenByStyle() const override;</span>
<span class="line-added"> 467 </span>
 468     // ScrollableArea overrides
 469     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 470 
 471     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 472     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 473     ScrollableArea* enclosingScrollableArea() const override;
<a name="12" id="anc12"></a><span class="line-added"> 474 </span>
 475     bool isScrollableOrRubberbandable() override;
 476     bool hasScrollableOrRubberbandableAncestor() override;
 477     bool useDarkAppearance() const final;
 478 #if ENABLE(CSS_SCROLL_SNAP)
 479     void updateSnapOffsets() override;
 480 #endif
 481 
<a name="13" id="anc13"></a>


 482     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 483     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 484 
 485 #if PLATFORM(IOS_FAMILY)
 486 #if ENABLE(IOS_TOUCH_EVENTS)
 487     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 488 #endif
 489 
 490     void didStartScroll() override;
 491     void didEndScroll() override;
 492     void didUpdateScroll() override;
 493 #endif
 494 
 495     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 496     bool canUseCompositedScrolling() const;
 497     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
<a name="14" id="anc14"></a><span class="line-modified"> 498     bool hasCompositedScrollableOverflow() const { return m_hasCompositedScrollableOverflow; }</span>
 499 
 500     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 501     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 502 
 503     bool hasOverflowControls() const;
 504     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 505     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 506     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 507 
 508     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 509     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 510     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 511 
 512     void updateScrollInfoAfterLayout();
 513 
 514     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 515     void autoscroll(const IntPoint&amp;);
 516 
 517     bool canResize() const;
 518     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 519     bool inResizeMode() const { return m_inResizeMode; }
 520     void setInResizeMode(bool b) { m_inResizeMode = b; }
 521 
 522     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 523     bool isForcedStackingContext() const { return m_forcedStackingContext; }
<a name="15" id="anc15"></a><span class="line-added"> 524     bool isOpportunisticStackingContext() const { return m_isOpportunisticStackingContext; }</span>
 525 
 526     RenderLayerCompositor&amp; compositor() const;
 527 
 528     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 529     // Allows updates of layer content without repainting.
 530     void contentChanged(ContentChangeType);
 531 
 532     bool canRender3DTransforms() const;
 533 
<a name="16" id="anc16"></a><span class="line-modified"> 534     void updateLayerPositionsAfterStyleChange();</span>
<span class="line-modified"> 535     void updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint);</span>








 536 
 537     void updateLayerPositionsAfterOverflowScroll();
 538     void updateLayerPositionsAfterDocumentScroll();
 539 
 540     bool hasCompositedLayerInEnclosingPaginationChain() const;
 541     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 542     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 543     {
 544         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 545             return nullptr;
 546         return m_enclosingPaginationLayer.get();
 547     }
 548 
 549     void updateTransform();
 550 
 551 #if ENABLE(CSS_COMPOSITING)
 552     void updateBlendMode();
<a name="17" id="anc17"></a><span class="line-added"> 553     void willRemoveChildWithBlendMode();</span>
 554 #endif
 555 
 556     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 557 
 558     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 559     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 560 
 561     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 562     void clearBlockSelectionGapsBounds();
 563     void repaintBlockSelectionGaps();
 564 
 565     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 566     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 567     bool hasVisibleContent() const { return m_hasVisibleContent; }
 568     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 569 
 570     void setHasVisibleContent();
 571     void dirtyVisibleContentStatus();
 572 
 573     bool hasVisibleBoxDecorationsOrBackground() const;
 574     bool hasVisibleBoxDecorations() const;
 575 
<a name="18" id="anc18"></a><span class="line-added"> 576     bool behavesAsFixed() const { return m_behavesAsFixed; }</span>
<span class="line-added"> 577 </span>
 578     struct PaintedContentRequest {
 579         void makeStatesUndetermined()
 580         {
 581             if (hasPaintedContent == RequestState::Unknown)
 582                 hasPaintedContent = RequestState::Undetermined;
 583 
 584             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 585                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 586         }
 587 
 588         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 589         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 590 
 591         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 592         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 593 
 594         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 595         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 596 
 597         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 598 
 599         RequestState hasPaintedContent { RequestState::Unknown };
 600         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 601     };
 602 
 603     // Returns true if this layer has visible content (ignoring any child layers).
 604     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 605     // True if this layer container renderers that paint.
 606     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 607 
 608     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 609     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 610     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 611 
<a name="19" id="anc19"></a><span class="line-added"> 612     bool ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit = nullptr) const;</span>
<span class="line-added"> 613 </span>
 614     // Gets the nearest enclosing positioned ancestor layer (also includes
 615     // the &lt;html&gt; layer and the root layer).
 616     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 617 
 618     // Returns the nearest enclosing layer that is scrollable.
 619     RenderLayer* enclosingScrollableLayer() const;
 620 
 621     // The layer relative to which clipping rects for this layer are computed.
 622     RenderLayer* clippingRootForPainting() const;
 623 
 624     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 625 
 626     // Enclosing compositing layer; if includeSelf is true, may return this.
 627     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 628     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 629     // Ancestor compositing layer, excluding this.
 630     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 631 
 632     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 633     RenderLayer* enclosingFilterRepaintLayer() const;
 634     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 635     bool hasAncestorWithFilterOutsets() const;
 636 
<a name="20" id="anc20"></a><span class="line-modified"> 637     bool canUseOffsetFromAncestor() const</span>
 638     {
<a name="21" id="anc21"></a><span class="line-modified"> 639         // FIXME: This really needs to know if there are transforms on this layer and any of the layers</span>
<span class="line-added"> 640         // between it and the ancestor in question.</span>
 641         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 642     }
 643 
 644     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 645     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 646     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 647     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 648     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 649 
 650     int zIndex() const { return renderer().style().zIndex(); }
 651 
 652     enum PaintLayerFlag {
 653         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 654         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 655         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 656         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 657         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 658         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 659         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 660         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 661         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 662         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 663         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 664         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 665         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 666         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
<a name="22" id="anc22"></a><span class="line-added"> 667         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,</span>
 668     };
<a name="23" id="anc23"></a><span class="line-modified"> 669     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }</span>
 670 
 671     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 672 
 673     // The two main functions that use the layer system.  The paint method
 674     // paints the layers that intersect the damage rect from back to
 675     // front.  The hitTest method looks for mouse events by walking
 676     // layers that intersect the point from front to back.
 677     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 678         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 679     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 680     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 681     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 682 
 683     struct ClipRectsContext {
 684         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 685             : rootLayer(inRootLayer)
 686             , clipRectsType(inClipRectsType)
 687             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 688             , respectOverflowClip(inRespectOverflowClip)
 689         { }
 690         const RenderLayer* rootLayer;
 691         ClipRectsType clipRectsType;
 692         OverlayScrollbarSizeRelevancy overlayScrollbarSizeRelevancy;
 693         ShouldRespectOverflowClip respectOverflowClip;
 694     };
 695 
 696     // This method figures out our layerBounds in coordinates relative to
 697     // |rootLayer}.  It also computes our background and foreground clip rects
 698     // for painting/event handling.
 699     // Pass offsetFromRoot if known.
 700     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 701         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 702 
 703     // Public just for RenderTreeAsText.
 704     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 705         PaginationInclusionMode,
 706         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 707         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 708 
 709     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 710     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 711     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 712 
<a name="24" id="anc24"></a><span class="line-added"> 713     bool clipCrossesPaintingBoundary() const;</span>
<span class="line-added"> 714 </span>
 715     // Pass offsetFromRoot if known.
 716     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 717 
 718     enum CalculateLayerBoundsFlag {
 719         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 720         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 721         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 722         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 723         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 724         DontConstrainForMask                    = 1 &lt;&lt; 5,
 725         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 726         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 727         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 728     };
 729     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 730 
 731     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 732     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 733     // Bounding box in the coordinates of this layer.
 734     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 735     // Deprecated: Pixel snapped bounding box relative to the root.
 736     WEBCORE_EXPORT IntRect absoluteBoundingBox() const;
 737     // Device pixel snapped bounding box relative to the root. absoluteBoundingBox() callers will be directed to this.
 738     FloatRect absoluteBoundingBoxForPainting() const;
 739 
 740     // Bounds used for layer overlap testing in RenderLayerCompositor.
 741     LayoutRect overlapBounds() const;
 742 
 743     // Takes transform animations into account, returning true if they could be cheaply computed.
 744     // Unlike overlapBounds, these bounds include descendant layers.
 745     bool getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp;, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags = { }) const;
 746 
 747     // If true, this layer&#39;s children are included in its bounds for overlap testing.
 748     // We can&#39;t rely on the children&#39;s positions if this layer has a filter that could have moved the children&#39;s pixels around.
 749     bool overlapBoundsIncludeChildren() const { return hasFilter() &amp;&amp; renderer().style().filter().hasFilterThatMovesPixels(); }
 750 
 751     // Can pass offsetFromRoot if known.
 752     LayoutRect calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; = defaultCalculateLayerBoundsFlags()) const;
 753 
 754     // Return a cached repaint rect, computed relative to the layer renderer&#39;s containerForRepaint.
 755     bool hasComputedRepaintRects() const { return renderer().hasRepaintLayoutRects(); }
 756     LayoutRect repaintRectIncludingNonCompositingDescendants() const;
 757 
 758     void setRepaintStatus(RepaintStatus status) { m_repaintStatus = status; }
 759     RepaintStatus repaintStatus() const { return static_cast&lt;RepaintStatus&gt;(m_repaintStatus); }
 760 
 761     LayoutUnit staticInlinePosition() const { return m_staticInlinePosition; }
 762     LayoutUnit staticBlockPosition() const { return m_staticBlockPosition; }
 763 
 764     void setStaticInlinePosition(LayoutUnit position) { m_staticInlinePosition = position; }
 765     void setStaticBlockPosition(LayoutUnit position) { m_staticBlockPosition = position; }
 766 
 767 #if PLATFORM(IOS_FAMILY)
 768     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 769     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 770 #endif
 771 
 772     bool hasTransform() const { return renderer().hasTransform(); }
 773     // Note that this transform has the transform-origin baked in.
 774     TransformationMatrix* transform() const { return m_transform.get(); }
 775     // currentTransform computes a transform which takes accelerated animations into account. The
 776     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 777     // returns the identity matrix.
 778     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 779     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 780 
 781     // Get the perspective transform, which is applied to transformed sublayers.
 782     // Returns true if the layer has a -webkit-perspective.
 783     // Note that this transform has the perspective-origin baked in.
 784     TransformationMatrix perspectiveTransform() const;
 785     FloatPoint perspectiveOrigin() const;
 786     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 787     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
<a name="25" id="anc25"></a><span class="line-added"> 788     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }</span>
 789 
 790     void filterNeedsRepaint();
 791     bool hasFilter() const { return renderer().hasFilter(); }
 792     bool hasBackdropFilter() const
 793     {
 794 #if ENABLE(FILTERS_LEVEL_2)
 795         return renderer().hasBackdropFilter();
 796 #else
 797         return false;
 798 #endif
 799     }
 800 
 801 #if ENABLE(CSS_COMPOSITING)
 802     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 803     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 804 
<a name="26" id="anc26"></a><span class="line-modified"> 805     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }</span>
 806     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 807     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 808     {
 809         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 810     }
 811 
<a name="27" id="anc27"></a><span class="line-modified"> 812     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isCSSStackingContext(); }</span>
 813 
 814     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 815     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 816     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 817 #else
 818     bool hasBlendMode() const { return false; }
 819     bool isolatesCompositedBlending() const { return false; }
 820     bool isolatesBlending() const { return false; }
 821     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 822 #endif
 823 
 824     bool isComposited() const { return m_backing != nullptr; }
 825     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 826     bool hasCompositedMask() const;
 827 
<a name="28" id="anc28"></a><span class="line-added"> 828     // If non-null, a non-ancestor composited layer that this layer paints into (it is sharing its backing store with this layer).</span>
<span class="line-added"> 829     RenderLayer* backingProviderLayer() const { return m_backingProviderLayer.get(); }</span>
<span class="line-added"> 830     void setBackingProviderLayer(RenderLayer*);</span>
<span class="line-added"> 831     void disconnectFromBackingProviderLayer();</span>
<span class="line-added"> 832 </span>
<span class="line-added"> 833     bool paintsIntoProvidedBacking() const { return !!m_backingProviderLayer; }</span>
<span class="line-added"> 834 </span>
 835     RenderLayerBacking* backing() const { return m_backing.get(); }
 836     RenderLayerBacking* ensureBacking();
 837     void clearBacking(bool layerBeingDestroyed = false);
 838 
 839     GraphicsLayer* layerForHorizontalScrollbar() const override;
 840     GraphicsLayer* layerForVerticalScrollbar() const override;
 841     GraphicsLayer* layerForScrollCorner() const override;
 842 
 843     bool usesCompositedScrolling() const override;
 844     bool usesAsyncScrolling() const override;
 845 
<a name="29" id="anc29"></a><span class="line-added"> 846     bool hasCompositedScrollingAncestor() const { return m_hasCompositedScrollingAncestor; }</span>
<span class="line-added"> 847     void setHasCompositedScrollingAncestor(bool hasCompositedScrollingAncestor) { m_hasCompositedScrollingAncestor = hasCompositedScrollingAncestor; }</span>
<span class="line-added"> 848 </span>
 849     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 850     {
 851         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 852     }
 853 
 854     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 855     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 856     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 857 
 858     // Returns true if background phase is painted opaque in the given rect.
 859     // The query rect is given in local coordinates.
 860     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 861 
 862     bool scrollingMayRevealBackground() const;
 863 
 864     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 865     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 866 
 867     bool paintsWithFilters() const;
 868     bool requiresFullLayerImageForFilters() const;
 869 
 870     Element* enclosingElement() const;
 871 
 872     enum ViewportConstrainedNotCompositedReason {
 873         NoNotCompositedReason,
 874         NotCompositedForBoundsOutOfView,
 875         NotCompositedForNonViewContainer,
 876         NotCompositedForNoVisibleContent,
 877     };
 878 
 879     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 880     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 881 
<a name="30" id="anc30"></a><span class="line-added"> 882     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }</span>
<span class="line-added"> 883 </span>
 884     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 885     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 886     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 887     bool isDirtyRenderFragmentedFlow() const
 888     {
 889         ASSERT(isRenderFragmentedFlow());
 890         return zOrderListsDirty() || normalFlowListDirty();
 891     }
 892 
 893     RenderLayer* enclosingFragmentedFlowAncestor() const;
 894 
 895     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 896 
 897     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 898     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 899 
<a name="31" id="anc31"></a><span class="line-added"> 900     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902     void invalidateEventRegion();</span>
<span class="line-added"> 903 </span>
 904 private:
 905 
 906     void setNextSibling(RenderLayer* next) { m_next = next; }
 907     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 908     void setParent(RenderLayer*);
 909     void setFirstChild(RenderLayer* first) { m_first = first; }
 910     void setLastChild(RenderLayer* last) { m_last = last; }
 911 
 912     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 913 
 914     bool shouldBeNormalFlowOnly() const;
<a name="32" id="anc32"></a><span class="line-modified"> 915     bool shouldBeCSSStackingContext() const;</span>
 916 
 917     // Return true if changed.
 918     bool setIsNormalFlowOnly(bool);
<a name="33" id="anc33"></a><span class="line-modified"> 919 </span>
<span class="line-added"> 920     bool setIsOpportunisticStackingContext(bool);</span>
<span class="line-added"> 921     bool setIsCSSStackingContext(bool);</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     void isStackingContextChanged();</span>
 924 
 925     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 926 
 927     void updateZOrderLists();
 928     void rebuildZOrderLists();
 929     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 930     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);
 931     void clearZOrderLists();
 932 
 933     void updateNormalFlowList();
 934 
 935     struct LayerPaintingInfo {
 936         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 937             : rootLayer(inRootLayer)
 938             , subtreePaintRoot(inSubtreePaintRoot)
 939             , paintDirtyRect(inDirtyRect)
 940             , subpixelOffset(inSubpixelOffset)
 941             , overlapTestRequests(inOverlapTestRequests)
 942             , paintBehavior(inPaintBehavior)
 943             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 944         { }
 945 
 946         RenderLayer* rootLayer;
 947         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 948         LayoutRect paintDirtyRect; // Relative to rootLayer;
 949         LayoutSize subpixelOffset;
 950         OverlapTestRequestMap* overlapTestRequests; // May be null.
 951         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 952         bool requireSecurityOriginAccessForWidgets;
 953         bool clipToDirtyRect { true };
<a name="34" id="anc34"></a><span class="line-added"> 954         EventRegionContext* eventRegionContext { nullptr };</span>
 955     };
 956 
 957     // Compute, cache and return clip rects computed with the given layer as the root.
 958     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 959     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 960     // (rather than computing them all from scratch up the parent chain).
 961     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 962     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 963 
 964     void setAncestorChainHasSelfPaintingLayerDescendant();
 965     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 966 
 967     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 968     void computeRepaintRectsIncludingDescendants();
 969     void clearRepaintRects();
 970 
 971     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 972 
 973     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 974     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 975 
 976     bool shouldRepaintAfterLayout() const;
 977 
 978     void updateSelfPaintingLayer();
 979 
 980     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 981     void updateScrollbarsAfterLayout();
 982 
<a name="35" id="anc35"></a><span class="line-added"> 983     enum UpdateLayerPositionsFlag {</span>
<span class="line-added"> 984         CheckForRepaint                     = 1 &lt;&lt; 0,</span>
<span class="line-added"> 985         NeedsFullRepaintInBacking           = 1 &lt;&lt; 1,</span>
<span class="line-added"> 986         ContainingClippingLayerChangedSize  = 1 &lt;&lt; 2,</span>
<span class="line-added"> 987         UpdatePagination                    = 1 &lt;&lt; 3,</span>
<span class="line-added"> 988         SeenFixedLayer                      = 1 &lt;&lt; 4,</span>
<span class="line-added"> 989         SeenTransformedLayer                = 1 &lt;&lt; 5,</span>
<span class="line-added"> 990         Seen3DTransformedLayer              = 1 &lt;&lt; 6,</span>
<span class="line-added"> 991         SeenCompositedScrollingLayer        = 1 &lt;&lt; 7,</span>
<span class="line-added"> 992     };</span>
<span class="line-added"> 993     static OptionSet&lt;UpdateLayerPositionsFlag&gt; flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer);</span>
<span class="line-added"> 994 </span>
 995     // Returns true if the position changed.
<a name="36" id="anc36"></a><span class="line-modified"> 996     bool updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* = nullptr);</span>
 997 
<a name="37" id="anc37"></a><span class="line-modified"> 998     void updateLayerPositions(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsFlag&gt;);</span>
 999 
1000     enum UpdateLayerPositionsAfterScrollFlag {
1001         IsOverflowScroll                        = 1 &lt;&lt; 0,
1002         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
1003         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
1004         HasChangedAncestor                      = 1 &lt;&lt; 3,
1005     };
1006     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
1007 
1008     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
1009 
1010     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
1011 
1012     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
1013 
1014     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
1015 
1016     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
1017 
1018     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1019 
1020     void ensureLayerFilters();
1021     void clearLayerFilters();
1022 
1023     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
1024     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1025     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
1026 
1027     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<a name="38" id="anc38"></a><span class="line-added">1028     void paintLayerWithEffects(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);</span>
<span class="line-added">1029 </span>
1030     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1031     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
1032     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1033     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1034 
1035     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
1036     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1037         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1038     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1039         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1040     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1041     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1042     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1043     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1044     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1045     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<a name="39" id="anc39"></a><span class="line-added">1046     void collectEventRegionForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);</span>
1047 
1048     RenderLayer* transparentPaintingAncestor();
1049     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
1050 
1051     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1052         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
1053         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1054     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1055         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
1056         const LayoutSize&amp; translationOffset = LayoutSize());
1057     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1058         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1059         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
1060         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
1061 
1062     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
1063         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1064         const HitTestingTransformState* containerTransformState,
1065         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1066 
1067     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1068     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1069     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1070     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1071         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1072 
1073     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1074 
1075     void computeScrollDimensions();
1076     bool hasHorizontalOverflow() const;
1077     bool hasVerticalOverflow() const;
<a name="40" id="anc40"></a>

1078 
1079     bool showsOverflowControls() const;
1080 
1081     bool shouldBeSelfPaintingLayer() const;
1082 
<a name="41" id="anc41"></a>

1083     // ScrollableArea interface
1084     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1085     void invalidateScrollCornerRect(const IntRect&amp;) override;
1086     bool isActive() const override;
1087     bool isScrollCornerVisible() const override;
1088     IntRect scrollCornerRect() const override;
1089     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1090     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1091     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1092     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
<a name="42" id="anc42"></a>
1093     void setScrollOffset(const ScrollOffset&amp;) override;
<a name="43" id="anc43"></a><span class="line-added">1094     ScrollingNodeID scrollingNodeID() const override;</span>
1095 
1096     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1097     IntSize overhangAmount() const override;
1098     IntPoint lastKnownMousePosition() const override;
1099     bool isHandlingWheelEvent() const override;
1100     bool shouldSuspendScrollAnimations() const override;
1101     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1102     bool isRubberBandInProgress() const override;
1103     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1104 #if ENABLE(CSS_SCROLL_SNAP)
1105     bool isScrollSnapInProgress() const override;
1106 #endif
1107     bool usesMockScrollAnimator() const override;
1108     void logMockScrollAnimatorMessage(const String&amp;) const override;
1109 
1110 #if ENABLE(IOS_TOUCH_EVENTS)
1111     void registerAsTouchEventListenerForScrolling();
1112     void unregisterAsTouchEventListenerForScrolling();
1113 #endif
1114 
1115     // Rectangle encompassing the scroll corner and resizer rect.
1116     LayoutRect scrollCornerAndResizerRect() const;
1117 
1118     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1119     void scrollTo(const ScrollPosition&amp;);
1120     void updateCompositingLayersAfterScroll();
1121 
1122     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1123 
1124     void updateScrollableAreaSet(bool hasOverflow);
1125 
1126     bool allowsCurrentScroll() const;
1127 
1128     void dirtyAncestorChainVisibleDescendantStatus();
1129     void setAncestorChainHasVisibleDescendant();
1130 
1131     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
<a name="44" id="anc44"></a>

1132     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1133 
1134     void dirty3DTransformedDescendantStatus();
1135     // Both updates the status, and returns true if descendants of this have 3d.
1136     bool update3DTransformedDescendantStatus();
1137 
1138     void createReflection();
1139     void removeReflection();
1140 
1141     RenderStyle createReflectionStyle();
1142     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1143     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1144 
1145     void updateFiltersAfterStyleChange();
1146     void updateFilterPaintingStrategy();
1147 
1148 #if ENABLE(CSS_COMPOSITING)
1149     void updateAncestorChainHasBlendingDescendants();
1150     void dirtyAncestorChainHasBlendingDescendants();
1151 #endif
1152 
1153     Ref&lt;ClipRects&gt; parentClipRects(const ClipRectsContext&amp;) const;
1154     ClipRect backgroundClipRect(const ClipRectsContext&amp;) const;
1155 
1156     RenderLayer* enclosingTransformedAncestor() const;
1157 
1158     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1159 
1160     // Convert a point in absolute coords into layer coords, taking transforms into account
1161     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1162 
1163     void positionOverflowControls(const IntSize&amp;);
1164     void updateScrollCornerStyle();
1165     void clearScrollCorner();
1166     void updateResizerStyle();
1167     void clearResizer();
1168 
1169     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1170 
1171     void updatePagination();
1172 
1173     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1174 
<a name="45" id="anc45"></a>









1175     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
<a name="46" id="anc46"></a>
1176     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1177 
<a name="47" id="anc47"></a>



1178     LayoutUnit overflowTop() const;
1179     LayoutUnit overflowBottom() const;
1180     LayoutUnit overflowLeft() const;
1181     LayoutUnit overflowRight() const;
1182 
1183     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1184     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1185 
1186     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1187     LayoutUnit horizontalScrollbarStart(int minX) const;
1188 
1189     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1190 
1191     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1192 
1193     const bool m_isRenderViewLayer : 1;
1194     const bool m_forcedStackingContext : 1;
1195 
1196     bool m_isNormalFlowOnly : 1;
<a name="48" id="anc48"></a><span class="line-modified">1197     bool m_isCSSStackingContext : 1;</span>
<span class="line-added">1198     bool m_isOpportunisticStackingContext : 1;</span>
1199 
1200     bool m_zOrderListsDirty : 1;
1201     bool m_normalFlowListDirty: 1;
1202     bool m_hadNegativeZOrderList : 1;
1203 
1204     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1205     bool m_inResizeMode : 1;
1206 
1207     bool m_scrollDimensionsDirty : 1;
1208     bool m_isSelfPaintingLayer : 1;
1209 
1210     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1211     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1212     bool m_hasSelfPaintingLayerDescendant : 1;
1213     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1214 
1215     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1216                                  // we ended up painting this layer or any descendants (and therefore need to
1217                                  // blend).
1218     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1219     bool m_inOverflowRelayout : 1;
1220     unsigned m_repaintStatus : 2; // RepaintStatus
1221 
1222     bool m_visibleContentStatusDirty : 1;
1223     bool m_hasVisibleContent : 1;
1224     bool m_visibleDescendantStatusDirty : 1;
1225     bool m_hasVisibleDescendant : 1;
1226     bool m_registeredScrollableArea : 1;
1227     bool m_isFixedIntersectingViewport : 1;
<a name="49" id="anc49"></a><span class="line-added">1228     bool m_behavesAsFixed : 1;</span>
1229 
1230     bool m_3DTransformedDescendantStatusDirty : 1;
1231     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1232                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1233     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1234 
<a name="50" id="anc50"></a><span class="line-added">1235     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.</span>
<span class="line-added">1236     bool m_hasCompositedScrollableOverflow : 1;</span>
<span class="line-added">1237 </span>
1238     bool m_hasTransformedAncestor : 1;
1239     bool m_has3DTransformedAncestor : 1;
1240 
1241     unsigned m_indirectCompositingReason : 3;
1242     unsigned m_viewportConstrainedNotCompositedReason : 2;
1243 
1244 #if PLATFORM(IOS_FAMILY)
1245 #if ENABLE(IOS_TOUCH_EVENTS)
1246     bool m_registeredAsTouchEventListenerForScrolling : 1;
1247 #endif
1248     bool m_adjustForIOSCaretWhenScrolling : 1;
1249 #endif
1250 
<a name="51" id="anc51"></a>
1251     bool m_requiresScrollPositionReconciliation : 1;
1252     bool m_containsDirtyOverlayScrollbars : 1;
1253     bool m_updatingMarqueePosition : 1;
1254 
1255 #if !ASSERT_DISABLED
1256     bool m_layerListMutationAllowed : 1;
1257 #endif
1258 
1259 #if ENABLE(CSS_COMPOSITING)
1260     unsigned m_blendMode : 5;
1261     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1262     bool m_hasNotIsolatedBlendingDescendants : 1;
1263     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1264 #endif
1265 
1266     RenderLayerModelObject&amp; m_renderer;
1267 
1268     RenderLayer* m_parent { nullptr };
1269     RenderLayer* m_previous { nullptr };
1270     RenderLayer* m_next { nullptr };
1271     RenderLayer* m_first { nullptr };
1272     RenderLayer* m_last { nullptr };
1273 
<a name="52" id="anc52"></a><span class="line-added">1274     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;</span>
<span class="line-added">1275 </span>
1276     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1277     // descendant layers within the stacking context that have z-indices of 0 or greater
1278     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1279     // z-indices.
1280     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1281     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1282 
1283     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1284     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1285 
1286     // Our current relative position offset.
1287     LayoutSize m_offsetForInFlowPosition;
1288 
1289     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1290     LayoutPoint m_topLeft;
1291 
1292     // The layer&#39;s width/height
1293     IntSize m_layerSize;
1294 
1295     ScrollPosition m_scrollPosition;
1296     Optional&lt;ScrollPosition&gt; m_postLayoutScrollPosition;
1297 
1298     // The width/height of our scrolled area.
1299     IntSize m_scrollSize;
1300 
1301     // For layers with overflow, we have a pair of scrollbars.
1302     RefPtr&lt;Scrollbar&gt; m_hBar;
1303     RefPtr&lt;Scrollbar&gt; m_vBar;
1304 
1305     std::unique_ptr&lt;ClipRectsCache&gt; m_clipRectsCache;
1306 
1307     IntPoint m_cachedOverlayScrollbarOffset;
1308 
1309     std::unique_ptr&lt;RenderMarquee&gt; m_marquee; // Used for &lt;marquee&gt;.
1310 
1311     // Cached normal flow values for absolute positioned elements with static left/top values.
1312     LayoutUnit m_staticInlinePosition;
1313     LayoutUnit m_staticBlockPosition;
1314 
1315     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
1316 
1317     // May ultimately be extended to many replicas (with their own paint order).
1318     RenderPtr&lt;RenderReplica&gt; m_reflection;
1319 
1320     // Renderers to hold our custom scroll corner and resizer.
1321     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
1322     RenderPtr&lt;RenderScrollbarPart&gt; m_resizer;
1323 
1324     // Pointer to the enclosing RenderLayer that caused us to be paginated. It is 0 if we are not paginated.
1325     WeakPtr&lt;RenderLayer&gt; m_enclosingPaginationLayer;
1326 
1327     IntRect m_blockSelectionGapsBounds;
1328 
1329     std::unique_ptr&lt;RenderLayerFilters&gt; m_filters;
1330     std::unique_ptr&lt;RenderLayerBacking&gt; m_backing;
1331 
1332     PaintFrequencyTracker m_paintFrequencyTracker;
1333 };
1334 
1335 inline void RenderLayer::clearZOrderLists()
1336 {
1337     ASSERT(!isStackingContext());
1338     ASSERT(layerListMutationAllowed());
1339 
1340     m_posZOrderList = nullptr;
1341     m_negZOrderList = nullptr;
1342 }
1343 
1344 inline void RenderLayer::updateZOrderLists()
1345 {
1346     if (!m_zOrderListsDirty)
1347         return;
1348 
1349     if (!isStackingContext()) {
1350         clearZOrderLists();
1351         m_zOrderListsDirty = false;
1352         return;
1353     }
1354 
1355     rebuildZOrderLists();
1356 }
1357 
1358 inline RenderLayer* RenderLayer::paintOrderParent() const
1359 {
1360     return m_isNormalFlowOnly ? m_parent : stackingContext();
1361 }
1362 
1363 #if !ASSERT_DISABLED
1364 class LayerListMutationDetector {
1365 public:
1366     LayerListMutationDetector(RenderLayer&amp; layer)
1367         : m_layer(layer)
1368         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1369     {
1370         m_layer.setLayerListMutationAllowed(false);
1371     }
1372 
1373     ~LayerListMutationDetector()
1374     {
1375         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1376     }
1377 
1378 private:
1379     RenderLayer&amp; m_layer;
1380     bool m_previousMutationAllowedState;
1381 };
1382 #endif
1383 
1384 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1385 
1386 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1387 
<a name="53" id="anc53"></a><span class="line-added">1388 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);</span>
1389 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
<a name="54" id="anc54"></a><span class="line-added">1390 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);</span>
<span class="line-added">1391 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);</span>
1392 
1393 } // namespace WebCore
1394 
1395 #if ENABLE(TREE_DEBUGGING)
1396 // Outside the WebCore namespace for ease of invocation from lldb.
1397 void showLayerTree(const WebCore::RenderLayer*);
1398 void showPaintOrderTree(const WebCore::RenderLayer*);
1399 void showLayerTree(const WebCore::RenderObject*);
1400 #endif
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>