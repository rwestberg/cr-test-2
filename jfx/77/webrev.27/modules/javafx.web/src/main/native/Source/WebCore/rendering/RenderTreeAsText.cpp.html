<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
 38 #include &quot;LineLayoutInterfaceTextBoxes.h&quot;
 39 #include &quot;Logging.h&quot;
 40 #include &quot;PrintContext.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderCounter.h&quot;
 44 #include &quot;RenderDetailsMarker.h&quot;
 45 #include &quot;RenderFileUploadControl.h&quot;
 46 #include &quot;RenderFragmentContainer.h&quot;
 47 #include &quot;RenderInline.h&quot;
 48 #include &quot;RenderIterator.h&quot;
 49 #include &quot;RenderLayer.h&quot;
 50 #include &quot;RenderLayerBacking.h&quot;
 51 #include &quot;RenderLineBreak.h&quot;
 52 #include &quot;RenderListItem.h&quot;
 53 #include &quot;RenderListMarker.h&quot;
 54 #include &quot;RenderSVGContainer.h&quot;
 55 #include &quot;RenderSVGGradientStop.h&quot;
 56 #include &quot;RenderSVGImage.h&quot;
 57 #include &quot;RenderSVGInlineText.h&quot;
 58 #include &quot;RenderSVGPath.h&quot;
 59 #include &quot;RenderSVGResourceContainer.h&quot;
 60 #include &quot;RenderSVGRoot.h&quot;
 61 #include &quot;RenderSVGText.h&quot;
 62 #include &quot;RenderTableCell.h&quot;
 63 #include &quot;RenderView.h&quot;
 64 #include &quot;RenderWidget.h&quot;
 65 #include &quot;SVGRenderTreeAsText.h&quot;
 66 #include &quot;ShadowRoot.h&quot;
 67 #include &quot;StyleProperties.h&quot;
 68 #include &lt;wtf/HexNumber.h&gt;
 69 #include &lt;wtf/Vector.h&gt;
 70 #include &lt;wtf/text/TextStream.h&gt;
 71 #include &lt;wtf/unicode/CharacterNames.h&gt;
 72 
 73 #if PLATFORM(MAC)
 74 #include &quot;ScrollbarThemeMac.h&quot;
 75 #endif
 76 
 77 namespace WebCore {
 78 
 79 using namespace HTMLNames;
 80 
 81 static void writeLayers(TextStream&amp;, const RenderLayer&amp; rootLayer, RenderLayer&amp;, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;RenderAsTextFlag&gt;);
 82 
 83 static void printBorderStyle(TextStream&amp; ts, const BorderStyle borderStyle)
 84 {
 85     switch (borderStyle) {
 86     case BorderStyle::None:
 87         ts &lt;&lt; &quot;none&quot;;
 88         break;
 89     case BorderStyle::Hidden:
 90         ts &lt;&lt; &quot;hidden&quot;;
 91         break;
 92     case BorderStyle::Inset:
 93         ts &lt;&lt; &quot;inset&quot;;
 94         break;
 95     case BorderStyle::Groove:
 96         ts &lt;&lt; &quot;groove&quot;;
 97         break;
 98     case BorderStyle::Ridge:
 99         ts &lt;&lt; &quot;ridge&quot;;
100         break;
101     case BorderStyle::Outset:
102         ts &lt;&lt; &quot;outset&quot;;
103         break;
104     case BorderStyle::Dotted:
105         ts &lt;&lt; &quot;dotted&quot;;
106         break;
107     case BorderStyle::Dashed:
108         ts &lt;&lt; &quot;dashed&quot;;
109         break;
110     case BorderStyle::Solid:
111         ts &lt;&lt; &quot;solid&quot;;
112         break;
113     case BorderStyle::Double:
114         ts &lt;&lt; &quot;double&quot;;
115         break;
116     }
117 
118     ts &lt;&lt; &quot; &quot;;
119 }
120 
121 static String getTagName(Node* n)
122 {
123     if (n-&gt;isDocumentNode())
124         return &quot;&quot;;
125     if (n-&gt;nodeType() == Node::COMMENT_NODE)
126         return &quot;COMMENT&quot;;
127     return n-&gt;nodeName();
128 }
129 
130 static bool isEmptyOrUnstyledAppleStyleSpan(const Node* node)
131 {
132     if (!is&lt;HTMLSpanElement&gt;(node))
133         return false;
134 
135     const HTMLElement&amp; element = downcast&lt;HTMLSpanElement&gt;(*node);
136     if (element.getAttribute(classAttr) != &quot;Apple-style-span&quot;)
137         return false;
138 
139     if (!node-&gt;hasChildNodes())
140         return true;
141 
142     const StyleProperties* inlineStyleDecl = element.inlineStyle();
143     return (!inlineStyleDecl || inlineStyleDecl-&gt;isEmpty());
144 }
145 
146 String quoteAndEscapeNonPrintables(StringView s)
147 {
148     StringBuilder result;
149     result.append(&#39;&quot;&#39;);
150     for (unsigned i = 0; i != s.length(); ++i) {
151         UChar c = s[i];
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
163                 appendUnsignedAsHex(c, result);
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
173 {
174     ts &lt;&lt; o.renderName();
175 
176     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
179     if (o.style().zIndex())
180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().zIndex();
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
205         auto textBoxes = LineLayoutInterface::textBoxes(text);
206         if (textBoxes.begin() == textBoxes.end())
207             adjustForTableCells = false;
208     } else if (o.isBR()) {
209         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
210         IntRect linesBox = br.linesBoundingBox();
211         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
212         if (!br.inlineBoxWrapper())
213             adjustForTableCells = false;
214     } else if (is&lt;RenderInline&gt;(o)) {
215         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
216         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
217         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
218         adjustForTableCells = false;
219     } else if (is&lt;RenderTableCell&gt;(o)) {
220         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
221         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
222         // captured by the results.
223         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
224         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
225     } else if (is&lt;RenderBox&gt;(o))
226         r = downcast&lt;RenderBox&gt;(o).frameRect();
227 
228     // FIXME: Temporary in order to ensure compatibility with existing layout test results.
229     if (adjustForTableCells)
230         r.move(0_lu, -downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
231 
232     // FIXME: Convert layout test results to report sub-pixel values, in the meantime using enclosingIntRect
233     // for consistency with old results.
234     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
235 
236     if (!is&lt;RenderText&gt;(o)) {
237         if (is&lt;RenderFileUploadControl&gt;(o))
238             ts &lt;&lt; &quot; &quot; &lt;&lt; quoteAndEscapeNonPrintables(downcast&lt;RenderFileUploadControl&gt;(o).fileTextValue());
239 
240         if (o.parent()) {
241             Color color = o.style().visitedDependentColor(CSSPropertyColor);
242             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyColor).rgb() != color.rgb())
243                 ts &lt;&lt; &quot; [color=&quot; &lt;&lt; color.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
244 
245             // Do not dump invalid or transparent backgrounds, since that is the default.
246             Color backgroundColor = o.style().visitedDependentColor(CSSPropertyBackgroundColor);
247             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyBackgroundColor).rgb() != backgroundColor.rgb()
248                 &amp;&amp; backgroundColor.isValid() &amp;&amp; backgroundColor.rgb())
249                 ts &lt;&lt; &quot; [bgcolor=&quot; &lt;&lt; backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
250 
251             Color textFillColor = o.style().visitedDependentColor(CSSPropertyWebkitTextFillColor);
252             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextFillColor).rgb() != textFillColor.rgb()
253                 &amp;&amp; textFillColor.isValid() &amp;&amp; textFillColor.rgb() != color.rgb() &amp;&amp; textFillColor.rgb())
254                 ts &lt;&lt; &quot; [textFillColor=&quot; &lt;&lt; textFillColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
255 
256             Color textStrokeColor = o.style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor);
257             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor).rgb() != textStrokeColor.rgb()
258                 &amp;&amp; textStrokeColor.isValid() &amp;&amp; textStrokeColor.rgb() != color.rgb() &amp;&amp; textStrokeColor.rgb())
259                 ts &lt;&lt; &quot; [textStrokeColor=&quot; &lt;&lt; textStrokeColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
260 
261             if (o.parent()-&gt;style().textStrokeWidth() != o.style().textStrokeWidth() &amp;&amp; o.style().textStrokeWidth() &gt; 0)
262                 ts &lt;&lt; &quot; [textStrokeWidth=&quot; &lt;&lt; o.style().textStrokeWidth() &lt;&lt; &quot;]&quot;;
263         }
264 
265         if (!is&lt;RenderBoxModelObject&gt;(o) || is&lt;RenderLineBreak&gt;(o))
266             return;
267 
268         const RenderBoxModelObject&amp; box = downcast&lt;RenderBoxModelObject&gt;(o);
269         LayoutUnit borderTop = box.borderTop();
270         LayoutUnit borderRight = box.borderRight();
271         LayoutUnit borderBottom = box.borderBottom();
272         LayoutUnit borderLeft = box.borderLeft();
273         if (box.isFieldset()) {
274             const auto&amp; block = downcast&lt;RenderBlock&gt;(box);
275             if (o.style().writingMode() == TopToBottomWritingMode)
276                 borderTop -= block.intrinsicBorderForFieldset();
277             else if (o.style().writingMode() == BottomToTopWritingMode)
278                 borderBottom -= block.intrinsicBorderForFieldset();
279             else if (o.style().writingMode() == LeftToRightWritingMode)
280                 borderLeft -= block.intrinsicBorderForFieldset();
281             else if (o.style().writingMode() == RightToLeftWritingMode)
282                 borderRight -= block.intrinsicBorderForFieldset();
283 
284         }
285         if (borderTop || borderRight || borderBottom || borderLeft) {
286             ts &lt;&lt; &quot; [border:&quot;;
287 
288             BorderValue prevBorder = o.style().borderTop();
289             if (!borderTop)
290                 ts &lt;&lt; &quot; none&quot;;
291             else {
292                 ts &lt;&lt; &quot; (&quot; &lt;&lt; borderTop &lt;&lt; &quot;px &quot;;
293                 printBorderStyle(ts, o.style().borderTopStyle());
294                 Color col = o.style().borderTopColor();
295                 if (!col.isValid())
296                     col = o.style().color();
297                 ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
298             }
299 
300             if (o.style().borderRight() != prevBorder) {
301                 prevBorder = o.style().borderRight();
302                 if (!borderRight)
303                     ts &lt;&lt; &quot; none&quot;;
304                 else {
305                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderRight &lt;&lt; &quot;px &quot;;
306                     printBorderStyle(ts, o.style().borderRightStyle());
307                     Color col = o.style().borderRightColor();
308                     if (!col.isValid())
309                         col = o.style().color();
310                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
311                 }
312             }
313 
314             if (o.style().borderBottom() != prevBorder) {
315                 prevBorder = box.style().borderBottom();
316                 if (!borderBottom)
317                     ts &lt;&lt; &quot; none&quot;;
318                 else {
319                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderBottom &lt;&lt; &quot;px &quot;;
320                     printBorderStyle(ts, o.style().borderBottomStyle());
321                     Color col = o.style().borderBottomColor();
322                     if (!col.isValid())
323                         col = o.style().color();
324                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
325                 }
326             }
327 
328             if (o.style().borderLeft() != prevBorder) {
329                 prevBorder = o.style().borderLeft();
330                 if (!borderLeft)
331                     ts &lt;&lt; &quot; none&quot;;
332                 else {
333                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderLeft &lt;&lt; &quot;px &quot;;
334                     printBorderStyle(ts, o.style().borderLeftStyle());
335                     Color col = o.style().borderLeftColor();
336                     if (!col.isValid())
337                         col = o.style().color();
338                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
339                 }
340             }
341 
342             ts &lt;&lt; &quot;]&quot;;
343         }
344 
345 #if ENABLE(MATHML)
346         // We want to show any layout padding, both CSS padding and intrinsic padding, so we can&#39;t just check o.style().hasPadding().
347         if (o.isRenderMathMLBlock() &amp;&amp; (box.paddingTop() || box.paddingRight() || box.paddingBottom() || box.paddingLeft())) {
348             ts &lt;&lt; &quot; [&quot;;
349             LayoutUnit cssTop = box.computedCSSPaddingTop();
350             LayoutUnit cssRight = box.computedCSSPaddingRight();
351             LayoutUnit cssBottom = box.computedCSSPaddingBottom();
352             LayoutUnit cssLeft = box.computedCSSPaddingLeft();
353             if (box.paddingTop() != cssTop || box.paddingRight() != cssRight || box.paddingBottom() != cssBottom || box.paddingLeft() != cssLeft) {
354                 ts &lt;&lt; &quot;intrinsic &quot;;
355                 if (cssTop || cssRight || cssBottom || cssLeft)
356                     ts &lt;&lt; &quot;+ CSS &quot;;
357             }
358             ts &lt;&lt; &quot;padding: &quot; &lt;&lt; roundToInt(box.paddingTop()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingRight()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingBottom()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingLeft()) &lt;&lt; &quot;]&quot;;
359         }
360 #endif
361     }
362 
363     if (is&lt;RenderTableCell&gt;(o)) {
364         const RenderTableCell&amp; c = downcast&lt;RenderTableCell&gt;(o);
365         ts &lt;&lt; &quot; [r=&quot; &lt;&lt; c.rowIndex() &lt;&lt; &quot; c=&quot; &lt;&lt; c.col() &lt;&lt; &quot; rs=&quot; &lt;&lt; c.rowSpan() &lt;&lt; &quot; cs=&quot; &lt;&lt; c.colSpan() &lt;&lt; &quot;]&quot;;
366     }
367 
368     if (is&lt;RenderDetailsMarker&gt;(o)) {
369         ts &lt;&lt; &quot;: &quot;;
370         switch (downcast&lt;RenderDetailsMarker&gt;(o).orientation()) {
371         case RenderDetailsMarker::Left:
372             ts &lt;&lt; &quot;left&quot;;
373             break;
374         case RenderDetailsMarker::Right:
375             ts &lt;&lt; &quot;right&quot;;
376             break;
377         case RenderDetailsMarker::Up:
378             ts &lt;&lt; &quot;up&quot;;
379             break;
380         case RenderDetailsMarker::Down:
381             ts &lt;&lt; &quot;down&quot;;
382             break;
383         }
384     }
385 
386     if (is&lt;RenderListMarker&gt;(o)) {
387         String text = downcast&lt;RenderListMarker&gt;(o).text();
388         if (!text.isEmpty()) {
389             if (text.length() != 1)
390                 text = quoteAndEscapeNonPrintables(text);
391             else {
392                 switch (text[0]) {
393                     case bullet:
394                         text = &quot;bullet&quot;;
395                         break;
396                     case blackSquare:
397                         text = &quot;black square&quot;;
398                         break;
399                     case whiteBullet:
400                         text = &quot;white bullet&quot;;
401                         break;
402                     default:
403                         text = quoteAndEscapeNonPrintables(text);
404                 }
405             }
406             ts &lt;&lt; &quot;: &quot; &lt;&lt; text;
407         }
408     }
409 
410     writeDebugInfo(ts, o, behavior);
411 }
412 
413 void writeDebugInfo(TextStream&amp; ts, const RenderObject&amp; object, OptionSet&lt;RenderAsTextFlag&gt; behavior)
414 {
415     if (behavior.contains(RenderAsTextFlag::ShowIDAndClass)) {
416         if (Element* element = is&lt;Element&gt;(object.node()) ? downcast&lt;Element&gt;(object.node()) : nullptr) {
417             if (element-&gt;hasID())
418                 ts &lt;&lt; &quot; id=\&quot;&quot; + element-&gt;getIdAttribute() + &quot;\&quot;&quot;;
419 
420             if (element-&gt;hasClass()) {
421                 ts &lt;&lt; &quot; class=\&quot;&quot;;
422                 for (size_t i = 0; i &lt; element-&gt;classNames().size(); ++i) {
423                     if (i &gt; 0)
424                         ts &lt;&lt; &quot; &quot;;
425                     ts &lt;&lt; element-&gt;classNames()[i];
426                 }
427                 ts &lt;&lt; &quot;\&quot;&quot;;
428             }
429         }
430     }
431 
432     if (behavior.contains(RenderAsTextFlag::ShowLayoutState)) {
433         bool needsLayout = object.selfNeedsLayout() || object.needsPositionedMovementLayout() || object.posChildNeedsLayout() || object.normalChildNeedsLayout();
434         if (needsLayout)
435             ts &lt;&lt; &quot; (needs layout:&quot;;
436 
437         bool havePrevious = false;
438         if (object.selfNeedsLayout()) {
439             ts &lt;&lt; &quot; self&quot;;
440             havePrevious = true;
441         }
442 
443         if (object.needsPositionedMovementLayout()) {
444             if (havePrevious)
445                 ts &lt;&lt; &quot;,&quot;;
446             havePrevious = true;
447             ts &lt;&lt; &quot; positioned movement&quot;;
448         }
449 
450         if (object.normalChildNeedsLayout()) {
451             if (havePrevious)
452                 ts &lt;&lt; &quot;,&quot;;
453             havePrevious = true;
454             ts &lt;&lt; &quot; child&quot;;
455         }
456 
457         if (object.posChildNeedsLayout()) {
458             if (havePrevious)
459                 ts &lt;&lt; &quot;,&quot;;
460             ts &lt;&lt; &quot; positioned child&quot;;
461         }
462 
463         if (needsLayout)
464             ts &lt;&lt; &quot;)&quot;;
465     }
466 
467     if (behavior.contains(RenderAsTextFlag::ShowOverflow) &amp;&amp; is&lt;RenderBox&gt;(object)) {
468         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
469         if (box.hasRenderOverflow()) {
470             LayoutRect layoutOverflow = box.layoutOverflowRect();
471             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
472 
473             if (box.hasVisualOverflow()) {
474                 LayoutRect visualOverflow = box.visualOverflowRect();
475                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
476             }
477         }
478     }
479 }
480 
481 static void writeTextBox(TextStream&amp; ts, const RenderText&amp; o, const LineLayoutInterface::TextBox&amp; textBox)
482 {
483     auto rect = textBox.rect();
484     auto logicalRect = textBox.logicalRect();
485 
486     int x = rect.x();
487     int y = rect.y();
488 
489     // FIXME: Mixing logical and physical here doesn&#39;t make sense.
490     int logicalWidth = ceilf(rect.x() + logicalRect.width()) - x;
491 
492     // FIXME: Table cell adjustment is temporary until results can be updated.
493     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
494         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
495 
496     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
497     if (!textBox.isLeftToRightDirection() || textBox.dirOverride()) {
498         ts &lt;&lt; (!textBox.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);
499         if (textBox.dirOverride())
500             ts &lt;&lt; &quot; override&quot;;
501     }
502     ts &lt;&lt; &quot;: &quot;
503         &lt;&lt; quoteAndEscapeNonPrintables(textBox.text());
504     if (textBox.hasHyphen())
505         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
506     ts &lt;&lt; &quot;\n&quot;;
507 }
508 
509 void write(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
510 {
511     if (is&lt;RenderSVGShape&gt;(o)) {
512         write(ts, downcast&lt;RenderSVGShape&gt;(o), behavior);
513         return;
514     }
515     if (is&lt;RenderSVGGradientStop&gt;(o)) {
516         writeSVGGradientStop(ts, downcast&lt;RenderSVGGradientStop&gt;(o), behavior);
517         return;
518     }
519     if (is&lt;RenderSVGResourceContainer&gt;(o)) {
520         writeSVGResourceContainer(ts, downcast&lt;RenderSVGResourceContainer&gt;(o), behavior);
521         return;
522     }
523     if (is&lt;RenderSVGContainer&gt;(o)) {
524         writeSVGContainer(ts, downcast&lt;RenderSVGContainer&gt;(o), behavior);
525         return;
526     }
527     if (is&lt;RenderSVGRoot&gt;(o)) {
528         write(ts, downcast&lt;RenderSVGRoot&gt;(o), behavior);
529         return;
530     }
531     if (is&lt;RenderSVGText&gt;(o)) {
532         writeSVGText(ts, downcast&lt;RenderSVGText&gt;(o), behavior);
533         return;
534     }
535     if (is&lt;RenderSVGInlineText&gt;(o)) {
536         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
537         return;
538     }
539     if (is&lt;RenderSVGImage&gt;(o)) {
540         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
541         return;
542     }
543 
544     ts &lt;&lt; indent;
545 
546     RenderTreeAsText::writeRenderObject(ts, o, behavior);
547     ts &lt;&lt; &quot;\n&quot;;
548 
549     TextStream::IndentScope indentScope(ts);
550 
551     if (is&lt;RenderText&gt;(o)) {
552         auto&amp; text = downcast&lt;RenderText&gt;(o);
553         for (auto textBox : LineLayoutInterface::textBoxes(text)) {
554             ts &lt;&lt; indent;
555             writeTextBox(ts, text, textBox);
556         }
557     } else {
558         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
559             if (child.hasLayer())
560                 continue;
561             write(ts, child, behavior);
562         }
563     }
564 
565     if (is&lt;RenderWidget&gt;(o)) {
566         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
567         if (is&lt;FrameView&gt;(widget)) {
568             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
569             if (RenderView* root = view.frame().contentRenderer()) {
570                 if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
571                     view.layoutContext().layout();
572                 if (RenderLayer* layer = root-&gt;layer())
573                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
574             }
575         }
576     }
577 }
578 
579 enum LayerPaintPhase {
580     LayerPaintPhaseAll = 0,
581     LayerPaintPhaseBackground = -1,
582     LayerPaintPhaseForeground = 1
583 };
584 
585 static void writeLayer(TextStream&amp; ts, const RenderLayer&amp; layer, const LayoutRect&amp; layerBounds, const LayoutRect&amp; backgroundClipRect, const LayoutRect&amp; clipRect,
586     LayerPaintPhase paintPhase = LayerPaintPhaseAll, OptionSet&lt;RenderAsTextFlag&gt; behavior = { })
587 {
588     IntRect adjustedLayoutBounds = snappedIntRect(layerBounds);
589     IntRect adjustedBackgroundClipRect = snappedIntRect(backgroundClipRect);
590     IntRect adjustedClipRect = snappedIntRect(clipRect);
591 
592     ts &lt;&lt; indent &lt;&lt; &quot;layer &quot;;
593 
594     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
595         ts &lt;&lt; static_cast&lt;const void*&gt;(&amp;layer) &lt;&lt; &quot; &quot;;
596 
597     ts &lt;&lt; adjustedLayoutBounds;
598 
599     if (!adjustedLayoutBounds.isEmpty()) {
600         if (!adjustedBackgroundClipRect.contains(adjustedLayoutBounds))
601             ts &lt;&lt; &quot; backgroundClip &quot; &lt;&lt; adjustedBackgroundClipRect;
602         if (!adjustedClipRect.contains(adjustedLayoutBounds))
603             ts &lt;&lt; &quot; clip &quot; &lt;&lt; adjustedClipRect;
604     }
605 
606     if (layer.renderer().hasOverflowClip()) {
607         if (layer.scrollOffset().x())
608             ts &lt;&lt; &quot; scrollX &quot; &lt;&lt; layer.scrollOffset().x();
609         if (layer.scrollOffset().y())
610             ts &lt;&lt; &quot; scrollY &quot; &lt;&lt; layer.scrollOffset().y();
611         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientWidth()) != layer.scrollWidth())
612             ts &lt;&lt; &quot; scrollWidth &quot; &lt;&lt; layer.scrollWidth();
613         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientHeight()) != layer.scrollHeight())
614             ts &lt;&lt; &quot; scrollHeight &quot; &lt;&lt; layer.scrollHeight();
615 #if PLATFORM(MAC)
616         ScrollbarTheme&amp; scrollbarTheme = ScrollbarTheme::theme();
617         if (!scrollbarTheme.isMockTheme() &amp;&amp; layer.hasVerticalScrollbar()) {
618             ScrollbarThemeMac&amp; macTheme = *static_cast&lt;ScrollbarThemeMac*&gt;(&amp;scrollbarTheme);
619             if (macTheme.isLayoutDirectionRTL(*layer.verticalScrollbar()))
620                 ts &lt;&lt; &quot; scrollbarHasRTLLayoutDirection&quot;;
621         }
622 #endif
623     }
624 
625     if (paintPhase == LayerPaintPhaseBackground)
626         ts &lt;&lt; &quot; layerType: background only&quot;;
627     else if (paintPhase == LayerPaintPhaseForeground)
628         ts &lt;&lt; &quot; layerType: foreground only&quot;;
629 
630     if (behavior.contains(RenderAsTextFlag::ShowCompositedLayers)) {
631         if (layer.isComposited()) {
632             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
633                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
634         } else if (layer.paintsIntoProvidedBacking())
635             ts &lt;&lt; &quot; (shared backing of &quot; &lt;&lt; layer.backingProviderLayer() &lt;&lt; &quot;)&quot;;
636     }
637 
638 #if ENABLE(CSS_COMPOSITING)
639     if (layer.isolatesBlending())
640         ts &lt;&lt; &quot; isolatesBlending&quot;;
641     if (layer.hasBlendMode())
642         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, layer.blendMode());
643 #endif
644 
645     ts &lt;&lt; &quot;\n&quot;;
646 }
647 
648 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, OptionSet&lt;RenderAsTextFlag&gt; behavior)
649 {
650     if (paintPhase != LayerPaintPhaseBackground) {
651         TextStream::IndentScope indentScope(ts);
652         write(ts, layer.renderer(), behavior);
653     }
654 }
655 
656 static LayoutSize maxLayoutOverflow(const RenderBox* box)
657 {
658     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
659     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
660 }
661 
662 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, OptionSet&lt;RenderAsTextFlag&gt; behavior)
663 {
664     // FIXME: Apply overflow to the root layer to not break every test. Complete hack. Sigh.
665     LayoutRect paintDirtyRect(paintRect);
666     if (&amp;rootLayer == &amp;layer) {
667         paintDirtyRect.setWidth(std::max&lt;LayoutUnit&gt;(paintDirtyRect.width(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxX()));
668         paintDirtyRect.setHeight(std::max&lt;LayoutUnit&gt;(paintDirtyRect.height(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxY()));
669         layer.setSize(layer.size().expandedTo(snappedIntSize(maxLayoutOverflow(layer.renderBox()), LayoutPoint(0, 0))));
670     }
671 
672     // Calculate the clip rects we should use.
673     LayoutRect layerBounds;
674     ClipRect damageRect;
675     ClipRect clipRectToApply;
676     LayoutSize offsetFromRoot = layer.offsetFromAncestor(&amp;rootLayer);
677     layer.calculateRects(RenderLayer::ClipRectsContext(&amp;rootLayer, TemporaryClipRects), paintDirtyRect, layerBounds, damageRect, clipRectToApply, offsetFromRoot);
678 
679     // Ensure our lists are up-to-date.
680     layer.updateLayerListsIfNeeded();
681     layer.updateDescendantDependentFlags();
682 
683     bool shouldPaint = (behavior.contains(RenderAsTextFlag::ShowAllLayers)) ? true : layer.intersectsDamageRect(layerBounds, damageRect.rect(), &amp;rootLayer, layer.offsetFromAncestor(&amp;rootLayer));
684     auto negativeZOrderLayers = layer.negativeZOrderLayers();
685     bool paintsBackgroundSeparately = negativeZOrderLayers.size() &gt; 0;
686     if (shouldPaint &amp;&amp; paintsBackgroundSeparately) {
687         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), LayerPaintPhaseBackground, behavior);
688         writeLayerRenderers(ts, layer, LayerPaintPhaseBackground, behavior);
689     }
690 
691     if (negativeZOrderLayers.size()) {
692         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
693             ts &lt;&lt; indent &lt;&lt; &quot; negative z-order list (&quot; &lt;&lt; negativeZOrderLayers.size() &lt;&lt; &quot;)\n&quot;;
694             ts.increaseIndent();
695         }
696 
697         for (auto* currLayer : negativeZOrderLayers)
698             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
699 
700         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
701             ts.decreaseIndent();
702     }
703 
704     if (shouldPaint) {
705         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
706 
707         if (behavior.contains(RenderAsTextFlag::ShowLayerFragments)) {
708             LayerFragments layerFragments;
709             layer.collectFragments(layerFragments, &amp;rootLayer, paintDirtyRect, RenderLayer::PaginationInclusionMode::ExcludeCompositedPaginatedLayers, TemporaryClipRects, IgnoreOverlayScrollbarSize, RespectOverflowClip, offsetFromRoot);
710 
711             if (layerFragments.size() &gt; 1) {
712                 TextStream::IndentScope indentScope(ts, 2);
713                 for (unsigned i = 0; i &lt; layerFragments.size(); ++i) {
714                     const auto&amp; fragment = layerFragments[i];
715                     ts &lt;&lt; indent &lt;&lt; &quot; fragment &quot; &lt;&lt; i &lt;&lt; &quot;: bounds in layer &quot; &lt;&lt; fragment.layerBounds &lt;&lt; &quot; fragment bounds &quot; &lt;&lt; fragment.boundingBox &lt;&lt; &quot;\n&quot;;
716                 }
717             }
718         }
719 
720         writeLayerRenderers(ts, layer, paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
721     }
722 
723     auto normalFlowLayers = layer.normalFlowLayers();
724     if (normalFlowLayers.size()) {
725         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
726             ts &lt;&lt; indent &lt;&lt; &quot; normal flow list (&quot; &lt;&lt; normalFlowLayers.size() &lt;&lt; &quot;)\n&quot;;
727             ts.increaseIndent();
728         }
729 
730         for (auto* currLayer : normalFlowLayers)
731             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
732 
733         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
734             ts.decreaseIndent();
735     }
736 
737     auto positiveZOrderLayers = layer.positiveZOrderLayers();
738     if (positiveZOrderLayers.size()) {
739         size_t layerCount = positiveZOrderLayers.size();
740 
741         if (layerCount) {
742             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
743                 ts &lt;&lt; indent &lt;&lt; &quot; positive z-order list (&quot; &lt;&lt; layerCount &lt;&lt; &quot;)\n&quot;;
744                 ts.increaseIndent();
745             }
746 
747             for (auto* currLayer : positiveZOrderLayers)
748                 writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
749 
750             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
751                 ts.decreaseIndent();
752         }
753     }
754 }
755 
756 static String nodePosition(Node* node)
757 {
758     StringBuilder result;
759 
760     auto* body = node-&gt;document().bodyOrFrameset();
761     Node* parent;
762     for (Node* n = node; n; n = parent) {
763         parent = n-&gt;parentOrShadowHostNode();
764         if (n != node)
765             result.appendLiteral(&quot; of &quot;);
766         if (parent) {
767             if (body &amp;&amp; n == body) {
768                 // We don&#39;t care what offset body may be in the document.
769                 result.appendLiteral(&quot;body&quot;);
770                 break;
771             }
772             if (n-&gt;isShadowRoot()) {
773                 result.append(&#39;{&#39;);
774                 result.append(getTagName(n));
775                 result.append(&#39;}&#39;);
776             } else {
777                 result.appendLiteral(&quot;child &quot;);
778                 result.appendNumber(n-&gt;computeNodeIndex());
779                 result.appendLiteral(&quot; {&quot;);
780                 result.append(getTagName(n));
781                 result.append(&#39;}&#39;);
782             }
783         } else
784             result.appendLiteral(&quot;document&quot;);
785     }
786 
787     return result.toString();
788 }
789 
790 static void writeSelection(TextStream&amp; ts, const RenderBox&amp; renderer)
791 {
792     if (!renderer.isRenderView())
793         return;
794 
795     Frame* frame = renderer.document().frame();
796     if (!frame)
797         return;
798 
799     VisibleSelection selection = frame-&gt;selection().selection();
800     if (selection.isCaret()) {
801         ts &lt;&lt; &quot;caret: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode());
802         if (selection.affinity() == UPSTREAM)
803             ts &lt;&lt; &quot; (upstream affinity)&quot;;
804         ts &lt;&lt; &quot;\n&quot;;
805     } else if (selection.isRange())
806         ts &lt;&lt; &quot;selection start: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode()) &lt;&lt; &quot;\n&quot;
807            &lt;&lt; &quot;selection end:   position &quot; &lt;&lt; selection.end().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.end().deprecatedNode()) &lt;&lt; &quot;\n&quot;;
808 }
809 
810 static String externalRepresentation(RenderBox&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)
811 {
812     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
813     if (!renderer.hasLayer())
814         return ts.release();
815 
816     LOG(Layout, &quot;externalRepresentation: dumping layer tree&quot;);
817 
818     RenderLayer&amp; layer = *renderer.layer();
819     writeLayers(ts, layer, layer, layer.rect(), behavior);
820     writeSelection(ts, renderer);
821     return ts.release();
822 }
823 
824 static void updateLayoutIgnoringPendingStylesheetsIncludingSubframes(Document&amp; document)
825 {
826     document.updateLayoutIgnorePendingStylesheets();
827     auto* frame = document.frame();
828     for (auto* subframe = frame; subframe; subframe = subframe-&gt;tree().traverseNext(frame)) {
829         if (auto* document = subframe-&gt;document())
830             document-&gt;updateLayoutIgnorePendingStylesheets();
831     }
832 }
833 
834 String externalRepresentation(Frame* frame, OptionSet&lt;RenderAsTextFlag&gt; behavior)
835 {
836     ASSERT(frame);
837     ASSERT(frame-&gt;document());
838 
839     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
840         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(*frame-&gt;document());
841 
842     auto* renderer = frame-&gt;contentRenderer();
843     if (!renderer)
844         return String();
845 
846     PrintContext printContext(frame);
847     if (behavior.contains(RenderAsTextFlag::PrintingMode))
848         printContext.begin(renderer-&gt;width());
849 
850     return externalRepresentation(*renderer, behavior);
851 }
852 
853 String externalRepresentation(Element* element, OptionSet&lt;RenderAsTextFlag&gt; behavior)
854 {
855     ASSERT(element);
856 
857     // This function doesn&#39;t support printing mode.
858     ASSERT(!(behavior.contains(RenderAsTextFlag::PrintingMode)));
859 
860     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
861         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(element-&gt;document());
862 
863     auto* renderer = element-&gt;renderer();
864     if (!is&lt;RenderBox&gt;(renderer))
865         return String();
866 
867     return externalRepresentation(downcast&lt;RenderBox&gt;(*renderer), behavior | RenderAsTextFlag::ShowAllLayers);
868 }
869 
870 static void writeCounterValuesFromChildren(TextStream&amp; stream, const RenderElement* parent, bool&amp; isFirstCounter)
871 {
872     if (!parent)
873         return;
874     for (auto&amp; counter : childrenOfType&lt;RenderCounter&gt;(*parent)) {
875         if (!isFirstCounter)
876             stream &lt;&lt; &quot; &quot;;
877         isFirstCounter = false;
878         String str(counter.text());
879         stream &lt;&lt; str;
880     }
881 }
882 
883 String counterValueForElement(Element* element)
884 {
885     // Make sure the element is not freed during the layout.
886     RefPtr&lt;Element&gt; elementRef(element);
887     element-&gt;document().updateLayout();
888     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
889     bool isFirstCounter = true;
890     // The counter renderers should be children of :before or :after pseudo-elements.
891     if (PseudoElement* before = element-&gt;beforePseudoElement())
892         writeCounterValuesFromChildren(stream, before-&gt;renderer(), isFirstCounter);
893     if (PseudoElement* after = element-&gt;afterPseudoElement())
894         writeCounterValuesFromChildren(stream, after-&gt;renderer(), isFirstCounter);
895     return stream.release();
896 }
897 
898 String markerTextForListItem(Element* element)
899 {
900     // Make sure the element is not freed during the layout.
901     RefPtr&lt;Element&gt; elementRef(element);
902     element-&gt;document().updateLayout();
903 
904     RenderElement* renderer = element-&gt;renderer();
905     if (!is&lt;RenderListItem&gt;(renderer))
906         return String();
907 
908     return downcast&lt;RenderListItem&gt;(*renderer).markerText();
909 }
910 
911 } // namespace WebCore
    </pre>
  </body>
</html>