<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;ActiveDOMObject.h&quot;
  31 #include &quot;ApplicationStateChangeListener.h&quot;
  32 #include &quot;AutoplayEvent.h&quot;
  33 #include &quot;DeferrableTask.h&quot;
  34 #include &quot;GenericEventQueue.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLMediaElementEnums.h&quot;
  37 #include &quot;MediaCanStartListener.h&quot;
  38 #include &quot;MediaControllerInterface.h&quot;
  39 #include &quot;MediaElementSession.h&quot;
  40 #include &quot;MediaPlayer.h&quot;
  41 #include &quot;MediaProducer.h&quot;
  42 #include &quot;VisibilityChangeClient.h&quot;
  43 #include &lt;wtf/Function.h&gt;
  44 #include &lt;wtf/LoggerHelper.h&gt;
  45 #include &lt;wtf/WeakPtr.h&gt;
  46 
  47 #if ENABLE(VIDEO_TRACK)
  48 #include &quot;AudioTrack.h&quot;
  49 #include &quot;CaptionUserPreferences.h&quot;
  50 #include &quot;PODIntervalTree.h&quot;
  51 #include &quot;TextTrack.h&quot;
  52 #include &quot;TextTrackCue.h&quot;
  53 #include &quot;VTTCue.h&quot;
  54 #include &quot;VideoTrack.h&quot;
  55 #endif
  56 
  57 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
  58 #include &quot;AudioSession.h&quot;
  59 #endif
  60 
  61 #if ENABLE(ENCRYPTED_MEDIA)
  62 #include &quot;CDMClient.h&quot;
  63 #endif
  64 
  65 #ifndef NDEBUG
  66 #include &lt;wtf/StringPrintStream.h&gt;
  67 #endif
  68 
  69 namespace PAL {
  70 class SleepDisabler;
  71 }
  72 
  73 namespace WebCore {
  74 
  75 class AudioSourceProvider;
  76 class AudioTrackList;
  77 class AudioTrackPrivate;
  78 class Blob;
  79 class DOMException;
  80 class DOMWrapperWorld;
  81 class DeferredPromise;
  82 class Event;
  83 class HTMLSourceElement;
  84 class HTMLTrackElement;
  85 class InbandTextTrackPrivate;
  86 class JSDOMGlobalObject;
  87 class MediaController;
  88 class MediaControls;
  89 class MediaControlsHost;
  90 class MediaElementAudioSourceNode;
  91 class MediaError;
  92 class MediaKeys;
  93 class MediaResourceLoader;
  94 class MediaSession;
  95 class MediaSource;
  96 class MediaStream;
  97 class RenderMedia;
  98 class ScriptController;
  99 class ScriptExecutionContext;
 100 class SourceBuffer;
 101 class TextTrackList;
 102 class TimeRanges;
 103 class VideoPlaybackQuality;
 104 class VideoTrackList;
 105 class VideoTrackPrivate;
 106 class WebKitMediaKeys;
 107 
 108 template&lt;typename&gt; class DOMPromiseDeferred;
 109 
 110 #if ENABLE(VIDEO_TRACK)
 111 using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;
 112 using CueInterval = CueIntervalTree::IntervalType;
 113 using CueList = Vector&lt;CueInterval&gt;;
 114 #endif
 115 
 116 using MediaProvider = Optional&lt;Variant&lt;
 117 #if ENABLE(MEDIA_STREAM)
 118     RefPtr&lt;MediaStream&gt;,
 119 #endif
 120 #if ENABLE(MEDIA_SOURCE)
 121     RefPtr&lt;MediaSource&gt;,
 122 #endif
 123     RefPtr&lt;Blob&gt;&gt;&gt;;
 124 
 125 class HTMLMediaElement
 126     : public HTMLElement
 127     , public ActiveDOMObject
 128     , public MediaControllerInterface
<a name="1" id="anc1"></a>
 129     , public PlatformMediaSessionClient
 130     , private MediaCanStartListener
 131     , private MediaPlayerClient
 132     , private MediaProducer
 133     , private VisibilityChangeClient
 134     , private ApplicationStateChangeListener
 135 #if ENABLE(VIDEO_TRACK)
 136     , private AudioTrackClient
 137     , private TextTrackClient
 138     , private VideoTrackClient
 139 #endif
 140 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 141     , private AudioSession::MutedStateObserver
 142 #endif
 143 #if ENABLE(ENCRYPTED_MEDIA)
 144     , private CDMClient
 145 #endif
 146 #if !RELEASE_LOG_DISABLED
 147     , private LoggerHelper
 148 #endif
 149 {
 150     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 151 public:
<a name="2" id="anc2"></a><span class="line-added"> 152     using WeakValueType = HTMLElement::WeakValueType;</span>
<span class="line-added"> 153     using HTMLElement::weakPtrFactory;</span>
<span class="line-added"> 154 </span>
 155     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 156 
 157     virtual bool isVideo() const { return false; }
 158     bool hasVideo() const override { return false; }
 159     bool hasAudio() const override;
 160 
 161     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 162 
 163     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 164 
 165     static bool isRunningDestructor();
 166 
 167     WEBCORE_EXPORT void rewind(double timeDelta);
 168     WEBCORE_EXPORT void returnToRealtime() override;
 169 
 170     // Eventually overloaded in HTMLVideoElement
 171     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 172 
 173     bool supportsScanning() const override;
 174 
 175     bool canSaveMediaData() const;
 176 
<a name="3" id="anc3"></a><span class="line-modified"> 177     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const override;</span>
 178 
 179     PlatformLayer* platformLayer() const;
 180     bool isVideoLayerInline();
 181     void setPreparedToReturnVideoLayerToInline(bool);
 182     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 184     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 185 #ifdef __OBJC__
 186     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 187 #endif
 188     void setVideoFullscreenFrame(FloatRect);
 189     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);
 190     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }
 191 #endif
 192 
 193     void scheduleCheckPlaybackTargetCompatability();
 194     void checkPlaybackTargetCompatablity();
 195     void scheduleResolvePendingPlayPromises();
 196     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 197     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 198     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 199     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 200     void scheduleNotifyAboutPlaying();
 201     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 202 
 203     MediaPlayerEnums::MovieLoadType movieLoadType() const;
 204 
 205     bool inActiveDocument() const { return m_inActiveDocument; }
 206 
 207     Document* hostingDocument() const final { return &amp;document(); }
 208 
 209 // DOM API
 210 // error state
 211     WEBCORE_EXPORT MediaError* error() const;
 212 
 213     const URL&amp; currentSrc() const { return m_currentSrc; }
 214 
 215     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 216     void setSrcObject(MediaProvider&amp;&amp;);
 217 
<a name="4" id="anc4"></a><span class="line-modified"> 218     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);</span>
 219     WEBCORE_EXPORT String crossOrigin() const;
 220 
 221 // network state
 222     using HTMLMediaElementEnums::NetworkState;
 223     WEBCORE_EXPORT NetworkState networkState() const;
 224 
 225     WEBCORE_EXPORT String preload() const;
 226     WEBCORE_EXPORT void setPreload(const String&amp;);
 227 
 228     Ref&lt;TimeRanges&gt; buffered() const override;
 229     WEBCORE_EXPORT void load();
 230     WEBCORE_EXPORT String canPlayType(const String&amp; mimeType) const;
 231 
 232 // ready state
 233     using HTMLMediaElementEnums::ReadyState;
 234     ReadyState readyState() const override;
 235     WEBCORE_EXPORT bool seeking() const;
 236 
 237 // playback state
 238     WEBCORE_EXPORT double currentTime() const override;
 239     WEBCORE_EXPORT void setCurrentTime(double) override;
 240     void setCurrentTimeWithTolerance(double, double toleranceBefore, double toleranceAfter);
 241     double currentTimeForBindings() const { return currentTime(); }
 242     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCurrentTimeForBindings(double);
 243     WEBCORE_EXPORT double getStartDate() const;
 244     WEBCORE_EXPORT double duration() const override;
 245     WEBCORE_EXPORT bool paused() const override;
 246     double defaultPlaybackRate() const override;
 247     void setDefaultPlaybackRate(double) override;
 248     WEBCORE_EXPORT double playbackRate() const override;
 249     void setPlaybackRate(double) override;
 250 
 251 // MediaTime versions of playback state
 252     MediaTime currentMediaTime() const;
 253     void setCurrentTime(const MediaTime&amp;);
 254     MediaTime durationMediaTime() const;
 255     WEBCORE_EXPORT void fastSeek(const MediaTime&amp;);
 256 
 257     void updatePlaybackRate();
 258     WEBCORE_EXPORT bool webkitPreservesPitch() const;
 259     WEBCORE_EXPORT void setWebkitPreservesPitch(bool);
 260     Ref&lt;TimeRanges&gt; played() override;
 261     Ref&lt;TimeRanges&gt; seekable() const override;
 262     double seekableTimeRangesLastModifiedTime() const;
 263     double liveUpdateInterval() const;
 264     WEBCORE_EXPORT bool ended() const;
 265     bool autoplay() const;
 266     bool isAutoplaying() const { return m_autoplaying; }
 267     bool loop() const;
 268     void setLoop(bool b);
 269 
 270     void play(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 271 
 272     WEBCORE_EXPORT void play() override;
 273     WEBCORE_EXPORT void pause() override;
<a name="5" id="anc5"></a>

 274     WEBCORE_EXPORT void fastSeek(double);
 275     double minFastReverseRate() const;
 276     double maxFastForwardRate() const;
 277 
<a name="6" id="anc6"></a><span class="line-modified"> 278     using HTMLMediaElementEnums::BufferingPolicy;</span>
<span class="line-added"> 279     void setBufferingPolicy(BufferingPolicy);</span>
<span class="line-added"> 280     WEBCORE_EXPORT BufferingPolicy bufferingPolicy() const;</span>
<span class="line-added"> 281     WEBCORE_EXPORT void purgeBufferedDataIfPossible();</span>
 282 
 283 // captions
 284     WEBCORE_EXPORT bool webkitHasClosedCaptions() const;
 285     WEBCORE_EXPORT bool webkitClosedCaptionsVisible() const;
 286     WEBCORE_EXPORT void setWebkitClosedCaptionsVisible(bool);
 287 
 288     bool elementIsHidden() const { return m_elementIsHidden; }
 289 
 290 #if ENABLE(MEDIA_STATISTICS)
 291 // Statistics
 292     unsigned webkitAudioDecodedByteCount() const;
 293     unsigned webkitVideoDecodedByteCount() const;
 294 #endif
 295 
 296 #if ENABLE(MEDIA_SOURCE)
 297 //  Media Source.
 298     void detachMediaSource();
 299     void incrementDroppedFrameCount() { ++m_droppedVideoFrames; }
 300     size_t maximumSourceBufferSize(const SourceBuffer&amp;) const;
 301 #endif
 302 
 303 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 304     WebKitMediaKeys* webkitKeys() const { return m_webKitMediaKeys.get(); }
 305     void webkitSetMediaKeys(WebKitMediaKeys*);
 306 
 307     void keyAdded();
 308 #endif
 309 
 310 #if ENABLE(ENCRYPTED_MEDIA)
 311     MediaKeys* mediaKeys() const;
 312 
 313     void setMediaKeys(MediaKeys*, Ref&lt;DeferredPromise&gt;&amp;&amp;);
 314 #endif
 315 
 316 // controls
 317     WEBCORE_EXPORT bool controls() const;
 318     WEBCORE_EXPORT void setControls(bool);
 319     WEBCORE_EXPORT double volume() const override;
 320     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setVolume(double) override;
 321     WEBCORE_EXPORT bool muted() const override;
 322     WEBCORE_EXPORT void setMuted(bool) override;
 323 
 324     WEBCORE_EXPORT void togglePlayState();
 325     WEBCORE_EXPORT void beginScrubbing() override;
 326     WEBCORE_EXPORT void endScrubbing() override;
 327 
 328     void beginScanning(ScanDirection) override;
 329     void endScanning() override;
 330     double nextScanRate();
 331 
 332     WEBCORE_EXPORT bool canPlay() const override;
 333 
 334     double percentLoaded() const;
 335 
 336     bool shouldForceControlsDisplay() const;
 337 
 338 #if ENABLE(VIDEO_TRACK)
 339     ExceptionOr&lt;TextTrack&amp;&gt; addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language);
 340 
 341     AudioTrackList&amp; ensureAudioTracks();
 342     TextTrackList&amp; ensureTextTracks();
 343     VideoTrackList&amp; ensureVideoTracks();
 344     AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
 345     TextTrackList* textTracks() const { return m_textTracks.get(); }
 346     VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
 347 
 348     CueList currentlyActiveCues() const { return m_currentlyActiveCues; }
 349 
 350     void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 351     void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
 352     void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 353     void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 354     void removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;, bool scheduleEvent = true);
 355     void removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 356     void forgetResourceSpecificTracks();
 357     void closeCaptionTracksChanged();
 358     void notifyMediaPlayerOfTextTrackChanges();
 359 
 360     virtual void didAddTextTrack(HTMLTrackElement&amp;);
 361     virtual void didRemoveTextTrack(HTMLTrackElement&amp;);
 362 
 363     void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) final;
 364     void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) final;
 365     void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) final;
 366     void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) final;
 367     void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) final;
 368     void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) final;
 369 
 370 #if ENABLE(AVF_CAPTIONS)
 371     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() final;
 372 #endif
 373 
 374     struct TrackGroup;
 375     void configureTextTrackGroupForLanguage(const TrackGroup&amp;) const;
 376     void scheduleConfigureTextTracks();
 377     void configureTextTracks();
 378     void configureTextTrackGroup(const TrackGroup&amp;);
 379 
 380     void setSelectedTextTrack(TextTrack*);
 381 
 382     bool textTracksAreReady() const;
 383     using HTMLMediaElementEnums::TextTrackVisibilityCheckType;
 384     void configureTextTrackDisplay(TextTrackVisibilityCheckType checkType = CheckTextTrackVisibility);
 385     void updateTextTrackDisplay();
 386 
 387     // AudioTrackClient
 388     void audioTrackEnabledChanged(AudioTrack&amp;) final;
 389 
 390     void textTrackReadyStateChanged(TextTrack*);
 391 
 392     // TextTrackClient
 393     void textTrackKindChanged(TextTrack&amp;) override;
 394     void textTrackModeChanged(TextTrack&amp;) override;
 395     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 396     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 397     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 398     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 399 
 400     // VideoTrackClient
 401     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 402 
 403     bool requiresTextTrackRepresentation() const;
 404     void setTextTrackRepresentation(TextTrackRepresentation*);
 405     void syncTextTrackBounds();
 406 #endif
 407 
 408 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 409     void webkitShowPlaybackTargetPicker();
<a name="7" id="anc7"></a><span class="line-modified"> 410     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-modified"> 411     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
 412 
 413     void wirelessRoutesAvailableDidChange() override;
 414     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 415     void setShouldPlayToPlaybackTarget(bool) override;
 416 #endif
 417     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 418     void setIsPlayingToWirelessTarget(bool);
 419     bool webkitCurrentPlaybackTargetIsWireless() const;
 420 
 421     void setPlayingOnSecondScreen(bool value);
 422     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 423 
 424     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 425 
 426     // EventTarget function.
 427     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 428     // causes an ambiguity error at compile time. This class&#39;s constructor
 429     // ensures that both implementations return document, so return the result
 430     // of one of them here.
 431     using HTMLElement::scriptExecutionContext;
 432 
 433     bool hasSingleSecurityOrigin() const { return !m_player || m_player-&gt;hasSingleSecurityOrigin(); }
 434     bool didPassCORSAccessCheck() const { return m_player &amp;&amp; m_player-&gt;didPassCORSAccessCheck(); }
 435     bool wouldTaintOrigin(const SecurityOrigin&amp; origin) const { return m_player &amp;&amp; m_player-&gt;wouldTaintOrigin(origin); }
 436 
 437     WEBCORE_EXPORT bool isFullscreen() const override;
 438     bool isStandardFullscreen() const;
 439     void toggleStandardFullscreenState();
 440 
 441     using MediaPlayerEnums::VideoFullscreenMode;
 442     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 443     virtual void fullscreenModeChanged(VideoFullscreenMode);
 444 
 445     void enterFullscreen(VideoFullscreenMode);
 446     void enterFullscreen() override;
 447     WEBCORE_EXPORT void exitFullscreen();
 448     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 449 
 450     bool hasClosedCaptions() const override;
 451     bool closedCaptionsVisible() const override;
 452     void setClosedCaptionsVisible(bool) override;
 453 
 454     MediaControls* mediaControls() const;
 455 
 456     void sourceWasRemoved(HTMLSourceElement&amp;);
 457     void sourceWasAdded(HTMLSourceElement&amp;);
 458 
<a name="8" id="anc8"></a><span class="line-modified"> 459     void privateBrowsingStateDidChange(PAL::SessionID) override;</span>
 460 
 461     // Media cache management.
 462     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 463     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 464     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 465     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 466     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 467     static void resetMediaEngines();
 468 
 469     bool isPlaying() const { return m_playing; }
 470 
 471     bool hasPendingActivity() const override;
 472 
 473 #if ENABLE(WEB_AUDIO)
 474     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 475     void setAudioSourceNode(MediaElementAudioSourceNode*);
 476 
 477     AudioSourceProvider* audioSourceProvider();
 478 #endif
 479 
 480     using HTMLMediaElementEnums::InvalidURLAction;
 481     bool isSafeToLoadURL(const URL&amp;, InvalidURLAction);
 482 
 483     const String&amp; mediaGroup() const;
 484     void setMediaGroup(const String&amp;);
 485 
 486     MediaController* controller() const;
 487     void setController(RefPtr&lt;MediaController&gt;&amp;&amp;);
 488 
 489     MediaController* controllerForBindings() const { return controller(); }
 490     void setControllerForBindings(MediaController*);
 491 
 492     void enteredOrExitedFullscreen() { configureMediaControls(); }
 493 
 494     unsigned long long fileSize() const;
 495 
 496     void mediaLoadingFailed(MediaPlayerEnums::NetworkState);
 497     void mediaLoadingFailedFatally(MediaPlayerEnums::NetworkState);
 498 
 499 #if ENABLE(MEDIA_SESSION)
 500     WEBCORE_EXPORT double playerVolume() const;
 501 
 502     const String&amp; kind() const { return m_kind; }
 503     void setKind(const String&amp; kind) { m_kind = kind; }
 504 
 505     MediaSession* session() const;
 506     void setSession(MediaSession*);
 507 
 508     void setShouldDuck(bool);
 509 
 510     static HTMLMediaElement* elementWithID(uint64_t);
 511     uint64_t elementID() const { return m_elementID; }
 512 #endif
 513 
 514     RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
 515 
 516     MediaPlayerEnums::Preload preloadValue() const { return m_preload; }
 517     MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
 518 
 519 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 520     void pageScaleFactorChanged();
 521     void userInterfaceLayoutDirectionChanged();
 522     WEBCORE_EXPORT String getCurrentMediaControlsStatus();
 523 
 524     MediaControlsHost* mediaControlsHost() { return m_mediaControlsHost.get(); }
 525 #endif
 526 
 527     bool isDisablingSleep() const { return m_sleepDisabler.get(); }
 528 
 529     double maxBufferedTime() const;
 530 
 531     MediaProducer::MediaStateFlags mediaState() const override;
 532 
 533     void layoutSizeChanged();
 534     void visibilityDidChange();
 535 
 536     void allowsMediaDocumentInlinePlaybackChanged();
 537     void updateShouldPlay();
 538 
 539     RenderMedia* renderer() const;
 540 
 541     void resetPlaybackSessionState();
 542     bool isVisibleInViewport() const;
 543     bool hasEverNotifiedAboutPlaying() const;
 544     void setShouldDelayLoadEvent(bool);
 545 
 546     bool hasEverHadAudio() const { return m_hasEverHadAudio; }
 547     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 548 
 549     double playbackStartedTime() const { return m_playbackStartedTime; }
 550 
 551     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 552 
 553     void isVisibleInViewportChanged();
 554     void updateRateChangeRestrictions();
 555 
 556     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 557 
 558 #if ENABLE(MEDIA_STREAM)
 559     void mediaStreamCaptureStarted() { resumeAutoplaying(); }
 560     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 561 #endif
 562 
 563     bool supportsSeeking() const override;
 564 
 565 #if !RELEASE_LOG_DISABLED
 566     const Logger&amp; logger() const final { return *m_logger.get(); }
<a name="9" id="anc9"></a><span class="line-modified"> 567     const void* logIdentifier() const final { return m_logIdentifier; }</span>
<span class="line-added"> 568     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }</span>
 569     WTFLogChannel&amp; logChannel() const final;
 570 #endif
 571 
 572     bool willLog(WTFLogLevel) const;
 573 
 574     bool isSuspended() const final;
 575 
 576     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 577     WEBCORE_EXPORT void willExitFullscreen();
 578 
 579     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 580 
 581 protected:
 582     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 583     virtual void finishInitialization();
 584     virtual ~HTMLMediaElement();
 585 
<a name="10" id="anc10"></a><span class="line-modified"> 586     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;</span>
 587     void finishParsingChildren() override;
 588     bool isURLAttribute(const Attribute&amp;) const override;
 589     void willAttachRenderers() override;
 590     void didAttachRenderers() override;
 591     void willDetachRenderers() override;
 592     void didDetachRenderers() override;
 593 
 594     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 595 
 596     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 597     DisplayMode displayMode() const { return m_displayMode; }
 598     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 599 
 600     bool isMediaElement() const final { return true; }
 601 
 602 #if ENABLE(VIDEO_TRACK)
 603     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }
 604     void beginIgnoringTrackDisplayUpdateRequests();
 605     void endIgnoringTrackDisplayUpdateRequests();
 606 #endif
 607 
 608     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 609 
 610 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 611     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 612     void setMediaControlsDependOnPageScaleFactor(bool);
 613     void updateMediaControlsAfterPresentationModeChange();
 614 #endif
 615 
<a name="11" id="anc11"></a><span class="line-modified"> 616     void scheduleEvent(const AtomString&amp; eventName);</span>
 617 
 618 private:
 619     void createMediaPlayer();
 620 
 621     bool supportsFocus() const override;
 622     bool isMouseFocusable() const override;
 623     bool rendererIsNeeded(const RenderStyle&amp;) override;
 624     bool childShouldCreateRenderer(const Node&amp;) const override;
 625     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 626     void didFinishInsertingNode() override;
 627     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 628     void didRecalcStyle(Style::Change) override;
<a name="12" id="anc12"></a><span class="line-added"> 629     bool isInteractiveContent() const override;</span>
 630 
 631     void willBecomeFullscreenElement() override;
 632     void willStopBeingFullscreenElement() override;
 633 
 634     // ActiveDOMObject API.
 635     const char* activeDOMObjectName() const override;
 636     bool canSuspendForDocumentSuspension() const override;
 637     void suspend(ReasonForSuspension) override;
 638     void resume() override;
 639     void stop() override;
 640     void stopWithoutDestroyingMediaPlayer();
 641     void contextDestroyed() override;
 642 
 643     void mediaVolumeDidChange() override;
 644 
 645     void visibilityStateChanged() override;
 646 
 647     virtual void updateDisplayState() { }
 648 
 649     void setReadyState(MediaPlayerEnums::ReadyState);
 650     void setNetworkState(MediaPlayerEnums::NetworkState);
 651 
 652     double effectivePlaybackRate() const;
 653     double requestedPlaybackRate() const;
 654 
 655     void mediaPlayerNetworkStateChanged(MediaPlayer*) override;
 656     void mediaPlayerReadyStateChanged(MediaPlayer*) override;
 657     void mediaPlayerTimeChanged(MediaPlayer*) override;
 658     void mediaPlayerVolumeChanged(MediaPlayer*) override;
 659     void mediaPlayerMuteChanged(MediaPlayer*) override;
 660     void mediaPlayerDurationChanged(MediaPlayer*) override;
 661     void mediaPlayerRateChanged(MediaPlayer*) override;
 662     void mediaPlayerPlaybackStateChanged(MediaPlayer*) override;
 663     void mediaPlayerSawUnsupportedTracks(MediaPlayer*) override;
 664     void mediaPlayerResourceNotSupported(MediaPlayer*) override;
 665     void mediaPlayerRepaint(MediaPlayer*) override;
 666     void mediaPlayerSizeChanged(MediaPlayer*) override;
 667     bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) override;
 668     void mediaPlayerRenderingModeChanged(MediaPlayer*) override;
 669     bool mediaPlayerAcceleratedCompositingEnabled() override;
 670     void mediaPlayerEngineUpdated(MediaPlayer*) override;
 671 
 672     void scheduleMediaEngineWasUpdated();
 673     void mediaEngineWasUpdated();
 674 
 675     void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) override;
 676     void mediaPlayerCharacteristicChanged(MediaPlayer*) override;
 677 
 678 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 679     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const override;
 680     bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) override;
 681     String mediaPlayerMediaKeysStorageDirectory() const override;
 682 #endif
 683 
 684 #if ENABLE(ENCRYPTED_MEDIA)
 685     void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
 686     void mediaPlayerWaitingForKeyChanged() final;
 687 
 688     void attemptToDecrypt();
 689     void attemptToResumePlaybackIfNecessary();
 690 
 691     // CDMClient
 692     void cdmClientAttemptToResumePlaybackIfNecessary() final;
 693 #endif
 694 
 695 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 696     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) override;
 697     void enqueuePlaybackTargetAvailabilityChangedEvent();
 698 
 699     using EventTarget::dispatchEvent;
 700     void dispatchEvent(Event&amp;) override;
 701 #endif
 702 
 703 #if ENABLE(MEDIA_SESSION)
 704     void setSessionInternal(MediaSession&amp;);
 705 #endif
 706 
 707     String mediaPlayerReferrer() const override;
 708     String mediaPlayerUserAgent() const override;
 709 
 710     void mediaPlayerEnterFullscreen() override;
 711     void mediaPlayerExitFullscreen() override;
 712     bool mediaPlayerIsFullscreen() const override;
 713     bool mediaPlayerIsFullscreenPermitted() const override;
 714     bool mediaPlayerIsVideo() const override;
 715     LayoutRect mediaPlayerContentBoxRect() const override;
 716     float mediaPlayerContentsScale() const override;
 717     void mediaPlayerSetSize(const IntSize&amp;) override;
 718     void mediaPlayerPause() override;
 719     void mediaPlayerPlay() override;
 720     bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
 721     bool mediaPlayerIsPaused() const override;
 722     bool mediaPlayerIsLooping() const override;
 723     CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
 724     RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
 725     bool mediaPlayerShouldUsePersistentCache() const override;
 726     const String&amp; mediaPlayerMediaCacheDirectory() const override;
 727 
 728 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
 729     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const override;
 730 #endif
 731 
 732     void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) override;
 733 
 734     void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command) override { didReceiveRemoteControlCommand(command, nullptr); }
 735     String sourceApplicationIdentifier() const override;
 736     String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
 737     Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
 738 
 739 #if PLATFORM(IOS_FAMILY)
 740     String mediaPlayerNetworkInterfaceName() const override;
 741     bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
 742 #endif
 743 
 744     bool mediaPlayerIsInMediaDocument() const final;
 745     void mediaPlayerEngineFailedToLoad() const final;
 746 
 747     double mediaPlayerRequestedPlaybackRate() const final;
 748     VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
 749     bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
 750     bool mediaPlayerShouldDisableSleep() const final { return shouldDisableSleep() == SleepType::Display; }
 751     bool mediaPlayerShouldCheckHardwareSupport() const final;
 752     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final;
 753 
 754 #if USE(GSTREAMER)
 755     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp;) final;
 756 #endif
 757 
 758     void pendingActionTimerFired();
 759     void progressEventTimerFired();
 760     void playbackProgressTimerFired();
 761     void scanTimerFired();
 762     void seekTask();
 763     void startPlaybackProgressTimer();
 764     void startProgressEventTimer();
 765     void stopPeriodicTimers();
 766     void cancelPendingTasks();
 767     void closeTaskQueues();
 768 
 769     void seek(const MediaTime&amp;);
 770     void seekInternal(const MediaTime&amp;);
 771     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM);
 772     void finishSeek();
 773     void clearSeeking();
 774     void addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end);
 775 
 776     void scheduleTimeupdateEvent(bool periodicEvent);
 777     virtual void scheduleResizeEvent() { }
 778     virtual void scheduleResizeEventIfSizeChanged() { }
 779 
 780     void selectMediaResource();
 781     void loadResource(const URL&amp;, ContentType&amp;, const String&amp; keySystem);
 782     void scheduleNextSourceChild();
 783     void loadNextSourceChild();
 784     void userCancelledLoad();
 785     void clearMediaPlayer();
 786     bool havePotentialSourceChild();
 787     void noneSupported();
 788     void cancelPendingEventsAndCallbacks();
 789     void waitForSourceChange();
 790     void prepareToPlay();
 791 
 792     URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
 793 
 794 #if ENABLE(VIDEO_TRACK)
 795     void updateActiveTextTrackCues(const MediaTime&amp;);
 796     HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
 797 
 798     enum ReconfigureMode {
 799         Immediately,
 800         AfterDelay,
 801     };
 802     void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
 803     void captionPreferencesChanged() override;
 804     CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
 805 #endif
 806 
 807     // These &quot;internal&quot; functions do not check user gesture restrictions.
 808     void playInternal();
 809     void pauseInternal();
 810 
 811     void prepareForLoad();
 812     void allowVideoRendering();
 813 
 814     bool processingMediaPlayerCallback() const { return m_processingMediaPlayerCallback &gt; 0; }
 815     void beginProcessingMediaPlayerCallback() { ++m_processingMediaPlayerCallback; }
 816     void endProcessingMediaPlayerCallback() { ASSERT(m_processingMediaPlayerCallback); --m_processingMediaPlayerCallback; }
 817 
 818     void scheduleUpdatePlayState();
 819     void updatePlayState();
 820 
 821     void updateVolume();
 822     void setPlaying(bool);
 823     bool potentiallyPlaying() const;
 824     bool endedPlayback() const;
 825     bool stoppedDueToErrors() const;
 826     bool pausedForUserInteraction() const;
 827     bool couldPlayIfEnoughData() const;
 828     void dispatchPlayPauseEventsIfNeedsQuirks();
 829     SuccessOr&lt;MediaPlaybackDenialReason&gt; canTransitionFromAutoplayToPlay() const;
 830 
 831     void setAutoplayEventPlaybackState(AutoplayEventPlaybackState);
 832     void userDidInterfereWithAutoplay();
 833     void handleAutoplayEvent(AutoplayEvent);
 834 
 835     MediaTime minTimeSeekable() const;
 836     MediaTime maxTimeSeekable() const;
 837 
 838     // Pauses playback without changing any states or generating events
 839     void setPausedInternal(bool);
 840 
 841     void setPlaybackRateInternal(double);
 842 
 843     void mediaCanStart(Document&amp;) final;
 844 
 845     void invalidateCachedTime() const;
 846     void refreshCachedTime() const;
 847 
 848     bool hasMediaControls() const;
 849     bool createMediaControls();
 850     void configureMediaControls();
 851 
 852     void prepareMediaFragmentURI();
 853     void applyMediaFragmentURI();
 854 
 855     void changeNetworkStateFromLoadingToIdle();
 856 
<a name="13" id="anc13"></a><span class="line-modified"> 857     void removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);</span>
 858 
 859     void updateMediaController();
 860     bool isBlocked() const;
 861     bool isBlockedOnMediaController() const;
 862     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
 863     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }
 864 
 865     void updateSleepDisabling();
 866     enum class SleepType {
 867         None,
 868         Display,
 869         System,
 870     };
 871     SleepType shouldDisableSleep() const;
 872 
 873 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 874     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 875     DOMWrapperWorld&amp; ensureIsolatedWorld();
 876     bool ensureMediaControlsInjectedScript();
 877 #endif
 878 
 879     PlatformMediaSession::MediaType mediaType() const override;
 880     PlatformMediaSession::MediaType presentationType() const override;
 881     PlatformMediaSession::DisplayType displayType() const override;
 882     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 883 
 884     void suspendPlayback() override;
 885     void resumeAutoplaying() override;
 886     void mayResumePlayback(bool shouldResume) override;
 887     uint64_t mediaSessionUniqueIdentifier() const final;
 888     String mediaSessionTitle() const override;
 889     double mediaSessionDuration() const override { return duration(); }
 890     double mediaSessionCurrentTime() const override { return currentTime(); }
 891     bool canReceiveRemoteControlCommands() const override { return true; }
 892     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override;
 893     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override;
 894     bool shouldOverrideBackgroundLoadingRestriction() const override;
 895     bool canProduceAudio() const final;
 896     bool processingUserGestureForMedia() const final;
<a name="14" id="anc14"></a><span class="line-added"> 897     bool hasMediaStreamSource() const final;</span>
<span class="line-added"> 898     void processIsSuspendedChanged() final;</span>
 899 
 900     void pageMutedStateDidChange() override;
 901 
 902 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 903     void hardwareMutedStateDidChange(AudioSession*) final;
 904 #endif
 905 
 906     bool effectiveMuted() const;
<a name="15" id="anc15"></a><span class="line-added"> 907     double effectiveVolume() const;</span>
 908 
 909     void registerWithDocument(Document&amp;);
 910     void unregisterWithDocument(Document&amp;);
 911 
 912     void updateCaptionContainer();
 913     void ensureMediaControlsShadowRoot();
 914 
 915     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;
 916     bool setupAndCallJS(const JSSetupFunction&amp;);
 917 
 918 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 919     void prepareForDocumentSuspension() final;
 920     void resumeFromDocumentSuspension() final;
 921 
 922     void scheduleUpdateMediaState();
 923     void updateMediaState();
 924     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 925 #endif
 926 
 927     bool isVideoTooSmallForInlinePlayback();
 928     void updateShouldAutoplay();
 929 
 930     void pauseAfterDetachedTask();
 931     void updatePlaybackControlsManager();
 932     void schedulePlaybackControlsManagerUpdate();
 933     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 934 
 935     void updateRenderer();
 936 
 937     void updatePageScaleFactorJSProperty();
 938     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 939     void setControllerJSProperty(const char*, JSC::JSValue);
 940 
 941     void addBehaviorRestrictionsOnEndIfNecessary();
 942     void handleSeekToPlaybackPosition(double);
 943     void seekToPlaybackPositionEndedTimerFired();
 944 
 945     void applicationWillResignActive() final;
 946     void applicationDidBecomeActive() final;
 947 
 948     void setInActiveDocument(bool);
 949 
 950 #if !RELEASE_LOG_DISABLED
<a name="16" id="anc16"></a>

 951     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 952     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 953 #endif
 954 
 955     Timer m_progressEventTimer;
 956     Timer m_playbackProgressTimer;
 957     Timer m_scanTimer;
 958     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 959     Timer m_seekToPlaybackPositionEndedTimer;
 960     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 961     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 962     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 963     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
 964     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;
 965     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 966     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 967     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 968     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 969     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 970     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 971     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 972     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 973     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 974     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
 975     GenericEventQueue m_asyncEventQueue;
<a name="17" id="anc17"></a><span class="line-added"> 976 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 977     DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;</span>
<span class="line-added"> 978 #endif</span>
 979 
 980     PlayPromiseVector m_pendingPlayPromises;
 981 
 982     double m_requestedPlaybackRate { 1 };
 983     double m_reportedPlaybackRate { 1 };
 984     double m_defaultPlaybackRate { 1 };
 985     bool m_webkitPreservesPitch { true };
 986     NetworkState m_networkState { NETWORK_EMPTY };
 987     ReadyState m_readyState { HAVE_NOTHING };
 988     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 989     URL m_currentSrc;
 990 
 991     RefPtr&lt;MediaError&gt; m_error;
 992 
 993     struct PendingSeek {
<a name="18" id="anc18"></a><span class="line-added"> 994         WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
 995         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 996             : now(now)
 997             , targetTime(targetTime)
 998             , negativeTolerance(negativeTolerance)
 999             , positiveTolerance(positiveTolerance)
1000         {
1001         }
1002         MediaTime now;
1003         MediaTime targetTime;
1004         MediaTime negativeTolerance;
1005         MediaTime positiveTolerance;
1006     };
1007     std::unique_ptr&lt;PendingSeek&gt; m_pendingSeek;
1008     SeekType m_pendingSeekType { NoSeek };
1009 
1010     double m_volume { 1 };
1011     bool m_volumeInitialized { false };
1012     MediaTime m_lastSeekTime;
1013 
1014     MonotonicTime m_previousProgressTime { MonotonicTime::infinity() };
1015     double m_playbackStartedTime { 0 };
1016 
1017     // The last time a timeupdate event was sent (based on monotonic clock).
1018     MonotonicTime m_clockTimeAtLastUpdateEvent;
1019 
1020     // The last time a timeupdate event was sent in movie time.
1021     MediaTime m_lastTimeUpdateEventMovieTime;
1022 
1023     // Loading state.
1024     enum LoadState { WaitingForSource, LoadingFromSrcAttr, LoadingFromSourceElement };
1025     LoadState m_loadState { WaitingForSource };
1026     RefPtr&lt;HTMLSourceElement&gt; m_currentSourceNode;
1027     RefPtr&lt;HTMLSourceElement&gt; m_nextChildNodeToConsider;
1028 
1029     VideoFullscreenMode m_videoFullscreenMode { VideoFullscreenModeNone };
1030     bool m_videoFullscreenStandby { false };
1031     bool m_preparedForInline;
1032     WTF::Function&lt;void()&gt; m_preparedForInlineCompletionHandler;
1033 
1034     bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
1035 
1036 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
1037     RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
1038     FloatRect m_videoFullscreenFrame;
1039     MediaPlayerEnums::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravityResizeAspect };
1040 #endif
1041 
1042     RefPtr&lt;MediaPlayer&gt; m_player;
1043 
1044     MediaPlayerEnums::Preload m_preload { MediaPlayer::Auto };
1045 
1046     DisplayMode m_displayMode { Unknown };
1047 
1048     // Counter incremented while processing a callback from the media player, so we can avoid
1049     // calling the media engine recursively.
1050     int m_processingMediaPlayerCallback { 0 };
1051 
1052 #if ENABLE(MEDIA_SESSION)
1053     String m_kind;
1054     RefPtr&lt;MediaSession&gt; m_session;
1055     bool m_shouldDuck { false };
1056     uint64_t m_elementID;
1057 #endif
1058 
1059 #if ENABLE(MEDIA_SOURCE)
1060     RefPtr&lt;MediaSource&gt; m_mediaSource;
1061     unsigned m_droppedVideoFrames { 0 };
1062 #endif
1063 
1064     mutable MediaTime m_cachedTime;
1065     mutable MonotonicTime m_clockTimeAtLastCachedTimeUpdate;
1066     mutable MonotonicTime m_minimumClockTimeToUpdateCachedTime;
1067 
1068     MediaTime m_fragmentStartTime;
1069     MediaTime m_fragmentEndTime;
1070 
1071     using PendingActionFlags = unsigned;
1072     PendingActionFlags m_pendingActionFlags { 0 };
1073 
1074     enum ActionAfterScanType { Nothing, Play, Pause };
1075     ActionAfterScanType m_actionAfterScan { Nothing };
1076 
1077     enum ScanType { Seek, Scan };
1078     ScanType m_scanType { Scan };
1079     ScanDirection m_scanDirection { Forward };
1080 
<a name="19" id="anc19"></a><span class="line-added">1081     BufferingPolicy m_bufferingPolicy { BufferingPolicy::Default };</span>
<span class="line-added">1082 </span>
1083     bool m_firstTimePlaying : 1;
1084     bool m_playing : 1;
1085     bool m_isWaitingUntilMediaCanStart : 1;
1086     bool m_shouldDelayLoadEvent : 1;
1087     bool m_haveFiredLoadedData : 1;
1088     bool m_inActiveDocument : 1;
1089     bool m_autoplaying : 1;
1090     bool m_muted : 1;
1091     bool m_explicitlyMuted : 1;
1092     bool m_initiallyMuted : 1;
1093     bool m_paused : 1;
1094     bool m_seeking : 1;
1095     bool m_seekRequested : 1;
1096 
1097     // data has not been loaded since sending a &quot;stalled&quot; event
1098     bool m_sentStalledEvent : 1;
1099 
1100     // time has not changed since sending an &quot;ended&quot; event
1101     bool m_sentEndEvent : 1;
1102 
1103     bool m_pausedInternal : 1;
1104 
1105     bool m_closedCaptionsVisible : 1;
1106     bool m_webkitLegacyClosedCaptionOverride : 1;
1107     bool m_completelyLoaded : 1;
1108     bool m_havePreparedToPlay : 1;
1109     bool m_parsingInProgress : 1;
<a name="20" id="anc20"></a>
1110     bool m_elementIsHidden : 1;
1111     bool m_elementWasRemovedFromDOM : 1;
1112     bool m_creatingControls : 1;
1113     bool m_receivedLayoutSizeChanged : 1;
1114     bool m_hasEverNotifiedAboutPlaying : 1;
1115 
1116     bool m_hasEverHadAudio : 1;
1117     bool m_hasEverHadVideo : 1;
1118 
1119 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1120     bool m_mediaControlsDependOnPageScaleFactor : 1;
1121     bool m_haveSetUpCaptionContainer : 1;
1122 #endif
1123 
1124     bool m_isScrubbingRemotely : 1;
1125     bool m_waitingToEnterFullscreen : 1;
1126 
1127 #if ENABLE(VIDEO_TRACK)
1128     bool m_tracksAreReady : 1;
1129     bool m_haveVisibleTextTrack : 1;
1130     bool m_processingPreferenceChange : 1;
1131 
1132     AutoplayEventPlaybackState m_autoplayEventPlaybackState { AutoplayEventPlaybackState::None };
1133 
1134     String m_subtitleTrackLanguage;
1135     MediaTime m_lastTextTrackUpdateTime { -1, 1 };
1136 
1137     Optional&lt;CaptionUserPreferences::CaptionDisplayMode&gt; m_captionDisplayMode;
1138 
1139     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
1140     RefPtr&lt;TextTrackList&gt; m_textTracks;
1141     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
1142     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
1143 
1144     CueIntervalTree m_cueTree;
1145 
1146     CueList m_currentlyActiveCues;
1147     int m_ignoreTrackDisplayUpdate { 0 };
1148 
1149     bool m_requireCaptionPreferencesChangedCallbacks { false };
1150 #endif
1151 
1152 #if ENABLE(WEB_AUDIO)
1153     // This is a weak reference, since m_audioSourceNode holds a reference to us.
1154     // The value is set just after the MediaElementAudioSourceNode is created.
1155     // The value is cleared in MediaElementAudioSourceNode::~MediaElementAudioSourceNode().
1156     MediaElementAudioSourceNode* m_audioSourceNode { nullptr };
1157 #endif
1158 
1159     String m_mediaGroup;
1160     friend class MediaController;
1161     RefPtr&lt;MediaController&gt; m_mediaController;
1162 
1163     std::unique_ptr&lt;PAL::SleepDisabler&gt; m_sleepDisabler;
1164 
1165     WeakPtr&lt;const MediaResourceLoader&gt; m_lastMediaResourceLoaderForTesting;
1166 
1167     friend class TrackDisplayUpdateScope;
1168 
1169     RefPtr&lt;Blob&gt; m_blob;
1170     MediaProvider m_mediaProvider;
1171 
1172 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1173     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1174 #endif
1175 #if ENABLE(ENCRYPTED_MEDIA)
1176     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1177     bool m_attachingMediaKeys { false };
1178     bool m_playbackBlockedWaitingForKey { false };
1179     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1180 #endif
1181 
1182     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1183     size_t m_reportedExtraMemoryCost { 0 };
1184 
1185 #if !RELEASE_LOG_DISABLED
1186     RefPtr&lt;Logger&gt; m_logger;
<a name="21" id="anc21"></a><span class="line-modified">1187     const void* m_logIdentifier;</span>
1188 #endif
1189 
1190 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1191     friend class MediaControlsHost;
1192     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1193     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1194 #endif
1195 
1196 #if ENABLE(MEDIA_STREAM)
1197     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1198     bool m_settingMediaStreamSrcObject { false };
1199 #endif
1200 
1201 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1202     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1203     bool m_hasPlaybackTargetAvailabilityListeners { false };
1204     bool m_failedToPlayToWirelessTarget { false };
1205 #endif
1206 
1207     bool m_isPlayingToWirelessTarget { false };
1208     bool m_playingOnSecondScreen { false };
<a name="22" id="anc22"></a><span class="line-added">1209     bool m_removedBehaviorRestrictionsAfterFirstUserGesture { false };</span>
1210 };
1211 
1212 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1213 
1214 } // namespace WebCore
1215 
1216 namespace WTF {
1217 
1218 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1219     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1220 };
1221 
1222 #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)
1223 
1224 // Template specialization required by PodIntervalTree in debug mode.
1225 template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {
1226     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }
1227 };
1228 
1229 #endif
1230 
1231 #ifndef NDEBUG
1232 
1233 template&lt;&gt; struct ValueToString&lt;MediaTime&gt; {
1234     static String string(const MediaTime&amp; time) { return toString(time); }
1235 };
1236 
1237 #endif
1238 
1239 } // namespace WTF
1240 
1241 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
1242     static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
1243     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
1244 SPECIALIZE_TYPE_TRAITS_END()
1245 
1246 #endif
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>