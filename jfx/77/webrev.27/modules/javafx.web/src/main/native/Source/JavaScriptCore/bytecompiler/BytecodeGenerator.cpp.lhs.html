<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 
  34 #include &quot;ArithProfile.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BuiltinNames.h&quot;
  37 #include &quot;BytecodeGeneratorification.h&quot;
  38 #include &quot;BytecodeLivenessAnalysis.h&quot;
  39 #include &quot;BytecodeStructs.h&quot;
  40 #include &quot;BytecodeUseDef.h&quot;
  41 #include &quot;CatchScope.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;Interpreter.h&quot;
  44 #include &quot;JSAsyncGeneratorFunction.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFixedArray.h&quot;
  48 #include &quot;JSFunction.h&quot;
  49 #include &quot;JSGeneratorFunction.h&quot;
  50 #include &quot;JSImmutableButterfly.h&quot;
  51 #include &quot;JSLexicalEnvironment.h&quot;
  52 #include &quot;JSTemplateObjectDescriptor.h&quot;
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
<a name="1" id="anc1"></a>
  67 #include &lt;wtf/SmallPtrSet.h&gt;
  68 #include &lt;wtf/StdLibExtras.h&gt;
  69 #include &lt;wtf/text/WTFString.h&gt;
  70 
  71 namespace JSC {
  72 
  73 template&lt;typename CallOp, typename = std::true_type&gt;
  74 struct VarArgsOp;
  75 
  76 template&lt;typename CallOp&gt;
  77 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  78     using type = OpTailCallVarargs;
  79 };
  80 
  81 
  82 template&lt;typename CallOp&gt;
  83 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  84     using type = OpCallVarargs;
  85 };
  86 
  87 
  88 template&lt;typename T&gt;
  89 static inline void shrinkToFit(T&amp; segmentedVector)
  90 {
  91     while (segmentedVector.size() &amp;&amp; !segmentedVector.last().refCount())
  92         segmentedVector.removeLast();
  93 }
  94 
  95 void Label::setLocation(BytecodeGenerator&amp; generator, unsigned location)
  96 {
  97     m_location = location;
  98 
  99     for (auto offset : m_unresolvedJumps) {
 100         auto instruction = generator.m_writer.ref(offset);
 101         int target = m_location - offset;
 102 
 103 #define CASE(__op) \
 104     case __op::opcodeID:  \
 105         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 106             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 107             return BoundLabel(); \
 108         }); \
 109         break;
 110 
 111         switch (instruction-&gt;opcodeID()) {
 112         CASE(OpJmp)
 113         CASE(OpJtrue)
 114         CASE(OpJfalse)
 115         CASE(OpJeqNull)
 116         CASE(OpJneqNull)
<a name="2" id="anc2"></a>

 117         CASE(OpJeq)
 118         CASE(OpJstricteq)
 119         CASE(OpJneq)
 120         CASE(OpJneqPtr)
 121         CASE(OpJnstricteq)
 122         CASE(OpJless)
 123         CASE(OpJlesseq)
 124         CASE(OpJgreater)
 125         CASE(OpJgreatereq)
 126         CASE(OpJnless)
 127         CASE(OpJnlesseq)
 128         CASE(OpJngreater)
 129         CASE(OpJngreatereq)
 130         CASE(OpJbelow)
 131         CASE(OpJbeloweq)
 132         default:
 133             ASSERT_NOT_REACHED();
 134         }
 135 #undef CASE
 136     }
 137 }
 138 
 139 int BoundLabel::target()
 140 {
 141     switch (m_type) {
 142     case Offset:
 143         return m_target;
 144     case GeneratorBackward:
 145         return m_target - m_generator-&gt;m_writer.position();
 146     case GeneratorForward:
 147         return 0;
 148     default:
 149         RELEASE_ASSERT_NOT_REACHED();
 150     }
 151 }
 152 
 153 int BoundLabel::saveTarget()
 154 {
 155     if (m_type == GeneratorForward) {
 156         m_savedTarget = m_generator-&gt;m_writer.position();
 157         return 0;
 158     }
 159 
 160     m_savedTarget = target();
 161     return m_savedTarget;
 162 }
 163 
 164 int BoundLabel::commitTarget()
 165 {
 166     if (m_type == GeneratorForward) {
 167         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);
 168         return 0;
 169     }
 170 
 171     return m_savedTarget;
 172 }
 173 
 174 void Variable::dump(PrintStream&amp; out) const
 175 {
 176     out.print(
 177         &quot;{ident = &quot;, m_ident,
 178         &quot;, offset = &quot;, m_offset,
 179         &quot;, local = &quot;, RawPointer(m_local),
 180         &quot;, attributes = &quot;, m_attributes,
 181         &quot;, kind = &quot;, m_kind,
 182         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 183         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 184 }
 185 
<a name="3" id="anc3"></a>










 186 ParserError BytecodeGenerator::generate()
 187 {
 188     m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
 189 
 190     emitLogShadowChickenPrologueIfNecessary();
 191 
 192     // If we have declared a variable named &quot;arguments&quot; and we are using arguments then we should
 193     // perform that assignment now.
 194     if (m_needToInitializeArguments)
 195         initializeVariable(variable(propertyNames().arguments), m_argumentsRegister);
 196 
 197     if (m_restParameter)
 198         m_restParameter-&gt;emit(*this);
 199 
 200     {
 201         RefPtr&lt;RegisterID&gt; temp = newTemporary();
 202         RefPtr&lt;RegisterID&gt; tolLevelScope;
 203         for (auto functionPair : m_functionsToInitialize) {
 204             FunctionMetadataNode* metadata = functionPair.first;
 205             FunctionVariableType functionType = functionPair.second;
 206             emitNewFunction(temp.get(), metadata);
 207             if (functionType == NormalFunctionVariable)
 208                 initializeVariable(variable(metadata-&gt;ident()), temp.get());
 209             else if (functionType == TopLevelFunctionVariable) {
 210                 if (!tolLevelScope) {
 211                     // We know this will resolve to the top level scope or global object because our parser/global initialization code
 212                     // doesn&#39;t allow let/const/class variables to have the same names as functions.
 213                     // This is a top level function, and it&#39;s an error to ever create a top level function
 214                     // name that would resolve to a lexical variable. E.g:
 215                     // ```
 216                     //     function f() {
 217                     //         {
 218                     //             let x;
 219                     //             {
 220                     //             //// error thrown here
 221                     //                  eval(&quot;function x(){}&quot;);
 222                     //             }
 223                     //         }
 224                     //     }
 225                     // ```
 226                     // Therefore, we&#39;re guaranteed to have this resolve to a top level variable.
 227                     RefPtr&lt;RegisterID&gt; tolLevelObjectScope = emitResolveScope(nullptr, Variable(metadata-&gt;ident()));
 228                     tolLevelScope = newBlockScopeVariable();
 229                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 230                 }
 231                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 232             } else
 233                 RELEASE_ASSERT_NOT_REACHED();
 234         }
 235     }
 236 
 237     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();
 238     if (!callingClassConstructor)
 239         m_scopeNode-&gt;emitBytecode(*this);
 240     else {
 241         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 242         // just an artifact of how this generator is structured. That code never runs, but it confuses
 243         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 244         // basic block the strongest way possible.
 245         emitUnreachable();
 246     }
 247 
<a name="4" id="anc4"></a><span class="line-modified"> 248     for (auto&amp; tuple : m_catchesToEmit) {</span>
 249         Ref&lt;Label&gt; realCatchTarget = newLabel();
<a name="5" id="anc5"></a><span class="line-modified"> 250         OpCatch::emit(this, std::get&lt;1&gt;(tuple), std::get&lt;2&gt;(tuple));</span>


 251         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
<a name="6" id="anc6"></a>







 252         m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
 253 
 254 
<a name="7" id="anc7"></a><span class="line-removed"> 255         TryData* tryData = std::get&lt;0&gt;(tuple);</span>
 256         emitJump(tryData-&gt;target.get());
 257         tryData-&gt;target = WTFMove(realCatchTarget);
 258     }
 259 
 260     m_staticPropertyAnalyzer.kill();
 261 
 262     for (auto&amp; range : m_tryRanges) {
 263         int start = range.start-&gt;bind();
 264         int end = range.end-&gt;bind();
 265 
 266         // This will happen for empty try blocks and for some cases of finally blocks:
 267         //
 268         // try {
 269         //    try {
 270         //    } finally {
 271         //        return 42;
 272         //        // *HERE*
 273         //    }
 274         // } finally {
 275         //    print(&quot;things&quot;);
 276         // }
 277         //
 278         // The return will pop scopes to execute the outer finally block. But this includes
 279         // popping the try context for the inner try. The try context is live in the fall-through
 280         // part of the finally block not because we will emit a handler that overlaps the finally,
 281         // but because we haven&#39;t yet had a chance to plant the catch target. Then when we finish
 282         // emitting code for the outer finally block, we repush the try contex, this time with a
 283         // new start index. But that means that the start index for the try range corresponding
 284         // to the inner-finally-following-the-return (marked as &quot;*HERE*&quot; above) will be greater
 285         // than the end index of the try block. This is harmless since end &lt; start handlers will
 286         // never get matched in our logic, but we do the runtime a favor and choose to not emit
 287         // such handlers at all.
 288         if (end &lt;= start)
 289             continue;
 290 
 291         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 292             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 293         m_codeBlock-&gt;addExceptionHandler(info);
 294     }
 295 
 296 
 297     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 298         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 299 
 300     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
 301     m_codeBlock-&gt;setInstructions(m_writer.finalize());
 302 
 303     m_codeBlock-&gt;shrinkToFit();
 304 
 305     if (m_expressionTooDeep)
 306         return ParserError(ParserError::OutOfMemory);
 307     return ParserError(ParserError::ErrorNone);
 308 }
 309 
<a name="8" id="anc8"></a><span class="line-modified"> 310 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 311     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 312     , m_scopeNode(programNode)
 313     , m_codeBlock(vm, codeBlock)
 314     , m_thisRegister(CallFrame::thisArgumentOffset())
 315     , m_codeType(GlobalCode)
<a name="9" id="anc9"></a><span class="line-modified"> 316     , m_vm(&amp;vm)</span>
 317     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 318 {
 319     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 320 
 321     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 322         constantRegister = nullptr;
 323 
 324     allocateCalleeSaveSpace();
 325 
 326     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 327 
 328     emitEnter();
 329 
 330     allocateAndEmitScope();
 331 
<a name="10" id="anc10"></a><span class="line-removed"> 332     emitCheckTraps();</span>
<span class="line-removed"> 333 </span>
 334     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 335 
 336     for (auto* function : functionStack)
 337         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 338 
 339     if (Options::validateBytecode()) {
 340         for (auto&amp; entry : programNode-&gt;varDeclarations())
 341             RELEASE_ASSERT(entry.value.isVar());
 342     }
 343     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 344     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 345     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 346     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 347     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 348     // to the TDZ stack.
 349 
 350     if (needsToUpdateArrowFunctionContext()) {
 351         initializeArrowFunctionContextScopeIfNeeded();
 352         emitPutThisToArrowFunctionContextScope();
 353     }
 354 }
 355 
<a name="11" id="anc11"></a><span class="line-modified"> 356 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 357     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 358     , m_scopeNode(functionNode)
 359     , m_codeBlock(vm, codeBlock)
 360     , m_codeType(FunctionCode)
<a name="12" id="anc12"></a><span class="line-modified"> 361     , m_vm(&amp;vm)</span>
 362     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 363     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 364     // FIXME: We should be able to have tail call elimination with the profiler
 365     // enabled. This is currently not possible because the profiler expects
 366     // op_will_call / op_did_call pairs before and after a call, which are not
 367     // compatible with tail calls (we have no way of emitting op_did_call).
 368     // https://bugs.webkit.org/show_bug.cgi?id=148819
 369     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 370     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 371     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 372 {
 373     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 374         constantRegister = nullptr;
 375 
<a name="13" id="anc13"></a><span class="line-removed"> 376     if (m_isBuiltinFunction)</span>
<span class="line-removed"> 377         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed"> 378 </span>
 379     allocateCalleeSaveSpace();
 380 
<a name="14" id="anc14"></a><span class="line-modified"> 381     SymbolTable* functionSymbolTable = SymbolTable::create(*m_vm);</span>
 382     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 383     int symbolTableConstantIndex = 0;
 384 
 385     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 386     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 387     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 388     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 389     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 390     // a rest parameter, or any destructuring patterns.
 391     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 392     bool isSimpleParameterList = parameters.isSimpleParameterList();
 393 
 394     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 395 
 396     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
<a name="15" id="anc15"></a><span class="line-modified"> 397     bool shouldCaptureSomeOfTheThings = m_shouldEmitDebugHooks || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;</span>
 398 
<a name="16" id="anc16"></a><span class="line-modified"> 399     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
 400     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
 401 
 402     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 403         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 404         needsArguments = false;
<a name="17" id="anc17"></a><span class="line-removed"> 405 </span>
<span class="line-removed"> 406         // Generator and AsyncFunction uses the var scope to save and resume its variables. So the lexical scope is always instantiated.</span>
<span class="line-removed"> 407         shouldCaptureSomeOfTheThings = true;</span>
 408     }
 409 
 410     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 411         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 412         // This is because arguments of a generator should be evaluated before starting it.
 413         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 414         //
 415         //    function *gen(a, b = hello())
 416         //    {
 417         //        return {
 418         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 419         //            {
 420         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 421         //                ...
 422         //            }
 423         //        }
 424         //    }
 425         shouldCaptureSomeOfTheThings = true;
 426     }
 427 
 428     if (shouldCaptureAllOfTheThings)
 429         functionNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 430 
 431     auto captures = scopedLambda&lt;bool (UniquedStringImpl*)&gt;([&amp;] (UniquedStringImpl* uid) -&gt; bool {
 432         if (!shouldCaptureSomeOfTheThings)
 433             return false;
 434         if (needsArguments &amp;&amp; uid == propertyNames().arguments.impl()) {
 435             // Actually, we only need to capture the arguments object when we &quot;need full activation&quot;
 436             // because of name scopes. But historically we did it this way, so for now we just preserve
 437             // the old behavior.
 438             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=143072
 439             return true;
 440         }
 441         return functionNode-&gt;captures(uid);
 442     });
 443     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 444         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 445     };
 446 
 447     m_calleeRegister.setIndex(CallFrameSlot::callee);
 448 
 449     initializeParameters(parameters);
 450     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 451 
 452     emitEnter();
 453 
 454     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 455         m_generatorRegister = &amp;m_parameters[1];
 456 
 457     allocateAndEmitScope();
 458 
<a name="18" id="anc18"></a><span class="line-removed"> 459     emitCheckTraps();</span>
<span class="line-removed"> 460 </span>
 461     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 462         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 463         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 464         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 465         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 466         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 467         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 468     }
 469 
 470     if (shouldCaptureSomeOfTheThings)
 471         m_lexicalEnvironmentRegister = addVar();
 472 
<a name="19" id="anc19"></a><span class="line-modified"> 473     if (shouldCaptureSomeOfTheThings || vm.typeProfiler())</span>
 474         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 475 
 476     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 477     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 478     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 479     if (isSimpleParameterList)
 480         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
 481 
 482     // Figure out some interesting facts about our arguments.
 483     bool capturesAnyArgumentByName = false;
 484     if (functionNode-&gt;hasCapturedVariables()) {
 485         FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 486         for (size_t i = 0; i &lt; parameters.size(); ++i) {
 487             auto pattern = parameters.at(i).first;
 488             if (!pattern-&gt;isBindingNode())
 489                 continue;
 490             const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
 491             capturesAnyArgumentByName |= captures(ident.impl());
 492         }
 493     }
 494 
 495     if (capturesAnyArgumentByName)
 496         ASSERT(m_lexicalEnvironmentRegister);
 497 
 498     // Need to know what our functions are called. Parameters have some goofy behaviors when it
 499     // comes to functions of the same name.
 500     for (FunctionMetadataNode* function : functionNode-&gt;functionStack())
 501         m_functions.add(function-&gt;ident().impl());
 502 
 503     if (needsArguments) {
 504         // Create the arguments object now. We may put the arguments object into the activation if
 505         // it is captured. Either way, we create two arguments object variables: one is our
 506         // private variable that is immutable, and another that is the user-visible variable. The
 507         // immutable one is only used here, or during formal parameter resolutions if we opt for
 508         // DirectArguments.
 509 
 510         m_argumentsRegister = addVar();
 511         m_argumentsRegister-&gt;ref();
 512     }
 513 
 514     if (needsArguments &amp;&amp; !codeBlock-&gt;isStrictMode() &amp;&amp; isSimpleParameterList) {
 515         // If we captured any formal parameter by name, then we use ScopedArguments. Otherwise we
 516         // use DirectArguments. With ScopedArguments, we lift all of our arguments into the
 517         // activation.
 518 
 519         if (capturesAnyArgumentByName) {
 520             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 521 
 522             // For each parameter, we have two possibilities:
 523             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 524             // in the symbol table - or it just gets space reserved in the symbol table. Either
 525             // way we lift the value into the scope.
 526             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 527                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 528                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 529                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 530                     VarOffset varOffset(offset);
 531                     SymbolTableEntry entry(varOffset);
 532                     // Stores to these variables via the ScopedArguments object will not do
 533                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 534                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 535                     // So, we just disable it.
<a name="20" id="anc20"></a><span class="line-modified"> 536                     entry.disableWatching(*m_vm);</span>
 537                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 538                 }
<a name="21" id="anc21"></a><span class="line-modified"> 539                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
 540             }
 541 
 542             // This creates a scoped arguments object and copies the overflow arguments into the
 543             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 544             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 545         } else {
 546             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 547             // that the symbol table knows that this is happening.
 548             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 549                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 550                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 551             }
 552 
 553             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 554         }
 555     } else if (isSimpleParameterList) {
 556         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 557         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 558         // because when default parameter expressions exist, they belong in their own lexical environment
 559         // separate from the &quot;var&quot; lexical environment.
 560         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 561             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 562             if (!name)
 563                 continue;
 564 
 565             if (!captures(name)) {
 566                 // This is the easy case - just tell the symbol table about the argument. It will
 567                 // be accessed directly.
 568                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));
 569                 continue;
 570             }
 571 
 572             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 573             const Identifier&amp; ident =
 574                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 575             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 576 
<a name="22" id="anc22"></a><span class="line-modified"> 577             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
 578         }
 579     }
 580 
 581     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 582         // Allocate a cloned arguments object.
 583         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 584     }
 585 
 586     // There are some variables that need to be preinitialized to something other than Undefined:
 587     //
 588     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 589     //   arguments object.
 590     //
 591     // - functions: these always override everything else.
 592     //
 593     // The most logical way to do all of this is to initialize none of the variables until now,
 594     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 595     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 596     // then all arguments, then the functions.
 597     //
 598     // But some arguments are already initialized by default, since if they aren&#39;t captured and we
 599     // don&#39;t have &quot;arguments&quot; then we just point the symbol table at the stack slot of those
 600     // arguments. We end up initializing the rest of the arguments that have an uncomplicated
 601     // binding (i.e. don&#39;t involve destructuring) above when figuring out how to lay them out,
 602     // because that&#39;s just the simplest thing. This means that when we initialize them, we have to
 603     // watch out for the things that override arguments (namely, functions).
 604 
 605     // This is our final act of weirdness. &quot;arguments&quot; is overridden by everything except the
 606     // callee. We add it to the symbol table if it&#39;s not already there and it&#39;s not an argument.
 607     bool shouldCreateArgumentsVariableInParameterScope = false;
 608     if (needsArguments) {
 609         // If &quot;arguments&quot; is overridden by a function or destructuring parameter name, then it&#39;s
 610         // OK for us to call createVariable() because it won&#39;t change anything. It&#39;s also OK for
 611         // us to them tell BytecodeGenerator::generate() to write to it because it will do so
 612         // before it initializes functions and destructuring parameters. But if &quot;arguments&quot; is
 613         // overridden by a &quot;simple&quot; function parameter, then we have to bail: createVariable()
 614         // would assert and BytecodeGenerator::generate() would write the &quot;arguments&quot; after the
 615         // argument value had already been properly initialized.
 616 
 617         bool haveParameterNamedArguments = false;
 618         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 619             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 620             if (name == propertyNames().arguments.impl()) {
 621                 haveParameterNamedArguments = true;
 622                 break;
 623             }
 624         }
 625 
 626         bool shouldCreateArgumensVariable = !haveParameterNamedArguments
 627             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(m_codeBlock-&gt;parseMode());
 628         shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
 629         // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
 630         if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
 631             createVariable(
 632                 propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
 633 
 634             m_needToInitializeArguments = true;
 635         }
 636     }
 637 
 638     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 639         const Identifier&amp; ident = function-&gt;ident();
 640         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 641         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 642     }
 643     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 644         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 645         if (!entry.value.isVar()) // This is either a parameter or callee.
 646             continue;
 647         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 648             continue;
 649         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 650     }
 651 
 652 
<a name="23" id="anc23"></a><span class="line-modified"> 653     m_newTargetRegister = addVar();</span>


 654     switch (parseMode) {
 655     case SourceParseMode::GeneratorWrapperFunctionMode:
 656     case SourceParseMode::GeneratorWrapperMethodMode:
 657     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 658     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 659         m_generatorRegister = addVar();
 660 
 661         // FIXME: Emit to_this only when Generator uses it.
 662         // https://bugs.webkit.org/show_bug.cgi?id=151586
 663         emitToThis();
 664 
 665         move(m_generatorRegister, &amp;m_calleeRegister);
 666         emitCreateThis(m_generatorRegister);
 667         break;
 668     }
 669 
 670     case SourceParseMode::AsyncArrowFunctionMode:
 671     case SourceParseMode::AsyncMethodMode:
 672     case SourceParseMode::AsyncFunctionMode: {
 673         ASSERT(!isConstructor());
 674         ASSERT(constructorKind() == ConstructorKind::None);
 675         m_generatorRegister = addVar();
 676         m_promiseCapabilityRegister = addVar();
 677 
 678         if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
 679             // FIXME: Emit to_this only when AsyncFunctionBody uses it.
 680             // https://bugs.webkit.org/show_bug.cgi?id=151586
 681             emitToThis();
 682         }
 683 
 684         emitNewObject(m_generatorRegister);
 685 
 686         // let promiseCapability be @newPromiseCapability(@Promise)
 687         auto varNewPromiseCapability = variable(propertyNames().builtinNames().newPromiseCapabilityPrivateName());
 688         RefPtr&lt;RegisterID&gt; scope = newTemporary();
 689         move(scope.get(), emitResolveScope(scope.get(), varNewPromiseCapability));
 690         RefPtr&lt;RegisterID&gt; newPromiseCapability = emitGetFromScope(newTemporary(), scope.get(), varNewPromiseCapability, ThrowIfNotFound);
 691 
 692         CallArguments args(*this, nullptr, 1);
 693         emitLoad(args.thisRegister(), jsUndefined());
 694 
 695         auto&amp; builtinNames = propertyNames().builtinNames();
 696         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());
 697         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));
 698         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);
 699 
 700         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
 701         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
 702         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
 703         break;
 704     }
 705 
 706     case SourceParseMode::AsyncGeneratorBodyMode:
 707     case SourceParseMode::AsyncFunctionBodyMode:
 708     case SourceParseMode::AsyncArrowFunctionBodyMode:
 709     case SourceParseMode::GeneratorBodyMode: {
 710         // |this| is already filled correctly before here.
<a name="24" id="anc24"></a><span class="line-modified"> 711         emitLoad(m_newTargetRegister, jsUndefined());</span>

 712         break;
 713     }
 714 
 715     default: {
 716         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 717             if (isConstructor()) {
<a name="25" id="anc25"></a><span class="line-modified"> 718                 move(m_newTargetRegister, &amp;m_thisRegister);</span>

 719                 if (constructorKind() == ConstructorKind::Extends) {
 720                     moveEmptyValue(&amp;m_thisRegister);
 721                 } else
 722                     emitCreateThis(&amp;m_thisRegister);
 723             } else if (constructorKind() != ConstructorKind::None)
 724                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);
 725             else {
 726                 bool shouldEmitToThis = false;
 727                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())
 728                     shouldEmitToThis = true;
 729                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {
 730                     // We must emit to_this when we&#39;re not in strict mode because we
 731                     // will convert |this| to an object, and that object may be passed
 732                     // to a strict function as |this|. This is observable because that
 733                     // strict function&#39;s to_this will just return the object.
 734                     //
 735                     // We don&#39;t need to emit this for strict-mode code because
 736                     // strict-mode code may call another strict function, which will
 737                     // to_this if it directly uses this; this is OK, because we defer
 738                     // to_this until |this| is used directly. Strict-mode code might
 739                     // also call a sloppy mode function, and that will to_this, which
 740                     // will defer the conversion, again, until necessary.
 741                     shouldEmitToThis = true;
 742                 }
 743 
 744                 if (shouldEmitToThis)
 745                     emitToThis();
 746             }
 747         }
 748         break;
 749     }
 750     }
 751 
 752     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 753     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 754     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 755         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 756             emitLoadThisFromArrowFunctionLexicalEnvironment();
 757 
<a name="26" id="anc26"></a><span class="line-modified"> 758         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
 759             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 760     }
 761 
 762     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 763         bool canReuseLexicalEnvironment = isSimpleParameterList;
 764         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 765         emitPutThisToArrowFunctionContextScope();
 766         emitPutNewTargetToArrowFunctionContextScope();
 767         emitPutDerivedConstructorToArrowFunctionContextScope();
 768     }
 769 
 770     // All &quot;addVar()&quot;s needs to happen before &quot;initializeDefaultParameterValuesAndSetupFunctionScopeStack()&quot; is called
 771     // because a function&#39;s default parameter ExpressionNodes will use temporary registers.
 772     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 773 
 774     Ref&lt;Label&gt; catchLabel = newLabel();
 775     TryData* tryFormalParametersData = nullptr;
 776     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 777     if (needTryCatch) {
 778         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 779         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 780     }
 781 
 782     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 783 
 784     if (needTryCatch) {
 785         Ref&lt;Label&gt; didNotThrow = newLabel();
 786         emitJump(didNotThrow.get());
 787         emitLabel(catchLabel.get());
 788         popTry(tryFormalParametersData, catchLabel.get());
 789 
 790         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
<a name="27" id="anc27"></a><span class="line-modified"> 791         RegisterID* unused = newTemporary();</span>
<span class="line-removed"> 792         emitCatch(unused, thrownValue.get(), tryFormalParametersData);</span>
 793 
 794         // return promiseCapability.@reject(thrownValue)
<a name="28" id="anc28"></a><span class="line-modified"> 795         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().rejectPrivateName());</span>
 796 
 797         CallArguments args(*this, nullptr, 1);
 798         emitLoad(args.thisRegister(), jsUndefined());
 799         move(args.argumentRegister(0), thrownValue.get());
 800 
 801         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
 802 
 803         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<a name="29" id="anc29"></a><span class="line-modified"> 804         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().promisePrivateName()));</span>
 805 
 806         emitLabel(didNotThrow.get());
 807     }
 808 
 809     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 810     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 811     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 812     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 813         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 814             emitLoadThisFromArrowFunctionLexicalEnvironment();
 815 
<a name="30" id="anc30"></a><span class="line-modified"> 816         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
 817             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 818     }
 819 
 820     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 821     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 822     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
<a name="31" id="anc31"></a><span class="line-modified"> 823         ASSERT(m_lexicalEnvironmentRegister);</span>
<span class="line-removed"> 824         m_generatorFrameSymbolTable.set(*m_vm, functionSymbolTable);</span>
 825         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
<a name="32" id="anc32"></a><span class="line-modified"> 826         move(generatorFrameRegister(), m_lexicalEnvironmentRegister);</span>








 827         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
 828     }
 829 
 830     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 831     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 832 }
 833 
<a name="33" id="anc33"></a><span class="line-modified"> 834 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 835     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 836     , m_scopeNode(evalNode)
 837     , m_codeBlock(vm, codeBlock)
 838     , m_thisRegister(CallFrame::thisArgumentOffset())
 839     , m_codeType(EvalCode)
<a name="34" id="anc34"></a><span class="line-modified"> 840     , m_vm(&amp;vm)</span>
 841     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 842     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 843     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 844 {
 845     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 846         constantRegister = nullptr;
 847 
 848     allocateCalleeSaveSpace();
 849 
 850     m_codeBlock-&gt;setNumParameters(1);
 851 
 852     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 853 
 854     emitEnter();
 855 
 856     allocateAndEmitScope();
 857 
<a name="35" id="anc35"></a><span class="line-removed"> 858     emitCheckTraps();</span>
<span class="line-removed"> 859 </span>
 860     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 861         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 862         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 863     }
 864 
 865     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 866     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 867     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 868     for (auto&amp; entry : varDeclarations) {
 869         ASSERT(entry.value.isVar());
<a name="36" id="anc36"></a><span class="line-modified"> 870         ASSERT(entry.key-&gt;isAtomic() || entry.key-&gt;isSymbol());</span>
 871         if (entry.value.isSloppyModeHoistingCandidate())
 872             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 873         else
 874             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 875     }
 876     codeBlock-&gt;adoptVariables(variables);
 877     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 878 
<a name="37" id="anc37"></a><span class="line-modified"> 879     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
 880         m_newTargetRegister = addVar();
 881 
 882     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 883         emitLoadThisFromArrowFunctionLexicalEnvironment();
 884 
<a name="38" id="anc38"></a><span class="line-modified"> 885     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
 886         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 887 
 888     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 889         initializeArrowFunctionContextScopeIfNeeded();
 890         emitPutThisToArrowFunctionContextScope();
 891     }
 892 
 893     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 894     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 895 }
 896 
<a name="39" id="anc39"></a><span class="line-modified"> 897 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 898     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 899     , m_scopeNode(moduleProgramNode)
 900     , m_codeBlock(vm, codeBlock)
 901     , m_thisRegister(CallFrame::thisArgumentOffset())
 902     , m_codeType(ModuleCode)
<a name="40" id="anc40"></a><span class="line-modified"> 903     , m_vm(&amp;vm)</span>
 904     , m_usesNonStrictEval(false)
 905     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 906 {
 907     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 908 
 909     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 910         constantRegister = nullptr;
 911 
<a name="41" id="anc41"></a><span class="line-removed"> 912     if (m_isBuiltinFunction)</span>
<span class="line-removed"> 913         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed"> 914 </span>
 915     allocateCalleeSaveSpace();
 916 
<a name="42" id="anc42"></a><span class="line-modified"> 917     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(*m_vm);</span>
 918     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 919     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 920 
<a name="43" id="anc43"></a><span class="line-modified"> 921     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
 922     if (shouldCaptureAllOfTheThings)
 923         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 924 
 925     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 926         return moduleProgramNode-&gt;captures(uid);
 927     };
 928     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 929         // Allocate the exported variables in the module environment.
 930         if (entry.isExported())
 931             return VarKind::Scope;
 932 
 933         // Allocate the namespace variables in the module environment to instantiate
 934         // it from the outside of the module code.
 935         if (entry.isImportedNamespace())
 936             return VarKind::Scope;
 937 
 938         if (entry.isCaptured())
 939             return VarKind::Scope;
 940         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 941     };
 942 
 943     emitEnter();
 944 
 945     allocateAndEmitScope();
 946 
<a name="44" id="anc44"></a><span class="line-removed"> 947     emitCheckTraps();</span>
<span class="line-removed"> 948 </span>
 949     m_calleeRegister.setIndex(CallFrameSlot::callee);
 950 
 951     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 952 
 953     // Now declare all variables.
 954 
<a name="45" id="anc45"></a><span class="line-modified"> 955     createVariable(m_vm-&gt;propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);</span>
 956 
 957     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 958         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 959         if (!entry.value.isVar()) // This is either a parameter or callee.
 960             continue;
 961         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 962         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 963         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 964         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 965             continue;
 966         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 967     }
 968 
 969     VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
 970     instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
 971 
 972     // We keep the symbol table in the constant pool.
 973     RegisterID* constantSymbolTable = nullptr;
<a name="46" id="anc46"></a><span class="line-modified"> 974     if (vm.typeProfiler())</span>
 975         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
 976     else
<a name="47" id="anc47"></a><span class="line-modified"> 977         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(*m_vm));</span>
 978 
 979     pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
 980     bool isWithScope = false;
 981     m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
 982     emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
 983 
 984     // makeFunction assumes that there&#39;s correct TDZ stack entries.
 985     // So it should be called after putting our lexical environment to the TDZ stack correctly.
 986 
 987     for (FunctionMetadataNode* function : moduleProgramNode-&gt;functionStack()) {
 988         const auto&amp; iterator = moduleProgramNode-&gt;varDeclarations().find(function-&gt;ident().impl());
 989         RELEASE_ASSERT(iterator != moduleProgramNode-&gt;varDeclarations().end());
 990         RELEASE_ASSERT(!iterator-&gt;value.isImported());
 991 
 992         VarKind varKind = lookUpVarKind(iterator-&gt;key.get(), iterator-&gt;value);
 993         if (varKind == VarKind::Scope) {
 994             // http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation
 995             // Section 15.2.1.16.4, step 16-a-iv-1.
 996             // All heap allocated function declarations should be instantiated when the module environment
 997             // is created. They include the exported function declarations and not-exported-but-heap-allocated
 998             // function declarations. This is required because exported function should be instantiated before
 999             // executing the any module in the dependency graph. This enables the modules to link the imported
1000             // bindings before executing the any module code.
1001             //
1002             // And since function declarations are instantiated before executing the module body code, the spec
1003             // allows the functions inside the module to be executed before its module body is executed under
1004             // the circular dependencies. The following is the example.
1005             //
1006             // Module A (executed first):
1007             //    import { b } from &quot;B&quot;;
1008             //    // Here, the module &quot;B&quot; is not executed yet, but the function declaration is already instantiated.
1009             //    // So we can call the function exported from &quot;B&quot;.
1010             //    b();
1011             //
1012             //    export function a() {
1013             //    }
1014             //
1015             // Module B (executed second):
1016             //    import { a } from &quot;A&quot;;
1017             //
1018             //    export function b() {
1019             //        c();
1020             //    }
1021             //
1022             //    // c is not exported, but since it is referenced from the b, we should instantiate it before
1023             //    // executing the &quot;B&quot; module code.
1024             //    function c() {
1025             //        a();
1026             //    }
1027             //
1028             // Module EntryPoint (executed last):
1029             //    import &quot;B&quot;;
1030             //    import &quot;A&quot;;
1031             //
1032             m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
1033         } else {
1034             // Stack allocated functions can be allocated when executing the module&#39;s body.
1035             m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
1036         }
1037     }
1038 
1039     // Remember the constant register offset to the top-most symbol table. This symbol table will be
1040     // cloned in the code block linking. After that, to create the module environment, we retrieve
1041     // the cloned symbol table from the linked code block by using this offset.
1042     codeBlock-&gt;setModuleEnvironmentSymbolTableConstantRegisterOffset(constantSymbolTable-&gt;index());
1043 }
1044 
1045 BytecodeGenerator::~BytecodeGenerator()
1046 {
1047 }
1048 
1049 void BytecodeGenerator::initializeDefaultParameterValuesAndSetupFunctionScopeStack(
1050     FunctionParameters&amp; parameters, bool isSimpleParameterList, FunctionNode* functionNode, SymbolTable* functionSymbolTable,
1051     int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope)
1052 {
1053     Vector&lt;std::pair&lt;Identifier, RefPtr&lt;RegisterID&gt;&gt;&gt; valuesToMoveIntoVars;
1054     ASSERT(!(isSimpleParameterList &amp;&amp; shouldCreateArgumentsVariableInParameterScope));
1055     if (!isSimpleParameterList) {
1056         // Refer to the ES6 spec section 9.2.12: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
1057         // This implements step 21.
1058         VariableEnvironment environment;
1059         Vector&lt;Identifier&gt; allParameterNames;
1060         for (unsigned i = 0; i &lt; parameters.size(); i++)
1061             parameters.at(i).first-&gt;collectBoundIdentifiers(allParameterNames);
1062         if (shouldCreateArgumentsVariableInParameterScope)
1063             allParameterNames.append(propertyNames().arguments);
1064         IdentifierSet parameterSet;
1065         for (auto&amp; ident : allParameterNames) {
1066             parameterSet.add(ident.impl());
1067             auto addResult = environment.add(ident);
1068             addResult.iterator-&gt;value.setIsLet(); // When we have default parameter expressions, parameters act like &quot;let&quot; variables.
1069             if (captures(ident.impl()))
1070                 addResult.iterator-&gt;value.setIsCaptured();
1071         }
1072         // This implements step 25 of section 9.2.12.
1073         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1074 
1075         if (shouldCreateArgumentsVariableInParameterScope) {
1076             Variable argumentsVariable = variable(propertyNames().arguments);
1077             initializeVariable(argumentsVariable, m_argumentsRegister);
1078             liftTDZCheckIfPossible(argumentsVariable);
1079         }
1080 
1081         RefPtr&lt;RegisterID&gt; temp = newTemporary();
1082         for (unsigned i = 0; i &lt; parameters.size(); i++) {
1083             std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt; parameter = parameters.at(i);
1084             if (parameter.first-&gt;isRestParameter())
1085                 continue;
1086             if ((i + 1) &lt; m_parameters.size())
1087                 move(temp.get(), &amp;m_parameters[i + 1]);
1088             else
1089                 emitGetArgument(temp.get(), i);
1090             if (parameter.second) {
1091                 RefPtr&lt;RegisterID&gt; condition = emitIsUndefined(newTemporary(), temp.get());
1092                 Ref&lt;Label&gt; skipDefaultParameterBecauseNotUndefined = newLabel();
1093                 emitJumpIfFalse(condition.get(), skipDefaultParameterBecauseNotUndefined.get());
1094                 emitNode(temp.get(), parameter.second);
1095                 emitLabel(skipDefaultParameterBecauseNotUndefined.get());
1096             }
1097 
1098             parameter.first-&gt;bindValue(*this, temp.get());
1099         }
1100 
1101         // Final act of weirdness for default parameters. If a &quot;var&quot; also
1102         // has the same name as a parameter, it should start out as the
1103         // value of that parameter. Note, though, that they will be distinct
1104         // bindings.
1105         // This is step 28 of section 9.2.12.
1106         for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
1107             if (!entry.value.isVar()) // This is either a parameter or callee.
1108                 continue;
1109 
1110             if (parameterSet.contains(entry.key)) {
1111                 Identifier ident = Identifier::fromUid(m_vm, entry.key.get());
1112                 Variable var = variable(ident);
1113                 RegisterID* scope = emitResolveScope(nullptr, var);
1114                 RefPtr&lt;RegisterID&gt; value = emitGetFromScope(newTemporary(), scope, var, DoNotThrowIfNotFound);
1115                 valuesToMoveIntoVars.append(std::make_pair(ident, value));
1116             }
1117         }
1118 
1119         // Functions with default parameter expressions must have a separate environment
1120         // record for parameters and &quot;var&quot;s. The &quot;var&quot; environment record must have the
1121         // parameter environment record as its parent.
1122         // See step 28 of section 9.2.12.
1123         bool hasCapturedVariables = !!m_lexicalEnvironmentRegister;
1124         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, hasCapturedVariables);
1125     }
1126 
1127     // This completes step 28 of section 9.2.12.
1128     for (unsigned i = 0; i &lt; valuesToMoveIntoVars.size(); i++) {
1129         ASSERT(!isSimpleParameterList);
1130         Variable var = variable(valuesToMoveIntoVars[i].first);
1131         RegisterID* scope = emitResolveScope(nullptr, var);
1132         emitPutToScope(scope, var, valuesToMoveIntoVars[i].second.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
1133     }
1134 }
1135 
1136 bool BytecodeGenerator::needsDerivedConstructorInArrowFunctionLexicalEnvironment()
1137 {
1138     ASSERT(m_codeBlock-&gt;isClassContext() || !(isConstructor() &amp;&amp; constructorKind() == ConstructorKind::Extends));
1139     return m_codeBlock-&gt;isClassContext() &amp;&amp; isSuperUsedInInnerArrowFunction();
1140 }
1141 
1142 void BytecodeGenerator::initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable, bool canReuseLexicalEnvironment)
1143 {
1144     ASSERT(!m_arrowFunctionContextLexicalEnvironmentRegister);
1145 
1146     if (canReuseLexicalEnvironment &amp;&amp; m_lexicalEnvironmentRegister) {
1147         RELEASE_ASSERT(!m_codeBlock-&gt;isArrowFunction());
1148         RELEASE_ASSERT(functionSymbolTable);
1149 
1150         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalEnvironmentRegister;
1151 
1152         ScopeOffset offset;
1153 
1154         if (isThisUsedInInnerArrowFunction()) {
1155             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1156             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().thisIdentifier.impl(), SymbolTableEntry(VarOffset(offset)));
1157         }
1158 
1159         if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1160             offset = functionSymbolTable-&gt;takeNextScopeOffset();
1161             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().newTargetLocalPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1162         }
1163 
1164         if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1165             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1166             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().derivedConstructorPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1167         }
1168 
1169         return;
1170     }
1171 
1172     VariableEnvironment environment;
1173 
1174     if (isThisUsedInInnerArrowFunction()) {
1175         auto addResult = environment.add(propertyNames().thisIdentifier);
1176         addResult.iterator-&gt;value.setIsCaptured();
1177         addResult.iterator-&gt;value.setIsLet();
1178     }
1179 
1180     if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1181         auto addTarget = environment.add(propertyNames().builtinNames().newTargetLocalPrivateName());
1182         addTarget.iterator-&gt;value.setIsCaptured();
1183         addTarget.iterator-&gt;value.setIsLet();
1184     }
1185 
1186     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1187         auto derivedConstructor = environment.add(propertyNames().builtinNames().derivedConstructorPrivateName());
1188         derivedConstructor.iterator-&gt;value.setIsCaptured();
1189         derivedConstructor.iterator-&gt;value.setIsLet();
1190     }
1191 
1192     if (environment.size() &gt; 0) {
1193         size_t size = m_lexicalScopeStack.size();
1194         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1195 
1196         ASSERT_UNUSED(size, m_lexicalScopeStack.size() == size + 1);
1197 
1198         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalScopeStack.last().m_scope;
1199     }
1200 }
1201 
1202 RegisterID* BytecodeGenerator::initializeNextParameter()
1203 {
1204     VirtualRegister reg = virtualRegisterForArgument(m_codeBlock-&gt;numParameters());
1205     m_parameters.grow(m_parameters.size() + 1);
1206     auto&amp; parameter = registerFor(reg);
1207     parameter.setIndex(reg.offset());
1208     m_codeBlock-&gt;addParameter();
1209     return &amp;parameter;
1210 }
1211 
1212 void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
1213 {
1214     // Make sure the code block knows about all of our parameters, and make sure that parameters
1215     // needing destructuring are noted.
1216     m_thisRegister.setIndex(initializeNextParameter()-&gt;index()); // this
1217 
1218     bool nonSimpleArguments = false;
1219     for (unsigned i = 0; i &lt; parameters.size(); ++i) {
1220         auto parameter = parameters.at(i);
1221         auto pattern = parameter.first;
1222         if (pattern-&gt;isRestParameter()) {
1223             RELEASE_ASSERT(!m_restParameter);
1224             m_restParameter = static_cast&lt;RestParameterNode*&gt;(pattern);
1225             nonSimpleArguments = true;
1226             continue;
1227         }
1228         if (parameter.second) {
1229             nonSimpleArguments = true;
1230             continue;
1231         }
1232         if (!nonSimpleArguments)
1233             initializeNextParameter();
1234     }
1235 }
1236 
1237 void BytecodeGenerator::initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables)
1238 {
1239     if (hasCapturedVariables) {
1240         RELEASE_ASSERT(m_lexicalEnvironmentRegister);
1241         OpCreateLexicalEnvironment::emit(this, m_lexicalEnvironmentRegister, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
1242 
1243         OpMov::emit(this, scopeRegister(), m_lexicalEnvironmentRegister);
1244 
1245         pushLocalControlFlowScope();
1246     }
1247     bool isWithScope = false;
1248     m_lexicalScopeStack.append({ functionSymbolTable, m_lexicalEnvironmentRegister, isWithScope, symbolTableConstantIndex });
1249     m_varScopeLexicalScopeStackIndex = m_lexicalScopeStack.size() - 1;
1250 }
1251 
1252 UniquedStringImpl* BytecodeGenerator::visibleNameForParameter(DestructuringPatternNode* pattern)
1253 {
1254     if (pattern-&gt;isBindingNode()) {
1255         const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
1256         if (!m_functions.contains(ident.impl()))
1257             return ident.impl();
1258     }
1259     return nullptr;
1260 }
1261 
1262 RegisterID* BytecodeGenerator::newRegister()
1263 {
1264     m_calleeLocals.append(virtualRegisterForLocal(m_calleeLocals.size()));
1265     int numCalleeLocals = std::max&lt;int&gt;(m_codeBlock-&gt;m_numCalleeLocals, m_calleeLocals.size());
1266     numCalleeLocals = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), numCalleeLocals);
1267     m_codeBlock-&gt;m_numCalleeLocals = numCalleeLocals;
1268     return &amp;m_calleeLocals.last();
1269 }
1270 
1271 void BytecodeGenerator::reclaimFreeRegisters()
1272 {
1273     shrinkToFit(m_calleeLocals);
1274 }
1275 
1276 RegisterID* BytecodeGenerator::newBlockScopeVariable()
1277 {
1278     reclaimFreeRegisters();
1279 
1280     return newRegister();
1281 }
1282 
1283 RegisterID* BytecodeGenerator::newTemporary()
1284 {
1285     reclaimFreeRegisters();
1286 
1287     RegisterID* result = newRegister();
1288     result-&gt;setTemporary();
1289     return result;
1290 }
1291 
1292 Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
1293 {
1294     shrinkToFit(m_labelScopes);
1295 
1296     // Allocate new label scope.
1297     m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
1298     return m_labelScopes.last();
1299 }
1300 
1301 Ref&lt;Label&gt; BytecodeGenerator::newLabel()
1302 {
1303     shrinkToFit(m_labels);
1304 
1305     // Allocate new label ID.
1306     m_labels.append();
1307     return m_labels.last();
1308 }
1309 
1310 Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()
1311 {
1312     Ref&lt;Label&gt; label = newLabel();
1313     emitLabel(label.get());
1314     return label;
1315 }
1316 
1317 void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)
1318 {
1319     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
1320     m_lastInstruction = m_writer.ref();
1321     m_lastOpcodeID = opcodeID;
1322 }
1323 
<a name="48" id="anc48"></a><span class="line-modified">1324 void BytecodeGenerator::alignWideOpcode()</span>








1325 {
1326 #if CPU(NEEDS_ALIGNED_ACCESS)
<a name="49" id="anc49"></a><span class="line-modified">1327     while ((m_writer.position() + 1) % OpcodeSize::Wide)</span>
1328         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
1329 #endif
1330 }
1331 
1332 void BytecodeGenerator::emitLabel(Label&amp; l0)
1333 {
1334     unsigned newLabelIndex = instructions().size();
1335     l0.setLocation(*this, newLabelIndex);
1336 
1337     if (m_codeBlock-&gt;numberOfJumpTargets()) {
1338         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();
1339         ASSERT(lastLabelIndex &lt;= newLabelIndex);
1340         if (newLabelIndex == lastLabelIndex) {
1341             // Peephole optimizations have already been disabled by emitting the last label
1342             return;
1343         }
1344     }
1345 
1346     m_codeBlock-&gt;addJumpTarget(newLabelIndex);
1347 
1348     // This disables peephole optimizations when an instruction is a jump target
1349     m_lastOpcodeID = op_end;
1350 }
1351 
1352 void BytecodeGenerator::emitEnter()
1353 {
1354     OpEnter::emit(this);
1355 
1356     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1357         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1358         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1359         m_codeBlock-&gt;addJumpTarget(instructions().size());
1360         // This disables peephole optimizations when an instruction is a jump target
1361         m_lastOpcodeID = op_end;
1362     }
1363 }
1364 
1365 void BytecodeGenerator::emitLoopHint()
1366 {
1367     OpLoopHint::emit(this);
<a name="50" id="anc50"></a><span class="line-removed">1368     emitCheckTraps();</span>
1369 }
1370 
1371 void BytecodeGenerator::emitJump(Label&amp; target)
1372 {
1373     OpJmp::emit(this, target.bind(this));
1374 }
1375 
<a name="51" id="anc51"></a><span class="line-removed">1376 void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-removed">1377 {</span>
<span class="line-removed">1378     OpCheckTraps::emit(this);</span>
<span class="line-removed">1379 }</span>
<span class="line-removed">1380 </span>
1381 void ALWAYS_INLINE BytecodeGenerator::rewind()
1382 {
1383     ASSERT(m_lastInstruction.isValid());
1384     m_lastOpcodeID = op_end;
1385     m_writer.rewind(m_lastInstruction);
1386 }
1387 
1388 template&lt;typename BinOp, typename JmpOp&gt;
1389 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1390 {
<a name="52" id="anc52"></a>
1391     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1392     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1393         rewind();
1394 
1395         if (swapOperands)
1396             std::swap(binop.m_lhs, binop.m_rhs);
1397 
1398         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1399         return true;
1400     }
1401     return false;
1402 }
1403 
1404 template&lt;typename UnaryOp, typename JmpOp&gt;
1405 bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
1406 {
<a name="53" id="anc53"></a>
1407     auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
1408     if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1409         rewind();
1410 
1411         JmpOp::emit(this, unop.m_operand, target.bind(this));
1412         return true;
1413     }
1414     return false;
1415 }
1416 
1417 void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
1418 {
<a name="54" id="anc54"></a><span class="line-modified">1419 </span>
<span class="line-modified">1420     if (m_lastOpcodeID == op_less) {</span>
<span class="line-modified">1421         if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))</span>
<span class="line-modified">1422             return;</span>
<span class="line-modified">1423     } else if (m_lastOpcodeID == op_lesseq) {</span>
<span class="line-modified">1424         if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))</span>
<span class="line-modified">1425             return;</span>
<span class="line-modified">1426     } else if (m_lastOpcodeID == op_greater) {</span>
<span class="line-modified">1427         if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))</span>
<span class="line-modified">1428             return;</span>
<span class="line-modified">1429     } else if (m_lastOpcodeID == op_greatereq) {</span>
<span class="line-modified">1430         if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))</span>
<span class="line-modified">1431             return;</span>
<span class="line-modified">1432     } else if (m_lastOpcodeID == op_eq) {</span>
<span class="line-modified">1433         if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1434             return;</span>
<span class="line-modified">1435     } else if (m_lastOpcodeID == op_stricteq) {</span>
<span class="line-modified">1436         if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1437             return;</span>
<span class="line-modified">1438     } else if (m_lastOpcodeID == op_neq) {</span>
<span class="line-modified">1439         if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1440             return;</span>
<span class="line-modified">1441     } else if (m_lastOpcodeID == op_nstricteq) {</span>
<span class="line-modified">1442         if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1443             return;</span>
<span class="line-modified">1444     } else if (m_lastOpcodeID == op_below) {</span>
<span class="line-modified">1445         if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))</span>
<span class="line-modified">1446             return;</span>
<span class="line-modified">1447     } else if (m_lastOpcodeID == op_beloweq) {</span>
<span class="line-modified">1448         if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))</span>
<span class="line-modified">1449             return;</span>
<span class="line-modified">1450     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1451         if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">1452             return;</span>
<span class="line-modified">1453     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1454         if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1455             return;</span>




1456     }
1457 
1458     OpJtrue::emit(this, cond, target.bind(this));
1459 }
1460 
1461 void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
1462 {
<a name="55" id="anc55"></a><span class="line-modified">1463     if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1464         if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))</span>
<span class="line-modified">1465             return;</span>
<span class="line-modified">1466     } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1467         if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))</span>
<span class="line-modified">1468             return;</span>
<span class="line-modified">1469     } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1470         if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))</span>
<span class="line-modified">1471             return;</span>
<span class="line-modified">1472     } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1473         if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))</span>
<span class="line-modified">1474             return;</span>
<span class="line-modified">1475     } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1476         if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1477             return;</span>
<span class="line-modified">1478     } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1479         if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1480             return;</span>
<span class="line-modified">1481     } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1482         if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1483             return;</span>
<span class="line-modified">1484     } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1485         if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1486             return;</span>
<span class="line-modified">1487     } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1488         if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))</span>
<span class="line-modified">1489             return;</span>
<span class="line-modified">1490     } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1491         if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))</span>
<span class="line-modified">1492             return;</span>
<span class="line-modified">1493     } else if (m_lastOpcodeID == op_not) {</span>
<span class="line-modified">1494         if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))</span>
<span class="line-modified">1495             return;</span>
<span class="line-modified">1496     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1497         if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1498             return;</span>
<span class="line-modified">1499     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1500         if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">1501             return;</span>





1502     }
1503 
1504     OpJfalse::emit(this, cond, target.bind(this));
1505 }
1506 
1507 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1508 {
1509     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));
1510 }
1511 
1512 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1513 {
1514     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));
1515 }
1516 
1517 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1518 {
1519     UniquedStringImpl* rep = ident.impl();
1520     return m_identifierMap.contains(rep);
1521 }
1522 
1523 unsigned BytecodeGenerator::addConstant(const Identifier&amp; ident)
1524 {
1525     UniquedStringImpl* rep = ident.impl();
1526     IdentifierMap::AddResult result = m_identifierMap.add(rep, m_codeBlock-&gt;numberOfIdentifiers());
1527     if (result.isNewEntry)
1528         m_codeBlock-&gt;addIdentifier(ident);
1529 
1530     return result.iterator-&gt;value;
1531 }
1532 
1533 // We can&#39;t hash JSValue(), so we use a dedicated data member to cache it.
1534 RegisterID* BytecodeGenerator::addConstantEmptyValue()
1535 {
1536     if (!m_emptyValueRegister) {
1537         int index = addConstantIndex();
1538         m_codeBlock-&gt;addConstant(JSValue());
1539         m_emptyValueRegister = &amp;m_constantPoolRegisters[index];
1540     }
1541 
1542     return m_emptyValueRegister;
1543 }
1544 
1545 RegisterID* BytecodeGenerator::addConstantValue(JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1546 {
1547     if (!v)
1548         return addConstantEmptyValue();
1549 
1550     int index = m_nextConstantOffset;
1551 
1552     if (sourceCodeRepresentation == SourceCodeRepresentation::Double &amp;&amp; v.isInt32())
1553         v = jsDoubleNumber(v.asNumber());
1554     EncodedJSValueWithRepresentation valueMapKey { JSValue::encode(v), sourceCodeRepresentation };
1555     JSValueMap::AddResult result = m_jsValueMap.add(valueMapKey, m_nextConstantOffset);
1556     if (result.isNewEntry) {
1557         addConstantIndex();
1558         m_codeBlock-&gt;addConstant(v, sourceCodeRepresentation);
1559     } else
1560         index = result.iterator-&gt;value;
1561     return &amp;m_constantPoolRegisters[index];
1562 }
1563 
1564 RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
1565 {
1566     unsigned constantIndex = static_cast&lt;unsigned&gt;(type);
1567     if (!m_linkTimeConstantRegisters[constantIndex]) {
1568         int index = addConstantIndex();
1569         m_codeBlock-&gt;addConstant(type);
1570         m_linkTimeConstantRegisters[constantIndex] = &amp;m_constantPoolRegisters[index];
1571     }
1572 
1573     if (!dst)
1574         return m_linkTimeConstantRegisters[constantIndex];
1575 
1576     OpMov::emit(this, dst, m_linkTimeConstantRegisters[constantIndex]);
1577 
1578     return dst;
1579 }
1580 
1581 RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
1582 {
1583     RefPtr&lt;RegisterID&gt; emptyValue = addConstantEmptyValue();
1584 
1585     OpMov::emit(this, dst, emptyValue.get());
1586 
1587     return dst;
1588 }
1589 
1590 RegisterID* BytecodeGenerator::emitMove(RegisterID* dst, RegisterID* src)
1591 {
1592     ASSERT(src != m_emptyValueRegister);
1593 
1594     m_staticPropertyAnalyzer.mov(dst, src);
1595     OpMov::emit(this, dst, src);
1596 
1597     return dst;
1598 }
1599 
1600 RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, OperandTypes types)
1601 {
1602     switch (opcodeID) {
1603     case op_not:
1604         emitUnaryOp&lt;OpNot&gt;(dst, src);
1605         break;
1606     case op_negate:
1607         OpNegate::emit(this, dst, src, types);
1608         break;
1609     case op_bitnot:
1610         emitUnaryOp&lt;OpBitnot&gt;(dst, src);
1611         break;
1612     case op_to_number:
1613         emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1614         break;
1615     default:
1616         ASSERT_NOT_REACHED();
1617     }
1618     return dst;
1619 }
1620 
1621 RegisterID* BytecodeGenerator::emitBinaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
1622 {
1623     switch (opcodeID) {
1624     case op_eq:
1625         return emitBinaryOp&lt;OpEq&gt;(dst, src1, src2, types);
1626     case op_neq:
1627         return emitBinaryOp&lt;OpNeq&gt;(dst, src1, src2, types);
1628     case op_stricteq:
1629         return emitBinaryOp&lt;OpStricteq&gt;(dst, src1, src2, types);
1630     case op_nstricteq:
1631         return emitBinaryOp&lt;OpNstricteq&gt;(dst, src1, src2, types);
1632     case op_less:
1633         return emitBinaryOp&lt;OpLess&gt;(dst, src1, src2, types);
1634     case op_lesseq:
1635         return emitBinaryOp&lt;OpLesseq&gt;(dst, src1, src2, types);
1636     case op_greater:
1637         return emitBinaryOp&lt;OpGreater&gt;(dst, src1, src2, types);
1638     case op_greatereq:
1639         return emitBinaryOp&lt;OpGreatereq&gt;(dst, src1, src2, types);
1640     case op_below:
1641         return emitBinaryOp&lt;OpBelow&gt;(dst, src1, src2, types);
1642     case op_beloweq:
1643         return emitBinaryOp&lt;OpBeloweq&gt;(dst, src1, src2, types);
1644     case op_mod:
1645         return emitBinaryOp&lt;OpMod&gt;(dst, src1, src2, types);
1646     case op_pow:
1647         return emitBinaryOp&lt;OpPow&gt;(dst, src1, src2, types);
1648     case op_lshift:
1649         return emitBinaryOp&lt;OpLshift&gt;(dst, src1, src2, types);
1650     case op_rshift:
1651         return emitBinaryOp&lt;OpRshift&gt;(dst, src1, src2, types);
1652     case op_urshift:
1653         return emitBinaryOp&lt;OpUrshift&gt;(dst, src1, src2, types);
1654     case op_add:
1655         return emitBinaryOp&lt;OpAdd&gt;(dst, src1, src2, types);
1656     case op_mul:
1657         return emitBinaryOp&lt;OpMul&gt;(dst, src1, src2, types);
1658     case op_div:
1659         return emitBinaryOp&lt;OpDiv&gt;(dst, src1, src2, types);
1660     case op_sub:
1661         return emitBinaryOp&lt;OpSub&gt;(dst, src1, src2, types);
1662     case op_bitand:
1663         return emitBinaryOp&lt;OpBitand&gt;(dst, src1, src2, types);
1664     case op_bitxor:
1665         return emitBinaryOp&lt;OpBitxor&gt;(dst, src1, src2, types);
1666     case op_bitor:
1667         return emitBinaryOp&lt;OpBitor&gt;(dst, src1, src2, types);
1668     default:
1669         ASSERT_NOT_REACHED();
1670         return nullptr;
1671     }
1672 }
1673 
1674 RegisterID* BytecodeGenerator::emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message)
1675 {
1676     OpToObject::emit(this, dst, src, addConstant(message));
1677     return dst;
1678 }
1679 
1680 RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
1681 {
1682     return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1683 }
1684 
1685 RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
1686 {
1687     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1688 }
1689 
1690 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1691 {
1692     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1693 }
1694 
1695 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1696 {
1697     OpInc::emit(this, srcDst);
1698     return srcDst;
1699 }
1700 
1701 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1702 {
1703     OpDec::emit(this, srcDst);
1704     return srcDst;
1705 }
1706 
<a name="56" id="anc56"></a><span class="line-modified">1707 template&lt;typename EqOp&gt;</span>
<span class="line-removed">1708 RegisterID* BytecodeGenerator::emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
1709 {
<a name="57" id="anc57"></a>


1710     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1711         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
1712         if (src1-&gt;index() == op.m_dst.offset()
1713             &amp;&amp; src1-&gt;isTemporary()
1714             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
1715             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
1716             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
1717             if (value == &quot;undefined&quot;) {
1718                 rewind();
1719                 OpIsUndefined::emit(this, dst, op.m_value);
<a name="58" id="anc58"></a><span class="line-modified">1720                 return dst;</span>
1721             }
1722             if (value == &quot;boolean&quot;) {
1723                 rewind();
1724                 OpIsBoolean::emit(this, dst, op.m_value);
<a name="59" id="anc59"></a><span class="line-modified">1725                 return dst;</span>
1726             }
1727             if (value == &quot;number&quot;) {
1728                 rewind();
1729                 OpIsNumber::emit(this, dst, op.m_value);
<a name="60" id="anc60"></a><span class="line-modified">1730                 return dst;</span>
1731             }
1732             if (value == &quot;string&quot;) {
1733                 rewind();
1734                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
<a name="61" id="anc61"></a><span class="line-modified">1735                 return dst;</span>
1736             }
1737             if (value == &quot;symbol&quot;) {
1738                 rewind();
1739                 OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
<a name="62" id="anc62"></a><span class="line-modified">1740                 return dst;</span>
1741             }
1742             if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
1743                 rewind();
1744                 OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
<a name="63" id="anc63"></a><span class="line-modified">1745                 return dst;</span>
1746             }
1747             if (value == &quot;object&quot;) {
1748                 rewind();
1749                 OpIsObjectOrNull::emit(this, dst, op.m_value);
<a name="64" id="anc64"></a><span class="line-modified">1750                 return dst;</span>
1751             }
1752             if (value == &quot;function&quot;) {
1753                 rewind();
1754                 OpIsFunction::emit(this, dst, op.m_value);
<a name="65" id="anc65"></a><span class="line-modified">1755                 return dst;</span>
1756             }
1757         }
1758     }
1759 
<a name="66" id="anc66"></a><span class="line-modified">1760     EqOp::emit(this, dst, src1, src2);</span>
<span class="line-removed">1761     return dst;</span>
1762 }
1763 
1764 void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1765 {
<a name="67" id="anc67"></a><span class="line-modified">1766     ASSERT(vm()-&gt;typeProfiler());</span>
1767 
1768     unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
1769     unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
1770     unsigned instructionOffset = instructions().size() - 1;
1771     m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
1772 }
1773 
1774 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
1775 {
<a name="68" id="anc68"></a><span class="line-modified">1776     if (!vm()-&gt;typeProfiler())</span>
1777         return;
1778 
1779     if (!registerToProfile)
1780         return;
1781 
<a name="69" id="anc69"></a><span class="line-modified">1782     OpProfileType::emit(this, registerToProfile, 0, flag, { }, resolveType());</span>
1783 
1784     // Don&#39;t emit expression info for this version of profile type. This generally means
1785     // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
1786     // program. For example, implicit return undefined from a function call.
1787 }
1788 
1789 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1790 {
1791     emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
1792 }
1793 
1794 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1795 {
<a name="70" id="anc70"></a><span class="line-modified">1796     if (!vm()-&gt;typeProfiler())</span>
1797         return;
1798 
1799     if (!registerToProfile)
1800         return;
1801 
<a name="71" id="anc71"></a><span class="line-modified">1802     OpProfileType::emit(this, registerToProfile, 0,  flag, { }, resolveType());</span>
1803     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1804 }
1805 
1806 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1807 {
<a name="72" id="anc72"></a><span class="line-modified">1808     if (!vm()-&gt;typeProfiler())</span>
1809         return;
1810 
1811     if (!registerToProfile)
1812         return;
1813 
1814     ProfileTypeBytecodeFlag flag;
<a name="73" id="anc73"></a><span class="line-modified">1815     int symbolTableOrScopeDepth;</span>
1816     if (var.local() || var.offset().isScope()) {
1817         flag = ProfileTypeBytecodeLocallyResolved;
1818         ASSERT(var.symbolTableConstantIndex());
<a name="74" id="anc74"></a><span class="line-modified">1819         symbolTableOrScopeDepth = var.symbolTableConstantIndex();</span>
1820     } else {
1821         flag = ProfileTypeBytecodeClosureVar;
<a name="75" id="anc75"></a><span class="line-modified">1822         symbolTableOrScopeDepth = localScopeDepth();</span>
1823     }
1824 
1825     OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
1826     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1827 }
1828 
1829 void BytecodeGenerator::emitProfileControlFlow(int textOffset)
1830 {
<a name="76" id="anc76"></a><span class="line-modified">1831     if (vm()-&gt;controlFlowProfiler()) {</span>
1832         RELEASE_ASSERT(textOffset &gt;= 0);
1833 
1834         OpProfileControlFlow::emit(this, textOffset);
1835         m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
1836     }
1837 }
1838 
1839 unsigned BytecodeGenerator::addConstantIndex()
1840 {
1841     unsigned index = m_nextConstantOffset;
1842     m_constantPoolRegisters.append(FirstConstantRegisterIndex + m_nextConstantOffset);
1843     ++m_nextConstantOffset;
1844     return index;
1845 }
1846 
1847 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, bool b)
1848 {
1849     return emitLoad(dst, jsBoolean(b));
1850 }
1851 
1852 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, const Identifier&amp; identifier)
1853 {
1854     ASSERT(!identifier.isSymbol());
1855     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
1856     if (!stringInMap)
1857         stringInMap = jsOwnedString(vm(), identifier.string());
1858 
1859     return emitLoad(dst, JSValue(stringInMap));
1860 }
1861 
1862 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1863 {
1864     RegisterID* constantID = addConstantValue(v, sourceCodeRepresentation);
1865     if (dst)
1866         return move(dst, constantID);
1867     return constantID;
1868 }
1869 
1870 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, IdentifierSet&amp; set)
1871 {
1872     if (m_codeBlock-&gt;numberOfConstantIdentifierSets()) {
1873         for (const auto&amp; entry : m_codeBlock-&gt;constantIdentifierSets()) {
1874             if (entry.first != set)
1875                 continue;
1876 
1877             return &amp;m_constantPoolRegisters[entry.second];
1878         }
1879     }
1880 
1881     unsigned index = addConstantIndex();
1882     m_codeBlock-&gt;addSetConstant(set);
1883     RegisterID* m_setRegister = &amp;m_constantPoolRegisters[index];
1884 
1885     if (dst)
1886         return move(dst, m_setRegister);
1887 
1888     return m_setRegister;
1889 }
1890 
1891 template&lt;typename LookUpVarKindFunctor&gt;
1892 bool BytecodeGenerator::instantiateLexicalVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable, ScopeRegisterType scopeRegisterType, LookUpVarKindFunctor lookUpVarKind)
1893 {
1894     bool hasCapturedVariables = false;
1895     {
1896         for (auto&amp; entry : lexicalVariables) {
1897             ASSERT(entry.value.isLet() || entry.value.isConst() || entry.value.isFunction());
1898             ASSERT(!entry.value.isVar());
1899             SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1900             ASSERT(symbolTableEntry.isNull());
1901 
1902             // Imported bindings which are not the namespace bindings are not allocated
1903             // in the module environment as usual variables&#39; way.
1904             // And since these types of the variables only seen in the module environment,
1905             // other lexical environment need not to take care this.
1906             if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1907                 continue;
1908 
1909             VarKind varKind = lookUpVarKind(entry.key.get(), entry.value);
1910             VarOffset varOffset;
1911             if (varKind == VarKind::Scope) {
1912                 varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
1913                 hasCapturedVariables = true;
1914             } else {
1915                 ASSERT(varKind == VarKind::Stack);
1916                 RegisterID* local;
1917                 if (scopeRegisterType == ScopeRegisterType::Block) {
1918                     local = newBlockScopeVariable();
1919                     local-&gt;ref();
1920                 } else
1921                     local = addVar();
1922                 varOffset = VarOffset(local-&gt;virtualRegister());
1923             }
1924 
1925             SymbolTableEntry newEntry(varOffset, static_cast&lt;unsigned&gt;(entry.value.isConst() ? PropertyAttribute::ReadOnly : PropertyAttribute::None));
1926             symbolTable-&gt;add(NoLockingNecessary, entry.key.get(), newEntry);
1927         }
1928     }
1929     return hasCapturedVariables;
1930 }
1931 
1932 void BytecodeGenerator::emitPrefillStackTDZVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable)
1933 {
1934     // Prefill stack variables with the TDZ empty value.
1935     // Scope variables will be initialized to the TDZ empty value when JSLexicalEnvironment is allocated.
1936     for (auto&amp; entry : lexicalVariables) {
1937         // Imported bindings which are not the namespace bindings are not allocated
1938         // in the module environment as usual variables&#39; way.
1939         // And since these types of the variables only seen in the module environment,
1940         // other lexical environment need not to take care this.
1941         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1942             continue;
1943 
1944         if (entry.value.isFunction())
1945             continue;
1946 
1947         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1948         ASSERT(!symbolTableEntry.isNull());
1949         VarOffset offset = symbolTableEntry.varOffset();
1950         if (offset.isScope())
1951             continue;
1952 
1953         ASSERT(offset.isStack());
1954         moveEmptyValue(&amp;registerFor(offset.stackOffset()));
1955     }
1956 }
1957 
1958 void BytecodeGenerator::pushLexicalScope(VariableEnvironmentNode* node, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType, RegisterID** constantSymbolTableResult, bool shouldInitializeBlockScopedFunctions)
1959 {
1960     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
1961     RegisterID* constantSymbolTableResultTemp = nullptr;
1962     pushLexicalScopeInternal(environment, tdzCheckOptimization, nestedScopeType, &amp;constantSymbolTableResultTemp, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1963 
1964     if (shouldInitializeBlockScopedFunctions)
1965         initializeBlockScopedFunctions(environment, node-&gt;functionStack(), constantSymbolTableResultTemp);
1966 
1967     if (constantSymbolTableResult &amp;&amp; constantSymbolTableResultTemp)
1968         *constantSymbolTableResult = constantSymbolTableResultTemp;
1969 }
1970 
1971 void BytecodeGenerator::pushLexicalScopeInternal(VariableEnvironment&amp; environment, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType,
1972     RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
1973 {
1974     if (!environment.size())
1975         return;
1976 
<a name="77" id="anc77"></a><span class="line-modified">1977     if (m_shouldEmitDebugHooks)</span>
1978         environment.markAllVariablesAsCaptured();
1979 
<a name="78" id="anc78"></a><span class="line-modified">1980     SymbolTable* symbolTable = SymbolTable::create(*m_vm);</span>
1981     switch (scopeType) {
1982     case ScopeType::CatchScope:
1983         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
1984         break;
1985     case ScopeType::LetConstScope:
1986         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
1987         break;
1988     case ScopeType::FunctionNameScope:
1989         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::FunctionNameScope);
1990         break;
1991     }
1992 
1993     if (nestedScopeType == NestedScopeType::IsNested)
1994         symbolTable-&gt;markIsNestedLexicalScope();
1995 
1996     auto lookUpVarKind = [] (UniquedStringImpl*, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
1997         return entry.isCaptured() ? VarKind::Scope : VarKind::Stack;
1998     };
1999 
2000     bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
2001 
2002     RegisterID* newScope = nullptr;
2003     RegisterID* constantSymbolTable = nullptr;
2004     int symbolTableConstantIndex = 0;
<a name="79" id="anc79"></a><span class="line-modified">2005     if (vm()-&gt;typeProfiler()) {</span>
2006         constantSymbolTable = addConstantValue(symbolTable);
2007         symbolTableConstantIndex = constantSymbolTable-&gt;index();
2008     }
2009     if (hasCapturedVariables) {
2010         if (scopeRegisterType == ScopeRegisterType::Block) {
2011             newScope = newBlockScopeVariable();
2012             newScope-&gt;ref();
2013         } else
2014             newScope = addVar();
2015         if (!constantSymbolTable) {
<a name="80" id="anc80"></a><span class="line-modified">2016             ASSERT(!vm()-&gt;typeProfiler());</span>
<span class="line-modified">2017             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(*m_vm));</span>
2018             symbolTableConstantIndex = constantSymbolTable-&gt;index();
2019         }
2020         if (constantSymbolTableResult)
2021             *constantSymbolTableResult = constantSymbolTable;
2022 
2023         OpCreateLexicalEnvironment::emit(this, newScope, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(tdzRequirement == TDZRequirement::UnderTDZ ? jsTDZValue() : jsUndefined()));
2024 
2025         move(scopeRegister(), newScope);
2026 
2027         pushLocalControlFlowScope();
2028     }
2029 
2030     bool isWithScope = false;
2031     m_lexicalScopeStack.append({ symbolTable, newScope, isWithScope, symbolTableConstantIndex });
2032     pushTDZVariables(environment, tdzCheckOptimization, tdzRequirement);
2033 
2034     if (tdzRequirement == TDZRequirement::UnderTDZ)
2035         emitPrefillStackTDZVariables(environment, symbolTable);
2036 }
2037 
2038 void BytecodeGenerator::initializeBlockScopedFunctions(VariableEnvironment&amp; environment, FunctionStack&amp; functionStack, RegisterID* constantSymbolTable)
2039 {
2040     /*
2041      * We must transform block scoped function declarations in strict mode like so:
2042      *
2043      * function foo() {
2044      *     if (c) {
2045      *           function foo() { ... }
2046      *           if (bar) { ... }
2047      *           else { ... }
2048      *           function baz() { ... }
2049      *     }
2050      * }
2051      *
2052      * to:
2053      *
2054      * function foo() {
2055      *     if (c) {
2056      *         let foo = function foo() { ... }
2057      *         let baz = function baz() { ... }
2058      *         if (bar) { ... }
2059      *         else { ... }
2060      *     }
2061      * }
2062      *
2063      * But without the TDZ checks.
2064     */
2065 
2066     if (!environment.size()) {
2067         RELEASE_ASSERT(!functionStack.size());
2068         return;
2069     }
2070 
2071     if (!functionStack.size())
2072         return;
2073 
2074     SymbolTable* symbolTable = m_lexicalScopeStack.last().m_symbolTable;
2075     RegisterID* scope = m_lexicalScopeStack.last().m_scope;
2076     RefPtr&lt;RegisterID&gt; temp = newTemporary();
2077     int symbolTableIndex = constantSymbolTable ? constantSymbolTable-&gt;index() : 0;
2078     for (FunctionMetadataNode* function : functionStack) {
2079         const Identifier&amp; name = function-&gt;ident();
2080         auto iter = environment.find(name.impl());
2081         RELEASE_ASSERT(iter != environment.end());
2082         RELEASE_ASSERT(iter-&gt;value.isFunction());
2083         // We purposefully don&#39;t hold the symbol table lock around this loop because emitNewFunctionExpressionCommon may GC.
2084         SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, name.impl());
2085         RELEASE_ASSERT(!entry.isNull());
2086         emitNewFunctionExpressionCommon(temp.get(), function);
2087         bool isLexicallyScoped = true;
2088         emitPutToScope(scope, variableForLocalEntry(name, entry, symbolTableIndex, isLexicallyScoped), temp.get(), DoNotThrowIfNotFound, InitializationMode::Initialization);
2089     }
2090 }
2091 
2092 void BytecodeGenerator::hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName)
2093 {
2094     if (m_scopeNode-&gt;hasSloppyModeHoistedFunction(functionName.impl())) {
2095         if (codeType() != EvalCode) {
2096             Variable currentFunctionVariable = variable(functionName);
2097             RefPtr&lt;RegisterID&gt; currentValue;
2098             if (RegisterID* local = currentFunctionVariable.local())
2099                 currentValue = local;
2100             else {
2101                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2102                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2103             }
2104 
2105             ASSERT(m_varScopeLexicalScopeStackIndex);
2106             ASSERT(*m_varScopeLexicalScopeStackIndex &lt; m_lexicalScopeStack.size());
2107             LexicalScopeStackEntry varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex];
2108             SymbolTable* varSymbolTable = varScope.m_symbolTable;
2109             ASSERT(varSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope);
2110             SymbolTableEntry entry = varSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2111             if (functionName == propertyNames().arguments &amp;&amp; entry.isNull()) {
2112                 // &quot;arguments&quot; might be put in the parameter scope when we have a non-simple
2113                 // parameter list since &quot;arguments&quot; is visible to expressions inside the
2114                 // parameter evaluation list.
2115                 // e.g:
2116                 // function foo(x = arguments) { { function arguments() { } } }
2117                 RELEASE_ASSERT(*m_varScopeLexicalScopeStackIndex &gt; 0);
2118                 varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex - 1];
2119                 SymbolTable* parameterSymbolTable = varScope.m_symbolTable;
2120                 entry = parameterSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2121             }
2122             RELEASE_ASSERT(!entry.isNull());
2123             bool isLexicallyScoped = false;
2124             emitPutToScope(varScope.m_scope, variableForLocalEntry(functionName, entry, varScope.m_symbolTableConstantIndex, isLexicallyScoped), currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2125         } else {
2126             Variable currentFunctionVariable = variable(functionName);
2127             RefPtr&lt;RegisterID&gt; currentValue;
2128             if (RegisterID* local = currentFunctionVariable.local())
2129                 currentValue = local;
2130             else {
2131                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2132                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2133             }
2134 
2135             RefPtr&lt;RegisterID&gt; scopeId = emitResolveScopeForHoistingFuncDeclInEval(nullptr, functionName);
2136             RefPtr&lt;RegisterID&gt; checkResult = emitIsUndefined(newTemporary(), scopeId.get());
2137 
2138             Ref&lt;Label&gt; isNotVarScopeLabel = newLabel();
2139             emitJumpIfTrue(checkResult.get(), isNotVarScopeLabel.get());
2140 
2141             // Put to outer scope
2142             emitPutToScope(scopeId.get(), functionName, currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2143             emitLabel(isNotVarScopeLabel.get());
2144 
2145         }
2146     }
2147 }
2148 
2149 RegisterID* BytecodeGenerator::emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp; property)
2150 {
2151     ASSERT(m_codeType == EvalCode);
2152 
2153     dst = finalDestination(dst);
2154     OpResolveScopeForHoistingFuncDeclInEval::emit(this, kill(dst), m_topMostScope, addConstant(property));
2155     return dst;
2156 }
2157 
2158 void BytecodeGenerator::popLexicalScope(VariableEnvironmentNode* node)
2159 {
2160     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2161     popLexicalScopeInternal(environment);
2162 }
2163 
2164 void BytecodeGenerator::popLexicalScopeInternal(VariableEnvironment&amp; environment)
2165 {
2166     // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
2167     // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
2168     if (!environment.size())
2169         return;
2170 
<a name="81" id="anc81"></a><span class="line-modified">2171     if (m_shouldEmitDebugHooks)</span>
2172         environment.markAllVariablesAsCaptured();
2173 
2174     auto stackEntry = m_lexicalScopeStack.takeLast();
2175     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2176     bool hasCapturedVariables = false;
2177     for (auto&amp; entry : environment) {
2178         if (entry.value.isCaptured()) {
2179             hasCapturedVariables = true;
2180             continue;
2181         }
2182         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2183         ASSERT(!symbolTableEntry.isNull());
2184         VarOffset offset = symbolTableEntry.varOffset();
2185         ASSERT(offset.isStack());
2186         RegisterID* local = &amp;registerFor(offset.stackOffset());
2187         local-&gt;deref();
2188     }
2189 
2190     if (hasCapturedVariables) {
2191         RELEASE_ASSERT(stackEntry.m_scope);
2192         emitPopScope(scopeRegister(), stackEntry.m_scope);
2193         popLocalControlFlowScope();
2194         stackEntry.m_scope-&gt;deref();
2195     }
2196 
2197     m_TDZStack.removeLast();
2198     m_cachedVariablesUnderTDZ = { };
2199 }
2200 
2201 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2202 {
2203     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2204     if (!environment.size())
2205         return;
<a name="82" id="anc82"></a><span class="line-modified">2206     if (m_shouldEmitDebugHooks)</span>
2207         environment.markAllVariablesAsCaptured();
2208     if (!environment.hasCapturedVariables())
2209         return;
2210 
2211     RELEASE_ASSERT(loopSymbolTable);
2212 
2213     // This function needs to do setup for a for loop&#39;s activation if any of
2214     // the for loop&#39;s lexically declared variables are captured (that is, variables
2215     // declared in the loop header, not the loop body). This function needs to
2216     // make a copy of the current activation and copy the values from the previous
2217     // activation into the new activation because each iteration of a for loop
2218     // gets a new activation.
2219 
2220     auto stackEntry = m_lexicalScopeStack.last();
2221     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2222     RegisterID* loopScope = stackEntry.m_scope;
2223     ASSERT(symbolTable-&gt;scopeSize());
2224     ASSERT(loopScope);
2225     Vector&lt;std::pair&lt;RegisterID*, Identifier&gt;&gt; activationValuesToCopyOver;
2226 
2227     {
2228         activationValuesToCopyOver.reserveInitialCapacity(symbolTable-&gt;scopeSize());
2229 
2230         for (auto end = symbolTable-&gt;end(NoLockingNecessary), ptr = symbolTable-&gt;begin(NoLockingNecessary); ptr != end; ++ptr) {
2231             if (!ptr-&gt;value.varOffset().isScope())
2232                 continue;
2233 
2234             RefPtr&lt;UniquedStringImpl&gt; ident = ptr-&gt;key;
2235             Identifier identifier = Identifier::fromUid(m_vm, ident.get());
2236 
2237             RegisterID* transitionValue = newBlockScopeVariable();
2238             transitionValue-&gt;ref();
2239             emitGetFromScope(transitionValue, loopScope, variableForLocalEntry(identifier, ptr-&gt;value, loopSymbolTable-&gt;index(), true), DoNotThrowIfNotFound);
2240             activationValuesToCopyOver.uncheckedAppend(std::make_pair(transitionValue, identifier));
2241         }
2242     }
2243 
2244     // We need this dynamic behavior of the executing code to ensure
2245     // each loop iteration has a new activation object. (It&#39;s pretty ugly).
2246     // Also, this new activation needs to be assigned to the same register
2247     // as the previous scope because the loop body is compiled under
2248     // the assumption that the scope&#39;s register index is constant even
2249     // though the value in that register will change on each loop iteration.
2250     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), loopScope);
2251     move(scopeRegister(), parentScope.get());
2252 
2253     OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
2254 
2255     move(scopeRegister(), loopScope);
2256 
2257     {
2258         for (auto pair : activationValuesToCopyOver) {
2259             const Identifier&amp; identifier = pair.second;
2260             SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
2261             RELEASE_ASSERT(!entry.isNull());
2262             RegisterID* transitionValue = pair.first;
2263             emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2264             transitionValue-&gt;deref();
2265         }
2266     }
2267 }
2268 
2269 Variable BytecodeGenerator::variable(const Identifier&amp; property, ThisResolutionType thisResolutionType)
2270 {
2271     if (property == propertyNames().thisIdentifier &amp;&amp; thisResolutionType == ThisResolutionType::Local)
2272         return Variable(property, VarOffset(thisRegister()-&gt;virtualRegister()), thisRegister(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly), Variable::SpecialVariable, 0, false);
2273 
2274     // We can optimize lookups if the lexical variable is found before a &quot;with&quot; or &quot;catch&quot;
2275     // scope because we&#39;re guaranteed static resolution. If we have to pass through
2276     // a &quot;with&quot; or &quot;catch&quot; scope we loose this guarantee.
2277     // We can&#39;t optimize cases like this:
2278     // {
2279     //     let x = ...;
2280     //     with (o) {
2281     //         doSomethingWith(x);
2282     //     }
2283     // }
2284     // Because we can&#39;t gaurantee static resolution on x.
2285     // But, in this case, we are guaranteed static resolution:
2286     // {
2287     //     let x = ...;
2288     //     with (o) {
2289     //         let x = ...;
2290     //         doSomethingWith(x);
2291     //     }
2292     // }
2293     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2294         auto&amp; stackEntry = m_lexicalScopeStack[i];
2295         if (stackEntry.m_isWithScope)
2296             return Variable(property);
2297         SymbolTable* symbolTable = stackEntry.m_symbolTable;
2298         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2299         if (symbolTableEntry.isNull())
2300             continue;
2301         bool resultIsCallee = false;
2302         if (symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2303             if (m_usesNonStrictEval) {
2304                 // We don&#39;t know if an eval has introduced a &quot;var&quot; named the same thing as the function name scope variable name.
2305                 // We resort to dynamic lookup to answer this question.
2306                 Variable result = Variable(property);
2307                 return result;
2308             }
2309             resultIsCallee = true;
2310         }
2311         Variable result = variableForLocalEntry(property, symbolTableEntry, stackEntry.m_symbolTableConstantIndex, symbolTable-&gt;scopeType() == SymbolTable::ScopeType::LexicalScope);
2312         if (resultIsCallee)
2313             result.setIsReadOnly();
2314         return result;
2315     }
2316 
2317     return Variable(property);
2318 }
2319 
2320 Variable BytecodeGenerator::variableForLocalEntry(
2321     const Identifier&amp; property, const SymbolTableEntry&amp; entry, int symbolTableConstantIndex, bool isLexicallyScoped)
2322 {
2323     VarOffset offset = entry.varOffset();
2324 
2325     RegisterID* local;
2326     if (offset.isStack())
2327         local = &amp;registerFor(offset.stackOffset());
2328     else
2329         local = nullptr;
2330 
2331     return Variable(property, offset, local, entry.getAttributes(), Variable::NormalVariable, symbolTableConstantIndex, isLexicallyScoped);
2332 }
2333 
2334 void BytecodeGenerator::createVariable(
2335     const Identifier&amp; property, VarKind varKind, SymbolTable* symbolTable, ExistingVariableMode existingVariableMode)
2336 {
2337     ASSERT(property != propertyNames().thisIdentifier);
2338     SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2339 
2340     if (!entry.isNull()) {
2341         if (existingVariableMode == IgnoreExisting)
2342             return;
2343 
2344         // Do some checks to ensure that the variable we&#39;re being asked to create is sufficiently
2345         // compatible with the one we have already created.
2346 
2347         VarOffset offset = entry.varOffset();
2348 
2349         // We can&#39;t change our minds about whether it&#39;s captured.
2350         if (offset.kind() != varKind) {
2351             dataLog(
2352                 &quot;Trying to add variable called &quot;, property, &quot; as &quot;, varKind,
2353                 &quot; but it was already added as &quot;, offset, &quot;.\n&quot;);
2354             RELEASE_ASSERT_NOT_REACHED();
2355         }
2356 
2357         return;
2358     }
2359 
2360     VarOffset varOffset;
2361     if (varKind == VarKind::Scope)
2362         varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
2363     else {
2364         ASSERT(varKind == VarKind::Stack);
2365         varOffset = VarOffset(virtualRegisterForLocal(m_calleeLocals.size()));
2366     }
2367     SymbolTableEntry newEntry(varOffset, 0);
2368     symbolTable-&gt;add(NoLockingNecessary, property.impl(), newEntry);
2369 
2370     if (varKind == VarKind::Stack) {
2371         RegisterID* local = addVar();
2372         RELEASE_ASSERT(local-&gt;index() == varOffset.stackOffset().offset());
2373     }
2374 }
2375 
2376 RegisterID* BytecodeGenerator::emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue)
2377 {
2378     OpOverridesHasInstance::emit(this, dst, constructor, hasInstanceValue);
2379     return dst;
2380 }
2381 
2382 // Indicates the least upper bound of resolve type based on local scope. The bytecode linker
2383 // will start with this ResolveType and compute the least upper bound including intercepting scopes.
2384 ResolveType BytecodeGenerator::resolveType()
2385 {
2386     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2387         if (m_lexicalScopeStack[i].m_isWithScope)
2388             return Dynamic;
2389         if (m_usesNonStrictEval &amp;&amp; m_lexicalScopeStack[i].m_symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2390             // We never want to assign to a FunctionNameScope. Returning Dynamic here achieves this goal.
2391             // If we aren&#39;t in non-strict eval mode, then NodesCodeGen needs to take care not to emit
2392             // a put_to_scope with the destination being the function name scope variable.
2393             return Dynamic;
2394         }
2395     }
2396 
2397     if (m_usesNonStrictEval)
2398         return GlobalPropertyWithVarInjectionChecks;
2399     return GlobalProperty;
2400 }
2401 
2402 RegisterID* BytecodeGenerator::emitResolveScope(RegisterID* dst, const Variable&amp; variable)
2403 {
2404     switch (variable.offset().kind()) {
2405     case VarKind::Stack:
2406         return nullptr;
2407 
2408     case VarKind::DirectArgument:
2409         return argumentsRegister();
2410 
2411     case VarKind::Scope: {
2412         // This always refers to the activation that *we* allocated, and not the current scope that code
2413         // lives in. Note that this will change once we have proper support for block scoping. Once that
2414         // changes, it will be correct for this code to return scopeRegister(). The only reason why we
2415         // don&#39;t do that already is that m_lexicalEnvironment is required by ConstDeclNode. ConstDeclNode
2416         // requires weird things because it is a shameful pile of nonsense, but block scoping would make
2417         // that code sensible and obviate the need for us to do bad things.
2418         for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2419             auto&amp; stackEntry = m_lexicalScopeStack[i];
2420             // We should not resolve a variable to VarKind::Scope if a &quot;with&quot; scope lies in between the current
2421             // scope and the resolved scope.
2422             RELEASE_ASSERT(!stackEntry.m_isWithScope);
2423 
2424             if (stackEntry.m_symbolTable-&gt;get(NoLockingNecessary, variable.ident().impl()).isNull())
2425                 continue;
2426 
2427             RegisterID* scope = stackEntry.m_scope;
2428             RELEASE_ASSERT(scope);
2429             return scope;
2430         }
2431 
2432         RELEASE_ASSERT_NOT_REACHED();
2433         return nullptr;
2434 
2435     }
2436     case VarKind::Invalid:
2437         // Indicates non-local resolution.
2438 
2439         dst = tempDestination(dst);
2440         OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());
2441         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2442         return dst;
2443     }
2444 
2445     RELEASE_ASSERT_NOT_REACHED();
2446     return nullptr;
2447 }
2448 
2449 RegisterID* BytecodeGenerator::emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp; variable, ResolveMode resolveMode)
2450 {
2451     switch (variable.offset().kind()) {
2452     case VarKind::Stack:
2453         return move(dst, variable.local());
2454 
2455     case VarKind::DirectArgument: {
2456         OpGetFromArguments::emit(this, kill(dst), scope, variable.offset().capturedArgumentsOffset().offset());
2457         return dst;
2458     }
2459 
2460     case VarKind::Scope:
2461     case VarKind::Invalid: {
2462         OpGetFromScope::emit(
2463             this,
2464             kill(dst),
2465             scope,
2466             addConstant(variable.ident()),
2467             GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
2468             localScopeDepth(),
2469             variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);
2470         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2471         return dst;
2472     } }
2473 
2474     RELEASE_ASSERT_NOT_REACHED();
2475 }
2476 
2477 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2478 {
2479     switch (variable.offset().kind()) {
2480     case VarKind::Stack:
2481         move(variable.local(), value);
2482         return value;
2483 
2484     case VarKind::DirectArgument:
2485         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2486         return value;
2487 
2488     case VarKind::Scope:
2489     case VarKind::Invalid: {
2490         GetPutInfo getPutInfo(0);
<a name="83" id="anc83"></a><span class="line-modified">2491         int scopeDepth;</span>
2492         ScopeOffset offset;
2493         if (variable.offset().isScope()) {
2494             offset = variable.offset().scopeOffset();
2495             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
<a name="84" id="anc84"></a><span class="line-modified">2496             scopeDepth = variable.symbolTableConstantIndex();</span>
2497         } else {
2498             ASSERT(resolveType() != LocalClosureVar);
2499             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
<a name="85" id="anc85"></a><span class="line-modified">2500             scopeDepth = localScopeDepth();</span>
2501         }
<a name="86" id="anc86"></a><span class="line-modified">2502         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, scopeDepth, !!offset ? offset.offset() : 0);</span>
2503         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2504         return value;
2505     } }
2506 
2507     RELEASE_ASSERT_NOT_REACHED();
2508 }
2509 
2510 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2511 {
2512     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2513     RegisterID* scope = emitResolveScope(nullptr, variable);
2514     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2515 }
2516 
2517 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2518 {
2519     OpInstanceof::emit(this, dst, value, basePrototype);
2520     return dst;
2521 }
2522 
2523 RegisterID* BytecodeGenerator::emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue)
2524 {
2525     OpInstanceofCustom::emit(this, dst, value, constructor, hasInstanceValue);
2526     return dst;
2527 }
2528 
2529 RegisterID* BytecodeGenerator::emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base)
2530 {
2531     OpInByVal::emit(this, dst, base, property);
2532     return dst;
2533 }
2534 
2535 RegisterID* BytecodeGenerator::emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2536 {
2537     OpInById::emit(this, dst, base, addConstant(property));
2538     return dst;
2539 }
2540 
2541 RegisterID* BytecodeGenerator::emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2542 {
2543     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties are not supported with tryGetById.&quot;);
2544 
2545     OpTryGetById::emit(this, kill(dst), base, addConstant(property));
2546     return dst;
2547 }
2548 
2549 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2550 {
2551     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2552 
2553     OpGetById::emit(this, kill(dst), base, addConstant(property));
2554     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2555     return dst;
2556 }
2557 
2558 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
2559 {
2560     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2561 
2562     OpGetByIdWithThis::emit(this, kill(dst), base, thisVal, addConstant(property));
2563     return dst;
2564 }
2565 
2566 RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2567 {
2568     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
2569 
2570     OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));
2571     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2572     return dst;
2573 }
2574 
2575 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
2576 {
2577     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2578 
2579     unsigned propertyIndex = addConstant(property);
2580 
2581     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2582 
2583     OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct
2584     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2585 
2586     return value;
2587 }
2588 
2589 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2590 {
2591     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2592 
2593     unsigned propertyIndex = addConstant(property);
2594 
2595     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2596 
2597     return value;
2598 }
2599 
2600 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2601 {
2602     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2603 
2604     unsigned propertyIndex = addConstant(property);
2605 
2606     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2607 
<a name="87" id="anc87"></a><span class="line-modified">2608     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm-&gt;propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;</span>
2609     OpPutById::emit(this, base, propertyIndex, value, type);
2610     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2611     return value;
2612 }
2613 
2614 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2615 {
2616     unsigned propertyIndex = addConstant(property);
2617     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2618 
2619     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2620 }
2621 
2622 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2623 {
2624     unsigned propertyIndex = addConstant(property);
2625     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2626 
2627     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2628 }
2629 
2630 void BytecodeGenerator::emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter)
2631 {
2632     unsigned propertyIndex = addConstant(property);
2633 
2634     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2635 
2636     OpPutGetterSetterById::emit(this, base, propertyIndex, attributes, getter, setter);
2637 }
2638 
2639 void BytecodeGenerator::emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* getter)
2640 {
2641     OpPutGetterByVal::emit(this, base, property, attributes, getter);
2642 }
2643 
2644 void BytecodeGenerator::emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* setter)
2645 {
2646     OpPutSetterByVal::emit(this, base, property, attributes, setter);
2647 }
2648 
2649 void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
2650 {
2651     // FIXME: Currently, we just create an object and store generator related fields as its properties for ease.
2652     // But to make it efficient, we will introduce JSGenerator class, add opcode new_generator and use its C++ fields instead of these private properties.
2653     // https://bugs.webkit.org/show_bug.cgi?id=151545
2654 
2655     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);
2656 
2657     // We do not store &#39;this&#39; in arrow function within constructor,
2658     // because it might be not initialized, if super is called later.
2659     if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
2660         emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);
2661 
2662     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(0)), PropertyNode::KnownDirect);
2663 
2664     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2665 }
2666 
2667 void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
2668 {
2669     ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
2670 
2671     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);
2672 
2673     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);
2674 
2675     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorState::SuspendedStart))), PropertyNode::KnownDirect);
2676 
2677     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2678 
2679     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::None))), PropertyNode::KnownDirect);
2680 
2681     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2682     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2683 }
2684 
2685 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2686 {
2687     OpDelById::emit(this, dst, base, addConstant(property));
2688     return dst;
2689 }
2690 
2691 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2692 {
2693     for (size_t i = m_forInContextStack.size(); i--; ) {
2694         ForInContext&amp; context = m_forInContextStack[i].get();
2695         if (context.local() != property)
2696             continue;
2697 
2698         if (context.isIndexedForInContext()) {
2699             auto&amp; indexedContext = context.asIndexedForInContext();
<a name="88" id="anc88"></a><span class="line-modified">2700             OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, indexedContext.index());</span>






2701             indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2702             return dst;
2703         }
2704 
<a name="89" id="anc89"></a>
2705         StructureForInContext&amp; structureContext = context.asStructureForInContext();
<a name="90" id="anc90"></a><span class="line-modified">2706         OpGetDirectPname::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());</span>
2707 
2708         structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2709         return dst;
2710     }
2711 
2712     OpGetByVal::emit(this, kill(dst), base, property);
2713     return dst;
2714 }
2715 
2716 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property)
2717 {
2718     OpGetByValWithThis::emit(this, kill(dst), base, thisValue, property);
2719     return dst;
2720 }
2721 
2722 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2723 {
2724     OpPutByVal::emit(this, base, property, value);
2725     return value;
2726 }
2727 
2728 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value)
2729 {
2730     OpPutByValWithThis::emit(this, base, thisValue, property, value);
2731     return value;
2732 }
2733 
2734 RegisterID* BytecodeGenerator::emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2735 {
2736     OpPutByValDirect::emit(this, base, property, value);
2737     return value;
2738 }
2739 
2740 RegisterID* BytecodeGenerator::emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2741 {
2742     OpDelByVal::emit(this, dst, base, property);
2743     return dst;
2744 }
2745 
2746 void BytecodeGenerator::emitSuperSamplerBegin()
2747 {
2748     OpSuperSamplerBegin::emit(this);
2749 }
2750 
2751 void BytecodeGenerator::emitSuperSamplerEnd()
2752 {
2753     OpSuperSamplerEnd::emit(this);
2754 }
2755 
2756 RegisterID* BytecodeGenerator::emitIdWithProfile(RegisterID* src, SpeculatedType profile)
2757 {
2758     OpIdentityWithProfile::emit(this, src, static_cast&lt;uint32_t&gt;(profile &gt;&gt; 32), static_cast&lt;uint32_t&gt;(profile));
2759     return src;
2760 }
2761 
2762 void BytecodeGenerator::emitUnreachable()
2763 {
2764     OpUnreachable::emit(this);
2765 }
2766 
2767 RegisterID* BytecodeGenerator::emitGetArgument(RegisterID* dst, int32_t index)
2768 {
2769     OpGetArgument::emit(this, dst, index + 1 /* Including |this| */);
2770     return dst;
2771 }
2772 
2773 RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
2774 {
2775     OpCreateThis::emit(this, dst, dst, 0);
2776     m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
2777 
2778     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2779     return dst;
2780 }
2781 
2782 void BytecodeGenerator::emitTDZCheck(RegisterID* target)
2783 {
2784     OpCheckTdz::emit(this, target);
2785 }
2786 
2787 bool BytecodeGenerator::needsTDZCheck(const Variable&amp; variable)
2788 {
2789     for (unsigned i = m_TDZStack.size(); i--;) {
2790         auto iter = m_TDZStack[i].find(variable.ident().impl());
2791         if (iter == m_TDZStack[i].end())
2792             continue;
2793         return iter-&gt;value != TDZNecessityLevel::NotNeeded;
2794     }
2795 
2796     return false;
2797 }
2798 
2799 void BytecodeGenerator::emitTDZCheckIfNecessary(const Variable&amp; variable, RegisterID* target, RegisterID* scope)
2800 {
2801     if (needsTDZCheck(variable)) {
2802         if (target)
2803             emitTDZCheck(target);
2804         else {
2805             RELEASE_ASSERT(!variable.isLocal() &amp;&amp; scope);
2806             RefPtr&lt;RegisterID&gt; result = emitGetFromScope(newTemporary(), scope, variable, DoNotThrowIfNotFound);
2807             emitTDZCheck(result.get());
2808         }
2809     }
2810 }
2811 
2812 void BytecodeGenerator::liftTDZCheckIfPossible(const Variable&amp; variable)
2813 {
2814     RefPtr&lt;UniquedStringImpl&gt; identifier(variable.ident().impl());
2815     for (unsigned i = m_TDZStack.size(); i--;) {
2816         auto iter = m_TDZStack[i].find(identifier);
2817         if (iter != m_TDZStack[i].end()) {
2818             if (iter-&gt;value == TDZNecessityLevel::Optimize) {
2819                 m_cachedVariablesUnderTDZ = { };
2820                 iter-&gt;value = TDZNecessityLevel::NotNeeded;
2821             }
2822             break;
2823         }
2824     }
2825 }
2826 
2827 void BytecodeGenerator::pushTDZVariables(const VariableEnvironment&amp; environment, TDZCheckOptimization optimization, TDZRequirement requirement)
2828 {
2829     if (!environment.size())
2830         return;
2831 
2832     TDZNecessityLevel level;
2833     if (requirement == TDZRequirement::UnderTDZ) {
2834         if (optimization == TDZCheckOptimization::Optimize)
2835             level = TDZNecessityLevel::Optimize;
2836         else
2837             level = TDZNecessityLevel::DoNotOptimize;
2838     } else
2839         level = TDZNecessityLevel::NotNeeded;
2840 
2841     TDZMap map;
2842     for (const auto&amp; entry : environment)
2843         map.add(entry.key, entry.value.isFunction() ? TDZNecessityLevel::NotNeeded : level);
2844 
2845     m_TDZStack.append(WTFMove(map));
2846     m_cachedVariablesUnderTDZ = { };
2847 }
2848 
<a name="91" id="anc91"></a><span class="line-modified">2849 CompactVariableMap::Handle BytecodeGenerator::getVariablesUnderTDZ()</span>
2850 {
<a name="92" id="anc92"></a><span class="line-modified">2851     if (m_cachedVariablesUnderTDZ)</span>




2852         return m_cachedVariablesUnderTDZ;
<a name="93" id="anc93"></a>
2853 
2854     // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
2855     // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
2856     //
2857     //     {
2858     //         {
2859     //             let x;
2860     //             ...
2861     //         }
2862     //         let x;
2863     //     }
2864     SmallPtrSet&lt;UniquedStringImpl*, 16&gt; variablesThatDontNeedTDZ;
2865     VariableEnvironment environment;
2866     for (unsigned i = m_TDZStack.size(); i--; ) {
2867         auto&amp; map = m_TDZStack[i];
2868         for (auto&amp; entry : map)  {
2869             if (entry.value != TDZNecessityLevel::NotNeeded) {
2870                 if (!variablesThatDontNeedTDZ.contains(entry.key.get()))
2871                     environment.add(entry.key.get());
2872             } else
2873                 variablesThatDontNeedTDZ.add(entry.key.get());
2874         }
2875     }
2876 
<a name="94" id="anc94"></a><span class="line-modified">2877     m_cachedVariablesUnderTDZ = m_vm-&gt;m_compactVariableMap-&gt;get(environment);</span>




2878     return m_cachedVariablesUnderTDZ;
2879 }
2880 
2881 void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2882 {
2883     preservedStack.m_preservedTDZStack = m_TDZStack;
2884 }
2885 
2886 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2887 {
2888     m_TDZStack = preservedStack.m_preservedTDZStack;
2889     m_cachedVariablesUnderTDZ = { };
2890 }
2891 
2892 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2893 {
2894     OpNewObject::emit(this, dst, 0);
2895     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2896 
2897     return dst;
2898 }
2899 
2900 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2901 {
2902     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
<a name="95" id="anc95"></a><span class="line-modified">2903         auto scope = DECLARE_CATCH_SCOPE(*vm());</span>
2904         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
<a name="96" id="anc96"></a><span class="line-modified">2905         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, *vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);</span>
2906         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
2907         // https://bugs.webkit.org/show_bug.cgi?id=180139
2908         scope.assertNoException();
2909         RELEASE_ASSERT(bigIntInMap);
2910         addConstantValue(bigIntInMap);
2911 
2912         return bigIntInMap;
2913     }).iterator-&gt;value;
2914 }
2915 
2916 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2917 {
2918     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2919     if (!stringInMap) {
2920         stringInMap = jsString(vm(), identifier.string());
2921         addConstantValue(stringInMap);
2922     }
2923     return stringInMap;
2924 }
2925 
<a name="97" id="anc97"></a><span class="line-modified">2926 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor)</span>
2927 {
<a name="98" id="anc98"></a><span class="line-modified">2928     JSTemplateObjectDescriptor* descriptorValue = m_templateObjectDescriptorMap.ensure(descriptor.copyRef(), [&amp;] {</span>
<span class="line-modified">2929         return JSTemplateObjectDescriptor::create(*vm(), WTFMove(descriptor));</span>

2930     }).iterator-&gt;value;
<a name="99" id="anc99"></a><span class="line-removed">2931 </span>
2932     int index = addConstantIndex();
2933     m_codeBlock-&gt;addConstant(descriptorValue);
2934     return &amp;m_constantPoolRegisters[index];
2935 }
2936 
2937 RegisterID* BytecodeGenerator::emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly* array, IndexingType recommendedIndexingType)
2938 {
2939     OpNewArrayBuffer::emit(this, dst, addConstantValue(array), recommendedIndexingType);
2940     return dst;
2941 }
2942 
2943 RegisterID* BytecodeGenerator::emitNewArray(RegisterID* dst, ElementNode* elements, unsigned length, IndexingType recommendedIndexingType)
2944 {
2945     Vector&lt;RefPtr&lt;RegisterID&gt;, 16, UnsafeVectorOverflow&gt; argv;
2946     for (ElementNode* n = elements; n; n = n-&gt;next()) {
2947         if (!length)
2948             break;
2949         length--;
2950         ASSERT(!n-&gt;value()-&gt;isSpreadExpression());
2951         argv.append(newTemporary());
2952         // op_new_array requires the initial values to be a sequential range of registers
2953         ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
2954         emitNode(argv.last().get(), n-&gt;value());
2955     }
2956     ASSERT(!length);
2957     OpNewArray::emit(this, dst, argv.size() ? argv[0].get() : VirtualRegister { 0 }, argv.size(), recommendedIndexingType);
2958     return dst;
2959 }
2960 
2961 RegisterID* BytecodeGenerator::emitNewArrayWithSpread(RegisterID* dst, ElementNode* elements)
2962 {
2963     BitVector bitVector;
2964     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; argv;
2965     for (ElementNode* node = elements; node; node = node-&gt;next()) {
2966         bitVector.set(argv.size(), node-&gt;value()-&gt;isSpreadExpression());
2967 
2968         argv.append(newTemporary());
2969         // op_new_array_with_spread requires the initial values to be a sequential range of registers.
2970         RELEASE_ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
2971     }
2972 
2973     RELEASE_ASSERT(argv.size());
2974 
2975     {
2976         unsigned i = 0;
2977         for (ElementNode* node = elements; node; node = node-&gt;next()) {
2978             if (node-&gt;value()-&gt;isSpreadExpression()) {
2979                 ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(node-&gt;value())-&gt;expression();
2980                 RefPtr&lt;RegisterID&gt; tmp = newTemporary();
2981                 emitNode(tmp.get(), expression);
2982 
2983                 OpSpread::emit(this, argv[i].get(), tmp.get());
2984             } else {
2985                 ExpressionNode* expression = node-&gt;value();
2986                 emitNode(argv[i].get(), expression);
2987             }
2988             i++;
2989         }
2990     }
2991 
2992     unsigned bitVectorIndex = m_codeBlock-&gt;addBitVector(WTFMove(bitVector));
2993     OpNewArrayWithSpread::emit(this, dst, argv[0].get(), argv.size(), bitVectorIndex);
2994     return dst;
2995 }
2996 
2997 RegisterID* BytecodeGenerator::emitNewArrayWithSize(RegisterID* dst, RegisterID* length)
2998 {
2999     OpNewArrayWithSize::emit(this, dst, length);
3000     return dst;
3001 }
3002 
3003 RegisterID* BytecodeGenerator::emitNewRegExp(RegisterID* dst, RegExp* regExp)
3004 {
3005     OpNewRegexp::emit(this, dst, addConstantValue(regExp));
3006     return dst;
3007 }
3008 
3009 void BytecodeGenerator::emitNewFunctionExpressionCommon(RegisterID* dst, FunctionMetadataNode* function)
3010 {
3011     unsigned index = m_codeBlock-&gt;addFunctionExpr(makeFunction(function));
3012 
3013     switch (function-&gt;parseMode()) {
3014     case SourceParseMode::GeneratorWrapperFunctionMode:
3015     case SourceParseMode::GeneratorWrapperMethodMode:
3016         OpNewGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
3017         break;
3018     case SourceParseMode::AsyncFunctionMode:
3019     case SourceParseMode::AsyncMethodMode:
3020     case SourceParseMode::AsyncArrowFunctionMode:
3021         OpNewAsyncFuncExp::emit(this, dst, scopeRegister(), index);
3022         break;
3023     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
3024     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3025         OpNewAsyncGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
3026         break;
3027     default:
3028         OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3029         break;
3030     }
3031 }
3032 
3033 RegisterID* BytecodeGenerator::emitNewFunctionExpression(RegisterID* dst, FuncExprNode* func)
3034 {
3035     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3036     return dst;
3037 }
3038 
3039 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3040 {
3041     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3042     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3043     return dst;
3044 }
3045 
3046 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3047 {
3048     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3049     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3050     return dst;
3051 }
3052 
3053 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
3054     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
3055 {
<a name="100" id="anc100"></a><span class="line-modified">3056     UnlinkedFunctionExecutable* executable = m_vm-&gt;builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
3057     executable-&gt;setInvalidTypeProfilingOffsets();
3058     executable-&gt;setEcmaName(ecmaName);
3059     executable-&gt;setClassSource(classSource);
3060 
3061     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3062 
3063     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3064     return dst;
3065 }
3066 
3067 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3068 {
3069     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3070     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3071         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3072     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3073         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3074     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3075         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3076     else
3077         OpNewFunc::emit(this, dst, scopeRegister(), index);
3078     return dst;
3079 }
3080 
3081 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)
3082 {
3083     if (valueNode-&gt;isBaseFuncExprNode()) {
3084         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3085         if (!metadata-&gt;ecmaName().isNull())
3086             return;
3087     } else if (valueNode-&gt;isClassExprNode()) {
3088         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3089         if (!classExprNode-&gt;ecmaName().isNull())
3090             return;
<a name="101" id="anc101"></a><span class="line-modified">3091         if (classExprNode-&gt;hasStaticProperty(m_vm-&gt;propertyNames-&gt;name))</span>
3092             return;
3093     } else
3094         return;
3095 
3096     // FIXME: We should use an op_call to an internal function here instead.
3097     // https://bugs.webkit.org/show_bug.cgi?id=155547
3098     OpSetFunctionName::emit(this, value, name);
3099 }
3100 
3101 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3102 {
3103     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3104 }
3105 
3106 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3107 {
3108     if (m_inTailPosition) {
3109         m_codeBlock-&gt;setHasTailCalls();
3110         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3111     }
3112     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3113 }
3114 
3115 RegisterID* BytecodeGenerator::emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3116 {
3117     return emitCall&lt;OpCallEval&gt;(dst, func, NoExpectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3118 }
3119 
3120 ExpectedFunction BytecodeGenerator::expectedFunctionForIdentifier(const Identifier&amp; identifier)
3121 {
3122     if (identifier == propertyNames().Object || identifier == propertyNames().builtinNames().ObjectPrivateName())
3123         return ExpectObjectConstructor;
3124     if (identifier == propertyNames().Array || identifier == propertyNames().builtinNames().ArrayPrivateName())
3125         return ExpectArrayConstructor;
3126     return NoExpectedFunction;
3127 }
3128 
3129 ExpectedFunction BytecodeGenerator::emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, Label&amp; done)
3130 {
3131     Ref&lt;Label&gt; realCall = newLabel();
3132     switch (expectedFunction) {
3133     case ExpectObjectConstructor: {
3134         // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
3135         if (callArguments.argumentCountIncludingThis() &gt;= 2)
3136             return NoExpectedFunction;
3137 
3138         OpJneqPtr::emit(this, func, Special::ObjectConstructor, realCall-&gt;bind(this));
3139 
3140         if (dst != ignoredResult())
3141             emitNewObject(dst);
3142         break;
3143     }
3144 
3145     case ExpectArrayConstructor: {
3146         // If you&#39;re doing anything other than &quot;new Array()&quot; or &quot;new Array(foo)&quot; then we
3147         // don&#39;t do inline it, for now. The only reason is that call arguments are in
3148         // the opposite order of what op_new_array expects, so we&#39;d either need to change
3149         // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
3150         // things sounds like it&#39;s worth it.
3151         if (callArguments.argumentCountIncludingThis() &gt; 2)
3152             return NoExpectedFunction;
3153 
3154         OpJneqPtr::emit(this, func, Special::ArrayConstructor, realCall-&gt;bind(this));
3155 
3156         if (dst != ignoredResult()) {
3157             if (callArguments.argumentCountIncludingThis() == 2)
3158                 emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
3159             else {
3160                 ASSERT(callArguments.argumentCountIncludingThis() == 1);
3161                 OpNewArray::emit(this, dst, VirtualRegister { 0 }, 0, ArrayWithUndecided);
3162             }
3163         }
3164         break;
3165     }
3166 
3167     default:
3168         ASSERT(expectedFunction == NoExpectedFunction);
3169         return NoExpectedFunction;
3170     }
3171 
3172     OpJmp::emit(this, done.bind(this));
3173     emitLabel(realCall.get());
3174 
3175     return expectedFunction;
3176 }
3177 
3178 template&lt;typename CallOp&gt;
3179 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3180 {
3181     constexpr auto opcodeID = CallOp::opcodeID;
3182     ASSERT(opcodeID == op_call || opcodeID == op_call_eval || opcodeID == op_tail_call);
3183     ASSERT(func-&gt;refCount());
3184 
3185     // Generate code for arguments.
3186     unsigned argument = 0;
3187     if (callArguments.argumentsNode()) {
3188         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3189         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3190             RELEASE_ASSERT(!n-&gt;m_next);
3191             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3192             if (expression-&gt;isArrayLiteral()) {
3193                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3194                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3195                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3196                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3197                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3198 
3199                     return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3200                 }
3201             }
3202             RefPtr&lt;RegisterID&gt; argumentRegister;
3203             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3204             RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3205             return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3206         }
3207         for (; n; n = n-&gt;m_next)
3208             emitNode(callArguments.argumentRegister(argument++), n);
3209     }
3210 
3211     // Reserve space for call frame.
3212     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3213     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3214         callFrame.append(newTemporary());
3215 
<a name="102" id="anc102"></a><span class="line-modified">3216     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3217         emitDebugHook(WillExecuteExpression, divotStart);
3218 
3219     emitExpressionInfo(divot, divotStart, divotEnd);
3220 
3221     Ref&lt;Label&gt; done = newLabel();
3222     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3223 
3224     if (opcodeID == op_tail_call)
3225         emitLogShadowChickenTailIfNecessary();
3226 
3227     // Emit call.
3228     ASSERT(dst);
3229     ASSERT(dst != ignoredResult());
3230     CallOp::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3231 
3232     if (expectedFunction != NoExpectedFunction)
3233         emitLabel(done.get());
3234 
3235     return dst;
3236 }
3237 
3238 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3239 {
3240     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3241 }
3242 
3243 RegisterID* BytecodeGenerator::emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3244 {
3245     if (m_inTailPosition)
3246         return emitCallVarargs&lt;OpTailCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3247     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3248 }
3249 
3250 RegisterID* BytecodeGenerator::emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3251 {
3252     return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3253 }
3254 
3255 RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3256 {
<a name="103" id="anc103"></a><span class="line-modified">3257     ASSERT(m_inTailPosition);</span>

3258     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3259 }
3260 
3261 template&lt;typename VarargsOp&gt;
3262 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3263 {
<a name="104" id="anc104"></a><span class="line-modified">3264     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3265         emitDebugHook(WillExecuteExpression, divotStart);
3266 
3267     emitExpressionInfo(divot, divotStart, divotEnd);
3268 
3269     if (VarargsOp::opcodeID == op_tail_call_varargs)
3270         emitLogShadowChickenTailIfNecessary();
3271 
3272     // Emit call.
3273     ASSERT(dst != ignoredResult());
3274     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
3275     return dst;
3276 }
3277 
3278 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3279 {
<a name="105" id="anc105"></a><span class="line-modified">3280     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3281         return;
3282     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3283 }
3284 
3285 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3286 {
<a name="106" id="anc106"></a><span class="line-modified">3287     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3288         return;
3289     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3290 }
3291 
3292 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3293     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3294 {
3295     DefinePropertyAttributes attributes;
3296     if (options &amp; PropertyConfigurable)
3297         attributes.setConfigurable(true);
3298 
3299     if (options &amp; PropertyWritable)
3300         attributes.setWritable(true);
3301     else if (valueRegister)
3302         attributes.setWritable(false);
3303 
3304     if (options &amp; PropertyEnumerable)
3305         attributes.setEnumerable(true);
3306 
3307     if (valueRegister)
3308         attributes.setValue();
3309     if (getterRegister)
3310         attributes.setGet();
3311     if (setterRegister)
3312         attributes.setSet();
3313 
3314     ASSERT(!valueRegister || (!getterRegister &amp;&amp; !setterRegister));
3315 
3316     emitExpressionInfo(position, position, position);
3317 
3318     if (attributes.hasGet() || attributes.hasSet()) {
3319         RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
3320         if (!attributes.hasGet() || !attributes.hasSet())
3321             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::ThrowTypeErrorFunction);
3322 
3323         RefPtr&lt;RegisterID&gt; getter;
3324         if (attributes.hasGet())
3325             getter = getterRegister;
3326         else
3327             getter = throwTypeErrorFunction;
3328 
3329         RefPtr&lt;RegisterID&gt; setter;
3330         if (attributes.hasSet())
3331             setter = setterRegister;
3332         else
3333             setter = throwTypeErrorFunction;
3334 
3335         OpDefineAccessorProperty::emit(this, newObj, propertyNameRegister, getter.get(), setter.get(), emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3336     } else {
3337         OpDefineDataProperty::emit(this, newObj, propertyNameRegister, valueRegister, emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3338     }
3339 }
3340 
3341 RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
3342 {
3343     if (isConstructor()) {
3344         bool isDerived = constructorKind() == ConstructorKind::Extends;
3345         bool srcIsThis = src-&gt;index() == m_thisRegister.index();
3346 
3347         if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
3348             emitTDZCheck(src);
3349 
3350         if (!srcIsThis || from == ReturnFrom::Finally) {
3351             Ref&lt;Label&gt; isObjectLabel = newLabel();
3352             emitJumpIfTrue(emitIsObject(newTemporary(), src), isObjectLabel.get());
3353 
3354             if (isDerived) {
3355                 Ref&lt;Label&gt; isUndefinedLabel = newLabel();
3356                 emitJumpIfTrue(emitIsUndefined(newTemporary(), src), isUndefinedLabel.get());
3357                 emitThrowTypeError(&quot;Cannot return a non-object type in the constructor of a derived class.&quot;);
3358                 emitLabel(isUndefinedLabel.get());
3359                 emitTDZCheck(&amp;m_thisRegister);
3360             }
3361             OpRet::emit(this, &amp;m_thisRegister);
3362             emitLabel(isObjectLabel.get());
3363         }
3364     }
3365 
3366     OpRet::emit(this, src);
3367     return src;
3368 }
3369 
3370 RegisterID* BytecodeGenerator::emitEnd(RegisterID* src)
3371 {
3372     OpEnd::emit(this, src);
3373     return src;
3374 }
3375 
3376 
3377 RegisterID* BytecodeGenerator::emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
3378 {
3379     ASSERT(func-&gt;refCount());
3380 
3381     // Generate code for arguments.
3382     unsigned argument = 0;
3383     if (ArgumentsNode* argumentsNode = callArguments.argumentsNode()) {
3384 
3385         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3386         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3387             RELEASE_ASSERT(!n-&gt;m_next);
3388             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3389             if (expression-&gt;isArrayLiteral()) {
3390                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3391                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3392                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3393                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3394                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3395 
3396                     move(callArguments.thisRegister(), lazyThis);
3397                     RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3398                     return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3399                 }
3400             }
3401             RefPtr&lt;RegisterID&gt; argumentRegister;
3402             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3403             move(callArguments.thisRegister(), lazyThis);
3404             return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3405         }
3406 
3407         for (ArgumentListNode* n = argumentsNode-&gt;m_listNode; n; n = n-&gt;m_next)
3408             emitNode(callArguments.argumentRegister(argument++), n);
3409     }
3410 
3411     move(callArguments.thisRegister(), lazyThis);
3412 
3413     // Reserve space for call frame.
3414     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3415     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3416         callFrame.append(newTemporary());
3417 
3418     emitExpressionInfo(divot, divotStart, divotEnd);
3419 
3420     Ref&lt;Label&gt; done = newLabel();
3421     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3422 
3423     OpConstruct::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3424 
3425     if (expectedFunction != NoExpectedFunction)
3426         emitLabel(done.get());
3427 
3428     return dst;
3429 }
3430 
3431 RegisterID* BytecodeGenerator::emitStrcat(RegisterID* dst, RegisterID* src, int count)
3432 {
3433     OpStrcat::emit(this, dst, src, count);
3434     return dst;
3435 }
3436 
3437 void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
3438 {
3439     OpToPrimitive::emit(this, dst, src);
3440 }
3441 
3442 void BytecodeGenerator::emitGetScope()
3443 {
3444     OpGetScope::emit(this, scopeRegister());
3445 }
3446 
3447 RegisterID* BytecodeGenerator::emitPushWithScope(RegisterID* objectScope)
3448 {
3449     pushLocalControlFlowScope();
3450     RegisterID* newScope = newBlockScopeVariable();
3451     newScope-&gt;ref();
3452 
3453     OpPushWithScope::emit(this, newScope, scopeRegister(), objectScope);
3454 
3455     move(scopeRegister(), newScope);
3456     m_lexicalScopeStack.append({ nullptr, newScope, true, 0 });
3457 
3458     return newScope;
3459 }
3460 
3461 RegisterID* BytecodeGenerator::emitGetParentScope(RegisterID* dst, RegisterID* scope)
3462 {
3463     OpGetParentScope::emit(this, dst, scope);
3464     return dst;
3465 }
3466 
3467 void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)
3468 {
3469     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);
3470     move(dst, parentScope.get());
3471 }
3472 
3473 void BytecodeGenerator::emitPopWithScope()
3474 {
3475     emitPopScope(scopeRegister(), scopeRegister());
3476     popLocalControlFlowScope();
3477     auto stackEntry = m_lexicalScopeStack.takeLast();
3478     stackEntry.m_scope-&gt;deref();
3479     RELEASE_ASSERT(stackEntry.m_isWithScope);
3480 }
3481 
3482 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3483 {
<a name="107" id="anc107"></a><span class="line-modified">3484     if (!m_shouldEmitDebugHooks)</span>
3485         return;
3486 
3487     emitExpressionInfo(divot, divot, divot);
3488     OpDebug::emit(this, debugHookType, false);
3489 }
3490 
3491 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3492 {
3493     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3494 }
3495 
3496 void BytecodeGenerator::emitDebugHook(StatementNode* statement)
3497 {
3498     // DebuggerStatementNode will output its own special debug hook.
3499     if (statement-&gt;isDebuggerStatement())
3500         return;
3501 
3502     emitDebugHook(WillExecuteStatement, statement-&gt;position());
3503 }
3504 
3505 void BytecodeGenerator::emitDebugHook(ExpressionNode* expr)
3506 {
3507     emitDebugHook(WillExecuteStatement, expr-&gt;position());
3508 }
3509 
3510 void BytecodeGenerator::emitWillLeaveCallFrameDebugHook()
3511 {
3512     RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
3513     emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
3514 }
3515 
<a name="108" id="anc108"></a><span class="line-modified">3516 FinallyContext* BytecodeGenerator::pushFinallyControlFlowScope(Label&amp; finallyLabel)</span>
3517 {
<a name="109" id="anc109"></a><span class="line-modified">3518     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), FinallyContext(m_currentFinallyContext, finallyLabel));</span>
3519     m_controlFlowScopeStack.append(WTFMove(scope));
3520 
3521     m_finallyDepth++;
<a name="110" id="anc110"></a><span class="line-modified">3522     m_currentFinallyContext = &amp;m_controlFlowScopeStack.last().finallyContext;</span>
<span class="line-removed">3523     return m_currentFinallyContext;</span>
3524 }
3525 
<a name="111" id="anc111"></a><span class="line-modified">3526 FinallyContext BytecodeGenerator::popFinallyControlFlowScope()</span>
3527 {
3528     ASSERT(m_controlFlowScopeStack.size());
3529     ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
3530     ASSERT(m_finallyDepth &gt; 0);
3531     ASSERT(m_currentFinallyContext);
3532     m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
3533     m_finallyDepth--;
<a name="112" id="anc112"></a><span class="line-modified">3534     return m_controlFlowScopeStack.takeLast().finallyContext;</span>
3535 }
3536 
3537 LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
3538 {
3539     shrinkToFit(m_labelScopes);
3540 
3541     if (!m_labelScopes.size())
3542         return nullptr;
3543 
3544     // We special-case the following, which is a syntax error in Firefox:
3545     // label:
3546     //     break;
3547     if (name.isEmpty()) {
3548         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3549             LabelScope&amp; scope = m_labelScopes[i];
3550             if (scope.type() != LabelScope::NamedLabel)
3551                 return &amp;scope;
3552         }
3553         return nullptr;
3554     }
3555 
3556     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3557         LabelScope&amp; scope = m_labelScopes[i];
3558         if (scope.name() &amp;&amp; *scope.name() == name)
3559             return &amp;scope;
3560     }
3561     return nullptr;
3562 }
3563 
3564 LabelScope* BytecodeGenerator::continueTarget(const Identifier&amp; name)
3565 {
3566     shrinkToFit(m_labelScopes);
3567 
3568     if (!m_labelScopes.size())
3569         return nullptr;
3570 
3571     if (name.isEmpty()) {
3572         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3573             LabelScope&amp; scope = m_labelScopes[i];
3574             if (scope.type() == LabelScope::Loop) {
3575                 ASSERT(scope.continueTarget());
3576                 return &amp;scope;
3577             }
3578         }
3579         return nullptr;
3580     }
3581 
3582     // Continue to the loop nested nearest to the label scope that matches
3583     // &#39;name&#39;.
3584     LabelScope* result = nullptr;
3585     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3586         LabelScope&amp; scope = m_labelScopes[i];
3587         if (scope.type() == LabelScope::Loop) {
3588             ASSERT(scope.continueTarget());
3589             result = &amp;scope;
3590         }
3591         if (scope.name() &amp;&amp; *scope.name() == name)
3592             return result; // may be null.
3593     }
3594     return nullptr;
3595 }
3596 
3597 void BytecodeGenerator::allocateCalleeSaveSpace()
3598 {
3599     size_t virtualRegisterCountForCalleeSaves = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters();
3600 
3601     for (size_t i = 0; i &lt; virtualRegisterCountForCalleeSaves; i++) {
3602         RegisterID* localRegister = addVar();
3603         localRegister-&gt;ref();
3604         m_localRegistersForCalleeSaveRegisters.append(localRegister);
3605     }
3606 }
3607 
3608 void BytecodeGenerator::allocateAndEmitScope()
3609 {
3610     m_scopeRegister = addVar();
3611     m_scopeRegister-&gt;ref();
3612     m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
3613     emitGetScope();
3614     m_topMostScope = addVar();
3615     move(m_topMostScope, scopeRegister());
3616 }
3617 
3618 TryData* BytecodeGenerator::pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType handlerType)
3619 {
3620     m_tryData.append(TryData { handlerLabel, handlerType });
3621     TryData* result = &amp;m_tryData.last();
3622 
3623     m_tryContextStack.append(TryContext {
3624         start,
3625         result
3626     });
3627 
3628     return result;
3629 }
3630 
3631 void BytecodeGenerator::popTry(TryData* tryData, Label&amp; end)
3632 {
3633     m_usesExceptions = true;
3634 
3635     ASSERT_UNUSED(tryData, m_tryContextStack.last().tryData == tryData);
3636 
3637     m_tryRanges.append(TryRange {
3638         m_tryContextStack.last().start.copyRef(),
3639         end,
3640         m_tryContextStack.last().tryData
3641     });
3642     m_tryContextStack.removeLast();
3643 }
3644 
<a name="113" id="anc113"></a><span class="line-modified">3645 void BytecodeGenerator::emitCatch(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, TryData* data)</span>
3646 {
<a name="114" id="anc114"></a><span class="line-modified">3647     m_catchesToEmit.append(CatchEntry { data, exceptionRegister, thrownValueRegister });</span>














3648 }
3649 
3650 void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
3651 {
3652     if (lexicalScopeIndex == CurrentLexicalScopeIndex)
3653         return; // No change needed.
3654 
3655     if (lexicalScopeIndex != OutermostLexicalScopeIndex) {
3656         ASSERT(lexicalScopeIndex &lt; static_cast&lt;int&gt;(m_lexicalScopeStack.size()));
3657         int endIndex = lexicalScopeIndex + 1;
3658         for (size_t i = endIndex; i--; ) {
3659             if (m_lexicalScopeStack[i].m_scope) {
3660                 move(scopeRegister(), m_lexicalScopeStack[i].m_scope);
3661                 return;
3662             }
3663         }
3664     }
3665     // Note that if we don&#39;t find a local scope in the current function/program,
3666     // we must grab the outer-most scope of this bytecode generation.
3667     move(scopeRegister(), m_topMostScope);
3668 }
3669 
3670 void BytecodeGenerator::restoreScopeRegister()
3671 {
3672     restoreScopeRegister(currentLexicalScopeIndex());
3673 }
3674 
3675 int BytecodeGenerator::labelScopeDepthToLexicalScopeIndex(int targetLabelScopeDepth)
3676 {
3677     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
3678     size_t scopeDelta = labelScopeDepth() - targetLabelScopeDepth;
3679     ASSERT(scopeDelta &lt;= m_controlFlowScopeStack.size());
3680     if (!scopeDelta)
3681         return CurrentLexicalScopeIndex;
3682 
3683     ControlFlowScope&amp; targetScope = m_controlFlowScopeStack[targetLabelScopeDepth];
3684     return targetScope.lexicalScopeIndex;
3685 }
3686 
3687 void BytecodeGenerator::emitThrow(RegisterID* exc)
3688 {
3689     m_usesExceptions = true;
3690     OpThrow::emit(this, exc);
3691 }
3692 
3693 RegisterID* BytecodeGenerator::emitArgumentCount(RegisterID* dst)
3694 {
3695     OpArgumentCount::emit(this, dst);
3696     return dst;
3697 }
3698 
<a name="115" id="anc115"></a><span class="line-modified">3699 int BytecodeGenerator::localScopeDepth() const</span>
3700 {
3701     return m_localScopeDepth;
3702 }
3703 
3704 int BytecodeGenerator::labelScopeDepth() const
3705 {
3706     unsigned depth = localScopeDepth() + m_finallyDepth;
3707     ASSERT(depth == m_controlFlowScopeStack.size());
3708     return depth;
3709 }
3710 
3711 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, RegisterID* raw)
3712 {
3713     RefPtr&lt;RegisterID&gt; message = newTemporary();
3714     emitToString(message.get(), raw);
3715     OpThrowStaticError::emit(this, message.get(), errorType);
3716 }
3717 
3718 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, const Identifier&amp; message)
3719 {
3720     OpThrowStaticError::emit(this, addConstantValue(addStringConstant(message)), errorType);
3721 }
3722 
3723 void BytecodeGenerator::emitThrowReferenceError(const String&amp; message)
3724 {
3725     emitThrowStaticError(ErrorType::ReferenceError, Identifier::fromString(m_vm, message));
3726 }
3727 
3728 void BytecodeGenerator::emitThrowTypeError(const String&amp; message)
3729 {
3730     emitThrowStaticError(ErrorType::TypeError, Identifier::fromString(m_vm, message));
3731 }
3732 
3733 void BytecodeGenerator::emitThrowTypeError(const Identifier&amp; message)
3734 {
3735     emitThrowStaticError(ErrorType::TypeError, message);
3736 }
3737 
3738 void BytecodeGenerator::emitThrowRangeError(const Identifier&amp; message)
3739 {
3740     emitThrowStaticError(ErrorType::RangeError, message);
3741 }
3742 
3743 void BytecodeGenerator::emitThrowOutOfMemoryError()
3744 {
3745     emitThrowStaticError(ErrorType::Error, Identifier::fromString(m_vm, &quot;Out of memory&quot;));
3746 }
3747 
3748 void BytecodeGenerator::emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* callee, bool isCaptured)
3749 {
3750     // There is some nuance here:
3751     // If we&#39;re in strict mode code, the function name scope variable acts exactly like a &quot;const&quot; variable.
3752     // If we&#39;re not in strict mode code, we want to allow bogus assignments to the name scoped variable.
3753     // This means any assignment to the variable won&#39;t throw, but it won&#39;t actually assign a new value to it.
3754     // To accomplish this, we don&#39;t report that this scope is a lexical scope. This will prevent
3755     // any throws when trying to assign to the variable (while still ensuring it keeps its original
3756     // value). There is some ugliness and exploitation of a leaky abstraction here, but it&#39;s better than
3757     // having a completely new op code and a class to handle name scopes which are so close in functionality
3758     // to lexical environments.
3759     VariableEnvironment nameScopeEnvironment;
3760     auto addResult = nameScopeEnvironment.add(property);
3761     if (isCaptured)
3762         addResult.iterator-&gt;value.setIsCaptured();
3763     addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
3764     unsigned numVars = m_codeBlock-&gt;m_numVars;
3765     pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
3766     ASSERT_UNUSED(numVars, m_codeBlock-&gt;m_numVars == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.
3767     bool shouldTreatAsLexicalVariable = isStrictMode();
3768     Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
3769     emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
3770 }
3771 
3772 void BytecodeGenerator::pushLocalControlFlowScope()
3773 {
3774     ControlFlowScope scope(ControlFlowScope::Label, currentLexicalScopeIndex());
3775     m_controlFlowScopeStack.append(WTFMove(scope));
3776     m_localScopeDepth++;
3777 }
3778 
3779 void BytecodeGenerator::popLocalControlFlowScope()
3780 {
3781     ASSERT(m_controlFlowScopeStack.size());
3782     ASSERT(!m_controlFlowScopeStack.last().isFinallyScope());
3783     m_controlFlowScopeStack.removeLast();
3784     m_localScopeDepth--;
3785 }
3786 
3787 void BytecodeGenerator::emitPushCatchScope(VariableEnvironment&amp; environment)
3788 {
3789     pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::CatchScope, ScopeRegisterType::Block);
3790 }
3791 
3792 void BytecodeGenerator::emitPopCatchScope(VariableEnvironment&amp; environment)
3793 {
3794     popLexicalScopeInternal(environment);
3795 }
3796 
3797 void BytecodeGenerator::beginSwitch(RegisterID* scrutineeRegister, SwitchInfo::SwitchType type)
3798 {
3799     switch (type) {
3800     case SwitchInfo::SwitchImmediate: {
3801         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3802         m_codeBlock-&gt;addSwitchJumpTable();
3803         OpSwitchImm::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3804         break;
3805     }
3806     case SwitchInfo::SwitchCharacter: {
3807         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3808         m_codeBlock-&gt;addSwitchJumpTable();
3809         OpSwitchChar::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3810         break;
3811     }
3812     case SwitchInfo::SwitchString: {
3813         size_t tableIndex = m_codeBlock-&gt;numberOfStringSwitchJumpTables();
3814         m_codeBlock-&gt;addStringSwitchJumpTable();
3815         OpSwitchString::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3816         break;
3817     }
3818     default:
3819         RELEASE_ASSERT_NOT_REACHED();
3820     }
3821 
3822     SwitchInfo info = { m_lastInstruction.offset(), type };
3823     m_switchContextStack.append(info);
3824 }
3825 
3826 static int32_t keyForImmediateSwitch(ExpressionNode* node, int32_t min, int32_t max)
3827 {
3828     UNUSED_PARAM(max);
3829     ASSERT(node-&gt;isNumber());
3830     double value = static_cast&lt;NumberNode*&gt;(node)-&gt;value();
3831     int32_t key = static_cast&lt;int32_t&gt;(value);
3832     ASSERT(key == value);
3833     ASSERT(key &gt;= min);
3834     ASSERT(key &lt;= max);
3835     return key - min;
3836 }
3837 
3838 static int32_t keyForCharacterSwitch(ExpressionNode* node, int32_t min, int32_t max)
3839 {
3840     UNUSED_PARAM(max);
3841     ASSERT(node-&gt;isString());
3842     StringImpl* clause = static_cast&lt;StringNode*&gt;(node)-&gt;value().impl();
3843     ASSERT(clause-&gt;length() == 1);
3844 
3845     int32_t key = (*clause)[0];
3846     ASSERT(key &gt;= min);
3847     ASSERT(key &lt;= max);
3848     return key - min;
3849 }
3850 
3851 static void prepareJumpTableForSwitch(
3852     UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
3853     const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
3854     int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
3855 {
3856     jumpTable.min = min;
3857     jumpTable.branchOffsets.resize(max - min + 1);
3858     jumpTable.branchOffsets.fill(0);
3859     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3860         // We&#39;re emitting this after the clause labels should have been fixed, so
3861         // the labels should not be &quot;forward&quot; references
3862         ASSERT(!labels[i]-&gt;isForward());
3863         jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
3864     }
3865 }
3866 
3867 static void prepareJumpTableForStringSwitch(UnlinkedStringJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes)
3868 {
3869     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3870         // We&#39;re emitting this after the clause labels should have been fixed, so
3871         // the labels should not be &quot;forward&quot; references
3872         ASSERT(!labels[i]-&gt;isForward());
3873 
3874         ASSERT(nodes[i]-&gt;isString());
3875         StringImpl* clause = static_cast&lt;StringNode*&gt;(nodes[i])-&gt;value().impl();
3876         jumpTable.offsetTable.add(clause, UnlinkedStringJumpTable::OffsetLocation { labels[i]-&gt;bind(switchAddress) });
3877     }
3878 }
3879 
3880 void BytecodeGenerator::endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, Label&amp; defaultLabel, int32_t min, int32_t max)
3881 {
3882     SwitchInfo switchInfo = m_switchContextStack.last();
3883     m_switchContextStack.removeLast();
3884 
3885     BoundLabel defaultTarget = defaultLabel.bind(switchInfo.bytecodeOffset);
3886     auto handleSwitch = [&amp;](auto* op, auto bytecode) {
3887         op-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3888             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3889             return BoundLabel();
3890         });
3891 
3892         UnlinkedSimpleJumpTable&amp; jumpTable = m_codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex);
3893         prepareJumpTableForSwitch(
3894             jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes, min, max,
3895             switchInfo.switchType == SwitchInfo::SwitchImmediate
3896                 ? keyForImmediateSwitch
3897                 : keyForCharacterSwitch);
3898     };
3899 
3900     auto ref = m_writer.ref(switchInfo.bytecodeOffset);
3901     switch (switchInfo.switchType) {
3902     case SwitchInfo::SwitchImmediate: {
3903         handleSwitch(ref-&gt;cast&lt;OpSwitchImm&gt;(), ref-&gt;as&lt;OpSwitchImm&gt;());
3904         break;
3905     }
3906     case SwitchInfo::SwitchCharacter: {
3907         handleSwitch(ref-&gt;cast&lt;OpSwitchChar&gt;(), ref-&gt;as&lt;OpSwitchChar&gt;());
3908         break;
3909     }
3910 
3911     case SwitchInfo::SwitchString: {
3912         ref-&gt;cast&lt;OpSwitchString&gt;()-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3913             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3914             return BoundLabel();
3915         });
3916 
3917         UnlinkedStringJumpTable&amp; jumpTable = m_codeBlock-&gt;stringSwitchJumpTable(ref-&gt;as&lt;OpSwitchString&gt;().m_tableIndex);
3918         prepareJumpTableForStringSwitch(jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes);
3919         break;
3920     }
3921 
3922     default:
3923         RELEASE_ASSERT_NOT_REACHED();
3924         break;
3925     }
3926 }
3927 
3928 RegisterID* BytecodeGenerator::emitThrowExpressionTooDeepException()
3929 {
3930     // It would be nice to do an even better job of identifying exactly where the expression is.
3931     // And we could make the caller pass the node pointer in, if there was some way of getting
3932     // that from an arbitrary node. However, calling emitExpressionInfo without any useful data
3933     // is still good enough to get us an accurate line number.
3934     m_expressionTooDeep = true;
3935     return newTemporary();
3936 }
3937 
3938 bool BytecodeGenerator::isArgumentNumber(const Identifier&amp; ident, int argumentNumber)
3939 {
3940     RegisterID* registerID = variable(ident).local();
3941     if (!registerID)
3942         return false;
3943     return registerID-&gt;index() == CallFrame::argumentOffset(argumentNumber);
3944 }
3945 
3946 bool BytecodeGenerator::emitReadOnlyExceptionIfNeeded(const Variable&amp; variable)
3947 {
3948     // If we&#39;re in strict mode, we always throw.
3949     // If we&#39;re not in strict mode, we throw for &quot;const&quot; variables but not the function callee.
3950     if (isStrictMode() || variable.isConst()) {
3951         emitThrowTypeError(Identifier::fromString(m_vm, ReadonlyPropertyWriteError));
3952         return true;
3953     }
3954     return false;
3955 }
3956 
3957 void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
3958 {
3959     bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
3960     ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
3961 
<a name="116" id="anc116"></a><span class="line-removed">3962     CompletionRecordScope completionRecordScope(*this);</span>
<span class="line-removed">3963 </span>
3964     RefPtr&lt;RegisterID&gt; subject = newTemporary();
3965     emitNode(subject.get(), subjectNode);
3966     RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
3967     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
3968 
3969     Ref&lt;Label&gt; loopDone = newLabel();
3970     Ref&lt;Label&gt; tryStartLabel = newLabel();
3971     Ref&lt;Label&gt; finallyViaThrowLabel = newLabel();
3972     Ref&lt;Label&gt; finallyLabel = newLabel();
3973     Ref&lt;Label&gt; catchLabel = newLabel();
3974     Ref&lt;Label&gt; endCatchLabel = newLabel();
3975 
3976     // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
<a name="117" id="anc117"></a><span class="line-modified">3977     FinallyContext* finallyContext = pushFinallyControlFlowScope(finallyLabel.get());</span>

3978 
3979     {
3980         Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
3981         RefPtr&lt;RegisterID&gt; value = newTemporary();
3982         emitLoad(value.get(), jsUndefined());
3983 
3984         emitJump(*scope-&gt;continueTarget());
3985 
3986         Ref&lt;Label&gt; loopStart = newLabel();
3987         emitLabel(loopStart.get());
3988         emitLoopHint();
3989 
3990         emitLabel(tryStartLabel.get());
3991         TryData* tryData = pushTry(tryStartLabel.get(), finallyViaThrowLabel.get(), HandlerType::SynthesizedFinally);
3992         callBack(*this, value.get());
3993         emitJump(*scope-&gt;continueTarget());
3994 
3995         // IteratorClose sequence for abrupt completions.
3996         {
3997             // Finally block for the enumeration.
3998             emitLabel(finallyViaThrowLabel.get());
3999             popTry(tryData, finallyViaThrowLabel.get());
4000 
4001             Ref&lt;Label&gt; finallyBodyLabel = newLabel();
4002             RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
<a name="118" id="anc118"></a><span class="line-removed">4003             RegisterID* unused = newTemporary();</span>
4004 
<a name="119" id="anc119"></a><span class="line-modified">4005             emitCatch(completionValueRegister(), unused, tryData);</span>
<span class="line-modified">4006             emitSetCompletionType(CompletionType::Throw);</span>
<span class="line-removed">4007             move(finallyExceptionRegister.get(), completionValueRegister());</span>
4008             emitJump(finallyBodyLabel.get());
4009 
4010             emitLabel(finallyLabel.get());
4011             moveEmptyValue(finallyExceptionRegister.get());
4012 
<a name="120" id="anc120"></a>
4013             emitLabel(finallyBodyLabel.get());
4014             restoreScopeRegister();
4015 
4016             Ref&lt;Label&gt; finallyDone = newLabel();
4017 
4018             RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4019             emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), finallyDone.get());
4020 
4021             Ref&lt;Label&gt; returnCallTryStart = newLabel();
4022             emitLabel(returnCallTryStart.get());
4023             TryData* returnCallTryData = pushTry(returnCallTryStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
4024 
4025             CallArguments returnArguments(*this, nullptr);
4026             move(returnArguments.thisRegister(), iterator.get());
4027             emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4028 
4029             if (isForAwait)
4030                 emitAwait(value.get());
4031 
4032             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
4033             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4034 
4035             emitLabel(finallyDone.get());
<a name="121" id="anc121"></a><span class="line-modified">4036             emitFinallyCompletion(*finallyContext, completionTypeRegister(), endCatchLabel.get());</span>
4037 
4038             popTry(returnCallTryData, finallyDone.get());
4039 
4040             // Catch block for exceptions that may be thrown while calling the return
4041             // handler in the enumeration finally block. The only reason we need this
4042             // catch block is because if entered the above finally block due to a thrown
4043             // exception, then we want to re-throw the original exception on exiting
4044             // the finally block. Otherwise, we&#39;ll let any new exception pass through.
4045             {
4046                 emitLabel(catchLabel.get());
<a name="122" id="anc122"></a>
4047                 RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
<a name="123" id="anc123"></a><span class="line-modified">4048                 RegisterID* unused = newTemporary();</span>
<span class="line-removed">4049                 emitCatch(exceptionRegister.get(), unused, returnCallTryData);</span>
4050                 // Since this is a synthesized catch block and we&#39;re guaranteed to never need
4051                 // to resolve any symbols from the scope, we can skip restoring the scope
4052                 // register here.
4053 
4054                 Ref&lt;Label&gt; throwLabel = newLabel();
4055                 emitJumpIfTrue(emitIsEmpty(newTemporary(), finallyExceptionRegister.get()), throwLabel.get());
4056                 move(exceptionRegister.get(), finallyExceptionRegister.get());
4057 
4058                 emitLabel(throwLabel.get());
4059                 emitThrow(exceptionRegister.get());
4060 
4061                 emitLabel(endCatchLabel.get());
4062             }
4063         }
4064 
4065         emitLabel(*scope-&gt;continueTarget());
4066         if (forLoopNode) {
4067             RELEASE_ASSERT(forLoopNode-&gt;isForOfNode());
4068             prepareLexicalScopeForNextForLoopIteration(forLoopNode, forLoopSymbolTable);
4069             emitDebugHook(forLoopNode-&gt;lexpr());
4070         }
4071 
4072         {
4073             emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4074 
4075             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4076             emitGetById(value.get(), value.get(), propertyNames().value);
4077             emitJump(loopStart.get());
4078         }
4079 
4080         bool breakLabelIsBound = scope-&gt;breakTargetMayBeBound();
4081         if (breakLabelIsBound)
4082             emitLabel(scope-&gt;breakTarget());
4083         popFinallyControlFlowScope();
4084         if (breakLabelIsBound) {
4085             // IteratorClose sequence for break-ed control flow.
4086             emitIteratorClose(iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4087         }
4088     }
4089     emitLabel(loopDone.get());
4090 }
4091 
4092 RegisterID* BytecodeGenerator::emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode* taggedTemplate)
4093 {
4094     TemplateObjectDescriptor::StringVector rawStrings;
4095     TemplateObjectDescriptor::OptionalStringVector cookedStrings;
4096 
4097     TemplateStringListNode* templateString = taggedTemplate-&gt;templateLiteral()-&gt;templateStrings();
4098     for (; templateString; templateString = templateString-&gt;next()) {
4099         auto* string = templateString-&gt;value();
4100         ASSERT(string-&gt;raw());
4101         rawStrings.append(string-&gt;raw()-&gt;impl());
4102         if (!string-&gt;cooked())
4103             cookedStrings.append(WTF::nullopt);
4104         else
4105             cookedStrings.append(string-&gt;cooked()-&gt;impl());
4106     }
<a name="124" id="anc124"></a><span class="line-modified">4107     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)));</span>
4108     if (!dst)
4109         return constant.get();
4110     return move(dst, constant.get());
4111 }
4112 
4113 RegisterID* BytecodeGenerator::emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property)
4114 {
4115     dst = tempDestination(dst);
4116     Variable var = variable(property);
4117     if (RegisterID* local = var.local())
4118         return move(dst, local);
4119 
4120     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4121     move(scope.get(), emitResolveScope(scope.get(), var));
4122     return emitGetFromScope(dst, scope.get(), var, ThrowIfNotFound);
4123 }
4124 
4125 RegisterID* BytecodeGenerator::emitGetEnumerableLength(RegisterID* dst, RegisterID* base)
4126 {
4127     OpGetEnumerableLength::emit(this, dst, base);
4128     return dst;
4129 }
4130 
4131 RegisterID* BytecodeGenerator::emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4132 {
4133     OpHasGenericProperty::emit(this, dst, base, propertyName);
4134     return dst;
4135 }
4136 
4137 RegisterID* BytecodeGenerator::emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4138 {
4139     OpHasIndexedProperty::emit(this, dst, base, propertyName);
4140     return dst;
4141 }
4142 
4143 RegisterID* BytecodeGenerator::emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator)
4144 {
4145     OpHasStructureProperty::emit(this, dst, base, propertyName, enumerator);
4146     return dst;
4147 }
4148 
4149 RegisterID* BytecodeGenerator::emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base)
4150 {
4151     OpGetPropertyEnumerator::emit(this, dst, base);
4152     return dst;
4153 }
4154 
4155 RegisterID* BytecodeGenerator::emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4156 {
4157     OpEnumeratorStructurePname::emit(this, dst, enumerator, index);
4158     return dst;
4159 }
4160 
4161 RegisterID* BytecodeGenerator::emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4162 {
4163     OpEnumeratorGenericPname::emit(this, dst, enumerator, index);
4164     return dst;
4165 }
4166 
4167 RegisterID* BytecodeGenerator::emitToIndexString(RegisterID* dst, RegisterID* index)
4168 {
4169     OpToIndexString::emit(this, dst, index);
4170     return dst;
4171 }
4172 
4173 RegisterID* BytecodeGenerator::emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType type)
4174 {
4175     OpIsCellWithType::emit(this, dst, src, type);
4176     return dst;
4177 }
4178 
4179 RegisterID* BytecodeGenerator::emitIsObject(RegisterID* dst, RegisterID* src)
4180 {
4181     OpIsObject::emit(this, dst, src);
4182     return dst;
4183 }
4184 
4185 RegisterID* BytecodeGenerator::emitIsNumber(RegisterID* dst, RegisterID* src)
4186 {
4187     OpIsNumber::emit(this, dst, src);
4188     return dst;
4189 }
4190 
4191 RegisterID* BytecodeGenerator::emitIsUndefined(RegisterID* dst, RegisterID* src)
4192 {
4193     OpIsUndefined::emit(this, dst, src);
4194     return dst;
4195 }
4196 
4197 RegisterID* BytecodeGenerator::emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src)
4198 {
4199     OpIsUndefinedOrNull::emit(this, dst, src);
4200     return dst;
4201 }
4202 
4203 RegisterID* BytecodeGenerator::emitIsEmpty(RegisterID* dst, RegisterID* src)
4204 {
4205     OpIsEmpty::emit(this, dst, src);
4206     return dst;
4207 }
4208 
4209 RegisterID* BytecodeGenerator::emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4210 {
4211     {
4212         CallArguments nextArguments(*this, nullptr);
4213         move(nextArguments.thisRegister(), iterator);
4214         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4215 
4216         if (doEmitAwait == EmitAwait::Yes)
4217             emitAwait(dst);
4218     }
4219     {
4220         Ref&lt;Label&gt; typeIsObject = newLabel();
4221         emitJumpIfTrue(emitIsObject(newTemporary(), dst), typeIsObject.get());
4222         emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4223         emitLabel(typeIsObject.get());
4224     }
4225     return dst;
4226 }
4227 
4228 RegisterID* BytecodeGenerator::emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node)
4229 {
4230     {
4231         CallArguments nextArguments(*this, nullptr, 1);
4232         move(nextArguments.thisRegister(), iterator);
4233         move(nextArguments.argumentRegister(0), value);
4234         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4235     }
4236 
4237     return dst;
4238 }
4239 
4240 void BytecodeGenerator::emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4241 {
4242     Ref&lt;Label&gt; done = newLabel();
4243     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator, propertyNames().returnKeyword);
4244     emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), done.get());
4245 
4246     RefPtr&lt;RegisterID&gt; value = newTemporary();
4247     CallArguments returnArguments(*this, nullptr);
4248     move(returnArguments.thisRegister(), iterator);
4249     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4250 
4251     if (doEmitAwait == EmitAwait::Yes)
4252         emitAwait(value.get());
4253 
4254     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), done.get());
4255     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4256     emitLabel(done.get());
4257 }
4258 
4259 void BytecodeGenerator::pushIndexedForInScope(RegisterID* localRegister, RegisterID* indexRegister)
4260 {
4261     if (!localRegister)
4262         return;
4263     unsigned bodyBytecodeStartOffset = instructions().size();
4264     m_forInContextStack.append(adoptRef(*new IndexedForInContext(localRegister, indexRegister, bodyBytecodeStartOffset)));
4265 }
4266 
4267 void BytecodeGenerator::popIndexedForInScope(RegisterID* localRegister)
4268 {
4269     if (!localRegister)
4270         return;
4271     unsigned bodyBytecodeEndOffset = instructions().size();
4272     m_forInContextStack.last()-&gt;asIndexedForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4273     m_forInContextStack.removeLast();
4274 }
4275 
4276 RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
4277 {
4278     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode);
4279 
4280     return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
4281 }
4282 
4283 void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
4284 {
4285     emitGetFromScope(thisRegister(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier), variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped), DoNotThrowIfNotFound);
4286 }
4287 
4288 RegisterID* BytecodeGenerator::emitLoadNewTargetFromArrowFunctionLexicalEnvironment()
4289 {
4290     Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4291 
4292     return emitGetFromScope(m_newTargetRegister, emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().newTargetLocalPrivateName()), newTargetVar, ThrowIfNotFound);
4293 
4294 }
4295 
4296 RegisterID* BytecodeGenerator::emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment()
4297 {
4298     Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4299     return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
4300 }
4301 
4302 RegisterID* BytecodeGenerator::ensureThis()
4303 {
4304     if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
4305         if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
4306             emitLoadThisFromArrowFunctionLexicalEnvironment();
4307 
4308         emitTDZCheck(thisRegister());
4309     }
4310 
4311     return thisRegister();
4312 }
4313 
4314 bool BytecodeGenerator::isThisUsedInInnerArrowFunction()
4315 {
4316     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4317 }
4318 
4319 bool BytecodeGenerator::isArgumentsUsedInInnerArrowFunction()
4320 {
4321     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseArguments() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval();
4322 }
4323 
4324 bool BytecodeGenerator::isNewTargetUsedInInnerArrowFunction()
4325 {
4326     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseNewTarget() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4327 }
4328 
4329 bool BytecodeGenerator::isSuperUsedInInnerArrowFunction()
4330 {
4331     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4332 }
4333 
4334 bool BytecodeGenerator::isSuperCallUsedInInnerArrowFunction()
4335 {
4336     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4337 }
4338 
4339 void BytecodeGenerator::emitPutNewTargetToArrowFunctionContextScope()
4340 {
4341     if (isNewTargetUsedInInnerArrowFunction()) {
4342         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4343 
4344         Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4345         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, newTargetVar, newTarget(), DoNotThrowIfNotFound, InitializationMode::Initialization);
4346     }
4347 }
4348 
4349 void BytecodeGenerator::emitPutDerivedConstructorToArrowFunctionContextScope()
4350 {
4351     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
4352         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4353 
4354         Variable protoScope = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4355         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, protoScope, &amp;m_calleeRegister, DoNotThrowIfNotFound, InitializationMode::Initialization);
4356     }
4357 }
4358 
4359 void BytecodeGenerator::emitPutThisToArrowFunctionContextScope()
4360 {
4361     if (isThisUsedInInnerArrowFunction() || (m_scopeNode-&gt;usesSuperCall() &amp;&amp; m_codeType == EvalCode)) {
4362         ASSERT(isDerivedConstructorContext() || m_arrowFunctionContextLexicalEnvironmentRegister != nullptr);
4363 
4364         Variable thisVar = variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped);
4365         RegisterID* scope = isDerivedConstructorContext() ? emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier) : m_arrowFunctionContextLexicalEnvironmentRegister;
4366 
4367         emitPutToScope(scope, thisVar, thisRegister(), ThrowIfNotFound, InitializationMode::NotInitialization);
4368     }
4369 }
4370 
4371 void BytecodeGenerator::pushStructureForInScope(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister)
4372 {
4373     if (!localRegister)
4374         return;
4375     unsigned bodyBytecodeStartOffset = instructions().size();
4376     m_forInContextStack.append(adoptRef(*new StructureForInContext(localRegister, indexRegister, propertyRegister, enumeratorRegister, bodyBytecodeStartOffset)));
4377 }
4378 
4379 void BytecodeGenerator::popStructureForInScope(RegisterID* localRegister)
4380 {
4381     if (!localRegister)
4382         return;
4383     unsigned bodyBytecodeEndOffset = instructions().size();
4384     m_forInContextStack.last()-&gt;asStructureForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4385     m_forInContextStack.removeLast();
4386 }
4387 
4388 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4389 {
4390     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4391     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4392 
4393     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4394 
4395     return result;
4396 }
4397 
4398 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4399 {
<a name="125" id="anc125"></a><span class="line-removed">4400     // FIXME: op_jneq_null treats &quot;undetectable&quot; objects as null/undefined. RequireObjectCoercible</span>
<span class="line-removed">4401     // thus incorrectly throws a TypeError for interfaces like HTMLAllCollection.</span>
4402     Ref&lt;Label&gt; target = newLabel();
<a name="126" id="anc126"></a><span class="line-modified">4403     OpJneqNull::emit(this, value, target-&gt;bind(this));</span>
4404     emitThrowTypeError(error);
4405     emitLabel(target.get());
4406 }
4407 
4408 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4409 {
4410     Ref&lt;Label&gt; mergePoint = newLabel();
4411     unsigned yieldPointIndex = m_yieldPoints++;
4412     emitGeneratorStateChange(yieldPointIndex + 1);
4413 
4414     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4415         int suspendReason = static_cast&lt;int32_t&gt;(result);
4416         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));
4417     }
4418 
4419     // Split the try range here.
4420     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4421     for (unsigned i = m_tryContextStack.size(); i--;) {
4422         TryContext&amp; context = m_tryContextStack[i];
4423         m_tryRanges.append(TryRange {
4424             context.start.copyRef(),
4425             savePoint.copyRef(),
4426             context.tryData
4427         });
4428         // Try range will be restared at the merge point.
4429         context.start = mergePoint.get();
4430     }
4431     Vector&lt;TryContext&gt; savedTryContextStack;
4432     m_tryContextStack.swap(savedTryContextStack);
4433 
4434 
4435 #if CPU(NEEDS_ALIGNED_ACCESS)
4436     // conservatively align for the bytecode rewriter: it will delete this yield and
4437     // append a fragment, so we make sure that the start of the fragments is aligned
<a name="127" id="anc127"></a><span class="line-modified">4438     while (m_writer.position() % OpcodeSize::Wide)</span>
4439         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4440 #endif
4441     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4442 
4443     // Restore the try contexts, which start offset is updated to the merge point.
4444     m_tryContextStack.swap(savedTryContextStack);
4445     emitLabel(mergePoint.get());
4446 }
4447 
4448 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4449 {
4450     emitYieldPoint(argument, result);
4451 
4452     Ref&lt;Label&gt; normalLabel = newLabel();
4453     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4454     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4455     emitJumpIfTrue(condition.get(), normalLabel.get());
4456 
4457     Ref&lt;Label&gt; throwLabel = newLabel();
4458     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
4459     emitJumpIfTrue(condition.get(), throwLabel.get());
4460     // Return.
4461     {
4462         RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
4463         bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
4464         if (!hasFinally)
4465             emitReturn(returnRegister.get());
4466     }
4467 
4468     // Throw.
4469     emitLabel(throwLabel.get());
4470     emitThrow(generatorValueRegister());
4471 
4472     // Normal.
4473     emitLabel(normalLabel.get());
4474     return generatorValueRegister();
4475 }
4476 
4477 RegisterID* BytecodeGenerator::emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData* node)
4478 {
4479     CallArguments args(*this, nullptr);
4480     move(args.thisRegister(), argument);
4481     emitCall(iterator, iterator, NoExpectedFunction, args, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4482 
4483     return iterator;
4484 }
4485 
4486 void BytecodeGenerator::emitAwait(RegisterID* value)
4487 {
4488     emitYield(value, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);
4489     move(value, generatorValueRegister());
4490 }
4491 
4492 RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
4493 {
4494     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().iteratorSymbol);
4495     emitCallIterator(iterator.get(), argument, node);
4496 
4497     return iterator.get();
4498 }
4499 
4500 RegisterID* BytecodeGenerator::emitGetAsyncIterator(RegisterID* argument, ThrowableExpressionData* node)
4501 {
4502     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().asyncIteratorSymbol);
4503     Ref&lt;Label&gt; asyncIteratorNotFound = newLabel();
4504     Ref&lt;Label&gt; asyncIteratorFound = newLabel();
4505     Ref&lt;Label&gt; iteratorReceived = newLabel();
4506 
4507     emitJumpIfTrue(emitUnaryOp&lt;OpEqNull&gt;(newTemporary(), iterator.get()), asyncIteratorNotFound.get());
4508 
4509     emitJump(asyncIteratorFound.get());
4510     emitLabel(asyncIteratorNotFound.get());
4511 
4512     RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
4513     move(iterator.get(), commonIterator.get());
4514 
4515     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4516 
4517     auto varCreateAsyncFromSyncIterator = variable(propertyNames().builtinNames().createAsyncFromSyncIteratorPrivateName());
4518     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4519     move(scope.get(), emitResolveScope(scope.get(), varCreateAsyncFromSyncIterator));
4520     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = emitGetFromScope(newTemporary(), scope.get(), varCreateAsyncFromSyncIterator, ThrowIfNotFound);
4521 
4522     CallArguments args(*this, nullptr, 2);
4523     emitLoad(args.thisRegister(), jsUndefined());
4524 
4525     move(args.argumentRegister(0), iterator.get());
4526     move(args.argumentRegister(1), nextMethod.get());
4527 
4528     JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
4529     emitCall(iterator.get(), createAsyncFromSyncIterator.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4530 
4531     emitJump(iteratorReceived.get());
4532 
4533     emitLabel(asyncIteratorFound.get());
4534     emitCallIterator(iterator.get(), argument, node);
4535     emitLabel(iteratorReceived.get());
4536 
4537     return iterator.get();
4538 }
4539 
4540 RegisterID* BytecodeGenerator::emitDelegateYield(RegisterID* argument, ThrowableExpressionData* node)
4541 {
4542     RefPtr&lt;RegisterID&gt; value = newTemporary();
4543     {
4544         RefPtr&lt;RegisterID&gt; iterator = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? emitGetAsyncIterator(argument, node) : emitGetIterator(argument, node);
4545         RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4546 
4547         Ref&lt;Label&gt; loopDone = newLabel();
4548         {
4549             Ref&lt;Label&gt; nextElement = newLabel();
4550             emitLoad(value.get(), jsUndefined());
4551 
4552             emitJump(nextElement.get());
4553 
4554             Ref&lt;Label&gt; loopStart = newLabel();
4555             emitLabel(loopStart.get());
4556             emitLoopHint();
4557 
4558             Ref&lt;Label&gt; branchOnResult = newLabel();
4559             {
4560                 emitYieldPoint(value.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
4561 
4562                 Ref&lt;Label&gt; normalLabel = newLabel();
4563                 Ref&lt;Label&gt; returnLabel = newLabel();
4564                 {
4565                     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4566                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4567                     emitJumpIfTrue(condition.get(), normalLabel.get());
4568 
4569                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ReturnMode))));
4570                     emitJumpIfTrue(condition.get(), returnLabel.get());
4571 
4572                     // Fallthrough to ThrowMode.
4573                 }
4574 
4575                 // Throw.
4576                 {
4577                     Ref&lt;Label&gt; throwMethodFound = newLabel();
4578                     RefPtr&lt;RegisterID&gt; throwMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().throwKeyword);
4579                     emitJumpIfFalse(emitIsUndefined(newTemporary(), throwMethod.get()), throwMethodFound.get());
4580 
4581                     EmitAwait emitAwaitInIteratorClose = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? EmitAwait::Yes : EmitAwait::No;
4582                     emitIteratorClose(iterator.get(), node, emitAwaitInIteratorClose);
4583 
4584                     emitThrowTypeError(&quot;Delegated generator does not have a &#39;throw&#39; method.&quot;_s);
4585 
4586                     emitLabel(throwMethodFound.get());
4587                     CallArguments throwArguments(*this, nullptr, 1);
4588                     move(throwArguments.thisRegister(), iterator.get());
4589                     move(throwArguments.argumentRegister(0), generatorValueRegister());
4590                     emitCall(value.get(), throwMethod.get(), NoExpectedFunction, throwArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4591 
4592                     emitJump(branchOnResult.get());
4593                 }
4594 
4595                 // Return.
4596                 emitLabel(returnLabel.get());
4597                 {
4598                     Ref&lt;Label&gt; returnMethodFound = newLabel();
4599                     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4600                     emitJumpIfFalse(emitIsUndefined(newTemporary(), returnMethod.get()), returnMethodFound.get());
4601 
4602                     move(value.get(), generatorValueRegister());
4603 
4604                     Ref&lt;Label&gt; returnSequence = newLabel();
4605                     emitJump(returnSequence.get());
4606 
4607                     emitLabel(returnMethodFound.get());
4608                     CallArguments returnArguments(*this, nullptr, 1);
4609                     move(returnArguments.thisRegister(), iterator.get());
4610                     move(returnArguments.argumentRegister(0), generatorValueRegister());
4611                     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4612 
4613                     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4614                         emitAwait(value.get());
4615 
4616                     Ref&lt;Label&gt; returnIteratorResultIsObject = newLabel();
4617                     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), returnIteratorResultIsObject.get());
4618                     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4619 
4620                     emitLabel(returnIteratorResultIsObject.get());
4621 
4622                     Ref&lt;Label&gt; returnFromGenerator = newLabel();
4623                     emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), returnFromGenerator.get());
4624 
4625                     emitGetById(value.get(), value.get(), propertyNames().value);
4626                     emitJump(loopStart.get());
4627 
4628                     emitLabel(returnFromGenerator.get());
4629                     emitGetById(value.get(), value.get(), propertyNames().value);
4630 
4631                     emitLabel(returnSequence.get());
4632                     bool hasFinally = emitReturnViaFinallyIfNeeded(value.get());
4633                     if (!hasFinally)
4634                         emitReturn(value.get());
4635                 }
4636 
4637                 // Normal.
4638                 emitLabel(normalLabel.get());
4639                 move(value.get(), generatorValueRegister());
4640             }
4641 
4642             emitLabel(nextElement.get());
4643             emitIteratorNextWithValue(value.get(), nextMethod.get(), iterator.get(), value.get(), node);
4644 
4645             emitLabel(branchOnResult.get());
4646 
4647             if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4648                 emitAwait(value.get());
4649 
4650             Ref&lt;Label&gt; iteratorValueIsObject = newLabel();
4651             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), iteratorValueIsObject.get());
4652             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4653             emitLabel(iteratorValueIsObject.get());
4654 
4655             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4656             emitGetById(value.get(), value.get(), propertyNames().value);
4657 
4658             emitJump(loopStart.get());
4659         }
4660         emitLabel(loopDone.get());
4661     }
4662 
4663     emitGetById(value.get(), value.get(), propertyNames().value);
4664     return value.get();
4665 }
4666 
4667 
4668 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4669 {
4670     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
4671     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);
4672 }
4673 
4674 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4675 {
4676     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4677     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4678     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4679     if (!numberOfScopesToCheckForFinally)
4680         return false;
4681 
4682     FinallyContext* innermostFinallyContext = nullptr;
4683     FinallyContext* outermostFinallyContext = nullptr;
4684     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4685     while (numberOfScopesToCheckForFinally--) {
4686         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4687         if (scope-&gt;isFinallyScope()) {
<a name="128" id="anc128"></a><span class="line-modified">4688             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
4689             if (!innermostFinallyContext)
4690                 innermostFinallyContext = finallyContext;
4691             outermostFinallyContext = finallyContext;
4692             finallyContext-&gt;incNumberOfBreaksOrContinues();
4693         }
4694     }
4695     if (!outermostFinallyContext)
4696         return false; // No finallys to thread through.
4697 
4698     auto jumpID = bytecodeOffsetToJumpID(instructions().size());
4699     int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
4700     outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
4701 
<a name="129" id="anc129"></a><span class="line-modified">4702     emitSetCompletionType(jumpID);</span>
4703     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4704     return true; // We&#39;ll be jumping to a finally block.
4705 }
4706 
4707 bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
4708 {
4709     size_t numberOfScopesToCheckForFinally = m_controlFlowScopeStack.size();
4710     if (!numberOfScopesToCheckForFinally)
4711         return false;
4712 
4713     FinallyContext* innermostFinallyContext = nullptr;
4714     while (numberOfScopesToCheckForFinally) {
4715         size_t scopeIndex = --numberOfScopesToCheckForFinally;
4716         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
4717         if (scope-&gt;isFinallyScope()) {
<a name="130" id="anc130"></a><span class="line-modified">4718             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
4719             if (!innermostFinallyContext)
4720                 innermostFinallyContext = finallyContext;
4721             finallyContext-&gt;setHandlesReturns();
4722         }
4723     }
4724     if (!innermostFinallyContext)
4725         return false; // No finallys to thread through.
4726 
<a name="131" id="anc131"></a><span class="line-modified">4727     emitSetCompletionType(CompletionType::Return);</span>
<span class="line-modified">4728     emitSetCompletionValue(returnRegister);</span>
4729     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4730     return true; // We&#39;ll be jumping to a finally block.
4731 }
4732 
<a name="132" id="anc132"></a><span class="line-modified">4733 void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, RegisterID* completionTypeRegister, Label&amp; normalCompletionLabel)</span>
4734 {
4735     if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
<a name="133" id="anc133"></a><span class="line-modified">4736         emitJumpIf&lt;OpStricteq&gt;(completionTypeRegister, CompletionType::Normal, normalCompletionLabel);</span>
4737 
4738         FinallyContext* outerContext = context.outerContext();
4739 
4740         size_t numberOfJumps = context.numberOfJumps();
4741         ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
4742 
<a name="134" id="anc134"></a>
4743         for (size_t i = 0; i &lt; numberOfJumps; i++) {
4744             Ref&lt;Label&gt; nextLabel = newLabel();
4745             auto&amp; jump = context.jumps(i);
<a name="135" id="anc135"></a><span class="line-modified">4746             emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, jump.jumpID, nextLabel.get());</span>




















4747 
4748             restoreScopeRegister(jump.targetLexicalScopeIndex);
<a name="136" id="anc136"></a><span class="line-modified">4749             emitSetCompletionType(CompletionType::Normal);</span>
4750             emitJump(jump.targetLabel.get());
4751 
4752             emitLabel(nextLabel.get());
4753         }
4754 
<a name="137" id="anc137"></a>
4755         if (outerContext) {
<a name="138" id="anc138"></a><span class="line-modified">4756             // We are not the outermost finally.</span>
<span class="line-modified">4757             bool hasBreaksOrContinuesNotCoveredByJumps = context.numberOfBreaksOrContinues() &gt; numberOfJumps;</span>
<span class="line-modified">4758             if (hasBreaksOrContinuesNotCoveredByJumps || context.handlesReturns())</span>
<span class="line-modified">4759                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, *outerContext-&gt;finallyLabel());</span>
































































4760 
4761         } else {
4762             // We are the outermost finally.
4763             if (context.handlesReturns()) {
4764                 Ref&lt;Label&gt; notReturnLabel = newLabel();
<a name="139" id="anc139"></a><span class="line-modified">4765                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Return, notReturnLabel.get());</span>











4766 
4767                 emitWillLeaveCallFrameDebugHook();
<a name="140" id="anc140"></a><span class="line-modified">4768                 emitReturn(completionValueRegister(), ReturnFrom::Finally);</span>
4769 
4770                 emitLabel(notReturnLabel.get());
4771             }
4772         }
4773     }
<a name="141" id="anc141"></a><span class="line-removed">4774     emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, normalCompletionLabel);</span>
<span class="line-removed">4775     emitThrow(completionValueRegister());</span>
<span class="line-removed">4776 }</span>
4777 
<a name="142" id="anc142"></a><span class="line-modified">4778 bool BytecodeGenerator::allocateCompletionRecordRegisters()</span>
<span class="line-modified">4779 {</span>
<span class="line-removed">4780     if (m_completionTypeRegister)</span>
<span class="line-removed">4781         return false;</span>
4782 
<a name="143" id="anc143"></a><span class="line-modified">4783     ASSERT(!m_completionValueRegister);</span>
<span class="line-removed">4784     m_completionTypeRegister = newTemporary();</span>
<span class="line-removed">4785     m_completionValueRegister = newTemporary();</span>
4786 
<a name="144" id="anc144"></a><span class="line-modified">4787     emitSetCompletionType(CompletionType::Normal);</span>
<span class="line-modified">4788     moveEmptyValue(m_completionValueRegister.get());</span>
<span class="line-modified">4789     return true;</span>
<span class="line-modified">4790 }</span>





4791 
<a name="145" id="anc145"></a><span class="line-modified">4792 void BytecodeGenerator::releaseCompletionRecordRegisters()</span>
<span class="line-removed">4793 {</span>
<span class="line-removed">4794     ASSERT(m_completionTypeRegister &amp;&amp; m_completionValueRegister);</span>
<span class="line-removed">4795     m_completionTypeRegister = nullptr;</span>
<span class="line-removed">4796     m_completionValueRegister = nullptr;</span>
4797 }
4798 
4799 template&lt;typename CompareOp&gt;
4800 void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
4801 {
4802     RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
4803     RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
4804     OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
4805 
<a name="146" id="anc146"></a><span class="line-modified">4806     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), valueConstant, completionTypeRegister, operandTypes);</span>
4807     emitJumpIfTrue(equivalenceResult, jumpTarget);
4808 }
4809 
<a name="147" id="anc147"></a>



























4810 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4811 {
4812     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4813     // either of the following conditions is true:
4814     //
4815     // (1) The loop iteration variable is re-assigned within the body of the loop.
4816     // (2) The loop iteration variable is captured in the lexical scope of the function.
4817     //
4818     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4819     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4820     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4821     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4822     // reassigned from its original value.
4823 
4824     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
4825         auto instruction = generator.instructions().at(offset);
4826         OpcodeID opcodeID = instruction-&gt;opcodeID();
4827 
4828         ASSERT(opcodeID != op_enter);
4829         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {
4830             if (local()-&gt;virtualRegister() == operand)
4831                 invalidate();
4832         });
4833         offset += instruction-&gt;size();
4834     }
4835 }
4836 
4837 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4838 {
4839     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4840     if (isValid())
4841         return;
4842 
4843     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
4844     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
4845     for (const auto&amp; instTuple : m_getInsts) {
4846         unsigned instIndex = std::get&lt;0&gt;(instTuple);
4847         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
4848         auto instruction = generator.m_writer.ref(instIndex);
4849         auto end = instIndex + instruction-&gt;size();
<a name="148" id="anc148"></a><span class="line-modified">4850         ASSERT(instruction-&gt;isWide());</span>
4851 
4852         generator.m_writer.seek(instIndex);
4853 
4854         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
4855 
4856         // disable peephole optimizations
4857         generator.m_lastOpcodeID = op_end;
4858 
4859         // Change the opcode to get_by_val.
4860         // 1. dst stays the same.
4861         // 2. base stays the same.
4862         // 3. property gets switched to the original property.
<a name="149" id="anc149"></a><span class="line-modified">4863         OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));</span>
4864 
4865         // 4. nop out the remaining bytes
4866         while (generator.m_writer.position() &lt; end)
4867             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
4868     }
4869     generator.m_writer.seek(generator.m_writer.size());
4870     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
4871         generator.m_lastOpcodeID = lastOpcodeID;
4872         generator.m_lastInstruction = lastInstruction;
4873     }
4874 }
4875 
4876 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4877 {
4878     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4879     if (isValid())
4880         return;
4881 
4882     for (const auto&amp; instPair : m_getInsts) {
4883         unsigned instIndex = instPair.first;
4884         int propertyRegIndex = instPair.second;
<a name="150" id="anc150"></a><span class="line-removed">4885         // FIXME: we should not have to force this get_by_val to be wide, just guarantee that propertyRegIndex fits</span>
<span class="line-removed">4886         // https://bugs.webkit.org/show_bug.cgi?id=190929</span>
4887         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
4888             ASSERT_NOT_REACHED();
4889             return VirtualRegister();
4890         });
4891     }
4892 }
4893 
4894 void StaticPropertyAnalysis::record()
4895 {
4896     auto* instruction = m_instructionRef.ptr();
4897     auto size = m_propertyIndexes.size();
4898     switch (instruction-&gt;opcodeID()) {
4899     case OpNewObject::opcodeID:
4900         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
4901             return 255;
4902         });
4903         return;
4904     case OpCreateThis::opcodeID:
4905         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
4906             return 255;
4907         });
4908         return;
4909     default:
4910         ASSERT_NOT_REACHED();
4911     }
4912 }
4913 
4914 void BytecodeGenerator::emitToThis()
4915 {
4916     OpToThis::emit(this, kill(&amp;m_thisRegister));
4917     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
4918 }
4919 
4920 } // namespace JSC
4921 
4922 namespace WTF {
4923 
4924 void printInternal(PrintStream&amp; out, JSC::Variable::VariableKind kind)
4925 {
4926     switch (kind) {
4927     case JSC::Variable::NormalVariable:
4928         out.print(&quot;Normal&quot;);
4929         return;
4930     case JSC::Variable::SpecialVariable:
4931         out.print(&quot;Special&quot;);
4932         return;
4933     }
4934     RELEASE_ASSERT_NOT_REACHED();
4935 }
4936 
4937 } // namespace WTF
4938 
<a name="151" id="anc151"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="151" type="hidden" />
</body>
</html>