<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Structure.h&quot;
  28 
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DumpContext.h&quot;
  32 #include &quot;JSCInlines.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSPropertyNameEnumerator.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;PropertyMapHashTable.h&quot;
  37 #include &quot;PropertyNameArray.h&quot;
  38 #include &quot;StructureChain.h&quot;
  39 #include &quot;StructureRareDataInlines.h&quot;
  40 #include &quot;WeakGCMapInlines.h&quot;
  41 #include &lt;wtf/CommaPrinter.h&gt;
  42 #include &lt;wtf/NeverDestroyed.h&gt;
  43 #include &lt;wtf/ProcessID.h&gt;
  44 #include &lt;wtf/RefPtr.h&gt;
  45 #include &lt;wtf/Threading.h&gt;
  46 
  47 #define DUMP_STRUCTURE_ID_STATISTICS 0
  48 
  49 namespace JSC {
  50 
  51 #if DUMP_STRUCTURE_ID_STATISTICS
  52 static HashSet&lt;Structure*&gt;&amp; liveStructureSet = *(new HashSet&lt;Structure*&gt;);
  53 #endif
  54 
  55 class SingleSlotTransitionWeakOwner final : public WeakHandleOwner {
  56     void finalize(Handle&lt;Unknown&gt;, void* context) override
  57     {
  58         StructureTransitionTable* table = reinterpret_cast&lt;StructureTransitionTable*&gt;(context);
  59         ASSERT(table-&gt;isUsingSingleSlot());
  60         WeakSet::deallocate(table-&gt;weakImpl());
  61         table-&gt;m_data = StructureTransitionTable::UsingSingleSlotFlag;
  62     }
  63 };
  64 
  65 static SingleSlotTransitionWeakOwner&amp; singleSlotTransitionWeakOwner()
  66 {
  67     static NeverDestroyed&lt;SingleSlotTransitionWeakOwner&gt; owner;
  68     return owner;
  69 }
  70 
  71 inline Structure* StructureTransitionTable::singleTransition() const
  72 {
  73     ASSERT(isUsingSingleSlot());
  74     if (WeakImpl* impl = this-&gt;weakImpl()) {
  75         if (impl-&gt;state() == WeakImpl::Live)
  76             return jsCast&lt;Structure*&gt;(impl-&gt;jsValue().asCell());
  77     }
  78     return nullptr;
  79 }
  80 
  81 inline void StructureTransitionTable::setSingleTransition(Structure* structure)
  82 {
  83     ASSERT(isUsingSingleSlot());
  84     if (WeakImpl* impl = this-&gt;weakImpl())
  85         WeakSet::deallocate(impl);
  86     WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
  87     m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  88 }
  89 
  90 bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes) const
  91 {
  92     if (isUsingSingleSlot()) {
  93         Structure* transition = singleTransition();
  94         return transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes;
  95     }
  96     return map()-&gt;get(std::make_pair(rep, attributes));
  97 }
  98 
  99 inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes) const
 100 {
 101     if (isUsingSingleSlot()) {
 102         Structure* transition = singleTransition();
 103         return (transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes) ? transition : 0;
 104     }
 105     return map()-&gt;get(std::make_pair(rep, attributes));
 106 }
 107 
 108 void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
 109 {
 110     if (isUsingSingleSlot()) {
 111         Structure* existingTransition = singleTransition();
 112 
 113         // This handles the first transition being added.
 114         if (!existingTransition) {
 115             setSingleTransition(structure);
 116             return;
 117         }
 118 
 119         // This handles the second transition being added
 120         // (or the first transition being despecified!)
 121         setMap(new TransitionMap(vm));
 122         add(vm, existingTransition);
 123     }
 124 
 125     // Add the structure to the map.
 126 
 127     // Newer versions of the STL have an std::make_pair function that takes rvalue references.
 128     // When either of the parameters are bitfields, the C++ compiler will try to bind them as lvalues, which is invalid. To work around this, use unary &quot;+&quot; to make the parameter an rvalue.
 129     // See https://bugs.webkit.org/show_bug.cgi?id=59261 for more details
 130     map()-&gt;set(std::make_pair(structure-&gt;m_nameInPrevious.get(), +structure-&gt;attributesInPrevious()), structure);
 131 }
 132 
 133 void Structure::dumpStatistics()
 134 {
 135 #if DUMP_STRUCTURE_ID_STATISTICS
 136     unsigned numberLeaf = 0;
 137     unsigned numberUsingSingleSlot = 0;
 138     unsigned numberSingletons = 0;
 139     unsigned numberWithPropertyMaps = 0;
 140     unsigned totalPropertyMapsSize = 0;
 141 
 142     HashSet&lt;Structure*&gt;::const_iterator end = liveStructureSet.end();
 143     for (HashSet&lt;Structure*&gt;::const_iterator it = liveStructureSet.begin(); it != end; ++it) {
 144         Structure* structure = *it;
 145 
 146         switch (structure-&gt;m_transitionTable.size()) {
 147             case 0:
 148                 ++numberLeaf;
 149                 if (!structure-&gt;previousID())
 150                     ++numberSingletons;
 151                 break;
 152 
 153             case 1:
 154                 ++numberUsingSingleSlot;
 155                 break;
 156         }
 157 
 158         if (PropertyTable* table = structure-&gt;propertyTableOrNull()) {
 159             ++numberWithPropertyMaps;
 160             totalPropertyMapsSize += table-&gt;sizeInMemory();
 161         }
 162     }
 163 
 164     dataLogF(&quot;Number of live Structures: %d\n&quot;, liveStructureSet.size());
 165     dataLogF(&quot;Number of Structures using the single item optimization for transition map: %d\n&quot;, numberUsingSingleSlot);
 166     dataLogF(&quot;Number of Structures that are leaf nodes: %d\n&quot;, numberLeaf);
 167     dataLogF(&quot;Number of Structures that singletons: %d\n&quot;, numberSingletons);
 168     dataLogF(&quot;Number of Structures with PropertyMaps: %d\n&quot;, numberWithPropertyMaps);
 169 
 170     dataLogF(&quot;Size of a single Structures: %d\n&quot;, static_cast&lt;unsigned&gt;(sizeof(Structure)));
 171     dataLogF(&quot;Size of sum of all property maps: %d\n&quot;, totalPropertyMapsSize);
 172     dataLogF(&quot;Size of average of all property maps: %f\n&quot;, static_cast&lt;double&gt;(totalPropertyMapsSize) / static_cast&lt;double&gt;(liveStructureSet.size()));
 173 #else
 174     dataLogF(&quot;Dumping Structure statistics is not enabled.\n&quot;);
 175 #endif
 176 }
 177 
 178 Structure::Structure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 179     : JSCell(vm, vm.structureStructure.get())
 180     , m_blob(vm.heap.structureIDTable().allocateID(this), indexingType, typeInfo)
 181     , m_outOfLineTypeFlags(typeInfo.outOfLineTypeFlags())
 182     , m_inlineCapacity(inlineCapacity)
 183     , m_bitField(0)
 184     , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
 185     , m_prototype(vm, this, prototype)
 186     , m_classInfo(classInfo)
 187     , m_transitionWatchpointSet(IsWatched)
 188     , m_offset(invalidOffset)
 189     , m_propertyHash(0)
 190 {
 191     setDictionaryKind(NoneDictionaryKind);
 192     setIsPinnedPropertyTable(false);
 193     setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 194     setHasCustomGetterSetterProperties(false);
 195     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 196     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 197     setIsQuickPropertyAccessAllowedForEnumeration(true);
 198     setAttributesInPrevious(0);
 199     setDidPreventExtensions(false);
 200     setDidTransition(false);
 201     setStaticPropertiesReified(false);
 202     setTransitionWatchpointIsLikelyToBeFired(false);
 203     setHasBeenDictionary(false);
 204     setIsAddingPropertyForTransition(false);
 205 
 206     ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
 207     ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
 208     ASSERT(!hasRareData());
 209     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 210     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 211     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 212 }
 213 
 214 const ClassInfo Structure::s_info = { &quot;Structure&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(Structure) };
 215 
 216 Structure::Structure(VM&amp; vm)
 217     : JSCell(CreatingEarlyCell)
 218     , m_inlineCapacity(0)
 219     , m_bitField(0)
 220     , m_prototype(vm, this, jsNull())
 221     , m_classInfo(info())
 222     , m_transitionWatchpointSet(IsWatched)
 223     , m_offset(invalidOffset)
 224     , m_propertyHash(0)
 225 {
 226     setDictionaryKind(NoneDictionaryKind);
 227     setIsPinnedPropertyTable(false);
 228     setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 229     setHasCustomGetterSetterProperties(false);
 230     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 231     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 232     setIsQuickPropertyAccessAllowedForEnumeration(true);
 233     setAttributesInPrevious(0);
 234     setDidPreventExtensions(false);
 235     setDidTransition(false);
 236     setStaticPropertiesReified(false);
 237     setTransitionWatchpointIsLikelyToBeFired(false);
 238     setHasBeenDictionary(false);
 239     setIsAddingPropertyForTransition(false);
 240 
 241     TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
 242     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
 243     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 244 
 245     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 246     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 247     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 248 }
 249 
 250 Structure::Structure(VM&amp; vm, Structure* previous, DeferredStructureTransitionWatchpointFire* deferred)
 251     : JSCell(vm, vm.structureStructure.get())
 252     , m_inlineCapacity(previous-&gt;m_inlineCapacity)
 253     , m_bitField(0)
 254     , m_prototype(vm, this, previous-&gt;m_prototype.get())
 255     , m_classInfo(previous-&gt;m_classInfo)
 256     , m_transitionWatchpointSet(IsWatched)
 257     , m_offset(invalidOffset)
 258     , m_propertyHash(previous-&gt;m_propertyHash)
 259 {
 260     setDictionaryKind(previous-&gt;dictionaryKind());
 261     setIsPinnedPropertyTable(false);
 262     setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
 263     setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
 264     setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
 265     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
 266     setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
 267     setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
 268     setAttributesInPrevious(0);
 269     setDidPreventExtensions(previous-&gt;didPreventExtensions());
 270     setDidTransition(true);
 271     setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
 272     setHasBeenDictionary(previous-&gt;hasBeenDictionary());
 273     setIsAddingPropertyForTransition(false);
 274 
 275     TypeInfo typeInfo = previous-&gt;typeInfo();
 276     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
 277     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 278 
 279     ASSERT(!previous-&gt;typeInfo().structureIsImmortal());
 280     setPreviousID(vm, previous);
 281 
 282     previous-&gt;didTransitionFromThisStructure(deferred);
 283 
 284     // Copy this bit now, in case previous was being watched.
 285     setTransitionWatchpointIsLikelyToBeFired(previous-&gt;transitionWatchpointIsLikelyToBeFired());
 286 
 287     if (previous-&gt;m_globalObject)
 288         m_globalObject.set(vm, this, previous-&gt;m_globalObject.get());
 289     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 290     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 291     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 292 }
 293 
 294 Structure::~Structure()
 295 {
 296     if (typeInfo().structureIsImmortal())
 297         return;
 298     Heap::heap(this)-&gt;structureIDTable().deallocateID(this, m_blob.structureID());
 299 }
 300 
 301 void Structure::destroy(JSCell* cell)
 302 {
 303     static_cast&lt;Structure*&gt;(cell)-&gt;Structure::~Structure();
 304 }
 305 
 306 Structure* Structure::create(PolyProtoTag, VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 307 {
 308     Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 309 
 310     unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
 311     result-&gt;addPropertyWithoutTransition(
 312         vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
 313         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {
 314             RELEASE_ASSERT(Structure::outOfLineCapacity(newLastOffset) == oldOutOfLineCapacity);
 315             RELEASE_ASSERT(offset == knownPolyProtoOffset);
 316             RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
 317             result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
 318             result-&gt;setLastOffset(newLastOffset);
 319         });
 320 
 321     return result;
 322 }
 323 
 324 void Structure::findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp; structure, PropertyTable*&amp; table)
 325 {
 326     ASSERT(structures.isEmpty());
 327     table = 0;
 328 
 329     for (structure = this; structure; structure = structure-&gt;previousID()) {
 330         structure-&gt;m_lock.lock();
 331 
 332         table = structure-&gt;propertyTableOrNull();
 333         if (table) {
 334             // Leave the structure locked, so that the caller can do things to it atomically
 335             // before it loses its property table.
 336             return;
 337         }
 338 
 339         structures.append(structure);
 340         structure-&gt;m_lock.unlock();
 341     }
 342 
 343     ASSERT(!structure);
 344     ASSERT(!table);
 345 }
 346 
 347 PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
 348 {
 349     ASSERT(structure(vm)-&gt;classInfo() == info());
 350     ASSERT(!isAddingPropertyForTransition());
 351 
 352     DeferGC deferGC(vm.heap);
 353 
 354     Vector&lt;Structure*, 8&gt; structures;
 355     Structure* structure;
 356     PropertyTable* table;
 357 
 358     findStructuresAndMapForMaterialization(structures, structure, table);
 359 
 360     unsigned capacity = numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);
 361     if (table) {
 362         table = table-&gt;copy(vm, capacity);
 363         structure-&gt;m_lock.unlock();
 364     } else
 365         table = PropertyTable::create(vm, capacity);
 366 
 367     // Must hold the lock on this structure, since we will be modifying this structure&#39;s
 368     // property map. We don&#39;t want getConcurrently() to see the property map in a half-baked
 369     // state.
 370     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 371     if (setPropertyTable)
 372         this-&gt;setPropertyTable(vm, table);
 373 
 374     for (size_t i = structures.size(); i--;) {
 375         structure = structures[i];
 376         if (!structure-&gt;m_nameInPrevious)
 377             continue;
 378         PropertyMapEntry entry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious());
 379         table-&gt;add(entry, m_offset, PropertyTable::PropertyOffsetMustNotChange);
 380     }
 381 
 382     checkOffsetConsistency(
 383         table,
 384         [&amp;] () {
 385             dataLog(&quot;Detected in materializePropertyTable.\n&quot;);
 386             dataLog(&quot;Found structure = &quot;, RawPointer(structure), &quot;\n&quot;);
 387             dataLog(&quot;structures = &quot;);
 388             CommaPrinter comma;
 389             for (Structure* structure : structures)
 390                 dataLog(comma, RawPointer(structure));
 391             dataLog(&quot;\n&quot;);
 392         });
 393 
 394     return table;
 395 }
 396 
 397 Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 398 {
 399     ASSERT(!structure-&gt;isDictionary());
 400     ASSERT(structure-&gt;isObject());
 401 
 402     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes)) {
 403         validateOffset(existingTransition-&gt;m_offset, existingTransition-&gt;inlineCapacity());
 404         offset = existingTransition-&gt;m_offset;
 405         return existingTransition;
 406     }
 407 
 408     return 0;
 409 }
 410 
 411 Structure* Structure::addPropertyTransitionToExistingStructure(Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 412 {
 413     ASSERT(!isCompilationThread());
 414     return addPropertyTransitionToExistingStructureImpl(structure, propertyName.uid(), attributes, offset);
 415 }
 416 
 417 Structure* Structure::addPropertyTransitionToExistingStructureConcurrently(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 418 {
 419     ConcurrentJSLocker locker(structure-&gt;m_lock);
 420     return addPropertyTransitionToExistingStructureImpl(structure, uid, attributes, offset);
 421 }
 422 
 423 bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
 424 {
 425     ASSERT(base-&gt;structure(vm) == this);
 426 
 427     if (this-&gt;mayInterceptIndexedAccesses())
 428         return true;
 429 
 430     JSValue prototype = this-&gt;storedPrototype(base);
 431     if (!prototype.isObject())
 432         return false;
 433     JSObject* object = asObject(prototype);
 434 
 435     while (true) {
 436         Structure&amp; structure = *object-&gt;structure(vm);
 437         if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())
 438             return true;
 439         prototype = structure.storedPrototype(object);
 440         if (!prototype.isObject())
 441             return false;
 442         object = asObject(prototype);
 443     }
 444 
 445     RELEASE_ASSERT_NOT_REACHED();
 446     return false;
 447 }
 448 
 449 Structure* Structure::addPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 450 {
 451     Structure* newStructure = addPropertyTransitionToExistingStructure(
 452         structure, propertyName, attributes, offset);
 453     if (newStructure)
 454         return newStructure;
 455 
 456     return addNewPropertyTransition(
 457         vm, structure, propertyName, attributes, offset, PutPropertySlot::UnknownContext);
 458 }
 459 
 460 Structure* Structure::addNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset, PutPropertySlot::Context context, DeferredStructureTransitionWatchpointFire* deferred)
 461 {
 462     ASSERT(!structure-&gt;isDictionary());
 463     ASSERT(structure-&gt;isObject());
 464     ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, offset));
 465 
 466     int maxTransitionLength;
 467     if (context == PutPropertySlot::PutById)
 468         maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
 469     else
 470         maxTransitionLength = s_maxTransitionLength;
 471     if (structure-&gt;transitionCount() &gt; maxTransitionLength) {
 472         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
 473         Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
 474         ASSERT(structure != transition);
 475         offset = transition-&gt;add(vm, propertyName, attributes);
 476         return transition;
 477     }
 478 
 479     Structure* transition = create(vm, structure, deferred);
 480 
 481     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
 482 
 483     // While we are adding the property, rematerializing the property table is super weird: we already
 484     // have a m_nameInPrevious and attributesInPrevious but the m_offset is still wrong. If the
 485     // materialization algorithm runs, it&#39;ll build a property table that already has the property but
 486     // at a bogus offset. Rather than try to teach the materialization code how to create a table under
 487     // those conditions, we just tell the GC not to blow the table away during this period of time.
 488     // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
 489     // which case the GC will not blow the table away, or we do it after the GC already ran in which
 490     // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
 491     // isAddingPropertyForTransition before we set it to true, and then blow the table away after.
 492     {
 493         ConcurrentJSLocker locker(transition-&gt;m_lock);
 494         transition-&gt;setIsAddingPropertyForTransition(true);
 495     }
 496 
 497     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
 498     transition-&gt;m_nameInPrevious = propertyName.uid();
 499     transition-&gt;setAttributesInPrevious(attributes);
 500     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
 501     transition-&gt;m_offset = structure-&gt;m_offset;
 502 
 503     offset = transition-&gt;add(vm, propertyName, attributes);
 504 
 505     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
 506     // table away if it wants. We can now rebuild it fine.
 507     WTF::storeStoreFence();
 508     transition-&gt;setIsAddingPropertyForTransition(false);
 509 
 510     checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());
 511     {
 512         ConcurrentJSLocker locker(structure-&gt;m_lock);
 513         DeferGC deferGC(vm.heap);
 514         structure-&gt;m_transitionTable.add(vm, transition);
 515     }
 516     transition-&gt;checkOffsetConsistency();
 517     structure-&gt;checkOffsetConsistency();
 518     return transition;
 519 }
 520 
 521 Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset)
 522 {
 523     // NOTE: There are some good reasons why this goes directly to uncacheable dictionary rather than
 524     // caching the removal. We can fix all of these things, but we must remember to do so, if we ever try
 525     // to optimize this case.
 526     //
 527     // - Cached transitions usually steal the property table, and assume that this is possible because they
 528     //   can just rebuild the table by looking at past transitions. That code assumes that the table only
 529     //   grew and never shrank. To support removals, we&#39;d have to change the property table materialization
 530     //   code to handle deletions. Also, we have logic to get the list of properties on a structure that
 531     //   lacks a property table by just looking back through the set of transitions since the last
 532     //   structure that had a pinned table. That logic would also have to be changed to handle cached
 533     //   removals.
 534     //
 535     ASSERT(!structure-&gt;isUncacheableDictionary());
 536 
 537     Structure* transition = toUncacheableDictionaryTransition(vm, structure);
 538 
 539     offset = transition-&gt;remove(propertyName);
 540 
 541     transition-&gt;checkOffsetConsistency();
 542     return transition;
 543 }
 544 
 545 Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
 546 {
 547     ASSERT(prototype.isObject() || prototype.isNull());
 548 
 549     DeferGC deferGC(vm.heap);
 550     Structure* transition = create(vm, structure, &amp;deferred);
 551 
 552     transition-&gt;m_prototype.set(vm, transition, prototype);
 553 
 554     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 555     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 556     transition-&gt;m_offset = structure-&gt;m_offset;
 557 
 558     transition-&gt;checkOffsetConsistency();
 559     return transition;
 560 }
 561 
 562 Structure* Structure::attributeChangeTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes)
 563 {
 564     if (!structure-&gt;isUncacheableDictionary()) {
 565         Structure* transition = create(vm, structure);
 566 
 567         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 568         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 569         transition-&gt;m_offset = structure-&gt;m_offset;
 570 
 571         structure = transition;
 572     }
 573 
 574     PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
 575     ASSERT(entry);
 576     entry-&gt;attributes = attributes;
 577 
 578     structure-&gt;checkOffsetConsistency();
 579     return structure;
 580 }
 581 
 582 Structure* Structure::toDictionaryTransition(VM&amp; vm, Structure* structure, DictionaryKind kind, DeferredStructureTransitionWatchpointFire* deferred)
 583 {
 584     ASSERT(!structure-&gt;isUncacheableDictionary());
 585     DeferGC deferGC(vm.heap);
 586 
 587     Structure* transition = create(vm, structure, deferred);
 588 
 589     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 590     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 591     transition-&gt;m_offset = structure-&gt;m_offset;
 592     transition-&gt;setDictionaryKind(kind);
 593     transition-&gt;setHasBeenDictionary(true);
 594 
 595     transition-&gt;checkOffsetConsistency();
 596     return transition;
 597 }
 598 
 599 Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
 600 {
 601     return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
 602 }
 603 
 604 Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure)
 605 {
 606     return toDictionaryTransition(vm, structure, UncachedDictionaryKind);
 607 }
 608 
 609 Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
 610 {
 611     return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
 612 }
 613 
 614 Structure* Structure::freezeTransition(VM&amp; vm, Structure* structure)
 615 {
 616     return nonPropertyTransition(vm, structure, NonPropertyTransition::Freeze);
 617 }
 618 
 619 Structure* Structure::preventExtensionsTransition(VM&amp; vm, Structure* structure)
 620 {
 621     return nonPropertyTransition(vm, structure, NonPropertyTransition::PreventExtensions);
 622 }
 623 
 624 PropertyTable* Structure::takePropertyTableOrCloneIfPinned(VM&amp; vm)
 625 {
 626     // This must always return a property table. It can&#39;t return null.
 627     PropertyTable* result = propertyTableOrNull();
 628     if (result) {
 629         if (isPinnedPropertyTable())
 630             return result-&gt;copy(vm, result-&gt;size() + 1);
 631         ConcurrentJSLocker locker(m_lock);
 632         setPropertyTable(vm, nullptr);
 633         return result;
 634     }
 635     bool setPropertyTable = false;
 636     return materializePropertyTable(vm, setPropertyTable);
 637 }
 638 
 639 Structure* Structure::nonPropertyTransitionSlow(VM&amp; vm, Structure* structure, NonPropertyTransition transitionKind)
 640 {
 641     unsigned attributes = toAttributes(transitionKind);
 642     IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
 643 
 644     Structure* existingTransition;
 645     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes))) {
 646         ASSERT(existingTransition-&gt;attributesInPrevious() == attributes);
 647         ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
 648         return existingTransition;
 649     }
 650 
 651     DeferGC deferGC(vm.heap);
 652 
 653     Structure* transition = create(vm, structure);
 654     transition-&gt;setAttributesInPrevious(attributes);
 655     transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
 656 
 657     if (preventsExtensions(transitionKind))
 658         transition-&gt;setDidPreventExtensions(true);
 659 
 660     if (setsDontDeleteOnAllProperties(transitionKind)
 661         || setsReadOnlyOnNonAccessorProperties(transitionKind)) {
 662         // We pin the property table on transitions that do wholesale editing of the property
 663         // table, since our logic for walking the property transition chain to rematerialize the
 664         // table doesn&#39;t know how to take into account such wholesale edits.
 665 
 666         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 667         transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
 668         transition-&gt;m_offset = structure-&gt;m_offset;
 669 
 670         table = transition-&gt;propertyTableOrNull();
 671         RELEASE_ASSERT(table);
 672         for (auto&amp; entry : *table) {
 673             if (setsDontDeleteOnAllProperties(transitionKind))
 674                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete);
 675             if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
 676                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
 677         }
 678     } else {
 679         transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
 680         transition-&gt;m_offset = structure-&gt;m_offset;
 681         checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());
 682     }
 683 
 684     if (setsReadOnlyOnNonAccessorProperties(transitionKind)
 685         &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
 686         transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
 687 
 688     if (structure-&gt;isDictionary()) {
 689         PropertyTable* table = transition-&gt;ensurePropertyTable(vm);
 690         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 691     } else {
 692         auto locker = holdLock(structure-&gt;m_lock);
 693         structure-&gt;m_transitionTable.add(vm, transition);
 694     }
 695 
 696     transition-&gt;checkOffsetConsistency();
 697     return transition;
 698 }
 699 
 700 // In future we may want to cache this property.
 701 bool Structure::isSealed(VM&amp; vm)
 702 {
 703     if (isStructureExtensible())
 704         return false;
 705 
 706     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 707     if (!table)
 708         return true;
 709 
 710     PropertyTable::iterator end = table-&gt;end();
 711     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 712         if ((iter-&gt;attributes &amp; PropertyAttribute::DontDelete) != static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete))
 713             return false;
 714     }
 715     return true;
 716 }
 717 
 718 // In future we may want to cache this property.
 719 bool Structure::isFrozen(VM&amp; vm)
 720 {
 721     if (isStructureExtensible())
 722         return false;
 723 
 724     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 725     if (!table)
 726         return true;
 727 
 728     PropertyTable::iterator end = table-&gt;end();
 729     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 730         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontDelete))
 731             return false;
 732         if (!(iter-&gt;attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor)))
 733             return false;
 734     }
 735     return true;
 736 }
 737 
 738 Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
 739 {
 740     checkOffsetConsistency();
 741     ASSERT(isDictionary());
 742 
 743     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 744 
 745     object-&gt;setStructureIDDirectly(nuke(id()));
 746     WTF::storeStoreFence();
 747 
 748     size_t beforeOutOfLineCapacity = this-&gt;outOfLineCapacity();
 749     if (isUncacheableDictionary()) {
 750         PropertyTable* table = propertyTableOrNull();
 751         ASSERT(table);
 752 
 753         size_t propertyCount = table-&gt;size();
 754 
 755         // Holds our values compacted by insertion order.
 756         Vector&lt;JSValue&gt; values(propertyCount);
 757 
 758         // Copies out our values from their hashed locations, compacting property table offsets as we go.
 759         unsigned i = 0;
 760         PropertyTable::iterator end = table-&gt;end();
 761         m_offset = invalidOffset;
 762         for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
 763             values[i] = object-&gt;getDirect(iter-&gt;offset);
 764             m_offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);
 765         }
 766 
 767         // Copies in our values to their compacted locations.
 768         for (unsigned i = 0; i &lt; propertyCount; i++)
 769             object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
 770 
 771         table-&gt;clearDeletedOffsets();
 772 
 773         // We need to zero our unused property space; otherwise the GC might see a
 774         // stale pointer when we add properties in the future.
 775         memset(
 776             object-&gt;inlineStorageUnsafe() + inlineSize(),
 777             0,
 778             (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
 779 
 780         Butterfly* butterfly = object-&gt;butterfly();
 781         size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
 782         void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
 783         void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
 784         memset(startOfPropertyStorageSlots, 0, (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));
 785         checkOffsetConsistency();
 786     }
 787 
 788     setDictionaryKind(NoneDictionaryKind);
 789     setHasBeenFlattenedBefore(true);
 790 
 791     size_t afterOutOfLineCapacity = this-&gt;outOfLineCapacity();
 792 
 793     if (object-&gt;butterfly() &amp;&amp; beforeOutOfLineCapacity != afterOutOfLineCapacity) {
 794         ASSERT(beforeOutOfLineCapacity &gt; afterOutOfLineCapacity);
 795         // If the object had a Butterfly but after flattening/compacting we no longer have need of it,
 796         // we need to zero it out because the collector depends on the Structure to know the size for copying.
 797         if (!afterOutOfLineCapacity &amp;&amp; !this-&gt;hasIndexingHeader(object))
 798             object-&gt;setButterfly(vm, nullptr);
 799         // If the object was down-sized to the point where the base of the Butterfly is no longer within the
 800         // first CopiedBlock::blockSize bytes, we&#39;ll get the wrong answer if we try to mask the base back to
 801         // the CopiedBlock header. To prevent this case we need to memmove the Butterfly down.
 802         else
 803             object-&gt;shiftButterflyAfterFlattening(locker, vm, this, afterOutOfLineCapacity);
 804     }
 805 
 806     WTF::storeStoreFence();
 807     object-&gt;setStructureIDDirectly(id());
 808 
 809     // We need to do a writebarrier here because the GC thread might be scanning the butterfly while
 810     // we are shuffling properties around. See: https://bugs.webkit.org/show_bug.cgi?id=166989
 811     vm.heap.writeBarrier(object);
 812 
 813     return this;
 814 }
 815 
 816 void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 817 {
 818     setIsPinnedPropertyTable(true);
 819     setPropertyTable(vm, table);
 820     clearPreviousID();
 821     m_nameInPrevious = nullptr;
 822 }
 823 
 824 void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 825 {
 826     setIsPinnedPropertyTable(true);
 827     setPropertyTable(vm, table);
 828     m_nameInPrevious = nullptr;
 829 }
 830 
 831 void Structure::allocateRareData(VM&amp; vm)
 832 {
 833     ASSERT(!hasRareData());
 834     StructureRareData* rareData = StructureRareData::create(vm, previousID());
 835     WTF::storeStoreFence();
 836     m_previousOrRareData.set(vm, this, rareData);
 837     ASSERT(hasRareData());
 838 }
 839 
 840 WatchpointSet* Structure::ensurePropertyReplacementWatchpointSet(VM&amp; vm, PropertyOffset offset)
 841 {
 842     ASSERT(!isUncacheableDictionary());
 843 
 844     // In some places it&#39;s convenient to call this with an invalid offset. So, we do the check here.
 845     if (!isValidOffset(offset))
 846         return nullptr;
 847 
 848     if (!hasRareData())
 849         allocateRareData(vm);
 850     ConcurrentJSLocker locker(m_lock);
 851     StructureRareData* rareData = this-&gt;rareData();
 852     if (!rareData-&gt;m_replacementWatchpointSets) {
 853         rareData-&gt;m_replacementWatchpointSets =
 854             std::make_unique&lt;StructureRareData::PropertyWatchpointMap&gt;();
 855         WTF::storeStoreFence();
 856     }
 857     auto result = rareData-&gt;m_replacementWatchpointSets-&gt;add(offset, nullptr);
 858     if (result.isNewEntry)
 859         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
 860     return result.iterator-&gt;value.get();
 861 }
 862 
 863 void Structure::startWatchingPropertyForReplacements(VM&amp; vm, PropertyName propertyName)
 864 {
 865     ASSERT(!isUncacheableDictionary());
 866 
 867     startWatchingPropertyForReplacements(vm, get(vm, propertyName));
 868 }
 869 
 870 void Structure::didCachePropertyReplacement(VM&amp; vm, PropertyOffset offset)
 871 {
 872     RELEASE_ASSERT(isValidOffset(offset));
 873     ensurePropertyReplacementWatchpointSet(vm, offset)-&gt;fireAll(vm, &quot;Did cache property replacement&quot;);
 874 }
 875 
 876 void Structure::startWatchingInternalProperties(VM&amp; vm)
 877 {
 878     if (!isUncacheableDictionary()) {
 879         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;toString);
 880         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;valueOf);
 881     }
 882     setDidWatchInternalProperties(true);
 883 }
 884 
 885 #if DUMP_PROPERTYMAP_STATS
 886 
 887 PropertyMapHashTableStats* propertyMapHashTableStats = 0;
 888 
 889 struct PropertyMapStatisticsExitLogger {
 890     PropertyMapStatisticsExitLogger();
 891     ~PropertyMapStatisticsExitLogger();
 892 };
 893 
 894 DEFINE_GLOBAL_FOR_LOGGING(PropertyMapStatisticsExitLogger, logger, );
 895 
 896 PropertyMapStatisticsExitLogger::PropertyMapStatisticsExitLogger()
 897 {
 898     propertyMapHashTableStats = adoptPtr(new PropertyMapHashTableStats()).leakPtr();
 899 }
 900 
 901 PropertyMapStatisticsExitLogger::~PropertyMapStatisticsExitLogger()
 902 {
 903     unsigned finds = propertyMapHashTableStats-&gt;numFinds;
 904     unsigned collisions = propertyMapHashTableStats-&gt;numCollisions;
 905     dataLogF(&quot;\nJSC::PropertyMap statistics for process %d\n\n&quot;, getCurrentProcessID());
 906     dataLogF(&quot;%d finds\n&quot;, finds);
 907     dataLogF(&quot;%d collisions (%.1f%%)\n&quot;, collisions, 100.0 * collisions / finds);
 908     dataLogF(&quot;%d lookups\n&quot;, propertyMapHashTableStats-&gt;numLookups.load());
 909     dataLogF(&quot;%d lookup probings\n&quot;, propertyMapHashTableStats-&gt;numLookupProbing.load());
 910     dataLogF(&quot;%d adds\n&quot;, propertyMapHashTableStats-&gt;numAdds.load());
 911     dataLogF(&quot;%d removes\n&quot;, propertyMapHashTableStats-&gt;numRemoves.load());
 912     dataLogF(&quot;%d rehashes\n&quot;, propertyMapHashTableStats-&gt;numRehashes.load());
 913     dataLogF(&quot;%d reinserts\n&quot;, propertyMapHashTableStats-&gt;numReinserts.load());
 914 }
 915 
 916 #endif
 917 
 918 PropertyTable* Structure::copyPropertyTableForPinning(VM&amp; vm)
 919 {
 920     if (PropertyTable* table = propertyTableOrNull())
 921         return PropertyTable::clone(vm, *table);
 922     bool setPropertyTable = false;
 923     return materializePropertyTable(vm, setPropertyTable);
 924 }
 925 
 926 PropertyOffset Structure::getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes)
 927 {
 928     PropertyOffset result = invalidOffset;
 929 
 930     forEachPropertyConcurrently(
 931         [&amp;] (const PropertyMapEntry&amp; candidate) -&gt; bool {
 932             if (candidate.key != uid)
 933                 return true;
 934 
 935             result = candidate.offset;
 936             attributes = candidate.attributes;
 937             return false;
 938         });
 939 
 940     return result;
 941 }
 942 
 943 Vector&lt;PropertyMapEntry&gt; Structure::getPropertiesConcurrently()
 944 {
 945     Vector&lt;PropertyMapEntry&gt; result;
 946 
 947     forEachPropertyConcurrently(
 948         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
 949             result.append(entry);
 950             return true;
 951         });
 952 
 953     return result;
 954 }
 955 
 956 PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
 957 {
 958     return add&lt;ShouldPin::No&gt;(
 959         vm, propertyName, attributes,
 960         [this] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newLastOffset) {
 961             setLastOffset(newLastOffset);
 962         });
 963 }
 964 
 965 PropertyOffset Structure::remove(PropertyName propertyName)
 966 {
 967     return remove(propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
 968 }
 969 
 970 void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
 971 {
 972     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 973     if (!table)
 974         return;
 975 
 976     bool knownUnique = propertyNames.canAddKnownUniqueForStructure();
 977 
 978     PropertyTable::iterator end = table-&gt;end();
 979     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 980         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !(iter-&gt;attributes &amp; PropertyAttribute::DontEnum));
 981         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !iter-&gt;key-&gt;isSymbol());
 982         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties()) {
 983             if (iter-&gt;key-&gt;isSymbol() &amp;&amp; !propertyNames.includeSymbolProperties())
 984                 continue;
 985             if (knownUnique)
 986                 propertyNames.addUnchecked(iter-&gt;key);
 987             else
 988                 propertyNames.add(iter-&gt;key);
 989         }
 990     }
 991 }
 992 
 993 void StructureFireDetail::dump(PrintStream&amp; out) const
 994 {
 995     out.print(&quot;Structure transition from &quot;, *m_structure);
 996 }
 997 
 998 DeferredStructureTransitionWatchpointFire::DeferredStructureTransitionWatchpointFire(VM&amp; vm, Structure* structure)
 999     : DeferredWatchpointFire(vm)
1000     , m_structure(structure)
1001 {
1002 }
1003 
1004 DeferredStructureTransitionWatchpointFire::~DeferredStructureTransitionWatchpointFire()
1005 {
1006     fireAll();
1007 }
1008 
1009 void DeferredStructureTransitionWatchpointFire::dump(PrintStream&amp; out) const
1010 {
1011     out.print(&quot;Structure transition from &quot;, *m_structure);
1012 }
1013 
1014 void Structure::didTransitionFromThisStructure(DeferredStructureTransitionWatchpointFire* deferred) const
1015 {
1016     // If the structure is being watched, and this is the kind of structure that the DFG would
1017     // like to watch, then make sure to note for all future versions of this structure that it&#39;s
1018     // unwise to watch it.
1019     if (m_transitionWatchpointSet.isBeingWatched())
1020         const_cast&lt;Structure*&gt;(this)-&gt;setTransitionWatchpointIsLikelyToBeFired(true);
1021 
1022     if (deferred) {
1023         ASSERT(deferred-&gt;structure() == this);
1024         m_transitionWatchpointSet.fireAll(*vm(), deferred);
1025     } else
1026         m_transitionWatchpointSet.fireAll(*vm(), StructureFireDetail(this));
1027 }
1028 
1029 void Structure::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1030 {
1031     Structure* thisObject = jsCast&lt;Structure*&gt;(cell);
1032     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1033 
1034     Base::visitChildren(thisObject, visitor);
1035 
1036     ConcurrentJSLocker locker(thisObject-&gt;m_lock);
1037 
1038     visitor.append(thisObject-&gt;m_globalObject);
1039     if (!thisObject-&gt;isObject())
1040         thisObject-&gt;m_cachedPrototypeChain.clear();
1041     else {
1042         visitor.append(thisObject-&gt;m_prototype);
1043         visitor.append(thisObject-&gt;m_cachedPrototypeChain);
1044     }
1045     visitor.append(thisObject-&gt;m_previousOrRareData);
1046 
1047     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;isAddingPropertyForTransition()) {
1048         // NOTE: This can interleave in pin(), in which case it may see a null property table.
1049         // That&#39;s fine, because then the barrier will fire and we will scan this again.
1050         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1051     } else if (visitor.isBuildingHeapSnapshot())
1052         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1053     else if (thisObject-&gt;m_propertyTableUnsafe)
1054         thisObject-&gt;m_propertyTableUnsafe.clear();
1055 }
1056 
1057 bool Structure::isCheapDuringGC()
1058 {
1059     // FIXME: We could make this even safer by returning false if this structure&#39;s property table
1060     // has any large property names.
1061     // https://bugs.webkit.org/show_bug.cgi?id=157334
1062 
1063     return (!m_globalObject || Heap::isMarked(m_globalObject.get()))
1064         &amp;&amp; (hasPolyProto() || !storedPrototypeObject() || Heap::isMarked(storedPrototypeObject()));
1065 }
1066 
1067 bool Structure::markIfCheap(SlotVisitor&amp; visitor)
1068 {
1069     if (!isCheapDuringGC())
1070         return Heap::isMarked(this);
1071 
1072     visitor.appendUnbarriered(this);
1073     return true;
1074 }
1075 
1076 Ref&lt;StructureShape&gt; Structure::toStructureShape(JSValue value, bool&amp; sawPolyProtoStructure)
1077 {
1078     Ref&lt;StructureShape&gt; baseShape = StructureShape::create();
1079     RefPtr&lt;StructureShape&gt; curShape = baseShape.ptr();
1080     Structure* curStructure = this;
1081     JSValue curValue = value;
1082     sawPolyProtoStructure = false;
1083     while (curStructure) {
1084         sawPolyProtoStructure |= curStructure-&gt;hasPolyProto();
1085         curStructure-&gt;forEachPropertyConcurrently(
1086             [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1087                 if (!PropertyName(entry.key).isPrivateName())
1088                     curShape-&gt;addProperty(*entry.key);
1089                 return true;
1090             });
1091 
1092         if (JSObject* curObject = curValue.getObject())
1093             curShape-&gt;setConstructorName(JSObject::calculatedClassName(curObject));
1094         else
1095             curShape-&gt;setConstructorName(curStructure-&gt;classInfo()-&gt;className);
1096 
1097         if (curStructure-&gt;isDictionary())
1098             curShape-&gt;enterDictionaryMode();
1099 
1100         curShape-&gt;markAsFinal();
1101 
1102         if (!curValue.isObject())
1103             break;
1104 
1105         JSObject* object = asObject(curValue);
1106         JSObject* prototypeObject = object-&gt;structure()-&gt;storedPrototypeObject(object);
1107         if (!prototypeObject)
1108             break;
1109 
1110         auto newShape = StructureShape::create();
1111         curShape-&gt;setProto(newShape.copyRef());
1112         curShape = WTFMove(newShape);
1113         curValue = prototypeObject;
1114         curStructure = prototypeObject-&gt;structure();
1115     }
1116 
1117     return baseShape;
1118 }
1119 
1120 void Structure::dump(PrintStream&amp; out) const
1121 {
1122     out.print(RawPointer(this), &quot;:[&quot;, classInfo()-&gt;className, &quot;, {&quot;);
1123 
1124     CommaPrinter comma;
1125 
1126     const_cast&lt;Structure*&gt;(this)-&gt;forEachPropertyConcurrently(
1127         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1128             out.print(comma, entry.key, &quot;:&quot;, static_cast&lt;int&gt;(entry.offset));
1129             return true;
1130         });
1131 
1132     out.print(&quot;}, &quot;, IndexingTypeDump(indexingMode()));
1133 
1134     if (hasPolyProto())
1135         out.print(&quot;, PolyProto offset:&quot;, knownPolyProtoOffset);
1136     else if (m_prototype.get().isCell())
1137         out.print(&quot;, Proto:&quot;, RawPointer(m_prototype.get().asCell()));
1138 
1139     switch (dictionaryKind()) {
1140     case NoneDictionaryKind:
1141         if (hasBeenDictionary())
1142             out.print(&quot;, Has been dictionary&quot;);
1143         break;
1144     case CachedDictionaryKind:
1145         out.print(&quot;, Dictionary&quot;);
1146         break;
1147     case UncachedDictionaryKind:
1148         out.print(&quot;, UncacheableDictionary&quot;);
1149         break;
1150     }
1151 
1152     if (transitionWatchpointSetIsStillValid())
1153         out.print(&quot;, Leaf&quot;);
1154     else if (transitionWatchpointIsLikelyToBeFired())
1155         out.print(&quot;, Shady leaf&quot;);
1156 
1157     out.print(&quot;]&quot;);
1158 }
1159 
1160 void Structure::dumpInContext(PrintStream&amp; out, DumpContext* context) const
1161 {
1162     if (context)
1163         context-&gt;structures.dumpBrief(this, out);
1164     else
1165         dump(out);
1166 }
1167 
1168 void Structure::dumpBrief(PrintStream&amp; out, const CString&amp; string) const
1169 {
1170     out.print(&quot;%&quot;, string, &quot;:&quot;, classInfo()-&gt;className);
1171 }
1172 
1173 void Structure::dumpContextHeader(PrintStream&amp; out)
1174 {
1175     out.print(&quot;Structures:&quot;);
1176 }
1177 
1178 bool ClassInfo::hasStaticSetterOrReadonlyProperties() const
1179 {
1180     for (const ClassInfo* ci = this; ci; ci = ci-&gt;parentClass) {
1181         if (const HashTable* table = ci-&gt;staticPropHashTable) {
1182             if (table-&gt;hasSetterOrReadonlyProperties)
1183                 return true;
1184         }
1185     }
1186     return false;
1187 }
1188 
1189 void Structure::setCachedPropertyNameEnumerator(VM&amp; vm, JSPropertyNameEnumerator* enumerator)
1190 {
1191     ASSERT(!isDictionary());
1192     if (!hasRareData())
1193         allocateRareData(vm);
1194     rareData()-&gt;setCachedPropertyNameEnumerator(vm, enumerator);
1195 }
1196 
1197 JSPropertyNameEnumerator* Structure::cachedPropertyNameEnumerator() const
1198 {
1199     if (!hasRareData())
1200         return nullptr;
1201     return rareData()-&gt;cachedPropertyNameEnumerator();
1202 }
1203 
1204 bool Structure::canCachePropertyNameEnumerator() const
1205 {
1206     if (!this-&gt;canCacheOwnKeys())
1207         return false;
1208 
1209     StructureChain* structureChain = m_cachedPrototypeChain.get();
1210     ASSERT(structureChain);
1211     WriteBarrier&lt;Structure&gt;* structure = structureChain-&gt;head();
1212     while (true) {
1213         if (!structure-&gt;get())
1214             return true;
1215         if (!structure-&gt;get()-&gt;canCacheOwnKeys())
1216             return false;
1217         structure++;
1218     }
1219 
1220     ASSERT_NOT_REACHED();
1221     return true;
1222 }
1223 
1224 bool Structure::canAccessPropertiesQuicklyForEnumeration() const
1225 {
1226     if (!isQuickPropertyAccessAllowedForEnumeration())
1227         return false;
1228     if (hasGetterSetterProperties())
1229         return false;
1230     if (isUncacheableDictionary())
1231         return false;
1232     return true;
1233 }
1234 
1235 } // namespace JSC
    </pre>
  </body>
</html>