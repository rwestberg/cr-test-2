<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FloatingContext.h&quot;
 32 #include &quot;FloatingState.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;
<a name="1" id="anc1"></a>
 34 #include &quot;InlineLineBreaker.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 35 #include &quot;InlineRunProvider.h&quot;</span>
 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
 38 #include &quot;LayoutState.h&quot;
 39 #include &quot;TextUtil.h&quot;
 40 
 41 namespace WebCore {
 42 namespace Layout {
 43 
<a name="3" id="anc3"></a><span class="line-modified"> 44 class Line {</span>
<span class="line-modified"> 45 public:</span>
<span class="line-modified"> 46     void init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight);</span>
<span class="line-modified"> 47     void close();</span>
 48 
<a name="4" id="anc4"></a><span class="line-modified"> 49     void appendContent(const InlineRunProvider::Run&amp;, const LayoutSize&amp;);</span>




 50 
<a name="5" id="anc5"></a><span class="line-modified"> 51     void adjustLogicalLeft(LayoutUnit delta);</span>
<span class="line-modified"> 52     void adjustLogicalRight(LayoutUnit delta);</span>

 53 
<a name="6" id="anc6"></a><span class="line-modified"> 54     bool hasContent() const { return !m_inlineRuns.isEmpty(); }</span>
<span class="line-modified"> 55     bool isClosed() const { return m_closed; }</span>
<span class="line-removed"> 56     bool isFirstLine() const { return m_isFirstLine; }</span>
<span class="line-removed"> 57     Vector&lt;InlineRun&gt;&amp; runs() { return m_inlineRuns; }</span>
 58 
<a name="7" id="anc7"></a><span class="line-modified"> 59     LayoutUnit contentLogicalRight() const;</span>
<span class="line-modified"> 60     LayoutUnit contentLogicalLeft() const { return m_logicalRect.left(); }</span>
<span class="line-removed"> 61     LayoutUnit availableWidth() const { return m_availableWidth; }</span>
<span class="line-removed"> 62     Optional&lt;InlineRunProvider::Run::Type&gt; lastRunType() const { return m_lastRunType; }</span>
 63 
<a name="8" id="anc8"></a><span class="line-modified"> 64     LayoutUnit logicalTop() const { return m_logicalRect.top(); }</span>
<span class="line-modified"> 65     LayoutUnit logicalBottom() const { return m_logicalRect.bottom(); }</span>
<span class="line-removed"> 66     LayoutUnit logicalHeight() const { return logicalBottom() - logicalTop(); }</span>
 67 
<a name="9" id="anc9"></a><span class="line-modified"> 68 private:</span>
<span class="line-modified"> 69     struct TrailingTrimmableContent {</span>
<span class="line-removed"> 70         LayoutUnit width;</span>
<span class="line-removed"> 71         unsigned length;</span>
<span class="line-removed"> 72     };</span>
<span class="line-removed"> 73     Optional&lt;TrailingTrimmableContent&gt; m_trailingTrimmableContent;</span>
<span class="line-removed"> 74     Optional&lt;InlineRunProvider::Run::Type&gt; m_lastRunType;</span>
<span class="line-removed"> 75     bool m_lastRunCanExpand { false };</span>
 76 
<a name="10" id="anc10"></a><span class="line-modified"> 77     Display::Box::Rect m_logicalRect;</span>
<span class="line-modified"> 78     LayoutUnit m_availableWidth;</span>

 79 
<a name="11" id="anc11"></a><span class="line-modified"> 80     Vector&lt;InlineRun&gt; m_inlineRuns;</span>
<span class="line-modified"> 81     bool m_isFirstLine { true };</span>
<span class="line-modified"> 82     bool m_closed { true };</span>




 83 };
 84 
<a name="12" id="anc12"></a><span class="line-modified"> 85 void Line::init(const LayoutPoint&amp; topLeft, LayoutUnit availableWidth, LayoutUnit minimalHeight)</span>
<span class="line-modified"> 86 {</span>
<span class="line-removed"> 87     m_logicalRect.setTopLeft(topLeft);</span>
<span class="line-removed"> 88     m_logicalRect.setWidth(availableWidth);</span>
<span class="line-removed"> 89     m_logicalRect.setHeight(minimalHeight);</span>
<span class="line-removed"> 90     m_availableWidth = availableWidth;</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92     m_inlineRuns.clear();</span>
<span class="line-removed"> 93     m_lastRunType = { };</span>
<span class="line-removed"> 94     m_lastRunCanExpand = false;</span>
<span class="line-removed"> 95     m_trailingTrimmableContent = { };</span>
<span class="line-removed"> 96     m_closed = false;</span>
<span class="line-removed"> 97 }</span>
 98 
<a name="13" id="anc13"></a><span class="line-modified"> 99 void Line::adjustLogicalLeft(LayoutUnit delta)</span>
<span class="line-modified">100 {</span>
<span class="line-modified">101     ASSERT(delta &gt; 0);</span>




102 
<a name="14" id="anc14"></a><span class="line-modified">103     m_availableWidth -= delta;</span>
<span class="line-modified">104     m_logicalRect.shiftLeftTo(m_logicalRect.left() + delta);</span>



105 
<a name="15" id="anc15"></a><span class="line-modified">106     for (auto&amp; inlineRun : m_inlineRuns)</span>
<span class="line-modified">107         inlineRun.moveHorizontally(delta);</span>
<span class="line-modified">108 }</span>
109 
<a name="16" id="anc16"></a><span class="line-modified">110 void Line::adjustLogicalRight(LayoutUnit delta)</span>
<span class="line-removed">111 {</span>
<span class="line-removed">112     ASSERT(delta &gt; 0);</span>
113 
<a name="17" id="anc17"></a><span class="line-modified">114     m_availableWidth -= delta;</span>
<span class="line-modified">115     m_logicalRect.shiftRightTo(m_logicalRect.right() - delta);</span>
<span class="line-modified">116 }</span>











117 
<a name="18" id="anc18"></a><span class="line-modified">118 static bool isTrimmableContent(const InlineRunProvider::Run&amp; inlineRun)</span>
<span class="line-modified">119 {</span>
<span class="line-modified">120     return inlineRun.isWhitespace() &amp;&amp; inlineRun.style().collapseWhiteSpace();</span>
<span class="line-modified">121 }</span>
122 
<a name="19" id="anc19"></a><span class="line-modified">123 LayoutUnit Line::contentLogicalRight() const</span>
<span class="line-modified">124 {</span>
<span class="line-modified">125     if (m_inlineRuns.isEmpty())</span>
<span class="line-modified">126         return m_logicalRect.left();</span>
127 
<a name="20" id="anc20"></a><span class="line-modified">128     return m_inlineRuns.last().logicalRight();</span>
<span class="line-modified">129 }</span>









130 
<a name="21" id="anc21"></a><span class="line-modified">131 void Line::appendContent(const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize)</span>
132 {
<a name="22" id="anc22"></a><span class="line-modified">133     ASSERT(!isClosed());</span>
<span class="line-modified">134 </span>
<span class="line-removed">135     // Append this text run to the end of the last text run, if the last run is continuous.</span>
<span class="line-removed">136     Optional&lt;InlineRun::TextContext&gt; textRun;</span>
<span class="line-removed">137     if (run.isText()) {</span>
<span class="line-removed">138         auto textContext = run.textContext();</span>
<span class="line-removed">139         auto runLength = textContext-&gt;isCollapsed() ? 1 : textContext-&gt;length();</span>
<span class="line-removed">140         textRun = InlineRun::TextContext { textContext-&gt;start(), runLength };</span>
<span class="line-removed">141     }</span>
<span class="line-removed">142 </span>
<span class="line-removed">143     auto requiresNewInlineRun = !hasContent() || !run.isText() || !m_lastRunCanExpand;</span>
<span class="line-removed">144     if (requiresNewInlineRun) {</span>
<span class="line-removed">145         // FIXME: This needs proper baseline handling</span>
<span class="line-removed">146         auto inlineRun = InlineRun { { logicalTop(), contentLogicalRight(), runSize.width(), runSize.height() }, run.inlineItem() };</span>
<span class="line-removed">147         if (textRun)</span>
<span class="line-removed">148             inlineRun.setTextContext({ textRun-&gt;start(), textRun-&gt;length() });</span>
<span class="line-removed">149         m_inlineRuns.append(inlineRun);</span>
<span class="line-removed">150         m_logicalRect.setHeight(std::max(runSize.height(), m_logicalRect.height()));</span>
<span class="line-removed">151     } else {</span>
<span class="line-removed">152         // Non-text runs always require new inline run.</span>
<span class="line-removed">153         ASSERT(textRun);</span>
<span class="line-removed">154         auto&amp; inlineRun = m_inlineRuns.last();</span>
<span class="line-removed">155         ASSERT(runSize.height() == inlineRun.logicalHeight());</span>
<span class="line-removed">156         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + runSize.width());</span>
<span class="line-removed">157         inlineRun.textContext()-&gt;setLength(inlineRun.textContext()-&gt;length() + textRun-&gt;length());</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     m_availableWidth -= runSize.width();</span>
<span class="line-removed">161     m_lastRunType = run.type();</span>
<span class="line-removed">162     m_lastRunCanExpand = run.isText() &amp;&amp; !run.textContext()-&gt;isCollapsed();</span>
<span class="line-removed">163     m_trailingTrimmableContent = { };</span>
<span class="line-removed">164     if (isTrimmableContent(run))</span>
<span class="line-removed">165         m_trailingTrimmableContent = TrailingTrimmableContent { runSize.width(), textRun-&gt;length() };</span>
166 }
167 
<a name="23" id="anc23"></a><span class="line-modified">168 void Line::close()</span>
169 {
<a name="24" id="anc24"></a><span class="line-modified">170     auto trimTrailingContent = [&amp;] {</span>
<span class="line-modified">171         if (!m_trailingTrimmableContent)</span>
<span class="line-removed">172             return;</span>
<span class="line-removed">173         auto&amp; lastInlineRun = m_inlineRuns.last();</span>
<span class="line-removed">174         lastInlineRun.setLogicalWidth(lastInlineRun.logicalWidth() - m_trailingTrimmableContent-&gt;width);</span>
<span class="line-removed">175         lastInlineRun.textContext()-&gt;setLength(lastInlineRun.textContext()-&gt;length() - m_trailingTrimmableContent-&gt;length);</span>
<span class="line-removed">176 </span>
<span class="line-removed">177         if (!lastInlineRun.textContext()-&gt;length())</span>
<span class="line-removed">178             m_inlineRuns.removeLast();</span>
<span class="line-removed">179         m_availableWidth += m_trailingTrimmableContent-&gt;width;</span>
<span class="line-removed">180         m_trailingTrimmableContent = { };</span>
<span class="line-removed">181     };</span>
<span class="line-removed">182 </span>
<span class="line-removed">183     if (!hasContent())</span>
<span class="line-removed">184         return;</span>
<span class="line-removed">185 </span>
<span class="line-removed">186     trimTrailingContent();</span>
<span class="line-removed">187     m_isFirstLine = false;</span>
<span class="line-removed">188     m_closed = true;</span>
189 }
190 
<a name="25" id="anc25"></a><span class="line-modified">191 InlineFormattingContext::LineLayout::LineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-modified">192     : m_formattingContext(inlineFormattingContext)</span>
<span class="line-modified">193     , m_formattingState(m_formattingContext.formattingState())</span>
<span class="line-modified">194     , m_floatingState(m_formattingState.floatingState())</span>
<span class="line-modified">195     , m_formattingRoot(downcast&lt;Container&gt;(m_formattingContext.root()))</span>
196 {
197 }
198 
<a name="26" id="anc26"></a><span class="line-modified">199 static bool isTrimmableContent(const InlineLineBreaker::Run&amp; run)</span>
200 {
<a name="27" id="anc27"></a><span class="line-modified">201     return run.content.isWhitespace() &amp;&amp; run.content.style().collapseWhiteSpace();</span>





202 }
203 
<a name="28" id="anc28"></a><span class="line-modified">204 void InlineFormattingContext::LineLayout::layout(const InlineRunProvider&amp; inlineRunProvider) const</span>
205 {
<a name="29" id="anc29"></a><span class="line-modified">206     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">207     auto floatingContext = FloatingContext { m_floatingState };</span>

208 
<a name="30" id="anc30"></a><span class="line-modified">209     Line line;</span>
<span class="line-modified">210     initializeNewLine(line);</span>


211 
<a name="31" id="anc31"></a><span class="line-modified">212     InlineLineBreaker lineBreaker(layoutState, m_formattingState.inlineContent(), inlineRunProvider.runs());</span>
<span class="line-modified">213     while (auto run = lineBreaker.nextRun(line.contentLogicalRight(), line.availableWidth(), !line.hasContent())) {</span>
<span class="line-modified">214         auto isFirstRun = run-&gt;position == InlineLineBreaker::Run::Position::LineBegin;</span>
<span class="line-removed">215         auto isLastRun = run-&gt;position == InlineLineBreaker::Run::Position::LineEnd;</span>
<span class="line-removed">216         auto generatesInlineRun = true;</span>
217 
<a name="32" id="anc32"></a><span class="line-modified">218         // Position float and adjust the runs on line.</span>
<span class="line-modified">219         if (run-&gt;content.isFloat()) {</span>
<span class="line-modified">220             auto&amp; floatBox = run-&gt;content.inlineItem().layoutBox();</span>
<span class="line-modified">221             computeFloatPosition(floatingContext, line, floatBox);</span>
<span class="line-modified">222             m_floatingState.append(floatBox);</span>























223 
<a name="33" id="anc33"></a><span class="line-modified">224             auto floatBoxWidth = layoutState.displayBoxForLayoutBox(floatBox).marginBox().width();</span>
<span class="line-modified">225             // Shrink availble space for current line and move existing inline runs.</span>
<span class="line-modified">226             floatBox.isLeftFloatingPositioned() ? line.adjustLogicalLeft(floatBoxWidth) : line.adjustLogicalRight(floatBoxWidth);</span>









227 
<a name="34" id="anc34"></a><span class="line-modified">228             generatesInlineRun = false;</span>
<span class="line-modified">229         }</span>

230 
<a name="35" id="anc35"></a><span class="line-modified">231         // 1. Initialize new line if needed.</span>
<span class="line-modified">232         // 2. Append inline run unless it is skipped.</span>
<span class="line-removed">233         // 3. Close current line if needed.</span>
<span class="line-removed">234         if (isFirstRun) {</span>
<span class="line-removed">235             // When the first run does not generate an actual inline run, the next run comes in first-run as well.</span>
<span class="line-removed">236             // No need to spend time on closing/initializing.</span>
<span class="line-removed">237             // Skip leading whitespace.</span>
<span class="line-removed">238             if (!generatesInlineRun || isTrimmableContent(*run))</span>
<span class="line-removed">239                 continue;</span>
<span class="line-removed">240 </span>
<span class="line-removed">241             if (line.hasContent()) {</span>
<span class="line-removed">242                 // Previous run ended up being at the line end. Adjust the line accordingly.</span>
<span class="line-removed">243                 if (!line.isClosed())</span>
<span class="line-removed">244                     closeLine(line, IsLastLine::No);</span>
<span class="line-removed">245                 initializeNewLine(line);</span>
<span class="line-removed">246             }</span>
<span class="line-removed">247         }</span>
248 
<a name="36" id="anc36"></a><span class="line-modified">249         if (generatesInlineRun) {</span>
<span class="line-modified">250             auto width = run-&gt;width;</span>
<span class="line-modified">251             auto height = run-&gt;content.isText() ? LayoutUnit(m_formattingRoot.style().computedLineHeight()) : layoutState.displayBoxForLayoutBox(run-&gt;content.inlineItem().layoutBox()).height();</span>
<span class="line-modified">252             appendContentToLine(line, run-&gt;content, { width, height });</span>
<span class="line-modified">253         }</span>














254 
<a name="37" id="anc37"></a><span class="line-modified">255         if (isLastRun)</span>
<span class="line-modified">256             closeLine(line, IsLastLine::No);</span>

257     }
<a name="38" id="anc38"></a>










258 
<a name="39" id="anc39"></a><span class="line-modified">259     closeLine(line, IsLastLine::Yes);</span>



260 }
261 
<a name="40" id="anc40"></a><span class="line-modified">262 void InlineFormattingContext::LineLayout::initializeNewLine(Line&amp; line) const</span>
263 {
<a name="41" id="anc41"></a><span class="line-modified">264     auto&amp; formattingRootDisplayBox = m_formattingContext.layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>

265 
<a name="42" id="anc42"></a>
266     auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();
<a name="43" id="anc43"></a><span class="line-removed">267     auto lineLogicalTop = line.isFirstLine() ? formattingRootDisplayBox.contentBoxTop() : line.logicalBottom();</span>
<span class="line-removed">268     auto availableWidth = formattingRootDisplayBox.contentBoxWidth();</span>
269 
<a name="44" id="anc44"></a><span class="line-modified">270     // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">271     if (!m_floatingState.isEmpty()) {</span>
<span class="line-modified">272         auto floatConstraints = m_floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>




273         // Check if these constraints actually put limitation on the line.
<a name="45" id="anc45"></a><span class="line-modified">274         if (floatConstraints.left &amp;&amp; *floatConstraints.left &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
275             floatConstraints.left = { };
276 
<a name="46" id="anc46"></a><span class="line-modified">277         if (floatConstraints.right &amp;&amp; *floatConstraints.right &gt;= formattingRootDisplayBox.contentBoxRight())</span>
278             floatConstraints.right = { };
279 
<a name="47" id="anc47"></a>





280         if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<a name="48" id="anc48"></a><span class="line-modified">281             ASSERT(*floatConstraints.left &lt; *floatConstraints.right);</span>
<span class="line-modified">282             availableWidth = *floatConstraints.right - *floatConstraints.left;</span>
<span class="line-modified">283             lineLogicalLeft = *floatConstraints.left;</span>
284         } else if (floatConstraints.left) {
<a name="49" id="anc49"></a><span class="line-modified">285             ASSERT(*floatConstraints.left &gt; lineLogicalLeft);</span>
<span class="line-modified">286             availableWidth -= (*floatConstraints.left - lineLogicalLeft);</span>
<span class="line-modified">287             lineLogicalLeft = *floatConstraints.left;</span>
288         } else if (floatConstraints.right) {
<a name="50" id="anc50"></a><span class="line-modified">289             ASSERT(*floatConstraints.right &gt; lineLogicalLeft);</span>
<span class="line-modified">290             availableWidth = *floatConstraints.right - lineLogicalLeft;</span>
291         }
<a name="51" id="anc51"></a><span class="line-modified">292     }</span>
<span class="line-modified">293 </span>
<span class="line-removed">294     line.init({ lineLogicalLeft, lineLogicalTop }, availableWidth, m_formattingRoot.style().computedLineHeight());</span>
<span class="line-removed">295 }</span>
<span class="line-removed">296 </span>
<span class="line-removed">297 void InlineFormattingContext::LineLayout::splitInlineRunIfNeeded(const InlineRun&amp; inlineRun, InlineRuns&amp; splitRuns) const</span>
<span class="line-removed">298 {</span>
<span class="line-removed">299     ASSERT(inlineRun.textContext());</span>
<span class="line-removed">300     ASSERT(inlineRun.overlapsMultipleInlineItems());</span>
<span class="line-removed">301     // In certain cases, a run can overlap multiple inline elements like this:</span>
<span class="line-removed">302     // &lt;span&gt;normal text content&lt;/span&gt;&lt;span style=&quot;position: relative; left: 10px;&quot;&gt;but this one needs a dedicated run&lt;/span&gt;&lt;span&gt;end of text&lt;/span&gt;</span>
<span class="line-removed">303     // The content above generates one long run &lt;normal text contentbut this one needs dedicated runend of text&gt;</span>
<span class="line-removed">304     // However, since the middle run is positioned, it needs to be moved independently from the rest of the content, hence it needs a dedicated inline run.</span>
<span class="line-removed">305 </span>
<span class="line-removed">306     // 1. Start with the first inline item (element) and travers the list until</span>
<span class="line-removed">307     // 2. either find an inline item that needs a dedicated run or we reach the end of the run</span>
<span class="line-removed">308     // 3. Create dedicate inline runs.</span>
<span class="line-removed">309     auto&amp; inlineContent = m_formattingState.inlineContent();</span>
<span class="line-removed">310     auto contentStart = inlineRun.logicalLeft();</span>
<span class="line-removed">311     auto startPosition = inlineRun.textContext()-&gt;start();</span>
<span class="line-removed">312     auto remaningLength = inlineRun.textContext()-&gt;length();</span>
<span class="line-removed">313 </span>
<span class="line-removed">314     struct Uncommitted {</span>
<span class="line-removed">315         const InlineItem* firstInlineItem { nullptr };</span>
<span class="line-removed">316         const InlineItem* lastInlineItem { nullptr };</span>
<span class="line-removed">317         unsigned length { 0 };</span>
<span class="line-removed">318     };</span>
<span class="line-removed">319     Optional&lt;Uncommitted&gt; uncommitted;</span>
<span class="line-removed">320 </span>
<span class="line-removed">321     auto commit = [&amp;] {</span>
<span class="line-removed">322         if (!uncommitted)</span>
<span class="line-removed">323             return;</span>
<span class="line-removed">324 </span>
<span class="line-removed">325         contentStart += uncommitted-&gt;firstInlineItem-&gt;nonBreakableStart();</span>
<span class="line-removed">326 </span>
<span class="line-removed">327         auto runWidth = this-&gt;runWidth(inlineContent, *uncommitted-&gt;firstInlineItem, startPosition, uncommitted-&gt;length, contentStart);</span>
<span class="line-removed">328         auto run = InlineRun { { inlineRun.logicalTop(), contentStart, runWidth, inlineRun.logicalHeight() }, *uncommitted-&gt;firstInlineItem };</span>
<span class="line-removed">329         run.setTextContext({ startPosition, uncommitted-&gt;length });</span>
<span class="line-removed">330         splitRuns.append(run);</span>
<span class="line-removed">331 </span>
<span class="line-removed">332         contentStart += runWidth + uncommitted-&gt;lastInlineItem-&gt;nonBreakableEnd();</span>
<span class="line-removed">333 </span>
<span class="line-removed">334         startPosition = 0;</span>
<span class="line-removed">335         uncommitted = { };</span>
336     };
337 
<a name="52" id="anc52"></a><span class="line-modified">338     for (auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineRun.inlineItem())); iterator != inlineContent.end() &amp;&amp; remaningLength &gt; 0; ++iterator) {</span>
<span class="line-modified">339         auto&amp; inlineItem = **iterator;</span>
<span class="line-modified">340 </span>
<span class="line-modified">341         // Skip all non-inflow boxes (floats, out-of-flow positioned elements). They don&#39;t participate in the inline run context.</span>
<span class="line-modified">342         if (!inlineItem.layoutBox().isInFlow())</span>
<span class="line-modified">343             continue;</span>
<span class="line-modified">344 </span>
<span class="line-modified">345         auto currentLength = [&amp;] {</span>
<span class="line-modified">346             return std::min(remaningLength, inlineItem.textContent().length() - startPosition);</span>
<span class="line-modified">347         };</span>
<span class="line-modified">348 </span>
<span class="line-modified">349         // 1. Break before/after -&gt; requires dedicated run -&gt; commit what we&#39;ve got so far and also commit the current inline element as a separate inline run.</span>
<span class="line-modified">350         // 2. Break at the beginning of the inline element -&gt; commit what we&#39;ve got so far. Current element becomes the first uncommitted.</span>
<span class="line-modified">351         // 3. Break at the end of the inline element -&gt; commit what we&#39;ve got so far including the current element.</span>
<span class="line-removed">352         // 4. Inline element does not require run breaking -&gt; add current inline element to uncommitted. Jump to the next element.</span>
<span class="line-removed">353         auto detachingRules = inlineItem.detachingRules();</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         // #1</span>
<span class="line-removed">356         if (detachingRules.containsAll({ InlineItem::DetachingRule::BreakAtStart, InlineItem::DetachingRule::BreakAtEnd })) {</span>
<span class="line-removed">357             commit();</span>
<span class="line-removed">358             auto contentLength = currentLength();</span>
<span class="line-removed">359             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, contentLength };</span>
<span class="line-removed">360             remaningLength -= contentLength;</span>
<span class="line-removed">361             commit();</span>
<span class="line-removed">362             continue;</span>
363         }
<a name="53" id="anc53"></a><span class="line-removed">364 </span>
<span class="line-removed">365         // #2</span>
<span class="line-removed">366         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtStart))</span>
<span class="line-removed">367             commit();</span>
<span class="line-removed">368 </span>
<span class="line-removed">369         // Add current inline item to uncommitted.</span>
<span class="line-removed">370         // #3 and #4</span>
<span class="line-removed">371         auto contentLength = currentLength();</span>
<span class="line-removed">372         if (!uncommitted)</span>
<span class="line-removed">373             uncommitted = Uncommitted { &amp;inlineItem, &amp;inlineItem, 0 };</span>
<span class="line-removed">374         uncommitted-&gt;length += contentLength;</span>
<span class="line-removed">375         uncommitted-&gt;lastInlineItem = &amp;inlineItem;</span>
<span class="line-removed">376         remaningLength -= contentLength;</span>
<span class="line-removed">377 </span>
<span class="line-removed">378         // #3</span>
<span class="line-removed">379         if (detachingRules.contains(InlineItem::DetachingRule::BreakAtEnd))</span>
<span class="line-removed">380             commit();</span>
381     }
<a name="54" id="anc54"></a><span class="line-removed">382     // Either all inline elements needed dedicated runs or neither of them.</span>
<span class="line-removed">383     if (!remaningLength || remaningLength == inlineRun.textContext()-&gt;length())</span>
<span class="line-removed">384         return;</span>
<span class="line-removed">385 </span>
<span class="line-removed">386     commit();</span>
387 }
388 
<a name="55" id="anc55"></a><span class="line-modified">389 void InlineFormattingContext::LineLayout::createFinalRuns(Line&amp; line) const</span>
390 {
<a name="56" id="anc56"></a><span class="line-modified">391     for (auto&amp; inlineRun : line.runs()) {</span>
<span class="line-modified">392         if (inlineRun.overlapsMultipleInlineItems()) {</span>
<span class="line-modified">393             InlineRuns splitRuns;</span>
<span class="line-modified">394             splitInlineRunIfNeeded(inlineRun, splitRuns);</span>
<span class="line-modified">395             for (auto&amp; splitRun : splitRuns)</span>
<span class="line-modified">396                 m_formattingState.appendInlineRun(splitRun);</span>
<span class="line-modified">397 </span>
<span class="line-modified">398             if (!splitRuns.isEmpty())</span>
<span class="line-modified">399                 continue;</span>
<span class="line-removed">400         }</span>
<span class="line-removed">401 </span>
<span class="line-removed">402         auto finalRun = [&amp;] {</span>
<span class="line-removed">403             auto&amp; inlineItem = inlineRun.inlineItem();</span>
<span class="line-removed">404             if (inlineItem.detachingRules().isEmpty())</span>
<span class="line-removed">405                 return inlineRun;</span>
<span class="line-removed">406 </span>
<span class="line-removed">407             InlineRun adjustedRun = inlineRun;</span>
<span class="line-removed">408             auto width = inlineRun.logicalWidth() - inlineItem.nonBreakableStart() - inlineItem.nonBreakableEnd();</span>
<span class="line-removed">409             adjustedRun.setLogicalLeft(inlineRun.logicalLeft() + inlineItem.nonBreakableStart());</span>
<span class="line-removed">410             adjustedRun.setLogicalWidth(width);</span>
<span class="line-removed">411             return adjustedRun;</span>
<span class="line-removed">412         };</span>
<span class="line-removed">413 </span>
<span class="line-removed">414         m_formattingState.appendInlineRun(finalRun());</span>
415     }
<a name="57" id="anc57"></a>
416 }
417 
<a name="58" id="anc58"></a><span class="line-modified">418 void InlineFormattingContext::LineLayout::postProcessInlineRuns(Line&amp; line, IsLastLine isLastLine) const</span>
419 {
<a name="59" id="anc59"></a><span class="line-modified">420     alignRuns(m_formattingRoot.style().textAlign(), line, isLastLine);</span>
<span class="line-modified">421     auto firstRunIndex = m_formattingState.inlineRuns().size();</span>
<span class="line-modified">422     createFinalRuns(line);</span>
<span class="line-modified">423 </span>
<span class="line-modified">424     placeInFlowPositionedChildren(firstRunIndex);</span>
<span class="line-modified">425 }</span>









426 
<a name="60" id="anc60"></a><span class="line-modified">427 void InlineFormattingContext::LineLayout::closeLine(Line&amp; line, IsLastLine isLastLine) const</span>
<span class="line-modified">428 {</span>
<span class="line-modified">429     line.close();</span>
<span class="line-modified">430     if (!line.hasContent())</span>
431         return;
<a name="61" id="anc61"></a>
432 
<a name="62" id="anc62"></a><span class="line-modified">433     postProcessInlineRuns(line, isLastLine);</span>
<span class="line-modified">434 }</span>
<span class="line-modified">435 </span>
<span class="line-modified">436 void InlineFormattingContext::LineLayout::appendContentToLine(Line&amp; line, const InlineRunProvider::Run&amp; run, const LayoutSize&amp; runSize) const</span>
<span class="line-modified">437 {</span>
<span class="line-modified">438     auto lastRunType = line.lastRunType();</span>
<span class="line-modified">439     line.appendContent(run, runSize);</span>













440 
<a name="63" id="anc63"></a><span class="line-modified">441     if (m_formattingRoot.style().textAlign() == TextAlignMode::Justify)</span>
<span class="line-modified">442         computeExpansionOpportunities(line, run, lastRunType.valueOr(InlineRunProvider::Run::Type::NonWhitespace));</span>
<span class="line-modified">443 }</span>







444 
<a name="64" id="anc64"></a><span class="line-modified">445 void InlineFormattingContext::LineLayout::computeFloatPosition(const FloatingContext&amp; floatingContext, Line&amp; line, const Box&amp; floatBox) const</span>
<span class="line-modified">446 {</span>
<span class="line-modified">447     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">448     ASSERT(layoutState.hasDisplayBox(floatBox));</span>
<span class="line-modified">449     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(floatBox);</span>
<span class="line-modified">450 </span>
<span class="line-removed">451     // Set static position first.</span>
<span class="line-removed">452     displayBox.setTopLeft({ line.contentLogicalRight(), line.logicalTop() });</span>
<span class="line-removed">453     // Float it.</span>
<span class="line-removed">454     displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-removed">455 }</span>
456 
<a name="65" id="anc65"></a><span class="line-modified">457 void InlineFormattingContext::LineLayout::placeInFlowPositionedChildren(unsigned fistRunIndex) const</span>
<span class="line-modified">458 {</span>
<span class="line-modified">459     auto&amp; layoutState = m_formattingContext.layoutState();</span>
<span class="line-modified">460     auto&amp; inlineRuns = m_formattingState.inlineRuns();</span>
<span class="line-modified">461     for (auto runIndex = fistRunIndex; runIndex &lt; inlineRuns.size(); ++runIndex) {</span>
<span class="line-modified">462         auto&amp; inlineRun = inlineRuns[runIndex];</span>
<span class="line-removed">463 </span>
<span class="line-removed">464         auto positionOffset = [&amp;](auto&amp; layoutBox) {</span>
<span class="line-removed">465             // FIXME: Need to figure out whether in-flow offset should stick. This might very well be temporary.</span>
<span class="line-removed">466             Optional&lt;LayoutSize&gt; offset;</span>
<span class="line-removed">467             for (auto* box = &amp;layoutBox; box != &amp;m_formattingRoot; box = box-&gt;parent()) {</span>
<span class="line-removed">468                 if (!box-&gt;isInFlowPositioned())</span>
<span class="line-removed">469                     continue;</span>
<span class="line-removed">470                 offset = offset.valueOr(LayoutSize()) + Geometry::inFlowPositionedPositionOffset(layoutState, *box);</span>
471             }
<a name="66" id="anc66"></a><span class="line-modified">472             return offset;</span>
<span class="line-modified">473         };</span>






474 
<a name="67" id="anc67"></a><span class="line-modified">475         if (auto offset = positionOffset(inlineRun.inlineItem().layoutBox())) {</span>
<span class="line-modified">476             inlineRun.moveVertically(offset-&gt;height());</span>
<span class="line-modified">477             inlineRun.moveHorizontally(offset-&gt;width());</span>























478         }
479     }
<a name="68" id="anc68"></a>


480 }
481 
<a name="69" id="anc69"></a><span class="line-modified">482 static LayoutUnit adjustedLineLogicalLeft(TextAlignMode align, LayoutUnit lineLogicalLeft, LayoutUnit remainingWidth)</span>
483 {
484     switch (align) {
485     case TextAlignMode::Left:
486     case TextAlignMode::WebKitLeft:
487     case TextAlignMode::Start:
<a name="70" id="anc70"></a><span class="line-modified">488         return lineLogicalLeft;</span>
489     case TextAlignMode::Right:
490     case TextAlignMode::WebKitRight:
491     case TextAlignMode::End:
<a name="71" id="anc71"></a><span class="line-modified">492         return lineLogicalLeft + std::max(remainingWidth, 0_lu);</span>
493     case TextAlignMode::Center:
494     case TextAlignMode::WebKitCenter:
<a name="72" id="anc72"></a><span class="line-modified">495         return lineLogicalLeft + std::max(remainingWidth / 2, 0_lu);</span>
496     case TextAlignMode::Justify:
497         ASSERT_NOT_REACHED();
498         break;
499     }
500     ASSERT_NOT_REACHED();
<a name="73" id="anc73"></a><span class="line-modified">501     return lineLogicalLeft;</span>
<span class="line-removed">502 }</span>
<span class="line-removed">503 </span>
<span class="line-removed">504 void InlineFormattingContext::LineLayout::justifyRuns(Line&amp; line)</span>
<span class="line-removed">505 {</span>
<span class="line-removed">506     auto&amp; inlineRuns = line.runs();</span>
<span class="line-removed">507     auto&amp; lastInlineRun = inlineRuns.last();</span>
<span class="line-removed">508 </span>
<span class="line-removed">509     // Adjust (forbid) trailing expansion for the last text run on line.</span>
<span class="line-removed">510     auto expansionBehavior = lastInlineRun.expansionOpportunity().behavior;</span>
<span class="line-removed">511     // Remove allow and add forbid.</span>
<span class="line-removed">512     expansionBehavior ^= AllowTrailingExpansion;</span>
<span class="line-removed">513     expansionBehavior |= ForbidTrailingExpansion;</span>
<span class="line-removed">514     lastInlineRun.expansionOpportunity().behavior = expansionBehavior;</span>
<span class="line-removed">515 </span>
<span class="line-removed">516     // Collect expansion opportunities and justify the runs.</span>
<span class="line-removed">517     auto widthToDistribute = line.availableWidth();</span>
<span class="line-removed">518     if (widthToDistribute &lt;= 0)</span>
<span class="line-removed">519         return;</span>
<span class="line-removed">520 </span>
<span class="line-removed">521     auto expansionOpportunities = 0;</span>
<span class="line-removed">522     for (auto&amp; inlineRun : inlineRuns)</span>
<span class="line-removed">523         expansionOpportunities += inlineRun.expansionOpportunity().count;</span>
<span class="line-removed">524 </span>
<span class="line-removed">525     if (!expansionOpportunities)</span>
<span class="line-removed">526         return;</span>
<span class="line-removed">527 </span>
<span class="line-removed">528     float expansion = widthToDistribute.toFloat() / expansionOpportunities;</span>
<span class="line-removed">529     LayoutUnit accumulatedExpansion;</span>
<span class="line-removed">530     for (auto&amp; inlineRun : inlineRuns) {</span>
<span class="line-removed">531         auto expansionForRun = inlineRun.expansionOpportunity().count * expansion;</span>
<span class="line-removed">532 </span>
<span class="line-removed">533         inlineRun.expansionOpportunity().expansion = expansionForRun;</span>
<span class="line-removed">534         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + accumulatedExpansion);</span>
<span class="line-removed">535         inlineRun.setLogicalWidth(inlineRun.logicalWidth() + expansionForRun);</span>
<span class="line-removed">536         accumulatedExpansion += expansionForRun;</span>
<span class="line-removed">537     }</span>
<span class="line-removed">538 }</span>
<span class="line-removed">539 </span>
<span class="line-removed">540 void InlineFormattingContext::LineLayout::computeExpansionOpportunities(Line&amp; line, const InlineRunProvider::Run&amp; run, InlineRunProvider::Run::Type lastRunType) const</span>
<span class="line-removed">541 {</span>
<span class="line-removed">542     auto isExpansionOpportunity = [](auto currentRunIsWhitespace, auto lastRunIsWhitespace) {</span>
<span class="line-removed">543         return currentRunIsWhitespace || (!currentRunIsWhitespace &amp;&amp; !lastRunIsWhitespace);</span>
<span class="line-removed">544     };</span>
<span class="line-removed">545 </span>
<span class="line-removed">546     auto expansionBehavior = [](auto isAtExpansionOpportunity) {</span>
<span class="line-removed">547         ExpansionBehavior expansionBehavior = AllowTrailingExpansion;</span>
<span class="line-removed">548         expansionBehavior |= isAtExpansionOpportunity ? ForbidLeadingExpansion : AllowLeadingExpansion;</span>
<span class="line-removed">549         return expansionBehavior;</span>
<span class="line-removed">550     };</span>
<span class="line-removed">551 </span>
<span class="line-removed">552     auto isAtExpansionOpportunity = isExpansionOpportunity(run.isWhitespace(), lastRunType == InlineRunProvider::Run::Type::Whitespace);</span>
<span class="line-removed">553 </span>
<span class="line-removed">554     auto&amp; currentInlineRun = line.runs().last();</span>
<span class="line-removed">555     auto&amp; expansionOpportunity = currentInlineRun.expansionOpportunity();</span>
<span class="line-removed">556     if (isAtExpansionOpportunity)</span>
<span class="line-removed">557         ++expansionOpportunity.count;</span>
<span class="line-removed">558 </span>
<span class="line-removed">559     expansionOpportunity.behavior = expansionBehavior(isAtExpansionOpportunity);</span>
560 }
561 
<a name="74" id="anc74"></a><span class="line-modified">562 void InlineFormattingContext::LineLayout::alignRuns(TextAlignMode textAlign, Line&amp; line,  IsLastLine isLastLine) const</span>
563 {
<a name="75" id="anc75"></a><span class="line-modified">564     auto adjutedTextAlignment = textAlign != TextAlignMode::Justify ? textAlign : isLastLine == IsLastLine::No ? TextAlignMode::Justify : TextAlignMode::Left;</span>
<span class="line-modified">565     if (adjutedTextAlignment == TextAlignMode::Justify) {</span>
<span class="line-removed">566         justifyRuns(line);</span>
567         return;
<a name="76" id="anc76"></a><span class="line-removed">568     }</span>
<span class="line-removed">569 </span>
<span class="line-removed">570     auto lineLogicalLeft = line.contentLogicalLeft();</span>
<span class="line-removed">571     auto adjustedLogicalLeft = adjustedLineLogicalLeft(adjutedTextAlignment, lineLogicalLeft, line.availableWidth());</span>
<span class="line-removed">572     if (adjustedLogicalLeft == lineLogicalLeft)</span>
<span class="line-removed">573         return;</span>
<span class="line-removed">574 </span>
<span class="line-removed">575     auto delta = adjustedLogicalLeft - lineLogicalLeft;</span>
<span class="line-removed">576     for (auto&amp; inlineRun : line.runs())</span>
<span class="line-removed">577         inlineRun.setLogicalLeft(inlineRun.logicalLeft() + delta);</span>
<span class="line-removed">578 }</span>
579 
<a name="77" id="anc77"></a><span class="line-modified">580 LayoutUnit InlineFormattingContext::LineLayout::runWidth(const InlineContent&amp; inlineContent, const InlineItem&amp; inlineItem, ItemPosition from, unsigned length, LayoutUnit contentLogicalLeft) const</span>
<span class="line-modified">581 {</span>
<span class="line-removed">582     LayoutUnit width;</span>
<span class="line-removed">583     auto startPosition = from;</span>
<span class="line-removed">584     auto iterator = inlineContent.find(const_cast&lt;InlineItem*&gt;(&amp;inlineItem));</span>
<span class="line-removed">585 #if !ASSERT_DISABLED</span>
<span class="line-removed">586     auto inlineItemEnd = inlineContent.end();</span>
<span class="line-removed">587 #endif</span>
<span class="line-removed">588     while (length) {</span>
<span class="line-removed">589         ASSERT(iterator != inlineItemEnd);</span>
<span class="line-removed">590         auto&amp; currentInlineItem = **iterator;</span>
<span class="line-removed">591         auto endPosition = std::min&lt;ItemPosition&gt;(startPosition + length, currentInlineItem.textContent().length());</span>
<span class="line-removed">592         auto textWidth = TextUtil::width(currentInlineItem, startPosition, endPosition, contentLogicalLeft);</span>
<span class="line-removed">593 </span>
<span class="line-removed">594         contentLogicalLeft += textWidth;</span>
<span class="line-removed">595         width += textWidth;</span>
<span class="line-removed">596         length -= (endPosition - startPosition);</span>
<span class="line-removed">597 </span>
<span class="line-removed">598         startPosition = 0;</span>
<span class="line-removed">599         ++iterator;</span>
<span class="line-removed">600     }</span>
<span class="line-removed">601     return width;</span>
602 }
603 
604 }
605 }
606 
607 #endif
<a name="78" id="anc78"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="78" type="hidden" />
</body>
</html>