<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AST/WHLSLWhileLoop.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 


 31 #include &quot;WHLSLGatherEntryPointItems.h&quot;










 32 
 33 namespace WebCore {
 34 
 35 namespace WHLSL {
 36 
 37 namespace Metal {
 38 
<span class="line-modified"> 39 EntryPointScaffolding::EntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics)</span>
<span class="line-removed"> 40     : m_functionDefinition(&amp;functionDefinition)</span>
<span class="line-removed"> 41     , m_intrinsics(&amp;intrinsics)</span>
 42 {
<span class="line-modified"> 43     // FIXME: Implement this.</span>
<span class="line-modified"> 44     gatherEntryPointItems(*m_intrinsics, *m_functionDefinition);</span>





























 45 }
 46 
<span class="line-modified"> 47 String EntryPointScaffolding::helperTypes()</span>
 48 {
<span class="line-modified"> 49     // FIXME: Implement this.</span>
<span class="line-modified"> 50     return String();</span>


 51 }
 52 
<span class="line-modified"> 53 String EntryPointScaffolding::signature()</span>







 54 {
<span class="line-modified"> 55     // FIXME: Implement this.</span>
<span class="line-modified"> 56     return String();</span>







































































































































































































































































































































































































































































































 57 }
 58 
<span class="line-modified"> 59 String EntryPointScaffolding::unpack()</span>
 60 {
<span class="line-modified"> 61     // FIXME: Implement this.</span>
<span class="line-removed"> 62     return String();</span>
 63 }
 64 
<span class="line-modified"> 65 String EntryPointScaffolding::pack(const String&amp;, const String&amp;)</span>
 66 {
<span class="line-modified"> 67     // FIXME: Implement this.</span>
<span class="line-removed"> 68     return String();</span>
 69 }
 70 
 71 }
 72 
 73 }
 74 
 75 }
 76 
 77 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<span class="line-added"> 31 #include &quot;WHLSLBuiltInSemantic.h&quot;</span>
<span class="line-added"> 32 #include &quot;WHLSLFunctionDefinition.h&quot;</span>
 33 #include &quot;WHLSLGatherEntryPointItems.h&quot;
<span class="line-added"> 34 #include &quot;WHLSLPipelineDescriptor.h&quot;</span>
<span class="line-added"> 35 #include &quot;WHLSLReferenceType.h&quot;</span>
<span class="line-added"> 36 #include &quot;WHLSLResourceSemantic.h&quot;</span>
<span class="line-added"> 37 #include &quot;WHLSLStageInOutSemantic.h&quot;</span>
<span class="line-added"> 38 #include &quot;WHLSLStructureDefinition.h&quot;</span>
<span class="line-added"> 39 #include &quot;WHLSLTypeNamer.h&quot;</span>
<span class="line-added"> 40 #include &lt;algorithm&gt;</span>
<span class="line-added"> 41 #include &lt;wtf/Optional.h&gt;</span>
<span class="line-added"> 42 #include &lt;wtf/text/StringBuilder.h&gt;</span>
<span class="line-added"> 43 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
 44 
 45 namespace WebCore {
 46 
 47 namespace WHLSL {
 48 
 49 namespace Metal {
 50 
<span class="line-modified"> 51 static String attributeForSemantic(AST::BuiltInSemantic&amp; builtInSemantic)</span>


 52 {
<span class="line-modified"> 53     switch (builtInSemantic.variable()) {</span>
<span class="line-modified"> 54     case AST::BuiltInSemantic::Variable::SVInstanceID:</span>
<span class="line-added"> 55         return &quot;[[instance_id]]&quot;_str;</span>
<span class="line-added"> 56     case AST::BuiltInSemantic::Variable::SVVertexID:</span>
<span class="line-added"> 57         return &quot;[[vertex_id]]&quot;_str;</span>
<span class="line-added"> 58     case AST::BuiltInSemantic::Variable::PSize:</span>
<span class="line-added"> 59         return &quot;[[point_size]]&quot;_str;</span>
<span class="line-added"> 60     case AST::BuiltInSemantic::Variable::SVPosition:</span>
<span class="line-added"> 61         return &quot;[[position]]&quot;_str;</span>
<span class="line-added"> 62     case AST::BuiltInSemantic::Variable::SVIsFrontFace:</span>
<span class="line-added"> 63         return &quot;[[front_facing]]&quot;_str;</span>
<span class="line-added"> 64     case AST::BuiltInSemantic::Variable::SVSampleIndex:</span>
<span class="line-added"> 65         return &quot;[[sample_id]]&quot;_str;</span>
<span class="line-added"> 66     case AST::BuiltInSemantic::Variable::SVInnerCoverage:</span>
<span class="line-added"> 67         return &quot;[[sample_mask]]&quot;_str;</span>
<span class="line-added"> 68     case AST::BuiltInSemantic::Variable::SVTarget:</span>
<span class="line-added"> 69         return makeString(&quot;[[color(&quot;, *builtInSemantic.targetIndex(), &quot;)]]&quot;);</span>
<span class="line-added"> 70     case AST::BuiltInSemantic::Variable::SVDepth:</span>
<span class="line-added"> 71         return &quot;[[depth(any)]]&quot;_str;</span>
<span class="line-added"> 72     case AST::BuiltInSemantic::Variable::SVCoverage:</span>
<span class="line-added"> 73         return &quot;[[sample_mask]]&quot;_str;</span>
<span class="line-added"> 74     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:</span>
<span class="line-added"> 75         return &quot;[[thread_position_in_grid]]&quot;_str;</span>
<span class="line-added"> 76     case AST::BuiltInSemantic::Variable::SVGroupID:</span>
<span class="line-added"> 77         return &quot;[[threadgroup_position_in_grid]]&quot;_str;</span>
<span class="line-added"> 78     case AST::BuiltInSemantic::Variable::SVGroupIndex:</span>
<span class="line-added"> 79         return &quot;[[thread_index_in_threadgroup]]&quot;_str;</span>
<span class="line-added"> 80     default:</span>
<span class="line-added"> 81         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
<span class="line-added"> 82         return &quot;[[thread_position_in_threadgroup]]&quot;_str;</span>
<span class="line-added"> 83     }</span>
 84 }
 85 
<span class="line-modified"> 86 static String attributeForSemantic(AST::Semantic&amp; semantic)</span>
 87 {
<span class="line-modified"> 88     if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))</span>
<span class="line-modified"> 89         return attributeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(semantic));</span>
<span class="line-added"> 90     auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);</span>
<span class="line-added"> 91     return makeString(&quot;[[user(user&quot;, stageInOutSemantic.index(), &quot;)]]&quot;);</span>
 92 }
 93 
<span class="line-modified"> 94 EntryPointScaffolding::EntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)</span>
<span class="line-added"> 95     : m_functionDefinition(functionDefinition)</span>
<span class="line-added"> 96     , m_intrinsics(intrinsics)</span>
<span class="line-added"> 97     , m_typeNamer(typeNamer)</span>
<span class="line-added"> 98     , m_entryPointItems(entryPointItems)</span>
<span class="line-added"> 99     , m_resourceMap(resourceMap)</span>
<span class="line-added">100     , m_layout(layout)</span>
<span class="line-added">101     , m_generateNextVariableName(generateNextVariableName)</span>
102 {
<span class="line-modified">103     m_namedBindGroups.reserveInitialCapacity(m_layout.size());</span>
<span class="line-modified">104     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">105         NamedBindGroup namedBindGroup;</span>
<span class="line-added">106         namedBindGroup.structName = m_typeNamer.generateNextTypeName();</span>
<span class="line-added">107         namedBindGroup.variableName = m_generateNextVariableName();</span>
<span class="line-added">108         namedBindGroup.argumentBufferIndex = m_layout[i].name; // convertLayout() in GPURenderPipelineMetal.mm makes sure these don&#39;t collide.</span>
<span class="line-added">109         namedBindGroup.namedBindings.reserveInitialCapacity(m_layout[i].bindings.size());</span>
<span class="line-added">110         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">111             NamedBinding namedBinding;</span>
<span class="line-added">112             namedBinding.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">113             namedBinding.index = m_layout[i].bindings[j].internalName;</span>
<span class="line-added">114             WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding&amp; uniformBufferBinding) {</span>
<span class="line-added">115                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), uniformBufferBinding.lengthName };</span>
<span class="line-added">116                 namedBinding.lengthInformation = lengthInformation;</span>
<span class="line-added">117             }, [&amp;](SamplerBinding&amp;) {</span>
<span class="line-added">118             }, [&amp;](TextureBinding&amp;) {</span>
<span class="line-added">119             }, [&amp;](StorageBufferBinding&amp; storageBufferBinding) {</span>
<span class="line-added">120                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), storageBufferBinding.lengthName };</span>
<span class="line-added">121                 namedBinding.lengthInformation = lengthInformation;</span>
<span class="line-added">122             }), m_layout[i].bindings[j].binding);</span>
<span class="line-added">123             namedBindGroup.namedBindings.uncheckedAppend(WTFMove(namedBinding));</span>
<span class="line-added">124         }</span>
<span class="line-added">125         m_namedBindGroups.uncheckedAppend(WTFMove(namedBindGroup));</span>
<span class="line-added">126     }</span>
<span class="line-added">127 </span>
<span class="line-added">128     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {</span>
<span class="line-added">129         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*m_entryPointItems.inputs[i].semantic))</span>
<span class="line-added">130             continue;</span>
<span class="line-added">131         NamedBuiltIn namedBuiltIn;</span>
<span class="line-added">132         namedBuiltIn.indexInEntryPointItems = i;</span>
<span class="line-added">133         namedBuiltIn.variableName = m_generateNextVariableName();</span>
<span class="line-added">134         m_namedBuiltIns.append(WTFMove(namedBuiltIn));</span>
<span class="line-added">135     }</span>
<span class="line-added">136 </span>
<span class="line-added">137     m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());</span>
<span class="line-added">138     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)</span>
<span class="line-added">139         m_parameterVariables.uncheckedAppend(m_generateNextVariableName());</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">143 {</span>
<span class="line-added">144     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">145         stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);</span>
<span class="line-added">146         {</span>
<span class="line-added">147             IndentationScope scope(indent);</span>
<span class="line-added">148             Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;</span>
<span class="line-added">149             for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">150                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-added">151                 if (iterator == m_resourceMap.end())</span>
<span class="line-added">152                     continue;</span>
<span class="line-added">153                 auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="line-added">154                 if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="line-added">155                     auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="line-added">156                     auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="line-added">157                     auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="line-added">158                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">159                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-added">160                     structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">161                     if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="line-added">162                         structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="line-added">163                 } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="line-added">164                     auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">165                     auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="line-added">166                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">167                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-added">168                     structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">169                 }</span>
<span class="line-added">170             }</span>
<span class="line-added">171             std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {</span>
<span class="line-added">172                 return left.first &lt; right.first;</span>
<span class="line-added">173             });</span>
<span class="line-added">174             for (const auto&amp; structItem : structItems)</span>
<span class="line-added">175                 stringBuilder.append(indent, structItem.second, &#39;\n&#39;);</span>
<span class="line-added">176         }</span>
<span class="line-added">177         stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">178     }</span>
<span class="line-added">179 }</span>
<span class="line-added">180 </span>
<span class="line-added">181 bool EntryPointScaffolding::emitResourceSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)</span>
<span class="line-added">182 {</span>
<span class="line-added">183     if (!m_layout.size())</span>
<span class="line-added">184         return false;</span>
<span class="line-added">185 </span>
<span class="line-added">186     if (includePrecedingComma == IncludePrecedingComma::Yes)</span>
<span class="line-added">187         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">188 </span>
<span class="line-added">189     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">190         if (i)</span>
<span class="line-added">191             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">192         auto&amp; namedBindGroup = m_namedBindGroups[i];</span>
<span class="line-added">193         stringBuilder.append(&quot;device &quot;, namedBindGroup.structName, &quot;&amp; &quot;, namedBindGroup.variableName, &quot; [[buffer(&quot;, namedBindGroup.argumentBufferIndex, &quot;)]]&quot;);</span>
<span class="line-added">194     }</span>
<span class="line-added">195     return true;</span>
<span class="line-added">196 }</span>
<span class="line-added">197 </span>
<span class="line-added">198 static StringView internalTypeForSemantic(const AST::BuiltInSemantic&amp; builtInSemantic)</span>
<span class="line-added">199 {</span>
<span class="line-added">200     switch (builtInSemantic.variable()) {</span>
<span class="line-added">201     case AST::BuiltInSemantic::Variable::SVInstanceID:</span>
<span class="line-added">202         return &quot;uint&quot;;</span>
<span class="line-added">203     case AST::BuiltInSemantic::Variable::SVVertexID:</span>
<span class="line-added">204         return &quot;uint&quot;;</span>
<span class="line-added">205     case AST::BuiltInSemantic::Variable::PSize:</span>
<span class="line-added">206         return &quot;float&quot;;</span>
<span class="line-added">207     case AST::BuiltInSemantic::Variable::SVPosition:</span>
<span class="line-added">208         return &quot;float4&quot;;</span>
<span class="line-added">209     case AST::BuiltInSemantic::Variable::SVIsFrontFace:</span>
<span class="line-added">210         return &quot;bool&quot;;</span>
<span class="line-added">211     case AST::BuiltInSemantic::Variable::SVSampleIndex:</span>
<span class="line-added">212         return &quot;uint&quot;;</span>
<span class="line-added">213     case AST::BuiltInSemantic::Variable::SVInnerCoverage:</span>
<span class="line-added">214         return &quot;uint&quot;;</span>
<span class="line-added">215     case AST::BuiltInSemantic::Variable::SVTarget:</span>
<span class="line-added">216         return { };</span>
<span class="line-added">217     case AST::BuiltInSemantic::Variable::SVDepth:</span>
<span class="line-added">218         return &quot;float&quot;;</span>
<span class="line-added">219     case AST::BuiltInSemantic::Variable::SVCoverage:</span>
<span class="line-added">220         return &quot;uint&quot;;</span>
<span class="line-added">221     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:</span>
<span class="line-added">222         return &quot;uint3&quot;;</span>
<span class="line-added">223     case AST::BuiltInSemantic::Variable::SVGroupID:</span>
<span class="line-added">224         return &quot;uint3&quot;;</span>
<span class="line-added">225     case AST::BuiltInSemantic::Variable::SVGroupIndex:</span>
<span class="line-added">226         return &quot;uint&quot;;</span>
<span class="line-added">227     default:</span>
<span class="line-added">228         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
<span class="line-added">229         return &quot;uint3&quot;;</span>
<span class="line-added">230     }</span>
<span class="line-added">231 }</span>
<span class="line-added">232 </span>
<span class="line-added">233 bool EntryPointScaffolding::emitBuiltInsSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)</span>
<span class="line-added">234 {</span>
<span class="line-added">235     if (!m_namedBuiltIns.size())</span>
<span class="line-added">236         return false;</span>
<span class="line-added">237 </span>
<span class="line-added">238     if (includePrecedingComma == IncludePrecedingComma::Yes)</span>
<span class="line-added">239         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">240 </span>
<span class="line-added">241     for (size_t i = 0; i &lt; m_namedBuiltIns.size(); ++i) {</span>
<span class="line-added">242         if (i)</span>
<span class="line-added">243             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">244         auto&amp; namedBuiltIn = m_namedBuiltIns[i];</span>
<span class="line-added">245         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];</span>
<span class="line-added">246         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(*item.semantic);</span>
<span class="line-added">247         auto internalType = internalTypeForSemantic(builtInSemantic);</span>
<span class="line-added">248         if (!internalType.isNull())</span>
<span class="line-added">249             stringBuilder.append(internalType);</span>
<span class="line-added">250         else</span>
<span class="line-added">251             stringBuilder.append(m_typeNamer.mangledNameForType(*item.unnamedType));</span>
<span class="line-added">252         stringBuilder.append(&#39; &#39;, namedBuiltIn.variableName, &#39; &#39;, attributeForSemantic(builtInSemantic));</span>
<span class="line-added">253     }</span>
<span class="line-added">254     return true;</span>
<span class="line-added">255 }</span>
<span class="line-added">256 </span>
<span class="line-added">257 void EntryPointScaffolding::emitMangledInputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)</span>
<span class="line-added">258 {</span>
<span class="line-added">259     ASSERT(!path.isEmpty());</span>
<span class="line-added">260     bool found = false;</span>
<span class="line-added">261     AST::StructureDefinition* structureDefinition = nullptr;</span>
<span class="line-added">262     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i) {</span>
<span class="line-added">263         if (m_functionDefinition.parameters()[i]-&gt;name() == path[0]) {</span>
<span class="line-added">264             stringBuilder.append(m_parameterVariables[i]);</span>
<span class="line-added">265             auto&amp; unifyNode = m_functionDefinition.parameters()[i]-&gt;type()-&gt;unifyNode();</span>
<span class="line-added">266             if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">267                 auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">268                 if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">269                     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">270             }</span>
<span class="line-added">271             found = true;</span>
<span class="line-added">272             break;</span>
<span class="line-added">273         }</span>
<span class="line-added">274     }</span>
<span class="line-added">275     ASSERT(found);</span>
<span class="line-added">276     for (size_t i = 1; i &lt; path.size(); ++i) {</span>
<span class="line-added">277         ASSERT(structureDefinition);</span>
<span class="line-added">278         auto* next = structureDefinition-&gt;find(path[i]);</span>
<span class="line-added">279         ASSERT(next);</span>
<span class="line-added">280         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));</span>
<span class="line-added">281         structureDefinition = nullptr;</span>
<span class="line-added">282         auto&amp; unifyNode = next-&gt;type().unifyNode();</span>
<span class="line-added">283         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">284             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">285             if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">286                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">287         }</span>
<span class="line-added">288     }</span>
<span class="line-added">289 }</span>
<span class="line-added">290 </span>
<span class="line-added">291 void EntryPointScaffolding::emitMangledOutputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)</span>
<span class="line-added">292 {</span>
<span class="line-added">293     AST::StructureDefinition* structureDefinition = nullptr;</span>
<span class="line-added">294     auto&amp; unifyNode = m_functionDefinition.type().unifyNode();</span>
<span class="line-added">295     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifyNode));</span>
<span class="line-added">296     for (auto&amp; component : path) {</span>
<span class="line-added">297         ASSERT(structureDefinition);</span>
<span class="line-added">298         auto* next = structureDefinition-&gt;find(component);</span>
<span class="line-added">299         ASSERT(next);</span>
<span class="line-added">300         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));</span>
<span class="line-added">301         structureDefinition = nullptr;</span>
<span class="line-added">302         auto&amp; unifyNode = next-&gt;type().unifyNode();</span>
<span class="line-added">303         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-added">304             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-added">305             if (is&lt;AST::StructureDefinition&gt;(namedType))</span>
<span class="line-added">306                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);</span>
<span class="line-added">307         }</span>
<span class="line-added">308     }</span>
<span class="line-added">309 }</span>
<span class="line-added">310 </span>
<span class="line-added">311 void EntryPointScaffolding::emitUnpackResourcesAndNamedBuiltIns(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">312 {</span>
<span class="line-added">313     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)</span>
<span class="line-added">314         stringBuilder.append(indent, m_typeNamer.mangledNameForType(*m_functionDefinition.parameters()[i]-&gt;type()), &#39; &#39;, m_parameterVariables[i], &quot;;\n&quot;);</span>
<span class="line-added">315 </span>
<span class="line-added">316     for (size_t i = 0; i &lt; m_layout.size(); ++i) {</span>
<span class="line-added">317         auto variableName = m_namedBindGroups[i].variableName;</span>
<span class="line-added">318         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {</span>
<span class="line-added">319             auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-added">320             if (iterator == m_resourceMap.end())</span>
<span class="line-added">321                 continue;</span>
<span class="line-added">322             if (m_namedBindGroups[i].namedBindings[j].lengthInformation) {</span>
<span class="line-added">323                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;</span>
<span class="line-added">324                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">325                 auto lengthElementName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;elementName;</span>
<span class="line-added">326                 auto lengthTemporaryName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;temporaryName;</span>
<span class="line-added">327 </span>
<span class="line-added">328                 auto&amp; unnamedType = *m_entryPointItems.inputs[iterator-&gt;value].unnamedType;</span>
<span class="line-added">329                 auto mangledTypeName = m_typeNamer.mangledNameForType(downcast&lt;AST::ReferenceType&gt;(unnamedType).elementType());</span>
<span class="line-added">330 </span>
<span class="line-added">331                 stringBuilder.append(</span>
<span class="line-added">332                     indent, &quot;size_t &quot;, lengthTemporaryName, &quot; = &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.y;\n&quot;,</span>
<span class="line-added">333                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; &lt;&lt; 32;\n&quot;,</span>
<span class="line-added">334                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; | &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.x;\n&quot;,</span>
<span class="line-added">335                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; / sizeof(&quot;, mangledTypeName, &quot;);\n&quot;,</span>
<span class="line-added">336                     indent, &quot;if (&quot;, lengthTemporaryName, &quot; &gt; 0xFFFFFFFF)\n&quot;,</span>
<span class="line-added">337                     indent, &quot;    &quot;, lengthTemporaryName, &quot; = 0xFFFFFFFF;\n&quot;</span>
<span class="line-added">338                 );</span>
<span class="line-added">339 </span>
<span class="line-added">340                 stringBuilder.append(indent);</span>
<span class="line-added">341                 emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">342                 stringBuilder.append(</span>
<span class="line-added">343                     &quot; = { &quot;, variableName, &#39;.&#39;, elementName, &quot;, static_cast&lt;uint32_t&gt;(&quot;, lengthTemporaryName, &quot;) };\n&quot;</span>
<span class="line-added">344                 );</span>
<span class="line-added">345             } else {</span>
<span class="line-added">346                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;</span>
<span class="line-added">347                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-added">348 </span>
<span class="line-added">349                 stringBuilder.append(indent);</span>
<span class="line-added">350                 emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">351                 stringBuilder.append(&quot; = &quot;, variableName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">352             }</span>
<span class="line-added">353         }</span>
<span class="line-added">354     }</span>
<span class="line-added">355 </span>
<span class="line-added">356     for (auto&amp; namedBuiltIn : m_namedBuiltIns) {</span>
<span class="line-added">357         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];</span>
<span class="line-added">358         auto&amp; path = item.path;</span>
<span class="line-added">359         auto&amp; variableName = namedBuiltIn.variableName;</span>
<span class="line-added">360         auto mangledTypeName = m_typeNamer.mangledNameForType(*item.unnamedType);</span>
<span class="line-added">361 </span>
<span class="line-added">362         stringBuilder.append(indent);</span>
<span class="line-added">363         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">364         stringBuilder.append(&quot; = &quot;, mangledTypeName, &#39;(&#39;, variableName, &quot;);\n&quot;);</span>
<span class="line-added">365     }</span>
<span class="line-added">366 }</span>
<span class="line-added">367 </span>
<span class="line-added">368 VertexEntryPointScaffolding::VertexEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;VertexAttribute*, size_t&gt;&amp; matchedVertexAttributes)</span>
<span class="line-added">369     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">370     , m_matchedVertexAttributes(matchedVertexAttributes)</span>
<span class="line-added">371     , m_stageInStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">372     , m_returnStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">373     , m_stageInParameterName(m_generateNextVariableName())</span>
<span class="line-added">374 {</span>
<span class="line-added">375     m_namedStageIns.reserveInitialCapacity(m_matchedVertexAttributes.size());</span>
<span class="line-added">376     for (auto&amp; keyValuePair : m_matchedVertexAttributes) {</span>
<span class="line-added">377         NamedStageIn namedStageIn;</span>
<span class="line-added">378         namedStageIn.indexInEntryPointItems = keyValuePair.value;</span>
<span class="line-added">379         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">380         namedStageIn.attributeIndex = keyValuePair.key-&gt;metalLocation;</span>
<span class="line-added">381         m_namedStageIns.uncheckedAppend(WTFMove(namedStageIn));</span>
<span class="line-added">382     }</span>
<span class="line-added">383 </span>
<span class="line-added">384     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());</span>
<span class="line-added">385     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">386         auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">387         NamedOutput namedOutput;</span>
<span class="line-added">388         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">389         StringView internalType;</span>
<span class="line-added">390         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))</span>
<span class="line-added">391             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));</span>
<span class="line-added">392         if (!internalType.isNull())</span>
<span class="line-added">393             namedOutput.internalTypeName = internalType.toString();</span>
<span class="line-added">394         else</span>
<span class="line-added">395             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);</span>
<span class="line-added">396         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));</span>
<span class="line-added">397     }</span>
<span class="line-added">398 }</span>
<span class="line-added">399 </span>
<span class="line-added">400 void VertexEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">401 {</span>
<span class="line-added">402     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);</span>
<span class="line-added">403     {</span>
<span class="line-added">404         IndentationScope scope(indent);</span>
<span class="line-added">405         for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">406             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);</span>
<span class="line-added">407             auto elementName = namedStageIn.elementName;</span>
<span class="line-added">408             auto attributeIndex = namedStageIn.attributeIndex;</span>
<span class="line-added">409             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[attribute(&quot;, attributeIndex, &quot;)]];\n&quot;);</span>
<span class="line-added">410         }</span>
<span class="line-added">411     }</span>
<span class="line-added">412     stringBuilder.append(</span>
<span class="line-added">413         indent, &quot;};\n\n&quot;,</span>
<span class="line-added">414         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;</span>
<span class="line-added">415     );</span>
<span class="line-added">416     {</span>
<span class="line-added">417         IndentationScope scope(indent);</span>
<span class="line-added">418         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">419             auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">420             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">421             auto elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">422             auto attribute = attributeForSemantic(*outputItem.semantic);</span>
<span class="line-added">423             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);</span>
<span class="line-added">424         }</span>
<span class="line-added">425     }</span>
<span class="line-added">426     stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">427 </span>
<span class="line-added">428     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">429 }</span>
<span class="line-added">430 </span>
<span class="line-added">431 void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">432 {</span>
<span class="line-added">433     stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);</span>
<span class="line-added">434     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">435     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">436     stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">437 }</span>
<span class="line-added">438 </span>
<span class="line-added">439 void VertexEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">440 {</span>
<span class="line-added">441     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>
<span class="line-added">442 </span>
<span class="line-added">443     for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">444         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;</span>
<span class="line-added">445         auto&amp; elementName = namedStageIn.elementName;</span>
<span class="line-added">446 </span>
<span class="line-added">447         stringBuilder.append(indent);</span>
<span class="line-added">448         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">449         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">450     }</span>
<span class="line-added">451 }</span>
<span class="line-added">452 </span>
<span class="line-added">453 void VertexEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">454 {</span>
<span class="line-added">455     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">456     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {</span>
<span class="line-added">457         auto&amp; elementName = m_namedOutputs[0].elementName;</span>
<span class="line-added">458         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">459         return;</span>
<span class="line-added">460     }</span>
<span class="line-added">461     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">462         auto&amp; elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">463         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">464         auto&amp; path = m_entryPointItems.outputs[i].path;</span>
<span class="line-added">465         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);</span>
<span class="line-added">466         emitMangledOutputPath(stringBuilder, path);</span>
<span class="line-added">467         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">468     }</span>
<span class="line-added">469 }</span>
<span class="line-added">470 </span>
<span class="line-added">471 FragmentEntryPointScaffolding::FragmentEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;AttachmentDescriptor*, size_t&gt;&amp;)</span>
<span class="line-added">472     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">473     , m_stageInStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">474     , m_returnStructName(typeNamer.generateNextTypeName())</span>
<span class="line-added">475     , m_stageInParameterName(m_generateNextVariableName())</span>
<span class="line-added">476 {</span>
<span class="line-added">477     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {</span>
<span class="line-added">478         auto&amp; inputItem = m_entryPointItems.inputs[i];</span>
<span class="line-added">479         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic))</span>
<span class="line-added">480             continue;</span>
<span class="line-added">481         auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic);</span>
<span class="line-added">482         NamedStageIn namedStageIn;</span>
<span class="line-added">483         namedStageIn.indexInEntryPointItems = i;</span>
<span class="line-added">484         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">485         namedStageIn.attributeIndex = stageInOutSemantic.index();</span>
<span class="line-added">486         m_namedStageIns.append(WTFMove(namedStageIn));</span>
<span class="line-added">487     }</span>
<span class="line-added">488 </span>
<span class="line-added">489     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());</span>
<span class="line-added">490     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">491         auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">492         NamedOutput namedOutput;</span>
<span class="line-added">493         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();</span>
<span class="line-added">494         StringView internalType;</span>
<span class="line-added">495         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))</span>
<span class="line-added">496             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));</span>
<span class="line-added">497         if (!internalType.isNull())</span>
<span class="line-added">498             namedOutput.internalTypeName = internalType.toString();</span>
<span class="line-added">499         else</span>
<span class="line-added">500             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);</span>
<span class="line-added">501         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));</span>
<span class="line-added">502     }</span>
<span class="line-added">503 }</span>
<span class="line-added">504 </span>
<span class="line-added">505 void FragmentEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">506 {</span>
<span class="line-added">507     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);</span>
<span class="line-added">508     {</span>
<span class="line-added">509         IndentationScope scope(indent);</span>
<span class="line-added">510         for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">511             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);</span>
<span class="line-added">512             auto elementName = namedStageIn.elementName;</span>
<span class="line-added">513             auto attributeIndex = namedStageIn.attributeIndex;</span>
<span class="line-added">514             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[user(user&quot;, attributeIndex, &quot;)]];\n&quot;);</span>
<span class="line-added">515         }</span>
<span class="line-added">516     }</span>
<span class="line-added">517     stringBuilder.append(</span>
<span class="line-added">518         indent, &quot;};\n\n&quot;,</span>
<span class="line-added">519         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;</span>
<span class="line-added">520     );</span>
<span class="line-added">521     {</span>
<span class="line-added">522         IndentationScope scope(indent);</span>
<span class="line-added">523         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">524             auto&amp; outputItem = m_entryPointItems.outputs[i];</span>
<span class="line-added">525             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">526             auto elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">527             auto attribute = attributeForSemantic(*outputItem.semantic);</span>
<span class="line-added">528             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);</span>
<span class="line-added">529         }</span>
<span class="line-added">530     }</span>
<span class="line-added">531     stringBuilder.append(indent, &quot;};\n\n&quot;);</span>
<span class="line-added">532 </span>
<span class="line-added">533     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">534 }</span>
<span class="line-added">535 </span>
<span class="line-added">536 void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">537 {</span>
<span class="line-added">538     stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);</span>
<span class="line-added">539     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">540     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);</span>
<span class="line-added">541     stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">542 }</span>
<span class="line-added">543 </span>
<span class="line-added">544 void FragmentEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">545 {</span>
<span class="line-added">546     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>
<span class="line-added">547 </span>
<span class="line-added">548     for (auto&amp; namedStageIn : m_namedStageIns) {</span>
<span class="line-added">549         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;</span>
<span class="line-added">550         auto&amp; elementName = namedStageIn.elementName;</span>
<span class="line-added">551 </span>
<span class="line-added">552         stringBuilder.append(indent);</span>
<span class="line-added">553         emitMangledInputPath(stringBuilder, path);</span>
<span class="line-added">554         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);</span>
<span class="line-added">555     }</span>
<span class="line-added">556 }</span>
<span class="line-added">557 </span>
<span class="line-added">558 void FragmentEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">559 {</span>
<span class="line-added">560     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">561     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {</span>
<span class="line-added">562         auto&amp; elementName = m_namedOutputs[0].elementName;</span>
<span class="line-added">563         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);</span>
<span class="line-added">564         return;</span>
<span class="line-added">565     }</span>
<span class="line-added">566     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {</span>
<span class="line-added">567         auto&amp; elementName = m_namedOutputs[i].elementName;</span>
<span class="line-added">568         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;</span>
<span class="line-added">569         auto&amp; path = m_entryPointItems.outputs[i].path;</span>
<span class="line-added">570         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);</span>
<span class="line-added">571         emitMangledOutputPath(stringBuilder, path);</span>
<span class="line-added">572         stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added">573     }</span>
<span class="line-added">574 }</span>
<span class="line-added">575 </span>
<span class="line-added">576 ComputeEntryPointScaffolding::ComputeEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)</span>
<span class="line-added">577     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))</span>
<span class="line-added">578 {</span>
<span class="line-added">579 }</span>
<span class="line-added">580 </span>
<span class="line-added">581 void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="line-added">582 {</span>
<span class="line-added">583     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="line-added">584 }</span>
<span class="line-added">585 </span>
<span class="line-added">586 void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)</span>
<span class="line-added">587 {</span>
<span class="line-added">588     stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);</span>
<span class="line-added">589     bool addedToSignature = emitResourceSignature(stringBuilder, IncludePrecedingComma::No);</span>
<span class="line-added">590     emitBuiltInsSignature(stringBuilder, addedToSignature ? IncludePrecedingComma::Yes : IncludePrecedingComma::No);</span>
<span class="line-added">591     stringBuilder.append(&quot;)\n&quot;);</span>
592 }
593 
<span class="line-modified">594 void ComputeEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
595 {
<span class="line-modified">596     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);</span>

597 }
598 
<span class="line-modified">599 void ComputeEntryPointScaffolding::emitPack(StringBuilder&amp;, MangledVariableName, MangledVariableName, Indentation&lt;4&gt;)</span>
600 {
<span class="line-modified">601     ASSERT_NOT_REACHED();</span>

602 }
603 
604 }
605 
606 }
607 
608 }
609 
610 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../AST/WHLSLWhileLoop.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>