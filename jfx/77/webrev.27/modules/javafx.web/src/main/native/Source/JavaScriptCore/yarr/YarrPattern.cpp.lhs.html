<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009, 2013-2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Peter Varga (pvarga@inf.u-szeged.hu), University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrPattern.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;Yarr.h&quot;
  32 #include &quot;YarrCanonicalize.h&quot;
  33 #include &quot;YarrParser.h&quot;
  34 #include &lt;wtf/DataLog.h&gt;
  35 #include &lt;wtf/Optional.h&gt;
  36 #include &lt;wtf/StackPointer.h&gt;
  37 #include &lt;wtf/Threading.h&gt;
  38 #include &lt;wtf/Vector.h&gt;
<a name="1" id="anc1"></a><span class="line-removed">  39 #include &lt;wtf/text/WTFString.h&gt;</span>
  40 
  41 namespace JSC { namespace Yarr {
  42 
  43 #include &quot;RegExpJitTables.h&quot;
  44 
  45 class CharacterClassConstructor {
  46 public:
  47     CharacterClassConstructor(bool isCaseInsensitive, CanonicalMode canonicalMode)
  48         : m_isCaseInsensitive(isCaseInsensitive)
<a name="2" id="anc2"></a><span class="line-removed">  49         , m_hasNonBMPCharacters(false)</span>
  50         , m_anyCharacter(false)
<a name="3" id="anc3"></a>
  51         , m_canonicalMode(canonicalMode)
  52     {
  53     }
  54 
  55     void reset()
  56     {
  57         m_matches.clear();
  58         m_ranges.clear();
  59         m_matchesUnicode.clear();
  60         m_rangesUnicode.clear();
<a name="4" id="anc4"></a><span class="line-removed">  61         m_hasNonBMPCharacters = false;</span>
  62         m_anyCharacter = false;
<a name="5" id="anc5"></a>
  63     }
  64 
  65     void append(const CharacterClass* other)
  66     {
  67         for (size_t i = 0; i &lt; other-&gt;m_matches.size(); ++i)
  68             addSorted(m_matches, other-&gt;m_matches[i]);
  69         for (size_t i = 0; i &lt; other-&gt;m_ranges.size(); ++i)
  70             addSortedRange(m_ranges, other-&gt;m_ranges[i].begin, other-&gt;m_ranges[i].end);
  71         for (size_t i = 0; i &lt; other-&gt;m_matchesUnicode.size(); ++i)
  72             addSorted(m_matchesUnicode, other-&gt;m_matchesUnicode[i]);
  73         for (size_t i = 0; i &lt; other-&gt;m_rangesUnicode.size(); ++i)
  74             addSortedRange(m_rangesUnicode, other-&gt;m_rangesUnicode[i].begin, other-&gt;m_rangesUnicode[i].end);
  75     }
  76 
  77     void appendInverted(const CharacterClass* other)
  78     {
  79         auto addSortedInverted = [&amp;](UChar32 min, UChar32 max,
  80             const Vector&lt;UChar32&gt;&amp; srcMatches, const Vector&lt;CharacterRange&gt;&amp; srcRanges,
  81             Vector&lt;UChar32&gt;&amp; destMatches, Vector&lt;CharacterRange&gt;&amp; destRanges) {
  82 
  83             auto addSortedMatchOrRange = [&amp;](UChar32 lo, UChar32 hiPlusOne) {
  84                 if (lo &lt; hiPlusOne) {
  85                     if (lo + 1 == hiPlusOne)
  86                         addSorted(destMatches, lo);
  87                     else
  88                         addSortedRange(destRanges, lo, hiPlusOne - 1);
  89                 }
  90             };
  91 
  92             UChar32 lo = min;
  93             size_t matchesIndex = 0;
  94             size_t rangesIndex = 0;
  95             bool matchesRemaining = matchesIndex &lt; srcMatches.size();
  96             bool rangesRemaining = rangesIndex &lt; srcRanges.size();
  97 
  98             if (!matchesRemaining &amp;&amp; !rangesRemaining) {
  99                 addSortedMatchOrRange(min, max + 1);
 100                 return;
 101             }
 102 
 103             while (matchesRemaining || rangesRemaining) {
 104                 UChar32 hiPlusOne;
 105                 UChar32 nextLo;
 106 
 107                 if (matchesRemaining
 108                     &amp;&amp; (!rangesRemaining || srcMatches[matchesIndex] &lt; srcRanges[rangesIndex].begin)) {
 109                     hiPlusOne = srcMatches[matchesIndex];
 110                     nextLo = hiPlusOne + 1;
 111                     ++matchesIndex;
 112                     matchesRemaining = matchesIndex &lt; srcMatches.size();
 113                 } else {
 114                     hiPlusOne = srcRanges[rangesIndex].begin;
 115                     nextLo = srcRanges[rangesIndex].end + 1;
 116                     ++rangesIndex;
 117                     rangesRemaining = rangesIndex &lt; srcRanges.size();
 118                 }
 119 
 120                 addSortedMatchOrRange(lo, hiPlusOne);
 121 
 122                 lo = nextLo;
 123             }
 124 
 125             addSortedMatchOrRange(lo, max + 1);
 126         };
 127 
 128         addSortedInverted(0, 0x7f, other-&gt;m_matches, other-&gt;m_ranges, m_matches, m_ranges);
 129         addSortedInverted(0x80, 0x10ffff, other-&gt;m_matchesUnicode, other-&gt;m_rangesUnicode, m_matchesUnicode, m_rangesUnicode);
 130     }
 131 
 132     void putChar(UChar32 ch)
 133     {
 134         if (!m_isCaseInsensitive) {
 135             addSorted(ch);
 136             return;
 137         }
 138 
 139         if (m_canonicalMode == CanonicalMode::UCS2 &amp;&amp; isASCII(ch)) {
 140             // Handle ASCII cases.
 141             if (isASCIIAlpha(ch)) {
 142                 addSorted(m_matches, toASCIIUpper(ch));
 143                 addSorted(m_matches, toASCIILower(ch));
 144             } else
 145                 addSorted(m_matches, ch);
 146             return;
 147         }
 148 
 149         // Add multiple matches, if necessary.
 150         const CanonicalizationRange* info = canonicalRangeInfoFor(ch, m_canonicalMode);
 151         if (info-&gt;type == CanonicalizeUnique)
 152             addSorted(ch);
 153         else
 154             putUnicodeIgnoreCase(ch, info);
 155     }
 156 
 157     void putUnicodeIgnoreCase(UChar32 ch, const CanonicalizationRange* info)
 158     {
 159         ASSERT(m_isCaseInsensitive);
 160         ASSERT(ch &gt;= info-&gt;begin &amp;&amp; ch &lt;= info-&gt;end);
 161         ASSERT(info-&gt;type != CanonicalizeUnique);
 162         if (info-&gt;type == CanonicalizeSet) {
 163             for (const UChar32* set = canonicalCharacterSetInfo(info-&gt;value, m_canonicalMode); (ch = *set); ++set)
 164                 addSorted(ch);
 165         } else {
 166             addSorted(ch);
 167             addSorted(getCanonicalPair(info, ch));
 168         }
 169     }
 170 
 171     void putRange(UChar32 lo, UChar32 hi)
 172     {
 173         if (isASCII(lo)) {
 174             char asciiLo = lo;
 175             char asciiHi = std::min(hi, (UChar32)0x7f);
 176             addSortedRange(m_ranges, lo, asciiHi);
 177 
 178             if (m_isCaseInsensitive) {
 179                 if ((asciiLo &lt;= &#39;Z&#39;) &amp;&amp; (asciiHi &gt;= &#39;A&#39;))
 180                     addSortedRange(m_ranges, std::max(asciiLo, &#39;A&#39;)+(&#39;a&#39;-&#39;A&#39;), std::min(asciiHi, &#39;Z&#39;)+(&#39;a&#39;-&#39;A&#39;));
 181                 if ((asciiLo &lt;= &#39;z&#39;) &amp;&amp; (asciiHi &gt;= &#39;a&#39;))
 182                     addSortedRange(m_ranges, std::max(asciiLo, &#39;a&#39;)+(&#39;A&#39;-&#39;a&#39;), std::min(asciiHi, &#39;z&#39;)+(&#39;A&#39;-&#39;a&#39;));
 183             }
 184         }
 185         if (isASCII(hi))
 186             return;
 187 
 188         lo = std::max(lo, (UChar32)0x80);
 189         addSortedRange(m_rangesUnicode, lo, hi);
 190 
 191         if (!m_isCaseInsensitive)
 192             return;
 193 
 194         const CanonicalizationRange* info = canonicalRangeInfoFor(lo, m_canonicalMode);
 195         while (true) {
 196             // Handle the range [lo .. end]
 197             UChar32 end = std::min&lt;UChar32&gt;(info-&gt;end, hi);
 198 
 199             switch (info-&gt;type) {
 200             case CanonicalizeUnique:
 201                 // Nothing to do - no canonical equivalents.
 202                 break;
 203             case CanonicalizeSet: {
 204                 UChar ch;
 205                 for (const UChar32* set = canonicalCharacterSetInfo(info-&gt;value, m_canonicalMode); (ch = *set); ++set)
 206                     addSorted(m_matchesUnicode, ch);
 207                 break;
 208             }
 209             case CanonicalizeRangeLo:
 210                 addSortedRange(m_rangesUnicode, lo + info-&gt;value, end + info-&gt;value);
 211                 break;
 212             case CanonicalizeRangeHi:
 213                 addSortedRange(m_rangesUnicode, lo - info-&gt;value, end - info-&gt;value);
 214                 break;
 215             case CanonicalizeAlternatingAligned:
 216                 // Use addSortedRange since there is likely an abutting range to combine with.
 217                 if (lo &amp; 1)
 218                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 219                 if (!(end &amp; 1))
 220                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 221                 break;
 222             case CanonicalizeAlternatingUnaligned:
 223                 // Use addSortedRange since there is likely an abutting range to combine with.
 224                 if (!(lo &amp; 1))
 225                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 226                 if (end &amp; 1)
 227                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 228                 break;
 229             }
 230 
 231             if (hi == end)
 232                 return;
 233 
 234             ++info;
 235             lo = info-&gt;begin;
 236         };
 237 
 238     }
 239 
 240     std::unique_ptr&lt;CharacterClass&gt; charClass()
 241     {
 242         coalesceTables();
 243 
<a name="6" id="anc6"></a><span class="line-modified"> 244         auto characterClass = std::make_unique&lt;CharacterClass&gt;();</span>
 245 
 246         characterClass-&gt;m_matches.swap(m_matches);
 247         characterClass-&gt;m_ranges.swap(m_ranges);
 248         characterClass-&gt;m_matchesUnicode.swap(m_matchesUnicode);
 249         characterClass-&gt;m_rangesUnicode.swap(m_rangesUnicode);
<a name="7" id="anc7"></a><span class="line-removed"> 250         characterClass-&gt;m_hasNonBMPCharacters = hasNonBMPCharacters();</span>
 251         characterClass-&gt;m_anyCharacter = anyCharacter();
<a name="8" id="anc8"></a>
 252 
<a name="9" id="anc9"></a><span class="line-removed"> 253         m_hasNonBMPCharacters = false;</span>
 254         m_anyCharacter = false;
<a name="10" id="anc10"></a>
 255 
 256         return characterClass;
 257     }
 258 
 259 private:
 260     void addSorted(UChar32 ch)
 261     {
 262         addSorted(isASCII(ch) ? m_matches : m_matchesUnicode, ch);
 263     }
 264 
 265     void addSorted(Vector&lt;UChar32&gt;&amp; matches, UChar32 ch)
 266     {
 267         unsigned pos = 0;
 268         unsigned range = matches.size();
 269 
<a name="11" id="anc11"></a><span class="line-modified"> 270         if (!U_IS_BMP(ch))</span>
<span class="line-removed"> 271             m_hasNonBMPCharacters = true;</span>
 272 
 273         // binary chop, find position to insert char.
 274         while (range) {
 275             unsigned index = range &gt;&gt; 1;
 276 
 277             int val = matches[pos+index] - ch;
 278             if (!val)
 279                 return;
 280             else if (val &gt; 0) {
 281                 if (val == 1) {
 282                     UChar32 lo = ch;
 283                     UChar32 hi = ch + 1;
 284                     matches.remove(pos + index);
 285                     if (pos + index &gt; 0 &amp;&amp; matches[pos + index - 1] == ch - 1) {
 286                         lo = ch - 1;
 287                         matches.remove(pos + index - 1);
 288                     }
 289                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 290                     return;
 291                 }
 292                 range = index;
 293             } else {
 294                 if (val == -1) {
 295                     UChar32 lo = ch - 1;
 296                     UChar32 hi = ch;
 297                     matches.remove(pos + index);
 298                     if (pos + index + 1 &lt; matches.size() &amp;&amp; matches[pos + index + 1] == ch + 1) {
 299                         hi = ch + 1;
 300                         matches.remove(pos + index + 1);
 301                     }
 302                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 303                     return;
 304                 }
 305                 pos += (index+1);
 306                 range -= (index+1);
 307             }
 308         }
 309 
 310         if (pos == matches.size())
 311             matches.append(ch);
 312         else
 313             matches.insert(pos, ch);
 314     }
 315 
 316     void addSortedRange(Vector&lt;CharacterRange&gt;&amp; ranges, UChar32 lo, UChar32 hi)
 317     {
 318         size_t end = ranges.size();
 319 
<a name="12" id="anc12"></a>

 320         if (!U_IS_BMP(hi))
<a name="13" id="anc13"></a><span class="line-modified"> 321             m_hasNonBMPCharacters = true;</span>
 322 
 323         // Simple linear scan - I doubt there are that many ranges anyway...
 324         // feel free to fix this with something faster (eg binary chop).
 325         for (size_t i = 0; i &lt; end; ++i) {
 326             // does the new range fall before the current position in the array
 327             if (hi &lt; ranges[i].begin) {
 328                 // Concatenate appending ranges.
 329                 if (hi == (ranges[i].begin - 1)) {
 330                     ranges[i].begin = lo;
 331                     return;
 332                 }
 333                 ranges.insert(i, CharacterRange(lo, hi));
 334                 return;
 335             }
 336             // Okay, since we didn&#39;t hit the last case, the end of the new range is definitely at or after the begining
 337             // If the new range start at or before the end of the last range, then the overlap (if it starts one after the
 338             // end of the last range they concatenate, which is just as good.
 339             if (lo &lt;= (ranges[i].end + 1)) {
 340                 // found an intersect! we&#39;ll replace this entry in the array.
 341                 ranges[i].begin = std::min(ranges[i].begin, lo);
 342                 ranges[i].end = std::max(ranges[i].end, hi);
 343 
 344                 mergeRangesFrom(ranges, i);
 345                 return;
 346             }
 347         }
 348 
 349         // CharacterRange comes after all existing ranges.
 350         ranges.append(CharacterRange(lo, hi));
 351     }
 352 
 353     void mergeRangesFrom(Vector&lt;CharacterRange&gt;&amp; ranges, size_t index)
 354     {
 355         unsigned next = index + 1;
 356 
 357         // each iteration of the loop we will either remove something from the list, or break out of the loop.
 358         while (next &lt; ranges.size()) {
 359             if (ranges[next].begin &lt;= (ranges[index].end + 1)) {
 360                 // the next entry now overlaps / concatenates with this one.
 361                 ranges[index].end = std::max(ranges[index].end, ranges[next].end);
 362                 ranges.remove(next);
 363             } else
 364                 break;
 365         }
 366 
 367     }
 368 
 369     void coalesceTables()
 370     {
 371         auto coalesceMatchesAndRanges = [&amp;](Vector&lt;UChar32&gt;&amp; matches, Vector&lt;CharacterRange&gt;&amp; ranges) {
 372 
 373             size_t matchesIndex = 0;
 374             size_t rangesIndex = 0;
 375 
 376             while (matchesIndex &lt; matches.size() &amp;&amp; rangesIndex &lt; ranges.size()) {
 377                 while (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] &lt; ranges[rangesIndex].begin - 1)
 378                     matchesIndex++;
 379 
 380                 if (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] == ranges[rangesIndex].begin - 1) {
 381                     ranges[rangesIndex].begin = matches[matchesIndex];
 382                     matches.remove(matchesIndex);
 383                 }
 384 
 385                 while (matchesIndex &lt; matches.size() &amp;&amp; matches[matchesIndex] &lt; ranges[rangesIndex].end + 1)
 386                     matchesIndex++;
 387 
 388                 if (matchesIndex &lt; matches.size()) {
 389                     if (matches[matchesIndex] == ranges[rangesIndex].end + 1) {
 390                         ranges[rangesIndex].end = matches[matchesIndex];
 391                         matches.remove(matchesIndex);
 392 
 393                         mergeRangesFrom(ranges, rangesIndex);
 394                     } else
 395                         matchesIndex++;
 396                 }
 397             }
 398         };
 399 
 400         coalesceMatchesAndRanges(m_matches, m_ranges);
 401         coalesceMatchesAndRanges(m_matchesUnicode, m_rangesUnicode);
 402 
 403         if (!m_matches.size() &amp;&amp; !m_matchesUnicode.size()
 404             &amp;&amp; m_ranges.size() == 1 &amp;&amp; m_rangesUnicode.size() == 1
 405             &amp;&amp; m_ranges[0].begin == 0 &amp;&amp; m_ranges[0].end == 0x7f
 406             &amp;&amp; m_rangesUnicode[0].begin == 0x80 &amp;&amp; m_rangesUnicode[0].end == 0x10ffff)
 407             m_anyCharacter = true;
 408     }
 409 
 410     bool hasNonBMPCharacters()
 411     {
<a name="14" id="anc14"></a><span class="line-modified"> 412         return m_hasNonBMPCharacters;</span>





 413     }
 414 
 415     bool anyCharacter()
 416     {
 417         return m_anyCharacter;
 418     }
 419 
 420     bool m_isCaseInsensitive : 1;
<a name="15" id="anc15"></a><span class="line-removed"> 421     bool m_hasNonBMPCharacters : 1;</span>
 422     bool m_anyCharacter : 1;
<a name="16" id="anc16"></a>

 423     CanonicalMode m_canonicalMode;
 424 
 425     Vector&lt;UChar32&gt; m_matches;
 426     Vector&lt;CharacterRange&gt; m_ranges;
 427     Vector&lt;UChar32&gt; m_matchesUnicode;
 428     Vector&lt;CharacterRange&gt; m_rangesUnicode;
 429 };
 430 
 431 class YarrPatternConstructor {
 432 public:
 433     YarrPatternConstructor(YarrPattern&amp; pattern, void* stackLimit)
 434         : m_pattern(pattern)
 435         , m_characterClassConstructor(pattern.ignoreCase(), pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
 436         , m_stackLimit(stackLimit)
 437     {
<a name="17" id="anc17"></a><span class="line-modified"> 438         auto body = std::make_unique&lt;PatternDisjunction&gt;();</span>
 439         m_pattern.m_body = body.get();
 440         m_alternative = body-&gt;addNewAlternative();
 441         m_pattern.m_disjunctions.append(WTFMove(body));
 442     }
 443 
 444     ~YarrPatternConstructor()
 445     {
 446     }
 447 
 448     void resetForReparsing()
 449     {
 450         m_pattern.resetForReparsing();
 451         m_characterClassConstructor.reset();
 452 
<a name="18" id="anc18"></a><span class="line-modified"> 453         auto body = std::make_unique&lt;PatternDisjunction&gt;();</span>
 454         m_pattern.m_body = body.get();
 455         m_alternative = body-&gt;addNewAlternative();
 456         m_pattern.m_disjunctions.append(WTFMove(body));
 457     }
 458 
 459     void saveUnmatchedNamedForwardReferences()
 460     {
 461         m_unmatchedNamedForwardReferences.shrink(0);
 462 
 463         for (auto&amp; entry : m_pattern.m_namedForwardReferences) {
 464             if (!m_pattern.m_captureGroupNames.contains(entry))
 465                 m_unmatchedNamedForwardReferences.append(entry);
 466         }
 467     }
 468 
 469     void assertionBOL()
 470     {
 471         if (!m_alternative-&gt;m_terms.size() &amp;&amp; !m_invertParentheticalAssertion) {
 472             m_alternative-&gt;m_startsWithBOL = true;
 473             m_alternative-&gt;m_containsBOL = true;
 474             m_pattern.m_containsBOL = true;
 475         }
 476         m_alternative-&gt;m_terms.append(PatternTerm::BOL());
 477     }
 478     void assertionEOL()
 479     {
 480         m_alternative-&gt;m_terms.append(PatternTerm::EOL());
 481     }
 482     void assertionWordBoundary(bool invert)
 483     {
 484         m_alternative-&gt;m_terms.append(PatternTerm::WordBoundary(invert));
 485     }
 486 
 487     void atomPatternCharacter(UChar32 ch)
 488     {
 489         // We handle case-insensitive checking of unicode characters which do have both
 490         // cases by handling them as if they were defined using a CharacterClass.
 491         if (!m_pattern.ignoreCase() || (isASCII(ch) &amp;&amp; !m_pattern.unicode())) {
 492             m_alternative-&gt;m_terms.append(PatternTerm(ch));
 493             return;
 494         }
 495 
 496         const CanonicalizationRange* info = canonicalRangeInfoFor(ch, m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2);
 497         if (info-&gt;type == CanonicalizeUnique) {
 498             m_alternative-&gt;m_terms.append(PatternTerm(ch));
 499             return;
 500         }
 501 
 502         m_characterClassConstructor.putUnicodeIgnoreCase(ch, info);
 503         auto newCharacterClass = m_characterClassConstructor.charClass();
 504         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), false));
 505         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 506     }
 507 
 508     void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert)
 509     {
 510         switch (classID) {
 511         case BuiltInCharacterClassID::DigitClassID:
 512             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.digitsCharacterClass(), invert));
 513             break;
 514         case BuiltInCharacterClassID::SpaceClassID:
 515             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.spacesCharacterClass(), invert));
 516             break;
 517         case BuiltInCharacterClassID::WordClassID:
 518             if (m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
 519                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.wordUnicodeIgnoreCaseCharCharacterClass(), invert));
 520             else
 521                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.wordcharCharacterClass(), invert));
 522             break;
 523         case BuiltInCharacterClassID::DotClassID:
 524             ASSERT(!invert);
 525             if (m_pattern.dotAll())
 526                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.anyCharacterClass(), false));
 527             else
 528                 m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.newlineCharacterClass(), true));
 529             break;
 530         default:
 531             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.unicodeCharacterClassFor(classID), invert));
 532             break;
 533         }
 534     }
 535 
 536     void atomCharacterClassBegin(bool invert = false)
 537     {
 538         m_invertCharacterClass = invert;
 539     }
 540 
 541     void atomCharacterClassAtom(UChar32 ch)
 542     {
 543         m_characterClassConstructor.putChar(ch);
 544     }
 545 
 546     void atomCharacterClassRange(UChar32 begin, UChar32 end)
 547     {
 548         m_characterClassConstructor.putRange(begin, end);
 549     }
 550 
 551     void atomCharacterClassBuiltIn(BuiltInCharacterClassID classID, bool invert)
 552     {
 553         ASSERT(classID != BuiltInCharacterClassID::DotClassID);
 554 
 555         switch (classID) {
 556         case BuiltInCharacterClassID::DigitClassID:
 557             m_characterClassConstructor.append(invert ? m_pattern.nondigitsCharacterClass() : m_pattern.digitsCharacterClass());
 558             break;
 559 
 560         case BuiltInCharacterClassID::SpaceClassID:
 561             m_characterClassConstructor.append(invert ? m_pattern.nonspacesCharacterClass() : m_pattern.spacesCharacterClass());
 562             break;
 563 
 564         case BuiltInCharacterClassID::WordClassID:
 565             if (m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
 566                 m_characterClassConstructor.append(invert ? m_pattern.nonwordUnicodeIgnoreCaseCharCharacterClass() : m_pattern.wordUnicodeIgnoreCaseCharCharacterClass());
 567             else
 568                 m_characterClassConstructor.append(invert ? m_pattern.nonwordcharCharacterClass() : m_pattern.wordcharCharacterClass());
 569             break;
 570 
 571         default:
 572             if (!invert)
 573                 m_characterClassConstructor.append(m_pattern.unicodeCharacterClassFor(classID));
 574             else
 575                 m_characterClassConstructor.appendInverted(m_pattern.unicodeCharacterClassFor(classID));
 576         }
 577     }
 578 
 579     void atomCharacterClassEnd()
 580     {
 581         auto newCharacterClass = m_characterClassConstructor.charClass();
 582 
 583         if (!m_invertCharacterClass &amp;&amp; newCharacterClass.get()-&gt;m_anyCharacter) {
 584             m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.anyCharacterClass(), false));
 585             return;
 586         }
 587         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), m_invertCharacterClass));
 588         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 589     }
 590 
 591     void atomParenthesesSubpatternBegin(bool capture = true, Optional&lt;String&gt; optGroupName = WTF::nullopt)
 592     {
 593         unsigned subpatternId = m_pattern.m_numSubpatterns + 1;
 594         if (capture) {
 595             m_pattern.m_numSubpatterns++;
 596             if (optGroupName) {
 597                 while (m_pattern.m_captureGroupNames.size() &lt; subpatternId)
 598                     m_pattern.m_captureGroupNames.append(String());
 599                 m_pattern.m_captureGroupNames.append(optGroupName.value());
 600                 m_pattern.m_namedGroupToParenIndex.add(optGroupName.value(), subpatternId);
 601             }
 602         } else
 603             ASSERT(!optGroupName);
 604 
<a name="19" id="anc19"></a><span class="line-modified"> 605         auto parenthesesDisjunction = std::make_unique&lt;PatternDisjunction&gt;(m_alternative);</span>
 606         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction.get(), capture, false));
 607         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 608         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 609     }
 610 
 611     void atomParentheticalAssertionBegin(bool invert = false)
 612     {
<a name="20" id="anc20"></a><span class="line-modified"> 613         auto parenthesesDisjunction = std::make_unique&lt;PatternDisjunction&gt;(m_alternative);</span>
 614         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParentheticalAssertion, m_pattern.m_numSubpatterns + 1, parenthesesDisjunction.get(), false, invert));
 615         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 616         m_invertParentheticalAssertion = invert;
 617         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 618     }
 619 
 620     void atomParenthesesEnd()
 621     {
 622         ASSERT(m_alternative-&gt;m_parent);
 623         ASSERT(m_alternative-&gt;m_parent-&gt;m_parent);
 624 
 625         PatternDisjunction* parenthesesDisjunction = m_alternative-&gt;m_parent;
 626         m_alternative = m_alternative-&gt;m_parent-&gt;m_parent;
 627 
 628         PatternTerm&amp; lastTerm = m_alternative-&gt;lastTerm();
 629 
 630         unsigned numParenAlternatives = parenthesesDisjunction-&gt;m_alternatives.size();
 631         unsigned numBOLAnchoredAlts = 0;
 632 
 633         for (unsigned i = 0; i &lt; numParenAlternatives; i++) {
 634             // Bubble up BOL flags
 635             if (parenthesesDisjunction-&gt;m_alternatives[i]-&gt;m_startsWithBOL)
 636                 numBOLAnchoredAlts++;
 637         }
 638 
 639         if (numBOLAnchoredAlts) {
 640             m_alternative-&gt;m_containsBOL = true;
 641             // If all the alternatives in parens start with BOL, then so does this one
 642             if (numBOLAnchoredAlts == numParenAlternatives)
 643                 m_alternative-&gt;m_startsWithBOL = true;
 644         }
 645 
 646         lastTerm.parentheses.lastSubpatternId = m_pattern.m_numSubpatterns;
 647         m_invertParentheticalAssertion = false;
 648     }
 649 
 650     void atomBackReference(unsigned subpatternId)
 651     {
 652         ASSERT(subpatternId);
 653         m_pattern.m_containsBackreferences = true;
 654         m_pattern.m_maxBackReference = std::max(m_pattern.m_maxBackReference, subpatternId);
 655 
 656         if (subpatternId &gt; m_pattern.m_numSubpatterns) {
 657             m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 658             return;
 659         }
 660 
 661         PatternAlternative* currentAlternative = m_alternative;
 662         ASSERT(currentAlternative);
 663 
 664         // Note to self: if we waited until the AST was baked, we could also remove forwards refs
 665         while ((currentAlternative = currentAlternative-&gt;m_parent-&gt;m_parent)) {
 666             PatternTerm&amp; term = currentAlternative-&gt;lastTerm();
 667             ASSERT((term.type == PatternTerm::TypeParenthesesSubpattern) || (term.type == PatternTerm::TypeParentheticalAssertion));
 668 
 669             if ((term.type == PatternTerm::TypeParenthesesSubpattern) &amp;&amp; term.capture() &amp;&amp; (subpatternId == term.parentheses.subpatternId)) {
 670                 m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 671                 return;
 672             }
 673         }
 674 
 675         m_alternative-&gt;m_terms.append(PatternTerm(subpatternId));
 676     }
 677 
 678     void atomNamedBackReference(const String&amp; subpatternName)
 679     {
 680         ASSERT(m_pattern.m_namedGroupToParenIndex.find(subpatternName) != m_pattern.m_namedGroupToParenIndex.end());
 681         atomBackReference(m_pattern.m_namedGroupToParenIndex.get(subpatternName));
 682     }
 683 
 684     bool isValidNamedForwardReference(const String&amp; subpatternName)
 685     {
 686         return !m_unmatchedNamedForwardReferences.contains(subpatternName);
 687     }
 688 
 689     void atomNamedForwardReference(const String&amp; subpatternName)
 690     {
 691         m_pattern.m_namedForwardReferences.appendIfNotContains(subpatternName);
 692         m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 693     }
 694 
 695     // deep copy the argument disjunction.  If filterStartsWithBOL is true,
 696     // skip alternatives with m_startsWithBOL set true.
 697     PatternDisjunction* copyDisjunction(PatternDisjunction* disjunction, bool filterStartsWithBOL = false)
 698     {
<a name="21" id="anc21"></a>




 699         std::unique_ptr&lt;PatternDisjunction&gt; newDisjunction;
 700         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 701             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 702             if (!filterStartsWithBOL || !alternative-&gt;m_startsWithBOL) {
 703                 if (!newDisjunction) {
<a name="22" id="anc22"></a><span class="line-modified"> 704                     newDisjunction = std::make_unique&lt;PatternDisjunction&gt;();</span>
 705                     newDisjunction-&gt;m_parent = disjunction-&gt;m_parent;
 706                 }
 707                 PatternAlternative* newAlternative = newDisjunction-&gt;addNewAlternative();
 708                 newAlternative-&gt;m_terms.reserveInitialCapacity(alternative-&gt;m_terms.size());
 709                 for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i)
 710                     newAlternative-&gt;m_terms.append(copyTerm(alternative-&gt;m_terms[i], filterStartsWithBOL));
 711             }
 712         }
 713 
<a name="23" id="anc23"></a>




 714         if (!newDisjunction)
 715             return 0;
 716 
 717         PatternDisjunction* copiedDisjunction = newDisjunction.get();
 718         m_pattern.m_disjunctions.append(WTFMove(newDisjunction));
 719         return copiedDisjunction;
 720     }
 721 
 722     PatternTerm copyTerm(PatternTerm&amp; term, bool filterStartsWithBOL = false)
 723     {
<a name="24" id="anc24"></a>




 724         if ((term.type != PatternTerm::TypeParenthesesSubpattern) &amp;&amp; (term.type != PatternTerm::TypeParentheticalAssertion))
 725             return PatternTerm(term);
 726 
 727         PatternTerm termCopy = term;
 728         termCopy.parentheses.disjunction = copyDisjunction(termCopy.parentheses.disjunction, filterStartsWithBOL);
 729         m_pattern.m_hasCopiedParenSubexpressions = true;
 730         return termCopy;
 731     }
 732 
 733     void quantifyAtom(unsigned min, unsigned max, bool greedy)
 734     {
 735         ASSERT(min &lt;= max);
 736         ASSERT(m_alternative-&gt;m_terms.size());
 737 
 738         if (!max) {
 739             m_alternative-&gt;removeLastTerm();
 740             return;
 741         }
 742 
 743         PatternTerm&amp; term = m_alternative-&gt;lastTerm();
 744         ASSERT(term.type &gt; PatternTerm::TypeAssertionWordBoundary);
 745         ASSERT(term.quantityMinCount == 1 &amp;&amp; term.quantityMaxCount == 1 &amp;&amp; term.quantityType == QuantifierFixedCount);
 746 
 747         if (term.type == PatternTerm::TypeParentheticalAssertion) {
 748             // If an assertion is quantified with a minimum count of zero, it can simply be removed.
 749             // This arises from the RepeatMatcher behaviour in the spec. Matching an assertion never
 750             // results in any input being consumed, however the continuation passed to the assertion
 751             // (called in steps, 8c and 9 of the RepeatMatcher definition, ES5.1 15.10.2.5) will
 752             // reject all zero length matches (see step 2.1). A match from the continuation of the
 753             // expression will still be accepted regardless (via steps 8a and 11) - the upshot of all
 754             // this is that matches from the assertion are not required, and won&#39;t be accepted anyway,
 755             // so no need to ever run it.
 756             if (!min)
 757                 m_alternative-&gt;removeLastTerm();
 758             // We never need to run an assertion more than once. Subsequent interations will be run
 759             // with the same start index (since assertions are non-capturing) and the same captures
 760             // (per step 4 of RepeatMatcher in ES5.1 15.10.2.5), and as such will always produce the
 761             // same result and captures. If the first match succeeds then the subsequent (min - 1)
 762             // matches will too. Any additional optional matches will fail (on the same basis as the
 763             // minimum zero quantified assertions, above), but this will still result in a match.
 764             return;
 765         }
 766 
 767         if (min == max)
 768             term.quantify(min, max, QuantifierFixedCount);
 769         else if (!min || (term.type == PatternTerm::TypeParenthesesSubpattern &amp;&amp; m_pattern.m_hasCopiedParenSubexpressions))
 770             term.quantify(min, max, greedy ? QuantifierGreedy : QuantifierNonGreedy);
 771         else {
 772             term.quantify(min, min, QuantifierFixedCount);
 773             m_alternative-&gt;m_terms.append(copyTerm(term));
 774             // NOTE: this term is interesting from an analysis perspective, in that it can be ignored.....
 775             m_alternative-&gt;lastTerm().quantify((max == quantifyInfinite) ? max : max - min, greedy ? QuantifierGreedy : QuantifierNonGreedy);
 776             if (m_alternative-&gt;lastTerm().type == PatternTerm::TypeParenthesesSubpattern)
 777                 m_alternative-&gt;lastTerm().parentheses.isCopy = true;
 778         }
 779     }
 780 
 781     void disjunction()
 782     {
 783         m_alternative = m_alternative-&gt;m_parent-&gt;addNewAlternative();
 784     }
 785 
 786     ErrorCode setupAlternativeOffsets(PatternAlternative* alternative, unsigned currentCallFrameSize, unsigned initialInputPosition, unsigned&amp; newCallFrameSize) WARN_UNUSED_RETURN
 787     {
 788         if (UNLIKELY(!isSafeToRecurse()))
 789             return ErrorCode::TooManyDisjunctions;
 790 
 791         ErrorCode error = ErrorCode::NoError;
 792         alternative-&gt;m_hasFixedSize = true;
 793         Checked&lt;unsigned, RecordOverflow&gt; currentInputPosition = initialInputPosition;
 794 
 795         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i) {
 796             PatternTerm&amp; term = alternative-&gt;m_terms[i];
 797 
 798             switch (term.type) {
 799             case PatternTerm::TypeAssertionBOL:
 800             case PatternTerm::TypeAssertionEOL:
 801             case PatternTerm::TypeAssertionWordBoundary:
 802                 term.inputPosition = currentInputPosition.unsafeGet();
 803                 break;
 804 
 805             case PatternTerm::TypeBackReference:
 806                 term.inputPosition = currentInputPosition.unsafeGet();
 807                 term.frameLocation = currentCallFrameSize;
 808                 currentCallFrameSize += YarrStackSpaceForBackTrackInfoBackReference;
 809                 alternative-&gt;m_hasFixedSize = false;
 810                 break;
 811 
 812             case PatternTerm::TypeForwardReference:
 813                 break;
 814 
 815             case PatternTerm::TypePatternCharacter:
 816                 term.inputPosition = currentInputPosition.unsafeGet();
 817                 if (term.quantityType != QuantifierFixedCount) {
 818                     term.frameLocation = currentCallFrameSize;
 819                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoPatternCharacter;
 820                     alternative-&gt;m_hasFixedSize = false;
 821                 } else if (m_pattern.unicode()) {
 822                     Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;
 823                     tempCount *= U16_LENGTH(term.patternCharacter);
 824                     if (tempCount.hasOverflowed())
 825                         return ErrorCode::OffsetTooLarge;
 826                     currentInputPosition += tempCount;
 827                 } else
 828                     currentInputPosition += term.quantityMaxCount;
 829                 break;
 830 
 831             case PatternTerm::TypeCharacterClass:
 832                 term.inputPosition = currentInputPosition.unsafeGet();
 833                 if (term.quantityType != QuantifierFixedCount) {
 834                     term.frameLocation = currentCallFrameSize;
 835                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
 836                     alternative-&gt;m_hasFixedSize = false;
 837                 } else if (m_pattern.unicode()) {
 838                     term.frameLocation = currentCallFrameSize;
 839                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
<a name="25" id="anc25"></a><span class="line-modified"> 840                     currentInputPosition += term.quantityMaxCount;</span>
<span class="line-modified"> 841                     alternative-&gt;m_hasFixedSize = false;</span>








 842                 } else
 843                     currentInputPosition += term.quantityMaxCount;
 844                 break;
 845 
 846             case PatternTerm::TypeParenthesesSubpattern:
 847                 // Note: for fixed once parentheses we will ensure at least the minimum is available; others are on their own.
 848                 term.frameLocation = currentCallFrameSize;
 849                 if (term.quantityMaxCount == 1 &amp;&amp; !term.parentheses.isCopy) {
 850                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesOnce;
 851                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 852                     if (hasError(error))
 853                         return error;
 854                     // If quantity is fixed, then pre-check its minimum size.
 855                     if (term.quantityType == QuantifierFixedCount)
 856                         currentInputPosition += term.parentheses.disjunction-&gt;m_minimumSize;
 857                     term.inputPosition = currentInputPosition.unsafeGet();
 858                 } else if (term.parentheses.isTerminal) {
 859                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
 860                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 861                     if (hasError(error))
 862                         return error;
 863                     term.inputPosition = currentInputPosition.unsafeGet();
 864                 } else {
 865                     term.inputPosition = currentInputPosition.unsafeGet();
 866                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParentheses;
 867                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 868                     if (hasError(error))
 869                         return error;
 870                 }
 871                 // Fixed count of 1 could be accepted, if they have a fixed size *AND* if all alternatives are of the same length.
 872                 alternative-&gt;m_hasFixedSize = false;
 873                 break;
 874 
 875             case PatternTerm::TypeParentheticalAssertion:
 876                 term.inputPosition = currentInputPosition.unsafeGet();
 877                 term.frameLocation = currentCallFrameSize;
 878                 error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize + YarrStackSpaceForBackTrackInfoParentheticalAssertion, currentInputPosition.unsafeGet(), currentCallFrameSize);
 879                 if (hasError(error))
 880                     return error;
 881                 break;
 882 
 883             case PatternTerm::TypeDotStarEnclosure:
 884                 ASSERT(!m_pattern.m_saveInitialStartValue);
 885                 alternative-&gt;m_hasFixedSize = false;
 886                 term.inputPosition = initialInputPosition;
 887                 m_pattern.m_initialStartValueFrameLocation = currentCallFrameSize;
 888                 currentCallFrameSize += YarrStackSpaceForDotStarEnclosure;
 889                 m_pattern.m_saveInitialStartValue = true;
 890                 break;
 891             }
 892             if (currentInputPosition.hasOverflowed())
 893                 return ErrorCode::OffsetTooLarge;
 894         }
 895 
 896         alternative-&gt;m_minimumSize = (currentInputPosition - initialInputPosition).unsafeGet();
 897         newCallFrameSize = currentCallFrameSize;
 898         return error;
 899     }
 900 
 901     ErrorCode setupDisjunctionOffsets(PatternDisjunction* disjunction, unsigned initialCallFrameSize, unsigned initialInputPosition, unsigned&amp; callFrameSize)
 902     {
 903         if (UNLIKELY(!isSafeToRecurse()))
 904             return ErrorCode::TooManyDisjunctions;
 905 
 906         if ((disjunction != m_pattern.m_body) &amp;&amp; (disjunction-&gt;m_alternatives.size() &gt; 1))
 907             initialCallFrameSize += YarrStackSpaceForBackTrackInfoAlternative;
 908 
 909         unsigned minimumInputSize = UINT_MAX;
 910         unsigned maximumCallFrameSize = 0;
 911         bool hasFixedSize = true;
 912         ErrorCode error = ErrorCode::NoError;
 913 
 914         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 915             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 916             unsigned currentAlternativeCallFrameSize;
 917             error = setupAlternativeOffsets(alternative, initialCallFrameSize, initialInputPosition, currentAlternativeCallFrameSize);
 918             if (hasError(error))
 919                 return error;
 920             minimumInputSize = std::min(minimumInputSize, alternative-&gt;m_minimumSize);
 921             maximumCallFrameSize = std::max(maximumCallFrameSize, currentAlternativeCallFrameSize);
 922             hasFixedSize &amp;= alternative-&gt;m_hasFixedSize;
 923             if (alternative-&gt;m_minimumSize &gt; INT_MAX)
 924                 m_pattern.m_containsUnsignedLengthPattern = true;
 925         }
 926 
 927         ASSERT(minimumInputSize != UINT_MAX);
 928         ASSERT(maximumCallFrameSize &gt;= initialCallFrameSize);
 929 
 930         disjunction-&gt;m_hasFixedSize = hasFixedSize;
 931         disjunction-&gt;m_minimumSize = minimumInputSize;
 932         disjunction-&gt;m_callFrameSize = maximumCallFrameSize;
 933         callFrameSize = maximumCallFrameSize;
 934         return error;
 935     }
 936 
 937     ErrorCode setupOffsets()
 938     {
 939         // FIXME: Yarr should not use the stack to handle subpatterns (rdar://problem/26436314).
 940         unsigned ignoredCallFrameSize;
 941         return setupDisjunctionOffsets(m_pattern.m_body, 0, 0, ignoredCallFrameSize);
 942     }
 943 
 944     // This optimization identifies sets of parentheses that we will never need to backtrack.
 945     // In these cases we do not need to store state from prior iterations.
 946     // We can presently avoid backtracking for:
 947     //   * where the parens are at the end of the regular expression (last term in any of the
 948     //     alternatives of the main body disjunction).
 949     //   * where the parens are non-capturing, and quantified unbounded greedy (*).
 950     //   * where the parens do not contain any capturing subpatterns.
 951     void checkForTerminalParentheses()
 952     {
 953         // This check is much too crude; should be just checking whether the candidate
 954         // node contains nested capturing subpatterns, not the whole expression!
 955         if (m_pattern.m_numSubpatterns)
 956             return;
 957 
 958         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
 959         for (size_t i = 0; i &lt; alternatives.size(); ++i) {
 960             Vector&lt;PatternTerm&gt;&amp; terms = alternatives[i]-&gt;m_terms;
 961             if (terms.size()) {
 962                 PatternTerm&amp; term = terms.last();
 963                 if (term.type == PatternTerm::TypeParenthesesSubpattern
 964                     &amp;&amp; term.quantityType == QuantifierGreedy
 965                     &amp;&amp; term.quantityMinCount == 0
 966                     &amp;&amp; term.quantityMaxCount == quantifyInfinite
 967                     &amp;&amp; !term.capture())
 968                     term.parentheses.isTerminal = true;
 969             }
 970         }
 971     }
 972 
 973     void optimizeBOL()
 974     {
 975         // Look for expressions containing beginning of line (^) anchoring and unroll them.
 976         // e.g. /^a|^b|c/ becomes /^a|^b|c/ which is executed once followed by /c/ which loops
 977         // This code relies on the parsing code tagging alternatives with m_containsBOL and
 978         // m_startsWithBOL and rolling those up to containing alternatives.
 979         // At this point, this is only valid for non-multiline expressions.
 980         PatternDisjunction* disjunction = m_pattern.m_body;
 981 
 982         if (!m_pattern.m_containsBOL || m_pattern.multiline())
 983             return;
 984 
 985         PatternDisjunction* loopDisjunction = copyDisjunction(disjunction, true);
 986 
 987         // Set alternatives in disjunction to &quot;onceThrough&quot;
 988         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt)
 989             disjunction-&gt;m_alternatives[alt]-&gt;setOnceThrough();
 990 
 991         if (loopDisjunction) {
 992             // Move alternatives from loopDisjunction to disjunction
 993             for (unsigned alt = 0; alt &lt; loopDisjunction-&gt;m_alternatives.size(); ++alt)
 994                 disjunction-&gt;m_alternatives.append(loopDisjunction-&gt;m_alternatives[alt].release());
 995 
 996             loopDisjunction-&gt;m_alternatives.clear();
 997         }
 998     }
 999 
1000     bool containsCapturingTerms(PatternAlternative* alternative, size_t firstTermIndex, size_t endIndex)
1001     {
1002         Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;
1003 
1004         ASSERT(endIndex &lt;= terms.size());
1005         for (size_t termIndex = firstTermIndex; termIndex &lt; endIndex; ++termIndex) {
1006             PatternTerm&amp; term = terms[termIndex];
1007 
1008             if (term.m_capture)
1009                 return true;
1010 
1011             if (term.type == PatternTerm::TypeParenthesesSubpattern) {
1012                 PatternDisjunction* nestedDisjunction = term.parentheses.disjunction;
1013                 for (unsigned alt = 0; alt &lt; nestedDisjunction-&gt;m_alternatives.size(); ++alt) {
1014                     if (containsCapturingTerms(nestedDisjunction-&gt;m_alternatives[alt].get(), 0, nestedDisjunction-&gt;m_alternatives[alt]-&gt;m_terms.size()))
1015                         return true;
1016                 }
1017             }
1018         }
1019 
1020         return false;
1021     }
1022 
1023     // This optimization identifies alternatives in the form of
1024     // [^].*[?]&lt;expression&gt;.*[$] for expressions that don&#39;t have any
1025     // capturing terms. The alternative is changed to &lt;expression&gt;
1026     // followed by processing of the dot stars to find and adjust the
1027     // beginning and the end of the match.
1028     void optimizeDotStarWrappedExpressions()
1029     {
1030         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
1031         if (alternatives.size() != 1)
1032             return;
1033 
1034         CharacterClass* dotCharacterClass = m_pattern.dotAll() ? m_pattern.anyCharacterClass() : m_pattern.newlineCharacterClass();
1035         PatternAlternative* alternative = alternatives[0].get();
1036         Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;
1037         if (terms.size() &gt;= 3) {
1038             bool startsWithBOL = false;
1039             bool endsWithEOL = false;
1040             size_t termIndex, firstExpressionTerm;
1041 
1042             termIndex = 0;
1043             if (terms[termIndex].type == PatternTerm::TypeAssertionBOL) {
1044                 startsWithBOL = true;
1045                 ++termIndex;
1046             }
1047 
1048             PatternTerm&amp; firstNonAnchorTerm = terms[termIndex];
1049             if (firstNonAnchorTerm.type != PatternTerm::TypeCharacterClass
1050                 || firstNonAnchorTerm.characterClass != dotCharacterClass
1051                 || firstNonAnchorTerm.quantityMinCount
1052                 || firstNonAnchorTerm.quantityMaxCount != quantifyInfinite)
1053                 return;
1054 
1055             firstExpressionTerm = termIndex + 1;
1056 
1057             termIndex = terms.size() - 1;
1058             if (terms[termIndex].type == PatternTerm::TypeAssertionEOL) {
1059                 endsWithEOL = true;
1060                 --termIndex;
1061             }
1062 
1063             PatternTerm&amp; lastNonAnchorTerm = terms[termIndex];
1064             if (lastNonAnchorTerm.type != PatternTerm::TypeCharacterClass
1065                 || lastNonAnchorTerm.characterClass != dotCharacterClass
1066                 || lastNonAnchorTerm.quantityType != QuantifierGreedy
1067                 || lastNonAnchorTerm.quantityMinCount
1068                 || lastNonAnchorTerm.quantityMaxCount != quantifyInfinite)
1069                 return;
1070 
1071             size_t endIndex = termIndex;
1072             if (firstExpressionTerm &gt;= endIndex)
1073                 return;
1074 
1075             if (!containsCapturingTerms(alternative, firstExpressionTerm, endIndex)) {
1076                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1077                     terms.remove(termIndex);
1078 
1079                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1080                     terms.remove(termIndex - 1);
1081 
1082                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1083 
1084                 m_pattern.m_containsBOL = false;
1085             }
1086         }
1087     }
1088 
<a name="26" id="anc26"></a>

1089 private:
1090     bool isSafeToRecurse() const
1091     {
1092         if (!m_stackLimit)
1093             return true;
1094         ASSERT(Thread::current().stack().isGrowingDownward());
1095         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1096         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1097         return curr &gt;= limit;
1098     }
1099 
1100     YarrPattern&amp; m_pattern;
1101     PatternAlternative* m_alternative;
1102     CharacterClassConstructor m_characterClassConstructor;
1103     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1104     void* m_stackLimit;
<a name="27" id="anc27"></a>
1105     bool m_invertCharacterClass;
1106     bool m_invertParentheticalAssertion { false };
1107 };
1108 
1109 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1110 {
1111     YarrPatternConstructor constructor(*this, stackLimit);
1112 
<a name="28" id="anc28"></a><span class="line-removed">1113     if (m_flags == InvalidFlags)</span>
<span class="line-removed">1114         return ErrorCode::InvalidRegularExpressionFlags;</span>
<span class="line-removed">1115 </span>
1116     {
1117         ErrorCode error = parse(constructor, patternString, unicode());
1118         if (hasError(error))
1119             return error;
1120     }
1121 
1122     // If the pattern contains illegal backreferences reset &amp; reparse.
1123     // Quoting Netscape&#39;s &quot;What&#39;s new in JavaScript 1.2&quot;,
1124     //      &quot;Note: if the number of left parentheses is less than the number specified
1125     //       in \#, the \# is taken as an octal escape as described in the next row.&quot;
1126     if (containsIllegalBackReference() || containsIllegalNamedForwardReferences()) {
1127         if (unicode())
1128             return ErrorCode::InvalidBackreference;
1129 
1130         unsigned numSubpatterns = m_numSubpatterns;
1131 
1132         constructor.saveUnmatchedNamedForwardReferences();
1133         constructor.resetForReparsing();
1134         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1135         ASSERT_UNUSED(error, !hasError(error));
1136         ASSERT(numSubpatterns == m_numSubpatterns);
1137     }
1138 
1139     constructor.checkForTerminalParentheses();
1140     constructor.optimizeDotStarWrappedExpressions();
1141     constructor.optimizeBOL();
1142 
<a name="29" id="anc29"></a>


1143     {
1144         ErrorCode error = constructor.setupOffsets();
1145         if (hasError(error))
1146             return error;
1147     }
1148 
1149     if (Options::dumpCompiledRegExpPatterns())
1150         dumpPattern(patternString);
1151 
1152     return ErrorCode::NoError;
1153 }
1154 
<a name="30" id="anc30"></a><span class="line-modified">1155 YarrPattern::YarrPattern(const String&amp; pattern, RegExpFlags flags, ErrorCode&amp; error, void* stackLimit)</span>
1156     : m_containsBackreferences(false)
1157     , m_containsBOL(false)
1158     , m_containsUnsignedLengthPattern(false)
1159     , m_hasCopiedParenSubexpressions(false)
1160     , m_saveInitialStartValue(false)
1161     , m_flags(flags)
1162 {
<a name="31" id="anc31"></a>
1163     error = compile(pattern, stackLimit);
1164 }
1165 
1166 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1167 {
1168     out.print(&quot;    &quot;);
1169     for (; nestingDepth; --nestingDepth)
1170         out.print(&quot;  &quot;);
1171 }
1172 
1173 void dumpUChar32(PrintStream&amp; out, UChar32 c)
1174 {
1175     if (c &gt;= &#39; &#39;&amp;&amp; c &lt;= 0xff)
1176         out.printf(&quot;&#39;%c&#39;&quot;, static_cast&lt;char&gt;(c));
1177     else
1178         out.printf(&quot;0x%04x&quot;, c);
1179 }
1180 
1181 void dumpCharacterClass(PrintStream&amp; out, YarrPattern* pattern, CharacterClass* characterClass)
1182 {
1183     if (characterClass == pattern-&gt;anyCharacterClass())
1184         out.print(&quot;&lt;any character&gt;&quot;);
1185     else if (characterClass == pattern-&gt;newlineCharacterClass())
1186         out.print(&quot;&lt;newline&gt;&quot;);
1187     else if (characterClass == pattern-&gt;digitsCharacterClass())
1188         out.print(&quot;&lt;digits&gt;&quot;);
1189     else if (characterClass == pattern-&gt;spacesCharacterClass())
1190         out.print(&quot;&lt;whitespace&gt;&quot;);
1191     else if (characterClass == pattern-&gt;wordcharCharacterClass())
1192         out.print(&quot;&lt;word&gt;&quot;);
1193     else if (characterClass == pattern-&gt;wordUnicodeIgnoreCaseCharCharacterClass())
1194         out.print(&quot;&lt;unicode word ignore case&gt;&quot;);
1195     else if (characterClass == pattern-&gt;nondigitsCharacterClass())
1196         out.print(&quot;&lt;non-digits&gt;&quot;);
1197     else if (characterClass == pattern-&gt;nonspacesCharacterClass())
1198         out.print(&quot;&lt;non-whitespace&gt;&quot;);
1199     else if (characterClass == pattern-&gt;nonwordcharCharacterClass())
1200         out.print(&quot;&lt;non-word&gt;&quot;);
1201     else if (characterClass == pattern-&gt;nonwordUnicodeIgnoreCaseCharCharacterClass())
1202         out.print(&quot;&lt;unicode non-word ignore case&gt;&quot;);
1203     else {
1204         bool needMatchesRangesSeperator = false;
1205 
1206         auto dumpMatches = [&amp;] (const char* prefix, Vector&lt;UChar32&gt; matches) {
1207             size_t matchesSize = matches.size();
1208             if (matchesSize) {
1209                 if (needMatchesRangesSeperator)
1210                     out.print(&quot;,&quot;);
1211                 needMatchesRangesSeperator = true;
1212 
1213                 out.print(prefix, &quot;:(&quot;);
1214                 for (size_t i = 0; i &lt; matchesSize; ++i) {
1215                     if (i)
1216                         out.print(&quot;,&quot;);
1217                     dumpUChar32(out, matches[i]);
1218                 }
1219                 out.print(&quot;)&quot;);
1220             }
1221         };
1222 
1223         auto dumpRanges = [&amp;] (const char* prefix, Vector&lt;CharacterRange&gt; ranges) {
1224             size_t rangeSize = ranges.size();
1225             if (rangeSize) {
1226                 if (needMatchesRangesSeperator)
1227                     out.print(&quot;,&quot;);
1228                 needMatchesRangesSeperator = true;
1229 
1230                 out.print(prefix, &quot; ranges:(&quot;);
1231                 for (size_t i = 0; i &lt; rangeSize; ++i) {
1232                     if (i)
1233                         out.print(&quot;,&quot;);
1234                     CharacterRange range = ranges[i];
1235                     out.print(&quot;(&quot;);
1236                     dumpUChar32(out, range.begin);
1237                     out.print(&quot;..&quot;);
1238                     dumpUChar32(out, range.end);
1239                     out.print(&quot;)&quot;);
1240                 }
1241                 out.print(&quot;)&quot;);
1242             }
1243         };
1244 
1245         out.print(&quot;[&quot;);
1246         dumpMatches(&quot;ASCII&quot;, characterClass-&gt;m_matches);
1247         dumpRanges(&quot;ASCII&quot;, characterClass-&gt;m_ranges);
1248         dumpMatches(&quot;Unicode&quot;, characterClass-&gt;m_matchesUnicode);
1249         dumpRanges(&quot;Unicode&quot;, characterClass-&gt;m_rangesUnicode);
1250         out.print(&quot;]&quot;);
1251     }
1252 }
1253 
1254 void PatternAlternative::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth)
1255 {
1256     out.print(&quot;minimum size: &quot;, m_minimumSize);
1257     if (m_hasFixedSize)
1258         out.print(&quot;,fixed size&quot;);
1259     if (m_onceThrough)
1260         out.print(&quot;,once through&quot;);
1261     if (m_startsWithBOL)
1262         out.print(&quot;,starts with ^&quot;);
1263     if (m_containsBOL)
1264         out.print(&quot;,contains ^&quot;);
1265     out.print(&quot;\n&quot;);
1266 
1267     for (size_t i = 0; i &lt; m_terms.size(); ++i)
1268         m_terms[i].dump(out, thisPattern, nestingDepth);
1269 }
1270 
1271 void PatternTerm::dumpQuantifier(PrintStream&amp; out)
1272 {
1273     if (quantityType == QuantifierFixedCount &amp;&amp; quantityMinCount == 1 &amp;&amp; quantityMaxCount == 1)
1274         return;
1275     out.print(&quot; {&quot;, quantityMinCount.unsafeGet());
1276     if (quantityMinCount != quantityMaxCount) {
1277         if (quantityMaxCount == UINT_MAX)
1278             out.print(&quot;,...&quot;);
1279         else
1280             out.print(&quot;,&quot;, quantityMaxCount.unsafeGet());
1281     }
1282     out.print(&quot;}&quot;);
1283     if (quantityType == QuantifierGreedy)
1284         out.print(&quot; greedy&quot;);
1285     else if (quantityType == QuantifierNonGreedy)
1286         out.print(&quot; non-greedy&quot;);
1287 }
1288 
1289 void PatternTerm::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth)
1290 {
1291     indentForNestingLevel(out, nestingDepth);
1292 
1293     if (type != TypeParenthesesSubpattern &amp;&amp; type != TypeParentheticalAssertion) {
1294         if (invert())
1295             out.print(&quot;not &quot;);
1296     }
1297 
1298     switch (type) {
1299     case TypeAssertionBOL:
1300         out.println(&quot;BOL&quot;);
1301         break;
1302     case TypeAssertionEOL:
1303         out.println(&quot;EOL&quot;);
1304         break;
1305     case TypeAssertionWordBoundary:
1306         out.println(&quot;word boundary&quot;);
1307         break;
1308     case TypePatternCharacter:
1309         out.printf(&quot;character &quot;);
1310         out.printf(&quot;inputPosition %u &quot;, inputPosition);
1311         if (thisPattern-&gt;ignoreCase() &amp;&amp; isASCIIAlpha(patternCharacter)) {
1312             dumpUChar32(out, toASCIIUpper(patternCharacter));
1313             out.print(&quot;/&quot;);
1314             dumpUChar32(out, toASCIILower(patternCharacter));
1315         } else
1316             dumpUChar32(out, patternCharacter);
1317         dumpQuantifier(out);
1318         if (quantityType != QuantifierFixedCount)
1319             out.print(&quot;,frame location &quot;, frameLocation);
1320         out.println();
1321         break;
1322     case TypeCharacterClass:
1323         out.print(&quot;character class &quot;);
<a name="32" id="anc32"></a>
1324         dumpCharacterClass(out, thisPattern, characterClass);
1325         dumpQuantifier(out);
1326         if (quantityType != QuantifierFixedCount || thisPattern-&gt;unicode())
1327             out.print(&quot;,frame location &quot;, frameLocation);
1328         out.println();
1329         break;
1330     case TypeBackReference:
1331         out.print(&quot;back reference to subpattern #&quot;, backReferenceSubpatternId);
1332         out.println(&quot;,frame location &quot;, frameLocation);
1333         break;
1334     case TypeForwardReference:
1335         out.println(&quot;forward reference&quot;);
1336         break;
1337     case TypeParenthesesSubpattern:
1338         if (m_capture)
1339             out.print(&quot;captured &quot;);
1340         else
1341             out.print(&quot;non-captured &quot;);
1342 
1343         FALLTHROUGH;
1344     case TypeParentheticalAssertion:
1345         if (m_invert)
1346             out.print(&quot;inverted &quot;);
1347 
1348         if (type == TypeParenthesesSubpattern)
1349             out.print(&quot;subpattern&quot;);
1350         else if (type == TypeParentheticalAssertion)
1351             out.print(&quot;assertion&quot;);
1352 
1353         if (m_capture)
1354             out.print(&quot; #&quot;, parentheses.subpatternId);
1355 
1356         dumpQuantifier(out);
1357 
1358         if (parentheses.isCopy)
1359             out.print(&quot;,copy&quot;);
1360 
1361         if (parentheses.isTerminal)
1362             out.print(&quot;,terminal&quot;);
1363 
1364         out.println(&quot;,frame location &quot;, frameLocation);
1365 
1366         if (parentheses.disjunction-&gt;m_alternatives.size() &gt; 1) {
1367             indentForNestingLevel(out, nestingDepth + 1);
1368             unsigned alternativeFrameLocation = frameLocation;
1369             if (quantityMaxCount == 1 &amp;&amp; !parentheses.isCopy)
1370                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
1371             else if (parentheses.isTerminal)
1372                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
1373             else
1374                 alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
1375             out.println(&quot;alternative list,frame location &quot;, alternativeFrameLocation);
1376         }
1377 
1378         parentheses.disjunction-&gt;dump(out, thisPattern, nestingDepth + 1);
1379         break;
1380     case TypeDotStarEnclosure:
1381         out.println(&quot;.* enclosure,frame location &quot;, thisPattern-&gt;m_initialStartValueFrameLocation);
1382         break;
1383     }
1384 }
1385 
1386 void PatternDisjunction::dump(PrintStream&amp; out, YarrPattern* thisPattern, unsigned nestingDepth = 0)
1387 {
1388     unsigned alternativeCount = m_alternatives.size();
1389     for (unsigned i = 0; i &lt; alternativeCount; ++i) {
1390         indentForNestingLevel(out, nestingDepth);
1391         if (alternativeCount &gt; 1)
1392             out.print(&quot;alternative #&quot;, i, &quot;: &quot;);
1393         m_alternatives[i].get()-&gt;dump(out, thisPattern, nestingDepth + (alternativeCount &gt; 1));
1394     }
1395 }
1396 
1397 void YarrPattern::dumpPatternString(PrintStream&amp; out, const String&amp; patternString)
1398 {
1399     out.print(&quot;/&quot;, patternString, &quot;/&quot;);
1400 
1401     if (global())
1402         out.print(&quot;g&quot;);
1403     if (ignoreCase())
1404         out.print(&quot;i&quot;);
1405     if (multiline())
1406         out.print(&quot;m&quot;);
1407     if (unicode())
1408         out.print(&quot;u&quot;);
1409     if (sticky())
1410         out.print(&quot;y&quot;);
1411 }
1412 
1413 void YarrPattern::dumpPattern(const String&amp; patternString)
1414 {
1415     dumpPattern(WTF::dataFile(), patternString);
1416 }
1417 
1418 void YarrPattern::dumpPattern(PrintStream&amp; out, const String&amp; patternString)
1419 {
1420     out.print(&quot;RegExp pattern for &quot;);
1421     dumpPatternString(out, patternString);
1422 
<a name="33" id="anc33"></a><span class="line-modified">1423     if (m_flags != NoFlags) {</span>
<span class="line-modified">1424         bool printSeperator = false;</span>
1425         out.print(&quot; (&quot;);
1426         if (global()) {
1427             out.print(&quot;global&quot;);
<a name="34" id="anc34"></a><span class="line-modified">1428             printSeperator = true;</span>
1429         }
1430         if (ignoreCase()) {
<a name="35" id="anc35"></a><span class="line-modified">1431             if (printSeperator)</span>
1432                 out.print(&quot;|&quot;);
1433             out.print(&quot;ignore case&quot;);
<a name="36" id="anc36"></a><span class="line-modified">1434             printSeperator = true;</span>
1435         }
1436         if (multiline()) {
<a name="37" id="anc37"></a><span class="line-modified">1437             if (printSeperator)</span>
1438                 out.print(&quot;|&quot;);
1439             out.print(&quot;multiline&quot;);
<a name="38" id="anc38"></a><span class="line-modified">1440             printSeperator = true;</span>
1441         }
1442         if (unicode()) {
<a name="39" id="anc39"></a><span class="line-modified">1443             if (printSeperator)</span>
1444                 out.print(&quot;|&quot;);
1445             out.print(&quot;unicode&quot;);
<a name="40" id="anc40"></a><span class="line-modified">1446             printSeperator = true;</span>
1447         }
1448         if (sticky()) {
<a name="41" id="anc41"></a><span class="line-modified">1449             if (printSeperator)</span>
1450                 out.print(&quot;|&quot;);
1451             out.print(&quot;sticky&quot;);
<a name="42" id="anc42"></a><span class="line-removed">1452             printSeperator = true;</span>
1453         }
1454         out.print(&quot;)&quot;);
1455     }
1456     out.print(&quot;:\n&quot;);
1457     if (m_body-&gt;m_callFrameSize)
1458         out.print(&quot;    callframe size: &quot;, m_body-&gt;m_callFrameSize, &quot;\n&quot;);
1459     m_body-&gt;dump(out, this);
1460 }
1461 
1462 std::unique_ptr&lt;CharacterClass&gt; anycharCreate()
1463 {
<a name="43" id="anc43"></a><span class="line-modified">1464     auto characterClass = std::make_unique&lt;CharacterClass&gt;();</span>
1465     characterClass-&gt;m_ranges.append(CharacterRange(0x00, 0x7f));
1466     characterClass-&gt;m_rangesUnicode.append(CharacterRange(0x0080, 0x10ffff));
<a name="44" id="anc44"></a><span class="line-modified">1467     characterClass-&gt;m_hasNonBMPCharacters = true;</span>
1468     characterClass-&gt;m_anyCharacter = true;
1469     return characterClass;
1470 }
1471 
1472 } } // namespace JSC::Yarr
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>