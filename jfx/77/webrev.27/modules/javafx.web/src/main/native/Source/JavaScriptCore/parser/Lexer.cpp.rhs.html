<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  *  Copyright (C) 2006-2019 Apple Inc. All Rights Reserved.</span>
   4  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   5  *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   6  *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Library General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Library General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Library General Public License
  19  *  along with this library; see the file COPYING.LIB.  If not, write to
  20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  *  Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Lexer.h&quot;
  27 
  28 #include &quot;BuiltinNames.h&quot;
  29 #include &quot;Identifier.h&quot;
  30 #include &quot;JSCInlines.h&quot;
  31 #include &quot;JSFunctionInlines.h&quot;
  32 #include &quot;KeywordLookup.h&quot;
  33 #include &quot;Lexer.lut.h&quot;
  34 #include &quot;Nodes.h&quot;
  35 #include &quot;ParseInt.h&quot;
  36 #include &quot;Parser.h&quot;
  37 #include &lt;ctype.h&gt;
  38 #include &lt;limits.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/Assertions.h&gt;
  41 #include &lt;wtf/HexNumber.h&gt;
  42 #include &lt;wtf/Variant.h&gt;
  43 #include &lt;wtf/dtoa.h&gt;
  44 
  45 namespace JSC {
  46 
  47 bool isLexerKeyword(const Identifier&amp; identifier)
  48 {
  49     return JSC::mainTable.entry(identifier);
  50 }
  51 
  52 enum CharacterType {
  53     // Types for the main switch
  54 
  55     // The first three types are fixed, and also used for identifying
  56     // ASCII alpha and alphanumeric characters (see isIdentStart and isIdentPart).
  57     CharacterIdentifierStart,
  58     CharacterZero,
  59     CharacterNumber,
  60 
  61     // For single-byte characters grandfathered into Other_ID_Continue -- namely just U+00B7 MIDDLE DOT.
  62     // (http://unicode.org/reports/tr31/#Backward_Compatibility)
  63     CharacterOtherIdentifierPart,
  64 
  65     CharacterInvalid,
  66     CharacterLineTerminator,
  67     CharacterExclamationMark,
  68     CharacterOpenParen,
  69     CharacterCloseParen,
  70     CharacterOpenBracket,
  71     CharacterCloseBracket,
  72     CharacterComma,
  73     CharacterColon,
  74     CharacterQuestion,
  75     CharacterTilde,
  76     CharacterQuote,
  77     CharacterBackQuote,
  78     CharacterDot,
  79     CharacterSlash,
  80     CharacterBackSlash,
  81     CharacterSemicolon,
  82     CharacterOpenBrace,
  83     CharacterCloseBrace,
  84 
  85     CharacterAdd,
  86     CharacterSub,
  87     CharacterMultiply,
  88     CharacterModulo,
  89     CharacterAnd,
  90     CharacterXor,
  91     CharacterOr,
  92     CharacterLess,
  93     CharacterGreater,
  94     CharacterEqual,
  95 
  96     // Other types (only one so far)
  97     CharacterWhiteSpace,
<a name="2" id="anc2"></a><span class="line-added">  98     CharacterHash,</span>
  99     CharacterPrivateIdentifierStart
 100 };
 101 
 102 // 256 Latin-1 codes
 103 static constexpr const unsigned short typesOfLatin1Characters[256] = {
 104 /*   0 - Null               */ CharacterInvalid,
 105 /*   1 - Start of Heading   */ CharacterInvalid,
 106 /*   2 - Start of Text      */ CharacterInvalid,
 107 /*   3 - End of Text        */ CharacterInvalid,
 108 /*   4 - End of Transm.     */ CharacterInvalid,
 109 /*   5 - Enquiry            */ CharacterInvalid,
 110 /*   6 - Acknowledgment     */ CharacterInvalid,
 111 /*   7 - Bell               */ CharacterInvalid,
 112 /*   8 - Back Space         */ CharacterInvalid,
 113 /*   9 - Horizontal Tab     */ CharacterWhiteSpace,
 114 /*  10 - Line Feed          */ CharacterLineTerminator,
 115 /*  11 - Vertical Tab       */ CharacterWhiteSpace,
 116 /*  12 - Form Feed          */ CharacterWhiteSpace,
 117 /*  13 - Carriage Return    */ CharacterLineTerminator,
 118 /*  14 - Shift Out          */ CharacterInvalid,
 119 /*  15 - Shift In           */ CharacterInvalid,
 120 /*  16 - Data Line Escape   */ CharacterInvalid,
 121 /*  17 - Device Control 1   */ CharacterInvalid,
 122 /*  18 - Device Control 2   */ CharacterInvalid,
 123 /*  19 - Device Control 3   */ CharacterInvalid,
 124 /*  20 - Device Control 4   */ CharacterInvalid,
 125 /*  21 - Negative Ack.      */ CharacterInvalid,
 126 /*  22 - Synchronous Idle   */ CharacterInvalid,
 127 /*  23 - End of Transmit    */ CharacterInvalid,
 128 /*  24 - Cancel             */ CharacterInvalid,
 129 /*  25 - End of Medium      */ CharacterInvalid,
 130 /*  26 - Substitute         */ CharacterInvalid,
 131 /*  27 - Escape             */ CharacterInvalid,
 132 /*  28 - File Separator     */ CharacterInvalid,
 133 /*  29 - Group Separator    */ CharacterInvalid,
 134 /*  30 - Record Separator   */ CharacterInvalid,
 135 /*  31 - Unit Separator     */ CharacterInvalid,
 136 /*  32 - Space              */ CharacterWhiteSpace,
 137 /*  33 - !                  */ CharacterExclamationMark,
 138 /*  34 - &quot;                  */ CharacterQuote,
<a name="3" id="anc3"></a><span class="line-modified"> 139 /*  35 - #                  */ CharacterHash,</span>
 140 /*  36 - $                  */ CharacterIdentifierStart,
 141 /*  37 - %                  */ CharacterModulo,
 142 /*  38 - &amp;                  */ CharacterAnd,
 143 /*  39 - &#39;                  */ CharacterQuote,
 144 /*  40 - (                  */ CharacterOpenParen,
 145 /*  41 - )                  */ CharacterCloseParen,
 146 /*  42 - *                  */ CharacterMultiply,
 147 /*  43 - +                  */ CharacterAdd,
 148 /*  44 - ,                  */ CharacterComma,
 149 /*  45 - -                  */ CharacterSub,
 150 /*  46 - .                  */ CharacterDot,
 151 /*  47 - /                  */ CharacterSlash,
 152 /*  48 - 0                  */ CharacterZero,
 153 /*  49 - 1                  */ CharacterNumber,
 154 /*  50 - 2                  */ CharacterNumber,
 155 /*  51 - 3                  */ CharacterNumber,
 156 /*  52 - 4                  */ CharacterNumber,
 157 /*  53 - 5                  */ CharacterNumber,
 158 /*  54 - 6                  */ CharacterNumber,
 159 /*  55 - 7                  */ CharacterNumber,
 160 /*  56 - 8                  */ CharacterNumber,
 161 /*  57 - 9                  */ CharacterNumber,
 162 /*  58 - :                  */ CharacterColon,
 163 /*  59 - ;                  */ CharacterSemicolon,
 164 /*  60 - &lt;                  */ CharacterLess,
 165 /*  61 - =                  */ CharacterEqual,
 166 /*  62 - &gt;                  */ CharacterGreater,
 167 /*  63 - ?                  */ CharacterQuestion,
 168 /*  64 - @                  */ CharacterPrivateIdentifierStart,
 169 /*  65 - A                  */ CharacterIdentifierStart,
 170 /*  66 - B                  */ CharacterIdentifierStart,
 171 /*  67 - C                  */ CharacterIdentifierStart,
 172 /*  68 - D                  */ CharacterIdentifierStart,
 173 /*  69 - E                  */ CharacterIdentifierStart,
 174 /*  70 - F                  */ CharacterIdentifierStart,
 175 /*  71 - G                  */ CharacterIdentifierStart,
 176 /*  72 - H                  */ CharacterIdentifierStart,
 177 /*  73 - I                  */ CharacterIdentifierStart,
 178 /*  74 - J                  */ CharacterIdentifierStart,
 179 /*  75 - K                  */ CharacterIdentifierStart,
 180 /*  76 - L                  */ CharacterIdentifierStart,
 181 /*  77 - M                  */ CharacterIdentifierStart,
 182 /*  78 - N                  */ CharacterIdentifierStart,
 183 /*  79 - O                  */ CharacterIdentifierStart,
 184 /*  80 - P                  */ CharacterIdentifierStart,
 185 /*  81 - Q                  */ CharacterIdentifierStart,
 186 /*  82 - R                  */ CharacterIdentifierStart,
 187 /*  83 - S                  */ CharacterIdentifierStart,
 188 /*  84 - T                  */ CharacterIdentifierStart,
 189 /*  85 - U                  */ CharacterIdentifierStart,
 190 /*  86 - V                  */ CharacterIdentifierStart,
 191 /*  87 - W                  */ CharacterIdentifierStart,
 192 /*  88 - X                  */ CharacterIdentifierStart,
 193 /*  89 - Y                  */ CharacterIdentifierStart,
 194 /*  90 - Z                  */ CharacterIdentifierStart,
 195 /*  91 - [                  */ CharacterOpenBracket,
 196 /*  92 - \                  */ CharacterBackSlash,
 197 /*  93 - ]                  */ CharacterCloseBracket,
 198 /*  94 - ^                  */ CharacterXor,
 199 /*  95 - _                  */ CharacterIdentifierStart,
 200 /*  96 - `                  */ CharacterBackQuote,
 201 /*  97 - a                  */ CharacterIdentifierStart,
 202 /*  98 - b                  */ CharacterIdentifierStart,
 203 /*  99 - c                  */ CharacterIdentifierStart,
 204 /* 100 - d                  */ CharacterIdentifierStart,
 205 /* 101 - e                  */ CharacterIdentifierStart,
 206 /* 102 - f                  */ CharacterIdentifierStart,
 207 /* 103 - g                  */ CharacterIdentifierStart,
 208 /* 104 - h                  */ CharacterIdentifierStart,
 209 /* 105 - i                  */ CharacterIdentifierStart,
 210 /* 106 - j                  */ CharacterIdentifierStart,
 211 /* 107 - k                  */ CharacterIdentifierStart,
 212 /* 108 - l                  */ CharacterIdentifierStart,
 213 /* 109 - m                  */ CharacterIdentifierStart,
 214 /* 110 - n                  */ CharacterIdentifierStart,
 215 /* 111 - o                  */ CharacterIdentifierStart,
 216 /* 112 - p                  */ CharacterIdentifierStart,
 217 /* 113 - q                  */ CharacterIdentifierStart,
 218 /* 114 - r                  */ CharacterIdentifierStart,
 219 /* 115 - s                  */ CharacterIdentifierStart,
 220 /* 116 - t                  */ CharacterIdentifierStart,
 221 /* 117 - u                  */ CharacterIdentifierStart,
 222 /* 118 - v                  */ CharacterIdentifierStart,
 223 /* 119 - w                  */ CharacterIdentifierStart,
 224 /* 120 - x                  */ CharacterIdentifierStart,
 225 /* 121 - y                  */ CharacterIdentifierStart,
 226 /* 122 - z                  */ CharacterIdentifierStart,
 227 /* 123 - {                  */ CharacterOpenBrace,
 228 /* 124 - |                  */ CharacterOr,
 229 /* 125 - }                  */ CharacterCloseBrace,
 230 /* 126 - ~                  */ CharacterTilde,
 231 /* 127 - Delete             */ CharacterInvalid,
 232 /* 128 - Cc category        */ CharacterInvalid,
 233 /* 129 - Cc category        */ CharacterInvalid,
 234 /* 130 - Cc category        */ CharacterInvalid,
 235 /* 131 - Cc category        */ CharacterInvalid,
 236 /* 132 - Cc category        */ CharacterInvalid,
 237 /* 133 - Cc category        */ CharacterInvalid,
 238 /* 134 - Cc category        */ CharacterInvalid,
 239 /* 135 - Cc category        */ CharacterInvalid,
 240 /* 136 - Cc category        */ CharacterInvalid,
 241 /* 137 - Cc category        */ CharacterInvalid,
 242 /* 138 - Cc category        */ CharacterInvalid,
 243 /* 139 - Cc category        */ CharacterInvalid,
 244 /* 140 - Cc category        */ CharacterInvalid,
 245 /* 141 - Cc category        */ CharacterInvalid,
 246 /* 142 - Cc category        */ CharacterInvalid,
 247 /* 143 - Cc category        */ CharacterInvalid,
 248 /* 144 - Cc category        */ CharacterInvalid,
 249 /* 145 - Cc category        */ CharacterInvalid,
 250 /* 146 - Cc category        */ CharacterInvalid,
 251 /* 147 - Cc category        */ CharacterInvalid,
 252 /* 148 - Cc category        */ CharacterInvalid,
 253 /* 149 - Cc category        */ CharacterInvalid,
 254 /* 150 - Cc category        */ CharacterInvalid,
 255 /* 151 - Cc category        */ CharacterInvalid,
 256 /* 152 - Cc category        */ CharacterInvalid,
 257 /* 153 - Cc category        */ CharacterInvalid,
 258 /* 154 - Cc category        */ CharacterInvalid,
 259 /* 155 - Cc category        */ CharacterInvalid,
 260 /* 156 - Cc category        */ CharacterInvalid,
 261 /* 157 - Cc category        */ CharacterInvalid,
 262 /* 158 - Cc category        */ CharacterInvalid,
 263 /* 159 - Cc category        */ CharacterInvalid,
 264 /* 160 - Zs category (nbsp) */ CharacterWhiteSpace,
 265 /* 161 - Po category        */ CharacterInvalid,
 266 /* 162 - Sc category        */ CharacterInvalid,
 267 /* 163 - Sc category        */ CharacterInvalid,
 268 /* 164 - Sc category        */ CharacterInvalid,
 269 /* 165 - Sc category        */ CharacterInvalid,
 270 /* 166 - So category        */ CharacterInvalid,
 271 /* 167 - So category        */ CharacterInvalid,
 272 /* 168 - Sk category        */ CharacterInvalid,
 273 /* 169 - So category        */ CharacterInvalid,
 274 /* 170 - Ll category        */ CharacterIdentifierStart,
 275 /* 171 - Pi category        */ CharacterInvalid,
 276 /* 172 - Sm category        */ CharacterInvalid,
 277 /* 173 - Cf category        */ CharacterInvalid,
 278 /* 174 - So category        */ CharacterInvalid,
 279 /* 175 - Sk category        */ CharacterInvalid,
 280 /* 176 - So category        */ CharacterInvalid,
 281 /* 177 - Sm category        */ CharacterInvalid,
 282 /* 178 - No category        */ CharacterInvalid,
 283 /* 179 - No category        */ CharacterInvalid,
 284 /* 180 - Sk category        */ CharacterInvalid,
 285 /* 181 - Ll category        */ CharacterIdentifierStart,
 286 /* 182 - So category        */ CharacterInvalid,
 287 /* 183 - Po category        */ CharacterOtherIdentifierPart,
 288 /* 184 - Sk category        */ CharacterInvalid,
 289 /* 185 - No category        */ CharacterInvalid,
 290 /* 186 - Ll category        */ CharacterIdentifierStart,
 291 /* 187 - Pf category        */ CharacterInvalid,
 292 /* 188 - No category        */ CharacterInvalid,
 293 /* 189 - No category        */ CharacterInvalid,
 294 /* 190 - No category        */ CharacterInvalid,
 295 /* 191 - Po category        */ CharacterInvalid,
 296 /* 192 - Lu category        */ CharacterIdentifierStart,
 297 /* 193 - Lu category        */ CharacterIdentifierStart,
 298 /* 194 - Lu category        */ CharacterIdentifierStart,
 299 /* 195 - Lu category        */ CharacterIdentifierStart,
 300 /* 196 - Lu category        */ CharacterIdentifierStart,
 301 /* 197 - Lu category        */ CharacterIdentifierStart,
 302 /* 198 - Lu category        */ CharacterIdentifierStart,
 303 /* 199 - Lu category        */ CharacterIdentifierStart,
 304 /* 200 - Lu category        */ CharacterIdentifierStart,
 305 /* 201 - Lu category        */ CharacterIdentifierStart,
 306 /* 202 - Lu category        */ CharacterIdentifierStart,
 307 /* 203 - Lu category        */ CharacterIdentifierStart,
 308 /* 204 - Lu category        */ CharacterIdentifierStart,
 309 /* 205 - Lu category        */ CharacterIdentifierStart,
 310 /* 206 - Lu category        */ CharacterIdentifierStart,
 311 /* 207 - Lu category        */ CharacterIdentifierStart,
 312 /* 208 - Lu category        */ CharacterIdentifierStart,
 313 /* 209 - Lu category        */ CharacterIdentifierStart,
 314 /* 210 - Lu category        */ CharacterIdentifierStart,
 315 /* 211 - Lu category        */ CharacterIdentifierStart,
 316 /* 212 - Lu category        */ CharacterIdentifierStart,
 317 /* 213 - Lu category        */ CharacterIdentifierStart,
 318 /* 214 - Lu category        */ CharacterIdentifierStart,
 319 /* 215 - Sm category        */ CharacterInvalid,
 320 /* 216 - Lu category        */ CharacterIdentifierStart,
 321 /* 217 - Lu category        */ CharacterIdentifierStart,
 322 /* 218 - Lu category        */ CharacterIdentifierStart,
 323 /* 219 - Lu category        */ CharacterIdentifierStart,
 324 /* 220 - Lu category        */ CharacterIdentifierStart,
 325 /* 221 - Lu category        */ CharacterIdentifierStart,
 326 /* 222 - Lu category        */ CharacterIdentifierStart,
 327 /* 223 - Ll category        */ CharacterIdentifierStart,
 328 /* 224 - Ll category        */ CharacterIdentifierStart,
 329 /* 225 - Ll category        */ CharacterIdentifierStart,
 330 /* 226 - Ll category        */ CharacterIdentifierStart,
 331 /* 227 - Ll category        */ CharacterIdentifierStart,
 332 /* 228 - Ll category        */ CharacterIdentifierStart,
 333 /* 229 - Ll category        */ CharacterIdentifierStart,
 334 /* 230 - Ll category        */ CharacterIdentifierStart,
 335 /* 231 - Ll category        */ CharacterIdentifierStart,
 336 /* 232 - Ll category        */ CharacterIdentifierStart,
 337 /* 233 - Ll category        */ CharacterIdentifierStart,
 338 /* 234 - Ll category        */ CharacterIdentifierStart,
 339 /* 235 - Ll category        */ CharacterIdentifierStart,
 340 /* 236 - Ll category        */ CharacterIdentifierStart,
 341 /* 237 - Ll category        */ CharacterIdentifierStart,
 342 /* 238 - Ll category        */ CharacterIdentifierStart,
 343 /* 239 - Ll category        */ CharacterIdentifierStart,
 344 /* 240 - Ll category        */ CharacterIdentifierStart,
 345 /* 241 - Ll category        */ CharacterIdentifierStart,
 346 /* 242 - Ll category        */ CharacterIdentifierStart,
 347 /* 243 - Ll category        */ CharacterIdentifierStart,
 348 /* 244 - Ll category        */ CharacterIdentifierStart,
 349 /* 245 - Ll category        */ CharacterIdentifierStart,
 350 /* 246 - Ll category        */ CharacterIdentifierStart,
 351 /* 247 - Sm category        */ CharacterInvalid,
 352 /* 248 - Ll category        */ CharacterIdentifierStart,
 353 /* 249 - Ll category        */ CharacterIdentifierStart,
 354 /* 250 - Ll category        */ CharacterIdentifierStart,
 355 /* 251 - Ll category        */ CharacterIdentifierStart,
 356 /* 252 - Ll category        */ CharacterIdentifierStart,
 357 /* 253 - Ll category        */ CharacterIdentifierStart,
 358 /* 254 - Ll category        */ CharacterIdentifierStart,
 359 /* 255 - Ll category        */ CharacterIdentifierStart
 360 };
 361 
 362 // This table provides the character that results from \X where X is the index in the table beginning
 363 // with SPACE. A table value of 0 means that more processing needs to be done.
 364 static constexpr const LChar singleCharacterEscapeValuesForASCII[128] = {
 365 /*   0 - Null               */ 0,
 366 /*   1 - Start of Heading   */ 0,
 367 /*   2 - Start of Text      */ 0,
 368 /*   3 - End of Text        */ 0,
 369 /*   4 - End of Transm.     */ 0,
 370 /*   5 - Enquiry            */ 0,
 371 /*   6 - Acknowledgment     */ 0,
 372 /*   7 - Bell               */ 0,
 373 /*   8 - Back Space         */ 0,
 374 /*   9 - Horizontal Tab     */ 0,
 375 /*  10 - Line Feed          */ 0,
 376 /*  11 - Vertical Tab       */ 0,
 377 /*  12 - Form Feed          */ 0,
 378 /*  13 - Carriage Return    */ 0,
 379 /*  14 - Shift Out          */ 0,
 380 /*  15 - Shift In           */ 0,
 381 /*  16 - Data Line Escape   */ 0,
 382 /*  17 - Device Control 1   */ 0,
 383 /*  18 - Device Control 2   */ 0,
 384 /*  19 - Device Control 3   */ 0,
 385 /*  20 - Device Control 4   */ 0,
 386 /*  21 - Negative Ack.      */ 0,
 387 /*  22 - Synchronous Idle   */ 0,
 388 /*  23 - End of Transmit    */ 0,
 389 /*  24 - Cancel             */ 0,
 390 /*  25 - End of Medium      */ 0,
 391 /*  26 - Substitute         */ 0,
 392 /*  27 - Escape             */ 0,
 393 /*  28 - File Separator     */ 0,
 394 /*  29 - Group Separator    */ 0,
 395 /*  30 - Record Separator   */ 0,
 396 /*  31 - Unit Separator     */ 0,
 397 /*  32 - Space              */ &#39; &#39;,
 398 /*  33 - !                  */ &#39;!&#39;,
 399 /*  34 - &quot;                  */ &#39;&quot;&#39;,
 400 /*  35 - #                  */ &#39;#&#39;,
 401 /*  36 - $                  */ &#39;$&#39;,
 402 /*  37 - %                  */ &#39;%&#39;,
 403 /*  38 - &amp;                  */ &#39;&amp;&#39;,
 404 /*  39 - &#39;                  */ &#39;\&#39;&#39;,
 405 /*  40 - (                  */ &#39;(&#39;,
 406 /*  41 - )                  */ &#39;)&#39;,
 407 /*  42 - *                  */ &#39;*&#39;,
 408 /*  43 - +                  */ &#39;+&#39;,
 409 /*  44 - ,                  */ &#39;,&#39;,
 410 /*  45 - -                  */ &#39;-&#39;,
 411 /*  46 - .                  */ &#39;.&#39;,
 412 /*  47 - /                  */ &#39;/&#39;,
 413 /*  48 - 0                  */ 0,
 414 /*  49 - 1                  */ 0,
 415 /*  50 - 2                  */ 0,
 416 /*  51 - 3                  */ 0,
 417 /*  52 - 4                  */ 0,
 418 /*  53 - 5                  */ 0,
 419 /*  54 - 6                  */ 0,
 420 /*  55 - 7                  */ 0,
 421 /*  56 - 8                  */ 0,
 422 /*  57 - 9                  */ 0,
 423 /*  58 - :                  */ &#39;:&#39;,
 424 /*  59 - ;                  */ &#39;;&#39;,
 425 /*  60 - &lt;                  */ &#39;&lt;&#39;,
 426 /*  61 - =                  */ &#39;=&#39;,
 427 /*  62 - &gt;                  */ &#39;&gt;&#39;,
 428 /*  63 - ?                  */ &#39;?&#39;,
 429 /*  64 - @                  */ &#39;@&#39;,
 430 /*  65 - A                  */ &#39;A&#39;,
 431 /*  66 - B                  */ &#39;B&#39;,
 432 /*  67 - C                  */ &#39;C&#39;,
 433 /*  68 - D                  */ &#39;D&#39;,
 434 /*  69 - E                  */ &#39;E&#39;,
 435 /*  70 - F                  */ &#39;F&#39;,
 436 /*  71 - G                  */ &#39;G&#39;,
 437 /*  72 - H                  */ &#39;H&#39;,
 438 /*  73 - I                  */ &#39;I&#39;,
 439 /*  74 - J                  */ &#39;J&#39;,
 440 /*  75 - K                  */ &#39;K&#39;,
 441 /*  76 - L                  */ &#39;L&#39;,
 442 /*  77 - M                  */ &#39;M&#39;,
 443 /*  78 - N                  */ &#39;N&#39;,
 444 /*  79 - O                  */ &#39;O&#39;,
 445 /*  80 - P                  */ &#39;P&#39;,
 446 /*  81 - Q                  */ &#39;Q&#39;,
 447 /*  82 - R                  */ &#39;R&#39;,
 448 /*  83 - S                  */ &#39;S&#39;,
 449 /*  84 - T                  */ &#39;T&#39;,
 450 /*  85 - U                  */ &#39;U&#39;,
 451 /*  86 - V                  */ &#39;V&#39;,
 452 /*  87 - W                  */ &#39;W&#39;,
 453 /*  88 - X                  */ &#39;X&#39;,
 454 /*  89 - Y                  */ &#39;Y&#39;,
 455 /*  90 - Z                  */ &#39;Z&#39;,
 456 /*  91 - [                  */ &#39;[&#39;,
 457 /*  92 - \                  */ &#39;\\&#39;,
 458 /*  93 - ]                  */ &#39;]&#39;,
 459 /*  94 - ^                  */ &#39;^&#39;,
 460 /*  95 - _                  */ &#39;_&#39;,
 461 /*  96 - `                  */ &#39;`&#39;,
 462 /*  97 - a                  */ &#39;a&#39;,
 463 /*  98 - b                  */ 0x08,
 464 /*  99 - c                  */ &#39;c&#39;,
 465 /* 100 - d                  */ &#39;d&#39;,
 466 /* 101 - e                  */ &#39;e&#39;,
 467 /* 102 - f                  */ 0x0C,
 468 /* 103 - g                  */ &#39;g&#39;,
 469 /* 104 - h                  */ &#39;h&#39;,
 470 /* 105 - i                  */ &#39;i&#39;,
 471 /* 106 - j                  */ &#39;j&#39;,
 472 /* 107 - k                  */ &#39;k&#39;,
 473 /* 108 - l                  */ &#39;l&#39;,
 474 /* 109 - m                  */ &#39;m&#39;,
 475 /* 110 - n                  */ 0x0A,
 476 /* 111 - o                  */ &#39;o&#39;,
 477 /* 112 - p                  */ &#39;p&#39;,
 478 /* 113 - q                  */ &#39;q&#39;,
 479 /* 114 - r                  */ 0x0D,
 480 /* 115 - s                  */ &#39;s&#39;,
 481 /* 116 - t                  */ 0x09,
 482 /* 117 - u                  */ 0,
 483 /* 118 - v                  */ 0x0B,
 484 /* 119 - w                  */ &#39;w&#39;,
 485 /* 120 - x                  */ 0,
 486 /* 121 - y                  */ &#39;y&#39;,
 487 /* 122 - z                  */ &#39;z&#39;,
 488 /* 123 - {                  */ &#39;{&#39;,
 489 /* 124 - |                  */ &#39;|&#39;,
 490 /* 125 - }                  */ &#39;}&#39;,
 491 /* 126 - ~                  */ &#39;~&#39;,
 492 /* 127 - Delete             */ 0
 493 };
 494 
 495 template &lt;typename T&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 496 Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)</span>
 497     : m_isReparsingFunction(false)
 498     , m_vm(vm)
 499     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 500     , m_scriptMode(scriptMode)
 501 {
 502 }
 503 
 504 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 505 {
 506     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 507         return INTEGER;
 508     return DOUBLE;
 509 }
 510 
 511 template &lt;typename T&gt;
 512 Lexer&lt;T&gt;::~Lexer()
 513 {
 514 }
 515 
 516 template &lt;typename T&gt;
 517 String Lexer&lt;T&gt;::invalidCharacterMessage() const
 518 {
 519     switch (m_current) {
 520     case 0:
 521         return &quot;Invalid character: &#39;\\0&#39;&quot;_s;
 522     case 10:
 523         return &quot;Invalid character: &#39;\\n&#39;&quot;_s;
 524     case 11:
 525         return &quot;Invalid character: &#39;\\v&#39;&quot;_s;
 526     case 13:
 527         return &quot;Invalid character: &#39;\\r&#39;&quot;_s;
 528     case 35:
 529         return &quot;Invalid character: &#39;#&#39;&quot;_s;
 530     case 64:
 531         return &quot;Invalid character: &#39;@&#39;&quot;_s;
 532     case 96:
 533         return &quot;Invalid character: &#39;`&#39;&quot;_s;
 534     default:
 535         return makeString(&quot;Invalid character &#39;\\u&quot;, hex(m_current, 4, Lowercase), &#39;\&#39;&#39;);
 536     }
 537 }
 538 
 539 template &lt;typename T&gt;
 540 ALWAYS_INLINE const T* Lexer&lt;T&gt;::currentSourcePtr() const
 541 {
 542     ASSERT(m_code &lt;= m_codeEnd);
 543     return m_code;
 544 }
 545 
 546 template &lt;typename T&gt;
 547 void Lexer&lt;T&gt;::setCode(const SourceCode&amp; source, ParserArena* arena)
 548 {
 549     m_arena = &amp;arena-&gt;identifierArena();
 550 
 551     m_lineNumber = source.firstLine().oneBasedInt();
 552     m_lastToken = -1;
 553 
 554     StringView sourceString = source.provider()-&gt;source();
 555 
 556     if (!sourceString.isNull())
 557         setCodeStart(sourceString);
 558     else
 559         m_codeStart = 0;
 560 
 561     m_source = &amp;source;
 562     m_sourceOffset = source.startOffset();
 563     m_codeStartPlusOffset = m_codeStart + source.startOffset();
 564     m_code = m_codeStartPlusOffset;
 565     m_codeEnd = m_codeStart + source.endOffset();
 566     m_error = false;
 567     m_atLineStart = true;
 568     m_lineStart = m_code;
 569     m_lexErrorMessage = String();
 570     m_sourceURLDirective = String();
 571     m_sourceMappingURLDirective = String();
 572 
 573     m_buffer8.reserveInitialCapacity(initialReadBufferCapacity);
 574     m_buffer16.reserveInitialCapacity(initialReadBufferCapacity);
 575     m_bufferForRawTemplateString16.reserveInitialCapacity(initialReadBufferCapacity);
 576 
 577     if (LIKELY(m_code &lt; m_codeEnd))
 578         m_current = *m_code;
 579     else
 580         m_current = 0;
 581     ASSERT(currentOffset() == source.startOffset());
 582 }
 583 
 584 template &lt;typename T&gt;
 585 template &lt;int shiftAmount&gt; ALWAYS_INLINE void Lexer&lt;T&gt;::internalShift()
 586 {
 587     m_code += shiftAmount;
 588     ASSERT(currentOffset() &gt;= currentLineStartOffset());
 589     m_current = *m_code;
 590 }
 591 
 592 template &lt;typename T&gt;
 593 ALWAYS_INLINE void Lexer&lt;T&gt;::shift()
 594 {
 595     // At one point timing showed that setting m_current to 0 unconditionally was faster than an if-else sequence.
 596     m_current = 0;
 597     ++m_code;
 598     if (LIKELY(m_code &lt; m_codeEnd))
 599         m_current = *m_code;
 600 }
 601 
 602 template &lt;typename T&gt;
 603 ALWAYS_INLINE bool Lexer&lt;T&gt;::atEnd() const
 604 {
 605     ASSERT(!m_current || m_code &lt; m_codeEnd);
 606     return UNLIKELY(UNLIKELY(!m_current) &amp;&amp; m_code == m_codeEnd);
 607 }
 608 
 609 template &lt;typename T&gt;
 610 ALWAYS_INLINE T Lexer&lt;T&gt;::peek(int offset) const
 611 {
 612     ASSERT(offset &gt; 0 &amp;&amp; offset &lt; 5);
 613     const T* code = m_code + offset;
 614     return (code &lt; m_codeEnd) ? *code : 0;
 615 }
 616 
 617 struct ParsedUnicodeEscapeValue {
 618     ParsedUnicodeEscapeValue(UChar32 value)
 619         : m_value(value)
 620     {
 621         ASSERT(isValid());
 622     }
 623 
 624     enum SpecialValueType { Incomplete = -2, Invalid = -1 };
 625     ParsedUnicodeEscapeValue(SpecialValueType type)
 626         : m_value(type)
 627     {
 628     }
 629 
 630     bool isValid() const { return m_value &gt;= 0; }
 631     bool isIncomplete() const { return m_value == Incomplete; }
 632 
 633     UChar32 value() const
 634     {
 635         ASSERT(isValid());
 636         return m_value;
 637     }
 638 
 639 private:
 640     UChar32 m_value;
 641 };
 642 
 643 template&lt;typename CharacterType&gt;
 644 ParsedUnicodeEscapeValue Lexer&lt;CharacterType&gt;::parseUnicodeEscape()
 645 {
 646     if (m_current == &#39;{&#39;) {
 647         shift();
 648         UChar32 codePoint = 0;
 649         do {
 650             if (!isASCIIHexDigit(m_current))
 651                 return m_current ? ParsedUnicodeEscapeValue::Invalid : ParsedUnicodeEscapeValue::Incomplete;
 652             codePoint = (codePoint &lt;&lt; 4) | toASCIIHexValue(m_current);
 653             if (codePoint &gt; UCHAR_MAX_VALUE) {
 654                 // For raw template literal syntax, we consume `NotEscapeSequence`.
 655                 // Here, we consume NotCodePoint&#39;s HexDigits.
 656                 //
 657                 // NotEscapeSequence ::
 658                 //     u { [lookahread not one of HexDigit]
 659                 //     u { NotCodePoint
 660                 //     u { CodePoint [lookahead != }]
 661                 //
 662                 // NotCodePoint ::
 663                 //     HexDigits but not if MV of HexDigits &lt;= 0x10FFFF
 664                 //
 665                 // CodePoint ::
 666                 //     HexDigits but not if MV of HexDigits &gt; 0x10FFFF
 667                 shift();
 668                 while (isASCIIHexDigit(m_current))
 669                     shift();
 670 
 671                 return atEnd() ? ParsedUnicodeEscapeValue::Incomplete : ParsedUnicodeEscapeValue::Invalid;
 672             }
 673             shift();
 674         } while (m_current != &#39;}&#39;);
 675         shift();
 676         return codePoint;
 677     }
 678 
 679     auto character2 = peek(1);
 680     auto character3 = peek(2);
 681     auto character4 = peek(3);
 682     if (UNLIKELY(!isASCIIHexDigit(m_current) || !isASCIIHexDigit(character2) || !isASCIIHexDigit(character3) || !isASCIIHexDigit(character4))) {
 683         auto result = (m_code + 4) &gt;= m_codeEnd ? ParsedUnicodeEscapeValue::Incomplete : ParsedUnicodeEscapeValue::Invalid;
 684 
 685         // For raw template literal syntax, we consume `NotEscapeSequence`.
 686         //
 687         // NotEscapeSequence ::
 688         //     u [lookahead not one of HexDigit][lookahead != {]
 689         //     u HexDigit [lookahead not one of HexDigit]
 690         //     u HexDigit HexDigit [lookahead not one of HexDigit]
 691         //     u HexDigit HexDigit HexDigit [lookahead not one of HexDigit]
 692         while (isASCIIHexDigit(m_current))
 693             shift();
 694 
 695         return result;
 696     }
 697 
 698     auto result = convertUnicode(m_current, character2, character3, character4);
 699     shift();
 700     shift();
 701     shift();
 702     shift();
 703     return result;
 704 }
 705 
 706 template &lt;typename T&gt;
 707 void Lexer&lt;T&gt;::shiftLineTerminator()
 708 {
 709     ASSERT(isLineTerminator(m_current));
 710 
 711     m_positionBeforeLastNewline = currentPosition();
 712     T prev = m_current;
 713     shift();
 714 
 715     if (prev == &#39;\r&#39; &amp;&amp; m_current == &#39;\n&#39;)
 716         shift();
 717 
 718     ++m_lineNumber;
 719 }
 720 
 721 template &lt;typename T&gt;
 722 ALWAYS_INLINE bool Lexer&lt;T&gt;::lastTokenWasRestrKeyword() const
 723 {
 724     return m_lastToken == CONTINUE || m_lastToken == BREAK || m_lastToken == RETURN || m_lastToken == THROW;
 725 }
 726 
 727 template &lt;typename T&gt;
 728 ALWAYS_INLINE void Lexer&lt;T&gt;::skipWhitespace()
 729 {
 730     while (isWhiteSpace(m_current))
 731         shift();
 732 }
 733 
 734 static NEVER_INLINE bool isNonLatin1IdentStart(UChar c)
 735 {
 736     return u_hasBinaryProperty(c, UCHAR_ID_START);
 737 }
 738 
 739 static inline bool isIdentStart(LChar c)
 740 {
 741     return typesOfLatin1Characters[c] == CharacterIdentifierStart;
 742 }
 743 
 744 static inline bool isIdentStart(UChar32 c)
 745 {
 746     return isLatin1(c) ? isIdentStart(static_cast&lt;LChar&gt;(c)) : isNonLatin1IdentStart(c);
 747 }
 748 
 749 static NEVER_INLINE bool isNonLatin1IdentPart(UChar32 c)
 750 {
 751     return u_hasBinaryProperty(c, UCHAR_ID_CONTINUE) || c == 0x200C || c == 0x200D;
 752 }
 753 
 754 static ALWAYS_INLINE bool isIdentPart(LChar c)
 755 {
 756     // Character types are divided into two groups depending on whether they can be part of an
 757     // identifier or not. Those whose type value is less or equal than CharacterOtherIdentifierPart can be
 758     // part of an identifier. (See the CharacterType definition for more details.)
 759     return typesOfLatin1Characters[c] &lt;= CharacterOtherIdentifierPart;
 760 }
 761 
 762 static ALWAYS_INLINE bool isIdentPart(UChar32 c)
 763 {
 764     return isLatin1(c) ? isIdentPart(static_cast&lt;LChar&gt;(c)) : isNonLatin1IdentPart(c);
 765 }
 766 
 767 static ALWAYS_INLINE bool isIdentPart(UChar c)
 768 {
 769     return isIdentPart(static_cast&lt;UChar32&gt;(c));
 770 }
 771 
 772 template&lt;typename CharacterType&gt; ALWAYS_INLINE bool isIdentPartIncludingEscapeTemplate(const CharacterType* code, const CharacterType* codeEnd)
 773 {
 774     if (isIdentPart(code[0]))
 775         return true;
 776 
 777     // Shortest sequence handled below is \u{0}, which is 5 characters.
 778     if (!(code[0] == &#39;\\&#39; &amp;&amp; codeEnd - code &gt;= 5 &amp;&amp; code[1] == &#39;u&#39;))
 779         return false;
 780 
 781     if (code[2] == &#39;{&#39;) {
 782         UChar32 codePoint = 0;
 783         const CharacterType* pointer;
 784         for (pointer = &amp;code[3]; pointer &lt; codeEnd; ++pointer) {
 785             auto digit = *pointer;
 786             if (!isASCIIHexDigit(digit))
 787                 break;
 788             codePoint = (codePoint &lt;&lt; 4) | toASCIIHexValue(digit);
 789             if (codePoint &gt; UCHAR_MAX_VALUE)
 790                 return false;
 791         }
 792         return isIdentPart(codePoint) &amp;&amp; pointer &lt; codeEnd &amp;&amp; *pointer == &#39;}&#39;;
 793     }
 794 
 795     // Shortest sequence handled below is \uXXXX, which is 6 characters.
 796     if (codeEnd - code &lt; 6)
 797         return false;
 798 
 799     auto character1 = code[2];
 800     auto character2 = code[3];
 801     auto character3 = code[4];
 802     auto character4 = code[5];
 803     return isASCIIHexDigit(character1) &amp;&amp; isASCIIHexDigit(character2) &amp;&amp; isASCIIHexDigit(character3) &amp;&amp; isASCIIHexDigit(character4)
 804         &amp;&amp; isIdentPart(Lexer&lt;LChar&gt;::convertUnicode(character1, character2, character3, character4));
 805 }
 806 
 807 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const LChar* code, const LChar* codeEnd)
 808 {
 809     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 810 }
 811 
 812 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
 813 {
 814     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 815 }
 816 
<a name="5" id="anc5"></a><span class="line-modified"> 817 template&lt;typename CharacterType&gt;</span>
<span class="line-added"> 818 static inline bool isASCIIDigitOrSeparator(CharacterType character)</span>
 819 {
<a name="6" id="anc6"></a><span class="line-modified"> 820     return isASCIIDigit(character) || character == &#39;_&#39;;</span>




 821 }
 822 
<a name="7" id="anc7"></a><span class="line-modified"> 823 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 824 static inline bool isASCIIHexDigitOrSeparator(CharacterType character)</span>
 825 {
<a name="8" id="anc8"></a><span class="line-modified"> 826     return isASCIIHexDigit(character) || character == &#39;_&#39;;</span>


 827 }
 828 
<a name="9" id="anc9"></a><span class="line-modified"> 829 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 830 static inline bool isASCIIBinaryDigitOrSeparator(CharacterType character)</span>
 831 {
<a name="10" id="anc10"></a><span class="line-modified"> 832     return isASCIIBinaryDigit(character) || character == &#39;_&#39;;</span>


 833 }
 834 
<a name="11" id="anc11"></a><span class="line-modified"> 835 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 836 static inline bool isASCIIOctalDigitOrSeparator(CharacterType character)</span>
 837 {
<a name="12" id="anc12"></a><span class="line-modified"> 838     return isASCIIOctalDigit(character) || character == &#39;_&#39;;</span>

 839 }
 840 
<a name="13" id="anc13"></a><span class="line-modified"> 841 static inline LChar singleEscape(int c)</span>
<span class="line-modified"> 842 {</span>
<span class="line-added"> 843     if (c &lt; 128) {</span>
<span class="line-added"> 844         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));</span>
<span class="line-added"> 845         return singleCharacterEscapeValuesForASCII[c];</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847     return 0;</span>
<span class="line-added"> 848 }</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850 template &lt;typename T&gt;</span>
<span class="line-added"> 851 inline void Lexer&lt;T&gt;::record8(int c)</span>
 852 {
<a name="14" id="anc14"></a><span class="line-added"> 853     ASSERT(isLatin1(c));</span>
<span class="line-added"> 854     m_buffer8.append(static_cast&lt;LChar&gt;(c));</span>
 855 }
 856 
 857 template &lt;typename T&gt;
 858 inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
 859 {
 860     size_t currentSize = m_buffer8.size();
 861     m_buffer8.grow(currentSize + length);
 862     LChar* rawBuffer = m_buffer8.data() + currentSize;
 863 
 864     for (size_t i = 0; i &lt; length; i++) {
 865         T c = p[i];
<a name="15" id="anc15"></a><span class="line-modified"> 866         ASSERT(isLatin1(c));</span>
 867         rawBuffer[i] = c;
 868     }
 869 }
 870 
 871 template &lt;typename T&gt;
 872 inline void Lexer&lt;T&gt;::append16(const LChar* p, size_t length)
 873 {
 874     size_t currentSize = m_buffer16.size();
 875     m_buffer16.grow(currentSize + length);
 876     UChar* rawBuffer = m_buffer16.data() + currentSize;
 877 
 878     for (size_t i = 0; i &lt; length; i++)
 879         rawBuffer[i] = p[i];
 880 }
 881 
 882 template &lt;typename T&gt;
 883 inline void Lexer&lt;T&gt;::record16(T c)
 884 {
 885     m_buffer16.append(c);
 886 }
 887 
 888 template &lt;typename T&gt;
 889 inline void Lexer&lt;T&gt;::record16(int c)
 890 {
 891     ASSERT(c &gt;= 0);
 892     ASSERT(c &lt;= static_cast&lt;int&gt;(USHRT_MAX));
 893     m_buffer16.append(static_cast&lt;UChar&gt;(c));
 894 }
 895 
 896 template&lt;typename CharacterType&gt; inline void Lexer&lt;CharacterType&gt;::recordUnicodeCodePoint(UChar32 codePoint)
 897 {
 898     ASSERT(codePoint &gt;= 0);
 899     ASSERT(codePoint &lt;= UCHAR_MAX_VALUE);
 900     if (U_IS_BMP(codePoint))
 901         record16(codePoint);
 902     else {
 903         UChar codeUnits[2] = { U16_LEAD(codePoint), U16_TRAIL(codePoint) };
 904         append16(codeUnits, 2);
 905     }
 906 }
 907 
 908 #if !ASSERT_DISABLED
 909 bool isSafeBuiltinIdentifier(VM&amp; vm, const Identifier* ident)
 910 {
 911     if (!ident)
 912         return true;
 913     /* Just block any use of suspicious identifiers.  This is intended to
 914      * be used as a safety net while implementing builtins.
 915      */
 916     // FIXME: How can a debug-only assertion be a safety net?
 917     if (*ident == vm.propertyNames-&gt;builtinNames().callPublicName())
 918         return false;
 919     if (*ident == vm.propertyNames-&gt;builtinNames().applyPublicName())
 920         return false;
 921     if (*ident == vm.propertyNames-&gt;eval)
 922         return false;
 923     if (*ident == vm.propertyNames-&gt;Function)
 924         return false;
 925     return true;
 926 }
 927 #endif
 928 
 929 template &lt;&gt;
 930 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::parseIdentifier(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)
 931 {
 932     tokenData-&gt;escaped = false;
 933     const ptrdiff_t remaining = m_codeEnd - m_code;
 934     if ((remaining &gt;= maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) {
 935         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
 936         if (keyword != IDENT) {
 937             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
 938             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
 939         }
 940     }
 941 
 942     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
 943     if (isPrivateName)
 944         shift();
 945 
 946     const LChar* identifierStart = currentSourcePtr();
 947     unsigned identifierLineStart = currentLineStartOffset();
 948 
 949     while (isIdentPart(m_current))
 950         shift();
 951 
 952     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 953         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 954         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
 955     }
 956 
 957     const Identifier* ident = nullptr;
 958 
 959     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 960         int identifierLength = currentSourcePtr() - identifierStart;
 961         ident = makeIdentifier(identifierStart, identifierLength);
 962         if (m_parsingBuiltinFunction) {
<a name="16" id="anc16"></a><span class="line-modified"> 963             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
 964                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 965                 return ERRORTOK;
 966             }
 967             if (isPrivateName)
<a name="17" id="anc17"></a><span class="line-modified"> 968                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified"> 969             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified"> 970                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
 971             if (!ident)
 972                 return INVALID_PRIVATE_NAME_ERRORTOK;
 973         }
 974         tokenData-&gt;ident = ident;
 975     } else
 976         tokenData-&gt;ident = nullptr;
 977 
 978     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
 979         ASSERT(shouldCreateIdentifier);
 980         if (remaining &lt; maxTokenLength) {
 981             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 982             ASSERT((remaining &lt; maxTokenLength) || !entry);
 983             if (!entry)
 984                 return IDENT;
 985             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 986             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 987         }
 988         return IDENT;
 989     }
 990 
 991     return IDENT;
 992 }
 993 
 994 template &lt;&gt;
 995 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;UChar&gt;::parseIdentifier(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)
 996 {
 997     tokenData-&gt;escaped = false;
 998     const ptrdiff_t remaining = m_codeEnd - m_code;
 999     if ((remaining &gt;= maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) {
1000         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
1001         if (keyword != IDENT) {
1002             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
1003             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
1004         }
1005     }
1006 
1007     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
1008     if (isPrivateName)
1009         shift();
1010 
1011     const UChar* identifierStart = currentSourcePtr();
1012     int identifierLineStart = currentLineStartOffset();
1013 
1014     UChar orAllChars = 0;
1015 
1016     while (isIdentPart(m_current)) {
1017         orAllChars |= m_current;
1018         shift();
1019     }
1020 
1021     if (UNLIKELY(m_current == &#39;\\&#39;)) {
1022         ASSERT(!isPrivateName);
1023         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
1024         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
1025     }
1026 
1027     bool isAll8Bit = false;
1028 
1029     if (!(orAllChars &amp; ~0xff))
1030         isAll8Bit = true;
1031 
1032     const Identifier* ident = nullptr;
1033 
1034     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
1035         int identifierLength = currentSourcePtr() - identifierStart;
1036         if (isAll8Bit)
1037             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1038         else
1039             ident = makeIdentifier(identifierStart, identifierLength);
1040         if (m_parsingBuiltinFunction) {
<a name="18" id="anc18"></a><span class="line-modified">1041             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
1042                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1043                 return ERRORTOK;
1044             }
1045             if (isPrivateName)
<a name="19" id="anc19"></a><span class="line-modified">1046                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">1047             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">1048                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
1049             if (!ident)
1050                 return INVALID_PRIVATE_NAME_ERRORTOK;
1051         }
1052         tokenData-&gt;ident = ident;
1053     } else
1054         tokenData-&gt;ident = nullptr;
1055 
1056     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
1057         ASSERT(shouldCreateIdentifier);
1058         if (remaining &lt; maxTokenLength) {
1059             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1060             ASSERT((remaining &lt; maxTokenLength) || !entry);
1061             if (!entry)
1062                 return IDENT;
1063             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1064             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1065         }
1066         return IDENT;
1067     }
1068 
1069     return IDENT;
1070 }
1071 
1072 template&lt;typename CharacterType&gt; template&lt;bool shouldCreateIdentifier&gt; JSTokenType Lexer&lt;CharacterType&gt;::parseIdentifierSlowCase(JSTokenData* tokenData, unsigned lexerFlags, bool strictMode)
1073 {
1074     tokenData-&gt;escaped = true;
1075     auto identifierStart = currentSourcePtr();
1076     bool bufferRequired = false;
1077 
1078     while (true) {
1079         if (LIKELY(isIdentPart(m_current))) {
1080             shift();
1081             continue;
1082         }
1083         if (LIKELY(m_current != &#39;\\&#39;))
1084             break;
1085 
1086         // \uXXXX unicode characters.
1087         bufferRequired = true;
1088         if (identifierStart != currentSourcePtr())
1089             m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1090         shift();
1091         if (UNLIKELY(m_current != &#39;u&#39;))
1092             return atEnd() ? UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_ESCAPE_ERRORTOK;
1093         shift();
1094         auto character = parseUnicodeEscape();
1095         if (UNLIKELY(!character.isValid()))
1096             return character.isIncomplete() ? UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK;
1097         if (UNLIKELY(m_buffer16.size() ? !isIdentPart(character.value()) : !isIdentStart(character.value())))
1098             return INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK;
1099         if (shouldCreateIdentifier)
1100             recordUnicodeCodePoint(character.value());
1101         identifierStart = currentSourcePtr();
1102     }
1103 
1104     int identifierLength;
1105     const Identifier* ident = nullptr;
1106     if (shouldCreateIdentifier) {
1107         if (!bufferRequired) {
1108             identifierLength = currentSourcePtr() - identifierStart;
1109             ident = makeIdentifier(identifierStart, identifierLength);
1110         } else {
1111             if (identifierStart != currentSourcePtr())
1112                 m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1113             ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1114         }
1115 
1116         tokenData-&gt;ident = ident;
1117     } else
1118         tokenData-&gt;ident = nullptr;
1119 
1120     m_buffer16.shrink(0);
1121 
1122     if (LIKELY(!(lexerFlags &amp; LexerFlagsIgnoreReservedWords))) {
1123         ASSERT(shouldCreateIdentifier);
1124         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1125         if (!entry)
1126             return IDENT;
1127         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1128         if ((token != RESERVED_IF_STRICT) || strictMode)
1129             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1130     }
1131 
1132     return IDENT;
1133 }
1134 
1135 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1136 {
1137     return character &lt; 0xE;
1138 }
1139 
1140 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1141 {
<a name="20" id="anc20"></a><span class="line-modified">1142     return character &lt; 0xE || !isLatin1(character);</span>
1143 }
1144 
1145 template &lt;typename T&gt;
1146 template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
1147 {
1148     int startingOffset = currentOffset();
1149     int startingLineStartOffset = currentLineStartOffset();
1150     int startingLineNumber = lineNumber();
1151     T stringQuoteCharacter = m_current;
1152     shift();
1153 
1154     const T* stringStart = currentSourcePtr();
1155 
1156     while (m_current != stringQuoteCharacter) {
1157         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1158             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1159                 append8(stringStart, currentSourcePtr() - stringStart);
1160             shift();
1161 
1162             LChar escape = singleEscape(m_current);
1163 
1164             // Most common escape sequences first.
1165             if (escape) {
1166                 if (shouldBuildStrings)
1167                     record8(escape);
1168                 shift();
1169             } else if (UNLIKELY(isLineTerminator(m_current)))
1170                 shiftLineTerminator();
1171             else if (m_current == &#39;x&#39;) {
1172                 shift();
1173                 if (!isASCIIHexDigit(m_current) || !isASCIIHexDigit(peek(1))) {
1174                     m_lexErrorMessage = &quot;\\x can only be followed by a hex character sequence&quot;_s;
1175                     return (atEnd() || (isASCIIHexDigit(m_current) &amp;&amp; (m_code + 1 == m_codeEnd))) ? StringUnterminated : StringCannotBeParsed;
1176                 }
1177                 T prev = m_current;
1178                 shift();
1179                 if (shouldBuildStrings)
1180                     record8(convertHex(prev, m_current));
1181                 shift();
1182             } else {
1183                 setOffset(startingOffset, startingLineStartOffset);
1184                 setLineNumber(startingLineNumber);
1185                 m_buffer8.shrink(0);
1186                 return parseStringSlowCase&lt;shouldBuildStrings&gt;(tokenData, strictMode);
1187             }
1188             stringStart = currentSourcePtr();
1189             continue;
1190         }
1191 
1192         if (UNLIKELY(characterRequiresParseStringSlowCase(m_current))) {
1193             setOffset(startingOffset, startingLineStartOffset);
1194             setLineNumber(startingLineNumber);
1195             m_buffer8.shrink(0);
1196             return parseStringSlowCase&lt;shouldBuildStrings&gt;(tokenData, strictMode);
1197         }
1198 
1199         shift();
1200     }
1201 
1202     if (currentSourcePtr() != stringStart &amp;&amp; shouldBuildStrings)
1203         append8(stringStart, currentSourcePtr() - stringStart);
1204     if (shouldBuildStrings) {
1205         tokenData-&gt;ident = makeIdentifier(m_buffer8.data(), m_buffer8.size());
1206         m_buffer8.shrink(0);
1207     } else
1208         tokenData-&gt;ident = 0;
1209 
1210     return StringParsedSuccessfully;
1211 }
1212 
1213 template &lt;typename T&gt;
1214 template &lt;bool shouldBuildStrings, LexerEscapeParseMode escapeParseMode&gt; ALWAYS_INLINE auto Lexer&lt;T&gt;::parseComplexEscape(bool strictMode, T stringQuoteCharacter) -&gt; StringParseResult
1215 {
1216     if (m_current == &#39;x&#39;) {
1217         shift();
1218         if (!isASCIIHexDigit(m_current) || !isASCIIHexDigit(peek(1))) {
1219             // For raw template literal syntax, we consume `NotEscapeSequence`.
1220             //
1221             // NotEscapeSequence ::
1222             //     x [lookahread not one of HexDigit]
1223             //     x HexDigit [lookahread not one of HexDigit]
1224             if (isASCIIHexDigit(m_current))
1225                 shift();
1226             ASSERT(!isASCIIHexDigit(m_current));
1227 
1228             m_lexErrorMessage = &quot;\\x can only be followed by a hex character sequence&quot;_s;
1229             return atEnd() ? StringUnterminated : StringCannotBeParsed;
1230         }
1231 
1232         T prev = m_current;
1233         shift();
1234         if (shouldBuildStrings)
1235             record16(convertHex(prev, m_current));
1236         shift();
1237 
1238         return StringParsedSuccessfully;
1239     }
1240 
1241     if (m_current == &#39;u&#39;) {
1242         shift();
1243 
1244         if (escapeParseMode == LexerEscapeParseMode::String &amp;&amp; m_current == stringQuoteCharacter) {
1245             if (shouldBuildStrings)
1246                 record16(&#39;u&#39;);
1247             return StringParsedSuccessfully;
1248         }
1249 
1250         auto character = parseUnicodeEscape();
1251         if (character.isValid()) {
1252             if (shouldBuildStrings)
1253                 recordUnicodeCodePoint(character.value());
1254             return StringParsedSuccessfully;
1255         }
1256 
1257         m_lexErrorMessage = &quot;\\u can only be followed by a Unicode character sequence&quot;_s;
1258         return atEnd() ? StringUnterminated : StringCannotBeParsed;
1259     }
1260 
1261     if (strictMode) {
1262         if (isASCIIDigit(m_current)) {
1263             // The only valid numeric escape in strict mode is &#39;\0&#39;, and this must not be followed by a decimal digit.
1264             int character1 = m_current;
1265             shift();
1266             if (character1 != &#39;0&#39; || isASCIIDigit(m_current)) {
1267                 // For raw template literal syntax, we consume `NotEscapeSequence`.
1268                 //
1269                 // NotEscapeSequence ::
1270                 //     0 DecimalDigit
1271                 //     DecimalDigit but not 0
1272                 if (character1 == &#39;0&#39;)
1273                     shift();
1274 
1275                 m_lexErrorMessage = &quot;The only valid numeric escape in strict mode is &#39;\\0&#39;&quot;_s;
1276                 return atEnd() ? StringUnterminated : StringCannotBeParsed;
1277             }
1278             if (shouldBuildStrings)
1279                 record16(0);
1280             return StringParsedSuccessfully;
1281         }
1282     } else {
1283         if (isASCIIOctalDigit(m_current)) {
1284             // Octal character sequences
1285             T character1 = m_current;
1286             shift();
1287             if (isASCIIOctalDigit(m_current)) {
1288                 // Two octal characters
1289                 T character2 = m_current;
1290                 shift();
1291                 if (character1 &gt;= &#39;0&#39; &amp;&amp; character1 &lt;= &#39;3&#39; &amp;&amp; isASCIIOctalDigit(m_current)) {
1292                     if (shouldBuildStrings)
1293                         record16((character1 - &#39;0&#39;) * 64 + (character2 - &#39;0&#39;) * 8 + m_current - &#39;0&#39;);
1294                     shift();
1295                 } else {
1296                     if (shouldBuildStrings)
1297                         record16((character1 - &#39;0&#39;) * 8 + character2 - &#39;0&#39;);
1298                 }
1299             } else {
1300                 if (shouldBuildStrings)
1301                     record16(character1 - &#39;0&#39;);
1302             }
1303             return StringParsedSuccessfully;
1304         }
1305     }
1306 
1307     if (!atEnd()) {
1308         if (shouldBuildStrings)
1309             record16(m_current);
1310         shift();
1311         return StringParsedSuccessfully;
1312     }
1313 
1314     m_lexErrorMessage = &quot;Unterminated string constant&quot;_s;
1315     return StringUnterminated;
1316 }
1317 
1318 template &lt;typename T&gt;
1319 template &lt;bool shouldBuildStrings&gt; auto Lexer&lt;T&gt;::parseStringSlowCase(JSTokenData* tokenData, bool strictMode) -&gt; StringParseResult
1320 {
1321     T stringQuoteCharacter = m_current;
1322     shift();
1323 
1324     const T* stringStart = currentSourcePtr();
1325 
1326     while (m_current != stringQuoteCharacter) {
1327         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1328             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1329                 append16(stringStart, currentSourcePtr() - stringStart);
1330             shift();
1331 
1332             LChar escape = singleEscape(m_current);
1333 
1334             // Most common escape sequences first
1335             if (escape) {
1336                 if (shouldBuildStrings)
1337                     record16(escape);
1338                 shift();
1339             } else if (UNLIKELY(isLineTerminator(m_current)))
1340                 shiftLineTerminator();
1341             else {
1342                 StringParseResult result = parseComplexEscape&lt;shouldBuildStrings, LexerEscapeParseMode::String&gt;(strictMode, stringQuoteCharacter);
1343                 if (result != StringParsedSuccessfully)
1344                     return result;
1345             }
1346 
1347             stringStart = currentSourcePtr();
1348             continue;
1349         }
1350         // Fast check for characters that require special handling.
1351         // Catches 0, \n, and \r as efficiently as possible, and lets through all common ASCII characters.
1352         static_assert(std::is_unsigned&lt;T&gt;::value, &quot;Lexer expects an unsigned character type&quot;);
1353         if (UNLIKELY(m_current &lt; 0xE)) {
1354             // New-line or end of input is not allowed
1355             if (atEnd() || m_current == &#39;\r&#39; || m_current == &#39;\n&#39;) {
1356                 m_lexErrorMessage = &quot;Unexpected EOF&quot;_s;
1357                 return atEnd() ? StringUnterminated : StringCannotBeParsed;
1358             }
1359             // Anything else is just a normal character
1360         }
1361         shift();
1362     }
1363 
1364     if (currentSourcePtr() != stringStart &amp;&amp; shouldBuildStrings)
1365         append16(stringStart, currentSourcePtr() - stringStart);
1366     if (shouldBuildStrings)
1367         tokenData-&gt;ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1368     else
1369         tokenData-&gt;ident = 0;
1370 
1371     m_buffer16.shrink(0);
1372     return StringParsedSuccessfully;
1373 }
1374 
1375 template &lt;typename T&gt;
1376 typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseTemplateLiteral(JSTokenData* tokenData, RawStringsBuildMode rawStringsBuildMode)
1377 {
1378     bool parseCookedFailed = false;
1379     const T* stringStart = currentSourcePtr();
1380     const T* rawStringStart = currentSourcePtr();
1381 
1382     while (m_current != &#39;`&#39;) {
1383         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1384             if (stringStart != currentSourcePtr())
1385                 append16(stringStart, currentSourcePtr() - stringStart);
1386             shift();
1387 
1388             LChar escape = singleEscape(m_current);
1389 
1390             // Most common escape sequences first.
1391             if (escape) {
1392                 record16(escape);
1393                 shift();
1394             } else if (UNLIKELY(isLineTerminator(m_current))) {
1395                 // Normalize &lt;CR&gt;, &lt;CR&gt;&lt;LF&gt; to &lt;LF&gt;.
1396                 if (m_current == &#39;\r&#39;) {
1397                     ASSERT_WITH_MESSAGE(rawStringStart != currentSourcePtr(), &quot;We should have at least shifted the escape.&quot;);
1398 
1399                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings) {
1400                         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1401                         m_bufferForRawTemplateString16.append(&#39;\n&#39;);
1402                     }
1403 
1404                     shiftLineTerminator();
1405                     rawStringStart = currentSourcePtr();
1406                 } else
1407                     shiftLineTerminator();
1408             } else {
1409                 bool strictMode = true;
1410                 StringParseResult result = parseComplexEscape&lt;true, LexerEscapeParseMode::Template&gt;(strictMode, &#39;`&#39;);
1411                 if (result != StringParsedSuccessfully) {
1412                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings &amp;&amp; result == StringCannotBeParsed)
1413                         parseCookedFailed = true;
1414                     else
1415                         return result;
1416                 }
1417             }
1418 
1419             stringStart = currentSourcePtr();
1420             continue;
1421         }
1422 
1423         if (m_current == &#39;$&#39; &amp;&amp; peek(1) == &#39;{&#39;)
1424             break;
1425 
1426         // Fast check for characters that require special handling.
1427         // Catches 0, \n, \r, 0x2028, and 0x2029 as efficiently
1428         // as possible, and lets through all common ASCII characters.
1429         if (UNLIKELY(((static_cast&lt;unsigned&gt;(m_current) - 0xE) &amp; 0x2000))) {
1430             // End of input is not allowed.
1431             // Unlike String, line terminator is allowed.
1432             if (atEnd()) {
1433                 m_lexErrorMessage = &quot;Unexpected EOF&quot;_s;
1434                 return StringUnterminated;
1435             }
1436 
1437             if (isLineTerminator(m_current)) {
1438                 if (m_current == &#39;\r&#39;) {
1439                     // Normalize &lt;CR&gt;, &lt;CR&gt;&lt;LF&gt; to &lt;LF&gt;.
1440                     if (stringStart != currentSourcePtr())
1441                         append16(stringStart, currentSourcePtr() - stringStart);
1442                     if (rawStringStart != currentSourcePtr() &amp;&amp; rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1443                         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1444 
1445                     record16(&#39;\n&#39;);
1446                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1447                         m_bufferForRawTemplateString16.append(&#39;\n&#39;);
1448                     shiftLineTerminator();
1449                     stringStart = currentSourcePtr();
1450                     rawStringStart = currentSourcePtr();
1451                 } else
1452                     shiftLineTerminator();
1453                 continue;
1454             }
1455             // Anything else is just a normal character
1456         }
1457 
1458         shift();
1459     }
1460 
1461     bool isTail = m_current == &#39;`&#39;;
1462 
1463     if (currentSourcePtr() != stringStart)
1464         append16(stringStart, currentSourcePtr() - stringStart);
1465     if (rawStringStart != currentSourcePtr() &amp;&amp; rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1466         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1467 
1468     if (!parseCookedFailed)
1469         tokenData-&gt;cooked = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1470     else
1471         tokenData-&gt;cooked = nullptr;
1472 
1473     // Line terminator normalization (e.g. &lt;CR&gt; =&gt; &lt;LF&gt;) should be applied to both the raw and cooked representations.
1474     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1475         tokenData-&gt;raw = makeIdentifier(m_bufferForRawTemplateString16.data(), m_bufferForRawTemplateString16.size());
1476     else
1477         tokenData-&gt;raw = nullptr;
1478 
1479     tokenData-&gt;isTail = isTail;
1480 
1481     m_buffer16.shrink(0);
1482     m_bufferForRawTemplateString16.shrink(0);
1483 
1484     if (isTail) {
1485         // Skip `
1486         shift();
1487     } else {
1488         // Skip $ and {
1489         shift();
1490         shift();
1491     }
1492 
1493     return StringParsedSuccessfully;
1494 }
1495 
1496 template &lt;typename T&gt;
<a name="21" id="anc21"></a><span class="line-modified">1497 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; Optional&lt;NumberParseResult&gt;</span>
1498 {
<a name="22" id="anc22"></a><span class="line-added">1499     ASSERT(isASCIIHexDigit(m_current));</span>
<span class="line-added">1500 </span>
1501     // Optimization: most hexadecimal values fit into 4 bytes.
1502     uint32_t hexValue = 0;
1503     int maximumDigits = 7;
1504 
1505     do {
<a name="23" id="anc23"></a><span class="line-added">1506         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1507             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">1508                 return WTF::nullopt;</span>
<span class="line-added">1509 </span>
<span class="line-added">1510             shift();</span>
<span class="line-added">1511         }</span>
<span class="line-added">1512 </span>
1513         hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
1514         shift();
1515         --maximumDigits;
<a name="24" id="anc24"></a><span class="line-modified">1516     } while (isASCIIHexDigitOrSeparator(m_current) &amp;&amp; maximumDigits &gt;= 0);</span>
1517 
1518     if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
<a name="25" id="anc25"></a><span class="line-modified">1519         return NumberParseResult { hexValue };</span>
1520 
1521     // No more place in the hexValue buffer.
1522     // The values are shifted out and placed into the m_buffer8 vector.
1523     for (int i = 0; i &lt; 8; ++i) {
1524          int digit = hexValue &gt;&gt; 28;
1525          if (digit &lt; 10)
1526              record8(digit + &#39;0&#39;);
1527          else
1528              record8(digit - 10 + &#39;a&#39;);
1529          hexValue &lt;&lt;= 4;
1530     }
1531 
<a name="26" id="anc26"></a><span class="line-modified">1532     while (isASCIIHexDigitOrSeparator(m_current)) {</span>
<span class="line-added">1533         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1534             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">1535                 return WTF::nullopt;</span>
<span class="line-added">1536 </span>
<span class="line-added">1537             shift();</span>
<span class="line-added">1538         }</span>
<span class="line-added">1539 </span>
1540         record8(m_current);
1541         shift();
1542     }
1543 
1544     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<a name="27" id="anc27"></a><span class="line-modified">1545         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1546 
<a name="28" id="anc28"></a><span class="line-modified">1547     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16) };</span>
1548 }
1549 
1550 template &lt;typename T&gt;
1551 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
1552 {
<a name="29" id="anc29"></a><span class="line-added">1553     ASSERT(isASCIIBinaryDigit(m_current));</span>
<span class="line-added">1554 </span>
1555     // Optimization: most binary values fit into 4 bytes.
1556     uint32_t binaryValue = 0;
1557     const unsigned maximumDigits = 32;
1558     int digit = maximumDigits - 1;
1559     // Temporary buffer for the digits. Makes easier
1560     // to reconstruct the input characters when needed.
1561     LChar digits[maximumDigits];
1562 
1563     do {
<a name="30" id="anc30"></a><span class="line-added">1564         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1565             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">1566                 return WTF::nullopt;</span>
<span class="line-added">1567 </span>
<span class="line-added">1568             shift();</span>
<span class="line-added">1569         }</span>
<span class="line-added">1570 </span>
1571         binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
1572         digits[digit] = m_current;
1573         shift();
1574         --digit;
<a name="31" id="anc31"></a><span class="line-modified">1575     } while (isASCIIBinaryDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
1576 
<a name="32" id="anc32"></a><span class="line-modified">1577     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-modified">1578         return NumberParseResult { binaryValue };</span>
1579 
1580     for (int i = maximumDigits - 1; i &gt; digit; --i)
1581         record8(digits[i]);
1582 
<a name="33" id="anc33"></a><span class="line-modified">1583     while (isASCIIBinaryDigitOrSeparator(m_current)) {</span>
<span class="line-added">1584         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1585             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">1586                 return WTF::nullopt;</span>
<span class="line-added">1587 </span>
<span class="line-added">1588             shift();</span>
<span class="line-added">1589         }</span>
<span class="line-added">1590 </span>
1591         record8(m_current);
1592         shift();
1593     }
1594 
1595     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<a name="34" id="anc34"></a><span class="line-modified">1596         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1597 
1598     if (isASCIIDigit(m_current))
1599         return WTF::nullopt;
1600 
<a name="35" id="anc35"></a><span class="line-modified">1601     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };</span>
1602 }
1603 
1604 template &lt;typename T&gt;
1605 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
1606 {
<a name="36" id="anc36"></a><span class="line-added">1607     ASSERT(isASCIIOctalDigit(m_current));</span>
<span class="line-added">1608     ASSERT(!m_buffer8.size() || (m_buffer8.size() == 1 &amp;&amp; m_buffer8[0] == &#39;0&#39;));</span>
<span class="line-added">1609     bool isLegacyLiteral = m_buffer8.size();</span>
<span class="line-added">1610 </span>
1611     // Optimization: most octal values fit into 4 bytes.
1612     uint32_t octalValue = 0;
1613     const unsigned maximumDigits = 10;
1614     int digit = maximumDigits - 1;
1615     // Temporary buffer for the digits. Makes easier
1616     // to reconstruct the input characters when needed.
1617     LChar digits[maximumDigits];
1618 
1619     do {
<a name="37" id="anc37"></a><span class="line-added">1620         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1621             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1622                 return WTF::nullopt;</span>
<span class="line-added">1623 </span>
<span class="line-added">1624             shift();</span>
<span class="line-added">1625         }</span>
<span class="line-added">1626 </span>
1627         octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
1628         digits[digit] = m_current;
1629         shift();
1630         --digit;
<a name="38" id="anc38"></a><span class="line-modified">1631     } while (isASCIIOctalDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>



1632 
<a name="39" id="anc39"></a><span class="line-added">1633     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-added">1634         return NumberParseResult { octalValue };</span>
1635 
1636     for (int i = maximumDigits - 1; i &gt; digit; --i)
1637          record8(digits[i]);
1638 
<a name="40" id="anc40"></a><span class="line-modified">1639     while (isASCIIOctalDigitOrSeparator(m_current)) {</span>
<span class="line-added">1640         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1641             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1642                 return WTF::nullopt;</span>
<span class="line-added">1643 </span>
<span class="line-added">1644             shift();</span>
<span class="line-added">1645         }</span>
<span class="line-added">1646 </span>
1647         record8(m_current);
1648         shift();
1649     }
1650 
<a name="41" id="anc41"></a><span class="line-modified">1651     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;) &amp;&amp; !isLegacyLiteral)</span>
<span class="line-modified">1652         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1653 
1654     if (isASCIIDigit(m_current))
1655         return WTF::nullopt;
1656 
<a name="42" id="anc42"></a><span class="line-modified">1657     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };</span>
1658 }
1659 
1660 template &lt;typename T&gt;
1661 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
1662 {
<a name="43" id="anc43"></a><span class="line-added">1663     ASSERT(isASCIIDigit(m_current) || m_buffer8.size());</span>
<span class="line-added">1664     bool isLegacyLiteral = m_buffer8.size() &amp;&amp; isASCIIDigitOrSeparator(m_current);</span>
<span class="line-added">1665 </span>
1666     // Optimization: most decimal values fit into 4 bytes.
1667     uint32_t decimalValue = 0;
1668 
1669     // Since parseOctal may be executed before parseDecimal,
1670     // the m_buffer8 may hold ascii digits.
1671     if (!m_buffer8.size()) {
1672         const unsigned maximumDigits = 10;
1673         int digit = maximumDigits - 1;
1674         // Temporary buffer for the digits. Makes easier
1675         // to reconstruct the input characters when needed.
1676         LChar digits[maximumDigits];
1677 
1678         do {
<a name="44" id="anc44"></a><span class="line-added">1679             if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1680                 if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1681                     return WTF::nullopt;</span>
<span class="line-added">1682 </span>
<span class="line-added">1683                 shift();</span>
<span class="line-added">1684             }</span>
<span class="line-added">1685 </span>
1686             decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
1687             digits[digit] = m_current;
1688             shift();
1689             --digit;
<a name="45" id="anc45"></a><span class="line-modified">1690         } while (isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
1691 
1692         if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
<a name="46" id="anc46"></a><span class="line-modified">1693             return NumberParseResult { decimalValue };</span>
1694 
1695         for (int i = maximumDigits - 1; i &gt; digit; --i)
1696             record8(digits[i]);
1697     }
1698 
<a name="47" id="anc47"></a><span class="line-modified">1699     while (isASCIIDigitOrSeparator(m_current)) {</span>
<span class="line-added">1700         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1701             if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1702                 return WTF::nullopt;</span>
<span class="line-added">1703 </span>
<span class="line-added">1704             shift();</span>
<span class="line-added">1705         }</span>
<span class="line-added">1706 </span>
1707         record8(m_current);
1708         shift();
1709     }
1710 
<a name="48" id="anc48"></a><span class="line-modified">1711     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39; &amp;&amp; !isLegacyLiteral))</span>
<span class="line-modified">1712         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1713 
1714     return WTF::nullopt;
1715 }
1716 
1717 template &lt;typename T&gt;
<a name="49" id="anc49"></a><span class="line-modified">1718 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()</span>
1719 {
<a name="50" id="anc50"></a><span class="line-added">1720     ASSERT(isASCIIDigit(m_current));</span>
1721     record8(&#39;.&#39;);
<a name="51" id="anc51"></a><span class="line-modified">1722 </span>
<span class="line-added">1723     do {</span>
<span class="line-added">1724         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1725             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">1726                 return false;</span>
<span class="line-added">1727 </span>
<span class="line-added">1728             shift();</span>
<span class="line-added">1729         }</span>
<span class="line-added">1730 </span>
1731         record8(m_current);
1732         shift();
<a name="52" id="anc52"></a><span class="line-modified">1733     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">1734 </span>
<span class="line-added">1735     return true;</span>
1736 }
1737 
1738 template &lt;typename T&gt;
1739 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
1740 {
1741     record8(&#39;e&#39;);
1742     shift();
1743     if (m_current == &#39;+&#39; || m_current == &#39;-&#39;) {
1744         record8(m_current);
1745         shift();
1746     }
1747 
1748     if (!isASCIIDigit(m_current))
1749         return false;
1750 
1751     do {
<a name="53" id="anc53"></a><span class="line-added">1752         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1753             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">1754                 return false;</span>
<span class="line-added">1755 </span>
<span class="line-added">1756             shift();</span>
<span class="line-added">1757         }</span>
<span class="line-added">1758 </span>
1759         record8(m_current);
1760         shift();
<a name="54" id="anc54"></a><span class="line-modified">1761     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">1762 </span>
1763     return true;
1764 }
1765 
1766 template &lt;typename T&gt;
1767 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
1768 {
1769     while (true) {
1770         while (UNLIKELY(m_current == &#39;*&#39;)) {
1771             shift();
1772             if (m_current == &#39;/&#39;) {
1773                 shift();
1774                 return true;
1775             }
1776         }
1777 
1778         if (atEnd())
1779             return false;
1780 
1781         if (isLineTerminator(m_current)) {
1782             shiftLineTerminator();
1783             m_hasLineTerminatorBeforeToken = true;
1784         } else
1785             shift();
1786     }
1787 }
1788 
1789 template &lt;typename T&gt;
1790 ALWAYS_INLINE void Lexer&lt;T&gt;::parseCommentDirective()
1791 {
1792     // sourceURL and sourceMappingURL directives.
1793     if (!consume(&quot;source&quot;))
1794         return;
1795 
1796     if (consume(&quot;URL=&quot;)) {
1797         m_sourceURLDirective = parseCommentDirectiveValue();
1798         return;
1799     }
1800 
1801     if (consume(&quot;MappingURL=&quot;)) {
1802         m_sourceMappingURLDirective = parseCommentDirectiveValue();
1803         return;
1804     }
1805 }
1806 
1807 template &lt;typename T&gt;
1808 ALWAYS_INLINE String Lexer&lt;T&gt;::parseCommentDirectiveValue()
1809 {
1810     skipWhitespace();
1811     const T* stringStart = currentSourcePtr();
1812     while (!isWhiteSpace(m_current) &amp;&amp; !isLineTerminator(m_current) &amp;&amp; m_current != &#39;&quot;&#39; &amp;&amp; m_current != &#39;\&#39;&#39; &amp;&amp; !atEnd())
1813         shift();
1814     const T* stringEnd = currentSourcePtr();
1815     skipWhitespace();
1816 
1817     if (!isLineTerminator(m_current) &amp;&amp; !atEnd())
1818         return String();
1819 
1820     append8(stringStart, stringEnd - stringStart);
1821     String result = String(m_buffer8.data(), m_buffer8.size());
1822     m_buffer8.shrink(0);
1823     return result;
1824 }
1825 
1826 template &lt;typename T&gt;
1827 template &lt;unsigned length&gt;
1828 ALWAYS_INLINE bool Lexer&lt;T&gt;::consume(const char (&amp;input)[length])
1829 {
1830     unsigned lengthToCheck = length - 1; // Ignore the ending NULL byte in the string literal.
1831 
1832     unsigned i = 0;
1833     for (; i &lt; lengthToCheck &amp;&amp; m_current == input[i]; i++)
1834         shift();
1835 
1836     return i == lengthToCheck;
1837 }
1838 
1839 template &lt;typename T&gt;
1840 bool Lexer&lt;T&gt;::nextTokenIsColon()
1841 {
1842     const T* code = m_code;
1843     while (code &lt; m_codeEnd &amp;&amp; (isWhiteSpace(*code) || isLineTerminator(*code)))
1844         code++;
1845 
1846     return code &lt; m_codeEnd &amp;&amp; *code == &#39;:&#39;;
1847 }
1848 
1849 template &lt;typename T&gt;
1850 void Lexer&lt;T&gt;::fillTokenInfo(JSToken* tokenRecord, JSTokenType token, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition)
1851 {
1852     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1853     tokenLocation-&gt;line = lineNumber;
1854     tokenLocation-&gt;endOffset = endOffset;
1855     tokenLocation-&gt;lineStartOffset = lineStartOffset;
1856     ASSERT(tokenLocation-&gt;endOffset &gt;= tokenLocation-&gt;lineStartOffset);
1857     tokenRecord-&gt;m_endPosition = endPosition;
1858     m_lastToken = token;
1859 }
1860 
1861 template &lt;typename T&gt;
1862 JSTokenType Lexer&lt;T&gt;::lexWithoutClearingLineTerminator(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)
1863 {
1864     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
1865     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1866     m_lastTokenLocation = JSTokenLocation(tokenRecord-&gt;m_location);
1867 
1868     ASSERT(!m_error);
1869     ASSERT(m_buffer8.isEmpty());
1870     ASSERT(m_buffer16.isEmpty());
1871 
1872     JSTokenType token = ERRORTOK;
1873 
1874 start:
1875     skipWhitespace();
1876 
1877     tokenLocation-&gt;startOffset = currentOffset();
1878     ASSERT(currentOffset() &gt;= currentLineStartOffset());
1879     tokenRecord-&gt;m_startPosition = currentPosition();
1880 
1881     if (atEnd()) {
1882         token = EOFTOK;
1883         goto returnToken;
1884     }
1885 
1886     CharacterType type;
1887     if (LIKELY(isLatin1(m_current)))
1888         type = static_cast&lt;CharacterType&gt;(typesOfLatin1Characters[m_current]);
1889     else if (isNonLatin1IdentStart(m_current))
1890         type = CharacterIdentifierStart;
1891     else if (isLineTerminator(m_current))
1892         type = CharacterLineTerminator;
1893     else
1894         type = CharacterInvalid;
1895 
1896     switch (type) {
1897     case CharacterGreater:
1898         shift();
1899         if (m_current == &#39;&gt;&#39;) {
1900             shift();
1901             if (m_current == &#39;&gt;&#39;) {
1902                 shift();
1903                 if (m_current == &#39;=&#39;) {
1904                     shift();
1905                     token = URSHIFTEQUAL;
1906                     break;
1907                 }
1908                 token = URSHIFT;
1909                 break;
1910             }
1911             if (m_current == &#39;=&#39;) {
1912                 shift();
1913                 token = RSHIFTEQUAL;
1914                 break;
1915             }
1916             token = RSHIFT;
1917             break;
1918         }
1919         if (m_current == &#39;=&#39;) {
1920             shift();
1921             token = GE;
1922             break;
1923         }
1924         token = GT;
1925         break;
1926     case CharacterEqual: {
1927         if (peek(1) == &#39;&gt;&#39;) {
1928             token = ARROWFUNCTION;
1929             tokenData-&gt;line = lineNumber();
1930             tokenData-&gt;offset = currentOffset();
1931             tokenData-&gt;lineStartOffset = currentLineStartOffset();
1932             ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
1933             shift();
1934             shift();
1935             break;
1936         }
1937 
1938         shift();
1939         if (m_current == &#39;=&#39;) {
1940             shift();
1941             if (m_current == &#39;=&#39;) {
1942                 shift();
1943                 token = STREQ;
1944                 break;
1945             }
1946             token = EQEQ;
1947             break;
1948         }
1949         token = EQUAL;
1950         break;
1951     }
1952     case CharacterLess:
1953         shift();
1954         if (m_current == &#39;!&#39; &amp;&amp; peek(1) == &#39;-&#39; &amp;&amp; peek(2) == &#39;-&#39;) {
1955             if (m_scriptMode == JSParserScriptMode::Classic) {
1956                 // &lt;!-- marks the beginning of a line comment (for www usage)
1957                 goto inSingleLineComment;
1958             }
1959         }
1960         if (m_current == &#39;&lt;&#39;) {
1961             shift();
1962             if (m_current == &#39;=&#39;) {
1963                 shift();
1964                 token = LSHIFTEQUAL;
1965                 break;
1966             }
1967             token = LSHIFT;
1968             break;
1969         }
1970         if (m_current == &#39;=&#39;) {
1971             shift();
1972             token = LE;
1973             break;
1974         }
1975         token = LT;
1976         break;
1977     case CharacterExclamationMark:
1978         shift();
1979         if (m_current == &#39;=&#39;) {
1980             shift();
1981             if (m_current == &#39;=&#39;) {
1982                 shift();
1983                 token = STRNEQ;
1984                 break;
1985             }
1986             token = NE;
1987             break;
1988         }
1989         token = EXCLAMATION;
1990         break;
1991     case CharacterAdd:
1992         shift();
1993         if (m_current == &#39;+&#39;) {
1994             shift();
1995             token = (!m_hasLineTerminatorBeforeToken) ? PLUSPLUS : AUTOPLUSPLUS;
1996             break;
1997         }
1998         if (m_current == &#39;=&#39;) {
1999             shift();
2000             token = PLUSEQUAL;
2001             break;
2002         }
2003         token = PLUS;
2004         break;
2005     case CharacterSub:
2006         shift();
2007         if (m_current == &#39;-&#39;) {
2008             shift();
2009             if ((m_atLineStart || m_hasLineTerminatorBeforeToken) &amp;&amp; m_current == &#39;&gt;&#39;) {
2010                 if (m_scriptMode == JSParserScriptMode::Classic) {
2011                     shift();
2012                     goto inSingleLineComment;
2013                 }
2014             }
2015             token = (!m_hasLineTerminatorBeforeToken) ? MINUSMINUS : AUTOMINUSMINUS;
2016             break;
2017         }
2018         if (m_current == &#39;=&#39;) {
2019             shift();
2020             token = MINUSEQUAL;
2021             break;
2022         }
2023         token = MINUS;
2024         break;
2025     case CharacterMultiply:
2026         shift();
2027         if (m_current == &#39;=&#39;) {
2028             shift();
2029             token = MULTEQUAL;
2030             break;
2031         }
2032         if (m_current == &#39;*&#39;) {
2033             shift();
2034             if (m_current == &#39;=&#39;) {
2035                 shift();
2036                 token = POWEQUAL;
2037                 break;
2038             }
2039             token = POW;
2040             break;
2041         }
2042         token = TIMES;
2043         break;
2044     case CharacterSlash:
2045         shift();
2046         if (m_current == &#39;/&#39;) {
2047             shift();
2048             goto inSingleLineCommentCheckForDirectives;
2049         }
2050         if (m_current == &#39;*&#39;) {
2051             shift();
2052             if (parseMultilineComment())
2053                 goto start;
2054             m_lexErrorMessage = &quot;Multiline comment was not closed properly&quot;_s;
2055             token = UNTERMINATED_MULTILINE_COMMENT_ERRORTOK;
2056             goto returnError;
2057         }
2058         if (m_current == &#39;=&#39;) {
2059             shift();
2060             token = DIVEQUAL;
2061             break;
2062         }
2063         token = DIVIDE;
2064         break;
2065     case CharacterAnd:
2066         shift();
2067         if (m_current == &#39;&amp;&#39;) {
2068             shift();
2069             token = AND;
2070             break;
2071         }
2072         if (m_current == &#39;=&#39;) {
2073             shift();
2074             token = ANDEQUAL;
2075             break;
2076         }
2077         token = BITAND;
2078         break;
2079     case CharacterXor:
2080         shift();
2081         if (m_current == &#39;=&#39;) {
2082             shift();
2083             token = XOREQUAL;
2084             break;
2085         }
2086         token = BITXOR;
2087         break;
2088     case CharacterModulo:
2089         shift();
2090         if (m_current == &#39;=&#39;) {
2091             shift();
2092             token = MODEQUAL;
2093             break;
2094         }
2095         token = MOD;
2096         break;
2097     case CharacterOr:
2098         shift();
2099         if (m_current == &#39;=&#39;) {
2100             shift();
2101             token = OREQUAL;
2102             break;
2103         }
2104         if (m_current == &#39;|&#39;) {
2105             shift();
2106             token = OR;
2107             break;
2108         }
2109         token = BITOR;
2110         break;
2111     case CharacterOpenParen:
2112         token = OPENPAREN;
2113         tokenData-&gt;line = lineNumber();
2114         tokenData-&gt;offset = currentOffset();
2115         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2116         shift();
2117         break;
2118     case CharacterCloseParen:
2119         token = CLOSEPAREN;
2120         shift();
2121         break;
2122     case CharacterOpenBracket:
2123         token = OPENBRACKET;
2124         shift();
2125         break;
2126     case CharacterCloseBracket:
2127         token = CLOSEBRACKET;
2128         shift();
2129         break;
2130     case CharacterComma:
2131         token = COMMA;
2132         shift();
2133         break;
2134     case CharacterColon:
2135         token = COLON;
2136         shift();
2137         break;
2138     case CharacterQuestion:
<a name="55" id="anc55"></a>
2139         shift();
<a name="56" id="anc56"></a><span class="line-added">2140         if (Options::useNullishAwareOperators()) {</span>
<span class="line-added">2141             if (m_current == &#39;?&#39;) {</span>
<span class="line-added">2142                 shift();</span>
<span class="line-added">2143                 token = COALESCE;</span>
<span class="line-added">2144                 break;</span>
<span class="line-added">2145             }</span>
<span class="line-added">2146             if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-added">2147                 shift();</span>
<span class="line-added">2148                 token = QUESTIONDOT;</span>
<span class="line-added">2149                 break;</span>
<span class="line-added">2150             }</span>
<span class="line-added">2151         }</span>
<span class="line-added">2152         token = QUESTION;</span>
2153         break;
2154     case CharacterTilde:
2155         token = TILDE;
2156         shift();
2157         break;
2158     case CharacterSemicolon:
2159         shift();
2160         token = SEMICOLON;
2161         break;
2162     case CharacterBackQuote:
2163         shift();
2164         token = BACKQUOTE;
2165         break;
2166     case CharacterOpenBrace:
2167         tokenData-&gt;line = lineNumber();
2168         tokenData-&gt;offset = currentOffset();
2169         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2170         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2171         shift();
2172         token = OPENBRACE;
2173         break;
2174     case CharacterCloseBrace:
2175         tokenData-&gt;line = lineNumber();
2176         tokenData-&gt;offset = currentOffset();
2177         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2178         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2179         shift();
2180         token = CLOSEBRACE;
2181         break;
2182     case CharacterDot:
2183         shift();
2184         if (!isASCIIDigit(m_current)) {
2185             if (UNLIKELY((m_current == &#39;.&#39;) &amp;&amp; (peek(1) == &#39;.&#39;))) {
2186                 shift();
2187                 shift();
2188                 token = DOTDOTDOT;
2189                 break;
2190             }
2191             token = DOT;
2192             break;
2193         }
<a name="57" id="anc57"></a><span class="line-modified">2194         if (UNLIKELY(!parseNumberAfterDecimalPoint())) {</span>
<span class="line-added">2195             m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-added">2196             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">2197             goto returnError;</span>
<span class="line-added">2198         }</span>
2199         token = DOUBLE;
<a name="58" id="anc58"></a><span class="line-modified">2200         if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">2201             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-modified">2202             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">2203             goto returnError;</span>


2204         }
2205         size_t parsedLength;
2206         tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2207         if (token == INTEGER)
2208             token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2209 
2210         if (UNLIKELY(isIdentStart(m_current))) {
2211             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2212             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2213             goto returnError;
2214         }
2215         m_buffer8.shrink(0);
2216         break;
2217     case CharacterZero:
2218         shift();
2219         if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
<a name="59" id="anc59"></a><span class="line-modified">2220             if (UNLIKELY(!isASCIIHexDigit(peek(1)))) {</span>
2221                 m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
2222                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2223                 goto returnError;
2224             }
2225 
2226             // Shift out the &#39;x&#39; prefix.
2227             shift();
2228 
2229             auto parseNumberResult = parseHex();
<a name="60" id="anc60"></a><span class="line-modified">2230             if (!parseNumberResult)</span>
<span class="line-modified">2231                 tokenData-&gt;doubleValue = 0;</span>
<span class="line-added">2232             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))</span>
<span class="line-added">2233                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
2234             else {
2235                 token = BIGINT;
2236                 shift();
<a name="61" id="anc61"></a><span class="line-modified">2237                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);</span>
2238                 tokenData-&gt;radix = 16;
2239             }
2240 
<a name="62" id="anc62"></a><span class="line-modified">2241             if (UNLIKELY(isIdentStart(m_current))) {</span>
2242                 m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
2243                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2244                 goto returnError;
2245             }
2246             if (LIKELY(token != BIGINT))
2247                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2248             m_buffer8.shrink(0);
2249             break;
2250         }
2251         if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
<a name="63" id="anc63"></a><span class="line-modified">2252             if (UNLIKELY(!isASCIIBinaryDigit(peek(1)))) {</span>
2253                 m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
2254                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2255                 goto returnError;
2256             }
2257 
2258             // Shift out the &#39;b&#39; prefix.
2259             shift();
2260 
2261             auto parseNumberResult = parseBinary();
2262             if (!parseNumberResult)
2263                 tokenData-&gt;doubleValue = 0;
2264             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2265                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2266             else {
2267                 token = BIGINT;
2268                 shift();
2269                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2270                 tokenData-&gt;radix = 2;
2271             }
2272 
<a name="64" id="anc64"></a><span class="line-modified">2273             if (UNLIKELY(isIdentStart(m_current))) {</span>
2274                 m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
2275                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2276                 goto returnError;
2277             }
2278             if (LIKELY(token != BIGINT))
2279                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2280             m_buffer8.shrink(0);
2281             break;
2282         }
2283 
2284         if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
<a name="65" id="anc65"></a><span class="line-modified">2285             if (UNLIKELY(!isASCIIOctalDigit(peek(1)))) {</span>
2286                 m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
2287                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2288                 goto returnError;
2289             }
2290 
2291             // Shift out the &#39;o&#39; prefix.
2292             shift();
2293 
2294             auto parseNumberResult = parseOctal();
2295             if (!parseNumberResult)
2296                 tokenData-&gt;doubleValue = 0;
2297             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2298                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2299             else {
2300                 token = BIGINT;
2301                 shift();
2302                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2303                 tokenData-&gt;radix = 8;
2304             }
2305 
<a name="66" id="anc66"></a><span class="line-modified">2306             if (UNLIKELY(isIdentStart(m_current))) {</span>
2307                 m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
2308                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2309                 goto returnError;
2310             }
2311             if (LIKELY(token != BIGINT))
2312                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2313             m_buffer8.shrink(0);
2314             break;
2315         }
2316 
<a name="67" id="anc67"></a><span class="line-added">2317         if (UNLIKELY(m_current == &#39;_&#39;)) {</span>
<span class="line-added">2318             m_lexErrorMessage = &quot;Numeric literals may not begin with 0_&quot;_s;</span>
<span class="line-added">2319             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;</span>
<span class="line-added">2320             goto returnError;</span>
<span class="line-added">2321         }</span>
<span class="line-added">2322 </span>
2323         record8(&#39;0&#39;);
<a name="68" id="anc68"></a><span class="line-modified">2324         if (UNLIKELY(strictMode &amp;&amp; isASCIIDigit(m_current))) {</span>
2325             m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
2326             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2327             goto returnError;
2328         }
2329         if (isASCIIOctalDigit(m_current)) {
2330             auto parseNumberResult = parseOctal();
2331             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {
2332                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2333                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2334             }
2335         }
2336         FALLTHROUGH;
2337     case CharacterNumber:
2338         if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
2339             auto parseNumberResult = parseDecimal();
<a name="69" id="anc69"></a><span class="line-modified">2340             if (parseNumberResult) {</span>
<span class="line-modified">2341                 if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {</span>
<span class="line-modified">2342                     tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
<span class="line-modified">2343                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
<span class="line-modified">2344                 } else {</span>

2345                     token = BIGINT;
2346                     shift();
2347                     tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2348                     tokenData-&gt;radix = 10;
<a name="70" id="anc70"></a><span class="line-modified">2349                 }</span>
<span class="line-modified">2350             } else {</span>
<span class="line-modified">2351                 token = INTEGER;</span>
<span class="line-modified">2352                 if (m_current == &#39;.&#39;) {</span>
<span class="line-modified">2353                     shift();</span>
<span class="line-modified">2354                     if (UNLIKELY(isASCIIDigit(m_current) &amp;&amp; !parseNumberAfterDecimalPoint())) {</span>
<span class="line-modified">2355                         m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-modified">2356                         token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">2357                         goto returnError;</span>




2358                     }
<a name="71" id="anc71"></a><span class="line-modified">2359                     token = DOUBLE;</span>
<span class="line-modified">2360                 }</span>
<span class="line-modified">2361                 if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">2362                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-added">2363                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">2364                     goto returnError;</span>
2365                 }
<a name="72" id="anc72"></a><span class="line-added">2366                 size_t parsedLength;</span>
<span class="line-added">2367                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);</span>
<span class="line-added">2368                 if (token == INTEGER)</span>
<span class="line-added">2369                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
2370             }
2371         }
2372 
2373         if (UNLIKELY(isIdentStart(m_current))) {
2374             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2375             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2376             goto returnError;
2377         }
2378         m_buffer8.shrink(0);
2379         break;
2380     case CharacterQuote: {
2381         StringParseResult result = StringCannotBeParsed;
2382         if (lexerFlags &amp; LexerFlagsDontBuildStrings)
2383             result = parseString&lt;false&gt;(tokenData, strictMode);
2384         else
2385             result = parseString&lt;true&gt;(tokenData, strictMode);
2386 
2387         if (UNLIKELY(result != StringParsedSuccessfully)) {
2388             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2389             goto returnError;
2390         }
2391         shift();
2392         token = STRING;
2393         break;
2394         }
2395     case CharacterIdentifierStart:
2396         ASSERT(isIdentStart(m_current));
2397         FALLTHROUGH;
2398     case CharacterBackSlash:
2399         parseIdent:
2400         if (lexerFlags &amp; LexexFlagsDontBuildKeywords)
2401             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2402         else
2403             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2404         break;
2405     case CharacterLineTerminator:
2406         ASSERT(isLineTerminator(m_current));
2407         shiftLineTerminator();
2408         m_atLineStart = true;
2409         m_hasLineTerminatorBeforeToken = true;
2410         m_lineStart = m_code;
2411         goto start;
<a name="73" id="anc73"></a><span class="line-added">2412     case CharacterHash:</span>
<span class="line-added">2413         // Hashbang is only permitted at the start of the source text.</span>
<span class="line-added">2414         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {</span>
<span class="line-added">2415             shift();</span>
<span class="line-added">2416             shift();</span>
<span class="line-added">2417             goto inSingleLineComment;</span>
<span class="line-added">2418         }</span>
<span class="line-added">2419         goto invalidCharacter;</span>
2420     case CharacterPrivateIdentifierStart:
2421         if (m_parsingBuiltinFunction)
2422             goto parseIdent;
<a name="74" id="anc74"></a><span class="line-modified">2423         goto invalidCharacter;</span>

2424     case CharacterOtherIdentifierPart:
2425     case CharacterInvalid:
<a name="75" id="anc75"></a><span class="line-modified">2426         goto invalidCharacter;</span>


2427     default:
2428         RELEASE_ASSERT_NOT_REACHED();
2429         m_lexErrorMessage = &quot;Internal Error&quot;_s;
2430         token = ERRORTOK;
2431         goto returnError;
2432     }
2433 
2434     m_atLineStart = false;
2435     goto returnToken;
2436 
2437 inSingleLineCommentCheckForDirectives:
2438     // Script comment directives like &quot;//# sourceURL=test.js&quot;.
2439     if (UNLIKELY((m_current == &#39;#&#39; || m_current == &#39;@&#39;) &amp;&amp; isWhiteSpace(peek(1)))) {
2440         shift();
2441         shift();
2442         parseCommentDirective();
2443     }
2444     // Fall through to complete single line comment parsing.
2445 
2446 inSingleLineComment:
2447     {
2448         auto lineNumber = m_lineNumber;
2449         auto endOffset = currentOffset();
2450         auto lineStartOffset = currentLineStartOffset();
2451         auto endPosition = currentPosition();
2452 
2453         while (!isLineTerminator(m_current)) {
2454             if (atEnd()) {
2455                 token = EOFTOK;
2456                 fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2457                 return token;
2458             }
2459             shift();
2460         }
2461         shiftLineTerminator();
2462         m_atLineStart = true;
2463         m_hasLineTerminatorBeforeToken = true;
2464         m_lineStart = m_code;
2465         if (!lastTokenWasRestrKeyword())
2466             goto start;
2467 
2468         token = SEMICOLON;
2469         fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2470         return token;
2471     }
2472 
2473 returnToken:
2474     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2475     return token;
2476 
<a name="76" id="anc76"></a><span class="line-added">2477 invalidCharacter:</span>
<span class="line-added">2478     m_lexErrorMessage = invalidCharacterMessage();</span>
<span class="line-added">2479     token = ERRORTOK;</span>
<span class="line-added">2480     // Falls through to return error.</span>
<span class="line-added">2481 </span>
2482 returnError:
2483     m_error = true;
2484     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2485     RELEASE_ASSERT(token &amp; ErrorTokenFlag);
2486     return token;
2487 }
2488 
2489 template &lt;typename T&gt;
2490 static inline void orCharacter(UChar&amp;, UChar);
2491 
2492 template &lt;&gt;
2493 inline void orCharacter&lt;LChar&gt;(UChar&amp;, UChar) { }
2494 
2495 template &lt;&gt;
2496 inline void orCharacter&lt;UChar&gt;(UChar&amp; orAccumulator, UChar character)
2497 {
2498     orAccumulator |= character;
2499 }
2500 
2501 template &lt;typename T&gt;
2502 JSTokenType Lexer&lt;T&gt;::scanRegExp(JSToken* tokenRecord, UChar patternPrefix)
2503 {
2504     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
2505     ASSERT(m_buffer16.isEmpty());
2506 
2507     bool lastWasEscape = false;
2508     bool inBrackets = false;
2509     UChar charactersOredTogether = 0;
2510 
2511     if (patternPrefix) {
2512         ASSERT(!isLineTerminator(patternPrefix));
2513         ASSERT(patternPrefix != &#39;/&#39;);
2514         ASSERT(patternPrefix != &#39;[&#39;);
2515         record16(patternPrefix);
2516     }
2517 
2518     while (true) {
2519         if (isLineTerminator(m_current) || atEnd()) {
2520             m_buffer16.shrink(0);
2521             JSTokenType token = UNTERMINATED_REGEXP_LITERAL_ERRORTOK;
2522             fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2523             m_error = true;
2524             m_lexErrorMessage = makeString(&quot;Unterminated regular expression literal &#39;&quot;, getToken(*tokenRecord), &quot;&#39;&quot;);
2525             return token;
2526         }
2527 
2528         T prev = m_current;
2529 
2530         shift();
2531 
2532         if (prev == &#39;/&#39; &amp;&amp; !lastWasEscape &amp;&amp; !inBrackets)
2533             break;
2534 
2535         record16(prev);
2536         orCharacter&lt;T&gt;(charactersOredTogether, prev);
2537 
2538         if (lastWasEscape) {
2539             lastWasEscape = false;
2540             continue;
2541         }
2542 
2543         switch (prev) {
2544         case &#39;[&#39;:
2545             inBrackets = true;
2546             break;
2547         case &#39;]&#39;:
2548             inBrackets = false;
2549             break;
2550         case &#39;\\&#39;:
2551             lastWasEscape = true;
2552             break;
2553         }
2554     }
2555 
2556     tokenData-&gt;pattern = makeRightSizedIdentifier(m_buffer16.data(), m_buffer16.size(), charactersOredTogether);
2557 
2558     m_buffer16.shrink(0);
2559     charactersOredTogether = 0;
2560 
2561     while (isIdentPart(m_current)) {
2562         record16(m_current);
2563         orCharacter&lt;T&gt;(charactersOredTogether, m_current);
2564         shift();
2565     }
2566 
2567     tokenData-&gt;flags = makeRightSizedIdentifier(m_buffer16.data(), m_buffer16.size(), charactersOredTogether);
2568     m_buffer16.shrink(0);
2569 
2570     // Since RegExp always ends with /, m_atLineStart always becomes false.
2571     m_atLineStart = false;
2572 
2573     JSTokenType token = REGEXP;
2574     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2575     return token;
2576 }
2577 
2578 template &lt;typename T&gt;
2579 JSTokenType Lexer&lt;T&gt;::scanTemplateString(JSToken* tokenRecord, RawStringsBuildMode rawStringsBuildMode)
2580 {
2581     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
2582     ASSERT(!m_error);
2583     ASSERT(m_buffer16.isEmpty());
2584 
2585     // Leading backquote ` (for template head) or closing brace } (for template trailing) are already shifted in the previous token scan.
2586     // So in this re-scan phase, shift() is not needed here.
2587     StringParseResult result = parseTemplateLiteral(tokenData, rawStringsBuildMode);
2588     JSTokenType token = ERRORTOK;
2589     if (UNLIKELY(result != StringParsedSuccessfully)) {
2590         token = result == StringUnterminated ? UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK : INVALID_TEMPLATE_LITERAL_ERRORTOK;
2591         m_error = true;
2592     } else
2593         token = TEMPLATE;
2594 
2595     // Since TemplateString always ends with ` or }, m_atLineStart always becomes false.
2596     m_atLineStart = false;
2597     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2598     return token;
2599 }
2600 
2601 template &lt;typename T&gt;
2602 void Lexer&lt;T&gt;::clear()
2603 {
2604     m_arena = 0;
2605 
2606     Vector&lt;LChar&gt; newBuffer8;
2607     m_buffer8.swap(newBuffer8);
2608 
2609     Vector&lt;UChar&gt; newBuffer16;
2610     m_buffer16.swap(newBuffer16);
2611 
2612     Vector&lt;UChar&gt; newBufferForRawTemplateString16;
2613     m_bufferForRawTemplateString16.swap(newBufferForRawTemplateString16);
2614 
2615     m_isReparsingFunction = false;
2616 }
2617 
2618 // Instantiate the two flavors of Lexer we need instead of putting most of this file in Lexer.h
2619 template class Lexer&lt;LChar&gt;;
2620 template class Lexer&lt;UChar&gt;;
2621 
2622 } // namespace JSC
<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>