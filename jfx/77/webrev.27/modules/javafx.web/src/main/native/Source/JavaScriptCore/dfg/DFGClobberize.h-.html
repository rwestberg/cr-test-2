<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;DFGAbstractHeap.h&quot;
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGHeapLocation.h&quot;
  33 #include &quot;DFGLazyNode.h&quot;
  34 #include &quot;DFGPureValue.h&quot;
  35 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  36 #include &quot;DOMJITSignature.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;
  38 #include &quot;JSFixedArray.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 
  41 namespace JSC { namespace DFG {
  42 
  43 template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
  44 void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)
  45 {
  46     // Some notes:
  47     //
  48     // - The canonical way of clobbering the world is to read world and write
  49     //   heap. This is because World subsumes Heap and Stack, and Stack can be
  50     //   read by anyone but only written to by explicit stack writing operations.
  51     //   Of course, claiming to also write World is not wrong; it&#39;ll just
  52     //   pessimise some important optimizations.
  53     //
  54     // - We cannot hoist, or sink, anything that has effects. This means that the
  55     //   easiest way of indicating that something cannot be hoisted is to claim
  56     //   that it side-effects some miscellaneous thing.
  57     //
  58     // - We cannot hoist forward-exiting nodes without some additional effort. I
  59     //   believe that what it comes down to is that forward-exiting generally have
  60     //   their NodeExitsForward cleared upon hoist, except for forward-exiting
  61     //   nodes that take bogus state as their input. Those are substantially
  62     //   harder. We disable it for now. In the future we could enable it by having
  63     //   versions of those nodes that backward-exit instead, but I&#39;m not convinced
  64     //   of the soundness.
  65     //
  66     // - Some nodes lie, and claim that they do not read the JSCell_structureID,
  67     //   JSCell_typeInfoFlags, etc. These are nodes that use the structure in a way
  68     //   that does not depend on things that change under structure transitions.
  69     //
  70     // - It&#39;s implicitly understood that OSR exits read the world. This is why we
  71     //   generally don&#39;t move or eliminate stores. Every node can exit, so the
  72     //   read set does not reflect things that would be read if we exited.
  73     //   Instead, the read set reflects what the node will have to read if it
  74     //   *doesn&#39;t* exit.
  75     //
  76     // - Broadly, we don&#39;t say that we&#39;re reading something if that something is
  77     //   immutable.
  78     //
  79     // - This must be sound even prior to type inference. We use this as early as
  80     //   bytecode parsing to determine at which points in the program it&#39;s legal to
  81     //   OSR exit.
  82     //
  83     // - If you do read(Stack) or read(World), then make sure that readTop() in
  84     //   PreciseLocalClobberize is correct.
  85 
  86     // While read() and write() are fairly self-explanatory - they track what sorts of things the
  87     // node may read or write - the def() functor is more tricky. It tells you the heap locations
  88     // (not just abstract heaps) that are defined by a node. A heap location comprises an abstract
  89     // heap, some nodes, and a LocationKind. Briefly, a location defined by a node is a location
  90     // whose value can be deduced from looking at the node itself. The locations returned must obey
  91     // the following properties:
  92     //
  93     // - If someone wants to CSE a load from the heap, then a HeapLocation object should be
  94     //   sufficient to find a single matching node.
  95     //
  96     // - The abstract heap is the only abstract heap that could be clobbered to invalidate any such
  97     //   CSE attempt. I.e. if clobberize() reports that on every path between some node and a node
  98     //   that defines a HeapLocation that it wanted, there were no writes to any abstract heap that
  99     //   overlap the location&#39;s heap, then we have a sound match. Effectively, the semantics of
 100     //   write() and def() are intertwined such that for them to be sound they must agree on what
 101     //   is CSEable.
 102     //
 103     // read(), write(), and def() for heap locations is enough to do GCSE on effectful things. To
 104     // keep things simple, this code will also def() pure things. def() must be overloaded to also
 105     // accept PureValue. This way, a client of clobberize() can implement GCSE entirely using the
 106     // information that clobberize() passes to write() and def(). Other clients of clobberize() can
 107     // just ignore def() by using a NoOpClobberize functor.
 108 
 109     // We allow the runtime to perform a stack scan at any time. We don&#39;t model which nodes get implemented
 110     // by calls into the runtime. For debugging we might replace the implementation of any node with a call
 111     // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
 112     // scan would read. That&#39;s what this does.
 113     for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame) {
 114         if (inlineCallFrame-&gt;isClosureCall)
 115             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));
 116         if (inlineCallFrame-&gt;isVarargs())
 117             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));
 118     }
 119 
 120     // We don&#39;t want to specifically account which nodes can read from the scope
 121     // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
 122     // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
 123     // The debugger&#39;s machinery is free to take a stack trace and try to read from
 124     // a scope which is expected to be flushed to the stack.
 125     if (graph.hasDebuggerEnabled()) {
 126         ASSERT(!node-&gt;origin.semantic.inlineCallFrame);
 127         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 128     }
 129 
 130     switch (node-&gt;op()) {
 131     case JSConstant:
 132     case DoubleConstant:
 133     case Int52Constant:
 134         def(PureValue(node, node-&gt;constant()));
 135         return;
 136 
 137     case Identity:
 138     case IdentityWithProfile:
 139     case Phantom:
 140     case Check:
 141     case CheckVarargs:
 142     case ExtractOSREntryLocal:
 143     case CheckStructureImmediate:
 144         return;
 145 
 146     case ExtractCatchLocal:
 147         read(AbstractHeap(CatchLocals, node-&gt;catchOSREntryIndex()));
 148         return;
 149 
 150     case ClearCatchLocals:
 151         write(CatchLocals);
 152         return;
 153 
 154     case LazyJSConstant:
 155         // We should enable CSE of LazyJSConstant. It&#39;s a little annoying since LazyJSValue has
 156         // more bits than we currently have in PureValue.
 157         return;
 158 
 159     case CompareEqPtr:
 160         def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));
 161         return;
 162 
 163     case ArithIMul:
 164     case ArithMin:
 165     case ArithMax:
 166     case ArithPow:
 167     case GetScope:
 168     case SkipScope:
 169     case GetGlobalObject:
 170     case StringCharCodeAt:
 171     case CompareStrictEq:
 172     case SameValue:
 173     case IsEmpty:
 174     case IsUndefined:
 175     case IsUndefinedOrNull:
 176     case IsBoolean:
 177     case IsNumber:
 178     case NumberIsInteger:
 179     case IsObject:
 180     case IsTypedArrayView:
 181     case LogicalNot:
 182     case CheckInBounds:
 183     case DoubleRep:
 184     case ValueRep:
 185     case Int52Rep:
 186     case BooleanToNumber:
 187     case FiatInt52:
 188     case MakeRope:
 189     case StrCat:
 190     case ValueToInt32:
 191     case GetExecutable:
 192     case BottomValue:
 193     case TypeOf:
 194         def(PureValue(node));
 195         return;
 196 
 197     case GetGlobalThis:
 198         read(World);
 199         return;
 200 
 201     case AtomicsIsLockFree:
 202         if (node-&gt;child1().useKind() == Int32Use)
 203             def(PureValue(node));
 204         else {
 205             read(World);
 206             write(Heap);
 207         }
 208         return;
 209 
 210     case ArithUnary:
 211         if (node-&gt;child1().useKind() == DoubleRepUse)
 212             def(PureValue(node, static_cast&lt;std::underlying_type&lt;Arith::UnaryType&gt;::type&gt;(node-&gt;arithUnaryType())));
 213         else {
 214             read(World);
 215             write(Heap);
 216         }
 217         return;
 218 
 219     case ArithFRound:
 220     case ArithSqrt:
 221         if (node-&gt;child1().useKind() == DoubleRepUse)
 222             def(PureValue(node));
 223         else {
 224             read(World);
 225             write(Heap);
 226         }
 227         return;
 228 
 229     case ArithAbs:
 230         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == DoubleRepUse)
 231             def(PureValue(node));
 232         else {
 233             read(World);
 234             write(Heap);
 235         }
 236         return;
 237 
 238     case ArithClz32:
 239         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use)
 240             def(PureValue(node));
 241         else {
 242             read(World);
 243             write(Heap);
 244         }
 245         return;
 246 
 247     case ArithNegate:
 248         if (node-&gt;child1().useKind() == Int32Use
 249             || node-&gt;child1().useKind() == DoubleRepUse
 250             || node-&gt;child1().useKind() == Int52RepUse)
 251             def(PureValue(node));
 252         else {
 253             read(World);
 254             write(Heap);
 255         }
 256         return;
 257 
 258     case IsCellWithType:
 259         def(PureValue(node, node-&gt;queriedType()));
 260         return;
 261 
 262     case ArithBitNot:
 263         if (node-&gt;child1().useKind() == UntypedUse) {
 264             read(World);
 265             write(Heap);
 266             return;
 267         }
 268         def(PureValue(node));
 269         return;
 270 
 271     case ArithBitAnd:
 272     case ArithBitOr:
 273     case ArithBitXor:
 274     case BitLShift:
 275     case BitRShift:
 276     case BitURShift:
 277         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 278             read(World);
 279             write(Heap);
 280             return;
 281         }
 282         def(PureValue(node));
 283         return;
 284 
 285     case ArithRandom:
 286         read(MathDotRandomState);
 287         write(MathDotRandomState);
 288         return;
 289 
 290     case GetEnumerableLength: {
 291         read(Heap);
 292         write(SideState);
 293         return;
 294     }
 295 
 296     case ToIndexString:
 297     case GetEnumeratorStructurePname:
 298     case GetEnumeratorGenericPname: {
 299         def(PureValue(node));
 300         return;
 301     }
 302 
 303     case HasIndexedProperty: {
 304         read(JSObject_butterfly);
 305         ArrayMode mode = node-&gt;arrayMode();
 306         switch (mode.type()) {
 307         case Array::ForceExit: {
 308             write(SideState);
 309             return;
 310         }
 311         case Array::Int32: {
 312             if (mode.isInBounds()) {
 313                 read(Butterfly_publicLength);
 314                 read(IndexedInt32Properties);
 315                 def(HeapLocation(HasIndexedPropertyLoc, IndexedInt32Properties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 316                 return;
 317             }
 318             read(Heap);
 319             return;
 320         }
 321 
 322         case Array::Double: {
 323             if (mode.isInBounds()) {
 324                 read(Butterfly_publicLength);
 325                 read(IndexedDoubleProperties);
 326                 def(HeapLocation(HasIndexedPropertyLoc, IndexedDoubleProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 327                 return;
 328             }
 329             read(Heap);
 330             return;
 331         }
 332 
 333         case Array::Contiguous: {
 334             if (mode.isInBounds()) {
 335                 read(Butterfly_publicLength);
 336                 read(IndexedContiguousProperties);
 337                 def(HeapLocation(HasIndexedPropertyLoc, IndexedContiguousProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 338                 return;
 339             }
 340             read(Heap);
 341             return;
 342         }
 343 
 344         case Array::ArrayStorage: {
 345             if (mode.isInBounds()) {
 346                 read(Butterfly_vectorLength);
 347                 read(IndexedArrayStorageProperties);
 348                 return;
 349             }
 350             read(Heap);
 351             return;
 352         }
 353 
 354         default: {
 355             read(World);
 356             write(Heap);
 357             return;
 358         }
 359         }
 360         RELEASE_ASSERT_NOT_REACHED();
 361         return;
 362     }
 363 
 364     case StringFromCharCode:
 365         switch (node-&gt;child1().useKind()) {
 366         case Int32Use:
 367             def(PureValue(node));
 368             return;
 369         case UntypedUse:
 370             read(World);
 371             write(Heap);
 372             return;
 373         default:
 374             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
 375         }
 376         return;
 377 
 378     case ArithAdd:
 379     case ArithMod:
 380     case DoubleAsInt32:
 381     case UInt32ToNumber:
 382         def(PureValue(node, node-&gt;arithMode()));
 383         return;
 384 
 385     case ArithDiv:
 386     case ArithMul:
 387     case ArithSub:
 388         switch (node-&gt;binaryUseKind()) {
 389         case Int32Use:
 390         case Int52RepUse:
 391         case DoubleRepUse:
 392             def(PureValue(node, node-&gt;arithMode()));
 393             return;
 394         case UntypedUse:
 395             read(World);
 396             write(Heap);
 397             return;
 398         default:
 399             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
 400         }
 401 
 402     case ArithRound:
 403     case ArithFloor:
 404     case ArithCeil:
 405     case ArithTrunc:
 406         if (node-&gt;child1().useKind() == DoubleRepUse)
 407             def(PureValue(node, static_cast&lt;uintptr_t&gt;(node-&gt;arithRoundingMode())));
 408         else {
 409             read(World);
 410             write(Heap);
 411         }
 412         return;
 413 
 414     case CheckCell:
 415         def(PureValue(CheckCell, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;cellOperand()));
 416         return;
 417 
 418     case CheckNotEmpty:
 419         def(PureValue(CheckNotEmpty, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1())));
 420         return;
 421 
 422     case AssertNotEmpty:
 423         write(SideState);
 424         return;
 425 
 426     case CheckStringIdent:
 427         def(PureValue(CheckStringIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));
 428         return;
 429 
 430     case ConstantStoragePointer:
 431         def(PureValue(node, node-&gt;storagePointer()));
 432         return;
 433 
 434     case KillStack:
 435         write(AbstractHeap(Stack, node-&gt;unlinkedLocal()));
 436         return;
 437 
 438     case MovHint:
 439     case ZombieHint:
 440     case ExitOK:
 441     case Upsilon:
 442     case Phi:
 443     case PhantomLocal:
 444     case SetArgument:
 445     case Jump:
 446     case Branch:
 447     case Switch:
 448     case EntrySwitch:
 449     case ForceOSRExit:
 450     case CPUIntrinsic:
 451     case CheckBadCell:
 452     case Return:
 453     case Unreachable:
 454     case CheckTierUpInLoop:
 455     case CheckTierUpAtReturn:
 456     case CheckTierUpAndOSREnter:
 457     case LoopHint:
 458     case ProfileType:
 459     case ProfileControlFlow:
 460     case PutHint:
 461     case InitializeEntrypointArguments:
 462     case FilterCallLinkStatus:
 463     case FilterGetByIdStatus:
 464     case FilterPutByIdStatus:
 465     case FilterInByIdStatus:
 466         write(SideState);
 467         return;
 468 
 469     case StoreBarrier:
 470         read(JSCell_cellState);
 471         write(JSCell_cellState);
 472         return;
 473 
 474     case FencedStoreBarrier:
 475         read(Heap);
 476         write(JSCell_cellState);
 477         return;
 478 
 479     case CheckTraps:
 480         read(InternalState);
 481         write(InternalState);
 482         return;
 483 
 484     case InvalidationPoint:
 485         write(SideState);
 486         def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
 487         return;
 488 
 489     case Flush:
 490         read(AbstractHeap(Stack, node-&gt;local()));
 491         write(SideState);
 492         return;
 493 
 494     case NotifyWrite:
 495         write(Watchpoint_fire);
 496         write(SideState);
 497         return;
 498 
 499     case PushWithScope: {
 500         read(World);
 501         write(HeapObjectCount);
 502         return;
 503     }
 504 
 505     case CreateActivation: {
 506         SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 507         if (table-&gt;singletonScope()-&gt;isStillValid())
 508             write(Watchpoint_fire);
 509         read(HeapObjectCount);
 510         write(HeapObjectCount);
 511         return;
 512     }
 513 
 514     case CreateDirectArguments:
 515     case CreateScopedArguments:
 516     case CreateClonedArguments:
 517         read(Stack);
 518         read(HeapObjectCount);
 519         write(HeapObjectCount);
 520         return;
 521 
 522     case PhantomDirectArguments:
 523     case PhantomClonedArguments:
 524         // DFG backend requires that the locals that this reads are flushed. FTL backend can handle those
 525         // locals being promoted.
 526         if (!graph.m_plan.isFTL())
 527             read(Stack);
 528 
 529         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 530         read(HeapObjectCount);
 531         write(HeapObjectCount);
 532         return;
 533 
 534     case PhantomSpread:
 535     case PhantomNewArrayWithSpread:
 536     case PhantomNewArrayBuffer:
 537     case PhantomCreateRest:
 538         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 539         read(HeapObjectCount);
 540         write(HeapObjectCount);
 541         return;
 542 
 543     case CallObjectConstructor:
 544         read(HeapObjectCount);
 545         write(HeapObjectCount);
 546         return;
 547 
 548     case ToThis:
 549         read(MiscFields);
 550         read(HeapObjectCount);
 551         write(HeapObjectCount);
 552         return;
 553 
 554     case IsObjectOrNull:
 555         read(MiscFields);
 556         def(HeapLocation(IsObjectOrNullLoc, MiscFields, node-&gt;child1()), LazyNode(node));
 557         return;
 558 
 559     case IsFunction:
 560         read(MiscFields);
 561         def(HeapLocation(IsFunctionLoc, MiscFields, node-&gt;child1()), LazyNode(node));
 562         return;
 563 
 564     case MatchStructure:
 565         read(JSCell_structureID);
 566         return;
 567 
 568     case ArraySlice:
 569         read(MiscFields);
 570         read(JSCell_indexingType);
 571         read(JSCell_structureID);
 572         read(JSObject_butterfly);
 573         read(Butterfly_publicLength);
 574         read(IndexedDoubleProperties);
 575         read(IndexedInt32Properties);
 576         read(IndexedContiguousProperties);
 577         read(HeapObjectCount);
 578         write(HeapObjectCount);
 579         return;
 580 
 581     case ArrayIndexOf: {
 582         // FIXME: Should support a CSE rule.
 583         // https://bugs.webkit.org/show_bug.cgi?id=173173
 584         read(MiscFields);
 585         read(JSCell_indexingType);
 586         read(JSCell_structureID);
 587         read(JSObject_butterfly);
 588         read(Butterfly_publicLength);
 589         switch (node-&gt;arrayMode().type()) {
 590         case Array::Double:
 591             read(IndexedDoubleProperties);
 592             return;
 593         case Array::Int32:
 594             read(IndexedInt32Properties);
 595             return;
 596         case Array::Contiguous:
 597             read(IndexedContiguousProperties);
 598             return;
 599         default:
 600             RELEASE_ASSERT_NOT_REACHED();
 601             return;
 602         }
 603         return;
 604     }
 605 
 606     case GetById:
 607     case GetByIdFlush:
 608     case GetByIdWithThis:
 609     case GetByIdDirect:
 610     case GetByIdDirectFlush:
 611     case GetByValWithThis:
 612     case PutById:
 613     case PutByIdWithThis:
 614     case PutByValWithThis:
 615     case PutByIdFlush:
 616     case PutByIdDirect:
 617     case PutGetterById:
 618     case PutSetterById:
 619     case PutGetterSetterById:
 620     case PutGetterByVal:
 621     case PutSetterByVal:
 622     case DefineDataProperty:
 623     case DefineAccessorProperty:
 624     case DeleteById:
 625     case DeleteByVal:
 626     case ArrayPush:
 627     case ArrayPop:
 628     case Call:
 629     case DirectCall:
 630     case TailCallInlinedCaller:
 631     case DirectTailCallInlinedCaller:
 632     case Construct:
 633     case DirectConstruct:
 634     case CallVarargs:
 635     case CallForwardVarargs:
 636     case TailCallVarargsInlinedCaller:
 637     case TailCallForwardVarargsInlinedCaller:
 638     case ConstructVarargs:
 639     case ConstructForwardVarargs:
 640     case ToPrimitive:
 641     case InByVal:
 642     case InById:
 643     case HasOwnProperty:
 644     case ValueNegate:
 645     case SetFunctionName:
 646     case GetDynamicVar:
 647     case PutDynamicVar:
 648     case ResolveScopeForHoistingFuncDeclInEval:
 649     case ResolveScope:
 650     case ToObject:
 651     case HasGenericProperty:
 652     case HasStructureProperty:
 653     case GetPropertyEnumerator:
 654     case GetDirectPname:
 655     case InstanceOfCustom:
 656     case ToNumber:
 657     case NumberToStringWithRadix:
 658     case CreateThis:
 659     case InstanceOf:
 660     case StringValueOf:
 661     case ObjectKeys:
 662         read(World);
 663         write(Heap);
 664         return;
 665 
 666     case ValueBitAnd:
 667     case ValueBitXor:
 668     case ValueBitOr:
 669     case ValueAdd:
 670     case ValueSub:
 671     case ValueMul:
 672     case ValueDiv:
 673         if (node-&gt;isBinaryUseKind(BigIntUse)) {
 674             def(PureValue(node));
 675             return;
 676         }
 677         read(World);
 678         write(Heap);
 679         return;
 680 
 681     case AtomicsAdd:
 682     case AtomicsAnd:
 683     case AtomicsCompareExchange:
 684     case AtomicsExchange:
 685     case AtomicsLoad:
 686     case AtomicsOr:
 687     case AtomicsStore:
 688     case AtomicsSub:
 689     case AtomicsXor: {
 690         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
 691         Edge storageEdge = graph.child(node, 2 + numExtraArgs);
 692         if (!storageEdge) {
 693             read(World);
 694             write(Heap);
 695             return;
 696         }
 697         read(TypedArrayProperties);
 698         read(MiscFields);
 699         write(TypedArrayProperties);
 700         return;
 701     }
 702 
 703     case CallEval:
 704         ASSERT(!node-&gt;origin.semantic.inlineCallFrame);
 705         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 706         read(AbstractHeap(Stack, virtualRegisterForArgument(0)));
 707         read(World);
 708         write(Heap);
 709         return;
 710 
 711     case Throw:
 712     case ThrowStaticError:
 713     case TailCall:
 714     case DirectTailCall:
 715     case TailCallVarargs:
 716     case TailCallForwardVarargs:
 717         read(World);
 718         write(SideState);
 719         return;
 720 
 721     case GetGetter:
 722         read(GetterSetter_getter);
 723         def(HeapLocation(GetterLoc, GetterSetter_getter, node-&gt;child1()), LazyNode(node));
 724         return;
 725 
 726     case GetSetter:
 727         read(GetterSetter_setter);
 728         def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
 729         return;
 730 
 731     case GetCallee:
 732         read(AbstractHeap(Stack, CallFrameSlot::callee));
 733         def(HeapLocation(StackLoc, AbstractHeap(Stack, CallFrameSlot::callee)), LazyNode(node));
 734         return;
 735 
 736     case SetCallee:
 737         write(AbstractHeap(Stack, CallFrameSlot::callee));
 738         return;
 739 
 740     case GetArgumentCountIncludingThis: {
 741         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCount)));
 742         read(heap);
 743         def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
 744         return;
 745     }
 746 
 747     case SetArgumentCountIncludingThis:
 748         write(AbstractHeap(Stack, CallFrameSlot::argumentCount));
 749         return;
 750 
 751     case GetRestLength:
 752         read(Stack);
 753         return;
 754 
 755     case GetLocal:
 756         read(AbstractHeap(Stack, node-&gt;local()));
 757         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node));
 758         return;
 759 
 760     case SetLocal:
 761         write(AbstractHeap(Stack, node-&gt;local()));
 762         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node-&gt;child1().node()));
 763         return;
 764 
 765     case GetStack: {
 766         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);
 767         read(heap);
 768         def(HeapLocation(StackLoc, heap), LazyNode(node));
 769         return;
 770     }
 771 
 772     case PutStack: {
 773         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);
 774         write(heap);
 775         def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
 776         return;
 777     }
 778 
 779     case LoadVarargs: {
 780         read(World);
 781         write(Heap);
 782         LoadVarargsData* data = node-&gt;loadVarargsData();
 783         write(AbstractHeap(Stack, data-&gt;count.offset()));
 784         for (unsigned i = data-&gt;limit; i--;)
 785             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));
 786         return;
 787     }
 788 
 789     case ForwardVarargs: {
 790         // We could be way more precise here.
 791         read(Stack);
 792 
 793         LoadVarargsData* data = node-&gt;loadVarargsData();
 794         write(AbstractHeap(Stack, data-&gt;count.offset()));
 795         for (unsigned i = data-&gt;limit; i--;)
 796             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));
 797         return;
 798     }
 799 
 800     case GetByVal: {
 801         ArrayMode mode = node-&gt;arrayMode();
 802         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 803         switch (mode.type()) {
 804         case Array::SelectUsingPredictions:
 805         case Array::Unprofiled:
 806         case Array::SelectUsingArguments:
 807             // Assume the worst since we don&#39;t have profiling yet.
 808             read(World);
 809             write(Heap);
 810             return;
 811 
 812         case Array::ForceExit:
 813             write(SideState);
 814             return;
 815 
 816         case Array::Generic:
 817             read(World);
 818             write(Heap);
 819             return;
 820 
 821         case Array::String:
 822             if (mode.isOutOfBounds()) {
 823                 read(World);
 824                 write(Heap);
 825                 return;
 826             }
 827             // This appears to read nothing because it&#39;s only reading immutable data.
 828             def(PureValue(graph, node, mode.asWord()));
 829             return;
 830 
 831         case Array::DirectArguments:
 832             if (mode.isInBounds()) {
 833                 read(DirectArgumentsProperties);
 834                 def(HeapLocation(indexedPropertyLoc, DirectArgumentsProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 835                 return;
 836             }
 837             read(World);
 838             write(Heap);
 839             return;
 840 
 841         case Array::ScopedArguments:
 842             read(ScopeProperties);
 843             def(HeapLocation(indexedPropertyLoc, ScopeProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 844             return;
 845 
 846         case Array::Int32:
 847             if (mode.isInBounds()) {
 848                 read(Butterfly_publicLength);
 849                 read(IndexedInt32Properties);
 850                 def(HeapLocation(indexedPropertyLoc, IndexedInt32Properties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 851                 return;
 852             }
 853             read(World);
 854             write(Heap);
 855             return;
 856 
 857         case Array::Double:
 858             if (mode.isInBounds()) {
 859                 read(Butterfly_publicLength);
 860                 read(IndexedDoubleProperties);
 861                 LocationKind kind = mode.isSaneChain() ? IndexedPropertyDoubleSaneChainLoc : IndexedPropertyDoubleLoc;
 862                 def(HeapLocation(kind, IndexedDoubleProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 863                 return;
 864             }
 865             read(World);
 866             write(Heap);
 867             return;
 868 
 869         case Array::Contiguous:
 870             if (mode.isInBounds()) {
 871                 read(Butterfly_publicLength);
 872                 read(IndexedContiguousProperties);
 873                 def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 874                 return;
 875             }
 876             read(World);
 877             write(Heap);
 878             return;
 879 
 880         case Array::Undecided:
 881             def(PureValue(graph, node));
 882             return;
 883 
 884         case Array::ArrayStorage:
 885         case Array::SlowPutArrayStorage:
 886             if (mode.isInBounds()) {
 887                 read(Butterfly_vectorLength);
 888                 read(IndexedArrayStorageProperties);
 889                 return;
 890             }
 891             read(World);
 892             write(Heap);
 893             return;
 894 
 895         case Array::Int8Array:
 896         case Array::Int16Array:
 897         case Array::Int32Array:
 898         case Array::Uint8Array:
 899         case Array::Uint8ClampedArray:
 900         case Array::Uint16Array:
 901         case Array::Uint32Array:
 902         case Array::Float32Array:
 903         case Array::Float64Array:
 904             read(TypedArrayProperties);
 905             read(MiscFields);
 906             def(HeapLocation(indexedPropertyLoc, TypedArrayProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 907             return;
 908         // We should not get an AnyTypedArray in a GetByVal as AnyTypedArray is only created from intrinsics, which
 909         // are only added from Inline Caching a GetById.
 910         case Array::AnyTypedArray:
 911             DFG_CRASH(graph, node, &quot;impossible array mode for get&quot;);
 912             return;
 913         }
 914         RELEASE_ASSERT_NOT_REACHED();
 915         return;
 916     }
 917 
 918     case GetMyArgumentByVal:
 919     case GetMyArgumentByValOutOfBounds: {
 920         read(Stack);
 921         // FIXME: It would be trivial to have a def here.
 922         // https://bugs.webkit.org/show_bug.cgi?id=143077
 923         return;
 924     }
 925 
 926     case PutByValDirect:
 927     case PutByVal:
 928     case PutByValAlias: {
 929         ArrayMode mode = node-&gt;arrayMode();
 930         Node* base = graph.varArgChild(node, 0).node();
 931         Node* index = graph.varArgChild(node, 1).node();
 932         Node* value = graph.varArgChild(node, 2).node();
 933         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 934 
 935         switch (mode.modeForPut().type()) {
 936         case Array::SelectUsingPredictions:
 937         case Array::SelectUsingArguments:
 938         case Array::Unprofiled:
 939         case Array::Undecided:
 940             // Assume the worst since we don&#39;t have profiling yet.
 941             read(World);
 942             write(Heap);
 943             return;
 944 
 945         case Array::ForceExit:
 946             write(SideState);
 947             return;
 948 
 949         case Array::Generic:
 950             read(World);
 951             write(Heap);
 952             return;
 953 
 954         case Array::Int32:
 955             if (node-&gt;arrayMode().isOutOfBounds()) {
 956                 read(World);
 957                 write(Heap);
 958                 return;
 959             }
 960             read(Butterfly_publicLength);
 961             read(Butterfly_vectorLength);
 962             read(IndexedInt32Properties);
 963             write(IndexedInt32Properties);
 964             if (node-&gt;arrayMode().mayStoreToHole())
 965                 write(Butterfly_publicLength);
 966             def(HeapLocation(indexedPropertyLoc, IndexedInt32Properties, base, index), LazyNode(value));
 967             return;
 968 
 969         case Array::Double:
 970             if (node-&gt;arrayMode().isOutOfBounds()) {
 971                 read(World);
 972                 write(Heap);
 973                 return;
 974             }
 975             read(Butterfly_publicLength);
 976             read(Butterfly_vectorLength);
 977             read(IndexedDoubleProperties);
 978             write(IndexedDoubleProperties);
 979             if (node-&gt;arrayMode().mayStoreToHole())
 980                 write(Butterfly_publicLength);
 981             def(HeapLocation(IndexedPropertyDoubleLoc, IndexedDoubleProperties, base, index), LazyNode(value));
 982             def(HeapLocation(IndexedPropertyDoubleSaneChainLoc, IndexedDoubleProperties, base, index), LazyNode(value));
 983             return;
 984 
 985         case Array::Contiguous:
 986             if (node-&gt;arrayMode().isOutOfBounds()) {
 987                 read(World);
 988                 write(Heap);
 989                 return;
 990             }
 991             read(Butterfly_publicLength);
 992             read(Butterfly_vectorLength);
 993             read(IndexedContiguousProperties);
 994             write(IndexedContiguousProperties);
 995             if (node-&gt;arrayMode().mayStoreToHole())
 996                 write(Butterfly_publicLength);
 997             def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, base, index), LazyNode(value));
 998             return;
 999 
1000         case Array::ArrayStorage:
1001             if (node-&gt;arrayMode().isOutOfBounds()) {
1002                 read(World);
1003                 write(Heap);
1004                 return;
1005             }
1006             read(Butterfly_publicLength);
1007             read(Butterfly_vectorLength);
1008             read(ArrayStorageProperties);
1009             write(ArrayStorageProperties);
1010             if (node-&gt;arrayMode().mayStoreToHole())
1011                 write(Butterfly_publicLength);
1012             return;
1013 
1014         case Array::SlowPutArrayStorage:
1015             if (node-&gt;arrayMode().mayStoreToHole()) {
1016                 read(World);
1017                 write(Heap);
1018                 return;
1019             }
1020             read(Butterfly_publicLength);
1021             read(Butterfly_vectorLength);
1022             read(ArrayStorageProperties);
1023             write(ArrayStorageProperties);
1024             return;
1025 
1026         case Array::Int8Array:
1027         case Array::Int16Array:
1028         case Array::Int32Array:
1029         case Array::Uint8Array:
1030         case Array::Uint8ClampedArray:
1031         case Array::Uint16Array:
1032         case Array::Uint32Array:
1033         case Array::Float32Array:
1034         case Array::Float64Array:
1035             read(MiscFields);
1036             write(TypedArrayProperties);
1037             // FIXME: We can&#39;t def() anything here because these operations truncate their inputs.
1038             // https://bugs.webkit.org/show_bug.cgi?id=134737
1039             return;
1040         case Array::AnyTypedArray:
1041         case Array::String:
1042         case Array::DirectArguments:
1043         case Array::ScopedArguments:
1044             DFG_CRASH(graph, node, &quot;impossible array mode for put&quot;);
1045             return;
1046         }
1047         RELEASE_ASSERT_NOT_REACHED();
1048         return;
1049     }
1050 
1051     case CheckStructureOrEmpty:
1052     case CheckStructure:
1053         read(JSCell_structureID);
1054         return;
1055 
1056     case CheckArray:
1057         read(JSCell_indexingType);
1058         read(JSCell_typeInfoType);
1059         read(JSCell_structureID);
1060         return;
1061 
1062     case CheckTypeInfoFlags:
1063         read(JSCell_typeInfoFlags);
1064         def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1065         return;
1066 
1067     case ParseInt:
1068         // Note: We would have eliminated a ParseInt that has just a single child as an Int32Use inside fixup.
1069         if (node-&gt;child1().useKind() == StringUse &amp;&amp; (!node-&gt;child2() || node-&gt;child2().useKind() == Int32Use)) {
1070             def(PureValue(node));
1071             return;
1072         }
1073 
1074         read(World);
1075         write(Heap);
1076         return;
1077 
1078     case OverridesHasInstance:
1079         read(JSCell_typeInfoFlags);
1080         def(HeapLocation(OverridesHasInstanceLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1081         return;
1082 
1083     case PutStructure:
1084         read(JSObject_butterfly);
1085         write(JSCell_structureID);
1086         write(JSCell_typeInfoType);
1087         write(JSCell_typeInfoFlags);
1088         write(JSCell_indexingType);
1089         return;
1090 
1091     case AllocatePropertyStorage:
1092     case ReallocatePropertyStorage:
1093         read(HeapObjectCount);
1094         write(HeapObjectCount);
1095         return;
1096 
1097     case NukeStructureAndSetButterfly:
1098         write(JSObject_butterfly);
1099         write(JSCell_structureID);
1100         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1101         return;
1102 
1103     case GetButterfly:
1104         read(JSObject_butterfly);
1105         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node));
1106         return;
1107 
1108     case CheckSubClass:
1109         def(PureValue(node, node-&gt;classInfo()));
1110         return;
1111 
1112     case CallDOMGetter: {
1113         DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
1114         if (!snippet) {
1115             read(World);
1116             write(Heap);
1117             return;
1118         }
1119         DOMJIT::Effect effect = snippet-&gt;effect;
1120         if (effect.reads) {
1121             if (effect.reads == DOMJIT::HeapRange::top())
1122                 read(World);
1123             else
1124                 read(AbstractHeap(DOMState, effect.reads.rawRepresentation()));
1125         }
1126         if (effect.writes) {
1127             if (effect.writes == DOMJIT::HeapRange::top())
1128                 write(Heap);
1129             else
1130                 write(AbstractHeap(DOMState, effect.writes.rawRepresentation()));
1131         }
1132         if (effect.def != DOMJIT::HeapRange::top()) {
1133             DOMJIT::HeapRange range = effect.def;
1134             if (range == DOMJIT::HeapRange::none())
1135                 def(PureValue(node, bitwise_cast&lt;uintptr_t&gt;(node-&gt;callDOMGetterData()-&gt;customAccessorGetter)));
1136             else {
1137                 // Def with heap location. We do not include &quot;GlobalObject&quot; for that since this information is included in the base node.
1138                 // We only see the DOMJIT getter here. So just including &quot;base&quot; is ok.
1139                 def(HeapLocation(DOMStateLoc, AbstractHeap(DOMState, range.rawRepresentation()), node-&gt;child1()), LazyNode(node));
1140             }
1141         }
1142         return;
1143     }
1144 
1145     case CallDOM: {
1146         const DOMJIT::Signature* signature = node-&gt;signature();
1147         DOMJIT::Effect effect = signature-&gt;effect;
1148         if (effect.reads) {
1149             if (effect.reads == DOMJIT::HeapRange::top())
1150                 read(World);
1151             else
1152                 read(AbstractHeap(DOMState, effect.reads.rawRepresentation()));
1153         }
1154         if (effect.writes) {
1155             if (effect.writes == DOMJIT::HeapRange::top())
1156                 write(Heap);
1157             else
1158                 write(AbstractHeap(DOMState, effect.writes.rawRepresentation()));
1159         }
1160         ASSERT_WITH_MESSAGE(effect.def == DOMJIT::HeapRange::top(), &quot;Currently, we do not accept any def for CallDOM.&quot;);
1161         return;
1162     }
1163 
1164     case Arrayify:
1165     case ArrayifyToStructure:
1166         read(JSCell_structureID);
1167         read(JSCell_indexingType);
1168         read(JSObject_butterfly);
1169         write(JSCell_structureID);
1170         write(JSCell_indexingType);
1171         write(JSObject_butterfly);
1172         write(Watchpoint_fire);
1173         return;
1174 
1175     case GetIndexedPropertyStorage:
1176         if (node-&gt;arrayMode().type() == Array::String) {
1177             def(PureValue(node, node-&gt;arrayMode().asWord()));
1178             return;
1179         }
1180         read(MiscFields);
1181         def(HeapLocation(IndexedPropertyStorageLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1182         return;
1183 
1184     case GetTypedArrayByteOffset:
1185         read(MiscFields);
1186         def(HeapLocation(TypedArrayByteOffsetLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1187         return;
1188 
1189     case GetPrototypeOf: {
1190         switch (node-&gt;child1().useKind()) {
1191         case ArrayUse:
1192         case FunctionUse:
1193         case FinalObjectUse:
1194             read(JSCell_structureID);
1195             read(JSObject_butterfly);
1196             read(NamedProperties); // Poly proto could load prototype from its slot.
1197             def(HeapLocation(PrototypeLoc, NamedProperties, node-&gt;child1()), LazyNode(node));
1198             return;
1199         default:
1200             read(World);
1201             write(Heap);
1202             return;
1203         }
1204     }
1205 
1206     case GetByOffset:
1207     case GetGetterSetterByOffset: {
1208         unsigned identifierNumber = node-&gt;storageAccessData().identifierNumber;
1209         AbstractHeap heap(NamedProperties, identifierNumber);
1210         read(heap);
1211         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child2()), LazyNode(node));
1212         return;
1213     }
1214 
1215     case TryGetById: {
1216         read(Heap);
1217         return;
1218     }
1219 
1220     case MultiGetByOffset: {
1221         read(JSCell_structureID);
1222         read(JSObject_butterfly);
1223         AbstractHeap heap(NamedProperties, node-&gt;multiGetByOffsetData().identifierNumber);
1224         read(heap);
1225         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child1()), LazyNode(node));
1226         return;
1227     }
1228 
1229     case MultiPutByOffset: {
1230         read(JSCell_structureID);
1231         read(JSObject_butterfly);
1232         AbstractHeap heap(NamedProperties, node-&gt;multiPutByOffsetData().identifierNumber);
1233         write(heap);
1234         if (node-&gt;multiPutByOffsetData().writesStructures())
1235             write(JSCell_structureID);
1236         if (node-&gt;multiPutByOffsetData().reallocatesStorage())
1237             write(JSObject_butterfly);
1238         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1239         return;
1240     }
1241 
1242     case PutByOffset: {
1243         unsigned identifierNumber = node-&gt;storageAccessData().identifierNumber;
1244         AbstractHeap heap(NamedProperties, identifierNumber);
1245         write(heap);
1246         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child2()), LazyNode(node-&gt;child3().node()));
1247         return;
1248     }
1249 
1250     case GetArrayLength: {
1251         ArrayMode mode = node-&gt;arrayMode();
1252         switch (mode.type()) {
1253         case Array::Undecided:
1254         case Array::Int32:
1255         case Array::Double:
1256         case Array::Contiguous:
1257         case Array::ArrayStorage:
1258         case Array::SlowPutArrayStorage:
1259             read(Butterfly_publicLength);
1260             def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node-&gt;child1()), LazyNode(node));
1261             return;
1262 
1263         case Array::String:
1264             def(PureValue(node, mode.asWord()));
1265             return;
1266 
1267         case Array::DirectArguments:
1268         case Array::ScopedArguments:
1269             read(MiscFields);
1270             def(HeapLocation(ArrayLengthLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1271             return;
1272 
1273         default:
1274             ASSERT(mode.isSomeTypedArrayView());
1275             read(MiscFields);
1276             def(HeapLocation(ArrayLengthLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1277             return;
1278         }
1279     }
1280 
1281     case GetVectorLength: {
1282         ArrayMode mode = node-&gt;arrayMode();
1283         switch (mode.type()) {
1284         case Array::ArrayStorage:
1285         case Array::SlowPutArrayStorage:
1286             read(Butterfly_vectorLength);
1287             def(HeapLocation(VectorLengthLoc, Butterfly_vectorLength, node-&gt;child1()), LazyNode(node));
1288             return;
1289 
1290         default:
1291             RELEASE_ASSERT_NOT_REACHED();
1292             return;
1293         }
1294     }
1295 
1296     case GetClosureVar:
1297         read(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1298         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node));
1299         return;
1300 
1301     case PutClosureVar:
1302         write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1303         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1304         return;
1305 
1306     case GetRegExpObjectLastIndex:
1307         read(RegExpObject_lastIndex);
1308         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
1309         return;
1310 
1311     case SetRegExpObjectLastIndex:
1312         write(RegExpObject_lastIndex);
1313         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1314         return;
1315 
1316     case RecordRegExpCachedResult:
1317         write(RegExpState);
1318         return;
1319 
1320     case GetFromArguments: {
1321         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1322         read(heap);
1323         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node));
1324         return;
1325     }
1326 
1327     case PutToArguments: {
1328         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1329         write(heap);
1330         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1331         return;
1332     }
1333 
1334     case GetArgument: {
1335         read(Stack);
1336         // FIXME: It would be trivial to have a def here.
1337         // https://bugs.webkit.org/show_bug.cgi?id=143077
1338         return;
1339     }
1340 
1341     case GetGlobalVar:
1342     case GetGlobalLexicalVariable:
1343         read(AbstractHeap(Absolute, node-&gt;variablePointer()));
1344         def(HeapLocation(GlobalVariableLoc, AbstractHeap(Absolute, node-&gt;variablePointer())), LazyNode(node));
1345         return;
1346 
1347     case PutGlobalVariable:
1348         write(AbstractHeap(Absolute, node-&gt;variablePointer()));
1349         def(HeapLocation(GlobalVariableLoc, AbstractHeap(Absolute, node-&gt;variablePointer())), LazyNode(node-&gt;child2().node()));
1350         return;
1351 
1352     case NewArrayWithSize:
1353         read(HeapObjectCount);
1354         write(HeapObjectCount);
1355         return;
1356 
1357     case NewTypedArray:
1358         switch (node-&gt;child1().useKind()) {
1359         case Int32Use:
1360             read(HeapObjectCount);
1361             write(HeapObjectCount);
1362             return;
1363         case UntypedUse:
1364             read(World);
1365             write(Heap);
1366             return;
1367         default:
1368             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
1369         }
1370         break;
1371 
1372     case NewArrayWithSpread: {
1373         // This also reads from JSFixedArray&#39;s data store, but we don&#39;t have any way of describing that yet.
1374         read(HeapObjectCount);
1375         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
1376             Node* child = graph.varArgChild(node, i).node();
1377             if (child-&gt;op() == PhantomSpread) {
1378                 read(Stack);
1379                 break;
1380             }
1381         }
1382         write(HeapObjectCount);
1383         return;
1384     }
1385 
1386     case Spread: {
1387         if (node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
1388             read(MiscFields);
1389             return;
1390         }
1391 
1392         if (node-&gt;child1()-&gt;op() == PhantomCreateRest) {
1393             read(Stack);
1394             write(HeapObjectCount);
1395             return;
1396         }
1397 
1398         read(World);
1399         write(Heap);
1400         return;
1401     }
1402 
1403     case NewArray: {
1404         read(HeapObjectCount);
1405         write(HeapObjectCount);
1406 
1407         unsigned numElements = node-&gt;numChildren();
1408 
1409         def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node),
1410             LazyNode(graph.freeze(jsNumber(numElements))));
1411 
1412         if (!numElements)
1413             return;
1414 
1415         AbstractHeap heap;
1416         LocationKind indexedPropertyLoc;
1417         switch (node-&gt;indexingType()) {
1418         case ALL_DOUBLE_INDEXING_TYPES:
1419             heap = IndexedDoubleProperties;
1420             indexedPropertyLoc = IndexedPropertyDoubleLoc;
1421             break;
1422 
1423         case ALL_INT32_INDEXING_TYPES:
1424             heap = IndexedInt32Properties;
1425             indexedPropertyLoc = IndexedPropertyJSLoc;
1426             break;
1427 
1428         case ALL_CONTIGUOUS_INDEXING_TYPES:
1429             heap = IndexedContiguousProperties;
1430             indexedPropertyLoc = IndexedPropertyJSLoc;
1431             break;
1432 
1433         default:
1434             return;
1435         }
1436 
1437         if (numElements &lt; graph.m_uint32ValuesInUse.size()) {
1438             for (unsigned operandIdx = 0; operandIdx &lt; numElements; ++operandIdx) {
1439                 Edge use = graph.m_varArgChildren[node-&gt;firstChild() + operandIdx];
1440                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(operandIdx)))),
1441                     LazyNode(use.node()));
1442             }
1443         } else {
1444             for (uint32_t operandIdx : graph.m_uint32ValuesInUse) {
1445                 if (operandIdx &gt;= numElements)
1446                     continue;
1447                 Edge use = graph.m_varArgChildren[node-&gt;firstChild() + operandIdx];
1448                 // operandIdx comes from graph.m_uint32ValuesInUse and thus is guaranteed to be already frozen
1449                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(operandIdx)))),
1450                     LazyNode(use.node()));
1451             }
1452         }
1453         return;
1454     }
1455 
1456     case NewArrayBuffer: {
1457         read(HeapObjectCount);
1458         write(HeapObjectCount);
1459 
1460         auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1461         unsigned numElements = array-&gt;length();
1462         def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node),
1463             LazyNode(graph.freeze(jsNumber(numElements))));
1464 
1465         AbstractHeap heap;
1466         LocationKind indexedPropertyLoc;
1467         NodeType op = JSConstant;
1468         switch (node-&gt;indexingType()) {
1469         case ALL_DOUBLE_INDEXING_TYPES:
1470             heap = IndexedDoubleProperties;
1471             indexedPropertyLoc = IndexedPropertyDoubleLoc;
1472             op = DoubleConstant;
1473             break;
1474 
1475         case ALL_INT32_INDEXING_TYPES:
1476             heap = IndexedInt32Properties;
1477             indexedPropertyLoc = IndexedPropertyJSLoc;
1478             break;
1479 
1480         case ALL_CONTIGUOUS_INDEXING_TYPES:
1481             heap = IndexedContiguousProperties;
1482             indexedPropertyLoc = IndexedPropertyJSLoc;
1483             break;
1484 
1485         default:
1486             return;
1487         }
1488 
1489         if (numElements &lt; graph.m_uint32ValuesInUse.size()) {
1490             for (unsigned index = 0; index &lt; numElements; ++index) {
1491                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(index)))),
1492                     LazyNode(graph.freeze(array-&gt;get(index)), op));
1493             }
1494         } else {
1495             Vector&lt;uint32_t&gt; possibleIndices;
1496             for (uint32_t index : graph.m_uint32ValuesInUse) {
1497                 if (index &gt;= numElements)
1498                     continue;
1499                 possibleIndices.append(index);
1500             }
1501             for (uint32_t index : possibleIndices) {
1502                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(index)))),
1503                     LazyNode(graph.freeze(array-&gt;get(index)), op));
1504             }
1505         }
1506         return;
1507     }
1508 
1509     case CreateRest: {
1510         if (!graph.isWatchingHavingABadTimeWatchpoint(node)) {
1511             // This means we&#39;re already having a bad time.
1512             read(World);
1513             write(Heap);
1514             return;
1515         }
1516         read(Stack);
1517         read(HeapObjectCount);
1518         write(HeapObjectCount);
1519         return;
1520     }
1521 
1522     case ObjectCreate: {
1523         switch (node-&gt;child1().useKind()) {
1524         case ObjectUse:
1525             read(HeapObjectCount);
1526             write(HeapObjectCount);
1527             return;
1528         case UntypedUse:
1529             read(World);
1530             write(Heap);
1531             return;
1532         default:
1533             RELEASE_ASSERT_NOT_REACHED();
1534             return;
1535         }
1536     }
1537 
1538     case NewObject:
1539     case NewRegexp:
1540     case NewSymbol:
1541     case NewStringObject:
1542     case PhantomNewObject:
1543     case MaterializeNewObject:
1544     case PhantomNewFunction:
1545     case PhantomNewGeneratorFunction:
1546     case PhantomNewAsyncFunction:
1547     case PhantomNewAsyncGeneratorFunction:
1548     case PhantomCreateActivation:
1549     case MaterializeCreateActivation:
1550     case PhantomNewRegexp:
1551         read(HeapObjectCount);
1552         write(HeapObjectCount);
1553         return;
1554 
1555     case NewFunction:
1556     case NewGeneratorFunction:
1557     case NewAsyncGeneratorFunction:
1558     case NewAsyncFunction:
1559         if (node-&gt;castOperand&lt;FunctionExecutable*&gt;()-&gt;singletonFunction()-&gt;isStillValid())
1560             write(Watchpoint_fire);
1561         read(HeapObjectCount);
1562         write(HeapObjectCount);
1563         return;
1564 
1565     case RegExpExec:
1566     case RegExpTest:
1567         // Even if we&#39;ve proven known input types as RegExpObject and String,
1568         // accessing lastIndex is effectful if it&#39;s a global regexp.
1569         read(World);
1570         write(Heap);
1571         return;
1572 
1573     case RegExpMatchFast:
1574         read(RegExpState);
1575         read(RegExpObject_lastIndex);
1576         write(RegExpState);
1577         write(RegExpObject_lastIndex);
1578         return;
1579 
1580     case RegExpExecNonGlobalOrSticky:
1581     case RegExpMatchFastGlobal:
1582         read(RegExpState);
1583         write(RegExpState);
1584         return;
1585 
1586     case StringReplace:
1587     case StringReplaceRegExp:
1588         if (node-&gt;child1().useKind() == StringUse
1589             &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
1590             &amp;&amp; node-&gt;child3().useKind() == StringUse) {
1591             read(RegExpState);
1592             read(RegExpObject_lastIndex);
1593             write(RegExpState);
1594             write(RegExpObject_lastIndex);
1595             return;
1596         }
1597         read(World);
1598         write(Heap);
1599         return;
1600 
1601     case StringCharAt:
1602         if (node-&gt;arrayMode().isOutOfBounds()) {
1603             read(World);
1604             write(Heap);
1605             return;
1606         }
1607         def(PureValue(node));
1608         return;
1609 
1610     case CompareBelow:
1611     case CompareBelowEq:
1612         def(PureValue(node));
1613         return;
1614 
1615     case CompareEq:
1616     case CompareLess:
1617     case CompareLessEq:
1618     case CompareGreater:
1619     case CompareGreaterEq:
1620         if (node-&gt;isBinaryUseKind(StringUse)) {
1621             read(HeapObjectCount);
1622             write(HeapObjectCount);
1623             return;
1624         }
1625 
1626         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1627             read(World);
1628             write(Heap);
1629             return;
1630         }
1631 
1632         def(PureValue(node));
1633         return;
1634 
1635     case ToString:
1636     case CallStringConstructor:
1637         switch (node-&gt;child1().useKind()) {
1638         case CellUse:
1639         case UntypedUse:
1640             read(World);
1641             write(Heap);
1642             return;
1643 
1644         case StringObjectUse:
1645         case StringOrStringObjectUse:
1646             // These two StringObjectUse&#39;s are pure because if we emit this node with either
1647             // of these UseKinds, we&#39;ll first emit a StructureCheck ensuring that we&#39;re the
1648             // original String or StringObject structure. Therefore, we don&#39;t have an overridden
1649             // valueOf, etc.
1650 
1651         case Int32Use:
1652         case Int52RepUse:
1653         case DoubleRepUse:
1654         case NotCellUse:
1655             def(PureValue(node));
1656             return;
1657 
1658         default:
1659             RELEASE_ASSERT_NOT_REACHED();
1660             return;
1661         }
1662 
1663     case CountExecution:
1664     case SuperSamplerBegin:
1665     case SuperSamplerEnd:
1666         read(InternalState);
1667         write(InternalState);
1668         return;
1669 
1670     case LogShadowChickenPrologue:
1671     case LogShadowChickenTail:
1672         write(SideState);
1673         return;
1674 
1675     case MapHash:
1676         def(PureValue(node));
1677         return;
1678 
1679     case NormalizeMapKey:
1680         def(PureValue(node));
1681         return;
1682 
1683     case GetMapBucket: {
1684         Edge&amp; mapEdge = node-&gt;child1();
1685         Edge&amp; keyEdge = node-&gt;child2();
1686         AbstractHeapKind heap = (mapEdge.useKind() == MapObjectUse) ? JSMapFields : JSSetFields;
1687         read(heap);
1688         def(HeapLocation(MapBucketLoc, heap, mapEdge, keyEdge), LazyNode(node));
1689         return;
1690     }
1691 
1692     case GetMapBucketHead: {
1693         Edge&amp; mapEdge = node-&gt;child1();
1694         AbstractHeapKind heap = (mapEdge.useKind() == MapObjectUse) ? JSMapFields : JSSetFields;
1695         read(heap);
1696         def(HeapLocation(MapBucketHeadLoc, heap, mapEdge), LazyNode(node));
1697         return;
1698     }
1699 
1700     case GetMapBucketNext: {
1701         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1702         read(heap);
1703         Edge&amp; bucketEdge = node-&gt;child1();
1704         def(HeapLocation(MapBucketNextLoc, heap, bucketEdge), LazyNode(node));
1705         return;
1706     }
1707 
1708     case LoadKeyFromMapBucket: {
1709         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1710         read(heap);
1711         Edge&amp; bucketEdge = node-&gt;child1();
1712         def(HeapLocation(MapBucketKeyLoc, heap, bucketEdge), LazyNode(node));
1713         return;
1714     }
1715 
1716     case LoadValueFromMapBucket: {
1717         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1718         read(heap);
1719         Edge&amp; bucketEdge = node-&gt;child1();
1720         def(HeapLocation(MapBucketValueLoc, heap, bucketEdge), LazyNode(node));
1721         return;
1722     }
1723 
1724     case WeakMapGet: {
1725         Edge&amp; mapEdge = node-&gt;child1();
1726         Edge&amp; keyEdge = node-&gt;child2();
1727         AbstractHeapKind heap = (mapEdge.useKind() == WeakMapObjectUse) ? JSWeakMapFields : JSWeakSetFields;
1728         read(heap);
1729         def(HeapLocation(WeakMapGetLoc, heap, mapEdge, keyEdge), LazyNode(node));
1730         return;
1731     }
1732 
1733     case SetAdd: {
1734         Edge&amp; mapEdge = node-&gt;child1();
1735         Edge&amp; keyEdge = node-&gt;child2();
1736         write(JSSetFields);
1737         def(HeapLocation(MapBucketLoc, JSSetFields, mapEdge, keyEdge), LazyNode(node));
1738         return;
1739     }
1740 
1741     case MapSet: {
1742         Edge&amp; mapEdge = graph.varArgChild(node, 0);
1743         Edge&amp; keyEdge = graph.varArgChild(node, 1);
1744         write(JSMapFields);
1745         def(HeapLocation(MapBucketLoc, JSMapFields, mapEdge, keyEdge), LazyNode(node));
1746         return;
1747     }
1748 
1749     case WeakSetAdd: {
1750         Edge&amp; mapEdge = node-&gt;child1();
1751         Edge&amp; keyEdge = node-&gt;child2();
1752         write(JSWeakSetFields);
1753         def(HeapLocation(WeakMapGetLoc, JSWeakSetFields, mapEdge, keyEdge), LazyNode(keyEdge.node()));
1754         return;
1755     }
1756 
1757     case WeakMapSet: {
1758         Edge&amp; mapEdge = graph.varArgChild(node, 0);
1759         Edge&amp; keyEdge = graph.varArgChild(node, 1);
1760         Edge&amp; valueEdge = graph.varArgChild(node, 2);
1761         write(JSWeakMapFields);
1762         def(HeapLocation(WeakMapGetLoc, JSWeakMapFields, mapEdge, keyEdge), LazyNode(valueEdge.node()));
1763         return;
1764     }
1765 
1766     case ExtractValueFromWeakMapGet:
1767         def(PureValue(node));
1768         return;
1769 
1770     case StringSlice:
1771         def(PureValue(node));
1772         return;
1773 
1774     case ToLowerCase:
1775         def(PureValue(node));
1776         return;
1777 
1778     case NumberToStringWithValidRadixConstant:
1779         def(PureValue(node, node-&gt;validRadixConstant()));
1780         return;
1781 
1782     case DataViewGetFloat:
1783     case DataViewGetInt: {
1784         read(MiscFields);
1785         read(TypedArrayProperties);
1786         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
1787         def(HeapLocation(indexedPropertyLoc, AbstractHeap(TypedArrayProperties, node-&gt;dataViewData().asQuadWord),
1788             node-&gt;child1(), node-&gt;child2(), node-&gt;child3()), LazyNode(node));
1789         return;
1790     }
1791 
1792     case DataViewSet: {
1793         read(MiscFields);
1794         read(TypedArrayProperties);
1795         write(TypedArrayProperties);
1796         return;
1797     }
1798 
1799     case LastNodeType:
1800         RELEASE_ASSERT_NOT_REACHED();
1801         return;
1802     }
1803 
1804     DFG_CRASH(graph, node, toCString(&quot;Unrecognized node type: &quot;, Graph::opName(node-&gt;op())).data());
1805 }
1806 
1807 class NoOpClobberize {
1808 public:
1809     NoOpClobberize() { }
1810     template&lt;typename... T&gt;
1811     void operator()(T...) const { }
1812 };
1813 
1814 class CheckClobberize {
1815 public:
1816     CheckClobberize()
1817         : m_result(false)
1818     {
1819     }
1820 
1821     template&lt;typename... T&gt;
1822     void operator()(T...) const { m_result = true; }
1823 
1824     bool result() const { return m_result; }
1825 
1826 private:
1827     mutable bool m_result;
1828 };
1829 
1830 bool doesWrites(Graph&amp;, Node*);
1831 
1832 class AbstractHeapOverlaps {
1833 public:
1834     AbstractHeapOverlaps(AbstractHeap heap)
1835         : m_heap(heap)
1836         , m_result(false)
1837     {
1838     }
1839 
1840     void operator()(AbstractHeap otherHeap) const
1841     {
1842         if (m_result)
1843             return;
1844         m_result = m_heap.overlaps(otherHeap);
1845     }
1846 
1847     bool result() const { return m_result; }
1848 
1849 private:
1850     AbstractHeap m_heap;
1851     mutable bool m_result;
1852 };
1853 
1854 bool accessesOverlap(Graph&amp;, Node*, AbstractHeap);
1855 bool writesOverlap(Graph&amp;, Node*, AbstractHeap);
1856 
1857 bool clobbersHeap(Graph&amp;, Node*);
1858 
1859 // We would have used bind() for these, but because of the overlaoding that we are doing,
1860 // it&#39;s quite a bit of clearer to just write this out the traditional way.
1861 
1862 template&lt;typename T&gt;
1863 class ReadMethodClobberize {
1864 public:
1865     ReadMethodClobberize(T&amp; value)
1866         : m_value(value)
1867     {
1868     }
1869 
1870     void operator()(AbstractHeap heap) const
1871     {
1872         m_value.read(heap);
1873     }
1874 private:
1875     T&amp; m_value;
1876 };
1877 
1878 template&lt;typename T&gt;
1879 class WriteMethodClobberize {
1880 public:
1881     WriteMethodClobberize(T&amp; value)
1882         : m_value(value)
1883     {
1884     }
1885 
1886     void operator()(AbstractHeap heap) const
1887     {
1888         m_value.write(heap);
1889     }
1890 private:
1891     T&amp; m_value;
1892 };
1893 
1894 template&lt;typename T&gt;
1895 class DefMethodClobberize {
1896 public:
1897     DefMethodClobberize(T&amp; value)
1898         : m_value(value)
1899     {
1900     }
1901 
1902     void operator()(PureValue value) const
1903     {
1904         m_value.def(value);
1905     }
1906 
1907     void operator()(HeapLocation location, LazyNode node) const
1908     {
1909         m_value.def(location, node);
1910     }
1911 
1912 private:
1913     T&amp; m_value;
1914 };
1915 
1916 template&lt;typename Adaptor&gt;
1917 void clobberize(Graph&amp; graph, Node* node, Adaptor&amp; adaptor)
1918 {
1919     ReadMethodClobberize&lt;Adaptor&gt; read(adaptor);
1920     WriteMethodClobberize&lt;Adaptor&gt; write(adaptor);
1921     DefMethodClobberize&lt;Adaptor&gt; def(adaptor);
1922     clobberize(graph, node, read, write, def);
1923 }
1924 
1925 } } // namespace JSC::DFG
1926 
1927 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>