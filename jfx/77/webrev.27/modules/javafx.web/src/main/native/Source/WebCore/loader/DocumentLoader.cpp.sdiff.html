<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CrossOriginPreflightResultCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;DocumentLoader.h&quot;
  32 
  33 #include &quot;ApplicationCacheHost.h&quot;
  34 #include &quot;Archive.h&quot;
  35 #include &quot;ArchiveResourceCollection.h&quot;
  36 #include &quot;CachedPage.h&quot;
  37 #include &quot;CachedRawResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;ContentExtensionError.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;

  41 #include &quot;DOMWindow.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;DocumentParser.h&quot;
  44 #include &quot;DocumentWriter.h&quot;
  45 #include &quot;ElementChildIterator.h&quot;
  46 #include &quot;Event.h&quot;
  47 #include &quot;EventNames.h&quot;
  48 #include &quot;ExtensionStyleSheets.h&quot;
  49 #include &quot;FormState.h&quot;
  50 #include &quot;Frame.h&quot;
  51 #include &quot;FrameLoader.h&quot;
  52 #include &quot;FrameLoaderClient.h&quot;
  53 #include &quot;FrameTree.h&quot;
  54 #include &quot;HTMLFormElement.h&quot;
  55 #include &quot;HTMLFrameOwnerElement.h&quot;
<span class="line-removed">  56 #include &quot;HTTPHeaderField.h&quot;</span>
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
  62 #include &quot;LinkIconCollector.h&quot;
  63 #include &quot;LinkIconType.h&quot;
  64 #include &quot;LoaderStrategy.h&quot;
  65 #include &quot;Logging.h&quot;
  66 #include &quot;MemoryCache.h&quot;
  67 #include &quot;NetworkLoadMetrics.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PingLoader.h&quot;
  70 #include &quot;PlatformStrategies.h&quot;
  71 #include &quot;PolicyChecker.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;ResourceHandle.h&quot;
  74 #include &quot;ResourceLoadObserver.h&quot;
  75 #include &quot;RuntimeEnabledFeatures.h&quot;
  76 #include &quot;SWClientConnection.h&quot;
</pre>
<hr />
<pre>
 108 #include &quot;PreviewConverter.h&quot;
 109 #include &quot;QuickLook.h&quot;
 110 #endif
 111 
 112 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 113 
 114 namespace WebCore {
 115 
 116 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 117 {
 118     for (auto&amp; loader : copyToVector(loaders.values()))
 119         loader-&gt;cancel();
 120 }
 121 
 122 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 123 {
 124     for (auto&amp; loader : copyToVector(loaders.values()))
 125         loader-&gt;setDefersLoading(defers);
 126 }
 127 




































 128 static bool areAllLoadersPageCacheAcceptable(const ResourceLoaderMap&amp; loaders)
 129 {
 130     for (auto&amp; loader : copyToVector(loaders.values())) {
 131         if (!loader-&gt;frameLoader() || !loader-&gt;frameLoader()-&gt;frame().page())
 132             return false;
 133 
 134         CachedResource* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
 135         if (!cachedResource)
 136             return false;
 137 
<span class="line-modified"> 138         // Only image and XHR loads do prevent the page from entering the PageCache.</span>
 139         // All non-image loads will prevent the page from entering the PageCache.
<span class="line-modified"> 140         if (!cachedResource-&gt;isImage() &amp;&amp; !cachedResource-&gt;areAllClientsXMLHttpRequests())</span>
 141             return false;
 142     }
 143     return true;
 144 }
 145 
 146 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 147     : FrameDestructionObserver(nullptr)
 148     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 149     , m_originalRequest(request)
 150     , m_substituteData(substituteData)
 151     , m_originalRequestCopy(request)
 152     , m_request(request)
 153     , m_originalSubstituteDataWasValid(substituteData.isValid())
 154     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 155     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
<span class="line-modified"> 156     , m_applicationCacheHost(std::make_unique&lt;ApplicationCacheHost&gt;(*this))</span>
 157 {
 158 }
 159 
 160 FrameLoader* DocumentLoader::frameLoader() const
 161 {
 162     if (!m_frame)
 163         return nullptr;
 164     return &amp;m_frame-&gt;loader();
 165 }
 166 
 167 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 168 {
 169     if (!m_mainResource)
 170         return nullptr;
 171     return m_mainResource-&gt;loader();
 172 }
 173 
 174 DocumentLoader::~DocumentLoader()
 175 {
 176     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
</pre>
<hr />
<pre>
 770     // from the application cache, ensure we don&#39;t save the result for future use.
 771     if (willLoadFallback)
 772         MemoryCache::singleton().remove(*m_mainResource);
 773 
 774     if (willLoadFallback)
 775         return;
 776 
 777     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 778     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
 779     ASSERT(identifier);
 780 
 781     if (m_substituteData.isValid() || !platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 782         auto url = response.url();
 783         ContentSecurityPolicy contentSecurityPolicy(URL { url }, this);
 784         contentSecurityPolicy.didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer());
 785         if (!contentSecurityPolicy.allowFrameAncestors(*m_frame, url)) {
 786             stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 787             return;
 788         }
 789 
<span class="line-modified"> 790         String frameOptions = response.httpHeaderFields().get(HTTPHeaderName::XFrameOptions);</span>
<span class="line-modified"> 791         if (!frameOptions.isNull()) {</span>
<span class="line-modified"> 792             if (frameLoader()-&gt;shouldInterruptLoadForXFrameOptions(frameOptions, url, identifier)) {</span>
<span class="line-modified"> 793                 String message = &quot;Refused to display &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;&quot; + frameOptions + &quot;&#39;.&quot;;</span>
<span class="line-modified"> 794                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, identifier);</span>
<span class="line-modified"> 795                 stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);</span>
<span class="line-modified"> 796                 return;</span>


 797             }
 798         }
 799     }
 800 
 801     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 802     // See &lt;rdar://problem/6304600&gt; for more details.
 803 #if !USE(CF)
 804     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 805 #endif
 806 
 807     if (m_isLoadingMultipartContent) {
 808         setupForReplace();
 809         m_mainResource-&gt;clear();
 810     } else if (response.isMultipart())
 811         m_isLoadingMultipartContent = true;
 812 
 813     m_response = response;
 814 
 815     if (m_identifierForLoadWithoutResourceLoader) {
 816         if (m_mainResource &amp;&amp; m_mainResource-&gt;wasRedirected()) {
</pre>
<hr />
<pre>
 923             return;
 924         }
 925 
 926         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 927             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 928 
 929         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 930         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 931         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 932 
 933         PAL::SessionID sessionID = PAL::SessionID::defaultSessionID();
 934         if (frame() &amp;&amp; frame()-&gt;page())
 935             sessionID = frame()-&gt;page()-&gt;sessionID();
 936 
 937         if (m_request.url().protocolIsData()) {
 938             // We decode data URL internally, there is no resource load to convert.
 939             frameLoader()-&gt;client().startDownload(m_request);
 940         } else
 941             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, sessionID, m_request, m_response);
 942 
<span class="line-modified"> 943         // It might have gone missing</span>
<span class="line-modified"> 944         if (mainResourceLoader())</span>
 945             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());






 946         return;
 947     }
 948     case PolicyAction::StopAllLoads:
 949         ASSERT_NOT_REACHED();
 950 #if ASSERT_DISABLED
 951         FALLTHROUGH;
 952 #endif
 953     case PolicyAction::Ignore:
 954         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 955             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 956         stopLoadingForPolicyChange();
 957         return;
 958     }
 959 
 960     if (m_response.isHTTP()) {
 961         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
 962         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
 963             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
 964 
 965             frameLoader()-&gt;handleFallbackContent();
</pre>
<hr />
<pre>
1059                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1060             }
1061 
1062             if (m_frame-&gt;document()-&gt;activeServiceWorker() || SchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))
1063                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID()));
1064 
1065             // We currently unregister the temporary service worker client since we now registered the real document.
1066             // FIXME: We should make the real document use the temporary client identifier.
1067             unregisterTemporaryServiceWorkerClient();
1068         }
1069 #endif
1070         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1071         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1072         if (!isMultipartReplacingLoad())
1073             frameLoader()-&gt;receivedFirstData();
1074 
1075         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1076         if (!isLoading())
1077             return;
1078 



1079         bool userChosen;
1080         String encoding;
1081         if (overrideEncoding().isNull()) {
1082             userChosen = false;
1083             encoding = response().textEncodingName();
1084 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1085             if (m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceEncoding())
1086                 encoding = m_archive-&gt;mainResource()-&gt;textEncoding();
1087 #endif
1088         } else {
1089             userChosen = true;
1090             encoding = overrideEncoding();
1091         }
1092 
1093         m_writer.setEncoding(encoding, userChosen);
1094 
1095         RELEASE_ASSERT(hasBegun);
1096     }
1097 
1098 #if ENABLE(CONTENT_EXTENSIONS)
</pre>
<hr />
<pre>
1154     frameLoader()-&gt;client().willReplaceMultipartContent();
1155 
1156     maybeFinishLoadingMultipartContent();
1157     maybeCreateArchive();
1158     m_writer.end();
1159     frameLoader()-&gt;setReplacing();
1160     m_gotFirstByte = false;
1161 
1162     stopLoadingSubresources();
1163     stopLoadingPlugIns();
1164 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1165     clearArchiveResources();
1166 #endif
1167 }
1168 
1169 void DocumentLoader::checkLoadComplete()
1170 {
1171     if (!m_frame || isLoading())
1172         return;
1173 
<span class="line-modified">1174     // ASSERT(this == frameLoader()-&gt;activeDocumentLoader());</span>
1175     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1176 }
1177 















1178 void DocumentLoader::attachToFrame(Frame&amp; frame)
1179 {
1180     if (m_frame == &amp;frame)
1181         return;
1182 
1183     ASSERT(!m_frame);
1184     observeFrame(&amp;frame);
1185     m_writer.setFrame(frame);
1186     attachToFrame();
1187 
1188 #ifndef NDEBUG
1189     m_hasEverBeenAttached = true;
1190 #endif


1191 }
1192 
1193 void DocumentLoader::attachToFrame()
1194 {
1195     ASSERT(m_frame);
1196 }
1197 
1198 void DocumentLoader::detachFromFrame()
1199 {
1200 #ifndef NDEBUG
1201     if (m_hasEverBeenAttached)
1202         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1203     else
1204         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1205 #endif
1206     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1207     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1208 
1209     // It never makes sense to have a document loader that is detached from its
1210     // frame have any loads active, so kill all the loads.
</pre>
<hr />
<pre>
1255     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1256         return 0;
1257 
1258     auto head = document-&gt;head();
1259     if (!head)
1260         return 0;
1261 
1262     URL manifestURL;
1263     bool useCredentials = false;
1264     for (const auto&amp; link : childrenOfType&lt;HTMLLinkElement&gt;(*head)) {
1265         if (link.isApplicationManifest()) {
1266             manifestURL = link.href();
1267             useCredentials = equalIgnoringASCIICase(link.attributeWithoutSynchronization(HTMLNames::crossoriginAttr), &quot;use-credentials&quot;);
1268             break;
1269         }
1270     }
1271 
1272     if (manifestURL.isEmpty() || !manifestURL.isValid())
1273         return 0;
1274 
<span class="line-modified">1275     auto manifestLoader = std::make_unique&lt;ApplicationManifestLoader&gt;(*this, manifestURL, useCredentials);</span>
1276     auto* rawManifestLoader = manifestLoader.get();
1277     auto callbackID = nextCallbackID++;
1278     m_applicationManifestLoaders.set(WTFMove(manifestLoader), callbackID);
1279 
1280     if (!rawManifestLoader-&gt;startLoading()) {
1281         m_applicationManifestLoaders.remove(rawManifestLoader);
1282         return 0;
1283     }
1284 
1285     return callbackID;
1286 }
1287 
1288 void DocumentLoader::finishedLoadingApplicationManifest(ApplicationManifestLoader&amp; loader)
1289 {
1290     // If the DocumentLoader has detached from its frame, all manifest loads should have already been canceled.
1291     ASSERT(m_frame);
1292 
1293     auto callbackIdentifier = m_applicationManifestLoaders.get(&amp;loader);
1294     notifyFinishedLoadingApplicationManifest(callbackIdentifier, loader.processManifest());
1295     m_applicationManifestLoaders.remove(&amp;loader);
1296 }
1297 
1298 void DocumentLoader::notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt; manifest)
1299 {
1300     RELEASE_ASSERT(callbackIdentifier);
1301     RELEASE_ASSERT(m_frame);
1302     m_frame-&gt;loader().client().finishedLoadingApplicationManifest(callbackIdentifier, manifest);
1303 }
1304 #endif
1305 
<span class="line-removed">1306 void DocumentLoader::setCustomHeaderFields(Vector&lt;HTTPHeaderField&gt;&amp;&amp; fields)</span>
<span class="line-removed">1307 {</span>
<span class="line-removed">1308     m_customHeaderFields = WTFMove(fields);</span>
<span class="line-removed">1309 }</span>
<span class="line-removed">1310 </span>
1311 bool DocumentLoader::isLoadingInAPISense() const
1312 {
1313     // Once a frame has loaded, we no longer need to consider subresources,
1314     // but we still need to consider subframes.
1315     if (frameLoader()-&gt;state() != FrameStateComplete) {
1316         if (m_frame-&gt;settings().needsIsLoadingInAPISenseQuirk() &amp;&amp; !m_subresourceLoaders.isEmpty())
1317             return true;
1318 
1319         ASSERT(m_frame-&gt;document());
1320         auto&amp; document = *m_frame-&gt;document();
1321         if ((isLoadingMainResource() || !document.loadEventFinished()) &amp;&amp; isLoading())
1322             return true;
1323         if (m_cachedResourceLoader-&gt;requestCount())
1324             return true;
1325         if (document.isDelayingLoadEvent())
1326             return true;
1327         if (document.processingLoadEvent())
1328             return true;
1329         if (document.hasActiveParser())
1330             return true;
</pre>
<hr />
<pre>
1351     m_parsedArchiveData = &amp;mainResource.data();
1352     m_writer.setMIMEType(mainResource.mimeType());
1353 
1354     ASSERT(m_frame-&gt;document());
1355     commitData(mainResource.data().data(), mainResource.data().size());
1356     return true;
1357 #endif
1358 }
1359 
1360 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1361 
1362 void DocumentLoader::setArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
1363 {
1364     m_archive = WTFMove(archive);
1365     addAllArchiveResources(*m_archive);
1366 }
1367 
1368 void DocumentLoader::addAllArchiveResources(Archive&amp; archive)
1369 {
1370     if (!m_archiveResourceCollection)
<span class="line-modified">1371         m_archiveResourceCollection = std::make_unique&lt;ArchiveResourceCollection&gt;();</span>
1372     m_archiveResourceCollection-&gt;addAllResources(archive);
1373 }
1374 
1375 // FIXME: Adding a resource directly to a DocumentLoader/ArchiveResourceCollection seems like bad design, but is API some apps rely on.
1376 // Can we change the design in a manner that will let us deprecate that API without reducing functionality of those apps?
1377 void DocumentLoader::addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp; resource)
1378 {
1379     if (!m_archiveResourceCollection)
<span class="line-modified">1380         m_archiveResourceCollection = std::make_unique&lt;ArchiveResourceCollection&gt;();</span>
1381     m_archiveResourceCollection-&gt;addResource(WTFMove(resource));
1382 }
1383 
1384 RefPtr&lt;Archive&gt; DocumentLoader::popArchiveForSubframe(const String&amp; frameName, const URL&amp; url)
1385 {
1386     return m_archiveResourceCollection ? m_archiveResourceCollection-&gt;popSubframeArchive(frameName, url) : nullptr;
1387 }
1388 
1389 void DocumentLoader::clearArchiveResources()
1390 {
1391     m_archiveResourceCollection = nullptr;
1392     m_substituteResourceDeliveryTimer.stop();
1393 }
1394 
1395 SharedBuffer* DocumentLoader::parsedArchiveData() const
1396 {
1397     return m_parsedArchiveData.get();
1398 }
1399 
1400 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
</pre>
<hr />
<pre>
1539 }
1540 
1541 void DocumentLoader::scheduleCannotShowURLError(ResourceLoader&amp; loader)
1542 {
1543     m_pendingSubstituteResources.set(&amp;loader, nullptr);
1544     deliverSubstituteResourcesAfterDelay();
1545 }
1546 
1547 void DocumentLoader::addResponse(const ResourceResponse&amp; response)
1548 {
1549     if (!m_stopRecordingResponses)
1550         m_responses.append(response);
1551 }
1552 
1553 void DocumentLoader::stopRecordingResponses()
1554 {
1555     m_stopRecordingResponses = true;
1556     m_responses.shrinkToFit();
1557 }
1558 





1559 void DocumentLoader::setTitle(const StringWithDirection&amp; title)
1560 {
1561     if (m_pageTitle == title)
1562         return;
1563 
1564     frameLoader()-&gt;willChangeTitle(this);
1565     m_pageTitle = title;
1566     frameLoader()-&gt;didChangeTitle(this);
1567 }
1568 
1569 URL DocumentLoader::urlForHistory() const
1570 {
1571     // Return the URL to be used for history and B/F list.
1572     // Returns nil for WebDataProtocol URLs that aren&#39;t alternates
1573     // for unreachable URLs, because these can&#39;t be stored in history.
1574     if (m_substituteData.isValid() &amp;&amp; !m_substituteData.shouldRevealToSessionHistory())
1575         return unreachableURL();
1576 
1577     return m_originalRequestCopy.url();
1578 }
</pre>
<hr />
<pre>
1637     ASSERT(m_subresourceLoaders.isEmpty());
1638 }
1639 
1640 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1641 {
1642     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1643     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1644     // let it be added. In the main resource load case, mainResourceLoader()
1645     // will still be null at this point, but m_gotFirstByte should be false here if and only
1646     // if we are just starting the main resource load.
1647     if (!m_gotFirstByte)
1648         return;
1649     ASSERT(loader-&gt;identifier());
1650     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1651     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1652 
1653     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1654     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1655         return;
1656 
<span class="line-modified">1657     // A page in the PageCache or about to enter PageCache should not be able to start loads.</span>
<span class="line-modified">1658     ASSERT_WITH_SECURITY_IMPLICATION(!document() || document()-&gt;pageCacheState() == Document::NotInPageCache);</span>
















1659 
1660     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1661 }
1662 
1663 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1664 {
1665     ASSERT(loader-&gt;identifier());
1666 
1667     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1668         return;
1669     checkLoadComplete();
1670     if (Frame* frame = m_frame)
1671         frame-&gt;loader().subresourceLoadDone(type);
1672 }
1673 
1674 void DocumentLoader::addPlugInStreamLoader(ResourceLoader&amp; loader)
1675 {
1676     ASSERT(loader.identifier());
1677     ASSERT(!m_plugInStreamLoaders.contains(loader.identifier()));
1678 
</pre>
<hr />
<pre>
1779 #else
1780         if (tryLoadingRequestFromApplicationCache()) {
1781             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1782             return;
1783         }
1784         loadMainResource(WTFMove(request));
1785 #endif
1786     });
1787 }
1788 
1789 void DocumentLoader::registerTemporaryServiceWorkerClient(const URL&amp; url)
1790 {
1791 #if ENABLE(SERVICE_WORKER)
1792     ASSERT(!m_temporaryServiceWorkerClient);
1793 
1794     if (!m_serviceWorkerRegistrationData)
1795         return;
1796 
1797     m_temporaryServiceWorkerClient = TemporaryServiceWorkerClient {
1798         DocumentIdentifier::generate(),
<span class="line-modified">1799         *ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID())</span>
1800     };
1801 


1802     // FIXME: Compute ServiceWorkerClientFrameType appropriately.
<span class="line-modified">1803     ServiceWorkerClientData data { { m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;serverConnectionIdentifier(), m_temporaryServiceWorkerClient-&gt;documentIdentifier }, ServiceWorkerClientType::Window, ServiceWorkerClientFrameType::None, url };</span>
1804 
1805     RefPtr&lt;SecurityOrigin&gt; topOrigin;
1806     if (m_frame-&gt;isMainFrame())
1807         topOrigin = SecurityOrigin::create(url);
1808     else
1809         topOrigin = &amp;m_frame-&gt;mainFrame().document()-&gt;topOrigin();
<span class="line-modified">1810     m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;registerServiceWorkerClient(*topOrigin, WTFMove(data), m_serviceWorkerRegistrationData-&gt;identifier, m_frame-&gt;loader().userAgent(url));</span>
1811 #else
1812     UNUSED_PARAM(url);
1813 #endif
1814 }
1815 
1816 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1817 {
1818 #if ENABLE(SERVICE_WORKER)
1819     if (!m_temporaryServiceWorkerClient)
1820         return;
1821 
<span class="line-modified">1822     m_temporaryServiceWorkerClient-&gt;serviceWorkerConnection-&gt;unregisterServiceWorkerClient(m_temporaryServiceWorkerClient-&gt;documentIdentifier);</span>

1823     m_temporaryServiceWorkerClient = WTF::nullopt;
1824 #endif
1825 }
1826 
1827 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1828 {
1829     static NeverDestroyed&lt;ResourceLoaderOptions&gt; mainResourceLoadOptions(
1830         SendCallbackPolicy::SendCallbacks,
1831         ContentSniffingPolicy::SniffContent,
1832         DataBufferingPolicy::BufferData,
1833         StoredCredentialsPolicy::Use,
1834         ClientCredentialPolicy::MayAskClientForCredentials,
1835         FetchOptions::Credentials::Include,
1836         SecurityCheckPolicy::SkipSecurityCheck,
1837         FetchOptions::Mode::Navigate,
1838         CertificateInfoPolicy::IncludeCertificateInfo,
1839         ContentSecurityPolicyImposition::SkipPolicyCheck,
1840         DefersLoadingPolicy::AllowDefersLoading,
1841         CachingPolicy::AllowCaching);
1842     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
</pre>
<hr />
<pre>
1863     if (!m_mainResource) {
1864         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1865         // This is because we may have fired the load event in a parent frame.
1866         if (!m_frame) {
1867             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1868             return;
1869         }
1870 
1871         if (!m_request.url().isValid()) {
1872             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1873             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1874             return;
1875         }
1876 
1877         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1878 
1879         setRequest(ResourceRequest());
1880         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
1881         // is now in a state where starting an empty load will be inconsistent. Replace it with
1882         // a new ApplicationCacheHost.
<span class="line-modified">1883         m_applicationCacheHost = std::make_unique&lt;ApplicationCacheHost&gt;(*this);</span>
1884         maybeLoadEmpty();
1885         return;
1886     }
1887 
1888     ASSERT(m_frame);
1889 
1890 #if ENABLE(CONTENT_EXTENSIONS)
1891     if (m_mainResource-&gt;errorOccurred() &amp;&amp; m_frame-&gt;page() &amp;&amp; m_mainResource-&gt;resourceError().domain() == ContentExtensions::WebKitContentBlockerDomain) {
1892         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Blocked by content blocker error (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1893         cancelMainResourceLoad(frameLoader()-&gt;blockedByContentBlockerError(m_request));
1894         return;
1895     }
1896 #endif
1897 
1898     if (!mainResourceLoader()) {
1899         m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
1900         frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, mainResourceRequest.resourceRequest());
1901         frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, mainResourceRequest.resourceRequest(), ResourceResponse());
1902     }
1903 
</pre>
<hr />
<pre>
2022 
2023     m_frame-&gt;loader().client().getLoadDecisionForIcons(iconDecisions);
2024 }
2025 
2026 void DocumentLoader::didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID)
2027 {
2028     auto icon = m_iconsPendingLoadDecision.take(loadIdentifier);
2029 
2030     // If the decision was not to load or this DocumentLoader is already detached, there is no load to perform.
2031     if (!decision || !m_frame)
2032         return;
2033 
2034     // If the LinkIcon we just took is empty, then the DocumentLoader had all of its loaders stopped
2035     // while this icon load decision was pending.
2036     // In this case we need to notify the client that the icon finished loading with empty data.
2037     if (icon.url.isEmpty()) {
2038         notifyFinishedLoadingIcon(newCallbackID, nullptr);
2039         return;
2040     }
2041 
<span class="line-modified">2042     auto iconLoader = std::make_unique&lt;IconLoader&gt;(*this, icon.url);</span>
2043     auto* rawIconLoader = iconLoader.get();
2044     m_iconLoaders.set(WTFMove(iconLoader), newCallbackID);
2045 
2046     rawIconLoader-&gt;startLoading();
2047 }
2048 
2049 void DocumentLoader::finishedLoadingIcon(IconLoader&amp; loader, SharedBuffer* buffer)
2050 {
2051     // If the DocumentLoader has detached from its frame, all icon loads should have already been cancelled.
2052     ASSERT(m_frame);
2053 
2054     auto callbackIdentifier = m_iconLoaders.take(&amp;loader);
2055     notifyFinishedLoadingIcon(callbackIdentifier, buffer);
2056 }
2057 
2058 void DocumentLoader::notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer* buffer)
2059 {
2060     RELEASE_ASSERT(callbackIdentifier);
2061     RELEASE_ASSERT(m_frame);
2062     m_frame-&gt;loader().client().finishedLoadingIcon(callbackIdentifier, buffer);
2063 }
2064 
2065 void DocumentLoader::dispatchOnloadEvents()
2066 {
2067     m_wasOnloadDispatched = true;
2068     m_applicationCacheHost-&gt;stopDeferringEvents();
2069 }
2070 
2071 void DocumentLoader::setTriggeringAction(NavigationAction&amp;&amp; action)
2072 {
2073     m_triggeringAction = WTFMove(action);
2074     m_triggeringAction.setShouldOpenExternalURLsPolicy(m_frame ? shouldOpenExternalURLsPolicyToPropagate() : m_shouldOpenExternalURLsPolicy);
2075 }
2076 
2077 ShouldOpenExternalURLsPolicy DocumentLoader::shouldOpenExternalURLsPolicyToPropagate() const
2078 {
<span class="line-modified">2079     if (!m_frame || !m_frame-&gt;isMainFrame())</span>
2080         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2081 
<span class="line-modified">2082     return m_shouldOpenExternalURLsPolicy;</span>








2083 }
2084 
2085 void DocumentLoader::becomeMainResourceClient()
2086 {
2087 #if ENABLE(CONTENT_FILTERING)
2088     if (m_contentFilter)
2089         m_contentFilter-&gt;startFilteringMainResource(*m_mainResource);
2090 #endif
2091     m_mainResource-&gt;addClient(*this);
2092 }
2093 
2094 #if ENABLE(CONTENT_EXTENSIONS)
2095 void DocumentLoader::addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp; sheet)
2096 {
2097     ASSERT(!m_gotFirstByte);
2098     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2099 }
2100 
2101 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2102 {
</pre>
</td>
<td>
<hr />
<pre>
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;DocumentLoader.h&quot;
  32 
  33 #include &quot;ApplicationCacheHost.h&quot;
  34 #include &quot;Archive.h&quot;
  35 #include &quot;ArchiveResourceCollection.h&quot;
  36 #include &quot;CachedPage.h&quot;
  37 #include &quot;CachedRawResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;ContentExtensionError.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
<span class="line-added">  41 #include &quot;CustomHeaderFields.h&quot;</span>
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentParser.h&quot;
  45 #include &quot;DocumentWriter.h&quot;
  46 #include &quot;ElementChildIterator.h&quot;
  47 #include &quot;Event.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;ExtensionStyleSheets.h&quot;
  50 #include &quot;FormState.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;HTMLFormElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;

  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
  62 #include &quot;LinkIconCollector.h&quot;
  63 #include &quot;LinkIconType.h&quot;
  64 #include &quot;LoaderStrategy.h&quot;
  65 #include &quot;Logging.h&quot;
  66 #include &quot;MemoryCache.h&quot;
  67 #include &quot;NetworkLoadMetrics.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PingLoader.h&quot;
  70 #include &quot;PlatformStrategies.h&quot;
  71 #include &quot;PolicyChecker.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;ResourceHandle.h&quot;
  74 #include &quot;ResourceLoadObserver.h&quot;
  75 #include &quot;RuntimeEnabledFeatures.h&quot;
  76 #include &quot;SWClientConnection.h&quot;
</pre>
<hr />
<pre>
 108 #include &quot;PreviewConverter.h&quot;
 109 #include &quot;QuickLook.h&quot;
 110 #endif
 111 
 112 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 113 
 114 namespace WebCore {
 115 
 116 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 117 {
 118     for (auto&amp; loader : copyToVector(loaders.values()))
 119         loader-&gt;cancel();
 120 }
 121 
 122 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 123 {
 124     for (auto&amp; loader : copyToVector(loaders.values()))
 125         loader-&gt;setDefersLoading(defers);
 126 }
 127 
<span class="line-added"> 128 static bool shouldPendingCachedResourceLoadPreventPageCache(CachedResource&amp; cachedResource)</span>
<span class="line-added"> 129 {</span>
<span class="line-added"> 130     if (!cachedResource.isLoading())</span>
<span class="line-added"> 131         return false;</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133     switch (cachedResource.type()) {</span>
<span class="line-added"> 134     case CachedResource::Type::ImageResource:</span>
<span class="line-added"> 135     case CachedResource::Type::Icon:</span>
<span class="line-added"> 136     case CachedResource::Type::Beacon:</span>
<span class="line-added"> 137     case CachedResource::Type::Ping:</span>
<span class="line-added"> 138     case CachedResource::Type::LinkPrefetch:</span>
<span class="line-added"> 139         return false;</span>
<span class="line-added"> 140     case CachedResource::Type::MainResource:</span>
<span class="line-added"> 141     case CachedResource::Type::CSSStyleSheet:</span>
<span class="line-added"> 142     case CachedResource::Type::Script:</span>
<span class="line-added"> 143     case CachedResource::Type::FontResource:</span>
<span class="line-added"> 144 #if ENABLE(SVG_FONTS)</span>
<span class="line-added"> 145     case CachedResource::Type::SVGFontResource:</span>
<span class="line-added"> 146 #endif</span>
<span class="line-added"> 147     case CachedResource::Type::MediaResource:</span>
<span class="line-added"> 148     case CachedResource::Type::RawResource:</span>
<span class="line-added"> 149     case CachedResource::Type::SVGDocumentResource:</span>
<span class="line-added"> 150 #if ENABLE(XSLT)</span>
<span class="line-added"> 151     case CachedResource::Type::XSLStyleSheet:</span>
<span class="line-added"> 152 #endif</span>
<span class="line-added"> 153 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-added"> 154     case CachedResource::Type::TextTrackResource:</span>
<span class="line-added"> 155 #endif</span>
<span class="line-added"> 156 #if ENABLE(APPLICATION_MANIFEST)</span>
<span class="line-added"> 157     case CachedResource::Type::ApplicationManifest:</span>
<span class="line-added"> 158 #endif</span>
<span class="line-added"> 159         break;</span>
<span class="line-added"> 160     };</span>
<span class="line-added"> 161     return !cachedResource.areAllClientsXMLHttpRequests();</span>
<span class="line-added"> 162 }</span>
<span class="line-added"> 163 </span>
 164 static bool areAllLoadersPageCacheAcceptable(const ResourceLoaderMap&amp; loaders)
 165 {
 166     for (auto&amp; loader : copyToVector(loaders.values())) {
 167         if (!loader-&gt;frameLoader() || !loader-&gt;frameLoader()-&gt;frame().page())
 168             return false;
 169 
 170         CachedResource* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
 171         if (!cachedResource)
 172             return false;
 173 
<span class="line-modified"> 174         // Only image and XHR loads do not prevent the page from entering the PageCache.</span>
 175         // All non-image loads will prevent the page from entering the PageCache.
<span class="line-modified"> 176         if (shouldPendingCachedResourceLoadPreventPageCache(*cachedResource))</span>
 177             return false;
 178     }
 179     return true;
 180 }
 181 
 182 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 183     : FrameDestructionObserver(nullptr)
 184     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 185     , m_originalRequest(request)
 186     , m_substituteData(substituteData)
 187     , m_originalRequestCopy(request)
 188     , m_request(request)
 189     , m_originalSubstituteDataWasValid(substituteData.isValid())
 190     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 191     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
<span class="line-modified"> 192     , m_applicationCacheHost(makeUnique&lt;ApplicationCacheHost&gt;(*this))</span>
 193 {
 194 }
 195 
 196 FrameLoader* DocumentLoader::frameLoader() const
 197 {
 198     if (!m_frame)
 199         return nullptr;
 200     return &amp;m_frame-&gt;loader();
 201 }
 202 
 203 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 204 {
 205     if (!m_mainResource)
 206         return nullptr;
 207     return m_mainResource-&gt;loader();
 208 }
 209 
 210 DocumentLoader::~DocumentLoader()
 211 {
 212     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
</pre>
<hr />
<pre>
 806     // from the application cache, ensure we don&#39;t save the result for future use.
 807     if (willLoadFallback)
 808         MemoryCache::singleton().remove(*m_mainResource);
 809 
 810     if (willLoadFallback)
 811         return;
 812 
 813     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 814     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
 815     ASSERT(identifier);
 816 
 817     if (m_substituteData.isValid() || !platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 818         auto url = response.url();
 819         ContentSecurityPolicy contentSecurityPolicy(URL { url }, this);
 820         contentSecurityPolicy.didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer());
 821         if (!contentSecurityPolicy.allowFrameAncestors(*m_frame, url)) {
 822             stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 823             return;
 824         }
 825 
<span class="line-modified"> 826         if (!contentSecurityPolicy.overridesXFrameOptions()) {</span>
<span class="line-modified"> 827             String frameOptions = response.httpHeaderFields().get(HTTPHeaderName::XFrameOptions);</span>
<span class="line-modified"> 828             if (!frameOptions.isNull()) {</span>
<span class="line-modified"> 829                 if (frameLoader()-&gt;shouldInterruptLoadForXFrameOptions(frameOptions, url, identifier)) {</span>
<span class="line-modified"> 830                     String message = &quot;Refused to display &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;&quot; + frameOptions + &quot;&#39;.&quot;;</span>
<span class="line-modified"> 831                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, identifier);</span>
<span class="line-modified"> 832                     stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);</span>
<span class="line-added"> 833                     return;</span>
<span class="line-added"> 834                 }</span>
 835             }
 836         }
 837     }
 838 
 839     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 840     // See &lt;rdar://problem/6304600&gt; for more details.
 841 #if !USE(CF)
 842     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 843 #endif
 844 
 845     if (m_isLoadingMultipartContent) {
 846         setupForReplace();
 847         m_mainResource-&gt;clear();
 848     } else if (response.isMultipart())
 849         m_isLoadingMultipartContent = true;
 850 
 851     m_response = response;
 852 
 853     if (m_identifierForLoadWithoutResourceLoader) {
 854         if (m_mainResource &amp;&amp; m_mainResource-&gt;wasRedirected()) {
</pre>
<hr />
<pre>
 961             return;
 962         }
 963 
 964         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 965             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 966 
 967         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 968         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 969         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 970 
 971         PAL::SessionID sessionID = PAL::SessionID::defaultSessionID();
 972         if (frame() &amp;&amp; frame()-&gt;page())
 973             sessionID = frame()-&gt;page()-&gt;sessionID();
 974 
 975         if (m_request.url().protocolIsData()) {
 976             // We decode data URL internally, there is no resource load to convert.
 977             frameLoader()-&gt;client().startDownload(m_request);
 978         } else
 979             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, sessionID, m_request, m_response);
 980 
<span class="line-modified"> 981         // The main resource might be loading from the memory cache, or its loader might have gone missing.</span>
<span class="line-modified"> 982         if (mainResourceLoader()) {</span>
 983             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
<span class="line-added"> 984             return;</span>
<span class="line-added"> 985         }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987         // We must stop loading even if there is no main resource loader. Otherwise, we might remain</span>
<span class="line-added"> 988         // the client of a CachedRawResource that will continue to send us data.</span>
<span class="line-added"> 989         stopLoadingForPolicyChange();</span>
 990         return;
 991     }
 992     case PolicyAction::StopAllLoads:
 993         ASSERT_NOT_REACHED();
 994 #if ASSERT_DISABLED
 995         FALLTHROUGH;
 996 #endif
 997     case PolicyAction::Ignore:
 998         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 999             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
1000         stopLoadingForPolicyChange();
1001         return;
1002     }
1003 
1004     if (m_response.isHTTP()) {
1005         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
1006         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
1007             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
1008 
1009             frameLoader()-&gt;handleFallbackContent();
</pre>
<hr />
<pre>
1103                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1104             }
1105 
1106             if (m_frame-&gt;document()-&gt;activeServiceWorker() || SchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))
1107                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID()));
1108 
1109             // We currently unregister the temporary service worker client since we now registered the real document.
1110             // FIXME: We should make the real document use the temporary client identifier.
1111             unregisterTemporaryServiceWorkerClient();
1112         }
1113 #endif
1114         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1115         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1116         if (!isMultipartReplacingLoad())
1117             frameLoader()-&gt;receivedFirstData();
1118 
1119         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1120         if (!isLoading())
1121             return;
1122 
<span class="line-added">1123         if (auto* window = m_frame-&gt;document()-&gt;domWindow())</span>
<span class="line-added">1124             window-&gt;prewarmLocalStorageIfNecessary();</span>
<span class="line-added">1125 </span>
1126         bool userChosen;
1127         String encoding;
1128         if (overrideEncoding().isNull()) {
1129             userChosen = false;
1130             encoding = response().textEncodingName();
1131 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1132             if (m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceEncoding())
1133                 encoding = m_archive-&gt;mainResource()-&gt;textEncoding();
1134 #endif
1135         } else {
1136             userChosen = true;
1137             encoding = overrideEncoding();
1138         }
1139 
1140         m_writer.setEncoding(encoding, userChosen);
1141 
1142         RELEASE_ASSERT(hasBegun);
1143     }
1144 
1145 #if ENABLE(CONTENT_EXTENSIONS)
</pre>
<hr />
<pre>
1201     frameLoader()-&gt;client().willReplaceMultipartContent();
1202 
1203     maybeFinishLoadingMultipartContent();
1204     maybeCreateArchive();
1205     m_writer.end();
1206     frameLoader()-&gt;setReplacing();
1207     m_gotFirstByte = false;
1208 
1209     stopLoadingSubresources();
1210     stopLoadingPlugIns();
1211 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1212     clearArchiveResources();
1213 #endif
1214 }
1215 
1216 void DocumentLoader::checkLoadComplete()
1217 {
1218     if (!m_frame || isLoading())
1219         return;
1220 
<span class="line-modified">1221     ASSERT(this == frameLoader()-&gt;activeDocumentLoader());</span>
1222     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1223 }
1224 
<span class="line-added">1225 void DocumentLoader::applyPoliciesToSettings()</span>
<span class="line-added">1226 {</span>
<span class="line-added">1227     if (!m_frame) {</span>
<span class="line-added">1228         ASSERT_NOT_REACHED();</span>
<span class="line-added">1229         return;</span>
<span class="line-added">1230     }</span>
<span class="line-added">1231 </span>
<span class="line-added">1232     if (!m_frame-&gt;isMainFrame())</span>
<span class="line-added">1233         return;</span>
<span class="line-added">1234 </span>
<span class="line-added">1235 #if ENABLE(MEDIA_SOURCE)</span>
<span class="line-added">1236     m_frame-&gt;settings().setMediaSourceEnabled(m_mediaSourcePolicy == MediaSourcePolicy::Default ? Settings::platformDefaultMediaSourceEnabled() : m_mediaSourcePolicy == MediaSourcePolicy::Enable);</span>
<span class="line-added">1237 #endif</span>
<span class="line-added">1238 }</span>
<span class="line-added">1239 </span>
1240 void DocumentLoader::attachToFrame(Frame&amp; frame)
1241 {
1242     if (m_frame == &amp;frame)
1243         return;
1244 
1245     ASSERT(!m_frame);
1246     observeFrame(&amp;frame);
1247     m_writer.setFrame(frame);
1248     attachToFrame();
1249 
1250 #ifndef NDEBUG
1251     m_hasEverBeenAttached = true;
1252 #endif
<span class="line-added">1253 </span>
<span class="line-added">1254     applyPoliciesToSettings();</span>
1255 }
1256 
1257 void DocumentLoader::attachToFrame()
1258 {
1259     ASSERT(m_frame);
1260 }
1261 
1262 void DocumentLoader::detachFromFrame()
1263 {
1264 #ifndef NDEBUG
1265     if (m_hasEverBeenAttached)
1266         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1267     else
1268         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1269 #endif
1270     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1271     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1272 
1273     // It never makes sense to have a document loader that is detached from its
1274     // frame have any loads active, so kill all the loads.
</pre>
<hr />
<pre>
1319     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1320         return 0;
1321 
1322     auto head = document-&gt;head();
1323     if (!head)
1324         return 0;
1325 
1326     URL manifestURL;
1327     bool useCredentials = false;
1328     for (const auto&amp; link : childrenOfType&lt;HTMLLinkElement&gt;(*head)) {
1329         if (link.isApplicationManifest()) {
1330             manifestURL = link.href();
1331             useCredentials = equalIgnoringASCIICase(link.attributeWithoutSynchronization(HTMLNames::crossoriginAttr), &quot;use-credentials&quot;);
1332             break;
1333         }
1334     }
1335 
1336     if (manifestURL.isEmpty() || !manifestURL.isValid())
1337         return 0;
1338 
<span class="line-modified">1339     auto manifestLoader = makeUnique&lt;ApplicationManifestLoader&gt;(*this, manifestURL, useCredentials);</span>
1340     auto* rawManifestLoader = manifestLoader.get();
1341     auto callbackID = nextCallbackID++;
1342     m_applicationManifestLoaders.set(WTFMove(manifestLoader), callbackID);
1343 
1344     if (!rawManifestLoader-&gt;startLoading()) {
1345         m_applicationManifestLoaders.remove(rawManifestLoader);
1346         return 0;
1347     }
1348 
1349     return callbackID;
1350 }
1351 
1352 void DocumentLoader::finishedLoadingApplicationManifest(ApplicationManifestLoader&amp; loader)
1353 {
1354     // If the DocumentLoader has detached from its frame, all manifest loads should have already been canceled.
1355     ASSERT(m_frame);
1356 
1357     auto callbackIdentifier = m_applicationManifestLoaders.get(&amp;loader);
1358     notifyFinishedLoadingApplicationManifest(callbackIdentifier, loader.processManifest());
1359     m_applicationManifestLoaders.remove(&amp;loader);
1360 }
1361 
1362 void DocumentLoader::notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt; manifest)
1363 {
1364     RELEASE_ASSERT(callbackIdentifier);
1365     RELEASE_ASSERT(m_frame);
1366     m_frame-&gt;loader().client().finishedLoadingApplicationManifest(callbackIdentifier, manifest);
1367 }
1368 #endif
1369 





1370 bool DocumentLoader::isLoadingInAPISense() const
1371 {
1372     // Once a frame has loaded, we no longer need to consider subresources,
1373     // but we still need to consider subframes.
1374     if (frameLoader()-&gt;state() != FrameStateComplete) {
1375         if (m_frame-&gt;settings().needsIsLoadingInAPISenseQuirk() &amp;&amp; !m_subresourceLoaders.isEmpty())
1376             return true;
1377 
1378         ASSERT(m_frame-&gt;document());
1379         auto&amp; document = *m_frame-&gt;document();
1380         if ((isLoadingMainResource() || !document.loadEventFinished()) &amp;&amp; isLoading())
1381             return true;
1382         if (m_cachedResourceLoader-&gt;requestCount())
1383             return true;
1384         if (document.isDelayingLoadEvent())
1385             return true;
1386         if (document.processingLoadEvent())
1387             return true;
1388         if (document.hasActiveParser())
1389             return true;
</pre>
<hr />
<pre>
1410     m_parsedArchiveData = &amp;mainResource.data();
1411     m_writer.setMIMEType(mainResource.mimeType());
1412 
1413     ASSERT(m_frame-&gt;document());
1414     commitData(mainResource.data().data(), mainResource.data().size());
1415     return true;
1416 #endif
1417 }
1418 
1419 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1420 
1421 void DocumentLoader::setArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
1422 {
1423     m_archive = WTFMove(archive);
1424     addAllArchiveResources(*m_archive);
1425 }
1426 
1427 void DocumentLoader::addAllArchiveResources(Archive&amp; archive)
1428 {
1429     if (!m_archiveResourceCollection)
<span class="line-modified">1430         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();</span>
1431     m_archiveResourceCollection-&gt;addAllResources(archive);
1432 }
1433 
1434 // FIXME: Adding a resource directly to a DocumentLoader/ArchiveResourceCollection seems like bad design, but is API some apps rely on.
1435 // Can we change the design in a manner that will let us deprecate that API without reducing functionality of those apps?
1436 void DocumentLoader::addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp; resource)
1437 {
1438     if (!m_archiveResourceCollection)
<span class="line-modified">1439         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();</span>
1440     m_archiveResourceCollection-&gt;addResource(WTFMove(resource));
1441 }
1442 
1443 RefPtr&lt;Archive&gt; DocumentLoader::popArchiveForSubframe(const String&amp; frameName, const URL&amp; url)
1444 {
1445     return m_archiveResourceCollection ? m_archiveResourceCollection-&gt;popSubframeArchive(frameName, url) : nullptr;
1446 }
1447 
1448 void DocumentLoader::clearArchiveResources()
1449 {
1450     m_archiveResourceCollection = nullptr;
1451     m_substituteResourceDeliveryTimer.stop();
1452 }
1453 
1454 SharedBuffer* DocumentLoader::parsedArchiveData() const
1455 {
1456     return m_parsedArchiveData.get();
1457 }
1458 
1459 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
</pre>
<hr />
<pre>
1598 }
1599 
1600 void DocumentLoader::scheduleCannotShowURLError(ResourceLoader&amp; loader)
1601 {
1602     m_pendingSubstituteResources.set(&amp;loader, nullptr);
1603     deliverSubstituteResourcesAfterDelay();
1604 }
1605 
1606 void DocumentLoader::addResponse(const ResourceResponse&amp; response)
1607 {
1608     if (!m_stopRecordingResponses)
1609         m_responses.append(response);
1610 }
1611 
1612 void DocumentLoader::stopRecordingResponses()
1613 {
1614     m_stopRecordingResponses = true;
1615     m_responses.shrinkToFit();
1616 }
1617 
<span class="line-added">1618 void DocumentLoader::setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp; fields)</span>
<span class="line-added">1619 {</span>
<span class="line-added">1620     m_customHeaderFields = WTFMove(fields);</span>
<span class="line-added">1621 }</span>
<span class="line-added">1622 </span>
1623 void DocumentLoader::setTitle(const StringWithDirection&amp; title)
1624 {
1625     if (m_pageTitle == title)
1626         return;
1627 
1628     frameLoader()-&gt;willChangeTitle(this);
1629     m_pageTitle = title;
1630     frameLoader()-&gt;didChangeTitle(this);
1631 }
1632 
1633 URL DocumentLoader::urlForHistory() const
1634 {
1635     // Return the URL to be used for history and B/F list.
1636     // Returns nil for WebDataProtocol URLs that aren&#39;t alternates
1637     // for unreachable URLs, because these can&#39;t be stored in history.
1638     if (m_substituteData.isValid() &amp;&amp; !m_substituteData.shouldRevealToSessionHistory())
1639         return unreachableURL();
1640 
1641     return m_originalRequestCopy.url();
1642 }
</pre>
<hr />
<pre>
1701     ASSERT(m_subresourceLoaders.isEmpty());
1702 }
1703 
1704 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1705 {
1706     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1707     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1708     // let it be added. In the main resource load case, mainResourceLoader()
1709     // will still be null at this point, but m_gotFirstByte should be false here if and only
1710     // if we are just starting the main resource load.
1711     if (!m_gotFirstByte)
1712         return;
1713     ASSERT(loader-&gt;identifier());
1714     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1715     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1716 
1717     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1718     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1719         return;
1720 
<span class="line-modified">1721 #if !ASSERT_DISABLED</span>
<span class="line-modified">1722     if (document()) {</span>
<span class="line-added">1723         switch (document()-&gt;pageCacheState()) {</span>
<span class="line-added">1724         case Document::NotInPageCache:</span>
<span class="line-added">1725             break;</span>
<span class="line-added">1726         case Document::AboutToEnterPageCache: {</span>
<span class="line-added">1727             // A page about to enter PageCache should only be able to start ping loads.</span>
<span class="line-added">1728             auto* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());</span>
<span class="line-added">1729             ASSERT(cachedResource &amp;&amp; CachedResource::shouldUsePingLoad(cachedResource-&gt;type()));</span>
<span class="line-added">1730             break;</span>
<span class="line-added">1731         }</span>
<span class="line-added">1732         case Document::InPageCache:</span>
<span class="line-added">1733             // A page in the PageCache should not be able to start loads.</span>
<span class="line-added">1734             ASSERT_NOT_REACHED();</span>
<span class="line-added">1735             break;</span>
<span class="line-added">1736         }</span>
<span class="line-added">1737     }</span>
<span class="line-added">1738 #endif</span>
1739 
1740     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1741 }
1742 
1743 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1744 {
1745     ASSERT(loader-&gt;identifier());
1746 
1747     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1748         return;
1749     checkLoadComplete();
1750     if (Frame* frame = m_frame)
1751         frame-&gt;loader().subresourceLoadDone(type);
1752 }
1753 
1754 void DocumentLoader::addPlugInStreamLoader(ResourceLoader&amp; loader)
1755 {
1756     ASSERT(loader.identifier());
1757     ASSERT(!m_plugInStreamLoaders.contains(loader.identifier()));
1758 
</pre>
<hr />
<pre>
1859 #else
1860         if (tryLoadingRequestFromApplicationCache()) {
1861             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1862             return;
1863         }
1864         loadMainResource(WTFMove(request));
1865 #endif
1866     });
1867 }
1868 
1869 void DocumentLoader::registerTemporaryServiceWorkerClient(const URL&amp; url)
1870 {
1871 #if ENABLE(SERVICE_WORKER)
1872     ASSERT(!m_temporaryServiceWorkerClient);
1873 
1874     if (!m_serviceWorkerRegistrationData)
1875         return;
1876 
1877     m_temporaryServiceWorkerClient = TemporaryServiceWorkerClient {
1878         DocumentIdentifier::generate(),
<span class="line-modified">1879         m_frame-&gt;page()-&gt;sessionID()</span>
1880     };
1881 
<span class="line-added">1882     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);</span>
<span class="line-added">1883 </span>
1884     // FIXME: Compute ServiceWorkerClientFrameType appropriately.
<span class="line-modified">1885     ServiceWorkerClientData data { { serviceWorkerConnection.serverConnectionIdentifier(), m_temporaryServiceWorkerClient-&gt;documentIdentifier }, ServiceWorkerClientType::Window, ServiceWorkerClientFrameType::None, url };</span>
1886 
1887     RefPtr&lt;SecurityOrigin&gt; topOrigin;
1888     if (m_frame-&gt;isMainFrame())
1889         topOrigin = SecurityOrigin::create(url);
1890     else
1891         topOrigin = &amp;m_frame-&gt;mainFrame().document()-&gt;topOrigin();
<span class="line-modified">1892     serviceWorkerConnection.registerServiceWorkerClient(*topOrigin, WTFMove(data), m_serviceWorkerRegistrationData-&gt;identifier, m_frame-&gt;loader().userAgent(url));</span>
1893 #else
1894     UNUSED_PARAM(url);
1895 #endif
1896 }
1897 
1898 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1899 {
1900 #if ENABLE(SERVICE_WORKER)
1901     if (!m_temporaryServiceWorkerClient)
1902         return;
1903 
<span class="line-modified">1904     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);</span>
<span class="line-added">1905     serviceWorkerConnection.unregisterServiceWorkerClient(m_temporaryServiceWorkerClient-&gt;documentIdentifier);</span>
1906     m_temporaryServiceWorkerClient = WTF::nullopt;
1907 #endif
1908 }
1909 
1910 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1911 {
1912     static NeverDestroyed&lt;ResourceLoaderOptions&gt; mainResourceLoadOptions(
1913         SendCallbackPolicy::SendCallbacks,
1914         ContentSniffingPolicy::SniffContent,
1915         DataBufferingPolicy::BufferData,
1916         StoredCredentialsPolicy::Use,
1917         ClientCredentialPolicy::MayAskClientForCredentials,
1918         FetchOptions::Credentials::Include,
1919         SecurityCheckPolicy::SkipSecurityCheck,
1920         FetchOptions::Mode::Navigate,
1921         CertificateInfoPolicy::IncludeCertificateInfo,
1922         ContentSecurityPolicyImposition::SkipPolicyCheck,
1923         DefersLoadingPolicy::AllowDefersLoading,
1924         CachingPolicy::AllowCaching);
1925     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
</pre>
<hr />
<pre>
1946     if (!m_mainResource) {
1947         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1948         // This is because we may have fired the load event in a parent frame.
1949         if (!m_frame) {
1950             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1951             return;
1952         }
1953 
1954         if (!m_request.url().isValid()) {
1955             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1956             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1957             return;
1958         }
1959 
1960         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1961 
1962         setRequest(ResourceRequest());
1963         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
1964         // is now in a state where starting an empty load will be inconsistent. Replace it with
1965         // a new ApplicationCacheHost.
<span class="line-modified">1966         m_applicationCacheHost = makeUnique&lt;ApplicationCacheHost&gt;(*this);</span>
1967         maybeLoadEmpty();
1968         return;
1969     }
1970 
1971     ASSERT(m_frame);
1972 
1973 #if ENABLE(CONTENT_EXTENSIONS)
1974     if (m_mainResource-&gt;errorOccurred() &amp;&amp; m_frame-&gt;page() &amp;&amp; m_mainResource-&gt;resourceError().domain() == ContentExtensions::WebKitContentBlockerDomain) {
1975         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Blocked by content blocker error (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1976         cancelMainResourceLoad(frameLoader()-&gt;blockedByContentBlockerError(m_request));
1977         return;
1978     }
1979 #endif
1980 
1981     if (!mainResourceLoader()) {
1982         m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
1983         frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, mainResourceRequest.resourceRequest());
1984         frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, mainResourceRequest.resourceRequest(), ResourceResponse());
1985     }
1986 
</pre>
<hr />
<pre>
2105 
2106     m_frame-&gt;loader().client().getLoadDecisionForIcons(iconDecisions);
2107 }
2108 
2109 void DocumentLoader::didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID)
2110 {
2111     auto icon = m_iconsPendingLoadDecision.take(loadIdentifier);
2112 
2113     // If the decision was not to load or this DocumentLoader is already detached, there is no load to perform.
2114     if (!decision || !m_frame)
2115         return;
2116 
2117     // If the LinkIcon we just took is empty, then the DocumentLoader had all of its loaders stopped
2118     // while this icon load decision was pending.
2119     // In this case we need to notify the client that the icon finished loading with empty data.
2120     if (icon.url.isEmpty()) {
2121         notifyFinishedLoadingIcon(newCallbackID, nullptr);
2122         return;
2123     }
2124 
<span class="line-modified">2125     auto iconLoader = makeUnique&lt;IconLoader&gt;(*this, icon.url);</span>
2126     auto* rawIconLoader = iconLoader.get();
2127     m_iconLoaders.set(WTFMove(iconLoader), newCallbackID);
2128 
2129     rawIconLoader-&gt;startLoading();
2130 }
2131 
2132 void DocumentLoader::finishedLoadingIcon(IconLoader&amp; loader, SharedBuffer* buffer)
2133 {
2134     // If the DocumentLoader has detached from its frame, all icon loads should have already been cancelled.
2135     ASSERT(m_frame);
2136 
2137     auto callbackIdentifier = m_iconLoaders.take(&amp;loader);
2138     notifyFinishedLoadingIcon(callbackIdentifier, buffer);
2139 }
2140 
2141 void DocumentLoader::notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer* buffer)
2142 {
2143     RELEASE_ASSERT(callbackIdentifier);
2144     RELEASE_ASSERT(m_frame);
2145     m_frame-&gt;loader().client().finishedLoadingIcon(callbackIdentifier, buffer);
2146 }
2147 
2148 void DocumentLoader::dispatchOnloadEvents()
2149 {
2150     m_wasOnloadDispatched = true;
2151     m_applicationCacheHost-&gt;stopDeferringEvents();
2152 }
2153 
2154 void DocumentLoader::setTriggeringAction(NavigationAction&amp;&amp; action)
2155 {
2156     m_triggeringAction = WTFMove(action);
2157     m_triggeringAction.setShouldOpenExternalURLsPolicy(m_frame ? shouldOpenExternalURLsPolicyToPropagate() : m_shouldOpenExternalURLsPolicy);
2158 }
2159 
2160 ShouldOpenExternalURLsPolicy DocumentLoader::shouldOpenExternalURLsPolicyToPropagate() const
2161 {
<span class="line-modified">2162     if (!m_frame)</span>
2163         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2164 
<span class="line-modified">2165     if (m_frame-&gt;isMainFrame())</span>
<span class="line-added">2166         return m_shouldOpenExternalURLsPolicy;</span>
<span class="line-added">2167 </span>
<span class="line-added">2168     if (auto* currentDocument = document()) {</span>
<span class="line-added">2169         if (currentDocument-&gt;securityOrigin().isSameOriginAs(currentDocument-&gt;topOrigin()))</span>
<span class="line-added">2170             return m_shouldOpenExternalURLsPolicy;</span>
<span class="line-added">2171     }</span>
<span class="line-added">2172 </span>
<span class="line-added">2173     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;</span>
2174 }
2175 
2176 void DocumentLoader::becomeMainResourceClient()
2177 {
2178 #if ENABLE(CONTENT_FILTERING)
2179     if (m_contentFilter)
2180         m_contentFilter-&gt;startFilteringMainResource(*m_mainResource);
2181 #endif
2182     m_mainResource-&gt;addClient(*this);
2183 }
2184 
2185 #if ENABLE(CONTENT_EXTENSIONS)
2186 void DocumentLoader::addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp; sheet)
2187 {
2188     ASSERT(!m_gotFirstByte);
2189     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2190 }
2191 
2192 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2193 {
</pre>
</td>
</tr>
</table>
<center><a href="CrossOriginPreflightResultCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>