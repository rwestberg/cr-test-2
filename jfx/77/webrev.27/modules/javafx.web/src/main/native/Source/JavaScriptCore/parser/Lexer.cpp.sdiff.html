<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ASTBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2006-2017 Apple Inc. All Rights Reserved.</span>
   4  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   5  *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   6  *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Library General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Library General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Library General Public License
  19  *  along with this library; see the file COPYING.LIB.  If not, write to
  20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  *  Boston, MA 02110-1301, USA.
  22  *
  23  */
</pre>
<hr />
<pre>
  78     CharacterDot,
  79     CharacterSlash,
  80     CharacterBackSlash,
  81     CharacterSemicolon,
  82     CharacterOpenBrace,
  83     CharacterCloseBrace,
  84 
  85     CharacterAdd,
  86     CharacterSub,
  87     CharacterMultiply,
  88     CharacterModulo,
  89     CharacterAnd,
  90     CharacterXor,
  91     CharacterOr,
  92     CharacterLess,
  93     CharacterGreater,
  94     CharacterEqual,
  95 
  96     // Other types (only one so far)
  97     CharacterWhiteSpace,

  98     CharacterPrivateIdentifierStart
  99 };
 100 
 101 // 256 Latin-1 codes
 102 static constexpr const unsigned short typesOfLatin1Characters[256] = {
 103 /*   0 - Null               */ CharacterInvalid,
 104 /*   1 - Start of Heading   */ CharacterInvalid,
 105 /*   2 - Start of Text      */ CharacterInvalid,
 106 /*   3 - End of Text        */ CharacterInvalid,
 107 /*   4 - End of Transm.     */ CharacterInvalid,
 108 /*   5 - Enquiry            */ CharacterInvalid,
 109 /*   6 - Acknowledgment     */ CharacterInvalid,
 110 /*   7 - Bell               */ CharacterInvalid,
 111 /*   8 - Back Space         */ CharacterInvalid,
 112 /*   9 - Horizontal Tab     */ CharacterWhiteSpace,
 113 /*  10 - Line Feed          */ CharacterLineTerminator,
 114 /*  11 - Vertical Tab       */ CharacterWhiteSpace,
 115 /*  12 - Form Feed          */ CharacterWhiteSpace,
 116 /*  13 - Carriage Return    */ CharacterLineTerminator,
 117 /*  14 - Shift Out          */ CharacterInvalid,
 118 /*  15 - Shift In           */ CharacterInvalid,
 119 /*  16 - Data Line Escape   */ CharacterInvalid,
 120 /*  17 - Device Control 1   */ CharacterInvalid,
 121 /*  18 - Device Control 2   */ CharacterInvalid,
 122 /*  19 - Device Control 3   */ CharacterInvalid,
 123 /*  20 - Device Control 4   */ CharacterInvalid,
 124 /*  21 - Negative Ack.      */ CharacterInvalid,
 125 /*  22 - Synchronous Idle   */ CharacterInvalid,
 126 /*  23 - End of Transmit    */ CharacterInvalid,
 127 /*  24 - Cancel             */ CharacterInvalid,
 128 /*  25 - End of Medium      */ CharacterInvalid,
 129 /*  26 - Substitute         */ CharacterInvalid,
 130 /*  27 - Escape             */ CharacterInvalid,
 131 /*  28 - File Separator     */ CharacterInvalid,
 132 /*  29 - Group Separator    */ CharacterInvalid,
 133 /*  30 - Record Separator   */ CharacterInvalid,
 134 /*  31 - Unit Separator     */ CharacterInvalid,
 135 /*  32 - Space              */ CharacterWhiteSpace,
 136 /*  33 - !                  */ CharacterExclamationMark,
 137 /*  34 - &quot;                  */ CharacterQuote,
<span class="line-modified"> 138 /*  35 - #                  */ CharacterInvalid,</span>
 139 /*  36 - $                  */ CharacterIdentifierStart,
 140 /*  37 - %                  */ CharacterModulo,
 141 /*  38 - &amp;                  */ CharacterAnd,
 142 /*  39 - &#39;                  */ CharacterQuote,
 143 /*  40 - (                  */ CharacterOpenParen,
 144 /*  41 - )                  */ CharacterCloseParen,
 145 /*  42 - *                  */ CharacterMultiply,
 146 /*  43 - +                  */ CharacterAdd,
 147 /*  44 - ,                  */ CharacterComma,
 148 /*  45 - -                  */ CharacterSub,
 149 /*  46 - .                  */ CharacterDot,
 150 /*  47 - /                  */ CharacterSlash,
 151 /*  48 - 0                  */ CharacterZero,
 152 /*  49 - 1                  */ CharacterNumber,
 153 /*  50 - 2                  */ CharacterNumber,
 154 /*  51 - 3                  */ CharacterNumber,
 155 /*  52 - 4                  */ CharacterNumber,
 156 /*  53 - 5                  */ CharacterNumber,
 157 /*  54 - 6                  */ CharacterNumber,
 158 /*  55 - 7                  */ CharacterNumber,
</pre>
<hr />
<pre>
 475 /* 111 - o                  */ &#39;o&#39;,
 476 /* 112 - p                  */ &#39;p&#39;,
 477 /* 113 - q                  */ &#39;q&#39;,
 478 /* 114 - r                  */ 0x0D,
 479 /* 115 - s                  */ &#39;s&#39;,
 480 /* 116 - t                  */ 0x09,
 481 /* 117 - u                  */ 0,
 482 /* 118 - v                  */ 0x0B,
 483 /* 119 - w                  */ &#39;w&#39;,
 484 /* 120 - x                  */ 0,
 485 /* 121 - y                  */ &#39;y&#39;,
 486 /* 122 - z                  */ &#39;z&#39;,
 487 /* 123 - {                  */ &#39;{&#39;,
 488 /* 124 - |                  */ &#39;|&#39;,
 489 /* 125 - }                  */ &#39;}&#39;,
 490 /* 126 - ~                  */ &#39;~&#39;,
 491 /* 127 - Delete             */ 0
 492 };
 493 
 494 template &lt;typename T&gt;
<span class="line-modified"> 495 Lexer&lt;T&gt;::Lexer(VM* vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)</span>
 496     : m_isReparsingFunction(false)
 497     , m_vm(vm)
 498     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 499     , m_scriptMode(scriptMode)
 500 {
 501 }
 502 
 503 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 504 {
 505     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 506         return INTEGER;
 507     return DOUBLE;
 508 }
 509 
 510 template &lt;typename T&gt;
 511 Lexer&lt;T&gt;::~Lexer()
 512 {
 513 }
 514 
 515 template &lt;typename T&gt;
</pre>
<hr />
<pre>
 796         return false;
 797 
 798     auto character1 = code[2];
 799     auto character2 = code[3];
 800     auto character3 = code[4];
 801     auto character4 = code[5];
 802     return isASCIIHexDigit(character1) &amp;&amp; isASCIIHexDigit(character2) &amp;&amp; isASCIIHexDigit(character3) &amp;&amp; isASCIIHexDigit(character4)
 803         &amp;&amp; isIdentPart(Lexer&lt;LChar&gt;::convertUnicode(character1, character2, character3, character4));
 804 }
 805 
 806 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const LChar* code, const LChar* codeEnd)
 807 {
 808     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 809 }
 810 
 811 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
 812 {
 813     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 814 }
 815 
<span class="line-modified"> 816 static inline LChar singleEscape(int c)</span>

 817 {
<span class="line-modified"> 818     if (c &lt; 128) {</span>
<span class="line-removed"> 819         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));</span>
<span class="line-removed"> 820         return singleCharacterEscapeValuesForASCII[c];</span>
<span class="line-removed"> 821     }</span>
<span class="line-removed"> 822     return 0;</span>
 823 }
 824 
<span class="line-modified"> 825 template &lt;typename T&gt;</span>
<span class="line-modified"> 826 inline void Lexer&lt;T&gt;::record8(int c)</span>
 827 {
<span class="line-modified"> 828     ASSERT(c &gt;= 0);</span>
<span class="line-removed"> 829     ASSERT(c &lt;= 0xFF);</span>
<span class="line-removed"> 830     m_buffer8.append(static_cast&lt;LChar&gt;(c));</span>
 831 }
 832 
<span class="line-modified"> 833 template &lt;typename T&gt;</span>
<span class="line-modified"> 834 inline void assertCharIsIn8BitRange(T c)</span>
 835 {
<span class="line-modified"> 836     UNUSED_PARAM(c);</span>
<span class="line-removed"> 837     ASSERT(c &gt;= 0);</span>
<span class="line-removed"> 838     ASSERT(c &lt;= 0xFF);</span>
 839 }
 840 
<span class="line-modified"> 841 template &lt;&gt;</span>
<span class="line-modified"> 842 inline void assertCharIsIn8BitRange(UChar c)</span>
 843 {
<span class="line-modified"> 844     UNUSED_PARAM(c);</span>
<span class="line-removed"> 845     ASSERT(c &lt;= 0xFF);</span>
 846 }
 847 
<span class="line-modified"> 848 template &lt;&gt;</span>
<span class="line-modified"> 849 inline void assertCharIsIn8BitRange(LChar)</span>









 850 {


 851 }
 852 
 853 template &lt;typename T&gt;
 854 inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
 855 {
 856     size_t currentSize = m_buffer8.size();
 857     m_buffer8.grow(currentSize + length);
 858     LChar* rawBuffer = m_buffer8.data() + currentSize;
 859 
 860     for (size_t i = 0; i &lt; length; i++) {
 861         T c = p[i];
<span class="line-modified"> 862         assertCharIsIn8BitRange(c);</span>
 863         rawBuffer[i] = c;
 864     }
 865 }
 866 
 867 template &lt;typename T&gt;
 868 inline void Lexer&lt;T&gt;::append16(const LChar* p, size_t length)
 869 {
 870     size_t currentSize = m_buffer16.size();
 871     m_buffer16.grow(currentSize + length);
 872     UChar* rawBuffer = m_buffer16.data() + currentSize;
 873 
 874     for (size_t i = 0; i &lt; length; i++)
 875         rawBuffer[i] = p[i];
 876 }
 877 
 878 template &lt;typename T&gt;
 879 inline void Lexer&lt;T&gt;::record16(T c)
 880 {
 881     m_buffer16.append(c);
 882 }
</pre>
<hr />
<pre>
 939     if (isPrivateName)
 940         shift();
 941 
 942     const LChar* identifierStart = currentSourcePtr();
 943     unsigned identifierLineStart = currentLineStartOffset();
 944 
 945     while (isIdentPart(m_current))
 946         shift();
 947 
 948     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 949         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 950         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
 951     }
 952 
 953     const Identifier* ident = nullptr;
 954 
 955     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 956         int identifierLength = currentSourcePtr() - identifierStart;
 957         ident = makeIdentifier(identifierStart, identifierLength);
 958         if (m_parsingBuiltinFunction) {
<span class="line-modified"> 959             if (!isSafeBuiltinIdentifier(*m_vm, ident) &amp;&amp; !isPrivateName) {</span>
 960                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 961                 return ERRORTOK;
 962             }
 963             if (isPrivateName)
<span class="line-modified"> 964                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm-&gt;propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified"> 965             else if (*ident == m_vm-&gt;propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified"> 966                 tokenData-&gt;ident = &amp;m_vm-&gt;propertyNames-&gt;undefinedPrivateName;</span>
 967             if (!ident)
 968                 return INVALID_PRIVATE_NAME_ERRORTOK;
 969         }
 970         tokenData-&gt;ident = ident;
 971     } else
 972         tokenData-&gt;ident = nullptr;
 973 
 974     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
 975         ASSERT(shouldCreateIdentifier);
 976         if (remaining &lt; maxTokenLength) {
 977             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 978             ASSERT((remaining &lt; maxTokenLength) || !entry);
 979             if (!entry)
 980                 return IDENT;
 981             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 982             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 983         }
 984         return IDENT;
 985     }
 986 
</pre>
<hr />
<pre>
1017     if (UNLIKELY(m_current == &#39;\\&#39;)) {
1018         ASSERT(!isPrivateName);
1019         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
1020         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
1021     }
1022 
1023     bool isAll8Bit = false;
1024 
1025     if (!(orAllChars &amp; ~0xff))
1026         isAll8Bit = true;
1027 
1028     const Identifier* ident = nullptr;
1029 
1030     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
1031         int identifierLength = currentSourcePtr() - identifierStart;
1032         if (isAll8Bit)
1033             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1034         else
1035             ident = makeIdentifier(identifierStart, identifierLength);
1036         if (m_parsingBuiltinFunction) {
<span class="line-modified">1037             if (!isSafeBuiltinIdentifier(*m_vm, ident) &amp;&amp; !isPrivateName) {</span>
1038                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1039                 return ERRORTOK;
1040             }
1041             if (isPrivateName)
<span class="line-modified">1042                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm-&gt;propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">1043             else if (*ident == m_vm-&gt;propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">1044                 tokenData-&gt;ident = &amp;m_vm-&gt;propertyNames-&gt;undefinedPrivateName;</span>
1045             if (!ident)
1046                 return INVALID_PRIVATE_NAME_ERRORTOK;
1047         }
1048         tokenData-&gt;ident = ident;
1049     } else
1050         tokenData-&gt;ident = nullptr;
1051 
1052     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
1053         ASSERT(shouldCreateIdentifier);
1054         if (remaining &lt; maxTokenLength) {
1055             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1056             ASSERT((remaining &lt; maxTokenLength) || !entry);
1057             if (!entry)
1058                 return IDENT;
1059             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1060             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1061         }
1062         return IDENT;
1063     }
1064 
</pre>
<hr />
<pre>
1118     if (LIKELY(!(lexerFlags &amp; LexerFlagsIgnoreReservedWords))) {
1119         ASSERT(shouldCreateIdentifier);
1120         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1121         if (!entry)
1122             return IDENT;
1123         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1124         if ((token != RESERVED_IF_STRICT) || strictMode)
1125             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1126     }
1127 
1128     return IDENT;
1129 }
1130 
1131 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1132 {
1133     return character &lt; 0xE;
1134 }
1135 
1136 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1137 {
<span class="line-modified">1138     return character &lt; 0xE || character &gt; 0xFF;</span>
1139 }
1140 
1141 template &lt;typename T&gt;
1142 template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
1143 {
1144     int startingOffset = currentOffset();
1145     int startingLineStartOffset = currentLineStartOffset();
1146     int startingLineNumber = lineNumber();
1147     T stringQuoteCharacter = m_current;
1148     shift();
1149 
1150     const T* stringStart = currentSourcePtr();
1151 
1152     while (m_current != stringQuoteCharacter) {
1153         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1154             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1155                 append8(stringStart, currentSourcePtr() - stringStart);
1156             shift();
1157 
1158             LChar escape = singleEscape(m_current);
</pre>
<hr />
<pre>
1473         tokenData-&gt;raw = nullptr;
1474 
1475     tokenData-&gt;isTail = isTail;
1476 
1477     m_buffer16.shrink(0);
1478     m_bufferForRawTemplateString16.shrink(0);
1479 
1480     if (isTail) {
1481         // Skip `
1482         shift();
1483     } else {
1484         // Skip $ and {
1485         shift();
1486         shift();
1487     }
1488 
1489     return StringParsedSuccessfully;
1490 }
1491 
1492 template &lt;typename T&gt;
<span class="line-modified">1493 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; NumberParseResult</span>
1494 {


1495     // Optimization: most hexadecimal values fit into 4 bytes.
1496     uint32_t hexValue = 0;
1497     int maximumDigits = 7;
1498 
1499     do {







1500         hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
1501         shift();
1502         --maximumDigits;
<span class="line-modified">1503     } while (isASCIIHexDigit(m_current) &amp;&amp; maximumDigits &gt;= 0);</span>
1504 
1505     if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
<span class="line-modified">1506         return hexValue;</span>
1507 
1508     // No more place in the hexValue buffer.
1509     // The values are shifted out and placed into the m_buffer8 vector.
1510     for (int i = 0; i &lt; 8; ++i) {
1511          int digit = hexValue &gt;&gt; 28;
1512          if (digit &lt; 10)
1513              record8(digit + &#39;0&#39;);
1514          else
1515              record8(digit - 10 + &#39;a&#39;);
1516          hexValue &lt;&lt;= 4;
1517     }
1518 
<span class="line-modified">1519     while (isASCIIHexDigit(m_current)) {</span>







1520         record8(m_current);
1521         shift();
1522     }
1523 
1524     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">1525         return makeIdentifier(m_buffer8.data(), m_buffer8.size());</span>
1526 
<span class="line-modified">1527     return parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16);</span>
1528 }
1529 
1530 template &lt;typename T&gt;
1531 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
1532 {


1533     // Optimization: most binary values fit into 4 bytes.
1534     uint32_t binaryValue = 0;
1535     const unsigned maximumDigits = 32;
1536     int digit = maximumDigits - 1;
1537     // Temporary buffer for the digits. Makes easier
1538     // to reconstruct the input characters when needed.
1539     LChar digits[maximumDigits];
1540 
1541     do {







1542         binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
1543         digits[digit] = m_current;
1544         shift();
1545         --digit;
<span class="line-modified">1546     } while (isASCIIBinaryDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
1547 
<span class="line-modified">1548     if (LIKELY(!isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-modified">1549         return Variant&lt;double, const Identifier*&gt; { binaryValue };</span>
1550 
1551     for (int i = maximumDigits - 1; i &gt; digit; --i)
1552         record8(digits[i]);
1553 
<span class="line-modified">1554     while (isASCIIBinaryDigit(m_current)) {</span>







1555         record8(m_current);
1556         shift();
1557     }
1558 
1559     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">1560         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1561 
1562     if (isASCIIDigit(m_current))
1563         return WTF::nullopt;
1564 
<span class="line-modified">1565     return Variant&lt;double, const Identifier*&gt; { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };</span>
1566 }
1567 
1568 template &lt;typename T&gt;
1569 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
1570 {




1571     // Optimization: most octal values fit into 4 bytes.
1572     uint32_t octalValue = 0;
1573     const unsigned maximumDigits = 10;
1574     int digit = maximumDigits - 1;
1575     // Temporary buffer for the digits. Makes easier
1576     // to reconstruct the input characters when needed.
1577     LChar digits[maximumDigits];
1578 
1579     do {







1580         octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
1581         digits[digit] = m_current;
1582         shift();
1583         --digit;
<span class="line-modified">1584     } while (isASCIIOctalDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
<span class="line-removed">1585 </span>
<span class="line-removed">1586     if (LIKELY(!isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-removed">1587         return Variant&lt;double, const Identifier*&gt; { octalValue };</span>
1588 


1589 
1590     for (int i = maximumDigits - 1; i &gt; digit; --i)
1591          record8(digits[i]);
1592 
<span class="line-modified">1593     while (isASCIIOctalDigit(m_current)) {</span>







1594         record8(m_current);
1595         shift();
1596     }
1597 
<span class="line-modified">1598     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))</span>
<span class="line-modified">1599         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1600 
1601     if (isASCIIDigit(m_current))
1602         return WTF::nullopt;
1603 
<span class="line-modified">1604     return Variant&lt;double, const Identifier*&gt; { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };</span>
1605 }
1606 
1607 template &lt;typename T&gt;
1608 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
1609 {



1610     // Optimization: most decimal values fit into 4 bytes.
1611     uint32_t decimalValue = 0;
1612 
1613     // Since parseOctal may be executed before parseDecimal,
1614     // the m_buffer8 may hold ascii digits.
1615     if (!m_buffer8.size()) {
1616         const unsigned maximumDigits = 10;
1617         int digit = maximumDigits - 1;
1618         // Temporary buffer for the digits. Makes easier
1619         // to reconstruct the input characters when needed.
1620         LChar digits[maximumDigits];
1621 
1622         do {







1623             decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
1624             digits[digit] = m_current;
1625             shift();
1626             --digit;
<span class="line-modified">1627         } while (isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
1628 
1629         if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
<span class="line-modified">1630             return Variant&lt;double, const Identifier*&gt; { decimalValue };</span>
1631 
1632         for (int i = maximumDigits - 1; i &gt; digit; --i)
1633             record8(digits[i]);
1634     }
1635 
<span class="line-modified">1636     while (isASCIIDigit(m_current)) {</span>







1637         record8(m_current);
1638         shift();
1639     }
1640 
<span class="line-modified">1641     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))</span>
<span class="line-modified">1642         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1643 
1644     return WTF::nullopt;
1645 }
1646 
1647 template &lt;typename T&gt;
<span class="line-modified">1648 ALWAYS_INLINE void Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()</span>
1649 {

1650     record8(&#39;.&#39;);
<span class="line-modified">1651     while (isASCIIDigit(m_current)) {</span>








1652         record8(m_current);
1653         shift();
<span class="line-modified">1654     }</span>


1655 }
1656 
1657 template &lt;typename T&gt;
1658 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
1659 {
1660     record8(&#39;e&#39;);
1661     shift();
1662     if (m_current == &#39;+&#39; || m_current == &#39;-&#39;) {
1663         record8(m_current);
1664         shift();
1665     }
1666 
1667     if (!isASCIIDigit(m_current))
1668         return false;
1669 
1670     do {







1671         record8(m_current);
1672         shift();
<span class="line-modified">1673     } while (isASCIIDigit(m_current));</span>

1674     return true;
1675 }
1676 
1677 template &lt;typename T&gt;
1678 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
1679 {
1680     while (true) {
1681         while (UNLIKELY(m_current == &#39;*&#39;)) {
1682             shift();
1683             if (m_current == &#39;/&#39;) {
1684                 shift();
1685                 return true;
1686             }
1687         }
1688 
1689         if (atEnd())
1690             return false;
1691 
1692         if (isLineTerminator(m_current)) {
1693             shiftLineTerminator();
</pre>
<hr />
<pre>
2030         token = CLOSEPAREN;
2031         shift();
2032         break;
2033     case CharacterOpenBracket:
2034         token = OPENBRACKET;
2035         shift();
2036         break;
2037     case CharacterCloseBracket:
2038         token = CLOSEBRACKET;
2039         shift();
2040         break;
2041     case CharacterComma:
2042         token = COMMA;
2043         shift();
2044         break;
2045     case CharacterColon:
2046         token = COLON;
2047         shift();
2048         break;
2049     case CharacterQuestion:
<span class="line-removed">2050         token = QUESTION;</span>
2051         shift();













2052         break;
2053     case CharacterTilde:
2054         token = TILDE;
2055         shift();
2056         break;
2057     case CharacterSemicolon:
2058         shift();
2059         token = SEMICOLON;
2060         break;
2061     case CharacterBackQuote:
2062         shift();
2063         token = BACKQUOTE;
2064         break;
2065     case CharacterOpenBrace:
2066         tokenData-&gt;line = lineNumber();
2067         tokenData-&gt;offset = currentOffset();
2068         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2069         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2070         shift();
2071         token = OPENBRACE;
</pre>
<hr />
<pre>
2073     case CharacterCloseBrace:
2074         tokenData-&gt;line = lineNumber();
2075         tokenData-&gt;offset = currentOffset();
2076         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2077         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2078         shift();
2079         token = CLOSEBRACE;
2080         break;
2081     case CharacterDot:
2082         shift();
2083         if (!isASCIIDigit(m_current)) {
2084             if (UNLIKELY((m_current == &#39;.&#39;) &amp;&amp; (peek(1) == &#39;.&#39;))) {
2085                 shift();
2086                 shift();
2087                 token = DOTDOTDOT;
2088                 break;
2089             }
2090             token = DOT;
2091             break;
2092         }
<span class="line-modified">2093         parseNumberAfterDecimalPoint();</span>




2094         token = DOUBLE;
<span class="line-modified">2095         if (isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;)) {</span>
<span class="line-modified">2096             if (!parseNumberAfterExponentIndicator()) {</span>
<span class="line-modified">2097                 m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-modified">2098                 token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-removed">2099                 goto returnError;</span>
<span class="line-removed">2100             }</span>
2101         }
2102         size_t parsedLength;
2103         tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2104         if (token == INTEGER)
2105             token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2106 
2107         if (UNLIKELY(isIdentStart(m_current))) {
2108             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2109             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2110             goto returnError;
2111         }
2112         m_buffer8.shrink(0);
2113         break;
2114     case CharacterZero:
2115         shift();
2116         if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
<span class="line-modified">2117             if (!isASCIIHexDigit(peek(1))) {</span>
2118                 m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
2119                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2120                 goto returnError;
2121             }
2122 
2123             // Shift out the &#39;x&#39; prefix.
2124             shift();
2125 
2126             auto parseNumberResult = parseHex();
<span class="line-modified">2127             if (WTF::holds_alternative&lt;double&gt;(parseNumberResult))</span>
<span class="line-modified">2128                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(parseNumberResult);</span>


2129             else {
2130                 token = BIGINT;
2131                 shift();
<span class="line-modified">2132                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(parseNumberResult);</span>
2133                 tokenData-&gt;radix = 16;
2134             }
2135 
<span class="line-modified">2136             if (isIdentStart(m_current)) {</span>
2137                 m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
2138                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2139                 goto returnError;
2140             }
2141             if (LIKELY(token != BIGINT))
2142                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2143             m_buffer8.shrink(0);
2144             break;
2145         }
2146         if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
<span class="line-modified">2147             if (!isASCIIBinaryDigit(peek(1))) {</span>
2148                 m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
2149                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2150                 goto returnError;
2151             }
2152 
2153             // Shift out the &#39;b&#39; prefix.
2154             shift();
2155 
2156             auto parseNumberResult = parseBinary();
2157             if (!parseNumberResult)
2158                 tokenData-&gt;doubleValue = 0;
2159             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2160                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2161             else {
2162                 token = BIGINT;
2163                 shift();
2164                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2165                 tokenData-&gt;radix = 2;
2166             }
2167 
<span class="line-modified">2168             if (isIdentStart(m_current)) {</span>
2169                 m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
2170                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2171                 goto returnError;
2172             }
2173             if (LIKELY(token != BIGINT))
2174                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2175             m_buffer8.shrink(0);
2176             break;
2177         }
2178 
2179         if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
<span class="line-modified">2180             if (!isASCIIOctalDigit(peek(1))) {</span>
2181                 m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
2182                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2183                 goto returnError;
2184             }
2185 
2186             // Shift out the &#39;o&#39; prefix.
2187             shift();
2188 
2189             auto parseNumberResult = parseOctal();
2190             if (!parseNumberResult)
2191                 tokenData-&gt;doubleValue = 0;
2192             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2193                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2194             else {
2195                 token = BIGINT;
2196                 shift();
2197                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2198                 tokenData-&gt;radix = 8;
2199             }
2200 
<span class="line-modified">2201             if (isIdentStart(m_current)) {</span>
2202                 m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
2203                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2204                 goto returnError;
2205             }
2206             if (LIKELY(token != BIGINT))
2207                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2208             m_buffer8.shrink(0);
2209             break;
2210         }
2211 






2212         record8(&#39;0&#39;);
<span class="line-modified">2213         if (strictMode &amp;&amp; isASCIIDigit(m_current)) {</span>
2214             m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
2215             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2216             goto returnError;
2217         }
2218         if (isASCIIOctalDigit(m_current)) {
2219             auto parseNumberResult = parseOctal();
2220             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {
2221                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2222                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2223             }
2224         }
2225         FALLTHROUGH;
2226     case CharacterNumber:
2227         if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
2228             auto parseNumberResult = parseDecimal();
<span class="line-modified">2229             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {</span>
<span class="line-modified">2230                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
<span class="line-modified">2231                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
<span class="line-modified">2232             } else {</span>
<span class="line-modified">2233                 if (parseNumberResult) {</span>
<span class="line-removed">2234                     ASSERT(WTF::get&lt;const Identifier*&gt;(*parseNumberResult));</span>
2235                     token = BIGINT;
2236                     shift();
2237                     tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2238                     tokenData-&gt;radix = 10;
<span class="line-modified">2239                 } else {</span>
<span class="line-modified">2240                     token = INTEGER;</span>
<span class="line-modified">2241                     if (m_current == &#39;.&#39;) {</span>
<span class="line-modified">2242                         shift();</span>
<span class="line-modified">2243                         parseNumberAfterDecimalPoint();</span>
<span class="line-modified">2244                         token = DOUBLE;</span>
<span class="line-modified">2245                     }</span>
<span class="line-modified">2246                     if (isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;)) {</span>
<span class="line-modified">2247                         if (!parseNumberAfterExponentIndicator()) {</span>
<span class="line-removed">2248                             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-removed">2249                             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-removed">2250                             goto returnError;</span>
<span class="line-removed">2251                         }</span>
2252                     }
<span class="line-modified">2253                     size_t parsedLength;</span>
<span class="line-modified">2254                     tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);</span>
<span class="line-modified">2255                     if (token == INTEGER)</span>
<span class="line-modified">2256                         token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>


2257                 }




2258             }
2259         }
2260 
2261         if (UNLIKELY(isIdentStart(m_current))) {
2262             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2263             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2264             goto returnError;
2265         }
2266         m_buffer8.shrink(0);
2267         break;
2268     case CharacterQuote: {
2269         StringParseResult result = StringCannotBeParsed;
2270         if (lexerFlags &amp; LexerFlagsDontBuildStrings)
2271             result = parseString&lt;false&gt;(tokenData, strictMode);
2272         else
2273             result = parseString&lt;true&gt;(tokenData, strictMode);
2274 
2275         if (UNLIKELY(result != StringParsedSuccessfully)) {
2276             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2277             goto returnError;
</pre>
<hr />
<pre>
2280         token = STRING;
2281         break;
2282         }
2283     case CharacterIdentifierStart:
2284         ASSERT(isIdentStart(m_current));
2285         FALLTHROUGH;
2286     case CharacterBackSlash:
2287         parseIdent:
2288         if (lexerFlags &amp; LexexFlagsDontBuildKeywords)
2289             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2290         else
2291             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2292         break;
2293     case CharacterLineTerminator:
2294         ASSERT(isLineTerminator(m_current));
2295         shiftLineTerminator();
2296         m_atLineStart = true;
2297         m_hasLineTerminatorBeforeToken = true;
2298         m_lineStart = m_code;
2299         goto start;








2300     case CharacterPrivateIdentifierStart:
2301         if (m_parsingBuiltinFunction)
2302             goto parseIdent;
<span class="line-modified">2303 </span>
<span class="line-removed">2304         FALLTHROUGH;</span>
2305     case CharacterOtherIdentifierPart:
2306     case CharacterInvalid:
<span class="line-modified">2307         m_lexErrorMessage = invalidCharacterMessage();</span>
<span class="line-removed">2308         token = ERRORTOK;</span>
<span class="line-removed">2309         goto returnError;</span>
2310     default:
2311         RELEASE_ASSERT_NOT_REACHED();
2312         m_lexErrorMessage = &quot;Internal Error&quot;_s;
2313         token = ERRORTOK;
2314         goto returnError;
2315     }
2316 
2317     m_atLineStart = false;
2318     goto returnToken;
2319 
2320 inSingleLineCommentCheckForDirectives:
2321     // Script comment directives like &quot;//# sourceURL=test.js&quot;.
2322     if (UNLIKELY((m_current == &#39;#&#39; || m_current == &#39;@&#39;) &amp;&amp; isWhiteSpace(peek(1)))) {
2323         shift();
2324         shift();
2325         parseCommentDirective();
2326     }
2327     // Fall through to complete single line comment parsing.
2328 
2329 inSingleLineComment:
</pre>
<hr />
<pre>
2340                 return token;
2341             }
2342             shift();
2343         }
2344         shiftLineTerminator();
2345         m_atLineStart = true;
2346         m_hasLineTerminatorBeforeToken = true;
2347         m_lineStart = m_code;
2348         if (!lastTokenWasRestrKeyword())
2349             goto start;
2350 
2351         token = SEMICOLON;
2352         fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2353         return token;
2354     }
2355 
2356 returnToken:
2357     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2358     return token;
2359 





2360 returnError:
2361     m_error = true;
2362     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2363     RELEASE_ASSERT(token &amp; ErrorTokenFlag);
2364     return token;
2365 }
2366 
2367 template &lt;typename T&gt;
2368 static inline void orCharacter(UChar&amp;, UChar);
2369 
2370 template &lt;&gt;
2371 inline void orCharacter&lt;LChar&gt;(UChar&amp;, UChar) { }
2372 
2373 template &lt;&gt;
2374 inline void orCharacter&lt;UChar&gt;(UChar&amp; orAccumulator, UChar character)
2375 {
2376     orAccumulator |= character;
2377 }
2378 
2379 template &lt;typename T&gt;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2006-2019 Apple Inc. All Rights Reserved.</span>
   4  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   5  *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   6  *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Library General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Library General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Library General Public License
  19  *  along with this library; see the file COPYING.LIB.  If not, write to
  20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  *  Boston, MA 02110-1301, USA.
  22  *
  23  */
</pre>
<hr />
<pre>
  78     CharacterDot,
  79     CharacterSlash,
  80     CharacterBackSlash,
  81     CharacterSemicolon,
  82     CharacterOpenBrace,
  83     CharacterCloseBrace,
  84 
  85     CharacterAdd,
  86     CharacterSub,
  87     CharacterMultiply,
  88     CharacterModulo,
  89     CharacterAnd,
  90     CharacterXor,
  91     CharacterOr,
  92     CharacterLess,
  93     CharacterGreater,
  94     CharacterEqual,
  95 
  96     // Other types (only one so far)
  97     CharacterWhiteSpace,
<span class="line-added">  98     CharacterHash,</span>
  99     CharacterPrivateIdentifierStart
 100 };
 101 
 102 // 256 Latin-1 codes
 103 static constexpr const unsigned short typesOfLatin1Characters[256] = {
 104 /*   0 - Null               */ CharacterInvalid,
 105 /*   1 - Start of Heading   */ CharacterInvalid,
 106 /*   2 - Start of Text      */ CharacterInvalid,
 107 /*   3 - End of Text        */ CharacterInvalid,
 108 /*   4 - End of Transm.     */ CharacterInvalid,
 109 /*   5 - Enquiry            */ CharacterInvalid,
 110 /*   6 - Acknowledgment     */ CharacterInvalid,
 111 /*   7 - Bell               */ CharacterInvalid,
 112 /*   8 - Back Space         */ CharacterInvalid,
 113 /*   9 - Horizontal Tab     */ CharacterWhiteSpace,
 114 /*  10 - Line Feed          */ CharacterLineTerminator,
 115 /*  11 - Vertical Tab       */ CharacterWhiteSpace,
 116 /*  12 - Form Feed          */ CharacterWhiteSpace,
 117 /*  13 - Carriage Return    */ CharacterLineTerminator,
 118 /*  14 - Shift Out          */ CharacterInvalid,
 119 /*  15 - Shift In           */ CharacterInvalid,
 120 /*  16 - Data Line Escape   */ CharacterInvalid,
 121 /*  17 - Device Control 1   */ CharacterInvalid,
 122 /*  18 - Device Control 2   */ CharacterInvalid,
 123 /*  19 - Device Control 3   */ CharacterInvalid,
 124 /*  20 - Device Control 4   */ CharacterInvalid,
 125 /*  21 - Negative Ack.      */ CharacterInvalid,
 126 /*  22 - Synchronous Idle   */ CharacterInvalid,
 127 /*  23 - End of Transmit    */ CharacterInvalid,
 128 /*  24 - Cancel             */ CharacterInvalid,
 129 /*  25 - End of Medium      */ CharacterInvalid,
 130 /*  26 - Substitute         */ CharacterInvalid,
 131 /*  27 - Escape             */ CharacterInvalid,
 132 /*  28 - File Separator     */ CharacterInvalid,
 133 /*  29 - Group Separator    */ CharacterInvalid,
 134 /*  30 - Record Separator   */ CharacterInvalid,
 135 /*  31 - Unit Separator     */ CharacterInvalid,
 136 /*  32 - Space              */ CharacterWhiteSpace,
 137 /*  33 - !                  */ CharacterExclamationMark,
 138 /*  34 - &quot;                  */ CharacterQuote,
<span class="line-modified"> 139 /*  35 - #                  */ CharacterHash,</span>
 140 /*  36 - $                  */ CharacterIdentifierStart,
 141 /*  37 - %                  */ CharacterModulo,
 142 /*  38 - &amp;                  */ CharacterAnd,
 143 /*  39 - &#39;                  */ CharacterQuote,
 144 /*  40 - (                  */ CharacterOpenParen,
 145 /*  41 - )                  */ CharacterCloseParen,
 146 /*  42 - *                  */ CharacterMultiply,
 147 /*  43 - +                  */ CharacterAdd,
 148 /*  44 - ,                  */ CharacterComma,
 149 /*  45 - -                  */ CharacterSub,
 150 /*  46 - .                  */ CharacterDot,
 151 /*  47 - /                  */ CharacterSlash,
 152 /*  48 - 0                  */ CharacterZero,
 153 /*  49 - 1                  */ CharacterNumber,
 154 /*  50 - 2                  */ CharacterNumber,
 155 /*  51 - 3                  */ CharacterNumber,
 156 /*  52 - 4                  */ CharacterNumber,
 157 /*  53 - 5                  */ CharacterNumber,
 158 /*  54 - 6                  */ CharacterNumber,
 159 /*  55 - 7                  */ CharacterNumber,
</pre>
<hr />
<pre>
 476 /* 111 - o                  */ &#39;o&#39;,
 477 /* 112 - p                  */ &#39;p&#39;,
 478 /* 113 - q                  */ &#39;q&#39;,
 479 /* 114 - r                  */ 0x0D,
 480 /* 115 - s                  */ &#39;s&#39;,
 481 /* 116 - t                  */ 0x09,
 482 /* 117 - u                  */ 0,
 483 /* 118 - v                  */ 0x0B,
 484 /* 119 - w                  */ &#39;w&#39;,
 485 /* 120 - x                  */ 0,
 486 /* 121 - y                  */ &#39;y&#39;,
 487 /* 122 - z                  */ &#39;z&#39;,
 488 /* 123 - {                  */ &#39;{&#39;,
 489 /* 124 - |                  */ &#39;|&#39;,
 490 /* 125 - }                  */ &#39;}&#39;,
 491 /* 126 - ~                  */ &#39;~&#39;,
 492 /* 127 - Delete             */ 0
 493 };
 494 
 495 template &lt;typename T&gt;
<span class="line-modified"> 496 Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)</span>
 497     : m_isReparsingFunction(false)
 498     , m_vm(vm)
 499     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 500     , m_scriptMode(scriptMode)
 501 {
 502 }
 503 
 504 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 505 {
 506     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 507         return INTEGER;
 508     return DOUBLE;
 509 }
 510 
 511 template &lt;typename T&gt;
 512 Lexer&lt;T&gt;::~Lexer()
 513 {
 514 }
 515 
 516 template &lt;typename T&gt;
</pre>
<hr />
<pre>
 797         return false;
 798 
 799     auto character1 = code[2];
 800     auto character2 = code[3];
 801     auto character3 = code[4];
 802     auto character4 = code[5];
 803     return isASCIIHexDigit(character1) &amp;&amp; isASCIIHexDigit(character2) &amp;&amp; isASCIIHexDigit(character3) &amp;&amp; isASCIIHexDigit(character4)
 804         &amp;&amp; isIdentPart(Lexer&lt;LChar&gt;::convertUnicode(character1, character2, character3, character4));
 805 }
 806 
 807 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const LChar* code, const LChar* codeEnd)
 808 {
 809     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 810 }
 811 
 812 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
 813 {
 814     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 815 }
 816 
<span class="line-modified"> 817 template&lt;typename CharacterType&gt;</span>
<span class="line-added"> 818 static inline bool isASCIIDigitOrSeparator(CharacterType character)</span>
 819 {
<span class="line-modified"> 820     return isASCIIDigit(character) || character == &#39;_&#39;;</span>




 821 }
 822 
<span class="line-modified"> 823 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 824 static inline bool isASCIIHexDigitOrSeparator(CharacterType character)</span>
 825 {
<span class="line-modified"> 826     return isASCIIHexDigit(character) || character == &#39;_&#39;;</span>


 827 }
 828 
<span class="line-modified"> 829 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 830 static inline bool isASCIIBinaryDigitOrSeparator(CharacterType character)</span>
 831 {
<span class="line-modified"> 832     return isASCIIBinaryDigit(character) || character == &#39;_&#39;;</span>


 833 }
 834 
<span class="line-modified"> 835 template&lt;typename CharacterType&gt;</span>
<span class="line-modified"> 836 static inline bool isASCIIOctalDigitOrSeparator(CharacterType character)</span>
 837 {
<span class="line-modified"> 838     return isASCIIOctalDigit(character) || character == &#39;_&#39;;</span>

 839 }
 840 
<span class="line-modified"> 841 static inline LChar singleEscape(int c)</span>
<span class="line-modified"> 842 {</span>
<span class="line-added"> 843     if (c &lt; 128) {</span>
<span class="line-added"> 844         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));</span>
<span class="line-added"> 845         return singleCharacterEscapeValuesForASCII[c];</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847     return 0;</span>
<span class="line-added"> 848 }</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850 template &lt;typename T&gt;</span>
<span class="line-added"> 851 inline void Lexer&lt;T&gt;::record8(int c)</span>
 852 {
<span class="line-added"> 853     ASSERT(isLatin1(c));</span>
<span class="line-added"> 854     m_buffer8.append(static_cast&lt;LChar&gt;(c));</span>
 855 }
 856 
 857 template &lt;typename T&gt;
 858 inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
 859 {
 860     size_t currentSize = m_buffer8.size();
 861     m_buffer8.grow(currentSize + length);
 862     LChar* rawBuffer = m_buffer8.data() + currentSize;
 863 
 864     for (size_t i = 0; i &lt; length; i++) {
 865         T c = p[i];
<span class="line-modified"> 866         ASSERT(isLatin1(c));</span>
 867         rawBuffer[i] = c;
 868     }
 869 }
 870 
 871 template &lt;typename T&gt;
 872 inline void Lexer&lt;T&gt;::append16(const LChar* p, size_t length)
 873 {
 874     size_t currentSize = m_buffer16.size();
 875     m_buffer16.grow(currentSize + length);
 876     UChar* rawBuffer = m_buffer16.data() + currentSize;
 877 
 878     for (size_t i = 0; i &lt; length; i++)
 879         rawBuffer[i] = p[i];
 880 }
 881 
 882 template &lt;typename T&gt;
 883 inline void Lexer&lt;T&gt;::record16(T c)
 884 {
 885     m_buffer16.append(c);
 886 }
</pre>
<hr />
<pre>
 943     if (isPrivateName)
 944         shift();
 945 
 946     const LChar* identifierStart = currentSourcePtr();
 947     unsigned identifierLineStart = currentLineStartOffset();
 948 
 949     while (isIdentPart(m_current))
 950         shift();
 951 
 952     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 953         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 954         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
 955     }
 956 
 957     const Identifier* ident = nullptr;
 958 
 959     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 960         int identifierLength = currentSourcePtr() - identifierStart;
 961         ident = makeIdentifier(identifierStart, identifierLength);
 962         if (m_parsingBuiltinFunction) {
<span class="line-modified"> 963             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
 964                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 965                 return ERRORTOK;
 966             }
 967             if (isPrivateName)
<span class="line-modified"> 968                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified"> 969             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified"> 970                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
 971             if (!ident)
 972                 return INVALID_PRIVATE_NAME_ERRORTOK;
 973         }
 974         tokenData-&gt;ident = ident;
 975     } else
 976         tokenData-&gt;ident = nullptr;
 977 
 978     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
 979         ASSERT(shouldCreateIdentifier);
 980         if (remaining &lt; maxTokenLength) {
 981             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 982             ASSERT((remaining &lt; maxTokenLength) || !entry);
 983             if (!entry)
 984                 return IDENT;
 985             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 986             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 987         }
 988         return IDENT;
 989     }
 990 
</pre>
<hr />
<pre>
1021     if (UNLIKELY(m_current == &#39;\\&#39;)) {
1022         ASSERT(!isPrivateName);
1023         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
1024         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
1025     }
1026 
1027     bool isAll8Bit = false;
1028 
1029     if (!(orAllChars &amp; ~0xff))
1030         isAll8Bit = true;
1031 
1032     const Identifier* ident = nullptr;
1033 
1034     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
1035         int identifierLength = currentSourcePtr() - identifierStart;
1036         if (isAll8Bit)
1037             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1038         else
1039             ident = makeIdentifier(identifierStart, identifierLength);
1040         if (m_parsingBuiltinFunction) {
<span class="line-modified">1041             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
1042                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1043                 return ERRORTOK;
1044             }
1045             if (isPrivateName)
<span class="line-modified">1046                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">1047             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">1048                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
1049             if (!ident)
1050                 return INVALID_PRIVATE_NAME_ERRORTOK;
1051         }
1052         tokenData-&gt;ident = ident;
1053     } else
1054         tokenData-&gt;ident = nullptr;
1055 
1056     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !(lexerFlags &amp; LexerFlagsIgnoreReservedWords)) &amp;&amp; !isPrivateName) {
1057         ASSERT(shouldCreateIdentifier);
1058         if (remaining &lt; maxTokenLength) {
1059             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1060             ASSERT((remaining &lt; maxTokenLength) || !entry);
1061             if (!entry)
1062                 return IDENT;
1063             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1064             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1065         }
1066         return IDENT;
1067     }
1068 
</pre>
<hr />
<pre>
1122     if (LIKELY(!(lexerFlags &amp; LexerFlagsIgnoreReservedWords))) {
1123         ASSERT(shouldCreateIdentifier);
1124         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1125         if (!entry)
1126             return IDENT;
1127         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1128         if ((token != RESERVED_IF_STRICT) || strictMode)
1129             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1130     }
1131 
1132     return IDENT;
1133 }
1134 
1135 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1136 {
1137     return character &lt; 0xE;
1138 }
1139 
1140 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1141 {
<span class="line-modified">1142     return character &lt; 0xE || !isLatin1(character);</span>
1143 }
1144 
1145 template &lt;typename T&gt;
1146 template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
1147 {
1148     int startingOffset = currentOffset();
1149     int startingLineStartOffset = currentLineStartOffset();
1150     int startingLineNumber = lineNumber();
1151     T stringQuoteCharacter = m_current;
1152     shift();
1153 
1154     const T* stringStart = currentSourcePtr();
1155 
1156     while (m_current != stringQuoteCharacter) {
1157         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1158             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1159                 append8(stringStart, currentSourcePtr() - stringStart);
1160             shift();
1161 
1162             LChar escape = singleEscape(m_current);
</pre>
<hr />
<pre>
1477         tokenData-&gt;raw = nullptr;
1478 
1479     tokenData-&gt;isTail = isTail;
1480 
1481     m_buffer16.shrink(0);
1482     m_bufferForRawTemplateString16.shrink(0);
1483 
1484     if (isTail) {
1485         // Skip `
1486         shift();
1487     } else {
1488         // Skip $ and {
1489         shift();
1490         shift();
1491     }
1492 
1493     return StringParsedSuccessfully;
1494 }
1495 
1496 template &lt;typename T&gt;
<span class="line-modified">1497 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; Optional&lt;NumberParseResult&gt;</span>
1498 {
<span class="line-added">1499     ASSERT(isASCIIHexDigit(m_current));</span>
<span class="line-added">1500 </span>
1501     // Optimization: most hexadecimal values fit into 4 bytes.
1502     uint32_t hexValue = 0;
1503     int maximumDigits = 7;
1504 
1505     do {
<span class="line-added">1506         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1507             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">1508                 return WTF::nullopt;</span>
<span class="line-added">1509 </span>
<span class="line-added">1510             shift();</span>
<span class="line-added">1511         }</span>
<span class="line-added">1512 </span>
1513         hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
1514         shift();
1515         --maximumDigits;
<span class="line-modified">1516     } while (isASCIIHexDigitOrSeparator(m_current) &amp;&amp; maximumDigits &gt;= 0);</span>
1517 
1518     if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
<span class="line-modified">1519         return NumberParseResult { hexValue };</span>
1520 
1521     // No more place in the hexValue buffer.
1522     // The values are shifted out and placed into the m_buffer8 vector.
1523     for (int i = 0; i &lt; 8; ++i) {
1524          int digit = hexValue &gt;&gt; 28;
1525          if (digit &lt; 10)
1526              record8(digit + &#39;0&#39;);
1527          else
1528              record8(digit - 10 + &#39;a&#39;);
1529          hexValue &lt;&lt;= 4;
1530     }
1531 
<span class="line-modified">1532     while (isASCIIHexDigitOrSeparator(m_current)) {</span>
<span class="line-added">1533         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1534             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">1535                 return WTF::nullopt;</span>
<span class="line-added">1536 </span>
<span class="line-added">1537             shift();</span>
<span class="line-added">1538         }</span>
<span class="line-added">1539 </span>
1540         record8(m_current);
1541         shift();
1542     }
1543 
1544     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">1545         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1546 
<span class="line-modified">1547     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16) };</span>
1548 }
1549 
1550 template &lt;typename T&gt;
1551 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
1552 {
<span class="line-added">1553     ASSERT(isASCIIBinaryDigit(m_current));</span>
<span class="line-added">1554 </span>
1555     // Optimization: most binary values fit into 4 bytes.
1556     uint32_t binaryValue = 0;
1557     const unsigned maximumDigits = 32;
1558     int digit = maximumDigits - 1;
1559     // Temporary buffer for the digits. Makes easier
1560     // to reconstruct the input characters when needed.
1561     LChar digits[maximumDigits];
1562 
1563     do {
<span class="line-added">1564         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1565             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">1566                 return WTF::nullopt;</span>
<span class="line-added">1567 </span>
<span class="line-added">1568             shift();</span>
<span class="line-added">1569         }</span>
<span class="line-added">1570 </span>
1571         binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
1572         digits[digit] = m_current;
1573         shift();
1574         --digit;
<span class="line-modified">1575     } while (isASCIIBinaryDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
1576 
<span class="line-modified">1577     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-modified">1578         return NumberParseResult { binaryValue };</span>
1579 
1580     for (int i = maximumDigits - 1; i &gt; digit; --i)
1581         record8(digits[i]);
1582 
<span class="line-modified">1583     while (isASCIIBinaryDigitOrSeparator(m_current)) {</span>
<span class="line-added">1584         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1585             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">1586                 return WTF::nullopt;</span>
<span class="line-added">1587 </span>
<span class="line-added">1588             shift();</span>
<span class="line-added">1589         }</span>
<span class="line-added">1590 </span>
1591         record8(m_current);
1592         shift();
1593     }
1594 
1595     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">1596         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1597 
1598     if (isASCIIDigit(m_current))
1599         return WTF::nullopt;
1600 
<span class="line-modified">1601     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };</span>
1602 }
1603 
1604 template &lt;typename T&gt;
1605 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
1606 {
<span class="line-added">1607     ASSERT(isASCIIOctalDigit(m_current));</span>
<span class="line-added">1608     ASSERT(!m_buffer8.size() || (m_buffer8.size() == 1 &amp;&amp; m_buffer8[0] == &#39;0&#39;));</span>
<span class="line-added">1609     bool isLegacyLiteral = m_buffer8.size();</span>
<span class="line-added">1610 </span>
1611     // Optimization: most octal values fit into 4 bytes.
1612     uint32_t octalValue = 0;
1613     const unsigned maximumDigits = 10;
1614     int digit = maximumDigits - 1;
1615     // Temporary buffer for the digits. Makes easier
1616     // to reconstruct the input characters when needed.
1617     LChar digits[maximumDigits];
1618 
1619     do {
<span class="line-added">1620         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1621             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1622                 return WTF::nullopt;</span>
<span class="line-added">1623 </span>
<span class="line-added">1624             shift();</span>
<span class="line-added">1625         }</span>
<span class="line-added">1626 </span>
1627         octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
1628         digits[digit] = m_current;
1629         shift();
1630         --digit;
<span class="line-modified">1631     } while (isASCIIOctalDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>



1632 
<span class="line-added">1633     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-added">1634         return NumberParseResult { octalValue };</span>
1635 
1636     for (int i = maximumDigits - 1; i &gt; digit; --i)
1637          record8(digits[i]);
1638 
<span class="line-modified">1639     while (isASCIIOctalDigitOrSeparator(m_current)) {</span>
<span class="line-added">1640         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1641             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1642                 return WTF::nullopt;</span>
<span class="line-added">1643 </span>
<span class="line-added">1644             shift();</span>
<span class="line-added">1645         }</span>
<span class="line-added">1646 </span>
1647         record8(m_current);
1648         shift();
1649     }
1650 
<span class="line-modified">1651     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;) &amp;&amp; !isLegacyLiteral)</span>
<span class="line-modified">1652         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1653 
1654     if (isASCIIDigit(m_current))
1655         return WTF::nullopt;
1656 
<span class="line-modified">1657     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };</span>
1658 }
1659 
1660 template &lt;typename T&gt;
1661 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
1662 {
<span class="line-added">1663     ASSERT(isASCIIDigit(m_current) || m_buffer8.size());</span>
<span class="line-added">1664     bool isLegacyLiteral = m_buffer8.size() &amp;&amp; isASCIIDigitOrSeparator(m_current);</span>
<span class="line-added">1665 </span>
1666     // Optimization: most decimal values fit into 4 bytes.
1667     uint32_t decimalValue = 0;
1668 
1669     // Since parseOctal may be executed before parseDecimal,
1670     // the m_buffer8 may hold ascii digits.
1671     if (!m_buffer8.size()) {
1672         const unsigned maximumDigits = 10;
1673         int digit = maximumDigits - 1;
1674         // Temporary buffer for the digits. Makes easier
1675         // to reconstruct the input characters when needed.
1676         LChar digits[maximumDigits];
1677 
1678         do {
<span class="line-added">1679             if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1680                 if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1681                     return WTF::nullopt;</span>
<span class="line-added">1682 </span>
<span class="line-added">1683                 shift();</span>
<span class="line-added">1684             }</span>
<span class="line-added">1685 </span>
1686             decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
1687             digits[digit] = m_current;
1688             shift();
1689             --digit;
<span class="line-modified">1690         } while (isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
1691 
1692         if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
<span class="line-modified">1693             return NumberParseResult { decimalValue };</span>
1694 
1695         for (int i = maximumDigits - 1; i &gt; digit; --i)
1696             record8(digits[i]);
1697     }
1698 
<span class="line-modified">1699     while (isASCIIDigitOrSeparator(m_current)) {</span>
<span class="line-added">1700         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1701             if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">1702                 return WTF::nullopt;</span>
<span class="line-added">1703 </span>
<span class="line-added">1704             shift();</span>
<span class="line-added">1705         }</span>
<span class="line-added">1706 </span>
1707         record8(m_current);
1708         shift();
1709     }
1710 
<span class="line-modified">1711     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39; &amp;&amp; !isLegacyLiteral))</span>
<span class="line-modified">1712         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
1713 
1714     return WTF::nullopt;
1715 }
1716 
1717 template &lt;typename T&gt;
<span class="line-modified">1718 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()</span>
1719 {
<span class="line-added">1720     ASSERT(isASCIIDigit(m_current));</span>
1721     record8(&#39;.&#39;);
<span class="line-modified">1722 </span>
<span class="line-added">1723     do {</span>
<span class="line-added">1724         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1725             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">1726                 return false;</span>
<span class="line-added">1727 </span>
<span class="line-added">1728             shift();</span>
<span class="line-added">1729         }</span>
<span class="line-added">1730 </span>
1731         record8(m_current);
1732         shift();
<span class="line-modified">1733     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">1734 </span>
<span class="line-added">1735     return true;</span>
1736 }
1737 
1738 template &lt;typename T&gt;
1739 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
1740 {
1741     record8(&#39;e&#39;);
1742     shift();
1743     if (m_current == &#39;+&#39; || m_current == &#39;-&#39;) {
1744         record8(m_current);
1745         shift();
1746     }
1747 
1748     if (!isASCIIDigit(m_current))
1749         return false;
1750 
1751     do {
<span class="line-added">1752         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">1753             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">1754                 return false;</span>
<span class="line-added">1755 </span>
<span class="line-added">1756             shift();</span>
<span class="line-added">1757         }</span>
<span class="line-added">1758 </span>
1759         record8(m_current);
1760         shift();
<span class="line-modified">1761     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">1762 </span>
1763     return true;
1764 }
1765 
1766 template &lt;typename T&gt;
1767 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
1768 {
1769     while (true) {
1770         while (UNLIKELY(m_current == &#39;*&#39;)) {
1771             shift();
1772             if (m_current == &#39;/&#39;) {
1773                 shift();
1774                 return true;
1775             }
1776         }
1777 
1778         if (atEnd())
1779             return false;
1780 
1781         if (isLineTerminator(m_current)) {
1782             shiftLineTerminator();
</pre>
<hr />
<pre>
2119         token = CLOSEPAREN;
2120         shift();
2121         break;
2122     case CharacterOpenBracket:
2123         token = OPENBRACKET;
2124         shift();
2125         break;
2126     case CharacterCloseBracket:
2127         token = CLOSEBRACKET;
2128         shift();
2129         break;
2130     case CharacterComma:
2131         token = COMMA;
2132         shift();
2133         break;
2134     case CharacterColon:
2135         token = COLON;
2136         shift();
2137         break;
2138     case CharacterQuestion:

2139         shift();
<span class="line-added">2140         if (Options::useNullishAwareOperators()) {</span>
<span class="line-added">2141             if (m_current == &#39;?&#39;) {</span>
<span class="line-added">2142                 shift();</span>
<span class="line-added">2143                 token = COALESCE;</span>
<span class="line-added">2144                 break;</span>
<span class="line-added">2145             }</span>
<span class="line-added">2146             if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-added">2147                 shift();</span>
<span class="line-added">2148                 token = QUESTIONDOT;</span>
<span class="line-added">2149                 break;</span>
<span class="line-added">2150             }</span>
<span class="line-added">2151         }</span>
<span class="line-added">2152         token = QUESTION;</span>
2153         break;
2154     case CharacterTilde:
2155         token = TILDE;
2156         shift();
2157         break;
2158     case CharacterSemicolon:
2159         shift();
2160         token = SEMICOLON;
2161         break;
2162     case CharacterBackQuote:
2163         shift();
2164         token = BACKQUOTE;
2165         break;
2166     case CharacterOpenBrace:
2167         tokenData-&gt;line = lineNumber();
2168         tokenData-&gt;offset = currentOffset();
2169         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2170         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2171         shift();
2172         token = OPENBRACE;
</pre>
<hr />
<pre>
2174     case CharacterCloseBrace:
2175         tokenData-&gt;line = lineNumber();
2176         tokenData-&gt;offset = currentOffset();
2177         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2178         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2179         shift();
2180         token = CLOSEBRACE;
2181         break;
2182     case CharacterDot:
2183         shift();
2184         if (!isASCIIDigit(m_current)) {
2185             if (UNLIKELY((m_current == &#39;.&#39;) &amp;&amp; (peek(1) == &#39;.&#39;))) {
2186                 shift();
2187                 shift();
2188                 token = DOTDOTDOT;
2189                 break;
2190             }
2191             token = DOT;
2192             break;
2193         }
<span class="line-modified">2194         if (UNLIKELY(!parseNumberAfterDecimalPoint())) {</span>
<span class="line-added">2195             m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-added">2196             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">2197             goto returnError;</span>
<span class="line-added">2198         }</span>
2199         token = DOUBLE;
<span class="line-modified">2200         if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">2201             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-modified">2202             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">2203             goto returnError;</span>


2204         }
2205         size_t parsedLength;
2206         tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2207         if (token == INTEGER)
2208             token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2209 
2210         if (UNLIKELY(isIdentStart(m_current))) {
2211             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2212             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2213             goto returnError;
2214         }
2215         m_buffer8.shrink(0);
2216         break;
2217     case CharacterZero:
2218         shift();
2219         if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
<span class="line-modified">2220             if (UNLIKELY(!isASCIIHexDigit(peek(1)))) {</span>
2221                 m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
2222                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2223                 goto returnError;
2224             }
2225 
2226             // Shift out the &#39;x&#39; prefix.
2227             shift();
2228 
2229             auto parseNumberResult = parseHex();
<span class="line-modified">2230             if (!parseNumberResult)</span>
<span class="line-modified">2231                 tokenData-&gt;doubleValue = 0;</span>
<span class="line-added">2232             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))</span>
<span class="line-added">2233                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
2234             else {
2235                 token = BIGINT;
2236                 shift();
<span class="line-modified">2237                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);</span>
2238                 tokenData-&gt;radix = 16;
2239             }
2240 
<span class="line-modified">2241             if (UNLIKELY(isIdentStart(m_current))) {</span>
2242                 m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
2243                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2244                 goto returnError;
2245             }
2246             if (LIKELY(token != BIGINT))
2247                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2248             m_buffer8.shrink(0);
2249             break;
2250         }
2251         if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
<span class="line-modified">2252             if (UNLIKELY(!isASCIIBinaryDigit(peek(1)))) {</span>
2253                 m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
2254                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2255                 goto returnError;
2256             }
2257 
2258             // Shift out the &#39;b&#39; prefix.
2259             shift();
2260 
2261             auto parseNumberResult = parseBinary();
2262             if (!parseNumberResult)
2263                 tokenData-&gt;doubleValue = 0;
2264             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2265                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2266             else {
2267                 token = BIGINT;
2268                 shift();
2269                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2270                 tokenData-&gt;radix = 2;
2271             }
2272 
<span class="line-modified">2273             if (UNLIKELY(isIdentStart(m_current))) {</span>
2274                 m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
2275                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2276                 goto returnError;
2277             }
2278             if (LIKELY(token != BIGINT))
2279                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2280             m_buffer8.shrink(0);
2281             break;
2282         }
2283 
2284         if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
<span class="line-modified">2285             if (UNLIKELY(!isASCIIOctalDigit(peek(1)))) {</span>
2286                 m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
2287                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2288                 goto returnError;
2289             }
2290 
2291             // Shift out the &#39;o&#39; prefix.
2292             shift();
2293 
2294             auto parseNumberResult = parseOctal();
2295             if (!parseNumberResult)
2296                 tokenData-&gt;doubleValue = 0;
2297             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2298                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2299             else {
2300                 token = BIGINT;
2301                 shift();
2302                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2303                 tokenData-&gt;radix = 8;
2304             }
2305 
<span class="line-modified">2306             if (UNLIKELY(isIdentStart(m_current))) {</span>
2307                 m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
2308                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2309                 goto returnError;
2310             }
2311             if (LIKELY(token != BIGINT))
2312                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2313             m_buffer8.shrink(0);
2314             break;
2315         }
2316 
<span class="line-added">2317         if (UNLIKELY(m_current == &#39;_&#39;)) {</span>
<span class="line-added">2318             m_lexErrorMessage = &quot;Numeric literals may not begin with 0_&quot;_s;</span>
<span class="line-added">2319             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;</span>
<span class="line-added">2320             goto returnError;</span>
<span class="line-added">2321         }</span>
<span class="line-added">2322 </span>
2323         record8(&#39;0&#39;);
<span class="line-modified">2324         if (UNLIKELY(strictMode &amp;&amp; isASCIIDigit(m_current))) {</span>
2325             m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
2326             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2327             goto returnError;
2328         }
2329         if (isASCIIOctalDigit(m_current)) {
2330             auto parseNumberResult = parseOctal();
2331             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {
2332                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2333                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2334             }
2335         }
2336         FALLTHROUGH;
2337     case CharacterNumber:
2338         if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
2339             auto parseNumberResult = parseDecimal();
<span class="line-modified">2340             if (parseNumberResult) {</span>
<span class="line-modified">2341                 if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {</span>
<span class="line-modified">2342                     tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
<span class="line-modified">2343                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
<span class="line-modified">2344                 } else {</span>

2345                     token = BIGINT;
2346                     shift();
2347                     tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2348                     tokenData-&gt;radix = 10;
<span class="line-modified">2349                 }</span>
<span class="line-modified">2350             } else {</span>
<span class="line-modified">2351                 token = INTEGER;</span>
<span class="line-modified">2352                 if (m_current == &#39;.&#39;) {</span>
<span class="line-modified">2353                     shift();</span>
<span class="line-modified">2354                     if (UNLIKELY(isASCIIDigit(m_current) &amp;&amp; !parseNumberAfterDecimalPoint())) {</span>
<span class="line-modified">2355                         m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-modified">2356                         token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">2357                         goto returnError;</span>




2358                     }
<span class="line-modified">2359                     token = DOUBLE;</span>
<span class="line-modified">2360                 }</span>
<span class="line-modified">2361                 if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">2362                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-added">2363                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">2364                     goto returnError;</span>
2365                 }
<span class="line-added">2366                 size_t parsedLength;</span>
<span class="line-added">2367                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);</span>
<span class="line-added">2368                 if (token == INTEGER)</span>
<span class="line-added">2369                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
2370             }
2371         }
2372 
2373         if (UNLIKELY(isIdentStart(m_current))) {
2374             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2375             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2376             goto returnError;
2377         }
2378         m_buffer8.shrink(0);
2379         break;
2380     case CharacterQuote: {
2381         StringParseResult result = StringCannotBeParsed;
2382         if (lexerFlags &amp; LexerFlagsDontBuildStrings)
2383             result = parseString&lt;false&gt;(tokenData, strictMode);
2384         else
2385             result = parseString&lt;true&gt;(tokenData, strictMode);
2386 
2387         if (UNLIKELY(result != StringParsedSuccessfully)) {
2388             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2389             goto returnError;
</pre>
<hr />
<pre>
2392         token = STRING;
2393         break;
2394         }
2395     case CharacterIdentifierStart:
2396         ASSERT(isIdentStart(m_current));
2397         FALLTHROUGH;
2398     case CharacterBackSlash:
2399         parseIdent:
2400         if (lexerFlags &amp; LexexFlagsDontBuildKeywords)
2401             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2402         else
2403             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2404         break;
2405     case CharacterLineTerminator:
2406         ASSERT(isLineTerminator(m_current));
2407         shiftLineTerminator();
2408         m_atLineStart = true;
2409         m_hasLineTerminatorBeforeToken = true;
2410         m_lineStart = m_code;
2411         goto start;
<span class="line-added">2412     case CharacterHash:</span>
<span class="line-added">2413         // Hashbang is only permitted at the start of the source text.</span>
<span class="line-added">2414         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {</span>
<span class="line-added">2415             shift();</span>
<span class="line-added">2416             shift();</span>
<span class="line-added">2417             goto inSingleLineComment;</span>
<span class="line-added">2418         }</span>
<span class="line-added">2419         goto invalidCharacter;</span>
2420     case CharacterPrivateIdentifierStart:
2421         if (m_parsingBuiltinFunction)
2422             goto parseIdent;
<span class="line-modified">2423         goto invalidCharacter;</span>

2424     case CharacterOtherIdentifierPart:
2425     case CharacterInvalid:
<span class="line-modified">2426         goto invalidCharacter;</span>


2427     default:
2428         RELEASE_ASSERT_NOT_REACHED();
2429         m_lexErrorMessage = &quot;Internal Error&quot;_s;
2430         token = ERRORTOK;
2431         goto returnError;
2432     }
2433 
2434     m_atLineStart = false;
2435     goto returnToken;
2436 
2437 inSingleLineCommentCheckForDirectives:
2438     // Script comment directives like &quot;//# sourceURL=test.js&quot;.
2439     if (UNLIKELY((m_current == &#39;#&#39; || m_current == &#39;@&#39;) &amp;&amp; isWhiteSpace(peek(1)))) {
2440         shift();
2441         shift();
2442         parseCommentDirective();
2443     }
2444     // Fall through to complete single line comment parsing.
2445 
2446 inSingleLineComment:
</pre>
<hr />
<pre>
2457                 return token;
2458             }
2459             shift();
2460         }
2461         shiftLineTerminator();
2462         m_atLineStart = true;
2463         m_hasLineTerminatorBeforeToken = true;
2464         m_lineStart = m_code;
2465         if (!lastTokenWasRestrKeyword())
2466             goto start;
2467 
2468         token = SEMICOLON;
2469         fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2470         return token;
2471     }
2472 
2473 returnToken:
2474     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2475     return token;
2476 
<span class="line-added">2477 invalidCharacter:</span>
<span class="line-added">2478     m_lexErrorMessage = invalidCharacterMessage();</span>
<span class="line-added">2479     token = ERRORTOK;</span>
<span class="line-added">2480     // Falls through to return error.</span>
<span class="line-added">2481 </span>
2482 returnError:
2483     m_error = true;
2484     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2485     RELEASE_ASSERT(token &amp; ErrorTokenFlag);
2486     return token;
2487 }
2488 
2489 template &lt;typename T&gt;
2490 static inline void orCharacter(UChar&amp;, UChar);
2491 
2492 template &lt;&gt;
2493 inline void orCharacter&lt;LChar&gt;(UChar&amp;, UChar) { }
2494 
2495 template &lt;&gt;
2496 inline void orCharacter&lt;UChar&gt;(UChar&amp; orAccumulator, UChar character)
2497 {
2498     orAccumulator |= character;
2499 }
2500 
2501 template &lt;typename T&gt;
</pre>
</td>
</tr>
</table>
<center><a href="ASTBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>