<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
   3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;VTTCue.h&quot;
  34 
  35 #if ENABLE(VIDEO_TRACK)
  36 
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CSSValueKeywords.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Event.h&quot;
  41 #include &quot;HTMLDivElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLStyleElement.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeTraversal.h&quot;
  46 #include &quot;RenderVTTCue.h&quot;
  47 #include &quot;ScriptDisallowedScope.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextTrack.h&quot;
  50 #include &quot;TextTrackCueList.h&quot;
  51 #include &quot;VTTRegionList.h&quot;
  52 #include &quot;VTTScanner.h&quot;
  53 #include &quot;WebVTTElement.h&quot;
  54 #include &quot;WebVTTParser.h&quot;
  55 #include &lt;wtf/IsoMallocInlines.h&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 
  62 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCueBox);
<a name="1" id="anc1"></a>
  63 
  64 // This constant should correspond with the percentage returned by CaptionUserPreferences::captionFontSizeScaleAndImportance.
  65 const static double DEFAULTCAPTIONFONTSIZEPERCENTAGE = 5;
  66 
  67 static const int undefinedPosition = -1;
  68 
  69 static const CSSValueID displayWritingModeMap[] = {
  70     CSSValueHorizontalTb, CSSValueVerticalRl, CSSValueVerticalLr
  71 };
  72 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayWritingModeMap) == VTTCue::NumberOfWritingDirections, displayWritingModeMap_has_wrong_size);
  73 
  74 static const CSSValueID displayAlignmentMap[] = {
  75     CSSValueStart, CSSValueCenter, CSSValueEnd, CSSValueLeft, CSSValueRight
  76 };
  77 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayAlignmentMap) == VTTCue::NumberOfAlignments, displayAlignmentMap_has_wrong_size);
  78 
  79 static const String&amp; startKeyword()
  80 {
  81     static NeverDestroyed&lt;const String&gt; start(MAKE_STATIC_STRING_IMPL(&quot;start&quot;));
  82     return start;
  83 }
  84 
  85 static const String&amp; centerKeyword()
  86 {
  87     static NeverDestroyed&lt;const String&gt; center(MAKE_STATIC_STRING_IMPL(&quot;center&quot;));
  88     return center;
  89 }
  90 
  91 static const String&amp; endKeyword()
  92 {
  93     static NeverDestroyed&lt;const String&gt; end(MAKE_STATIC_STRING_IMPL(&quot;end&quot;));
  94     return end;
  95 }
  96 
  97 static const String&amp; leftKeyword()
  98 {
  99     static NeverDestroyed&lt;const String&gt; left(MAKE_STATIC_STRING_IMPL(&quot;left&quot;));
 100     return left;
 101 }
 102 
 103 static const String&amp; rightKeyword()
 104 {
 105     static NeverDestroyed&lt;const String&gt; right(MAKE_STATIC_STRING_IMPL(&quot;right&quot;));
 106     return right;
 107 }
 108 
 109 static const String&amp; horizontalKeyword()
 110 {
 111     return emptyString();
 112 }
 113 
 114 static const String&amp; verticalGrowingLeftKeyword()
 115 {
 116     static NeverDestroyed&lt;const String&gt; verticalrl(MAKE_STATIC_STRING_IMPL(&quot;rl&quot;));
 117     return verticalrl;
 118 }
 119 
 120 static const String&amp; verticalGrowingRightKeyword()
 121 {
 122     static NeverDestroyed&lt;const String&gt; verticallr(MAKE_STATIC_STRING_IMPL(&quot;lr&quot;));
 123     return verticallr;
 124 }
 125 
 126 // ----------------------------
 127 
 128 Ref&lt;VTTCueBox&gt; VTTCueBox::create(Document&amp; document, VTTCue&amp; cue)
 129 {
 130     VTTCueBox&amp; cueBox = *new VTTCueBox(document, cue);
 131     cueBox.setPseudo(VTTCueBox::vttCueBoxShadowPseudoId());
 132     return adoptRef(cueBox);
 133 }
 134 
 135 VTTCueBox::VTTCueBox(Document&amp; document, VTTCue&amp; cue)
 136     : HTMLElement(divTag, document)
 137     , m_cue(makeWeakPtr(cue))
 138 {
 139     setPseudo(vttCueBoxShadowPseudoId());
 140 }
 141 
 142 VTTCue* VTTCueBox::getCue() const
 143 {
 144     return m_cue.get();
 145 }
 146 
 147 void VTTCueBox::applyCSSProperties(const IntSize&amp; videoSize)
 148 {
 149     if (!m_cue)
 150         return;
 151 
 152     auto cue = makeRef(*m_cue);
 153 
 154     // FIXME: Apply all the initial CSS positioning properties. http://wkb.ug/79916
 155     if (!cue-&gt;regionId().isEmpty()) {
 156         setInlineStyleProperty(CSSPropertyPosition, CSSValueRelative);
 157         return;
 158     }
 159 
 160     // 3.5.1 On the (root) List of WebVTT Node Objects:
 161 
 162     // the &#39;position&#39; property must be set to &#39;absolute&#39;
 163     setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
 164 
 165     //  the &#39;unicode-bidi&#39; property must be set to &#39;plaintext&#39;
 166     setInlineStyleProperty(CSSPropertyUnicodeBidi, CSSValuePlaintext);
 167 
 168     // the &#39;direction&#39; property must be set to direction
 169     setInlineStyleProperty(CSSPropertyDirection, cue-&gt;getCSSWritingDirection());
 170 
 171     // the &#39;writing-mode&#39; property must be set to writing-mode
 172     setInlineStyleProperty(CSSPropertyWritingMode, cue-&gt;getCSSWritingMode(), false);
 173 
 174     auto position = cue-&gt;getCSSPosition();
 175 
 176     // the &#39;top&#39; property must be set to top,
 177     setInlineStyleProperty(CSSPropertyTop, position.second, CSSPrimitiveValue::CSS_PERCENTAGE);
 178 
 179     // the &#39;left&#39; property must be set to left
<a name="2" id="anc2"></a><span class="line-modified"> 180     setInlineStyleProperty(CSSPropertyLeft, position.first, CSSPrimitiveValue::CSS_PERCENTAGE);</span>



 181 
 182     double authorFontSize = std::min(videoSize.width(), videoSize.height()) * DEFAULTCAPTIONFONTSIZEPERCENTAGE / 100.0;
 183     double multiplier = 1.0;
 184     if (authorFontSize)
 185         multiplier = m_fontSizeFromCaptionUserPrefs / authorFontSize;
 186 
 187     double textPosition = cue-&gt;calculateComputedTextPosition();
 188     double maxSize = 100.0;
 189     CSSValueID alignment = cue-&gt;getCSSAlignment();
 190     if (alignment == CSSValueEnd || alignment == CSSValueRight)
 191         maxSize = textPosition;
 192     else if (alignment == CSSValueStart || alignment == CSSValueLeft)
 193         maxSize = 100.0 - textPosition;
 194 
 195     double newCueSize = std::min(cue-&gt;getCSSSize() * multiplier, 100.0);
 196     // the &#39;width&#39; property must be set to width, and the &#39;height&#39; property  must be set to height
 197     if (cue-&gt;vertical() == horizontalKeyword()) {
 198         setInlineStyleProperty(CSSPropertyWidth, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 199         setInlineStyleProperty(CSSPropertyHeight, CSSValueAuto);
 200         setInlineStyleProperty(CSSPropertyMinWidth, &quot;min-content&quot;);
 201         setInlineStyleProperty(CSSPropertyMaxWidth, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 202         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 203             setInlineStyleProperty(CSSPropertyLeft, static_cast&lt;double&gt;(position.first - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);
 204     } else {
 205         setInlineStyleProperty(CSSPropertyWidth, CSSValueAuto);
 206         setInlineStyleProperty(CSSPropertyHeight, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 207         setInlineStyleProperty(CSSPropertyMinHeight, &quot;min-content&quot;);
 208         setInlineStyleProperty(CSSPropertyMaxHeight, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 209         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 210             setInlineStyleProperty(CSSPropertyTop, static_cast&lt;double&gt;(position.second - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);
 211     }
 212 
 213     // The &#39;text-align&#39; property on the (root) List of WebVTT Node Objects must
 214     // be set to the value in the second cell of the row of the table below
 215     // whose first cell is the value of the corresponding cue&#39;s text track cue
 216     // alignment:
 217     setInlineStyleProperty(CSSPropertyTextAlign, cue-&gt;getCSSAlignment());
 218 
 219     if (!cue-&gt;snapToLines()) {
 220         // 10.13.1 Set up x and y:
 221         // Note: x and y are set through the CSS left and top above.
 222 
 223         // 10.13.2 Position the boxes in boxes such that the point x% along the
 224         // width of the bounding box of the boxes in boxes is x% of the way
 225         // across the width of the video&#39;s rendering area, and the point y%
 226         // along the height of the bounding box of the boxes in boxes is y%
 227         // of the way across the height of the video&#39;s rendering area, while
 228         // maintaining the relative positions of the boxes in boxes to each
 229         // other.
 230         setInlineStyleProperty(CSSPropertyTransform,
 231             makeString(&quot;translate(&quot;, FormattedNumber::fixedWidth(-position.first, 2), &quot;%, &quot;, FormattedNumber::fixedWidth(-position.second, 2), &quot;%)&quot;));
 232 
 233         setInlineStyleProperty(CSSPropertyWhiteSpace, CSSValuePre);
 234     }
 235 
 236     // Make sure shadow or stroke is not clipped.
 237     setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 238     cue-&gt;element().setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 239 }
 240 
<a name="3" id="anc3"></a><span class="line-modified"> 241 const AtomicString&amp; VTTCueBox::vttCueBoxShadowPseudoId()</span>
 242 {
<a name="4" id="anc4"></a><span class="line-modified"> 243     static NeverDestroyed&lt;const AtomicString&gt; trackDisplayBoxShadowPseudoId(&quot;-webkit-media-text-track-display&quot;, AtomicString::ConstructFromLiteral);</span>
 244     return trackDisplayBoxShadowPseudoId;
 245 }
 246 
 247 RenderPtr&lt;RenderElement&gt; VTTCueBox::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 248 {
 249     return createRenderer&lt;RenderVTTCue&gt;(*this, WTFMove(style));
 250 }
 251 
 252 // ----------------------------
 253 
<a name="5" id="anc5"></a><span class="line-modified"> 254 const AtomicString&amp; VTTCue::cueBackdropShadowPseudoId()</span>
 255 {
<a name="6" id="anc6"></a><span class="line-modified"> 256     static NeverDestroyed&lt;const AtomicString&gt; cueBackdropShadowPseudoId(&quot;-webkit-media-text-track-display-backdrop&quot;, AtomicString::ConstructFromLiteral);</span>
 257     return cueBackdropShadowPseudoId;
 258 }
 259 
 260 Ref&lt;VTTCue&gt; VTTCue::create(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; data)
 261 {
 262     return adoptRef(*new VTTCue(context, data));
 263 }
 264 
 265 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, const String&amp; content)
 266     : TextTrackCue(context, start, end)
 267     , m_content(content)
 268 {
 269     initialize(context);
 270 }
 271 
 272 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; cueData)
 273     : TextTrackCue(context, MediaTime::zeroTime(), MediaTime::zeroTime())
 274 {
 275     initialize(context);
 276     setText(cueData.content());
 277     setStartTime(cueData.startTime());
 278     setEndTime(cueData.endTime());
 279     setId(cueData.id());
 280     setCueSettings(cueData.settings());
 281     m_originalStartTime = cueData.originalStartTime();
 282 }
 283 
 284 VTTCue::~VTTCue()
 285 {
 286 }
 287 
 288 void VTTCue::initialize(ScriptExecutionContext&amp; context)
 289 {
 290     m_linePosition = undefinedPosition;
 291     m_computedLinePosition = undefinedPosition;
 292     m_textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 293     m_cueSize = 100;
 294     m_writingDirection = Horizontal;
 295     m_cueAlignment = Center;
 296     m_webVTTNodeTree = nullptr;
 297     m_cueBackdropBox = HTMLDivElement::create(downcast&lt;Document&gt;(context));
 298     m_cueHighlightBox = HTMLSpanElement::create(spanTag, downcast&lt;Document&gt;(context));
 299     m_displayDirection = CSSValueLtr;
 300     m_displaySize = 0;
 301     m_snapToLines = true;
 302     m_displayTreeShouldChange = true;
 303     m_notifyRegion = true;
 304     m_originalStartTime = MediaTime::zeroTime();
 305 }
 306 
 307 Ref&lt;VTTCueBox&gt; VTTCue::createDisplayTree()
 308 {
 309     return VTTCueBox::create(ownerDocument(), *this);
 310 }
 311 
 312 VTTCueBox&amp; VTTCue::displayTreeInternal()
 313 {
 314     if (!m_displayTree)
 315         m_displayTree = createDisplayTree();
 316     return *m_displayTree;
 317 }
 318 
 319 void VTTCue::didChange()
 320 {
 321     TextTrackCue::didChange();
 322     m_displayTreeShouldChange = true;
 323 }
 324 
 325 const String&amp; VTTCue::vertical() const
 326 {
 327     switch (m_writingDirection) {
 328     case Horizontal:
 329         return horizontalKeyword();
 330     case VerticalGrowingLeft:
 331         return verticalGrowingLeftKeyword();
 332     case VerticalGrowingRight:
 333         return verticalGrowingRightKeyword();
 334     default:
 335         ASSERT_NOT_REACHED();
 336         return emptyString();
 337     }
 338 }
 339 
 340 ExceptionOr&lt;void&gt; VTTCue::setVertical(const String&amp; value)
 341 {
 342     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-vertical
 343     // On setting, the text track cue writing direction must be set to the value given
 344     // in the first cell of the row in the table above whose second cell is a
 345     // case-sensitive match for the new value, if any. If none of the values match, then
 346     // the user agent must instead throw a SyntaxError exception.
 347 
 348     WritingDirection direction = m_writingDirection;
 349     if (value == horizontalKeyword())
 350         direction = Horizontal;
 351     else if (value == verticalGrowingLeftKeyword())
 352         direction = VerticalGrowingLeft;
 353     else if (value == verticalGrowingRightKeyword())
 354         direction = VerticalGrowingRight;
 355     else
 356         return Exception { SyntaxError };
 357 
 358     if (direction == m_writingDirection)
 359         return { };
 360 
 361     willChange();
 362     m_writingDirection = direction;
 363     didChange();
 364 
 365     return { };
 366 }
 367 
 368 void VTTCue::setSnapToLines(bool value)
 369 {
 370     if (m_snapToLines == value)
 371         return;
 372 
 373     willChange();
 374     m_snapToLines = value;
 375     didChange();
 376 }
 377 
 378 ExceptionOr&lt;void&gt; VTTCue::setLine(double position)
 379 {
 380     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-line
 381     // On setting, if the text track cue snap-to-lines flag is not set, and the new
 382     // value is negative or greater than 100, then throw an IndexSizeError exception.
 383     if (!m_snapToLines &amp;&amp; !(position &gt;= 0 &amp;&amp; position &lt;= 100))
 384         return Exception { IndexSizeError };
 385 
 386     // Otherwise, set the text track cue line position to the new value.
 387     if (m_linePosition == position)
 388         return { };
 389 
 390     willChange();
 391     m_linePosition = position;
 392     m_computedLinePosition = calculateComputedLinePosition();
 393     didChange();
 394 
 395     return { };
 396 }
 397 
 398 VTTCue::LineAndPositionSetting VTTCue::position() const
 399 {
 400     if (textPositionIsAuto())
 401         return Auto;
 402     return m_textPosition;
 403 }
 404 
 405 ExceptionOr&lt;void&gt; VTTCue::setPosition(const LineAndPositionSetting&amp; position)
 406 {
 407     // http://dev.w3.org/html5/webvtt/#dfn-vttcue-position
 408     // On setting, if the new value is negative or greater than 100, then an
 409     // IndexSizeError exception must be thrown. Otherwise, the WebVTT cue
 410     // position must be set to the new value; if the new value is the string
 411     // &quot;auto&quot;, then it must be interpreted as the special value auto.
 412     double textPosition = 0;
 413     if (WTF::holds_alternative&lt;AutoKeyword&gt;(position)) {
 414         if (textPositionIsAuto())
 415             return { };
 416         textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 417     } else {
 418         if (!(WTF::get&lt;double&gt;(position) &gt;= 0 &amp;&amp; WTF::get&lt;double&gt;(position) &lt;= 100))
 419             return Exception { IndexSizeError };
 420 
 421         // Otherwise, set the text track cue line position to the new value.
 422         textPosition = WTF::get&lt;double&gt;(position);
 423         if (m_textPosition == textPosition)
 424             return { };
 425     }
 426 
 427     willChange();
 428     m_textPosition = textPosition;
 429     didChange();
 430 
 431     return { };
 432 }
 433 
 434 ExceptionOr&lt;void&gt; VTTCue::setSize(int size)
 435 {
 436     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-size
 437     // On setting, if the new value is negative or greater than 100, then throw an IndexSizeError
 438     // exception. Otherwise, set the text track cue size to the new value.
 439     if (!(size &gt;= 0 &amp;&amp; size &lt;= 100))
 440         return Exception { IndexSizeError };
 441 
 442     // Otherwise, set the text track cue line position to the new value.
 443     if (m_cueSize == size)
 444         return { };
 445 
 446     willChange();
 447     m_cueSize = size;
 448     didChange();
 449 
 450     return { };
 451 }
 452 
 453 const String&amp; VTTCue::align() const
 454 {
 455     switch (m_cueAlignment) {
 456     case Start:
 457         return startKeyword();
 458     case Center:
 459         return centerKeyword();
 460     case End:
 461         return endKeyword();
 462     case Left:
 463         return leftKeyword();
 464     case Right:
 465         return rightKeyword();
 466     default:
 467         ASSERT_NOT_REACHED();
 468         return emptyString();
 469     }
 470 }
 471 
 472 ExceptionOr&lt;void&gt; VTTCue::setAlign(const String&amp; value)
 473 {
 474     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-align
 475     // On setting, the text track cue alignment must be set to the value given in the
 476     // first cell of the row in the table above whose second cell is a case-sensitive
 477     // match for the new value, if any. If none of the values match, then the user
 478     // agent must instead throw a SyntaxError exception.
 479 
 480     CueAlignment alignment;
 481     if (value == startKeyword())
 482         alignment = Start;
 483     else if (value == centerKeyword())
 484         alignment = Center;
 485     else if (value == endKeyword())
 486         alignment = End;
 487     else if (value == leftKeyword())
 488         alignment = Left;
 489     else if (value == rightKeyword())
 490         alignment = Right;
 491     else
 492         return Exception { SyntaxError };
 493 
 494     if (alignment == m_cueAlignment)
 495         return { };
 496 
 497     willChange();
 498     m_cueAlignment = alignment;
 499     didChange();
 500 
 501     return { };
 502 }
 503 
 504 void VTTCue::setText(const String&amp; text)
 505 {
 506     if (m_content == text)
 507         return;
 508 
 509     willChange();
 510     // Clear the document fragment but don&#39;t bother to create it again just yet as we can do that
 511     // when it is requested.
 512     m_webVTTNodeTree = nullptr;
 513     m_content = text;
 514     didChange();
 515 }
 516 
 517 void VTTCue::createWebVTTNodeTree()
 518 {
 519     if (!m_webVTTNodeTree)
 520         m_webVTTNodeTree = WebVTTParser::createDocumentFragmentFromCueText(ownerDocument(), m_content);
 521 }
 522 
 523 void VTTCue::copyWebVTTNodeToDOMTree(ContainerNode* webVTTNode, ContainerNode* parent)
 524 {
 525     for (RefPtr&lt;Node&gt; node = webVTTNode-&gt;firstChild(); node; node = node-&gt;nextSibling()) {
 526         RefPtr&lt;Node&gt; clonedNode;
 527         if (is&lt;WebVTTElement&gt;(*node))
 528             clonedNode = downcast&lt;WebVTTElement&gt;(*node).createEquivalentHTMLElement(ownerDocument());
 529         else
 530             clonedNode = node-&gt;cloneNode(false);
 531         parent-&gt;appendChild(*clonedNode);
 532         if (is&lt;ContainerNode&gt;(*node))
 533             copyWebVTTNodeToDOMTree(downcast&lt;ContainerNode&gt;(node.get()), downcast&lt;ContainerNode&gt;(clonedNode.get()));
 534     }
 535 }
 536 
 537 RefPtr&lt;DocumentFragment&gt; VTTCue::getCueAsHTML()
 538 {
 539     createWebVTTNodeTree();
 540     if (!m_webVTTNodeTree)
 541         return nullptr;
 542 
 543     auto clonedFragment = DocumentFragment::create(ownerDocument());
 544     copyWebVTTNodeToDOMTree(m_webVTTNodeTree.get(), clonedFragment.ptr());
<a name="7" id="anc7"></a><span class="line-modified"> 545     return WTFMove(clonedFragment);</span>
 546 }
 547 
 548 RefPtr&lt;DocumentFragment&gt; VTTCue::createCueRenderingTree()
 549 {
 550     createWebVTTNodeTree();
 551     if (!m_webVTTNodeTree)
 552         return nullptr;
 553 
 554     auto clonedFragment = DocumentFragment::create(ownerDocument());
 555 
 556     // The cloned fragment is never exposed to author scripts so it&#39;s safe to dispatch events here.
 557     ScriptDisallowedScope::EventAllowedScope allowedScope(clonedFragment);
 558 
 559     m_webVTTNodeTree-&gt;cloneChildNodes(clonedFragment);
<a name="8" id="anc8"></a><span class="line-modified"> 560     return WTFMove(clonedFragment);</span>
 561 }
 562 
 563 void VTTCue::setRegionId(const String&amp; regionId)
 564 {
 565     if (m_regionId == regionId)
 566         return;
 567 
 568     willChange();
 569     m_regionId = regionId;
 570     didChange();
 571 }
 572 
 573 void VTTCue::notifyRegionWhenRemovingDisplayTree(bool notifyRegion)
 574 {
 575     m_notifyRegion = notifyRegion;
 576 }
 577 
 578 void VTTCue::setIsActive(bool active)
 579 {
 580     TextTrackCue::setIsActive(active);
 581 
 582     if (!active) {
 583         if (!hasDisplayTree())
 584             return;
 585 
 586         // Remove the display tree as soon as the cue becomes inactive.
 587         removeDisplayTree();
 588     }
 589 }
 590 
 591 int VTTCue::calculateComputedLinePosition()
 592 {
 593     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-computed-line-position
 594 
 595     // If the text track cue line position is numeric, then that is the text
 596     // track cue computed line position.
 597     if (m_linePosition != undefinedPosition)
 598         return m_linePosition;
 599 
 600     // If the text track cue snap-to-lines flag of the text track cue is not
 601     // set, the text track cue computed line position is the value 100;
 602     if (!m_snapToLines)
 603         return 100;
 604 
 605     // Otherwise, it is the value returned by the following algorithm:
 606 
 607     // If cue is not associated with a text track, return -1 and abort these
 608     // steps.
 609     if (!track())
 610         return -1;
 611 
 612     // Let n be the number of text tracks whose text track mode is showing or
 613     // showing by default and that are in the media element&#39;s list of text
 614     // tracks before track.
 615     int n = track()-&gt;trackIndexRelativeToRenderedTracks();
 616 
 617     // Increment n by one.
 618     n++;
 619 
 620     // Negate n.
 621     n = -n;
 622 
 623     return n;
 624 }
 625 
 626 static bool isCueParagraphSeparator(UChar character)
 627 {
 628     // Within a cue, paragraph boundaries are only denoted by Type B characters,
 629     // such as U+000A LINE FEED (LF), U+0085 NEXT LINE (NEL), and U+2029 PARAGRAPH SEPARATOR.
 630     return u_charType(character) == U_PARAGRAPH_SEPARATOR;
 631 }
 632 
 633 bool VTTCue::textPositionIsAuto() const
 634 {
 635     return std::isnan(m_textPosition);
 636 }
 637 
 638 void VTTCue::determineTextDirection()
 639 {
 640     static NeverDestroyed&lt;const String&gt; rtTag(MAKE_STATIC_STRING_IMPL(&quot;rt&quot;));
 641     createWebVTTNodeTree();
 642     if (!m_webVTTNodeTree)
 643         return;
 644 
 645     // Apply the Unicode Bidirectional Algorithm&#39;s Paragraph Level steps to the
 646     // concatenation of the values of each WebVTT Text Object in nodes, in a
 647     // pre-order, depth-first traversal, excluding WebVTT Ruby Text Objects and
 648     // their descendants.
 649     StringBuilder paragraphBuilder;
 650     for (RefPtr&lt;Node&gt; node = m_webVTTNodeTree-&gt;firstChild(); node; node = NodeTraversal::next(*node, m_webVTTNodeTree.get())) {
 651         // FIXME: The code does not match the comment above. This does not actually exclude Ruby Text Object descendant.
 652         if (!node-&gt;isTextNode() || node-&gt;localName() == rtTag)
 653             continue;
 654 
 655         paragraphBuilder.append(node-&gt;nodeValue());
 656     }
 657 
 658     String paragraph = paragraphBuilder.toString();
 659     if (!paragraph.length())
 660         return;
 661 
 662     for (size_t i = 0; i &lt; paragraph.length(); ++i) {
 663         UChar current = paragraph[i];
 664         if (!current || isCueParagraphSeparator(current))
 665             return;
 666 
 667         if (UChar current = paragraph[i]) {
 668             UCharDirection charDirection = u_charDirection(current);
 669             if (charDirection == U_LEFT_TO_RIGHT) {
 670                 m_displayDirection = CSSValueLtr;
 671                 return;
 672             }
 673             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
 674                 m_displayDirection = CSSValueRtl;
 675                 return;
 676             }
 677         }
 678     }
 679 }
 680 
 681 double VTTCue::calculateComputedTextPosition() const
 682 {
 683     // http://dev.w3.org/html5/webvtt/#dfn-cue-computed-position
 684 
 685     // 1. If the position is numeric, then return the value of the position and
 686     // abort these steps. (Otherwise, the position is the special value auto.)
 687     if (!textPositionIsAuto())
 688         return m_textPosition;
 689 
 690     switch (m_cueAlignment) {
 691     case Start:
 692     case Left:
 693         // 2. If the cue text alignment is start or left, return 0 and abort these
 694         // steps.
 695         return 0;
 696     case End:
 697     case Right:
 698         // 3. If the cue text alignment is end or right, return 100 and abort these
 699         // steps.
 700         return 100;
 701     case Center:
 702         // 4. If the cue text alignment is center, return 50 and abort these steps.
 703         return 50;
 704     default:
 705         ASSERT_NOT_REACHED();
 706         return 0;
 707     }
 708 }
 709 
 710 void VTTCue::calculateDisplayParameters()
 711 {
 712     // Steps 10.2, 10.3
 713     determineTextDirection();
 714 
 715     // 10.4 If the text track cue writing direction is horizontal, then let
 716     // block-flow be &#39;tb&#39;. Otherwise, if the text track cue writing direction is
 717     // vertical growing left, then let block-flow be &#39;lr&#39;. Otherwise, the text
 718     // track cue writing direction is vertical growing right; let block-flow be
 719     // &#39;rl&#39;.
 720 
 721     // The above step is done through the writing direction static map.
 722 
 723     // 10.5 Determine the value of maximum size for cue as per the appropriate
 724     // rules from the following list:
 725     double computedTextPosition = calculateComputedTextPosition();
 726     int maximumSize = computedTextPosition;
 727     if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueLtr)
 728         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueRtl)
 729         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Left)
 730         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))
 731         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))) {
 732         maximumSize = 100 - computedTextPosition;
 733     } else if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueLtr)
 734         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueRtl)
 735         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Right)
 736         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))
 737         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))) {
 738         maximumSize = computedTextPosition;
 739     } else if (m_cueAlignment == Center) {
 740         maximumSize = computedTextPosition &lt;= 50 ? computedTextPosition : (100 - computedTextPosition);
 741         maximumSize = maximumSize * 2;
 742     } else
 743         ASSERT_NOT_REACHED();
 744 
 745     // 10.6 If the text track cue size is less than maximum size, then let size
 746     // be text track cue size. Otherwise, let size be maximum size.
 747     m_displaySize = std::min(m_cueSize, maximumSize);
 748 
 749     // FIXME: Understand why step 10.7 is missing (just a copy/paste error?)
 750     // Could be done within a spec implementation check - http://crbug.com/301580
 751 
 752     // 10.8 Determine the value of x-position or y-position for cue as per the
 753     // appropriate rules from the following list:
 754     if (m_writingDirection == Horizontal) {
 755         switch (m_cueAlignment) {
 756         case Start:
 757             if (m_displayDirection == CSSValueLtr)
 758                 m_displayPosition.first = computedTextPosition;
 759             else
 760                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 761             break;
 762         case End:
 763             if (m_displayDirection == CSSValueRtl)
 764                 m_displayPosition.first = 100 - computedTextPosition;
 765             else
 766                 m_displayPosition.first = computedTextPosition - m_displaySize;
 767             break;
 768         case Left:
 769             if (m_displayDirection == CSSValueLtr)
 770                 m_displayPosition.first = computedTextPosition;
 771             else
 772                 m_displayPosition.first = 100 - computedTextPosition;
 773             break;
 774         case Right:
 775             if (m_displayDirection == CSSValueLtr)
 776                 m_displayPosition.first = computedTextPosition - m_displaySize;
 777             else
 778                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 779             break;
 780         case Center:
 781             if (m_displayDirection == CSSValueLtr)
 782                 m_displayPosition.first = computedTextPosition - m_displaySize / 2;
 783             else
 784                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize / 2;
 785             break;
 786         case NumberOfAlignments:
 787             ASSERT_NOT_REACHED();
 788         }
 789     }
 790 
 791     // A text track cue has a text track cue computed line position whose value
 792     // is defined in terms of the other aspects of the cue.
 793     m_computedLinePosition = calculateComputedLinePosition();
 794 
 795     // 10.9 Determine the value of whichever of x-position or y-position is not
 796     // yet calculated for cue as per the appropriate rules from the following
 797     // list:
 798     if (m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 799         m_displayPosition.second = 0;
 800 
 801     if (!m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 802         m_displayPosition.second = m_computedLinePosition;
 803 
 804     if (m_snapToLines &amp;&amp; m_displayPosition.first == undefinedPosition
 805         &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 806         m_displayPosition.first = 0;
 807 
 808     if (!m_snapToLines &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 809         m_displayPosition.first = m_computedLinePosition;
 810 }
 811 
 812 void VTTCue::markFutureAndPastNodes(ContainerNode* root, const MediaTime&amp; previousTimestamp, const MediaTime&amp; movieTime)
 813 {
 814     static NeverDestroyed&lt;const String&gt; timestampTag(MAKE_STATIC_STRING_IMPL(&quot;timestamp&quot;));
 815 
 816     bool isPastNode = true;
 817     MediaTime currentTimestamp = previousTimestamp;
 818     if (currentTimestamp &gt; movieTime)
 819         isPastNode = false;
 820 
 821     for (RefPtr&lt;Node&gt; child = root-&gt;firstChild(); child; child = NodeTraversal::next(*child, root)) {
 822         if (child-&gt;nodeName() == timestampTag) {
 823             MediaTime currentTimestamp;
 824             bool check = WebVTTParser::collectTimeStamp(child-&gt;nodeValue(), currentTimestamp);
 825             ASSERT_UNUSED(check, check);
 826 
 827             currentTimestamp += m_originalStartTime;
 828             if (currentTimestamp &gt; movieTime)
 829                 isPastNode = false;
 830         }
 831 
 832         if (is&lt;WebVTTElement&gt;(*child)) {
 833             downcast&lt;WebVTTElement&gt;(*child).setIsPastNode(isPastNode);
 834             // Make an elemenet id match a cue id for style matching purposes.
 835             if (!id().isEmpty())
 836                 downcast&lt;WebVTTElement&gt;(*child).setIdAttribute(id());
 837         }
 838     }
 839 }
 840 
 841 void VTTCue::updateDisplayTree(const MediaTime&amp; movieTime)
 842 {
 843     // The display tree may contain WebVTT timestamp objects representing
 844     // timestamps (processing instructions), along with displayable nodes.
 845 
 846     if (!track()-&gt;isRendered())
 847         return;
 848 
 849     // Mutating the VTT contents is safe because it&#39;s never exposed to author scripts.
 850     ScriptDisallowedScope::EventAllowedScope allowedScopeForCueHighlightBox(*m_cueHighlightBox);
 851 
 852     // Clear the contents of the set.
 853     m_cueHighlightBox-&gt;removeChildren();
 854 
 855     // Update the two sets containing past and future WebVTT objects.
 856     RefPtr&lt;DocumentFragment&gt; referenceTree = createCueRenderingTree();
 857     if (!referenceTree)
 858         return;
 859 
 860     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*referenceTree);
 861 
 862     markFutureAndPastNodes(referenceTree.get(), startMediaTime(), movieTime);
 863     m_cueHighlightBox-&gt;appendChild(*referenceTree);
 864 }
 865 
 866 VTTCueBox&amp; VTTCue::getDisplayTree(const IntSize&amp; videoSize, int fontSize)
 867 {
 868     Ref&lt;VTTCueBox&gt; displayTree = displayTreeInternal();
 869     if (!m_displayTreeShouldChange || !track()-&gt;isRendered())
 870         return displayTree.get();
 871 
 872     // 10.1 - 10.10
 873     calculateDisplayParameters();
 874 
 875     // 10.11. Apply the terms of the CSS specifications to nodes within the
 876     // following constraints, thus obtaining a set of CSS boxes positioned
 877     // relative to an initial containing block:
 878     displayTree-&gt;removeChildren();
 879 
 880     // The document tree is the tree of WebVTT Node Objects rooted at nodes.
 881 
 882     // The children of the nodes must be wrapped in an anonymous box whose
 883     // &#39;display&#39; property has the value &#39;inline&#39;. This is the WebVTT cue
 884     // background box.
 885 
 886     // Note: This is contained by default in m_cueHighlightBox.
 887     m_cueHighlightBox-&gt;setPseudo(cueShadowPseudoId());
 888 
 889     m_cueBackdropBox-&gt;setPseudo(cueBackdropShadowPseudoId());
 890     m_cueBackdropBox-&gt;appendChild(*m_cueHighlightBox);
 891     displayTree-&gt;appendChild(*m_cueBackdropBox);
 892 
 893     // FIXME(BUG 79916): Runs of children of WebVTT Ruby Objects that are not
 894     // WebVTT Ruby Text Objects must be wrapped in anonymous boxes whose
 895     // &#39;display&#39; property has the value &#39;ruby-base&#39;.
 896 
 897     displayTree-&gt;setFontSizeFromCaptionUserPrefs(fontSize);
 898     displayTree-&gt;applyCSSProperties(videoSize);
 899 
 900     if (displayTree-&gt;document().page()) {
 901         auto cssString = displayTree-&gt;document().page()-&gt;captionUserPreferencesStyleSheet();
 902         auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 903         style-&gt;setTextContent(cssString);
 904         displayTree-&gt;appendChild(style);
 905     }
 906 
 907     const auto&amp; styleSheets = track()-&gt;styleSheets();
 908     if (styleSheets) {
 909         for (const auto&amp; cssString : *styleSheets) {
 910             auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 911             style-&gt;setTextContent(cssString);
 912             displayTree-&gt;appendChild(style);
 913         }
 914     }
 915 
 916     m_displayTreeShouldChange = false;
 917 
 918     // 10.15. Let cue&#39;s text track cue display state have the CSS boxes in
 919     // boxes.
 920     return displayTree.get();
 921 }
 922 
 923 void VTTCue::removeDisplayTree()
 924 {
 925     // The region needs to be informed about the cue removal.
 926     if (m_notifyRegion &amp;&amp; track()) {
 927         if (VTTRegionList* regions = track()-&gt;regions()) {
 928             if (RefPtr&lt;VTTRegion&gt; region = regions-&gt;getRegionById(m_regionId)) {
 929                 if (hasDisplayTree())
 930                     region-&gt;willRemoveTextTrackCueBox(m_displayTree.get());
 931             }
 932         }
 933     }
 934 
 935     if (!hasDisplayTree())
 936         return;
 937 
 938     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
 939     ScriptDisallowedScope::EventAllowedScope allowedScope(displayTreeInternal());
 940     displayTreeInternal().remove();
 941 }
 942 
 943 std::pair&lt;double, double&gt; VTTCue::getPositionCoordinates() const
 944 {
 945     // This method is used for setting x and y when snap to lines is not set.
 946     std::pair&lt;double, double&gt; coordinates;
 947 
 948     auto textPosition = calculateComputedTextPosition();
 949 
 950     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueLtr) {
 951         coordinates.first = textPosition;
 952         coordinates.second = m_computedLinePosition;
 953 
 954         return coordinates;
 955     }
 956 
 957     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueRtl) {
 958         coordinates.first = 100 - textPosition;
 959         coordinates.second = m_computedLinePosition;
 960 
 961         return coordinates;
 962     }
 963 
 964     if (m_writingDirection == VerticalGrowingLeft) {
 965         coordinates.first = 100 - m_computedLinePosition;
 966         coordinates.second = textPosition;
 967 
 968         return coordinates;
 969     }
 970 
 971     if (m_writingDirection == VerticalGrowingRight) {
 972         coordinates.first = m_computedLinePosition;
 973         coordinates.second = textPosition;
 974 
 975         return coordinates;
 976     }
 977 
 978     ASSERT_NOT_REACHED();
 979 
 980     return coordinates;
 981 }
 982 
 983 VTTCue::CueSetting VTTCue::settingName(VTTScanner&amp; input)
 984 {
 985     CueSetting parsedSetting = None;
 986     if (input.scan(&quot;vertical&quot;))
 987         parsedSetting = Vertical;
 988     else if (input.scan(&quot;line&quot;))
 989         parsedSetting = Line;
 990     else if (input.scan(&quot;position&quot;))
 991         parsedSetting = Position;
 992     else if (input.scan(&quot;size&quot;))
 993         parsedSetting = Size;
 994     else if (input.scan(&quot;align&quot;))
 995         parsedSetting = Align;
 996     else if (input.scan(&quot;region&quot;))
 997         parsedSetting = RegionId;
 998 
 999     // Verify that a &#39;:&#39; follows.
1000     if (parsedSetting != None &amp;&amp; input.scan(&#39;:&#39;))
1001         return parsedSetting;
1002 
1003     return None;
1004 }
1005 
1006 void VTTCue::setCueSettings(const String&amp; inputString)
1007 {
1008     if (inputString.isEmpty())
1009         return;
1010 
1011     VTTScanner input(inputString);
1012 
1013     while (!input.isAtEnd()) {
1014 
1015         // The WebVTT cue settings part of a WebVTT cue consists of zero or more of the following components, in any order,
1016         // separated from each other by one or more U+0020 SPACE characters or U+0009 CHARACTER TABULATION (tab) characters.
1017         input.skipWhile&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1018         if (input.isAtEnd())
1019             break;
1020 
1021         // When the user agent is to parse the WebVTT settings given by a string input for a text track cue cue,
1022         // the user agent must run the following steps:
1023         // 1. Let settings be the result of splitting input on spaces.
1024         // 2. For each token setting in the list settings, run the following substeps:
1025         //    1. If setting does not contain a U+003A COLON character (:), or if the first U+003A COLON character (:)
1026         //       in setting is either the first or last character of setting, then jump to the step labeled next setting.
1027         //    2. Let name be the leading substring of setting up to and excluding the first U+003A COLON character (:) in that string.
1028         CueSetting name = settingName(input);
1029 
1030         // 3. Let value be the trailing substring of setting starting from the character immediately after the first U+003A COLON character (:) in that string.
1031         VTTScanner::Run valueRun = input.collectUntil&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1032 
1033         // 4. Run the appropriate substeps that apply for the value of name, as follows:
1034         switch (name) {
1035         case Vertical: {
1036             // If name is a case-sensitive match for &quot;vertical&quot;
1037             // 1. If value is a case-sensitive match for the string &quot;rl&quot;, then let cue&#39;s text track cue writing direction
1038             //    be vertical growing left.
1039             if (input.scanRun(valueRun, verticalGrowingLeftKeyword()))
1040                 m_writingDirection = VerticalGrowingLeft;
1041 
1042             // 2. Otherwise, if value is a case-sensitive match for the string &quot;lr&quot;, then let cue&#39;s text track cue writing
1043             //    direction be vertical growing right.
1044             else if (input.scanRun(valueRun, verticalGrowingRightKeyword()))
1045                 m_writingDirection = VerticalGrowingRight;
1046 
1047             else
1048                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Vertical&quot;);
1049             break;
1050         }
1051         case Line: {
1052             bool isValid = false;
1053             do {
1054                 // 1-2 - Collect chars that are either &#39;-&#39;, &#39;%&#39;, or a digit.
1055                 // 1. If value contains any characters other than U+002D HYPHEN-MINUS characters (-), U+0025 PERCENT SIGN
1056                 //    characters (%), and characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9), then jump
1057                 //    to the step labeled next setting.
1058                 float linePosition;
1059                 bool isNegative;
1060                 if (!input.scanFloat(linePosition, &amp;isNegative))
1061                     break;
1062 
1063                 bool isPercentage = input.scan(&#39;%&#39;);
1064                 if (!input.isAt(valueRun.end())) {
1065                     if (!input.scan(&#39;,&#39;))
1066                         break;
1067                     // FIXME: implement handling of line setting alignment.
1068                     if (!input.scan(startKeyword().characters8(), startKeyword().length())
1069                         &amp;&amp; !input.scan(centerKeyword().characters8(), centerKeyword().length())
1070                         &amp;&amp; !input.scan(endKeyword().characters8(), endKeyword().length())) {
1071                         LOG(Media, &quot;VTTCue::setCueSettings, invalid line setting alignment&quot;);
1072                         break;
1073                     }
1074                 }
1075 
1076                 // 2. If value does not contain at least one character in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
1077                 //    NINE (9), then jump to the step labeled next setting.
1078                 // 3. If any character in value other than the first character is a U+002D HYPHEN-MINUS character (-), then
1079                 //    jump to the step labeled next setting.
1080                 // 4. If any character in value other than the last character is a U+0025 PERCENT SIGN character (%), then
1081                 //    jump to the step labeled next setting.
1082                 // 5. If the first character in value is a U+002D HYPHEN-MINUS character (-) and the last character in value is a
1083                 //    U+0025 PERCENT SIGN character (%), then jump to the step labeled next setting.
1084                 if (isPercentage &amp;&amp; isNegative)
1085                     break;
1086 
1087                 // 6. Ignoring the trailing percent sign, if any, interpret value as a (potentially signed) integer, and
1088                 //    let number be that number.
1089                 // 7. If the last character in value is a U+0025 PERCENT SIGN character (%), but number is not in the range
1090                 //    0 ≤ number ≤ 100, then jump to the step labeled next setting.
1091                 // 8. Let cue&#39;s text track cue line position be number.
1092                 // 9. If the last character in value is a U+0025 PERCENT SIGN character (%), then let cue&#39;s text track cue
1093                 //    snap-to-lines flag be false. Otherwise, let it be true.
1094                 if (isPercentage) {
1095                     if (linePosition &lt; 0 || linePosition &gt; 100)
1096                         break;
1097 
1098                     // 10 - If &#39;%&#39; then set snap-to-lines flag to false.
1099                     m_snapToLines = false;
1100                 } else {
1101                     if (linePosition - static_cast&lt;int&gt;(linePosition))
1102                         break;
1103 
1104                     m_snapToLines = true;
1105                 }
1106 
1107                 m_linePosition = linePosition;
1108                 isValid = true;
1109             } while (0);
1110 
1111             if (!isValid)
1112                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Line&quot;);
1113 
1114             break;
1115         }
1116         case Position: {
1117             float position;
1118             if (WebVTTParser::parseFloatPercentageValue(input, position) &amp;&amp; input.isAt(valueRun.end()))
1119                 m_textPosition = position;
1120             else
1121                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Position&quot;);
1122             break;
1123         }
1124         case Size: {
1125             float cueSize;
1126             if (WebVTTParser::parseFloatPercentageValue(input, cueSize) &amp;&amp; input.isAt(valueRun.end()))
1127                 m_cueSize = cueSize;
1128             else
1129                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Size&quot;);
1130             break;
1131         }
1132         case Align: {
1133             // 1. If value is a case-sensitive match for the string &quot;start&quot;, then let cue&#39;s text track cue alignment be start alignment.
1134             if (input.scanRun(valueRun, startKeyword()))
1135                 m_cueAlignment = Start;
1136 
1137             // 2. If value is a case-sensitive match for the string &quot;center&quot;, then let cue&#39;s text track cue alignment be center alignment.
1138             else if (input.scanRun(valueRun, centerKeyword()))
1139                 m_cueAlignment = Center;
1140 
1141             // 3. If value is a case-sensitive match for the string &quot;end&quot;, then let cue&#39;s text track cue alignment be end alignment.
1142             else if (input.scanRun(valueRun, endKeyword()))
1143                 m_cueAlignment = End;
1144 
1145             // 4. If value is a case-sensitive match for the string &quot;left&quot;, then let cue&#39;s text track cue alignment be left alignment.
1146             else if (input.scanRun(valueRun, leftKeyword()))
1147                 m_cueAlignment = Left;
1148 
1149             // 5. If value is a case-sensitive match for the string &quot;right&quot;, then let cue&#39;s text track cue alignment be right alignment.
1150             else if (input.scanRun(valueRun, rightKeyword()))
1151                 m_cueAlignment = Right;
1152 
1153             else
1154                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Align&quot;);
1155 
1156             break;
1157         }
1158         case RegionId:
1159             m_regionId = input.extractString(valueRun);
1160             break;
1161         case None:
1162             break;
1163         }
1164 
1165         // Make sure the entire run is consumed.
1166         input.skipRun(valueRun);
1167     }
1168 
1169     // If cue&#39;s line position is not auto or cue&#39;s size is not 100 or cue&#39;s
1170     // writing direction is not horizontal, but cue&#39;s region identifier is not
1171     // the empty string, let cue&#39;s region identifier be the empty string.
1172     if (m_regionId.isEmpty())
1173         return;
1174 
1175     if (m_linePosition != undefinedPosition || m_cueSize != 100 || m_writingDirection != Horizontal)
1176         m_regionId = emptyString();
1177 }
1178 
1179 CSSValueID VTTCue::getCSSAlignment() const
1180 {
1181     return displayAlignmentMap[m_cueAlignment];
1182 }
1183 
1184 CSSValueID VTTCue::getCSSWritingDirection() const
1185 {
1186     return m_displayDirection;
1187 }
1188 
1189 CSSValueID VTTCue::getCSSWritingMode() const
1190 {
1191     return displayWritingModeMap[m_writingDirection];
1192 }
1193 
1194 int VTTCue::getCSSSize() const
1195 {
1196     return m_displaySize;
1197 }
1198 
1199 std::pair&lt;double, double&gt; VTTCue::getCSSPosition() const
1200 {
1201     if (!m_snapToLines)
1202         return getPositionCoordinates();
1203 
1204     return m_displayPosition;
1205 }
1206 
1207 bool VTTCue::cueContentsMatch(const TextTrackCue&amp; cue) const
1208 {
1209     RefPtr&lt;const VTTCue&gt; vttCue = toVTTCue(&amp;cue);
1210     if (text() != vttCue-&gt;text())
1211         return false;
1212     if (cueSettings() != vttCue-&gt;cueSettings())
1213         return false;
1214     if (position() != vttCue-&gt;position())
1215         return false;
1216     if (line() != vttCue-&gt;line())
1217         return false;
1218     if (size() != vttCue-&gt;size())
1219         return false;
1220     if (align() != vttCue-&gt;align())
1221         return false;
1222 
1223     return true;
1224 }
1225 
1226 bool VTTCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
1227 {
1228     if (!TextTrackCue::isEqual(cue, match))
1229         return false;
1230 
1231     if (cue.cueType() != WebVTT)
1232         return false;
1233 
1234     return cueContentsMatch(cue);
1235 }
1236 
1237 bool VTTCue::doesExtendCue(const TextTrackCue&amp; cue) const
1238 {
1239     if (!cueContentsMatch(cue))
1240         return false;
1241 
1242     return TextTrackCue::doesExtendCue(cue);
1243 }
1244 
1245 void VTTCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
1246 {
1247     if (!hasDisplayTree() || !fontSize)
1248         return;
1249 
1250     m_displayTreeShouldChange = true;
1251     displayTreeInternal().setInlineStyleProperty(CSSPropertyFontSize, fontSize, CSSPrimitiveValue::CSS_PX, important);
1252 }
1253 
1254 VTTCue* toVTTCue(TextTrackCue* cue)
1255 {
1256     return const_cast&lt;VTTCue*&gt;(toVTTCue(const_cast&lt;const TextTrackCue*&gt;(cue)));
1257 }
1258 
1259 const VTTCue* toVTTCue(const TextTrackCue* cue)
1260 {
1261     ASSERT_WITH_SECURITY_IMPLICATION(cue-&gt;isRenderable());
1262     return static_cast&lt;const VTTCue*&gt;(cue);
1263 }
1264 
1265 String VTTCue::toJSONString() const
1266 {
1267     auto object = JSON::Object::create();
1268     toJSON(object.get());
1269 
1270     return object-&gt;toJSONString();
1271 }
1272 
1273 void VTTCue::toJSON(JSON::Object&amp; object) const
1274 {
1275     TextTrackCue::toJSON(object);
1276 
1277 #if !LOG_DISABLED
1278     object.setString(&quot;text&quot;_s, text());
1279 #endif
1280     object.setString(&quot;vertical&quot;_s, vertical());
1281     object.setBoolean(&quot;snapToLines&quot;_s, snapToLines());
1282     object.setDouble(&quot;line&quot;_s, m_linePosition);
1283     if (textPositionIsAuto())
1284         object.setString(&quot;position&quot;_s, &quot;auto&quot;);
1285     else
1286         object.setDouble(&quot;position&quot;_s, m_textPosition);
1287     object.setInteger(&quot;size&quot;_s, m_cueSize);
1288     object.setString(&quot;align&quot;_s, align());
1289     object.setString(&quot;regionId&quot;_s, regionId());
1290 }
1291 
1292 } // namespace WebCore
1293 
1294 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>