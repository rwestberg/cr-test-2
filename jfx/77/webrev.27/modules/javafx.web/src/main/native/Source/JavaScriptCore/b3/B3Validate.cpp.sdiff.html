<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Validate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3UseCounts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3Value.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Validate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55 public:
 56     Validater(Procedure&amp; procedure, const char* dumpBefore)
 57         : m_procedure(procedure)
 58         , m_dumpBefore(dumpBefore)
 59     {
 60     }
 61 
 62 #define VALIDATE(condition, message) do {                               \
 63         if (condition)                                                  \
 64             break;                                                      \
 65         fail(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition, toCString message); \
 66     } while (false)
 67 
 68     void run()
 69     {
 70         HashSet&lt;BasicBlock*&gt; blocks;
 71         HashSet&lt;Value*&gt; valueInProc;
 72         HashMap&lt;Value*, unsigned&gt; valueInBlock;
 73         HashMap&lt;Value*, BasicBlock*&gt; valueOwner;
 74         HashMap&lt;Value*, unsigned&gt; valueIndex;







 75 
 76         for (BasicBlock* block : m_procedure) {
 77             blocks.add(block);
 78             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 79                 Value* value = block-&gt;at(i);
 80                 valueInBlock.add(value, 0).iterator-&gt;value++;
 81                 valueOwner.add(value, block);
 82                 valueIndex.add(value, i);
 83             }
 84         }
 85 
 86         for (Value* value : m_procedure.values())
 87             valueInProc.add(value);
 88 
 89         for (Value* value : valueInProc)
 90             VALIDATE(valueInBlock.contains(value), (&quot;At &quot;, *value));
 91         for (auto&amp; entry : valueInBlock) {
 92             VALIDATE(valueInProc.contains(entry.key), (&quot;At &quot;, *entry.key));
 93             VALIDATE(entry.value == 1, (&quot;At &quot;, *entry.key));
 94         }
</pre>
<hr />
<pre>
187                 VALIDATE(
188                     (value-&gt;as&lt;ArgumentRegValue&gt;()-&gt;argumentReg().isGPR() ? pointerType() : Double)
189                     == value-&gt;type(), (&quot;At &quot;, *value));
190                 break;
191             case Add:
192             case Sub:
193             case Mul:
194             case Div:
195             case UDiv:
196             case Mod:
197             case UMod:
198             case BitAnd:
199             case BitOr:
200             case BitXor:
201                 VALIDATE(!value-&gt;kind().traps(), (&quot;At &quot;, *value));
202                 switch (value-&gt;opcode()) {
203                 case Div:
204                 case Mod:
205                     if (value-&gt;isChill()) {
206                         VALIDATE(value-&gt;opcode() == Div || value-&gt;opcode() == Mod, (&quot;At &quot;, *value));
<span class="line-modified">207                         VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
208                     }
209                     break;
210                 default:
211                     VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
212                     break;
213                 }
214                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
215                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
216                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">217                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));</span>
218                 break;
219             case Neg:
220                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
221                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
222                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">223                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));</span>
224                 break;
225             case Shl:
226             case SShr:
227             case ZShr:
228             case RotR:
229                 case RotL:
230                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
231                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
232                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
233                 VALIDATE(value-&gt;child(1)-&gt;type() == Int32, (&quot;At &quot;, *value));
<span class="line-modified">234                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
235                 break;
236             case BitwiseCast:
237                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
238                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
239                 VALIDATE(value-&gt;type() != value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
240                 VALIDATE(
241                     (value-&gt;type() == Int64 &amp;&amp; value-&gt;child(0)-&gt;type() == Double)
242                     || (value-&gt;type() == Double &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
243                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Int32)
244                     || (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Float),
245                     (&quot;At &quot;, *value));
246                 break;
247             case SExt8:
248             case SExt16:
249                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
250                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
251                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
252                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
253                 break;
254             case SExt32:
255             case ZExt32:
256                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
257                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
258                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
259                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
260                 break;
261             case Clz:
262                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
263                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">264                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
<span class="line-modified">265                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
266                 break;
267             case Trunc:
268                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
269                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
270                 VALIDATE(
271                     (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
272                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Double),
273                     (&quot;At &quot;, *value));
274                 break;
275             case Abs:
276             case Ceil:
277             case Floor:
278             case Sqrt:
279                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
280                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">281                 VALIDATE(isFloat(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
<span class="line-modified">282                 VALIDATE(isFloat(value-&gt;type()), (&quot;At &quot;, *value));</span>
283                 break;
284             case IToD:
285                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
286                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">287                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
288                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
289                 break;
290             case IToF:
291                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
292                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">293                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
294                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
295                 break;
296             case FloatToDouble:
297                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
298                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
299                 VALIDATE(value-&gt;child(0)-&gt;type() == Float, (&quot;At &quot;, *value));
300                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
301                 break;
302             case DoubleToFloat:
303                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
304                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
305                 VALIDATE(value-&gt;child(0)-&gt;type() == Double, (&quot;At &quot;, *value));
306                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
307                 break;
308             case Equal:
309             case NotEqual:
310             case LessThan:
311             case GreaterThan:
312             case LessEqual:
313             case GreaterEqual:
314                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
315                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
316                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
317                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
318                 break;
319             case Above:
320             case Below:
321             case AboveEqual:
322             case BelowEqual:
323                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
324                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
325                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">326                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
327                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
328                 break;
329             case EqualOrUnordered:
330                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
331                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
332                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">333                 VALIDATE(isFloat(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
334                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
335                 break;
336             case Select:
337                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
338                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
<span class="line-modified">339                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
340                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
341                 VALIDATE(value-&gt;type() == value-&gt;child(2)-&gt;type(), (&quot;At &quot;, *value));
342                 break;
343             case Load8Z:
344             case Load8S:
345             case Load16Z:
346             case Load16S:
347                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
348                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
349                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
350                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
351                 validateFence(value);
352                 validateStackAccess(value);
353                 break;
354             case Load:
355                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
356                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
357                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
<span class="line-modified">358                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));</span>
359                 validateFence(value);
360                 validateStackAccess(value);
361                 break;
362             case Store8:
363             case Store16:
364                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
365                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
366                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
367                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
368                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
369                 validateFence(value);
370                 validateStackAccess(value);
371                 break;
372             case Store:
373                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
374                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
375                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
376                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
377                 validateFence(value);
378                 validateStackAccess(value);
379                 break;
380             case AtomicWeakCAS:
381                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
382                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
383                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
384                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">385                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
386                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
387                 validateAtomic(value);
388                 validateStackAccess(value);
389                 break;
390             case AtomicStrongCAS:
391                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
392                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
393                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
394                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">395                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
396                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
397                 validateAtomic(value);
398                 validateStackAccess(value);
399                 break;
400             case AtomicXchgAdd:
401             case AtomicXchgAnd:
402             case AtomicXchgOr:
403             case AtomicXchgSub:
404             case AtomicXchgXor:
405             case AtomicXchg:
406                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
407                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
408                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">409                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
410                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
411                 validateAtomic(value);
412                 validateStackAccess(value);
413                 break;
414             case Depend:
415                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
416                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
417                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">418                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));</span>
419                 break;
420             case WasmAddress:
421                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
422                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
423                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
424                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
425                 break;
426             case CCall:
427                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
428                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
429                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
430                 break;
431             case Patchpoint:
432                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
<span class="line-modified">433                 if (value-&gt;type() == Void)</span>
<span class="line-modified">434                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraint == ValueRep::WarmAny, (&quot;At &quot;, *value));</span>
<span class="line-modified">435                 else</span>
<span class="line-modified">436                     validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraint), ConstraintRole::Def);</span>










437                 validateStackmap(value);
438                 break;






439             case CheckAdd:
440             case CheckSub:
441             case CheckMul:
442                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
443                 VALIDATE(value-&gt;numChildren() &gt;= 2, (&quot;At &quot;, *value));
<span class="line-modified">444                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
<span class="line-modified">445                 VALIDATE(isInt(value-&gt;child(1)-&gt;type()), (&quot;At &quot;, *value));</span>
446                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
447                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(1).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
448                 validateStackmap(value);
449                 break;
450             case Check:
451                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
452                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
<span class="line-modified">453                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
454                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
455                 validateStackmap(value);
456                 break;
457             case WasmBoundsCheck:
458                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
459                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
460                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
461                 switch (value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;boundsType()) {
462                 case WasmBoundsCheckValue::Type::Pinned:
463                     VALIDATE(m_procedure.code().isPinned(value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;bounds().pinnedSize), (&quot;At &quot;, *value));
464                     break;
465                 case WasmBoundsCheckValue::Type::Maximum:
466                     break;
467                 }
468                 VALIDATE(m_procedure.code().wasmBoundsCheckGenerator(), (&quot;At &quot;, *value));
469                 break;
470             case Upsilon:
471                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
472                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
473                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi(), (&quot;At &quot;, *value));
474                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;opcode() == Phi, (&quot;At &quot;, *value));

475                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;type(), (&quot;At &quot;, *value));
476                 VALIDATE(valueInProc.contains(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()), (&quot;At &quot;, *value));
477                 break;
478             case Phi:
479                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
480                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
481                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
482                 break;
483             case Jump:
484                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
485                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
486                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
487                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 1, (&quot;At &quot;, *value));
488                 break;
489             case Oops:
490                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
491                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
492                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
493                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
494                 break;
495             case Return:
496                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
497                 VALIDATE(value-&gt;numChildren() &lt;= 1, (&quot;At &quot;, *value));
498                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
499                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
500                 break;
501             case Branch:
502                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
503                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">504                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
505                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
506                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 2, (&quot;At &quot;, *value));
507                 break;
508             case Switch: {
509                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
510                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">511                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));</span>
512                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
513                 VALIDATE(value-&gt;as&lt;SwitchValue&gt;()-&gt;hasFallThrough(valueOwner.get(value)), (&quot;At &quot;, *value));
514                 // This validates the same thing as hasFallThrough, but more explicitly. We want to
515                 // make sure that if anyone tries to change the definition of hasFallThrough, they
516                 // will feel some pain here, since this is fundamental.
517                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == value-&gt;as&lt;SwitchValue&gt;()-&gt;numCaseValues() + 1, (&quot;At &quot;, *value));
518 
519                 // Check that there are no duplicate cases.
520                 Vector&lt;int64_t&gt; caseValues = value-&gt;as&lt;SwitchValue&gt;()-&gt;caseValues();
521                 std::sort(caseValues.begin(), caseValues.end());
522                 for (unsigned i = 1; i &lt; caseValues.size(); ++i)
523                     VALIDATE(caseValues[i - 1] != caseValues[i], (&quot;At &quot;, *value, &quot;, caseValue = &quot;, caseValues[i]));
524                 break;
525             }
526             case EntrySwitch:
527                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
528                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
529                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
530                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == m_procedure.numEntrypoints(), (&quot;At &quot;, *value));
531                 break;
</pre>
<hr />
<pre>
543             for (BasicBlock* predecessor : block-&gt;predecessors())
544                 predecessors.add(predecessor);
545             VALIDATE(block-&gt;numPredecessors() == predecessors.size(), (&quot;At &quot;, *block));
546         }
547     }
548 
549 private:
550     void validateStackmap(Value* value)
551     {
552         StackmapValue* stackmap = value-&gt;as&lt;StackmapValue&gt;();
553         VALIDATE(stackmap, (&quot;At &quot;, *value));
554         VALIDATE(stackmap-&gt;numChildren() &gt;= stackmap-&gt;reps().size(), (&quot;At &quot;, *stackmap));
555         for (ConstrainedValue child : stackmap-&gt;constrainedChildren())
556             validateStackmapConstraint(stackmap, child);
557     }
558 
559     enum class ConstraintRole {
560         Use,
561         Def
562     };
<span class="line-modified">563     void validateStackmapConstraint(Value* context, const ConstrainedValue&amp; value, ConstraintRole role = ConstraintRole::Use)</span>
564     {
565         switch (value.rep().kind()) {
566         case ValueRep::WarmAny:
567         case ValueRep::SomeRegister:
568         case ValueRep::StackArgument:
569             break;
570         case ValueRep::LateColdAny:
571         case ValueRep::ColdAny:
572             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
573             break;
574         case ValueRep::SomeRegisterWithClobber:
575             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
576             VALIDATE(context-&gt;as&lt;PatchpointValue&gt;(), (&quot;At &quot;, *context));
577             break;
578         case ValueRep::SomeEarlyRegister:
579             VALIDATE(role == ConstraintRole::Def, (&quot;At &quot;, *context, &quot;: &quot;, value));
580             break;
581         case ValueRep::Register:
582         case ValueRep::LateRegister:

583             if (value.rep().kind() == ValueRep::LateRegister)
584                 VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
<span class="line-modified">585             if (value.rep().reg().isGPR())</span>
<span class="line-modified">586                 VALIDATE(isInt(value.value()-&gt;type()), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-modified">587             else</span>
<span class="line-modified">588                 VALIDATE(isFloat(value.value()-&gt;type()), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>







589             break;
590         default:
591             VALIDATE(false, (&quot;At &quot;, *context, &quot;: &quot;, value));
592             break;
593         }
594     }
595 
596     void validateFence(Value* value)
597     {
598         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
599         if (memory-&gt;hasFence())
600             VALIDATE(memory-&gt;accessBank() == GP, (&quot;Fence at &quot;, *memory));
601     }
602 
603     void validateAtomic(Value* value)
604     {
605         AtomicValue* atomic = value-&gt;as&lt;AtomicValue&gt;();
606 
607         VALIDATE(bestType(GP, atomic-&gt;accessWidth()) == atomic-&gt;accessType(), (&quot;At &quot;, *value));
608     }
</pre>
</td>
<td>
<hr />
<pre>
 55 public:
 56     Validater(Procedure&amp; procedure, const char* dumpBefore)
 57         : m_procedure(procedure)
 58         , m_dumpBefore(dumpBefore)
 59     {
 60     }
 61 
 62 #define VALIDATE(condition, message) do {                               \
 63         if (condition)                                                  \
 64             break;                                                      \
 65         fail(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition, toCString message); \
 66     } while (false)
 67 
 68     void run()
 69     {
 70         HashSet&lt;BasicBlock*&gt; blocks;
 71         HashSet&lt;Value*&gt; valueInProc;
 72         HashMap&lt;Value*, unsigned&gt; valueInBlock;
 73         HashMap&lt;Value*, BasicBlock*&gt; valueOwner;
 74         HashMap&lt;Value*, unsigned&gt; valueIndex;
<span class="line-added"> 75         HashMap&lt;Value*, Vector&lt;Optional&lt;Type&gt;&gt;&gt; extractions;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77         for (unsigned tuple = 0; tuple &lt; m_procedure.tuples().size(); ++tuple) {</span>
<span class="line-added"> 78             VALIDATE(m_procedure.tuples()[tuple].size(), (&quot;In tuple &quot;, tuple));</span>
<span class="line-added"> 79             for (unsigned i = 0; i &lt; m_procedure.tuples()[tuple].size(); ++i)</span>
<span class="line-added"> 80                 VALIDATE(m_procedure.tuples()[tuple][i].isNumeric(), (&quot;In tuple &quot;, tuple, &quot; at index&quot;, i));</span>
<span class="line-added"> 81         }</span>
 82 
 83         for (BasicBlock* block : m_procedure) {
 84             blocks.add(block);
 85             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 86                 Value* value = block-&gt;at(i);
 87                 valueInBlock.add(value, 0).iterator-&gt;value++;
 88                 valueOwner.add(value, block);
 89                 valueIndex.add(value, i);
 90             }
 91         }
 92 
 93         for (Value* value : m_procedure.values())
 94             valueInProc.add(value);
 95 
 96         for (Value* value : valueInProc)
 97             VALIDATE(valueInBlock.contains(value), (&quot;At &quot;, *value));
 98         for (auto&amp; entry : valueInBlock) {
 99             VALIDATE(valueInProc.contains(entry.key), (&quot;At &quot;, *entry.key));
100             VALIDATE(entry.value == 1, (&quot;At &quot;, *entry.key));
101         }
</pre>
<hr />
<pre>
194                 VALIDATE(
195                     (value-&gt;as&lt;ArgumentRegValue&gt;()-&gt;argumentReg().isGPR() ? pointerType() : Double)
196                     == value-&gt;type(), (&quot;At &quot;, *value));
197                 break;
198             case Add:
199             case Sub:
200             case Mul:
201             case Div:
202             case UDiv:
203             case Mod:
204             case UMod:
205             case BitAnd:
206             case BitOr:
207             case BitXor:
208                 VALIDATE(!value-&gt;kind().traps(), (&quot;At &quot;, *value));
209                 switch (value-&gt;opcode()) {
210                 case Div:
211                 case Mod:
212                     if (value-&gt;isChill()) {
213                         VALIDATE(value-&gt;opcode() == Div || value-&gt;opcode() == Mod, (&quot;At &quot;, *value));
<span class="line-modified">214                         VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
215                     }
216                     break;
217                 default:
218                     VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
219                     break;
220                 }
221                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
222                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
223                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">224                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
225                 break;
226             case Neg:
227                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
228                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
229                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">230                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
231                 break;
232             case Shl:
233             case SShr:
234             case ZShr:
235             case RotR:
236                 case RotL:
237                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
238                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
239                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
240                 VALIDATE(value-&gt;child(1)-&gt;type() == Int32, (&quot;At &quot;, *value));
<span class="line-modified">241                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
242                 break;
243             case BitwiseCast:
244                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
245                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
246                 VALIDATE(value-&gt;type() != value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
247                 VALIDATE(
248                     (value-&gt;type() == Int64 &amp;&amp; value-&gt;child(0)-&gt;type() == Double)
249                     || (value-&gt;type() == Double &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
250                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Int32)
251                     || (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Float),
252                     (&quot;At &quot;, *value));
253                 break;
254             case SExt8:
255             case SExt16:
256                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
257                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
258                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
259                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
260                 break;
261             case SExt32:
262             case ZExt32:
263                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
264                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
265                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
266                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
267                 break;
268             case Clz:
269                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
270                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">271                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
<span class="line-modified">272                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
273                 break;
274             case Trunc:
275                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
276                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
277                 VALIDATE(
278                     (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
279                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Double),
280                     (&quot;At &quot;, *value));
281                 break;
282             case Abs:
283             case Ceil:
284             case Floor:
285             case Sqrt:
286                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
287                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">288                 VALIDATE(value-&gt;child(0)-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
<span class="line-modified">289                 VALIDATE(value-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
290                 break;
291             case IToD:
292                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
293                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">294                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
295                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
296                 break;
297             case IToF:
298                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
299                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">300                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
301                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
302                 break;
303             case FloatToDouble:
304                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
305                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
306                 VALIDATE(value-&gt;child(0)-&gt;type() == Float, (&quot;At &quot;, *value));
307                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
308                 break;
309             case DoubleToFloat:
310                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
311                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
312                 VALIDATE(value-&gt;child(0)-&gt;type() == Double, (&quot;At &quot;, *value));
313                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
314                 break;
315             case Equal:
316             case NotEqual:
317             case LessThan:
318             case GreaterThan:
319             case LessEqual:
320             case GreaterEqual:
321                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
322                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
323                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
324                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
325                 break;
326             case Above:
327             case Below:
328             case AboveEqual:
329             case BelowEqual:
330                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
331                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
332                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">333                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
334                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
335                 break;
336             case EqualOrUnordered:
337                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
338                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
339                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">340                 VALIDATE(value-&gt;child(0)-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
341                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
342                 break;
343             case Select:
344                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
345                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
<span class="line-modified">346                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
347                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
348                 VALIDATE(value-&gt;type() == value-&gt;child(2)-&gt;type(), (&quot;At &quot;, *value));
349                 break;
350             case Load8Z:
351             case Load8S:
352             case Load16Z:
353             case Load16S:
354                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
355                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
356                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
357                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
358                 validateFence(value);
359                 validateStackAccess(value);
360                 break;
361             case Load:
362                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
363                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
364                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
<span class="line-modified">365                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
366                 validateFence(value);
367                 validateStackAccess(value);
368                 break;
369             case Store8:
370             case Store16:
371                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
372                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
373                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
374                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
375                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
376                 validateFence(value);
377                 validateStackAccess(value);
378                 break;
379             case Store:
380                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
381                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
382                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
383                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
384                 validateFence(value);
385                 validateStackAccess(value);
386                 break;
387             case AtomicWeakCAS:
388                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
389                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
390                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
391                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">392                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
393                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
394                 validateAtomic(value);
395                 validateStackAccess(value);
396                 break;
397             case AtomicStrongCAS:
398                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
399                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
400                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
401                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">402                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
403                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
404                 validateAtomic(value);
405                 validateStackAccess(value);
406                 break;
407             case AtomicXchgAdd:
408             case AtomicXchgAnd:
409             case AtomicXchgOr:
410             case AtomicXchgSub:
411             case AtomicXchgXor:
412             case AtomicXchg:
413                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
414                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
415                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">416                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
417                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
418                 validateAtomic(value);
419                 validateStackAccess(value);
420                 break;
421             case Depend:
422                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
423                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
424                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<span class="line-modified">425                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
426                 break;
427             case WasmAddress:
428                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
429                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
430                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
431                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
432                 break;
433             case CCall:
434                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
435                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
436                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
437                 break;
438             case Patchpoint:
439                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
<span class="line-modified">440                 if (value-&gt;type() == Void) {</span>
<span class="line-modified">441                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == 1, (&quot;At &quot;, *value));</span>
<span class="line-modified">442                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[0] == ValueRep::WarmAny, (&quot;At &quot;, *value));</span>
<span class="line-modified">443                 } else {</span>
<span class="line-added">444                     if (value-&gt;type().isNumeric()) {</span>
<span class="line-added">445                         VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == 1, (&quot;At &quot;, *value));</span>
<span class="line-added">446                         validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[0]), ConstraintRole::Def);</span>
<span class="line-added">447                     } else {</span>
<span class="line-added">448                         VALIDATE(m_procedure.isValidTuple(value-&gt;type()), (&quot;At &quot;, *value));</span>
<span class="line-added">449                         VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == m_procedure.tupleForType(value-&gt;type()).size(), (&quot;At &quot;, *value));</span>
<span class="line-added">450                         for (unsigned i = 0; i &lt; value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size(); ++i)</span>
<span class="line-added">451                             validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[i]), ConstraintRole::Def, i);</span>
<span class="line-added">452                     }</span>
<span class="line-added">453                 }</span>
454                 validateStackmap(value);
455                 break;
<span class="line-added">456             case Extract: {</span>
<span class="line-added">457                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));</span>
<span class="line-added">458                 VALIDATE(value-&gt;child(0)-&gt;type() == Tuple, (&quot;At &quot;, *value));</span>
<span class="line-added">459                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
<span class="line-added">460                 break;</span>
<span class="line-added">461             }</span>
462             case CheckAdd:
463             case CheckSub:
464             case CheckMul:
465                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
466                 VALIDATE(value-&gt;numChildren() &gt;= 2, (&quot;At &quot;, *value));
<span class="line-modified">467                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
<span class="line-modified">468                 VALIDATE(value-&gt;child(1)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
469                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
470                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(1).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
471                 validateStackmap(value);
472                 break;
473             case Check:
474                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
475                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
<span class="line-modified">476                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
477                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
478                 validateStackmap(value);
479                 break;
480             case WasmBoundsCheck:
481                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
482                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
483                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
484                 switch (value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;boundsType()) {
485                 case WasmBoundsCheckValue::Type::Pinned:
486                     VALIDATE(m_procedure.code().isPinned(value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;bounds().pinnedSize), (&quot;At &quot;, *value));
487                     break;
488                 case WasmBoundsCheckValue::Type::Maximum:
489                     break;
490                 }
491                 VALIDATE(m_procedure.code().wasmBoundsCheckGenerator(), (&quot;At &quot;, *value));
492                 break;
493             case Upsilon:
494                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
495                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
496                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi(), (&quot;At &quot;, *value));
497                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;opcode() == Phi, (&quot;At &quot;, *value));
<span class="line-added">498                 VALIDATE(value-&gt;child(0)-&gt;type() != Void, (&quot;At &quot;, *value));</span>
499                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;type(), (&quot;At &quot;, *value));
500                 VALIDATE(valueInProc.contains(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()), (&quot;At &quot;, *value));
501                 break;
502             case Phi:
503                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
504                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
505                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
506                 break;
507             case Jump:
508                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
509                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
510                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
511                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 1, (&quot;At &quot;, *value));
512                 break;
513             case Oops:
514                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
515                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
516                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
517                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
518                 break;
519             case Return:
520                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
521                 VALIDATE(value-&gt;numChildren() &lt;= 1, (&quot;At &quot;, *value));
522                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
523                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
524                 break;
525             case Branch:
526                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
527                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">528                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
529                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
530                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 2, (&quot;At &quot;, *value));
531                 break;
532             case Switch: {
533                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
534                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<span class="line-modified">535                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
536                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
537                 VALIDATE(value-&gt;as&lt;SwitchValue&gt;()-&gt;hasFallThrough(valueOwner.get(value)), (&quot;At &quot;, *value));
538                 // This validates the same thing as hasFallThrough, but more explicitly. We want to
539                 // make sure that if anyone tries to change the definition of hasFallThrough, they
540                 // will feel some pain here, since this is fundamental.
541                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == value-&gt;as&lt;SwitchValue&gt;()-&gt;numCaseValues() + 1, (&quot;At &quot;, *value));
542 
543                 // Check that there are no duplicate cases.
544                 Vector&lt;int64_t&gt; caseValues = value-&gt;as&lt;SwitchValue&gt;()-&gt;caseValues();
545                 std::sort(caseValues.begin(), caseValues.end());
546                 for (unsigned i = 1; i &lt; caseValues.size(); ++i)
547                     VALIDATE(caseValues[i - 1] != caseValues[i], (&quot;At &quot;, *value, &quot;, caseValue = &quot;, caseValues[i]));
548                 break;
549             }
550             case EntrySwitch:
551                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
552                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
553                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
554                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == m_procedure.numEntrypoints(), (&quot;At &quot;, *value));
555                 break;
</pre>
<hr />
<pre>
567             for (BasicBlock* predecessor : block-&gt;predecessors())
568                 predecessors.add(predecessor);
569             VALIDATE(block-&gt;numPredecessors() == predecessors.size(), (&quot;At &quot;, *block));
570         }
571     }
572 
573 private:
574     void validateStackmap(Value* value)
575     {
576         StackmapValue* stackmap = value-&gt;as&lt;StackmapValue&gt;();
577         VALIDATE(stackmap, (&quot;At &quot;, *value));
578         VALIDATE(stackmap-&gt;numChildren() &gt;= stackmap-&gt;reps().size(), (&quot;At &quot;, *stackmap));
579         for (ConstrainedValue child : stackmap-&gt;constrainedChildren())
580             validateStackmapConstraint(stackmap, child);
581     }
582 
583     enum class ConstraintRole {
584         Use,
585         Def
586     };
<span class="line-modified">587     void validateStackmapConstraint(Value* context, const ConstrainedValue&amp; value, ConstraintRole role = ConstraintRole::Use, unsigned tupleIndex = 0)</span>
588     {
589         switch (value.rep().kind()) {
590         case ValueRep::WarmAny:
591         case ValueRep::SomeRegister:
592         case ValueRep::StackArgument:
593             break;
594         case ValueRep::LateColdAny:
595         case ValueRep::ColdAny:
596             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
597             break;
598         case ValueRep::SomeRegisterWithClobber:
599             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
600             VALIDATE(context-&gt;as&lt;PatchpointValue&gt;(), (&quot;At &quot;, *context));
601             break;
602         case ValueRep::SomeEarlyRegister:
603             VALIDATE(role == ConstraintRole::Def, (&quot;At &quot;, *context, &quot;: &quot;, value));
604             break;
605         case ValueRep::Register:
606         case ValueRep::LateRegister:
<span class="line-added">607         case ValueRep::SomeLateRegister:</span>
608             if (value.rep().kind() == ValueRep::LateRegister)
609                 VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
<span class="line-modified">610             if (value.rep().reg().isGPR()) {</span>
<span class="line-modified">611                 if (value.value()-&gt;type().isTuple())</span>
<span class="line-modified">612                     VALIDATE(m_procedure.extractFromTuple(value.value()-&gt;type(), tupleIndex).isInt(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-modified">613                 else</span>
<span class="line-added">614                     VALIDATE(value.value()-&gt;type().isInt(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">615             } else {</span>
<span class="line-added">616                 if (value.value()-&gt;type().isTuple())</span>
<span class="line-added">617                     VALIDATE(m_procedure.extractFromTuple(value.value()-&gt;type(), tupleIndex).isFloat(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">618                 else</span>
<span class="line-added">619                     VALIDATE(value.value()-&gt;type().isFloat(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">620             }</span>
621             break;
622         default:
623             VALIDATE(false, (&quot;At &quot;, *context, &quot;: &quot;, value));
624             break;
625         }
626     }
627 
628     void validateFence(Value* value)
629     {
630         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
631         if (memory-&gt;hasFence())
632             VALIDATE(memory-&gt;accessBank() == GP, (&quot;Fence at &quot;, *memory));
633     }
634 
635     void validateAtomic(Value* value)
636     {
637         AtomicValue* atomic = value-&gt;as&lt;AtomicValue&gt;();
638 
639         VALIDATE(bestType(GP, atomic-&gt;accessWidth()) == atomic-&gt;accessType(), (&quot;At &quot;, *value));
640     }
</pre>
</td>
</tr>
</table>
<center><a href="B3UseCounts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3Value.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>