<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Variant.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Copyright (c) 2015, Just Software Solutions Ltd
   2 // All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or
   5 // without modification, are permitted provided that the
   6 // following conditions are met:
   7 //
   8 // 1. Redistributions of source code must retain the above
   9 // copyright notice, this list of conditions and the following
  10 // disclaimer.
  11 //
  12 // 2. Redistributions in binary form must reproduce the above
  13 // copyright notice, this list of conditions and the following
  14 // disclaimer in the documentation and/or other materials
  15 // provided with the distribution.
  16 //
  17 // 3. Neither the name of the copyright holder nor the names of
  18 // its contributors may be used to endorse or promote products
  19 // derived from this software without specific prior written
  20 // permission.
  21 //
  22 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
  23 // CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
  24 // INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  25 // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26 // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  27 // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  28 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  29 // NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  30 // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  31 // HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32 // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  33 // OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  34 // EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35 
  36 // Copied from https://bitbucket.org/anthonyw/variant/src (5bce47fa788648f79e5ea1d77b0eef2e8f0b2999)
  37 
  38 // Modified to make it compile with exceptions disabled.
  39 
  40 #pragma once
  41 
  42 #include &lt;functional&gt;
  43 #include &lt;limits.h&gt;
  44 #include &lt;new&gt;
  45 #include &lt;stddef.h&gt;
  46 #include &lt;stdexcept&gt;
  47 #include &lt;string&gt;
  48 #include &lt;type_traits&gt;
  49 #include &lt;utility&gt;
  50 #include &lt;wtf/Compiler.h&gt;
  51 #include &lt;wtf/StdLibExtras.h&gt;
  52 
  53 #if COMPILER(MSVC)
  54 #pragma warning(push)
  55 #pragma warning(disable:4245)
  56 #pragma warning(disable:4521)
  57 #pragma warning(disable:4522)
  58 #pragma warning(disable:4814)
  59 #endif
  60 
  61 #if !COMPILER(CLANG) || WTF_CPP_STD_VER &gt;= 14
  62 
  63 namespace WTF {
  64 
  65 #if COMPILER_SUPPORTS(EXCEPTIONS)
  66 #define __THROW_EXCEPTION(__exception) throw __exception;
  67 #define __NOEXCEPT noexcept
  68 #define __NOEXCEPT_(__exception) noexcept(__exception)
  69 #else
  70 #define __THROW_EXCEPTION(__exception) do { (void)__exception; CRASH(); } while (0);
  71 #define __NOEXCEPT
  72 #define __NOEXCEPT_(...)
  73 #endif
  74 
  75 struct __in_place_private{
  76     template&lt;typename&gt;
  77     struct __type_holder;
  78 
  79     template&lt;size_t&gt;
  80     struct __value_holder;
  81 };
  82 
  83 
  84 struct in_place_tag {
  85     in_place_tag() = delete;
  86 };
  87 
  88 using in_place_t = in_place_tag(&amp;)(__in_place_private&amp;);
  89 
  90 template &lt;class _Type&gt;
  91 using in_place_type_t = in_place_tag(&amp;)(__in_place_private::__type_holder&lt;_Type&gt;&amp;);
  92 
  93 template &lt;size_t _Index&gt;
  94 using in_place_index_t = in_place_tag(&amp;)(__in_place_private::__value_holder&lt;_Index&gt;&amp;);
  95 
  96 in_place_tag in_place(__in_place_private&amp;);
  97 
  98 template &lt;class _Type&gt;
  99 in_place_tag in_place(__in_place_private::__type_holder&lt;_Type&gt; &amp;) {
 100     __THROW_EXCEPTION(__in_place_private());
 101 }
 102 
 103 template &lt;size_t _Index&gt;
 104 in_place_tag in_place(__in_place_private::__value_holder&lt;_Index&gt; &amp;) {
 105     __THROW_EXCEPTION(__in_place_private());
 106 }
 107 
 108 class bad_variant_access: public std::logic_error{
 109 public:
 110     explicit bad_variant_access(const std::string&amp; what_arg):
 111         std::logic_error(what_arg)
 112     {}
 113     explicit bad_variant_access(const char* what_arg):
 114         std::logic_error(what_arg)
 115     {}
 116 };
 117 
 118 template&lt;typename T&gt;
 119 NO_RETURN_DUE_TO_CRASH inline T __throw_bad_variant_access(const char* what_arg){
 120     __THROW_EXCEPTION(bad_variant_access(what_arg))
 121 }
 122 
 123 template&lt;ptrdiff_t _Offset,typename _Type,typename ... _Types&gt;
 124 struct __type_index_helper;
 125 
 126 template&lt;ptrdiff_t _Offset,typename _Type,typename _Head,typename ... _Rest&gt;
 127 struct __type_index_helper&lt;_Offset,_Type,_Head,_Rest...&gt;{
 128     static constexpr ptrdiff_t __value=
 129         __type_index_helper&lt;_Offset+1,_Type,_Rest...&gt;::__value;
 130 };
 131 
 132 template&lt;ptrdiff_t _Offset,typename _Type,typename ... _Rest&gt;
 133 struct __type_index_helper&lt;_Offset,_Type,_Type,_Rest...&gt;{
 134     static constexpr ptrdiff_t __value=_Offset;
 135 };
 136 
 137 template&lt;typename _Type,typename ... _Types&gt;
 138 struct __type_index{
 139     static constexpr ptrdiff_t __value=
 140         __type_index_helper&lt;0,_Type,_Types...&gt;::__value;
 141 };
 142 
 143 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 144 struct __indexed_type;
 145 
 146 template&lt;typename _Head,typename ... _Rest&gt;
 147 struct __indexed_type&lt;0,_Head,_Rest...&gt;{
 148     typedef _Head __type;
 149 };
 150 
 151 template&lt;typename _Head,typename ... _Rest&gt;
 152 struct __indexed_type&lt;-1,_Head,_Rest...&gt;{
 153     typedef void __type;
 154 };
 155 
 156 template&lt;ptrdiff_t _Index,typename _Head,typename ... _Rest&gt;
 157 struct __indexed_type&lt;_Index,_Head,_Rest...&gt;{
 158     typedef typename __indexed_type&lt;_Index-1,_Rest...&gt;::__type __type;
 159 };
 160 
 161 template&lt;ptrdiff_t _Index,typename ..._Types&gt;
 162 struct __next_index{
 163     static constexpr ptrdiff_t __value=
 164         (_Index&gt;=ptrdiff_t(sizeof...(_Types)-1))?-1:_Index+1;
 165 };
 166 
 167 template&lt;typename ... _Types&gt;
 168 class Variant;
 169 
 170 template&lt;typename&gt;
 171 struct variant_size;
 172 
 173 template &lt;typename _Type&gt;
 174 struct variant_size&lt;const _Type&gt; : variant_size&lt;_Type&gt; {};
 175 
 176 template &lt;typename _Type&gt;
 177 struct variant_size&lt;volatile _Type&gt; : variant_size&lt;_Type&gt; {};
 178 
 179 template &lt;typename _Type&gt;
 180 struct variant_size&lt;const volatile _Type&gt; : variant_size&lt;_Type&gt; {};
 181 
 182 template &lt;typename... _Types&gt;
 183 struct variant_size&lt;Variant&lt;_Types...&gt;&gt;
 184     : std::integral_constant&lt;size_t, sizeof...(_Types)&gt; {};
 185 
 186 template&lt;size_t _Index,typename _Type&gt;
 187 struct variant_alternative;
 188 
 189 template&lt;size_t _Index,typename _Type&gt;
 190 using variant_alternative_t=typename variant_alternative&lt;_Index,_Type&gt;::type;
 191 
 192 template &lt;size_t _Index, typename _Type&gt;
 193 struct variant_alternative&lt;_Index, const _Type&gt;{
 194     using type=std::add_const_t&lt;variant_alternative_t&lt;_Index,_Type&gt;&gt;;
 195 };
 196 
 197 template &lt;size_t _Index, typename _Type&gt;
 198 struct variant_alternative&lt;_Index, volatile _Type&gt;{
 199     using type=std::add_volatile_t&lt;variant_alternative_t&lt;_Index,_Type&gt;&gt;;
 200 };
 201 
 202 template &lt;size_t _Index, typename _Type&gt;
 203 struct variant_alternative&lt;_Index, volatile const _Type&gt;{
 204     using type=std::add_volatile_t&lt;std::add_const_t&lt;variant_alternative_t&lt;_Index,_Type&gt;&gt;&gt;;
 205 };
 206 
 207 template&lt;size_t _Index,typename ... _Types&gt;
 208 struct variant_alternative&lt;_Index,Variant&lt;_Types...&gt;&gt;{
 209     using type=typename __indexed_type&lt;_Index,_Types...&gt;::__type;
 210 };
 211 
 212 constexpr size_t variant_npos=-1;
 213 
 214 template&lt;typename _Type,typename ... _Types&gt;
 215 constexpr _Type&amp; get(Variant&lt;_Types...&gt;&amp;);
 216 
 217 template&lt;typename _Type,typename ... _Types&gt;
 218 constexpr _Type const&amp; get(Variant&lt;_Types...&gt; const&amp;);
 219 
 220 template&lt;typename _Type,typename ... _Types&gt;
 221 constexpr _Type&amp;&amp; get(Variant&lt;_Types...&gt;&amp;&amp;);
 222 
 223 template&lt;typename _Type,typename ... _Types&gt;
 224 constexpr const _Type&amp;&amp; get(Variant&lt;_Types...&gt; const&amp;&amp;);
 225 
 226 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 227 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp; get(Variant&lt;_Types...&gt;&amp;);
 228 
 229 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 230 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp;&amp; get(Variant&lt;_Types...&gt;&amp;&amp;);
 231 
 232 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 233 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type const&amp; get(
 234     Variant&lt;_Types...&gt; const&amp;);
 235 
 236 template &lt;ptrdiff_t _Index, typename... _Types&gt;
 237 constexpr const typename __indexed_type&lt;_Index, _Types...&gt;::__type &amp;&amp;
 238 get(Variant&lt;_Types...&gt; const &amp;&amp;);
 239 
 240 template&lt;typename _Type,typename ... _Types&gt;
 241 constexpr std::add_pointer_t&lt;_Type&gt; get_if(Variant&lt;_Types...&gt;&amp;);
 242 
 243 template&lt;typename _Type,typename ... _Types&gt;
 244 constexpr std::add_pointer_t&lt;_Type const&gt; get_if(Variant&lt;_Types...&gt; const&amp;);
 245 
 246 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 247 constexpr std::add_pointer_t&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type&gt; get_if(Variant&lt;_Types...&gt;&amp;);
 248 
 249 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 250 constexpr std::add_pointer_t&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type const&gt; get_if(
 251     Variant&lt;_Types...&gt; const&amp;);
 252 
 253 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 254 struct __variant_accessor;
 255 
 256 template&lt;size_t __count,
 257          bool __larger_than_char=(__count&gt;SCHAR_MAX),
 258     bool __larger_than_short=(__count&gt;SHRT_MAX),
 259     bool __larger_than_int=(__count&gt;INT_MAX)&gt;
 260 struct __discriminator_type{
 261     typedef signed char __type;
 262 };
 263 
 264 template&lt;size_t __count&gt;
 265 struct __discriminator_type&lt;__count,true,false,false&gt;{
 266     typedef signed short __type;
 267 };
 268 
 269 template&lt;size_t __count&gt;
 270 struct __discriminator_type&lt;__count,true,true,false&gt;{
 271     typedef int __type;
 272 };
 273 template&lt;size_t __count&gt;
 274 struct __discriminator_type&lt;__count,true,true,true&gt;{
 275     typedef signed long __type;
 276 };
 277 
 278 template&lt;typename _Type&gt;
 279 struct __stored_type{
 280     typedef _Type __type;
 281 };
 282 
 283 template&lt;typename _Type&gt;
 284 struct __stored_type&lt;_Type&amp;&gt;{
 285     typedef _Type* __type;
 286 };
 287 
 288 template&lt;typename ... _Types&gt;
 289 struct __all_trivially_destructible;
 290 
 291 template&lt;&gt;
 292 struct __all_trivially_destructible&lt;&gt; {
 293     static constexpr bool __value=true;
 294 };
 295 
 296 template&lt;typename _Type&gt;
 297 struct __all_trivially_destructible&lt;_Type&gt; {
 298     static constexpr bool __value=
 299         std::is_trivially_destructible&lt;typename __stored_type&lt;_Type&gt;::__type&gt;::value;
 300 };
 301 
 302 template&lt;typename _Head,typename ... _Rest&gt;
 303 struct __all_trivially_destructible&lt;_Head,_Rest...&gt; {
 304     static constexpr bool __value=
 305         __all_trivially_destructible&lt;_Head&gt;::__value &amp;&amp;
 306         __all_trivially_destructible&lt;_Rest...&gt;::__value;
 307 };
 308 
 309 template&lt;typename _Target,typename ... _Args&gt;
 310 struct __storage_nothrow_constructible{
 311     static const bool __value=
 312         std::is_nothrow_constructible&lt;_Target, _Args...&gt;::value;
 313 };
 314 
 315 template&lt;typename ... _Types&gt;
 316 struct __storage_nothrow_move_constructible;
 317 
 318 template&lt;&gt;
 319 struct __storage_nothrow_move_constructible&lt;&gt; {
 320     static constexpr bool __value=true;
 321 };
 322 
 323 template&lt;typename _Type&gt;
 324 struct __storage_nothrow_move_constructible&lt;_Type&gt; {
 325     static constexpr bool __value=
 326         std::is_nothrow_move_constructible&lt;
 327         typename __stored_type&lt;_Type&gt;::__type&gt;::value;
 328 };
 329 
 330 template&lt;typename _Head,typename ... _Rest&gt;
 331 struct __storage_nothrow_move_constructible&lt;_Head,_Rest...&gt; {
 332     static constexpr bool __value=
 333         __storage_nothrow_move_constructible&lt;_Head&gt;::__value &amp;&amp;
 334         __storage_nothrow_move_constructible&lt;_Rest...&gt;::__value;
 335 };
 336 
 337 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 338 struct __other_storage_nothrow_move_constructible;
 339 
 340 template&lt;typename _Head,typename ... _Rest&gt;
 341 struct __other_storage_nothrow_move_constructible&lt;0,_Head,_Rest...&gt;{
 342     static const bool __value=__storage_nothrow_move_constructible&lt;_Rest...&gt;::__value;
 343 };
 344 
 345 template&lt;typename _Head,typename ... _Rest&gt;
 346 struct __other_storage_nothrow_move_constructible&lt;-1,_Head,_Rest...&gt;{
 347     static const bool __value=
 348         __storage_nothrow_move_constructible&lt;_Head,_Rest...&gt;::__value;
 349 };
 350 
 351 template&lt;ptrdiff_t _Index,typename _Head,typename ... _Rest&gt;
 352 struct __other_storage_nothrow_move_constructible&lt;_Index,_Head,_Rest...&gt;{
 353     static const bool __value=
 354         __storage_nothrow_move_constructible&lt;_Head&gt;::__value &amp;&amp;
 355         __other_storage_nothrow_move_constructible&lt;_Index-1,_Rest...&gt;::__value;
 356 };
 357 
 358 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 359 struct __backup_storage_required{
 360     static const bool __value=
 361         !__storage_nothrow_move_constructible&lt;
 362         typename __indexed_type&lt;_Index,_Types...&gt;::__type&gt;::__value &amp;&amp;
 363         !__other_storage_nothrow_move_constructible&lt;_Index,_Types...&gt;::__value;
 364 };
 365 
 366 template&lt;ptrdiff_t _Index,ptrdiff_t _Count,typename ... _Types&gt;
 367 struct __any_backup_storage_required_impl{
 368     static const bool __value=
 369         __backup_storage_required&lt;_Index,_Types...&gt;::__value ||
 370         __any_backup_storage_required_impl&lt;_Index+1,_Count-1,_Types...&gt;::__value;
 371 };
 372 
 373 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
 374 struct __any_backup_storage_required_impl&lt;_Index,0,_Types...&gt;{
 375     static const bool __value=false;
 376 };
 377 
 378 template&lt;typename _Variant&gt;
 379 struct __any_backup_storage_required;
 380 
 381 template&lt;typename ... _Types&gt;
 382 struct __any_backup_storage_required&lt;Variant&lt;_Types...&gt; &gt;{
 383     static const bool __value=
 384         __any_backup_storage_required_impl&lt;0,sizeof...(_Types),_Types...&gt;::__value;
 385 };
 386 
 387 template&lt;typename ... _Types&gt;
 388 union __variant_data;
 389 
 390 template&lt;typename _Type,bool=std::is_literal_type&lt;_Type&gt;::value&gt;
 391 struct __variant_storage{
 392     typedef _Type __type;
 393 
 394     static constexpr _Type&amp; __get(__type&amp; __val){
 395         return __val;
 396     }
 397     static constexpr _Type&amp;&amp; __get_rref(__type&amp; __val){
 398         return std::move(__val);
 399     }
 400     static constexpr const _Type&amp; __get(__type const&amp; __val){
 401         return __val;
 402     }
 403     static constexpr const _Type&amp;&amp; __get_rref(__type const&amp; __val){
 404         return std::move(__val);
 405     }
 406     static void __destroy(__type&amp;){}
 407 };
 408 
 409 template&lt;typename _Type&gt;
 410 struct __storage_wrapper{
 411     typename std::aligned_storage&lt;sizeof(_Type),alignof(_Type)&gt;::type __storage;
 412 
 413     template&lt;typename ... _Args&gt;
 414     static constexpr void __construct(void* __p,_Args&amp;&amp; ... __args){
 415         new (__p) _Type(std::forward&lt;_Args&gt;(__args)...);
 416     }
 417 
 418     template &lt;typename _Dummy = _Type&gt;
 419     __storage_wrapper(
 420         typename std::enable_if&lt;std::is_default_constructible&lt;_Dummy&gt;::value,
 421         void (__storage_wrapper::*)()&gt;::type = nullptr) {
 422       __construct(&amp;__storage);
 423     }
 424 
 425     template &lt;typename _Dummy = _Type&gt;
 426     __storage_wrapper(
 427         typename std::enable_if&lt;!std::is_default_constructible&lt;_Dummy&gt;::value,
 428         void (__storage_wrapper::*)()&gt;::type = nullptr) {
 429     }
 430 
 431     template&lt;typename _First,typename ... _Args&gt;
 432     __storage_wrapper(_First&amp;&amp; __first,_Args&amp;&amp; ... __args){
 433         __construct(&amp;__storage,std::forward&lt;_First&gt;(__first),std::forward&lt;_Args&gt;(__args)...);
 434     }
 435 
 436     _Type&amp; __get(){
 437         return *static_cast&lt;_Type*&gt;(static_cast&lt;void*&gt;(&amp;__storage));
 438     }
 439     constexpr _Type const&amp; __get() const{
 440         return *static_cast&lt;_Type const*&gt;(static_cast&lt;void const*&gt;(&amp;__storage));
 441     }
 442     void __destroy(){
 443         __get().~_Type();
 444     }
 445 };
 446 
 447 template&lt;typename _Type&gt;
 448 struct __storage_wrapper&lt;_Type&amp;&gt;{
 449     _Type* __storage;
 450 
 451     template&lt;typename _Arg&gt;
 452     constexpr __storage_wrapper(_Arg&amp; __arg):
 453         __storage(&amp;__arg){}
 454 
 455     _Type&amp; __get(){
 456         return *__storage;
 457     }
 458     constexpr _Type const&amp; __get() const{
 459         return *__storage;
 460     }
 461 };
 462 
 463 template&lt;typename _Type&gt;
 464 struct __variant_storage&lt;_Type,false&gt;{
 465     typedef __storage_wrapper&lt;_Type&gt; __type;
 466 
 467     static constexpr _Type&amp; __get(__type&amp; __val){
 468         return __val.__get();
 469     }
 470     static constexpr _Type&amp;&amp; __get_rref(__type&amp; __val){
 471         return std::move(__val.__get());
 472     }
 473     static constexpr const _Type&amp; __get(__type const&amp; __val){
 474         return __val.__get();
 475     }
 476     static constexpr const _Type&amp;&amp; __get_rref(__type const&amp; __val){
 477         return std::move(__val.__get());
 478     }
 479     static void __destroy(__type&amp; __val){
 480         __val.__destroy();
 481     }
 482 };
 483 
 484 template&lt;typename _Type,bool __b&gt;
 485 struct __variant_storage&lt;_Type&amp;,__b&gt;{
 486     typedef _Type* __type;
 487 
 488     static constexpr _Type&amp; __get(__type&amp; __val){
 489         return *__val;
 490     }
 491     static constexpr _Type&amp; __get_rref(__type&amp; __val){
 492         return *__val;
 493     }
 494     static constexpr _Type&amp; __get(__type const&amp; __val){
 495         return *__val;
 496     }
 497     static constexpr _Type&amp; __get_rref(__type const&amp; __val){
 498         return *__val;
 499     }
 500     static void __destroy(__type&amp;){}
 501 };
 502 
 503 template&lt;typename _Type,bool __b&gt;
 504 struct __variant_storage&lt;_Type&amp;&amp;,__b&gt;{
 505     typedef _Type* __type;
 506 
 507     static constexpr _Type&amp;&amp; __get(__type&amp; __val){
 508         return static_cast&lt;_Type&amp;&amp;&gt;(*__val);
 509     }
 510     static constexpr _Type&amp;&amp; __get_rref(__type&amp; __val){
 511         return static_cast&lt;_Type&amp;&amp;&gt;(*__val);
 512     }
 513     static constexpr _Type&amp;&amp; __get(__type const&amp; __val){
 514         return static_cast&lt;_Type&amp;&amp;&gt;(*__val);
 515     }
 516     static constexpr _Type&amp;&amp; __get_rref(__type const&amp; __val){
 517         return static_cast&lt;_Type&amp;&amp;&gt;(*__val);
 518     }
 519     static void __destroy(__type&amp;){}
 520 };
 521 
 522 template&lt;&gt;
 523 union __variant_data&lt;&gt;{
 524     constexpr __variant_data(){}
 525 };
 526 
 527 template&lt;typename _Type&gt;
 528 union __variant_data&lt;_Type&gt;{
 529     typename __variant_storage&lt;_Type&gt;::__type __val;
 530     struct __dummy_type{} __dummy;
 531 
 532     constexpr __variant_data():__dummy(){}
 533 
 534     template&lt;typename ... _Args&gt;
 535     constexpr __variant_data(in_place_index_t&lt;0&gt;,_Args&amp;&amp; ... __args):
 536         __val(std::forward&lt;_Args&gt;(__args)...){}
 537 
 538     _Type&amp; __get(in_place_index_t&lt;0&gt;){
 539         return __variant_storage&lt;_Type&gt;::__get(__val);
 540     }
 541     /*constexpr*/ _Type&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;){
 542         return __variant_storage&lt;_Type&gt;::__get_rref(__val);
 543     }
 544     constexpr const _Type&amp; __get(in_place_index_t&lt;0&gt;) const{
 545         return __variant_storage&lt;_Type&gt;::__get(__val);
 546     }
 547     constexpr const _Type&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;) const{
 548         return __variant_storage&lt;_Type&gt;::__get_rref(__val);
 549     }
 550     void __destroy(in_place_index_t&lt;0&gt;){
 551         __variant_storage&lt;_Type&gt;::__destroy(__val);
 552     }
 553 };
 554 
 555 template&lt;typename _Type&gt;
 556 union __variant_data&lt;_Type&amp;&gt;{
 557     typename __variant_storage&lt;_Type&amp;&gt;::__type __val;
 558     struct __dummy_type{} __dummy;
 559 
 560     constexpr __variant_data():__dummy(){}
 561 
 562     template&lt;typename ... _Args&gt;
 563     constexpr __variant_data(in_place_index_t&lt;0&gt;,_Args&amp;&amp; ... __args):
 564         __val(&amp;std::forward&lt;_Args&gt;(__args)...){}
 565 
 566     _Type&amp; __get(in_place_index_t&lt;0&gt;){
 567         return __variant_storage&lt;_Type&amp;&gt;::__get(__val);
 568     }
 569     constexpr _Type&amp; __get(in_place_index_t&lt;0&gt;) const{
 570         return __variant_storage&lt;_Type&amp;&gt;::__get(__val);
 571     }
 572 
 573     _Type&amp; __get_rref(in_place_index_t&lt;0&gt;){
 574         return __variant_storage&lt;_Type&amp;&gt;::__get_rref(__val);
 575     }
 576     constexpr _Type&amp; __get_rref(in_place_index_t&lt;0&gt;) const{
 577         return __variant_storage&lt;_Type&amp;&gt;::__get_rref(__val);
 578     }
 579 
 580     void __destroy(in_place_index_t&lt;0&gt;){
 581         __variant_storage&lt;_Type&amp;&gt;::__destroy(__val);
 582     }
 583 };
 584 
 585 template&lt;typename _Type&gt;
 586 union __variant_data&lt;_Type&amp;&amp;&gt;{
 587     typename __variant_storage&lt;_Type&amp;&amp;&gt;::__type __val;
 588     struct __dummy_type{} __dummy;
 589 
 590     constexpr __variant_data():__dummy(){}
 591 
 592     template&lt;typename _Arg&gt;
 593     __variant_data(in_place_index_t&lt;0&gt;,_Arg&amp;&amp; __arg):
 594         __val(&amp;__arg){}
 595 
 596     _Type&amp;&amp; __get(in_place_index_t&lt;0&gt;){
 597         return __variant_storage&lt;_Type&amp;&amp;&gt;::__get(__val);
 598     }
 599     constexpr _Type&amp;&amp; __get(in_place_index_t&lt;0&gt;) const{
 600         return __variant_storage&lt;_Type&amp;&amp;&gt;::__get(__val);
 601     }
 602     _Type&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;){
 603         return __variant_storage&lt;_Type&amp;&amp;&gt;::__get_rref(__val);
 604     }
 605     constexpr _Type&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;) const{
 606         return __variant_storage&lt;_Type&amp;&amp;&gt;::__get_rref(__val);
 607     }
 608     void __destroy(in_place_index_t&lt;0&gt;){
 609         __variant_storage&lt;_Type&amp;&amp;&gt;::__destroy(__val);
 610     }
 611 };
 612 
 613 template&lt;typename _Head,typename ... _Rest&gt;
 614 union __variant_data&lt;_Head,_Rest...&gt;{
 615     __variant_data&lt;_Head&gt; __head;
 616     __variant_data&lt;_Rest...&gt; __rest;
 617 
 618     constexpr __variant_data():
 619         __head(){}
 620 
 621     template&lt;typename ... _Args&gt;
 622     constexpr __variant_data(in_place_index_t&lt;0&gt;,_Args&amp;&amp; ... __args):
 623         __head(in_place&lt;0&gt;,std::forward&lt;_Args&gt;(__args)...){}
 624     template&lt;size_t _Index,typename ... _Args&gt;
 625     constexpr __variant_data(in_place_index_t&lt;_Index&gt;,_Args&amp;&amp; ... __args):
 626         __rest(in_place&lt;_Index-1&gt;,std::forward&lt;_Args&gt;(__args)...){}
 627 
 628     _Head&amp; __get(in_place_index_t&lt;0&gt;){
 629         return __head.__get(in_place&lt;0&gt;);
 630     }
 631 
 632     /*constexpr*/ _Head&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;){
 633         return __head.__get_rref(in_place&lt;0&gt;);
 634     }
 635 
 636     constexpr const _Head&amp; __get(in_place_index_t&lt;0&gt;) const{
 637         return __head.__get(in_place&lt;0&gt;);
 638     }
 639 
 640     constexpr const _Head&amp;&amp; __get_rref(in_place_index_t&lt;0&gt;) const{
 641         return __head.__get_rref(in_place&lt;0&gt;);
 642     }
 643 
 644     template&lt;size_t _Index&gt;
 645     typename __indexed_type&lt;_Index-1,_Rest...&gt;::__type&amp; __get(
 646         in_place_index_t&lt;_Index&gt;){
 647         return __rest.__get(in_place&lt;_Index-1&gt;);
 648     }
 649 
 650     template&lt;size_t _Index&gt;
 651     /*constexpr*/ typename __indexed_type&lt;_Index-1,_Rest...&gt;::__type&amp;&amp; __get_rref(
 652         in_place_index_t&lt;_Index&gt;){
 653         return __rest.__get_rref(in_place&lt;_Index-1&gt;);
 654     }
 655 
 656     template&lt;size_t _Index&gt;
 657     constexpr const typename __indexed_type&lt;_Index-1,_Rest...&gt;::__type&amp; __get(
 658         in_place_index_t&lt;_Index&gt;) const{
 659         return __rest.__get(in_place&lt;_Index-1&gt;);
 660     }
 661 
 662     template&lt;size_t _Index&gt;
 663     constexpr const typename __indexed_type&lt;_Index-1,_Rest...&gt;::__type&amp;&amp; __get_rref(
 664         in_place_index_t&lt;_Index&gt;) const{
 665         return __rest.__get_rref(in_place&lt;_Index-1&gt;);
 666     }
 667 
 668 
 669     void __destroy(in_place_index_t&lt;0&gt;){
 670         __head.__destroy(in_place&lt;0&gt;);
 671     }
 672     template&lt;size_t _Index&gt;
 673     void __destroy(in_place_index_t&lt;_Index&gt;){
 674         __rest.__destroy(in_place&lt;_Index-1&gt;);
 675     }
 676 };
 677 
 678 
 679 template&lt;ptrdiff_t... _Indices&gt;
 680 struct __index_sequence{
 681     typedef __index_sequence&lt;_Indices...,sizeof...(_Indices)&gt; __next;
 682     static constexpr size_t __length=sizeof...(_Indices);
 683 };
 684 
 685 template&lt;typename ... _Types&gt;
 686 struct __type_indices;
 687 
 688 template&lt;&gt;
 689 struct __type_indices&lt;&gt;{
 690     typedef __index_sequence&lt;&gt; __type;
 691 };
 692 
 693 template&lt;typename _Type&gt;
 694 struct __type_indices&lt;_Type&gt;{
 695     typedef __index_sequence&lt;0&gt; __type;
 696 };
 697 
 698 template&lt;typename _Type,typename ... _Rest&gt;
 699 struct __type_indices&lt;_Type,_Rest...&gt;{
 700     typedef typename __type_indices&lt;_Rest...&gt;::__type::__next __type;
 701 };
 702 
 703 template&lt;typename _Variant&gt;
 704 struct __variant_indices;
 705 
 706 template&lt;typename ... _Types&gt;
 707 struct __variant_indices&lt;Variant&lt;_Types...&gt;&gt;{
 708     typedef typename __type_indices&lt;_Types...&gt;::__type __type;
 709 };
 710 
 711 template&lt;typename _Variant,
 712          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 713 struct __move_construct_op_table;
 714 
 715 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 716 struct __move_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 717     typedef void(* const __func_type)(_Variant*,_Variant&amp;);
 718 
 719     template&lt;ptrdiff_t _Index&gt;
 720     static void __move_construct_func(
 721         _Variant * __lhs,_Variant&amp; __rhs){
 722         __lhs-&gt;template __emplace_construct&lt;_Index&gt;(
 723             std::move(get&lt;_Index&gt;(__rhs)));
 724     }
 725 
 726     static const __func_type __apply[sizeof...(_Indices)];
 727 };
 728 
 729 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 730 const typename __move_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 731 __func_type
 732 __move_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 733     sizeof...(_Indices)]={
 734         &amp;__move_construct_func&lt;_Indices&gt;...
 735     };
 736 
 737 template&lt;typename _Variant,
 738          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 739 struct __move_assign_op_table;
 740 
 741 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 742 struct __move_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 743     typedef void(* const __func_type)(_Variant*,_Variant&amp;);
 744 
 745     template&lt;ptrdiff_t _Index&gt;
 746     static void __move_assign_func(
 747         _Variant * __lhs,_Variant&amp; __rhs){
 748         get&lt;_Index&gt;(*__lhs)=std::move(get&lt;_Index&gt;(__rhs));
 749     }
 750 
 751     static const __func_type __apply[sizeof...(_Indices)];
 752 };
 753 
 754 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 755 const typename __move_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 756 __func_type
 757 __move_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 758     sizeof...(_Indices)]={
 759         &amp;__move_assign_func&lt;_Indices&gt;...
 760     };
 761 
 762 template&lt;typename _Variant,
 763          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 764 struct __copy_construct_op_table;
 765 
 766 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 767 struct __copy_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 768     typedef void(* const __func_type)(_Variant*,_Variant const&amp;);
 769 
 770     template&lt;ptrdiff_t _Index&gt;
 771     static void __copy_construct_func(
 772         _Variant * __lhs,_Variant const&amp; __rhs){
 773         __lhs-&gt;template __emplace_construct&lt;_Index&gt;(
 774             get&lt;_Index&gt;(__rhs));
 775     }
 776 
 777     static const __func_type __apply[sizeof...(_Indices)];
 778 };
 779 
 780 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 781 const typename __copy_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 782 __func_type
 783 __copy_construct_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 784     sizeof...(_Indices)]={
 785         &amp;__copy_construct_func&lt;_Indices&gt;...
 786     };
 787 
 788 template&lt;typename _Variant,
 789          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 790 struct __copy_assign_op_table;
 791 
 792 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 793 struct __copy_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 794     typedef void(* const __func_type)(_Variant*,_Variant const&amp;);
 795 
 796     template&lt;ptrdiff_t _Index&gt;
 797     static void __copy_assign_func(
 798         _Variant * __lhs,_Variant const&amp; __rhs){
 799         get&lt;_Index&gt;(*__lhs)=get&lt;_Index&gt;(__rhs);
 800     }
 801 
 802     static const __func_type __apply[sizeof...(_Indices)];
 803 };
 804 
 805 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 806 const typename __copy_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 807 __func_type
 808 __copy_assign_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 809     sizeof...(_Indices)]={
 810         &amp;__copy_assign_func&lt;_Indices&gt;...
 811     };
 812 
 813 template&lt;typename _Variant,
 814          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 815 struct __destroy_op_table;
 816 
 817 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 818 struct __destroy_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 819     typedef void(* const __func_type)(_Variant*);
 820 
 821     template&lt;ptrdiff_t _Index&gt;
 822     static void __destroy_func(
 823         _Variant * __self){
 824         if(__self-&gt;__index&gt;=0){
 825             __self-&gt;__storage.__destroy(in_place&lt;_Index&gt;);
 826         }
 827     }
 828 
 829     static const __func_type __apply[sizeof...(_Indices)];
 830 };
 831 
 832 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 833 const typename __destroy_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 834 __func_type
 835 __destroy_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 836     sizeof...(_Indices)]={
 837         &amp;__destroy_func&lt;_Indices&gt;...
 838     };
 839 
 840 template&lt;typename _Variant,
 841          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 842 struct __swap_op_table;
 843 
 844 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 845 struct __swap_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 846     typedef void(* const __func_type)(_Variant&amp;,_Variant&amp;);
 847 
 848     template&lt;ptrdiff_t _Index&gt;
 849     static void __swap_func(
 850         _Variant &amp; __lhs,_Variant &amp; __rhs){
 851         swap(get&lt;_Index&gt;(__lhs),get&lt;_Index&gt;(__rhs));
 852     }
 853 
 854     static const __func_type __apply[sizeof...(_Indices)];
 855 };
 856 
 857 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 858 const typename __swap_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 859 __func_type
 860 __swap_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__apply[
 861     sizeof...(_Indices)]={
 862         &amp;__swap_func&lt;_Indices&gt;...
 863     };
 864 
 865 template&lt;typename _Variant,
 866          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 867 struct __equality_op_table;
 868 
 869 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 870 struct __equality_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 871     typedef bool(* const __compare_func_type)(_Variant const&amp;,_Variant const&amp;);
 872 
 873     template&lt;ptrdiff_t _Index&gt;
 874     static constexpr bool __equality_compare_func(
 875         _Variant const&amp; __lhs,_Variant const&amp; __rhs){
 876         return get&lt;_Index&gt;(__lhs)==get&lt;_Index&gt;(__rhs);
 877     }
 878 
 879     static constexpr __compare_func_type __equality_compare[sizeof...(_Indices)]={
 880         &amp;__equality_compare_func&lt;_Indices&gt;...
 881     };
 882 };
 883 
 884 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 885 constexpr typename __equality_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 886 __compare_func_type
 887 __equality_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__equality_compare[
 888     sizeof...(_Indices)];
 889 
 890 template&lt;typename _Variant,
 891          typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
 892 struct __less_than_op_table;
 893 
 894 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 895 struct __less_than_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
 896     typedef bool(* const __compare_func_type)(_Variant const&amp;,_Variant const&amp;);
 897 
 898     template&lt;ptrdiff_t _Index&gt;
 899     static constexpr bool __less_than_compare_func(
 900         _Variant const&amp; __lhs,_Variant const&amp; __rhs){
 901         return get&lt;_Index&gt;(__lhs)&lt;get&lt;_Index&gt;(__rhs);
 902     }
 903 
 904     static constexpr __compare_func_type __less_than_compare[sizeof...(_Indices)]={
 905         &amp;__less_than_compare_func&lt;_Indices&gt;...
 906     };
 907 };
 908 
 909 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
 910 constexpr typename __less_than_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::
 911 __compare_func_type
 912 __less_than_op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;::__less_than_compare[
 913     sizeof...(_Indices)];
 914 
 915 template&lt;typename _Variant&gt;
 916 struct __variant_storage_type;
 917 
 918 template&lt;typename _Derived,bool __trivial_destructor&gt;
 919 struct __variant_base
 920 {
 921     ~__variant_base(){
 922         static_cast&lt;_Derived*&gt;(this)-&gt;__destroy_self();
 923     }
 924 };
 925 
 926 template&lt;typename _Derived&gt;
 927 struct __variant_base&lt;_Derived,true&gt;{
 928 };
 929 
 930 
 931 template&lt;ptrdiff_t _Offset,typename _CurrentSequence,
 932          typename _Type,typename ... _Types&gt;
 933 struct __all_indices_helper;
 934 
 935 template&lt;ptrdiff_t _Offset,ptrdiff_t ... _Indices,
 936          typename _Type,typename ... _Rest&gt;
 937 struct __all_indices_helper&lt;
 938     _Offset,__index_sequence&lt;_Indices...&gt;,
 939     _Type,_Type,_Rest...&gt;{
 940     typedef typename __all_indices_helper&lt;
 941         _Offset+1,__index_sequence&lt;_Indices...,_Offset&gt;,_Type,_Rest...&gt;::__type
 942         __type;
 943 };
 944 
 945 template&lt;ptrdiff_t _Offset,typename _CurrentSequence,
 946          typename _Type,typename _Head,typename ... _Rest&gt;
 947 struct __all_indices_helper&lt;_Offset,_CurrentSequence,_Type,_Head,_Rest...&gt;{
 948     typedef typename __all_indices_helper&lt;
 949         _Offset+1,_CurrentSequence,_Type,_Rest...&gt;::__type __type;
 950 };
 951 
 952 template&lt;ptrdiff_t _Offset,typename _CurrentSequence,typename _Type&gt;
 953 struct __all_indices_helper&lt;_Offset,_CurrentSequence,_Type&gt;{
 954     typedef _CurrentSequence __type;
 955 };
 956 
 957 template&lt;typename _Type,typename ... _Types&gt;
 958 struct __all_indices{
 959     typedef typename __all_indices_helper&lt;
 960         0,__index_sequence&lt;&gt;,_Type,_Types...&gt;::__type __type;
 961 };
 962 
 963 template&lt;typename ... _Sequences&gt;
 964 struct __combine_sequences;
 965 
 966 template&lt;ptrdiff_t ... _Indices1,ptrdiff_t ... _Indices2&gt;
 967 struct __combine_sequences&lt;
 968     __index_sequence&lt;_Indices1...&gt;,__index_sequence&lt;_Indices2...&gt;&gt;{
 969     typedef __index_sequence&lt;_Indices1...,_Indices2...&gt; __type;
 970 };
 971 
 972 template&lt;typename _Sequence,typename ... _Rest&gt;
 973 struct __combine_sequences&lt;_Sequence,_Rest...&gt;{
 974     typedef typename __combine_sequences&lt;
 975         _Sequence,
 976         typename __combine_sequences&lt;_Rest...&gt;::__type&gt;::__type __type;
 977 };
 978 
 979 template&lt;typename _Indices&gt;
 980 struct __first_index;
 981 
 982 template&lt;ptrdiff_t _FirstIndex,ptrdiff_t ... _Rest&gt;
 983 struct __first_index&lt;__index_sequence&lt;_FirstIndex,_Rest...&gt;&gt;{
 984     static constexpr ptrdiff_t __value=_FirstIndex;
 985 };
 986 
 987 template&lt;ptrdiff_t _Offset,typename _CurrentSequence,
 988          typename _Type,typename ... _Types&gt;
 989 struct __constructible_matches_helper;
 990 
 991 template&lt;ptrdiff_t _Offset,typename _Sequence,typename _Type&gt;
 992 struct __constructible_matches_helper&lt;
 993     _Offset,_Sequence,_Type&gt;{
 994     typedef _Sequence __type;
 995 };
 996 
 997 template&lt;bool _Accept,ptrdiff_t _Entry&gt;
 998 struct __sequence_or_empty{
 999     typedef __index_sequence&lt;&gt; __type;
1000 };
1001 
1002 template&lt;ptrdiff_t _Entry&gt;
1003 struct __sequence_or_empty&lt;true,_Entry&gt;{
1004     typedef __index_sequence&lt;_Entry&gt; __type;
1005 };
1006 
1007 template&lt;ptrdiff_t _Offset,typename _CurrentSequence,
1008          typename _Type,typename _Head,typename ... _Rest&gt;
1009 struct __constructible_matches_helper&lt;
1010     _Offset,_CurrentSequence,_Type,_Head,_Rest...&gt;{
1011     typedef
1012     typename __constructible_matches_helper&lt;
1013         _Offset+1,
1014         typename __combine_sequences&lt;
1015             _CurrentSequence,
1016             typename __sequence_or_empty&lt;
1017                 std::is_constructible&lt;_Head,_Type&gt;::value,
1018                 _Offset&gt;::__type&gt;::__type,
1019         _Type,_Rest...&gt;::__type __type;
1020 };
1021 
1022 template&lt;typename _Type,typename ... _Types&gt;
1023 struct __constructible_matches{
1024     typedef typename __constructible_matches_helper&lt;
1025         0,__index_sequence&lt;&gt;,_Type,_Types...&gt;::__type __type;
1026 };
1027 
1028 template&lt;typename _Type,typename ... _Types&gt;
1029 struct __type_index_to_construct{
1030     typedef typename __all_indices&lt;_Type,_Types...&gt;::__type __direct_matches;
1031     typedef typename __all_indices&lt;
1032         typename std::remove_const&lt;
1033             typename std::remove_reference&lt;_Type&gt;::type
1034             &gt;::type,_Types...&gt;::__type __value_matches;
1035     typedef typename __all_indices&lt;
1036         _Type,
1037         typename std::remove_const&lt;
1038             typename std::remove_reference&lt;_Types&gt;::type
1039             &gt;::type...&gt;::__type __rref_matches;
1040 
1041     typedef typename __constructible_matches&lt;_Type,_Types...&gt;::__type
1042     __constructibles;
1043 
1044     static_assert(
1045         (__direct_matches::__length&gt;0) ||
1046         (__value_matches::__length&gt;0) ||
1047         (__rref_matches::__length&gt;0) ||
1048         (__constructibles::__length==1),
1049         &quot;For conversion construction of variants, exactly one type must be constructible&quot;);
1050 
1051     typedef typename __combine_sequences&lt;
1052         __direct_matches,__value_matches,__rref_matches,
1053         __constructibles&gt;::__type __all_matches;
1054 
1055     static constexpr ptrdiff_t __value=__first_index&lt;__all_matches&gt;::__value;
1056 };
1057 
1058 struct __replace_construct_helper{
1059     template&lt;
1060         ptrdiff_t _Index,
1061         bool __construct_directly,
1062         bool __indexed_type_has_nothrow_move,
1063         bool __other_types_have_nothrow_move&gt;
1064     struct __helper;
1065 
1066     template&lt;typename _Variant,
1067              typename _Indices=typename __variant_indices&lt;_Variant&gt;::__type&gt;
1068     struct __op_table;
1069 };
1070 
1071 template&lt;
1072     ptrdiff_t _Index,
1073     bool __other_types_have_nothrow_move&gt;
1074 struct __replace_construct_helper::__helper&lt;
1075     _Index,false,true,__other_types_have_nothrow_move&gt;{
1076 
1077     template&lt;typename _Variant,typename ... _Args&gt;
1078     static void __trampoline(_Variant&amp; __v,_Args&amp;&amp; ... __args){
1079         __v.template __two_stage_replace&lt;_Index&gt;(__args...);
1080     }
1081 };
1082 
1083 template&lt;
1084     ptrdiff_t _Index,
1085     bool __indexed_type_has_nothrow_move,
1086     bool __other_types_have_nothrow_move&gt;
1087 struct __replace_construct_helper::__helper&lt;
1088     _Index,true,__indexed_type_has_nothrow_move,
1089     __other_types_have_nothrow_move&gt;{
1090 
1091     template&lt;typename _Variant,typename ... _Args&gt;
1092     static void __trampoline(_Variant&amp; __v,_Args&amp;&amp; ... __args){
1093         __v.template __direct_replace&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1094     }
1095 };
1096 
1097 
1098 template&lt;
1099     ptrdiff_t _Index&gt;
1100 struct __replace_construct_helper::__helper&lt;
1101     _Index,false,false,true&gt;{
1102 
1103     template&lt;typename _Variant,typename ... _Args&gt;
1104     static void __trampoline(_Variant&amp; __v,_Args&amp;&amp; ... __args){
1105         __v.template __local_backup_replace&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1106     }
1107 };
1108 
1109 template&lt;
1110     ptrdiff_t _Index&gt;
1111 struct __replace_construct_helper::__helper&lt;
1112     _Index,false,false,false&gt;{
1113 
1114     template&lt;typename _Variant,typename ... _Args&gt;
1115     static void __trampoline(_Variant&amp; __v,_Args&amp;&amp; ... __args){
1116         __v.template __direct_replace&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1117     }
1118 };
1119 
1120 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
1121 struct __replace_construct_helper::__op_table&lt;_Variant,__index_sequence&lt;_Indices...&gt;&gt;{
1122     typedef void(* const __move_func_type)(_Variant*,_Variant&amp;);
1123     typedef void(* const __copy_func_type)(_Variant*,_Variant const&amp;);
1124 
1125     template&lt;ptrdiff_t _Index&gt;
1126     static void __move_assign_func(
1127         _Variant * __lhs,_Variant&amp; __rhs){
1128         __lhs-&gt;template __replace_construct&lt;_Index&gt;(std::move(get&lt;_Index&gt;(__rhs)));
1129         __rhs.__destroy_self();
1130     }
1131 
1132     template&lt;ptrdiff_t _Index&gt;
1133     static void __copy_assign_func(
1134         _Variant * __lhs,_Variant const&amp; __rhs){
1135         __lhs-&gt;template __replace_construct&lt;_Index&gt;(get&lt;_Index&gt;(__rhs));
1136     }
1137 
1138     static const __move_func_type __move_assign[sizeof...(_Indices)];
1139     static const __copy_func_type __copy_assign[sizeof...(_Indices)];
1140 };
1141 
1142 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
1143 const typename __replace_construct_helper::__op_table&lt;
1144     _Variant,__index_sequence&lt;_Indices...&gt;&gt;::__move_func_type
1145 __replace_construct_helper::__op_table&lt;
1146     _Variant,__index_sequence&lt;_Indices...&gt;&gt;::__move_assign[
1147     sizeof...(_Indices)]={
1148         &amp;__move_assign_func&lt;_Indices&gt;...
1149     };
1150 
1151 template&lt;typename _Variant,ptrdiff_t ... _Indices&gt;
1152 const typename __replace_construct_helper::__op_table&lt;
1153     _Variant,__index_sequence&lt;_Indices...&gt;&gt;::__copy_func_type
1154 __replace_construct_helper::__op_table&lt;
1155     _Variant,__index_sequence&lt;_Indices...&gt;&gt;::__copy_assign[
1156     sizeof...(_Indices)]={
1157         &amp;__copy_assign_func&lt;_Indices&gt;...
1158     };
1159 
1160 template&lt;ptrdiff_t _Index,ptrdiff_t _MaskIndex,typename _Storage&gt;
1161 struct __backup_storage_ops{
1162     static void __move_construct_func(
1163         _Storage * __dest,_Storage&amp; __source){
1164         new(__dest) _Storage(
1165             in_place&lt;_Index&gt;,
1166             std::move(__source.__get(in_place&lt;_Index&gt;)));
1167     }
1168     static void __destroy_func(_Storage * __obj){
1169         __obj-&gt;__destroy(in_place&lt;_Index&gt;);
1170     };
1171 };
1172 
1173 template&lt;ptrdiff_t _Index,typename _Storage&gt;
1174 struct __backup_storage_ops&lt;_Index,_Index,_Storage&gt;{
1175     static void __move_construct_func(_Storage *,_Storage&amp;){
1176         __THROW_EXCEPTION(std::bad_alloc());
1177     };
1178     static void __destroy_func(_Storage *){
1179         __THROW_EXCEPTION(std::bad_alloc());
1180     };
1181 };
1182 
1183 template&lt;ptrdiff_t _MaskIndex,typename _Storage,typename _Indices&gt;
1184 struct __backup_storage_op_table;
1185 
1186 template&lt;ptrdiff_t _MaskIndex,typename _Storage,ptrdiff_t ... _Indices&gt;
1187 struct __backup_storage_op_table&lt;
1188     _MaskIndex,_Storage,__index_sequence&lt;_Indices...&gt; &gt;
1189 {
1190     typedef void (*__move_func_type)(_Storage * __dest,_Storage&amp; __source);
1191     typedef void (*__destroy_func_type)(_Storage * __obj);
1192 
1193     template&lt;size_t _Index&gt;
1194     struct __helper{
1195         typedef __backup_storage_ops&lt;_Index,_MaskIndex,_Storage&gt; __ops;
1196     };
1197 
1198     static const __move_func_type __move_ops[sizeof...(_Indices)];
1199     static const __destroy_func_type __destroy_ops[sizeof...(_Indices)];
1200 };
1201 
1202 template&lt;ptrdiff_t _MaskIndex,typename _Storage,ptrdiff_t ... _Indices&gt;
1203 const typename __backup_storage_op_table&lt;
1204     _MaskIndex,_Storage,__index_sequence&lt;_Indices...&gt; &gt;::__move_func_type
1205 __backup_storage_op_table&lt;
1206     _MaskIndex,_Storage,__index_sequence&lt;_Indices...&gt; &gt;::__move_ops[
1207         sizeof...(_Indices)]={
1208         &amp;__helper&lt;_Indices&gt;::__ops::__move_construct_func...
1209     };
1210 
1211 template&lt;ptrdiff_t _MaskIndex,typename _Storage,ptrdiff_t ... _Indices&gt;
1212 const typename __backup_storage_op_table&lt;
1213     _MaskIndex,_Storage,__index_sequence&lt;_Indices...&gt; &gt;::__destroy_func_type
1214 __backup_storage_op_table&lt;
1215     _MaskIndex,_Storage,__index_sequence&lt;_Indices...&gt; &gt;::__destroy_ops[
1216     sizeof...(_Indices)]={
1217         &amp;__helper&lt;_Indices&gt;::__ops::__destroy_func...
1218     };
1219 
1220 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1221 struct __backup_storage{
1222     typedef __variant_data&lt;_Types...&gt; __storage_type;
1223 
1224     typedef __backup_storage_op_table&lt;
1225         _Index,__storage_type,typename __type_indices&lt;_Types...&gt;::__type&gt;
1226     __op_table_type;
1227 
1228     ptrdiff_t __backup_index;
1229     __storage_type&amp; __live_storage;
1230     __storage_type __backup;
1231 
1232     __backup_storage(ptrdiff_t __live_index_,__storage_type&amp; __live_storage_):
1233         __backup_index(__live_index_),__live_storage(__live_storage_){
1234         if(__backup_index&gt;=0){
1235             __op_table_type::__move_ops[__backup_index](
1236                 &amp;__backup,__live_storage);
1237             __op_table_type::__destroy_ops[__backup_index](
1238                 &amp;__live_storage);
1239         }
1240     }
1241     void __destroy(){
1242         if(__backup_index&gt;=0)
1243             __op_table_type::__destroy_ops[__backup_index](
1244                 &amp;__backup);
1245         __backup_index=-1;
1246     }
1247 
1248     ~__backup_storage(){
1249         if(__backup_index&gt;=0){
1250             __op_table_type::__move_ops[__backup_index](
1251                 &amp;__live_storage,__backup);
1252             __destroy();
1253         }
1254     }
1255 };
1256 
1257 template&lt;typename ... _Types&gt;
1258 struct __all_move_constructible;
1259 
1260 template&lt;typename _Head,typename ... _Rest&gt;
1261 struct __all_move_constructible&lt;_Head,_Rest...&gt;
1262 {
1263     static constexpr bool value=std::is_move_constructible&lt;_Head&gt;::value &amp;&amp; __all_move_constructible&lt;_Rest...&gt;::value;
1264 };
1265 
1266 template&lt;&gt;
1267 struct __all_move_constructible&lt;&gt;:
1268     std::true_type{};
1269 
1270 template&lt;typename ... _Types&gt;
1271 struct __all_move_assignable;
1272 
1273 template&lt;typename _Head,typename ... _Rest&gt;
1274 struct __all_move_assignable&lt;_Head,_Rest...&gt;
1275 {
1276     static constexpr bool value=std::is_move_assignable&lt;_Head&gt;::value &amp;&amp; __all_move_assignable&lt;_Rest...&gt;::value;
1277 };
1278 
1279 template&lt;&gt;
1280 struct __all_move_assignable&lt;&gt;:
1281     std::true_type{};
1282 
1283 template&lt;typename ... _Types&gt;
1284 struct __all_copy_assignable;
1285 
1286 template&lt;typename _Head,typename ... _Rest&gt;
1287 struct __all_copy_assignable&lt;_Head,_Rest...&gt;
1288 {
1289     static constexpr bool value=std::is_copy_assignable&lt;_Head&gt;::value &amp;&amp; __all_copy_assignable&lt;_Rest...&gt;::value;
1290 };
1291 
1292 template&lt;&gt;
1293 struct __all_copy_assignable&lt;&gt;:
1294     std::true_type{};
1295 
1296 namespace __swap_test_detail{
1297 using std::swap;
1298 
1299 template&lt;typename _Other&gt;
1300 struct __swap_result{};
1301 
1302 template&lt;typename&gt;
1303 static char __test(...);
1304 template &lt;typename _Other&gt;
1305 static std::pair&lt;char, std::pair&lt;char, __swap_result&lt;decltype(
1306     swap(std::declval&lt;_Other &amp;&gt;(),std::declval&lt;_Other &amp;&gt;()))&gt;&gt;&gt;
1307 __test(_Other *);
1308 }
1309 
1310 template &lt;typename _Type&gt; struct __is_swappable {
1311     static constexpr bool value =
1312         sizeof(__swap_test_detail::__test&lt;_Type&gt;(0)) != 1;
1313 };
1314 
1315 template&lt;typename ... _Types&gt;
1316 struct __all_swappable;
1317 
1318 template&lt;typename _Head,typename ... _Rest&gt;
1319 struct __all_swappable&lt;_Head,_Rest...&gt;
1320 {
1321     static constexpr bool value=__is_swappable&lt;_Head&gt;::value &amp;&amp; __all_swappable&lt;_Rest...&gt;::value;
1322 };
1323 
1324 template&lt;&gt;
1325 struct __all_swappable&lt;&gt;:
1326     std::true_type{};
1327 
1328 template&lt;bool _MoveConstructible,typename ... _Types&gt;
1329 struct __noexcept_variant_move_construct_impl{};
1330 
1331 template&lt;typename _Head,typename ... _Rest&gt;
1332 struct __noexcept_variant_move_construct_impl&lt;true,_Head,_Rest...&gt;{
1333     static constexpr bool value=noexcept(_Head(std::declval&lt;_Head&amp;&amp;&gt;())) &amp;&amp; __noexcept_variant_move_construct_impl&lt;true,_Rest...&gt;::value;
1334 };
1335 
1336 template&lt;&gt;
1337 struct __noexcept_variant_move_construct_impl&lt;true&gt;{
1338     static constexpr bool value=true;
1339 };
1340 
1341 template&lt;typename ... _Types&gt;
1342 struct __noexcept_variant_move_construct:
1343 __noexcept_variant_move_construct_impl&lt;__all_move_constructible&lt;_Types...&gt;::value,_Types...&gt;
1344 {};
1345 
1346 template&lt;bool _MoveAssignable,typename ... _Types&gt;
1347 struct __noexcept_variant_move_assign_impl{};
1348 
1349 template &lt;typename _Head, typename... _Rest&gt;
1350 struct __noexcept_variant_move_assign_impl&lt;true, _Head, _Rest...&gt; {
1351     static constexpr bool value =
1352         std::is_nothrow_move_assignable&lt;_Head&gt;::value &amp;&amp;
1353         std::is_nothrow_move_constructible&lt;_Head&gt;::value &amp;&amp;
1354         __noexcept_variant_move_assign_impl&lt;true, _Rest...&gt;::value;
1355 };
1356 
1357 template&lt;&gt;
1358 struct __noexcept_variant_move_assign_impl&lt;true&gt;{
1359     static constexpr bool value=true;
1360 };
1361 
1362 template &lt;typename... _Types&gt;
1363 struct __noexcept_variant_move_assign
1364     : __noexcept_variant_move_assign_impl&lt;
1365           __all_move_assignable&lt;_Types...&gt;::value &amp;&amp;
1366               __all_move_constructible&lt;_Types...&gt;::value,
1367           _Types...&gt; {};
1368 
1369 template&lt;typename ... _Types&gt;
1370 struct __all_copy_constructible;
1371 
1372 template&lt;typename _Head,typename ... _Rest&gt;
1373 struct __all_copy_constructible&lt;_Head,_Rest...&gt;
1374 {
1375     static constexpr bool value=std::is_copy_constructible&lt;_Head&gt;::value &amp;&amp; __all_copy_constructible&lt;_Rest...&gt;::value;
1376 };
1377 
1378 template&lt;&gt;
1379 struct __all_copy_constructible&lt;&gt;:
1380     std::true_type{};
1381 
1382 template&lt;bool _CopyConstructible,typename ... _Types&gt;
1383 struct __noexcept_variant_const_copy_construct_impl{};
1384 
1385 template&lt;typename _Head,typename ... _Rest&gt;
1386 struct __noexcept_variant_const_copy_construct_impl&lt;true,_Head,_Rest...&gt;{
1387     static constexpr bool value=noexcept(_Head(std::declval&lt;_Head const&amp;&gt;())) &amp;&amp; __noexcept_variant_const_copy_construct_impl&lt;true,_Rest...&gt;::value;
1388 };
1389 
1390 template&lt;&gt;
1391 struct __noexcept_variant_const_copy_construct_impl&lt;true&gt;{
1392     static constexpr bool value=true;
1393 };
1394 
1395 template&lt;typename ... _Types&gt;
1396 struct __noexcept_variant_const_copy_construct:
1397 __noexcept_variant_const_copy_construct_impl&lt;__all_copy_constructible&lt;_Types...&gt;::value,_Types...&gt;
1398 {};
1399 
1400 template&lt;bool _CopyNon_Constructible,typename ... _Types&gt;
1401 struct __noexcept_variant_non_const_copy_construct_impl{};
1402 
1403 template&lt;typename _Head,typename ... _Rest&gt;
1404 struct __noexcept_variant_non_const_copy_construct_impl&lt;true,_Head,_Rest...&gt;{
1405     static constexpr bool value=noexcept(_Head(std::declval&lt;_Head&amp;&gt;())) &amp;&amp; __noexcept_variant_non_const_copy_construct_impl&lt;true,_Rest...&gt;::value;
1406 };
1407 
1408 template&lt;&gt;
1409 struct __noexcept_variant_non_const_copy_construct_impl&lt;true&gt;{
1410     static constexpr bool value=true;
1411 };
1412 
1413 template&lt;typename ... _Types&gt;
1414 struct __noexcept_variant_non_const_copy_construct:
1415 __noexcept_variant_non_const_copy_construct_impl&lt;__all_copy_constructible&lt;_Types...&gt;::value,_Types...&gt;
1416 {};
1417 
1418 template&lt;bool _Swappable,typename ... _Types&gt;
1419 struct __noexcept_variant_swap_impl{};
1420 
1421 template &lt;typename _Head, typename... _Rest&gt;
1422 struct __noexcept_variant_swap_impl&lt;true, _Head, _Rest...&gt; {
1423     static constexpr bool value =
1424         noexcept(swap(std::declval&lt;_Head&amp;&gt;(),std::declval&lt;_Head&amp;&gt;())) &amp;&amp;
1425         __noexcept_variant_swap_impl&lt;true, _Rest...&gt;::value;
1426 };
1427 
1428 template&lt;&gt;
1429 struct __noexcept_variant_swap_impl&lt;true&gt;{
1430     static constexpr bool value=true;
1431 };
1432 
1433 template&lt;typename ... _Types&gt;
1434 struct __noexcept_variant_swap:
1435 __noexcept_variant_swap_impl&lt;__all_swappable&lt;_Types...&gt;::value,_Types...&gt;
1436 {};
1437 
1438 template&lt;typename ... _Types&gt;
1439 class Variant:
1440         private __variant_base&lt;
1441     Variant&lt;_Types...&gt;,__all_trivially_destructible&lt;_Types...&gt;::__value&gt;
1442 {
<a name="1" id="anc1"></a><span class="line-added">1443     WTF_MAKE_FAST_ALLOCATED;</span>
1444     typedef __variant_base&lt;Variant&lt;_Types...&gt;,__all_trivially_destructible&lt;_Types...&gt;::__value&gt; __base_type;
1445     friend __base_type;
1446     friend struct __copy_construct_op_table&lt;Variant&gt;;
1447     friend struct __copy_assign_op_table&lt;Variant&gt;;
1448     friend struct __move_construct_op_table&lt;Variant&gt;;
1449     friend struct __move_assign_op_table&lt;Variant&gt;;
1450     friend struct __destroy_op_table&lt;Variant&gt;;
1451 
1452     template&lt;ptrdiff_t _Index,typename ... _Types2&gt;
1453     friend struct __variant_accessor;
1454 
1455     friend struct __replace_construct_helper;
1456 
1457     typedef __variant_data&lt;_Types...&gt; __storage_type;
1458     __storage_type __storage;
1459     typename __discriminator_type&lt;sizeof ... (_Types)&gt;::__type __index;
1460 
1461     template&lt;size_t _Index,typename ... _Args&gt;
1462     size_t __emplace_construct(_Args&amp;&amp; ... __args){
1463         new(&amp;__storage) __storage_type(
1464             in_place&lt;_Index&gt;,std::forward&lt;_Args&gt;(__args)...);
1465         return  _Index;
1466     }
1467 
1468     void __destroy_self(){
1469         if(valueless_by_exception())
1470             return;
1471         __destroy_op_table&lt;Variant&gt;::__apply[index()](this);
1472         __index=-1;
1473     }
1474 
1475     ptrdiff_t __move_construct(Variant&amp; __other){
1476         ptrdiff_t const __other_index=__other.index();
1477         if(__other_index==-1)
1478             return -1;
1479         __move_construct_op_table&lt;Variant&gt;::__apply[__other_index](this,__other);
1480         __other.__destroy_self();
1481         return __other_index;
1482     }
1483 
1484     ptrdiff_t __copy_construct(Variant const&amp; __other){
1485         ptrdiff_t const __other_index=__other.index();
1486         if(__other_index==-1)
1487             return -1;
1488         __copy_construct_op_table&lt;Variant&gt;::__apply[__other_index](this,__other);
1489         return __other_index;
1490     }
1491 
1492     template&lt;size_t _Index,typename ... _Args&gt;
1493     void __replace_construct(_Args&amp;&amp; ... __args){
1494         typedef typename __indexed_type&lt;_Index,_Types...&gt;::__type __this_type;
1495         __replace_construct_helper::__helper&lt;
1496             _Index,
1497             __storage_nothrow_constructible&lt;__this_type,_Args...&gt;::__value ||
1498             (sizeof...(_Types)==1),
1499             __storage_nothrow_move_constructible&lt;__this_type&gt;::__value,
1500             __other_storage_nothrow_move_constructible&lt;
1501                 _Index,_Types...&gt;::__value
1502             &gt;::__trampoline(*this,std::forward&lt;_Args&gt;(__args)...);
1503     }
1504 
1505     template&lt;size_t _Index,typename ... _Args&gt;
1506     void __two_stage_replace(_Args&amp;&amp; ... __args){
1507         typedef typename __indexed_type&lt;_Index,_Types...&gt;::__type __type;
1508         __variant_data&lt;__type&gt; __local(
1509             in_place&lt;0&gt;,std::forward&lt;_Args&gt;(__args)...);
1510         __destroy_self();
1511         __emplace_construct&lt;_Index&gt;(
1512             std::move(__local.__get(in_place&lt;0&gt;)));
1513         __index=_Index;
1514         __local.__destroy(in_place&lt;0&gt;);
1515     }
1516 
1517     template&lt;size_t _Index,typename ... _Args&gt;
1518     void __local_backup_replace(_Args&amp;&amp; ... __args){
1519         __backup_storage&lt;_Index,_Types...&gt; __backup(__index,__storage);
1520         __emplace_construct&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1521         __index=_Index;
1522         __backup.__destroy();
1523     }
1524 
1525     template&lt;size_t _Index,typename ... _Args&gt;
1526     void __direct_replace(_Args&amp;&amp; ... __args) {
1527         __destroy_self();
1528         __emplace_construct&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1529         __index=_Index;
1530     }
1531 
1532     struct __private_type{};
1533 
1534 public:
1535     constexpr Variant()
1536         __NOEXCEPT_(noexcept(typename __indexed_type&lt;0,_Types...&gt;::__type())):
1537         __storage(in_place&lt;0&gt;),
1538         __index(0)
1539     {}
1540 
1541     constexpr Variant(typename std::conditional&lt;__all_move_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type&amp;&amp; __other)
1542     __NOEXCEPT_(__noexcept_variant_move_construct&lt;_Types...&gt;::value):
1543         __index(__move_construct(__other))
1544     {}
1545 
1546     constexpr Variant(typename std::conditional&lt;!__all_move_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type&amp;&amp; __other)=delete;
1547 
1548     constexpr Variant(typename std::conditional&lt;__all_copy_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type&amp; __other)
1549     __NOEXCEPT_(__noexcept_variant_non_const_copy_construct&lt;_Types...&gt;::value):
1550         __index(__copy_construct(__other))
1551     {}
1552 
1553     constexpr Variant(typename std::conditional&lt;!__all_copy_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type&amp; __other)=delete;
1554 
1555     constexpr Variant(typename std::conditional&lt;__all_copy_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type const&amp; __other)
1556     __NOEXCEPT_(__noexcept_variant_const_copy_construct&lt;_Types...&gt;::value):
1557         __index(__copy_construct(__other))
1558     {}
1559 
1560     constexpr Variant(typename std::conditional&lt;!__all_copy_constructible&lt;_Types...&gt;::value,Variant,__private_type&gt;::type const&amp; __other)=delete;
1561 
1562     template&lt;typename _Type,typename ... _Args&gt;
1563     explicit constexpr Variant(in_place_type_t&lt;_Type&gt;,_Args&amp;&amp; ... __args):
1564         __storage(
1565             in_place&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;,
1566             std::forward&lt;_Args&gt;(__args)...),
1567         __index(__type_index&lt;_Type,_Types...&gt;::__value)
1568     {
1569         static_assert(std::is_constructible&lt;_Type,_Args...&gt;::value,&quot;Type must be constructible from args&quot;);
1570     }
1571 
1572     template&lt;size_t _Index,typename ... _Args&gt;
1573     explicit constexpr Variant(in_place_index_t&lt;_Index&gt;,_Args&amp;&amp; ... __args):
1574         __storage(in_place&lt;_Index&gt;,std::forward&lt;_Args&gt;(__args)...),
1575         __index(_Index)
1576     {
1577         static_assert(std::is_constructible&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type,_Args...&gt;::value,&quot;Type must be constructible from args&quot;);
1578     }
1579 
1580     template&lt;typename _Type&gt;
1581     constexpr Variant(_Type&amp;&amp; __x):
1582         __storage(
1583             in_place&lt;
1584             __type_index_to_construct&lt;_Type,_Types...&gt;::__value&gt;,
1585             std::forward&lt;_Type&gt;(__x)),
1586         __index(__type_index_to_construct&lt;_Type,_Types...&gt;::__value)
1587     {}
1588 
1589     template&lt;typename _Type,
1590              typename _Enable=
1591              typename std::enable_if&lt;
1592                  (__constructible_matches&lt;std::initializer_list&lt;_Type&gt;,_Types...&gt;::__type::__length&gt;0)
1593              &gt;::type&gt;
1594     constexpr Variant(std::initializer_list&lt;_Type&gt; __x):
1595         __storage(
1596             in_place&lt;
1597             __type_index_to_construct&lt;std::initializer_list&lt;_Type&gt;,_Types...&gt;::__value&gt;,
1598             __x),
1599         __index(__type_index_to_construct&lt;std::initializer_list&lt;_Type&gt;,_Types...&gt;::__value)
1600     {}
1601 
1602     template&lt;typename _Type&gt;
1603     Variant&amp; operator=(_Type&amp;&amp; __x){
1604         constexpr size_t _Index=
1605             __type_index_to_construct&lt;_Type,_Types...&gt;::__value;
1606         if(_Index==__index){
1607             get&lt;_Index&gt;(*this)=std::forward&lt;_Type&gt;(__x);
1608         }
1609         else{
1610             __replace_construct&lt;_Index&gt;(std::forward&lt;_Type&gt;(__x));
1611         }
1612         return *this;
1613     }
1614 
1615     Variant &amp;operator=(
1616         typename std::conditional&lt;
1617             !(__all_copy_constructible&lt;_Types...&gt;::value &amp;&amp;
1618               __all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1619               __all_copy_assignable&lt;_Types...&gt;::value),
1620             Variant, __private_type&gt;::type const &amp;__other) = delete;
1621 
1622     Variant &amp;operator=(
1623         typename std::conditional&lt;
1624             __all_copy_constructible&lt;_Types...&gt;::value &amp;&amp;
1625                 __all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1626                 __all_copy_assignable&lt;_Types...&gt;::value,
1627             Variant, __private_type&gt;::type const &amp;__other) {
1628         if (__other.valueless_by_exception()) {
1629             __destroy_self();
1630         }
1631         else if(__other.index()==index()){
1632             __copy_assign_op_table&lt;Variant&gt;::__apply[index()](this,__other);
1633         }
1634         else{
1635             __replace_construct_helper::__op_table&lt;Variant&gt;::__copy_assign[
1636                 __other.index()](this,__other);
1637         }
1638         return *this;
1639     }
1640     Variant &amp;operator=(
1641         typename std::conditional&lt;
1642             !(__all_copy_constructible&lt;_Types...&gt;::value &amp;&amp;
1643               __all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1644               __all_copy_assignable&lt;_Types...&gt;::value),
1645             Variant, __private_type&gt;::type &amp;__other) = delete;
1646 
1647     Variant &amp;operator=(
1648         typename std::conditional&lt;
1649             __all_copy_constructible&lt;_Types...&gt;::value &amp;&amp;
1650                 __all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1651                 __all_copy_assignable&lt;_Types...&gt;::value,
1652             Variant, __private_type&gt;::type &amp;__other) {
1653         if(__other.valueless_by_exception()){
1654             __destroy_self();
1655         }
1656         else if(__other.index()==index()){
1657             __copy_assign_op_table&lt;Variant&gt;::__apply[index()](this,__other);
1658         }
1659         else{
1660             __replace_construct_helper::__op_table&lt;Variant&gt;::__copy_assign[
1661                 __other.index()](this,__other);
1662         }
1663         return *this;
1664     }
1665     Variant &amp;operator=(
1666         typename std::conditional&lt;
1667             !(__all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1668               __all_move_assignable&lt;_Types...&gt;::value),
1669             Variant, __private_type&gt;::type &amp;&amp;__other) = delete;
1670 
1671     Variant &amp;operator=(
1672         typename std::conditional&lt;__all_move_constructible&lt;_Types...&gt;::value &amp;&amp;
1673                                       __all_move_assignable&lt;_Types...&gt;::value,
1674                                   Variant, __private_type&gt;::type &amp;&amp;
1675             __other) __NOEXCEPT_(__noexcept_variant_move_assign&lt;_Types...&gt;::value) {
1676         if (__other.valueless_by_exception()) {
1677             __destroy_self();
1678         }
1679         else if(__other.index()==index()){
1680             __move_assign_op_table&lt;Variant&gt;::__apply[index()](this,__other);
1681             __other.__destroy_self();
1682         }
1683         else{
1684             __replace_construct_helper::__op_table&lt;Variant&gt;::__move_assign[
1685                 __other.index()](this,__other);
1686         }
1687         return *this;
1688     }
1689 
1690     template&lt;typename _Type,typename ... _Args&gt;
1691     void emplace(_Args&amp;&amp; ... __args){
1692         __direct_replace&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;(
1693             std::forward&lt;_Args&gt;(__args)...);
1694     }
1695 
1696     template&lt;size_t _Index,typename ... _Args&gt;
1697     void emplace(_Args&amp;&amp; ... __args){
1698         __direct_replace&lt;_Index&gt;(std::forward&lt;_Args&gt;(__args)...);
1699     }
1700 
1701     constexpr bool valueless_by_exception() const __NOEXCEPT{
1702         return __index==-1;
1703     }
1704     constexpr ptrdiff_t index() const __NOEXCEPT{
1705         return __index;
1706     }
1707 
1708     void swap(
1709         typename std::conditional&lt;
1710             __all_swappable&lt;_Types...&gt;::value &amp;&amp;
1711                 __all_move_constructible&lt;_Types...&gt;::value,
1712             Variant, __private_type&gt;::type
1713             &amp;__other) __NOEXCEPT_(__noexcept_variant_swap&lt;_Types...&gt;::value) {
1714         if (__other.index() == index()) {
1715             if(!valueless_by_exception())
1716                 __swap_op_table&lt;Variant&gt;::__apply[index()](*this,__other);
1717         }
1718         else{
1719             Variant __temp(std::move(__other));
1720             __other.__index=__other.__move_construct(*this);
1721             __index=__move_construct(__temp);
1722         }
1723     }
1724 };
1725 
1726 template&lt;&gt;
1727 class Variant&lt;&gt;{
1728 public:
<a name="2" id="anc2"></a><span class="line-added">1729     WTF_MAKE_FAST_ALLOCATED;</span>
1730     Variant()=delete;
1731 
1732     constexpr bool valueless_by_exception() const __NOEXCEPT{
1733         return true;
1734     }
1735     constexpr ptrdiff_t index() const __NOEXCEPT{
1736         return -1;
1737     }
1738 
1739     void swap(Variant&amp;){}
1740 };
1741 
1742 template &lt;typename... _Types&gt;
1743 typename std::enable_if&lt;__all_swappable&lt;_Types...&gt;::value &amp;&amp;
1744                             __all_move_constructible&lt;_Types...&gt;::value,
1745                         void&gt;::type
1746 swap(Variant&lt;_Types...&gt; &amp;__lhs, Variant&lt;_Types...&gt; &amp;__rhs) __NOEXCEPT_(
1747     __noexcept_variant_swap&lt;_Types...&gt;::value) {
1748     __lhs.swap(__rhs);
1749 }
1750 
1751 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1752 struct __variant_accessor{
1753     typedef typename __indexed_type&lt;_Index,_Types...&gt;::__type __type;
1754     static constexpr __type&amp; get(Variant&lt;_Types...&gt;&amp; __v){
1755         return __v.__storage.__get(in_place&lt;_Index&gt;);
1756     }
1757     static constexpr __type const&amp; get(Variant&lt;_Types...&gt; const&amp; __v){
1758         return __v.__storage.__get(in_place&lt;_Index&gt;);
1759     }
1760     static constexpr __type&amp;&amp; get(Variant&lt;_Types...&gt;&amp;&amp; __v){
1761         return __v.__storage.__get_rref(in_place&lt;_Index&gt;);
1762     }
1763     static constexpr const __type&amp;&amp; get(Variant&lt;_Types...&gt; const&amp;&amp; __v){
1764         return __v.__storage.__get_rref(in_place&lt;_Index&gt;);
1765     }
1766 };
1767 
1768 template&lt;typename _Type,typename ... _Types&gt;
1769 constexpr _Type&amp; get(Variant&lt;_Types...&gt;&amp; __v){
1770     return get&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;(__v);
1771 }
1772 
1773 template&lt;typename _Type,typename ... _Types&gt;
1774 constexpr _Type&amp;&amp; get(Variant&lt;_Types...&gt;&amp;&amp; __v){
1775     return get&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;(std::move(__v));
1776 }
1777 
1778 template&lt;typename _Type,typename ... _Types&gt;
1779 constexpr _Type const&amp; get(Variant&lt;_Types...&gt; const&amp; __v){
1780     return get&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;(__v);
1781 }
1782 
1783 template&lt;typename _Type,typename ... _Types&gt;
1784 constexpr const _Type&amp;&amp; get(Variant&lt;_Types...&gt; const&amp;&amp; __v){
1785     return get&lt;__type_index&lt;_Type,_Types...&gt;::__value&gt;(std::move(__v));
1786 }
1787 
1788 
1789 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1790 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type const&amp; get(Variant&lt;_Types...&gt; const&amp; __v){
1791     return *(
1792         (_Index!=__v.index())
1793             ? std::addressof(__throw_bad_variant_access&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type const&amp;&gt;(&quot;Bad Variant index in get&quot;))
1794             : std::addressof(__variant_accessor&lt;_Index,_Types...&gt;::get(__v))
1795     );
1796 }
1797 
1798 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1799 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp; get(Variant&lt;_Types...&gt;&amp; __v){
1800     return *(
1801         (_Index!=__v.index())
1802             ? std::addressof(__throw_bad_variant_access&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp;&gt;(&quot;Bad Variant index in get&quot;))
1803             : std::addressof(__variant_accessor&lt;_Index,_Types...&gt;::get(__v))
1804     );
1805 }
1806 
1807 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1808 constexpr typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp;&amp; get(Variant&lt;_Types...&gt;&amp;&amp; __v){
1809     return __variant_accessor&lt;_Index,_Types...&gt;::get(
1810         (((_Index!=__v.index()) ? __throw_bad_variant_access&lt;int&gt;(&quot;Bad Variant index in get&quot;) : 0), std::move(__v))
1811     );
1812 }
1813 
1814 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1815 constexpr const typename __indexed_type&lt;_Index,_Types...&gt;::__type&amp;&amp; get(Variant&lt;_Types...&gt; const&amp;&amp; __v){
1816     return __variant_accessor&lt;_Index,_Types...&gt;::get(
1817         (((_Index!=__v.index()) ? __throw_bad_variant_access&lt;int&gt;(&quot;Bad Variant index in get&quot;) : 0), std::move(__v))
1818     );
1819 }
1820 
1821 template&lt;typename _Type,typename ... _Types&gt;
1822 constexpr std::add_pointer_t&lt;_Type&gt; get_if(Variant&lt;_Types...&gt;&amp; __v){
1823     return (__type_index&lt;_Type,_Types...&gt;::__value!=__v.index())?nullptr:std::addressof(get&lt;_Type&gt;(__v));
1824 }
1825 
1826 template&lt;typename _Type,typename ... _Types&gt;
1827 constexpr std::add_pointer_t&lt;_Type const&gt; get_if(Variant&lt;_Types...&gt; const&amp; __v){
1828     return (__type_index&lt;_Type,_Types...&gt;::__value!=__v.index())?nullptr:std::addressof(get&lt;_Type&gt;(__v));
1829 }
1830 
1831 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1832 constexpr std::add_pointer_t&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type&gt; get_if(Variant&lt;_Types...&gt;&amp; __v){
1833     return ((_Index!=__v.index())?nullptr:
1834         std::addressof(__variant_accessor&lt;_Index,_Types...&gt;::get(__v)));
1835 }
1836 
1837 template&lt;ptrdiff_t _Index,typename ... _Types&gt;
1838 constexpr std::add_pointer_t&lt;typename __indexed_type&lt;_Index,_Types...&gt;::__type const&gt; get_if(
1839     Variant&lt;_Types...&gt; const&amp; __v){
1840     return ((_Index!=__v.index())?nullptr:
1841         std::addressof(__variant_accessor&lt;_Index,_Types...&gt;::get(__v)));
1842 }
1843 
1844 template&lt;typename _Type,typename ... _Types&gt;
1845 constexpr bool holds_alternative(Variant&lt;_Types...&gt; const&amp; __v) __NOEXCEPT{
1846     return __v.index()==__type_index&lt;_Type,_Types...&gt;::__value;
1847 }
1848 
1849 template&lt;typename _Visitor,typename ... _Types&gt;
1850 struct __visitor_return_type;
1851 
1852 template&lt;typename _Visitor&gt;
1853 struct __visitor_return_type&lt;_Visitor&gt;{
1854     typedef decltype(std::declval&lt;_Visitor&amp;&gt;()()) __type;
1855 };
1856 
1857 template&lt;typename _Visitor,typename _Head,typename ... _Rest&gt;
1858 struct __visitor_return_type&lt;_Visitor,_Head,_Rest...&gt;{
1859     typedef decltype(std::declval&lt;_Visitor&amp;&gt;()(std::declval&lt;_Head&amp;&gt;())) __type;
1860 };
1861 
1862 template&lt;typename _Visitor,typename ... _Types&gt;
1863 struct __visitor_table{
1864     typedef Variant&lt;_Types...&gt; __variant_type;
1865     typedef typename __visitor_return_type&lt;_Visitor,_Types...&gt;::__type __return_type;
1866     typedef __return_type (*__func_type)(_Visitor&amp;,__variant_type&amp;);
1867 
1868     template&lt;typename _Type&gt;
1869     static __return_type __trampoline_func(_Visitor&amp; __visitor,__variant_type&amp; __v){
1870         return __visitor(get&lt;_Type&gt;(__v));
1871     }
1872 
<a name="3" id="anc3"></a><span class="line-modified">1873     static const __func_type __trampoline[sizeof...(_Types)];</span>


1874 };
1875 
1876 template&lt;typename _Visitor,typename ... _Types&gt;
<a name="4" id="anc4"></a><span class="line-modified">1877 const typename __visitor_table&lt;_Visitor,_Types...&gt;::__func_type __visitor_table&lt;_Visitor,_Types...&gt;::__trampoline[sizeof...(_Types)]={</span>
<span class="line-added">1878         &amp;__trampoline_func&lt;_Types&gt;...</span>
<span class="line-added">1879     };</span>
1880 
1881 template&lt;typename _Visitor,typename ... _Types&gt;
1882 constexpr typename __visitor_return_type&lt;_Visitor,_Types...&gt;::__type
1883 visit(_Visitor&amp;&amp; __visitor,Variant&lt;_Types...&gt;&amp; __v){
1884     return (__v.valueless_by_exception())
1885         ? __throw_bad_variant_access&lt;typename __visitor_return_type&lt;_Visitor,_Types...&gt;::__type&gt;(&quot;Visiting of empty Variant&quot;)
1886         : __visitor_table&lt;_Visitor,_Types...&gt;::__trampoline[__v.index()](__visitor,__v);
1887 }
1888 
1889 template&lt;typename _Visitor,typename ... _Variants&gt;
1890 struct __multi_visitor_return_type{
1891     typedef decltype(std::declval&lt;_Visitor&amp;&gt;()(get&lt;0&gt;(std::declval&lt;_Variants&gt;())...))
1892     __type;
1893 };
1894 
1895 template&lt;size_t _VariantIndex,typename _Indices&gt;
1896 struct __visit_helper;
1897 
1898 template&lt;ptrdiff_t ... _Indices&gt;
1899 struct __visit_helper&lt;0,__index_sequence&lt;_Indices...&gt;&gt;{
1900     template&lt;typename _Visitor,typename ... _Variants&gt;
1901     static constexpr typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type
1902     __visit(_Visitor&amp; __visitor,_Variants&amp; ... __v){
1903         return __visitor(get&lt;_Indices&gt;(__v)...);
1904     }
1905 };
1906 
1907 template&lt;size_t _Index,typename ... _Args&gt;
1908 struct __arg_selector_t;
1909 
1910 template&lt;typename _Head,typename ... _Rest&gt;
1911 struct __arg_selector_t&lt;0,_Head,_Rest...&gt;{
1912     typedef _Head __type;
1913 
1914     static constexpr __type&amp; __select(_Head&amp; __head,_Rest&amp; ...){
1915         return __head;
1916     }
1917 };
1918 
1919 template&lt;size_t _Index,typename _Head,typename ... _Rest&gt;
1920 struct __arg_selector_t&lt;_Index,_Head,_Rest...&gt;{
1921     typedef typename __arg_selector_t&lt;_Index-1,_Rest...&gt;::__type __type;
1922     static constexpr __type&amp; __select(_Head&amp;,_Rest&amp; ... __rest){
1923         return __arg_selector_t&lt;_Index-1,_Rest...&gt;::__select(__rest...);
1924     }
1925 };
1926 
1927 template&lt;size_t _Index,typename ... _Args&gt;
1928 constexpr typename __arg_selector_t&lt;_Index,_Args...&gt;::__type&amp;&amp; __arg_selector(_Args&amp;&amp; ... __args){
1929     return std::forward&lt;typename __arg_selector_t&lt;_Index,_Args...&gt;::__type&gt;(
1930         __arg_selector_t&lt;_Index,_Args...&gt;::__select(__args...));
1931 }
1932 
1933 template&lt;ptrdiff_t _Index,size_t _VariantIndex,ptrdiff_t ... _Indices&gt;
1934 struct __visit_helper2{
1935     template&lt;typename _Visitor,typename ... _Variants&gt;
1936     static constexpr typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type
1937     __visit(_Visitor&amp; __visitor,_Variants&amp;&amp; ... __v){
1938         return (__arg_selector&lt;_VariantIndex-1&gt;(__v...).index()==_Index)
1939             ? __visit_helper&lt;_VariantIndex-1,__index_sequence&lt;_Index,_Indices...&gt;&gt;::__visit(__visitor,std::forward&lt;_Variants&gt;(__v)...)
1940             : __visit_helper2&lt;_Index-1,_VariantIndex,_Indices...&gt;::__visit(__visitor,std::forward&lt;_Variants&gt;(__v)...);
1941     }
1942 };
1943 
1944 template&lt;size_t _VariantIndex,ptrdiff_t ... _Indices&gt;
1945 struct __visit_helper2&lt;-1,_VariantIndex,_Indices...&gt;{
1946     template&lt;typename _Visitor,typename ... _Variants&gt;
1947     static constexpr typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type
1948     __visit(_Visitor&amp;,_Variants&amp;&amp; ...){
1949         return __throw_bad_variant_access&lt;typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type&gt;(&quot;Visiting of empty Variant&quot;);
1950     }
1951 };
1952 
1953 template&lt;typename _Variant&gt;
1954 struct __variant_type_count;
1955 
1956 template&lt;typename ... _Types&gt;
1957 struct __variant_type_count&lt;Variant&lt;_Types...&gt;&gt;{
1958     static constexpr size_t __value=sizeof...(_Types);
1959 };
1960 
1961 template&lt;typename _Variant&gt;
1962 struct __variant_type_count&lt;_Variant&amp;&gt;{
1963     static constexpr size_t __value=__variant_type_count&lt;_Variant&gt;::__value;
1964 };
1965 
1966 template&lt;typename _Variant&gt;
1967 struct __variant_type_count&lt;_Variant const&amp;&gt;{
1968     static constexpr size_t __value=__variant_type_count&lt;_Variant&gt;::__value;
1969 };
1970 
1971 template&lt;size_t _VariantIndex,ptrdiff_t ... _Indices&gt;
1972 struct __visit_helper&lt;_VariantIndex,__index_sequence&lt;_Indices...&gt;&gt;{
1973 
1974     template&lt;typename _Visitor,typename ... _Variants&gt;
1975     static constexpr typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type
1976     __visit(_Visitor&amp; __visitor,_Variants&amp;&amp; ... __v){
1977         return __visit_helper2&lt;
1978             __variant_type_count&lt;
1979                 typename __arg_selector_t&lt;
1980                     _VariantIndex-1,_Variants...&gt;::__type&gt;::__value-1,
1981             _VariantIndex,_Indices...&gt;::__visit(
1982                 __visitor,std::forward&lt;_Variants&amp;&amp;&gt;(__v)...);
1983     }
1984 };
1985 
1986 template&lt;typename _Visitor,typename ... _Variants&gt;
1987 constexpr typename __multi_visitor_return_type&lt;_Visitor,_Variants...&gt;::__type
1988 visit(_Visitor&amp;&amp; __visitor,_Variants&amp;&amp; ... __v){
1989     return __visit_helper&lt;sizeof...(_Variants),__index_sequence&lt;&gt;&gt;::__visit(
1990         __visitor,std::forward&lt;_Variants&gt;(__v)...);
1991 }
1992 
1993 template&lt;typename ... _Types&gt;
1994 constexpr bool operator==(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
1995     return (__lhs.index()==__rhs.index()) &amp;&amp;
1996         ((__lhs.index()==-1) ||
1997          __equality_op_table&lt;Variant&lt;_Types...&gt;&gt;::__equality_compare[__lhs.index()](
1998              __lhs,__rhs));
1999 }
2000 
2001 template&lt;typename ... _Types&gt;
2002 constexpr bool operator!=(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
2003     return !(__lhs==__rhs);
2004 }
2005 
2006 template&lt;typename ... _Types&gt;
2007 constexpr bool operator&lt;(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
2008     return (__lhs.index()&lt;__rhs.index()) ||
2009         ((__lhs.index()==__rhs.index()) &amp;&amp;
2010          ((__lhs.index()!=-1) &amp;&amp;
2011           __less_than_op_table&lt;Variant&lt;_Types...&gt;&gt;::
2012           __less_than_compare[__lhs.index()](__lhs,__rhs)));
2013 }
2014 
2015 template&lt;typename ... _Types&gt;
2016 constexpr bool operator&gt;(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
2017     return __rhs&lt;__lhs;
2018 }
2019 
2020 template&lt;typename ... _Types&gt;
2021 constexpr bool operator&gt;=(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
2022     return !(__lhs&lt;__rhs);
2023 }
2024 
2025 template&lt;typename ... _Types&gt;
2026 constexpr bool operator&lt;=(Variant&lt;_Types...&gt; const&amp; __lhs,Variant&lt;_Types...&gt; const&amp; __rhs){
2027     return !(__lhs&gt;__rhs);
2028 }
2029 
2030 struct Monostate{};
2031 
2032 constexpr bool operator==(Monostate const&amp;, Monostate const&amp;) { return true; }
2033 constexpr bool operator!=(Monostate const&amp;, Monostate const&amp;) { return false; }
2034 constexpr bool operator&gt;=(Monostate const&amp;, Monostate const&amp;) { return true; }
2035 constexpr bool operator&lt;=(Monostate const&amp;, Monostate const&amp;) { return true; }
2036 constexpr bool operator&gt;(Monostate const&amp;, Monostate const&amp;) { return false; }
2037 constexpr bool operator&lt;(Monostate const&amp;, Monostate const&amp;) { return false; }
2038 
2039 struct __hash_visitor{
2040     template&lt;typename _Type&gt;
2041     size_t operator()(_Type const&amp; __x){
2042         return std::hash&lt;_Type&gt;()(__x);
2043     }
2044 };
2045 
2046 // -- WebKit Additions --
2047 
2048 template&lt;class V, class... F&gt;
<a name="5" id="anc5"></a><span class="line-modified">2049 auto switchOn(V&amp;&amp; v, F&amp;&amp;... f) -&gt; decltype(WTF::visit(makeVisitor(std::forward&lt;F&gt;(f)...), std::forward&lt;V&gt;(v)))</span>
2050 {
<a name="6" id="anc6"></a><span class="line-modified">2051     return WTF::visit(makeVisitor(std::forward&lt;F&gt;(f)...), std::forward&lt;V&gt;(v));</span>
2052 }
2053 
2054 } // namespace WTF
2055 
2056 namespace std {
2057 
2058 template&lt;&gt;
2059 struct hash&lt;WTF::Monostate&gt;{
2060     size_t operator()(WTF::Monostate) __NOEXCEPT{
2061         return 42;
2062     }
2063 };
2064 
2065 template&lt;typename ... _Types&gt;
2066 struct hash&lt;WTF::Variant&lt;_Types...&gt;&gt;{
2067     size_t operator()(WTF::Variant&lt;_Types...&gt; const &amp;v) __NOEXCEPT {
2068         return std::hash&lt;ptrdiff_t&gt;()(v.index()) ^ WTF::visit(WTF::__hash_visitor(), v);
2069     }
2070 };
2071 
2072 } // namespace std
2073 
2074 using WTF::Monostate;
2075 using WTF::Variant;
2076 
2077 #endif // !COMPILER(CLANG) || WTF_CPP_STD_VER &gt;= 14
2078 
2079 #if COMPILER(MSVC)
2080 #pragma warning(pop)
2081 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>