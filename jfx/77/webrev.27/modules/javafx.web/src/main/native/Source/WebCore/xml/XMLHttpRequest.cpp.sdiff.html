<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLErrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;MIMETypeRegistry.h&quot;
  43 #include &quot;MemoryCache.h&quot;
  44 #include &quot;ParsedContentType.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceRequest.h&quot;
  47 #include &quot;RuntimeApplicationChecks.h&quot;
  48 #include &quot;SecurityOriginPolicy.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StringAdaptors.h&quot;
  52 #include &quot;TextResourceDecoder.h&quot;
  53 #include &quot;ThreadableLoader.h&quot;
  54 #include &quot;XMLDocument.h&quot;
  55 #include &quot;XMLHttpRequestProgressEvent.h&quot;
  56 #include &quot;XMLHttpRequestUpload.h&quot;
  57 #include &quot;markup.h&quot;
  58 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  59 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
  60 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  61 #include &lt;JavaScriptCore/JSLock.h&gt;

  62 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  63 #include &lt;wtf/StdLibExtras.h&gt;
  64 #include &lt;wtf/text/CString.h&gt;
  65 
  66 namespace WebCore {
  67 




  68 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, xmlHttpRequestCounter, (&quot;XMLHttpRequest&quot;));
  69 
  70 // Histogram enum to see when we can deprecate xhr.send(ArrayBuffer).
  71 enum XMLHttpRequestSendArrayBufferOrView {
  72     XMLHttpRequestSendArrayBuffer,
  73     XMLHttpRequestSendArrayBufferView,
  74     XMLHttpRequestSendArrayBufferOrViewMax,
  75 };
  76 
<span class="line-modified">  77 static void replaceCharsetInMediaType(String&amp; mediaType, const String&amp; charsetValue)</span>
  78 {
<span class="line-modified">  79     unsigned pos = 0, len = 0;</span>
<span class="line-modified">  80 </span>
<span class="line-removed">  81     findCharsetInMediaType(mediaType, pos, len);</span>
<span class="line-removed">  82 </span>
<span class="line-removed">  83     if (!len) {</span>
<span class="line-removed">  84         // When no charset found, do nothing.</span>
  85         return;
<span class="line-removed">  86     }</span>
  87 
<span class="line-modified">  88     // Found at least one existing charset, replace all occurrences with new charset.</span>
<span class="line-modified">  89     while (len) {</span>
<span class="line-removed">  90         mediaType.replace(pos, len, charsetValue);</span>
<span class="line-removed">  91         unsigned start = pos + charsetValue.length();</span>
<span class="line-removed">  92         findCharsetInMediaType(mediaType, pos, len, start);</span>
<span class="line-removed">  93     }</span>
  94 }
  95 
  96 static void logConsoleError(ScriptExecutionContext* context, const String&amp; message)
  97 {
  98     if (!context)
  99         return;
 100     // FIXME: It&#39;s not good to report the bad usage without indicating what source line it came from.
 101     // We should pass additional parameters so we can tell the console where the mistake occurred.
 102     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);
 103 }
 104 
 105 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 106 {
 107     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 108     xmlHttpRequest-&gt;suspendIfNeeded();
 109     return xmlHttpRequest;
 110 }
 111 
 112 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 113     : ActiveDOMObject(&amp;context)
 114     , m_async(true)
 115     , m_includeCredentials(false)
 116     , m_sendFlag(false)
 117     , m_createdDocument(false)
 118     , m_error(false)
 119     , m_uploadListenerFlag(false)
 120     , m_uploadComplete(false)
 121     , m_wasAbortedByClient(false)
 122     , m_responseCacheIsValid(false)
 123     , m_dispatchErrorOnResuming(false)
 124     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 125     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
 126     , m_progressEventThrottle(this)
 127     , m_resumeTimer(*this, &amp;XMLHttpRequest::resumeTimerFired)
 128     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 129     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)

 130 {
 131 #ifndef NDEBUG
 132     xmlHttpRequestCounter.increment();
 133 #endif
 134 }
 135 
 136 XMLHttpRequest::~XMLHttpRequest()
 137 {
 138 #ifndef NDEBUG
 139     xmlHttpRequestCounter.decrement();
 140 #endif
 141 }
 142 
 143 Document* XMLHttpRequest::document() const
 144 {
 145     ASSERT(scriptExecutionContext());
 146     return downcast&lt;Document&gt;(scriptExecutionContext());
 147 }
 148 
 149 SecurityOrigin* XMLHttpRequest::securityOrigin() const
 150 {
 151     return scriptExecutionContext()-&gt;securityOrigin();
 152 }
 153 
<span class="line-removed"> 154 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 155 </span>
<span class="line-removed"> 156 bool XMLHttpRequest::usesDashboardBackwardCompatibilityMode() const</span>
<span class="line-removed"> 157 {</span>
<span class="line-removed"> 158     if (scriptExecutionContext()-&gt;isWorkerGlobalScope())</span>
<span class="line-removed"> 159         return false;</span>
<span class="line-removed"> 160     return document()-&gt;settings().usesDashboardBackwardCompatibilityMode();</span>
<span class="line-removed"> 161 }</span>
<span class="line-removed"> 162 </span>
<span class="line-removed"> 163 #endif</span>
<span class="line-removed"> 164 </span>
 165 ExceptionOr&lt;OwnedString&gt; XMLHttpRequest::responseText()
 166 {
 167     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Text)
 168         return Exception { InvalidStateError };
 169     return OwnedString { responseTextIgnoringResponseType() };
 170 }
 171 
 172 void XMLHttpRequest::didCacheResponse()
 173 {
 174     ASSERT(doneWithoutErrors());
 175     m_responseCacheIsValid = true;
 176     m_responseBuilder.clear();
 177 }
 178 
 179 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 180 {
 181     ASSERT(scriptExecutionContext()-&gt;isDocument());
 182 
 183     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 184         return Exception { InvalidStateError };
 185 
 186     if (!doneWithoutErrors())
 187         return nullptr;
 188 
 189     if (!m_createdDocument) {


 190         String mimeType = responseMIMEType();
 191         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 192 
 193         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 194         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 195         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 196             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 197             m_responseDocument = nullptr;
 198         } else {
 199             if (isHTML)
<span class="line-modified"> 200                 m_responseDocument = HTMLDocument::create(nullptr, m_url);</span>
 201             else
<span class="line-modified"> 202                 m_responseDocument = XMLDocument::create(nullptr, m_url);</span>
 203             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 204             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<span class="line-modified"> 205             m_responseDocument-&gt;setContextDocument(downcast&lt;Document&gt;(*scriptExecutionContext()));</span>
<span class="line-modified"> 206             m_responseDocument-&gt;setSecurityOriginPolicy(scriptExecutionContext()-&gt;securityOriginPolicy());</span>
 207             m_responseDocument-&gt;overrideMIMEType(mimeType);
 208 
 209             if (!m_responseDocument-&gt;wellFormed())
 210                 m_responseDocument = nullptr;
 211         }
 212         m_createdDocument = true;
 213     }
 214 
 215     return m_responseDocument.get();
 216 }
 217 
 218 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 219 {
 220     ASSERT(responseType() == ResponseType::Blob);
 221     ASSERT(doneWithoutErrors());
 222 
 223     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 224     Vector&lt;uint8_t&gt; data;
 225     if (m_binaryResponseBuilder)
 226         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 227     m_binaryResponseBuilder = nullptr;
 228     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<span class="line-modified"> 229     return Blob::create(WTFMove(data), normalizedContentType);</span>
 230 }
 231 
 232 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 233 {
 234     ASSERT(responseType() == ResponseType::Arraybuffer);
 235     ASSERT(doneWithoutErrors());
 236 
 237     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 238     m_binaryResponseBuilder = nullptr;
 239     return result;
 240 }
 241 
 242 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 243 {
 244     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 245         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 246         return Exception { InvalidAccessError };
 247     }
 248     m_timeoutMilliseconds = timeout;
 249     if (!m_timeoutTimer.isActive())
</pre>
<hr />
<pre>
 270     if (!m_async &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; m_url.protocolIsInHTTPFamily()) {
 271         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.responseType cannot be changed for synchronous HTTP(S) requests made from the window context.&quot;);
 272         return Exception { InvalidAccessError };
 273     }
 274 
 275     m_responseType = static_cast&lt;unsigned&gt;(type);
 276     return { };
 277 }
 278 
 279 String XMLHttpRequest::responseURL() const
 280 {
 281     URL responseURL(m_response.url());
 282     responseURL.removeFragmentIdentifier();
 283 
 284     return responseURL.string();
 285 }
 286 
 287 XMLHttpRequestUpload&amp; XMLHttpRequest::upload()
 288 {
 289     if (!m_upload)
<span class="line-modified"> 290         m_upload = std::make_unique&lt;XMLHttpRequestUpload&gt;(*this);</span>
 291     return *m_upload;
 292 }
 293 
 294 void XMLHttpRequest::changeState(State newState)
 295 {
 296     if (readyState() != newState) {
 297         m_readyState = static_cast&lt;State&gt;(newState);
 298         if (readyState() == DONE) {
 299             // The XHR object itself holds on to the responseText, and
 300             // thus has extra cost even independent of any
 301             // responseText or responseXML objects it has handed
 302             // out. But it is protected from GC while loading, so this
 303             // can&#39;t be recouped until the load is done, so only
 304             // report the extra cost at that point.
 305             if (auto* context = scriptExecutionContext()) {
 306                 JSC::VM&amp; vm = context-&gt;vm();
 307                 JSC::JSLockHolder lock(vm);
 308                 vm.heap.reportExtraMemoryAllocated(memoryCost());
 309             }
 310         }
</pre>
<hr />
<pre>
 425         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 426     ASSERT(!m_loader);
 427 
 428     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 429     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 430         if (!m_async)
 431             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 432         setPendingActivity(*this);
 433         m_timeoutTimer.stop();
 434         m_networkErrorTimer.startOneShot(0_s);
 435         return ExceptionOr&lt;void&gt; { };
 436     }
 437 
 438     m_error = false;
 439     return WTF::nullopt;
 440 }
 441 
 442 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 443 {
 444     InspectorInstrumentation::willSendXMLHttpRequest(scriptExecutionContext(), url());

 445 
 446     ExceptionOr&lt;void&gt; result;
 447     if (!sendType)
 448         result = send();
 449     else {
 450         result = WTF::switchOn(sendType.value(),
 451             [this] (const RefPtr&lt;Document&gt;&amp; document) -&gt; ExceptionOr&lt;void&gt; { return send(*document); },
 452             [this] (const RefPtr&lt;Blob&gt;&amp; blob) -&gt; ExceptionOr&lt;void&gt; { return send(*blob); },
 453             [this] (const RefPtr&lt;JSC::ArrayBufferView&gt;&amp; arrayBufferView) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBufferView); },
 454             [this] (const RefPtr&lt;JSC::ArrayBuffer&gt;&amp; arrayBuffer) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBuffer); },
 455             [this] (const RefPtr&lt;DOMFormData&gt;&amp; formData) -&gt; ExceptionOr&lt;void&gt; { return send(*formData); },
 456             [this] (const String&amp; string) -&gt; ExceptionOr&lt;void&gt; { return send(string); }
 457         );
 458     }
 459 
 460     return result;
 461 }
 462 
 463 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Document&amp; document)
 464 {
 465     if (auto result = prepareToSend())
 466         return WTFMove(result.value());
 467 
<span class="line-modified"> 468     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot; &amp;&amp; m_url.protocolIsInHTTPFamily()) {</span>
 469         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
<span class="line-modified"> 470 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-modified"> 471             if (usesDashboardBackwardCompatibilityMode())</span>
<span class="line-removed"> 472                 m_requestHeaders.set(HTTPHeaderName::ContentType, &quot;application/x-www-form-urlencoded&quot;_s);</span>
<span class="line-removed"> 473             else</span>
<span class="line-removed"> 474 #endif</span>
<span class="line-removed"> 475                 // FIXME: this should include the charset used for encoding.</span>
<span class="line-removed"> 476                 m_requestHeaders.set(HTTPHeaderName::ContentType, document.isHTMLDocument() ? &quot;text/html;charset=UTF-8&quot;_s : &quot;application/xml;charset=UTF-8&quot;_s);</span>
 477         } else {
 478             String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
<span class="line-modified"> 479             replaceCharsetInMediaType(contentType, &quot;UTF-8&quot;);</span>
 480             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 481         }
 482 
 483         // FIXME: According to XMLHttpRequest Level 2, this should use the Document.innerHTML algorithm
 484         // from the HTML5 specification to serialize the document.
 485         m_requestEntityBody = FormData::create(UTF8Encoding().encode(serializeFragment(document, SerializedNodes::SubtreeIncludingNode), UnencodableHandling::Entities));
 486         if (m_upload)
 487             m_requestEntityBody-&gt;setAlwaysStream(true);
 488     }
 489 
 490     return createRequest();
 491 }
 492 
 493 ExceptionOr&lt;void&gt; XMLHttpRequest::send(const String&amp; body)
 494 {
 495     if (auto result = prepareToSend())
 496         return WTFMove(result.value());
 497 
<span class="line-modified"> 498     if (!body.isNull() &amp;&amp; m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot; &amp;&amp; m_url.protocolIsInHTTPFamily()) {</span>
 499         String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
 500         if (contentType.isNull()) {
<span class="line-modified"> 501 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 502             if (usesDashboardBackwardCompatibilityMode())</span>
<span class="line-removed"> 503                 m_requestHeaders.set(HTTPHeaderName::ContentType, &quot;application/x-www-form-urlencoded&quot;_s);</span>
<span class="line-removed"> 504             else</span>
<span class="line-removed"> 505 #endif</span>
<span class="line-removed"> 506                 m_requestHeaders.set(HTTPHeaderName::ContentType, HTTPHeaderValues::textPlainContentType());</span>
 507         } else {
<span class="line-modified"> 508             replaceCharsetInMediaType(contentType, &quot;UTF-8&quot;);</span>
 509             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 510         }
 511 
 512         m_requestEntityBody = FormData::create(UTF8Encoding().encode(body, UnencodableHandling::Entities));
 513         if (m_upload)
 514             m_requestEntityBody-&gt;setAlwaysStream(true);
 515     }
 516 
 517     return createRequest();
 518 }
 519 
 520 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Blob&amp; body)
 521 {
 522     if (auto result = prepareToSend())
 523         return WTFMove(result.value());
 524 
<span class="line-modified"> 525     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot; &amp;&amp; m_url.protocolIsInHTTPFamily()) {</span>










 526         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
 527             const String&amp; blobType = body.type();
 528             if (!blobType.isEmpty() &amp;&amp; isValidContentType(blobType))
 529                 m_requestHeaders.set(HTTPHeaderName::ContentType, blobType);
 530             else {
 531                 // From FileAPI spec, whenever media type cannot be determined, empty string must be returned.
 532                 m_requestHeaders.set(HTTPHeaderName::ContentType, emptyString());
 533             }
 534         }
 535 
 536         m_requestEntityBody = FormData::create();
 537         m_requestEntityBody-&gt;appendBlob(body.url());
 538     }
 539 
 540     return createRequest();
 541 }
 542 
 543 ExceptionOr&lt;void&gt; XMLHttpRequest::send(DOMFormData&amp; body)
 544 {
 545     if (auto result = prepareToSend())
 546         return WTFMove(result.value());
 547 
<span class="line-modified"> 548     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot; &amp;&amp; m_url.protocolIsInHTTPFamily()) {</span>
<span class="line-modified"> 549         m_requestEntityBody = FormData::createMultiPart(body, document());</span>
<span class="line-removed"> 550         m_requestEntityBody-&gt;generateFiles(document());</span>
 551         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType))
 552             m_requestHeaders.set(HTTPHeaderName::ContentType, makeString(&quot;multipart/form-data; boundary=&quot;, m_requestEntityBody-&gt;boundary().data()));
 553     }
 554 
 555     return createRequest();
 556 }
 557 
 558 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBuffer&amp; body)
 559 {
 560     ASCIILiteral consoleMessage { &quot;ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.&quot;_s };
 561     scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);
 562     return sendBytesData(body.data(), body.byteLength());
 563 }
 564 
 565 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBufferView&amp; body)
 566 {
 567     return sendBytesData(body.baseAddress(), body.byteLength());
 568 }
 569 
 570 ExceptionOr&lt;void&gt; XMLHttpRequest::sendBytesData(const void* data, size_t length)
 571 {
 572     if (auto result = prepareToSend())
 573         return WTFMove(result.value());
 574 
<span class="line-modified"> 575     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot; &amp;&amp; m_url.protocolIsInHTTPFamily()) {</span>
 576         m_requestEntityBody = FormData::create(data, length);
 577         if (m_upload)
 578             m_requestEntityBody-&gt;setAlwaysStream(true);
 579     }
 580 
 581     return createRequest();
 582 }
 583 
 584 ExceptionOr&lt;void&gt; XMLHttpRequest::createRequest()
 585 {
 586     // Only GET request is supported for blob URL.
 587     if (!m_async &amp;&amp; m_url.protocolIsBlob() &amp;&amp; m_method != &quot;GET&quot;)
 588         return Exception { NetworkError };
 589 
 590     if (m_async &amp;&amp; m_upload &amp;&amp; m_upload-&gt;hasEventListeners())
 591         m_uploadListenerFlag = true;
 592 
 593     ResourceRequest request(m_url);
 594     request.setRequester(ResourceRequest::Requester::XHR);
 595     request.setInitiatorIdentifier(scriptExecutionContext()-&gt;resourceRequestIdentifier());
</pre>
<hr />
<pre>
 618     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 619 
 620     if (m_timeoutMilliseconds) {
 621         if (!m_async)
 622             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 623         else {
 624             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 625             m_sendingTime = MonotonicTime::now();
 626             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 627         }
 628     }
 629 
 630     m_exceptionCode = WTF::nullopt;
 631     m_error = false;
 632     m_uploadComplete = !request.httpBody();
 633     m_sendFlag = true;
 634 
 635     if (m_async) {
 636         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 637         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<span class="line-modified"> 638             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent);</span>
 639 
 640         if (readyState() != OPENED || !m_sendFlag || m_loader)
 641             return { };
 642 
 643         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 644         // This is true while running onunload handlers.
 645         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 646         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 647 
 648         // Either loader is null or some error was synchronously sent to us.
 649         ASSERT(m_loader || !m_sendFlag);
 650 
 651         // Neither this object nor the JavaScript wrapper should be deleted while
 652         // a request is in progress because we need to keep the listeners alive,
 653         // and they are referenced by the JavaScript wrapper.
 654         if (m_loader)
 655             setPendingActivity(*this);
 656     } else {
 657         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 658         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
</pre>
<hr />
<pre>
 776 {
 777     if (readyState() == DONE)
 778         return m_responseBuilder.length() * 2;
 779     return 0;
 780 }
 781 
 782 ExceptionOr&lt;void&gt; XMLHttpRequest::overrideMimeType(const String&amp; mimeType)
 783 {
 784     if (readyState() == LOADING || readyState() == DONE)
 785         return Exception { InvalidStateError };
 786 
 787     m_mimeTypeOverride = &quot;application/octet-stream&quot;_s;
 788     if (isValidContentType(mimeType))
 789         m_mimeTypeOverride = mimeType;
 790 
 791     return { };
 792 }
 793 
 794 ExceptionOr&lt;void&gt; XMLHttpRequest::setRequestHeader(const String&amp; name, const String&amp; value)
 795 {
<span class="line-modified"> 796     if (readyState() != OPENED || m_sendFlag) {</span>
<span class="line-removed"> 797 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 798         if (usesDashboardBackwardCompatibilityMode())</span>
<span class="line-removed"> 799             return { };</span>
<span class="line-removed"> 800 #endif</span>
 801         return Exception { InvalidStateError };
<span class="line-removed"> 802     }</span>
 803 
 804     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 805     if (!isValidHTTPToken(name) || !isValidHTTPHeaderValue(normalizedValue))
 806         return Exception { SyntaxError };
 807 
 808     bool allowUnsafeHeaderField = false;
<span class="line-modified"> 809 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-modified"> 810     allowUnsafeHeaderField = usesDashboardBackwardCompatibilityMode();</span>
<span class="line-removed"> 811 #endif</span>
<span class="line-removed"> 812     if (securityOrigin()-&gt;canLoadLocalResources() &amp;&amp; document()-&gt;settings().allowSettingAnyXHRHeaderFromFileURLs())</span>
 813         allowUnsafeHeaderField = true;
 814     if (!allowUnsafeHeaderField &amp;&amp; isForbiddenHeaderName(name)) {
 815         logConsoleError(scriptExecutionContext(), &quot;Refused to set unsafe header \&quot;&quot; + name + &quot;\&quot;&quot;);
 816         return { };
 817     }
 818 
 819     m_requestHeaders.add(name, normalizedValue);
 820     return { };
 821 }
 822 
 823 String XMLHttpRequest::getAllResponseHeaders() const
 824 {
 825     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 826         return emptyString();
 827 
 828     if (!m_allResponseHeaders) {
 829         Vector&lt;String&gt; headers;
 830         headers.reserveInitialCapacity(m_response.httpHeaderFields().size());
 831 
 832         for (auto&amp; header : m_response.httpHeaderFields()) {
</pre>
<hr />
<pre>
 843         for (auto&amp; header : headers)
 844             stringBuilder.append(header);
 845         m_allResponseHeaders = stringBuilder.toString();
 846     }
 847 
 848     return m_allResponseHeaders;
 849 }
 850 
 851 String XMLHttpRequest::getResponseHeader(const String&amp; name) const
 852 {
 853     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 854         return String();
 855 
 856     return m_response.httpHeaderField(name);
 857 }
 858 
 859 String XMLHttpRequest::responseMIMEType() const
 860 {
 861     String mimeType = extractMIMETypeFromMediaType(m_mimeTypeOverride);
 862     if (mimeType.isEmpty()) {

 863         if (m_response.isHTTP())
<span class="line-modified"> 864             mimeType = extractMIMETypeFromMediaType(m_response.httpHeaderField(HTTPHeaderName::ContentType));</span>
 865         else
<span class="line-modified"> 866             mimeType = m_response.mimeType();</span>
<span class="line-modified"> 867         if (mimeType.isEmpty())</span>
<span class="line-modified"> 868             mimeType = &quot;text/xml&quot;_s;</span>

 869     }
 870     return mimeType;
 871 }
 872 
 873 bool XMLHttpRequest::responseIsXML() const
 874 {
 875     return MIMETypeRegistry::isXMLMIMEType(responseMIMEType());
 876 }
 877 
 878 int XMLHttpRequest::status() const
 879 {
 880     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 881         return 0;
 882 
 883     return m_response.httpStatusCode();
 884 }
 885 
 886 String XMLHttpRequest::statusText() const
 887 {
 888     if (readyState() == UNSENT || readyState() == OPENED || m_error)
</pre>
<hr />
<pre>
 938     bool hadLoader = m_loader;
 939     m_loader = nullptr;
 940 
 941     m_sendFlag = false;
 942     changeState(DONE);
 943     m_responseEncoding = String();
 944     m_decoder = nullptr;
 945 
 946     m_timeoutTimer.stop();
 947 
 948     if (hadLoader)
 949         unsetPendingActivity(*this);
 950 }
 951 
 952 void XMLHttpRequest::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 953 {
 954     if (!m_upload)
 955         return;
 956 
 957     if (m_uploadListenerFlag)
<span class="line-modified"> 958         m_upload-&gt;dispatchThrottledProgressEvent(true, bytesSent, totalBytesToBeSent);</span>
 959 
 960     if (bytesSent == totalBytesToBeSent &amp;&amp; !m_uploadComplete) {
 961         m_uploadComplete = true;
 962         if (m_uploadListenerFlag) {
<span class="line-modified"> 963             m_upload-&gt;dispatchProgressEvent(eventNames().loadEvent);</span>
<span class="line-modified"> 964             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent);</span>
 965         }
 966     }
 967 }
 968 
 969 void XMLHttpRequest::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
 970 {
 971     m_response = response;
 972 }
 973 
 974 static inline bool shouldDecodeResponse(XMLHttpRequest::ResponseType type)
 975 {
 976     switch (type) {
 977     case XMLHttpRequest::ResponseType::EmptyString:
 978     case XMLHttpRequest::ResponseType::Document:
 979     case XMLHttpRequest::ResponseType::Json:
 980     case XMLHttpRequest::ResponseType::Text:
 981         return true;
 982     case XMLHttpRequest::ResponseType::Arraybuffer:
 983     case XMLHttpRequest::ResponseType::Blob:
 984         return false;
 985     }
 986     ASSERT_NOT_REACHED();
 987     return true;
 988 }
 989 












 990 Ref&lt;TextResourceDecoder&gt; XMLHttpRequest::createDecoder() const
 991 {
<span class="line-modified"> 992     if (!m_responseEncoding.isEmpty())</span>
<span class="line-modified"> 993         return TextResourceDecoder::create(&quot;text/plain&quot;, m_responseEncoding);</span>

 994 
 995     switch (responseType()) {
 996     case ResponseType::EmptyString:
 997         if (responseIsXML()) {
 998             auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
 999             // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1000             decoder-&gt;useLenientXMLDecoding();
1001             return decoder;
1002         }
1003         FALLTHROUGH;
1004     case ResponseType::Text:
1005     case ResponseType::Json:
1006         return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1007     case ResponseType::Document: {
1008         if (equalLettersIgnoringASCIICase(responseMIMEType(), &quot;text/html&quot;))
1009             return TextResourceDecoder::create(&quot;text/html&quot;, &quot;UTF-8&quot;);
1010         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
1011         // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1012         decoder-&gt;useLenientXMLDecoding();
1013         return decoder;
</pre>
<hr />
<pre>
1039         m_decoder = createDecoder();
1040 
1041     if (!len)
1042         return;
1043 
1044     if (len == -1)
1045         len = strlen(data);
1046 
1047     if (useDecoder)
1048         m_responseBuilder.append(m_decoder-&gt;decode(data, len));
1049     else {
1050         // Buffer binary data.
1051         if (!m_binaryResponseBuilder)
1052             m_binaryResponseBuilder = SharedBuffer::create();
1053         m_binaryResponseBuilder-&gt;append(data, len);
1054     }
1055 
1056     if (!m_error) {
1057         m_receivedLength += len;
1058 







1059         if (m_async) {
1060             long long expectedLength = m_response.expectedContentLength();
1061             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1062             unsigned long long total = lengthComputable ? expectedLength : 0;
1063             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1064         }


1065 
<span class="line-modified">1066         if (readyState() != LOADING)</span>
<span class="line-modified">1067             changeState(LOADING);</span>
<span class="line-modified">1068         else</span>
<span class="line-modified">1069             // Firefox calls readyStateChanged every time it receives data, 4449442</span>
<span class="line-modified">1070             callReadyStateChangeListener();</span>



1071     }



1072 }
1073 
<span class="line-modified">1074 void XMLHttpRequest::dispatchErrorEvents(const AtomicString&amp; type)</span>
1075 {
1076     if (!m_uploadComplete) {
1077         m_uploadComplete = true;
1078         if (m_upload &amp;&amp; m_uploadListenerFlag) {
<span class="line-modified">1079             m_upload-&gt;dispatchProgressEvent(type);</span>
<span class="line-modified">1080             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent);</span>
1081         }
1082     }
1083     m_progressEventThrottle.dispatchProgressEvent(type);
1084     m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
1085 }
1086 
1087 void XMLHttpRequest::didReachTimeout()
1088 {
1089     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
1090     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
1091     if (!internalAbort())
1092         return;
1093 
1094     clearResponse();
1095     clearRequest();
1096 
1097     m_sendFlag = false;
1098     m_error = true;
1099     m_exceptionCode = TimeoutError;
1100 
</pre>
<hr />
<pre>
1153 }
1154 
1155 void XMLHttpRequest::resumeTimerFired()
1156 {
1157     ASSERT(m_dispatchErrorOnResuming);
1158     m_dispatchErrorOnResuming = false;
1159     dispatchErrorEvents(eventNames().errorEvent);
1160 }
1161 
1162 void XMLHttpRequest::stop()
1163 {
1164     internalAbort();
1165 }
1166 
1167 void XMLHttpRequest::contextDestroyed()
1168 {
1169     ASSERT(!m_loader);
1170     ActiveDOMObject::contextDestroyed();
1171 }
1172 





1173 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;MIMETypeRegistry.h&quot;
  43 #include &quot;MemoryCache.h&quot;
  44 #include &quot;ParsedContentType.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceRequest.h&quot;
  47 #include &quot;RuntimeApplicationChecks.h&quot;
  48 #include &quot;SecurityOriginPolicy.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StringAdaptors.h&quot;
  52 #include &quot;TextResourceDecoder.h&quot;
  53 #include &quot;ThreadableLoader.h&quot;
  54 #include &quot;XMLDocument.h&quot;
  55 #include &quot;XMLHttpRequestProgressEvent.h&quot;
  56 #include &quot;XMLHttpRequestUpload.h&quot;
  57 #include &quot;markup.h&quot;
  58 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  59 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
  60 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  61 #include &lt;JavaScriptCore/JSLock.h&gt;
<span class="line-added">  62 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  63 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  64 #include &lt;wtf/StdLibExtras.h&gt;
  65 #include &lt;wtf/text/CString.h&gt;
  66 
  67 namespace WebCore {
  68 
<span class="line-added">  69 static const Seconds maximumIntervalForUserGestureForwarding { 10_s };</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 WTF_MAKE_ISO_ALLOCATED_IMPL(XMLHttpRequest);</span>
<span class="line-added">  72 </span>
  73 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, xmlHttpRequestCounter, (&quot;XMLHttpRequest&quot;));
  74 
  75 // Histogram enum to see when we can deprecate xhr.send(ArrayBuffer).
  76 enum XMLHttpRequestSendArrayBufferOrView {
  77     XMLHttpRequestSendArrayBuffer,
  78     XMLHttpRequestSendArrayBufferView,
  79     XMLHttpRequestSendArrayBufferOrViewMax,
  80 };
  81 
<span class="line-modified">  82 static void replaceCharsetInMediaTypeIfNeeded(String&amp; mediaType)</span>
  83 {
<span class="line-modified">  84     auto parsedContentType = ParsedContentType::create(mediaType);</span>
<span class="line-modified">  85     if (!parsedContentType || parsedContentType-&gt;charset().isEmpty() || equalIgnoringASCIICase(parsedContentType-&gt;charset(), &quot;UTF-8&quot;))</span>




  86         return;

  87 
<span class="line-modified">  88     parsedContentType-&gt;setCharset(&quot;UTF-8&quot;);</span>
<span class="line-modified">  89     mediaType = parsedContentType-&gt;serialize();</span>




  90 }
  91 
  92 static void logConsoleError(ScriptExecutionContext* context, const String&amp; message)
  93 {
  94     if (!context)
  95         return;
  96     // FIXME: It&#39;s not good to report the bad usage without indicating what source line it came from.
  97     // We should pass additional parameters so we can tell the console where the mistake occurred.
  98     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);
  99 }
 100 
 101 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 102 {
 103     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 104     xmlHttpRequest-&gt;suspendIfNeeded();
 105     return xmlHttpRequest;
 106 }
 107 
 108 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 109     : ActiveDOMObject(&amp;context)
 110     , m_async(true)
 111     , m_includeCredentials(false)
 112     , m_sendFlag(false)
 113     , m_createdDocument(false)
 114     , m_error(false)
 115     , m_uploadListenerFlag(false)
 116     , m_uploadComplete(false)
 117     , m_wasAbortedByClient(false)
 118     , m_responseCacheIsValid(false)
 119     , m_dispatchErrorOnResuming(false)
 120     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 121     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
 122     , m_progressEventThrottle(this)
 123     , m_resumeTimer(*this, &amp;XMLHttpRequest::resumeTimerFired)
 124     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 125     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
<span class="line-added"> 126     , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)</span>
 127 {
 128 #ifndef NDEBUG
 129     xmlHttpRequestCounter.increment();
 130 #endif
 131 }
 132 
 133 XMLHttpRequest::~XMLHttpRequest()
 134 {
 135 #ifndef NDEBUG
 136     xmlHttpRequestCounter.decrement();
 137 #endif
 138 }
 139 
 140 Document* XMLHttpRequest::document() const
 141 {
 142     ASSERT(scriptExecutionContext());
 143     return downcast&lt;Document&gt;(scriptExecutionContext());
 144 }
 145 
 146 SecurityOrigin* XMLHttpRequest::securityOrigin() const
 147 {
 148     return scriptExecutionContext()-&gt;securityOrigin();
 149 }
 150 











 151 ExceptionOr&lt;OwnedString&gt; XMLHttpRequest::responseText()
 152 {
 153     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Text)
 154         return Exception { InvalidStateError };
 155     return OwnedString { responseTextIgnoringResponseType() };
 156 }
 157 
 158 void XMLHttpRequest::didCacheResponse()
 159 {
 160     ASSERT(doneWithoutErrors());
 161     m_responseCacheIsValid = true;
 162     m_responseBuilder.clear();
 163 }
 164 
 165 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 166 {
 167     ASSERT(scriptExecutionContext()-&gt;isDocument());
 168 
 169     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 170         return Exception { InvalidStateError };
 171 
 172     if (!doneWithoutErrors())
 173         return nullptr;
 174 
 175     if (!m_createdDocument) {
<span class="line-added"> 176         auto&amp; context = *scriptExecutionContext();</span>
<span class="line-added"> 177 </span>
 178         String mimeType = responseMIMEType();
 179         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 180 
 181         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 182         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 183         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 184             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 185             m_responseDocument = nullptr;
 186         } else {
 187             if (isHTML)
<span class="line-modified"> 188                 m_responseDocument = HTMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 189             else
<span class="line-modified"> 190                 m_responseDocument = XMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 191             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 192             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<span class="line-modified"> 193             m_responseDocument-&gt;setContextDocument(downcast&lt;Document&gt;(context));</span>
<span class="line-modified"> 194             m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());</span>
 195             m_responseDocument-&gt;overrideMIMEType(mimeType);
 196 
 197             if (!m_responseDocument-&gt;wellFormed())
 198                 m_responseDocument = nullptr;
 199         }
 200         m_createdDocument = true;
 201     }
 202 
 203     return m_responseDocument.get();
 204 }
 205 
 206 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 207 {
 208     ASSERT(responseType() == ResponseType::Blob);
 209     ASSERT(doneWithoutErrors());
 210 
 211     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 212     Vector&lt;uint8_t&gt; data;
 213     if (m_binaryResponseBuilder)
 214         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 215     m_binaryResponseBuilder = nullptr;
 216     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<span class="line-modified"> 217     return Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(data), normalizedContentType);</span>
 218 }
 219 
 220 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 221 {
 222     ASSERT(responseType() == ResponseType::Arraybuffer);
 223     ASSERT(doneWithoutErrors());
 224 
 225     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 226     m_binaryResponseBuilder = nullptr;
 227     return result;
 228 }
 229 
 230 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 231 {
 232     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 233         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 234         return Exception { InvalidAccessError };
 235     }
 236     m_timeoutMilliseconds = timeout;
 237     if (!m_timeoutTimer.isActive())
</pre>
<hr />
<pre>
 258     if (!m_async &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; m_url.protocolIsInHTTPFamily()) {
 259         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.responseType cannot be changed for synchronous HTTP(S) requests made from the window context.&quot;);
 260         return Exception { InvalidAccessError };
 261     }
 262 
 263     m_responseType = static_cast&lt;unsigned&gt;(type);
 264     return { };
 265 }
 266 
 267 String XMLHttpRequest::responseURL() const
 268 {
 269     URL responseURL(m_response.url());
 270     responseURL.removeFragmentIdentifier();
 271 
 272     return responseURL.string();
 273 }
 274 
 275 XMLHttpRequestUpload&amp; XMLHttpRequest::upload()
 276 {
 277     if (!m_upload)
<span class="line-modified"> 278         m_upload = makeUnique&lt;XMLHttpRequestUpload&gt;(*this);</span>
 279     return *m_upload;
 280 }
 281 
 282 void XMLHttpRequest::changeState(State newState)
 283 {
 284     if (readyState() != newState) {
 285         m_readyState = static_cast&lt;State&gt;(newState);
 286         if (readyState() == DONE) {
 287             // The XHR object itself holds on to the responseText, and
 288             // thus has extra cost even independent of any
 289             // responseText or responseXML objects it has handed
 290             // out. But it is protected from GC while loading, so this
 291             // can&#39;t be recouped until the load is done, so only
 292             // report the extra cost at that point.
 293             if (auto* context = scriptExecutionContext()) {
 294                 JSC::VM&amp; vm = context-&gt;vm();
 295                 JSC::JSLockHolder lock(vm);
 296                 vm.heap.reportExtraMemoryAllocated(memoryCost());
 297             }
 298         }
</pre>
<hr />
<pre>
 413         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 414     ASSERT(!m_loader);
 415 
 416     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 417     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 418         if (!m_async)
 419             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 420         setPendingActivity(*this);
 421         m_timeoutTimer.stop();
 422         m_networkErrorTimer.startOneShot(0_s);
 423         return ExceptionOr&lt;void&gt; { };
 424     }
 425 
 426     m_error = false;
 427     return WTF::nullopt;
 428 }
 429 
 430 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 431 {
 432     InspectorInstrumentation::willSendXMLHttpRequest(scriptExecutionContext(), url());
<span class="line-added"> 433     m_userGestureToken = UserGestureIndicator::currentUserGesture();</span>
 434 
 435     ExceptionOr&lt;void&gt; result;
 436     if (!sendType)
 437         result = send();
 438     else {
 439         result = WTF::switchOn(sendType.value(),
 440             [this] (const RefPtr&lt;Document&gt;&amp; document) -&gt; ExceptionOr&lt;void&gt; { return send(*document); },
 441             [this] (const RefPtr&lt;Blob&gt;&amp; blob) -&gt; ExceptionOr&lt;void&gt; { return send(*blob); },
 442             [this] (const RefPtr&lt;JSC::ArrayBufferView&gt;&amp; arrayBufferView) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBufferView); },
 443             [this] (const RefPtr&lt;JSC::ArrayBuffer&gt;&amp; arrayBuffer) -&gt; ExceptionOr&lt;void&gt; { return send(*arrayBuffer); },
 444             [this] (const RefPtr&lt;DOMFormData&gt;&amp; formData) -&gt; ExceptionOr&lt;void&gt; { return send(*formData); },
 445             [this] (const String&amp; string) -&gt; ExceptionOr&lt;void&gt; { return send(string); }
 446         );
 447     }
 448 
 449     return result;
 450 }
 451 
 452 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Document&amp; document)
 453 {
 454     if (auto result = prepareToSend())
 455         return WTFMove(result.value());
 456 
<span class="line-modified"> 457     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 458         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
<span class="line-modified"> 459             // FIXME: this should include the charset used for encoding.</span>
<span class="line-modified"> 460             m_requestHeaders.set(HTTPHeaderName::ContentType, document.isHTMLDocument() ? &quot;text/html;charset=UTF-8&quot;_s : &quot;application/xml;charset=UTF-8&quot;_s);</span>





 461         } else {
 462             String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
<span class="line-modified"> 463             replaceCharsetInMediaTypeIfNeeded(contentType);</span>
 464             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 465         }
 466 
 467         // FIXME: According to XMLHttpRequest Level 2, this should use the Document.innerHTML algorithm
 468         // from the HTML5 specification to serialize the document.
 469         m_requestEntityBody = FormData::create(UTF8Encoding().encode(serializeFragment(document, SerializedNodes::SubtreeIncludingNode), UnencodableHandling::Entities));
 470         if (m_upload)
 471             m_requestEntityBody-&gt;setAlwaysStream(true);
 472     }
 473 
 474     return createRequest();
 475 }
 476 
 477 ExceptionOr&lt;void&gt; XMLHttpRequest::send(const String&amp; body)
 478 {
 479     if (auto result = prepareToSend())
 480         return WTFMove(result.value());
 481 
<span class="line-modified"> 482     if (!body.isNull() &amp;&amp; m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 483         String contentType = m_requestHeaders.get(HTTPHeaderName::ContentType);
 484         if (contentType.isNull()) {
<span class="line-modified"> 485             m_requestHeaders.set(HTTPHeaderName::ContentType, HTTPHeaderValues::textPlainContentType());</span>





 486         } else {
<span class="line-modified"> 487             replaceCharsetInMediaTypeIfNeeded(contentType);</span>
 488             m_requestHeaders.set(HTTPHeaderName::ContentType, contentType);
 489         }
 490 
 491         m_requestEntityBody = FormData::create(UTF8Encoding().encode(body, UnencodableHandling::Entities));
 492         if (m_upload)
 493             m_requestEntityBody-&gt;setAlwaysStream(true);
 494     }
 495 
 496     return createRequest();
 497 }
 498 
 499 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Blob&amp; body)
 500 {
 501     if (auto result = prepareToSend())
 502         return WTFMove(result.value());
 503 
<span class="line-modified"> 504     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
<span class="line-added"> 505         if (!m_url.protocolIsInHTTPFamily()) {</span>
<span class="line-added"> 506             // FIXME: We would like to support posting Blobs to non-http URLs (e.g. custom URL schemes)</span>
<span class="line-added"> 507             // but because of the architecture of blob-handling that will require a fair amount of work.</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509             ASCIILiteral consoleMessage { &quot;POST of a Blob to non-HTTP protocols in XMLHttpRequest.send() is currently unsupported.&quot;_s };</span>
<span class="line-added"> 510             scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);</span>
<span class="line-added"> 511 </span>
<span class="line-added"> 512             return createRequest();</span>
<span class="line-added"> 513         }</span>
<span class="line-added"> 514 </span>
 515         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType)) {
 516             const String&amp; blobType = body.type();
 517             if (!blobType.isEmpty() &amp;&amp; isValidContentType(blobType))
 518                 m_requestHeaders.set(HTTPHeaderName::ContentType, blobType);
 519             else {
 520                 // From FileAPI spec, whenever media type cannot be determined, empty string must be returned.
 521                 m_requestHeaders.set(HTTPHeaderName::ContentType, emptyString());
 522             }
 523         }
 524 
 525         m_requestEntityBody = FormData::create();
 526         m_requestEntityBody-&gt;appendBlob(body.url());
 527     }
 528 
 529     return createRequest();
 530 }
 531 
 532 ExceptionOr&lt;void&gt; XMLHttpRequest::send(DOMFormData&amp; body)
 533 {
 534     if (auto result = prepareToSend())
 535         return WTFMove(result.value());
 536 
<span class="line-modified"> 537     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
<span class="line-modified"> 538         m_requestEntityBody = FormData::createMultiPart(body);</span>

 539         if (!m_requestHeaders.contains(HTTPHeaderName::ContentType))
 540             m_requestHeaders.set(HTTPHeaderName::ContentType, makeString(&quot;multipart/form-data; boundary=&quot;, m_requestEntityBody-&gt;boundary().data()));
 541     }
 542 
 543     return createRequest();
 544 }
 545 
 546 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBuffer&amp; body)
 547 {
 548     ASCIILiteral consoleMessage { &quot;ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.&quot;_s };
 549     scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, consoleMessage);
 550     return sendBytesData(body.data(), body.byteLength());
 551 }
 552 
 553 ExceptionOr&lt;void&gt; XMLHttpRequest::send(ArrayBufferView&amp; body)
 554 {
 555     return sendBytesData(body.baseAddress(), body.byteLength());
 556 }
 557 
 558 ExceptionOr&lt;void&gt; XMLHttpRequest::sendBytesData(const void* data, size_t length)
 559 {
 560     if (auto result = prepareToSend())
 561         return WTFMove(result.value());
 562 
<span class="line-modified"> 563     if (m_method != &quot;GET&quot; &amp;&amp; m_method != &quot;HEAD&quot;) {</span>
 564         m_requestEntityBody = FormData::create(data, length);
 565         if (m_upload)
 566             m_requestEntityBody-&gt;setAlwaysStream(true);
 567     }
 568 
 569     return createRequest();
 570 }
 571 
 572 ExceptionOr&lt;void&gt; XMLHttpRequest::createRequest()
 573 {
 574     // Only GET request is supported for blob URL.
 575     if (!m_async &amp;&amp; m_url.protocolIsBlob() &amp;&amp; m_method != &quot;GET&quot;)
 576         return Exception { NetworkError };
 577 
 578     if (m_async &amp;&amp; m_upload &amp;&amp; m_upload-&gt;hasEventListeners())
 579         m_uploadListenerFlag = true;
 580 
 581     ResourceRequest request(m_url);
 582     request.setRequester(ResourceRequest::Requester::XHR);
 583     request.setInitiatorIdentifier(scriptExecutionContext()-&gt;resourceRequestIdentifier());
</pre>
<hr />
<pre>
 606     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 607 
 608     if (m_timeoutMilliseconds) {
 609         if (!m_async)
 610             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 611         else {
 612             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 613             m_sendingTime = MonotonicTime::now();
 614             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 615         }
 616     }
 617 
 618     m_exceptionCode = WTF::nullopt;
 619     m_error = false;
 620     m_uploadComplete = !request.httpBody();
 621     m_sendFlag = true;
 622 
 623     if (m_async) {
 624         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 625         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<span class="line-modified"> 626             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes(scriptExecutionContext()-&gt;sessionID()));</span>
 627 
 628         if (readyState() != OPENED || !m_sendFlag || m_loader)
 629             return { };
 630 
 631         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 632         // This is true while running onunload handlers.
 633         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 634         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 635 
 636         // Either loader is null or some error was synchronously sent to us.
 637         ASSERT(m_loader || !m_sendFlag);
 638 
 639         // Neither this object nor the JavaScript wrapper should be deleted while
 640         // a request is in progress because we need to keep the listeners alive,
 641         // and they are referenced by the JavaScript wrapper.
 642         if (m_loader)
 643             setPendingActivity(*this);
 644     } else {
 645         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 646         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
</pre>
<hr />
<pre>
 764 {
 765     if (readyState() == DONE)
 766         return m_responseBuilder.length() * 2;
 767     return 0;
 768 }
 769 
 770 ExceptionOr&lt;void&gt; XMLHttpRequest::overrideMimeType(const String&amp; mimeType)
 771 {
 772     if (readyState() == LOADING || readyState() == DONE)
 773         return Exception { InvalidStateError };
 774 
 775     m_mimeTypeOverride = &quot;application/octet-stream&quot;_s;
 776     if (isValidContentType(mimeType))
 777         m_mimeTypeOverride = mimeType;
 778 
 779     return { };
 780 }
 781 
 782 ExceptionOr&lt;void&gt; XMLHttpRequest::setRequestHeader(const String&amp; name, const String&amp; value)
 783 {
<span class="line-modified"> 784     if (readyState() != OPENED || m_sendFlag)</span>




 785         return Exception { InvalidStateError };

 786 
 787     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 788     if (!isValidHTTPToken(name) || !isValidHTTPHeaderValue(normalizedValue))
 789         return Exception { SyntaxError };
 790 
 791     bool allowUnsafeHeaderField = false;
<span class="line-modified"> 792     // FIXME: The allowSettingAnyXHRHeaderFromFileURLs setting currently only applies to Documents, not workers.</span>
<span class="line-modified"> 793     if (securityOrigin()-&gt;canLoadLocalResources() &amp;&amp; scriptExecutionContext()-&gt;isDocument() &amp;&amp; document()-&gt;settings().allowSettingAnyXHRHeaderFromFileURLs())</span>


 794         allowUnsafeHeaderField = true;
 795     if (!allowUnsafeHeaderField &amp;&amp; isForbiddenHeaderName(name)) {
 796         logConsoleError(scriptExecutionContext(), &quot;Refused to set unsafe header \&quot;&quot; + name + &quot;\&quot;&quot;);
 797         return { };
 798     }
 799 
 800     m_requestHeaders.add(name, normalizedValue);
 801     return { };
 802 }
 803 
 804 String XMLHttpRequest::getAllResponseHeaders() const
 805 {
 806     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 807         return emptyString();
 808 
 809     if (!m_allResponseHeaders) {
 810         Vector&lt;String&gt; headers;
 811         headers.reserveInitialCapacity(m_response.httpHeaderFields().size());
 812 
 813         for (auto&amp; header : m_response.httpHeaderFields()) {
</pre>
<hr />
<pre>
 824         for (auto&amp; header : headers)
 825             stringBuilder.append(header);
 826         m_allResponseHeaders = stringBuilder.toString();
 827     }
 828 
 829     return m_allResponseHeaders;
 830 }
 831 
 832 String XMLHttpRequest::getResponseHeader(const String&amp; name) const
 833 {
 834     if (readyState() &lt; HEADERS_RECEIVED || m_error)
 835         return String();
 836 
 837     return m_response.httpHeaderField(name);
 838 }
 839 
 840 String XMLHttpRequest::responseMIMEType() const
 841 {
 842     String mimeType = extractMIMETypeFromMediaType(m_mimeTypeOverride);
 843     if (mimeType.isEmpty()) {
<span class="line-added"> 844         String contentType;</span>
 845         if (m_response.isHTTP())
<span class="line-modified"> 846             contentType = m_response.httpHeaderField(HTTPHeaderName::ContentType);</span>
 847         else
<span class="line-modified"> 848             contentType = m_response.mimeType();</span>
<span class="line-modified"> 849         if (auto parsedContentType = ParsedContentType::create(contentType))</span>
<span class="line-modified"> 850             return parsedContentType-&gt;mimeType();</span>
<span class="line-added"> 851         return &quot;text/xml&quot;_s;</span>
 852     }
 853     return mimeType;
 854 }
 855 
 856 bool XMLHttpRequest::responseIsXML() const
 857 {
 858     return MIMETypeRegistry::isXMLMIMEType(responseMIMEType());
 859 }
 860 
 861 int XMLHttpRequest::status() const
 862 {
 863     if (readyState() == UNSENT || readyState() == OPENED || m_error)
 864         return 0;
 865 
 866     return m_response.httpStatusCode();
 867 }
 868 
 869 String XMLHttpRequest::statusText() const
 870 {
 871     if (readyState() == UNSENT || readyState() == OPENED || m_error)
</pre>
<hr />
<pre>
 921     bool hadLoader = m_loader;
 922     m_loader = nullptr;
 923 
 924     m_sendFlag = false;
 925     changeState(DONE);
 926     m_responseEncoding = String();
 927     m_decoder = nullptr;
 928 
 929     m_timeoutTimer.stop();
 930 
 931     if (hadLoader)
 932         unsetPendingActivity(*this);
 933 }
 934 
 935 void XMLHttpRequest::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 936 {
 937     if (!m_upload)
 938         return;
 939 
 940     if (m_uploadListenerFlag)
<span class="line-modified"> 941         m_upload-&gt;dispatchProgressEvent(eventNames().progressEvent, bytesSent, totalBytesToBeSent);</span>
 942 
 943     if (bytesSent == totalBytesToBeSent &amp;&amp; !m_uploadComplete) {
 944         m_uploadComplete = true;
 945         if (m_uploadListenerFlag) {
<span class="line-modified"> 946             m_upload-&gt;dispatchProgressEvent(eventNames().loadEvent, bytesSent, totalBytesToBeSent);</span>
<span class="line-modified"> 947             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, bytesSent, totalBytesToBeSent);</span>
 948         }
 949     }
 950 }
 951 
 952 void XMLHttpRequest::didReceiveResponse(unsigned long, const ResourceResponse&amp; response)
 953 {
 954     m_response = response;
 955 }
 956 
 957 static inline bool shouldDecodeResponse(XMLHttpRequest::ResponseType type)
 958 {
 959     switch (type) {
 960     case XMLHttpRequest::ResponseType::EmptyString:
 961     case XMLHttpRequest::ResponseType::Document:
 962     case XMLHttpRequest::ResponseType::Json:
 963     case XMLHttpRequest::ResponseType::Text:
 964         return true;
 965     case XMLHttpRequest::ResponseType::Arraybuffer:
 966     case XMLHttpRequest::ResponseType::Blob:
 967         return false;
 968     }
 969     ASSERT_NOT_REACHED();
 970     return true;
 971 }
 972 
<span class="line-added"> 973 // https://xhr.spec.whatwg.org/#final-charset</span>
<span class="line-added"> 974 TextEncoding XMLHttpRequest::finalResponseCharset() const</span>
<span class="line-added"> 975 {</span>
<span class="line-added"> 976     String label = m_responseEncoding;</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978     String overrideResponseCharset = extractCharsetFromMediaType(m_mimeTypeOverride);</span>
<span class="line-added"> 979     if (!overrideResponseCharset.isEmpty())</span>
<span class="line-added"> 980         label = overrideResponseCharset;</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982     return TextEncoding(label);</span>
<span class="line-added"> 983 }</span>
<span class="line-added"> 984 </span>
 985 Ref&lt;TextResourceDecoder&gt; XMLHttpRequest::createDecoder() const
 986 {
<span class="line-modified"> 987     TextEncoding finalResponseCharset = this-&gt;finalResponseCharset();</span>
<span class="line-modified"> 988     if (finalResponseCharset.isValid())</span>
<span class="line-added"> 989         return TextResourceDecoder::create(&quot;text/plain&quot;, finalResponseCharset);</span>
 990 
 991     switch (responseType()) {
 992     case ResponseType::EmptyString:
 993         if (responseIsXML()) {
 994             auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
 995             // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
 996             decoder-&gt;useLenientXMLDecoding();
 997             return decoder;
 998         }
 999         FALLTHROUGH;
1000     case ResponseType::Text:
1001     case ResponseType::Json:
1002         return TextResourceDecoder::create(&quot;text/plain&quot;, &quot;UTF-8&quot;);
1003     case ResponseType::Document: {
1004         if (equalLettersIgnoringASCIICase(responseMIMEType(), &quot;text/html&quot;))
1005             return TextResourceDecoder::create(&quot;text/html&quot;, &quot;UTF-8&quot;);
1006         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;);
1007         // Don&#39;t stop on encoding errors, unlike it is done for other kinds of XML resources. This matches the behavior of previous WebKit versions, Firefox and Opera.
1008         decoder-&gt;useLenientXMLDecoding();
1009         return decoder;
</pre>
<hr />
<pre>
1035         m_decoder = createDecoder();
1036 
1037     if (!len)
1038         return;
1039 
1040     if (len == -1)
1041         len = strlen(data);
1042 
1043     if (useDecoder)
1044         m_responseBuilder.append(m_decoder-&gt;decode(data, len));
1045     else {
1046         // Buffer binary data.
1047         if (!m_binaryResponseBuilder)
1048             m_binaryResponseBuilder = SharedBuffer::create();
1049         m_binaryResponseBuilder-&gt;append(data, len);
1050     }
1051 
1052     if (!m_error) {
1053         m_receivedLength += len;
1054 
<span class="line-added">1055         if (readyState() != LOADING)</span>
<span class="line-added">1056             changeState(LOADING);</span>
<span class="line-added">1057         else {</span>
<span class="line-added">1058             // Firefox calls readyStateChanged every time it receives data, 4449442</span>
<span class="line-added">1059             callReadyStateChangeListener();</span>
<span class="line-added">1060         }</span>
<span class="line-added">1061 </span>
1062         if (m_async) {
1063             long long expectedLength = m_response.expectedContentLength();
1064             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1065             unsigned long long total = lengthComputable ? expectedLength : 0;
1066             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1067         }
<span class="line-added">1068     }</span>
<span class="line-added">1069 }</span>
1070 
<span class="line-modified">1071 void XMLHttpRequest::dispatchEvent(Event&amp; event)</span>
<span class="line-modified">1072 {</span>
<span class="line-modified">1073     if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))</span>
<span class="line-modified">1074         m_userGestureToken = nullptr;</span>
<span class="line-modified">1075 </span>
<span class="line-added">1076     if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {</span>
<span class="line-added">1077         EventTarget::dispatchEvent(event);</span>
<span class="line-added">1078         return;</span>
1079     }
<span class="line-added">1080 </span>
<span class="line-added">1081     UserGestureIndicator gestureIndicator(m_userGestureToken, UserGestureToken::GestureScope::MediaOnly);</span>
<span class="line-added">1082     EventTarget::dispatchEvent(event);</span>
1083 }
1084 
<span class="line-modified">1085 void XMLHttpRequest::dispatchErrorEvents(const AtomString&amp; type)</span>
1086 {
1087     if (!m_uploadComplete) {
1088         m_uploadComplete = true;
1089         if (m_upload &amp;&amp; m_uploadListenerFlag) {
<span class="line-modified">1090             m_upload-&gt;dispatchProgressEvent(type, 0, 0);</span>
<span class="line-modified">1091             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, 0, 0);</span>
1092         }
1093     }
1094     m_progressEventThrottle.dispatchProgressEvent(type);
1095     m_progressEventThrottle.dispatchProgressEvent(eventNames().loadendEvent);
1096 }
1097 
1098 void XMLHttpRequest::didReachTimeout()
1099 {
1100     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
1101     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
1102     if (!internalAbort())
1103         return;
1104 
1105     clearResponse();
1106     clearRequest();
1107 
1108     m_sendFlag = false;
1109     m_error = true;
1110     m_exceptionCode = TimeoutError;
1111 
</pre>
<hr />
<pre>
1164 }
1165 
1166 void XMLHttpRequest::resumeTimerFired()
1167 {
1168     ASSERT(m_dispatchErrorOnResuming);
1169     m_dispatchErrorOnResuming = false;
1170     dispatchErrorEvents(eventNames().errorEvent);
1171 }
1172 
1173 void XMLHttpRequest::stop()
1174 {
1175     internalAbort();
1176 }
1177 
1178 void XMLHttpRequest::contextDestroyed()
1179 {
1180     ASSERT(!m_loader);
1181     ActiveDOMObject::contextDestroyed();
1182 }
1183 
<span class="line-added">1184 void XMLHttpRequest::setMaximumIntervalForUserGestureForwarding(double interval)</span>
<span class="line-added">1185 {</span>
<span class="line-added">1186     m_maximumIntervalForUserGestureForwarding = Seconds(interval);</span>
<span class="line-added">1187 }</span>
<span class="line-added">1188 </span>
1189 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="XMLErrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>