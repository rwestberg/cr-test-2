<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutTextFragmentIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutTextFragmentIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextAutoSizing.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutTextFragmentIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 94         bool m_isCollapsed { false };
 95         bool m_isCollapsible { false };
 96         bool m_hasHyphen { false };
 97     };
 98     TextFragment nextTextFragment(float xPosition = 0);
 99     void revertToEndOfFragment(const TextFragment&amp;);
100 
101     // FIXME: These functions below should be decoupled from the text iterator.
102     float textWidth(unsigned startPosition, unsigned endPosition, float xPosition) const;
103     Optional&lt;unsigned&gt; lastHyphenPosition(const TextFragmentIterator::TextFragment&amp; run, unsigned beforeIndex) const;
104 
105     struct Style {
106         explicit Style(const RenderStyle&amp;);
107 
108         const FontCascade&amp; font;
109         TextAlignMode textAlign;
110         bool hasKerningOrLigatures;
111         bool collapseWhitespace;
112         bool preserveNewline;
113         bool wrapLines;

114         bool breakAnyWordOnOverflow;

115         bool breakFirstWordOnOverflow;
116         bool breakNBSP;
117         bool keepAllWordsForCJK;
118         float wordSpacing;
<span class="line-modified">119         unsigned tabWidth;</span>
120         bool shouldHyphenate;
121         float hyphenStringWidth;
122         unsigned hyphenLimitBefore;
123         unsigned hyphenLimitAfter;
<span class="line-modified">124         AtomicString locale;</span>
125         Optional&lt;unsigned&gt; hyphenLimitLines;
126     };
127     const Style&amp; style() const { return m_style; }
128 
129 private:
130     TextFragment findNextTextFragment(float xPosition);
131     enum PositionType { Breakable, NonWhitespace };
132     unsigned skipToNextPosition(PositionType, unsigned startPosition, float&amp; width, float xPosition, bool&amp; overlappingFragment);
133     bool isSoftLineBreak(unsigned position) const;
134     bool isHardLineBreak(const FlowContents::Iterator&amp; segment) const;
135     unsigned nextBreakablePosition(const FlowContents::Segment&amp;, unsigned startPosition);
136     unsigned nextNonWhitespacePosition(const FlowContents::Segment&amp;, unsigned startPosition);
137 
138     FlowContents m_flowContents;
139     FlowContents::Iterator m_currentSegment;
140     LazyLineBreakIterator m_lineBreakIterator;
141     const Style m_style;
142     unsigned m_position { 0 };
143     bool m_atEndOfSegment { false };
144 };
</pre>
</td>
<td>
<hr />
<pre>
 94         bool m_isCollapsed { false };
 95         bool m_isCollapsible { false };
 96         bool m_hasHyphen { false };
 97     };
 98     TextFragment nextTextFragment(float xPosition = 0);
 99     void revertToEndOfFragment(const TextFragment&amp;);
100 
101     // FIXME: These functions below should be decoupled from the text iterator.
102     float textWidth(unsigned startPosition, unsigned endPosition, float xPosition) const;
103     Optional&lt;unsigned&gt; lastHyphenPosition(const TextFragmentIterator::TextFragment&amp; run, unsigned beforeIndex) const;
104 
105     struct Style {
106         explicit Style(const RenderStyle&amp;);
107 
108         const FontCascade&amp; font;
109         TextAlignMode textAlign;
110         bool hasKerningOrLigatures;
111         bool collapseWhitespace;
112         bool preserveNewline;
113         bool wrapLines;
<span class="line-added">114         bool breakSpaces;</span>
115         bool breakAnyWordOnOverflow;
<span class="line-added">116         bool breakWordOnOverflow;</span>
117         bool breakFirstWordOnOverflow;
118         bool breakNBSP;
119         bool keepAllWordsForCJK;
120         float wordSpacing;
<span class="line-modified">121         TabSize tabWidth;</span>
122         bool shouldHyphenate;
123         float hyphenStringWidth;
124         unsigned hyphenLimitBefore;
125         unsigned hyphenLimitAfter;
<span class="line-modified">126         AtomString locale;</span>
127         Optional&lt;unsigned&gt; hyphenLimitLines;
128     };
129     const Style&amp; style() const { return m_style; }
130 
131 private:
132     TextFragment findNextTextFragment(float xPosition);
133     enum PositionType { Breakable, NonWhitespace };
134     unsigned skipToNextPosition(PositionType, unsigned startPosition, float&amp; width, float xPosition, bool&amp; overlappingFragment);
135     bool isSoftLineBreak(unsigned position) const;
136     bool isHardLineBreak(const FlowContents::Iterator&amp; segment) const;
137     unsigned nextBreakablePosition(const FlowContents::Segment&amp;, unsigned startPosition);
138     unsigned nextNonWhitespacePosition(const FlowContents::Segment&amp;, unsigned startPosition);
139 
140     FlowContents m_flowContents;
141     FlowContents::Iterator m_currentSegment;
142     LazyLineBreakIterator m_lineBreakIterator;
143     const Style m_style;
144     unsigned m_position { 0 };
145     bool m_atEndOfSegment { false };
146 };
</pre>
</td>
</tr>
</table>
<center><a href="SimpleLineLayoutTextFragmentIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextAutoSizing.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>