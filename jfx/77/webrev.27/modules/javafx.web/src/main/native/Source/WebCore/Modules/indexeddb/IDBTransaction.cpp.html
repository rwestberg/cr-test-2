<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;IDBTransaction.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;DOMException.h&quot;
  32 #include &quot;DOMStringList.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;Event.h&quot;
  35 #include &quot;EventDispatcher.h&quot;
  36 #include &quot;EventNames.h&quot;
  37 #include &quot;EventQueue.h&quot;
  38 #include &quot;IDBCursorWithValue.h&quot;
  39 #include &quot;IDBDatabase.h&quot;
  40 #include &quot;IDBError.h&quot;
  41 #include &quot;IDBGetRecordData.h&quot;
  42 #include &quot;IDBIndex.h&quot;
  43 #include &quot;IDBIterateCursorData.h&quot;
  44 #include &quot;IDBKeyData.h&quot;
  45 #include &quot;IDBKeyRangeData.h&quot;
  46 #include &quot;IDBObjectStore.h&quot;
  47 #include &quot;IDBOpenDBRequest.h&quot;
  48 #include &quot;IDBRequest.h&quot;
  49 #include &quot;IDBResultData.h&quot;
  50 #include &quot;IDBValue.h&quot;
  51 #include &quot;JSDOMWindowBase.h&quot;
  52 #include &quot;Logging.h&quot;
  53 #include &quot;ScriptExecutionContext.h&quot;
  54 #include &quot;ScriptState.h&quot;
  55 #include &quot;SerializedScriptValue.h&quot;
  56 #include &quot;TransactionOperation.h&quot;
  57 #include &lt;wtf/CompletionHandler.h&gt;
  58 #include &lt;wtf/IsoMallocInlines.h&gt;
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);
  64 
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)
  81     , m_pendingOperationTimer(*this, &amp;IDBTransaction::pendingOperationTimerFired)
  82     , m_completedOperationTimer(*this, &amp;IDBTransaction::completedOperationTimerFired)
  83     , m_openDBRequest(request)
  84     , m_currentlyCompletingRequest(request)
  85 
  86 {
  87     LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
  88     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
  89 
  90     ++numberOfIDBTransactions;
  91 
  92     if (m_info.mode() == IDBTransactionMode::Versionchange) {
  93         ASSERT(m_openDBRequest);
  94         m_openDBRequest-&gt;setVersionChangeTransaction(*this);
  95         m_startedOnServer = true;
  96     } else {
  97         activate();
  98 
  99         auto* context = scriptExecutionContext();
 100         ASSERT(context);
 101 
 102         JSC::VM&amp; vm = context-&gt;vm();
 103         vm.whenIdle([protectedThis = makeRef(*this)]() {
 104             protectedThis-&gt;deactivate();
 105         });
 106 
 107         establishOnServer();
 108     }
 109 
 110     suspendIfNeeded();
 111 }
 112 
 113 IDBTransaction::~IDBTransaction()
 114 {
 115     --numberOfIDBTransactions;
 116     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 117 }
 118 
 119 IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
 120 {
 121     return m_database-&gt;connectionProxy();
 122 }
 123 
 124 Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
 125 {
 126     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 127 
 128     const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
 129 
 130     Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
 131     for (auto&amp; name : names)
 132         objectStoreNames-&gt;append(name);
 133 
 134     objectStoreNames-&gt;sort();
 135     return objectStoreNames;
 136 }
 137 
 138 IDBDatabase* IDBTransaction::db()
 139 {
 140     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 141     return m_database.ptr();
 142 }
 143 
 144 DOMException* IDBTransaction::error() const
 145 {
 146     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 147     return m_domError.get();
 148 }
 149 
 150 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
 151 {
 152     LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
 153     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 154 
 155     if (!scriptExecutionContext())
 156         return Exception { InvalidStateError };
 157 
 158     if (isFinishedOrFinishing())
 159         return Exception { InvalidStateError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The transaction finished.&quot;_s };
 160 
 161     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 162 
 163     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 164         return makeRef(*store);
 165 
 166     bool found = false;
 167     for (auto&amp; objectStore : m_info.objectStores()) {
 168         if (objectStore == objectStoreName) {
 169             found = true;
 170             break;
 171         }
 172     }
 173 
 174     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 175     if (!info)
 176         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 177 
 178     // Version change transactions are scoped to every object store in the database.
 179     if (!info || (!found &amp;&amp; !isVersionChange()))
 180         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 181 
 182     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);
 183     auto* rawObjectStore = objectStore.get();
 184     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 185 
 186     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 187 }
 188 
 189 
 190 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 191 {
 192     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
 193     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 194 
 195     if (isFinishedOrFinishing())
 196         return;
 197 
 198     m_domError = &amp;error;
 199     internalAbort();
 200 }
 201 
 202 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 203 {
 204     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 205 
 206     ASSERT(!isFinishedOrFinishing());
 207     m_state = state;
 208     ASSERT(isFinishedOrFinishing());
 209 }
 210 
 211 ExceptionOr&lt;void&gt; IDBTransaction::abort()
 212 {
 213     LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
 214     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 215 
 216     if (isFinishedOrFinishing())
 217         return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
 218 
 219     internalAbort();
 220 
 221     return { };
 222 }
 223 
 224 void IDBTransaction::internalAbort()
 225 {
 226     LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
 227     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 228     ASSERT(!isFinishedOrFinishing());
 229 
 230     m_database-&gt;willAbortTransaction(*this);
 231 
 232     if (isVersionChange()) {
 233         Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 234 
 235         auto&amp; info = m_database-&gt;info();
 236         Vector&lt;uint64_t&gt; identifiersToRemove;
 237         for (auto&amp; iterator : m_deletedObjectStores) {
 238             if (info.infoForExistingObjectStore(iterator.key)) {
 239                 auto name = iterator.value-&gt;info().name();
 240                 m_referencedObjectStores.set(name, WTFMove(iterator.value));
 241                 identifiersToRemove.append(iterator.key);
 242             }
 243         }
 244 
 245         for (auto identifier : identifiersToRemove)
 246             m_deletedObjectStores.remove(identifier);
 247 
 248         for (auto&amp; objectStore : m_referencedObjectStores.values())
 249             objectStore-&gt;rollbackForVersionChangeAbort();
 250     }
 251 
 252     transitionedToFinishing(IndexedDB::TransactionState::Aborting);
 253 
 254     m_abortQueue.swap(m_pendingTransactionOperationQueue);
 255 
 256     LOG(IndexedDBOperations, &quot;IDB abort-on-server operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 257     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 258         protectedThis-&gt;abortOnServerAndCancelRequests(operation);
 259     }));
 260 }
 261 
 262 void IDBTransaction::abortInProgressOperations(const IDBError&amp; error)
 263 {
 264     LOG(IndexedDB, &quot;IDBTransaction::abortInProgressOperations&quot;);
 265 
 266     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; inProgressAbortVector;
 267     inProgressAbortVector.reserveInitialCapacity(m_transactionOperationsInProgressQueue.size());
 268     while (!m_transactionOperationsInProgressQueue.isEmpty())
 269         inProgressAbortVector.uncheckedAppend(m_transactionOperationsInProgressQueue.takeFirst());
 270 
 271     for (auto&amp; operation : inProgressAbortVector) {
 272         m_transactionOperationsInProgressQueue.append(operation.get());
 273         m_currentlyCompletingRequest = nullptr;
 274         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 275     }
 276 
 277     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; completedOnServerAbortVector;
 278     completedOnServerAbortVector.reserveInitialCapacity(m_completedOnServerQueue.size());
 279     while (!m_completedOnServerQueue.isEmpty())
 280         completedOnServerAbortVector.uncheckedAppend(m_completedOnServerQueue.takeFirst().first);
 281 
 282     for (auto&amp; operation : completedOnServerAbortVector) {
 283         m_currentlyCompletingRequest = nullptr;
 284         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 285     }
 286 
 287     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 288 }
 289 
 290 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
 291 {
 292     LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
 293     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 294     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 295 
 296     m_database-&gt;connectionProxy().abortTransaction(*this);
 297 
 298     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 299     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 300     m_transactionOperationMap.remove(operation.identifier());
 301     m_transactionOperationsInProgressQueue.removeLast();
 302 
 303     m_currentlyCompletingRequest = nullptr;
 304 
 305     IDBError error(AbortError);
 306 
 307     abortInProgressOperations(error);
 308 
 309     for (auto&amp; operation : m_abortQueue) {
 310         m_transactionOperationsInProgressQueue.append(operation.get());
 311         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 312         m_currentlyCompletingRequest = nullptr;
 313     }
 314 
 315     m_abortQueue.clear();
 316     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 317     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 318 }
 319 
 320 const char* IDBTransaction::activeDOMObjectName() const
 321 {
 322     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 323     return &quot;IDBTransaction&quot;;
 324 }
 325 
 326 bool IDBTransaction::canSuspendForDocumentSuspension() const
 327 {
 328     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 329     return false;
 330 }
 331 
 332 bool IDBTransaction::hasPendingActivity() const
 333 {
 334     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());
 335     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 336 }
 337 
 338 void IDBTransaction::stop()
 339 {
 340     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
 341     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 342 
 343     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 344     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 345     if (m_contextStopped)
 346         return;
 347 
 348     removeAllEventListeners();
 349 
 350     m_contextStopped = true;
 351 
 352     if (isVersionChange())
 353         m_openDBRequest = nullptr;
 354 
 355     if (isFinishedOrFinishing())
 356         return;
 357 
 358     internalAbort();
 359 }
 360 
 361 bool IDBTransaction::isActive() const
 362 {
 363     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 364     return m_state == IndexedDB::TransactionState::Active;
 365 }
 366 
 367 bool IDBTransaction::isFinishedOrFinishing() const
 368 {
 369     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 370 
 371     return m_state == IndexedDB::TransactionState::Committing
 372         || m_state == IndexedDB::TransactionState::Aborting
 373         || m_state == IndexedDB::TransactionState::Finished;
 374 }
 375 
 376 void IDBTransaction::addRequest(IDBRequest&amp; request)
 377 {
 378     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 379     m_openRequests.add(&amp;request);
 380 }
 381 
 382 void IDBTransaction::removeRequest(IDBRequest&amp; request)
 383 {
 384     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 385     m_openRequests.remove(&amp;request);
 386 }
 387 
 388 void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation)
 389 {
 390     ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
 391     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 392 
 393     auto identifier = operation-&gt;identifier();
 394     m_pendingTransactionOperationQueue.append(operation.copyRef());
 395     m_transactionOperationMap.set(identifier, WTFMove(operation));
 396 
 397     schedulePendingOperationTimer();
 398 }
 399 
 400 void IDBTransaction::schedulePendingOperationTimer()
 401 {
 402     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 403 
 404     if (!m_pendingOperationTimer.isActive())
 405         m_pendingOperationTimer.startOneShot(0_s);
 406 }
 407 
 408 void IDBTransaction::pendingOperationTimerFired()
 409 {
 410     LOG(IndexedDB, &quot;IDBTransaction::pendingOperationTimerFired (%p)&quot;, this);
 411     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 412 
 413     if (!m_startedOnServer)
 414         return;
 415 
 416     // If the last in-progress operation we&#39;ve sent to the server is not an IDBRequest operation,
 417     // then we have to wait until it completes before sending any more.
 418     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())
 419         return;
 420 
 421     // We want to batch operations together without spinning the runloop for performance,
 422     // but don&#39;t want to affect responsiveness of the main thread.
 423     // This number is a good compromise in ad-hoc testing.
 424     static const size_t operationBatchLimit = 128;
 425 
 426     for (size_t iterations = 0; !m_pendingTransactionOperationQueue.isEmpty() &amp;&amp; iterations &lt; operationBatchLimit; ++iterations) {
 427         auto operation = m_pendingTransactionOperationQueue.takeFirst();
 428         m_transactionOperationsInProgressQueue.append(operation.get());
 429         operation-&gt;perform();
 430 
 431         if (!operation-&gt;nextRequestCanGoToServer())
 432             break;
 433 
 434     }
 435 
 436     if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())
 437         return;
 438 
 439     if (!isFinishedOrFinishing())
 440         commit();
 441 }
 442 
 443 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)
 444 {
 445     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 446     ASSERT(&amp;operation.originThread() == &amp;Thread::current());
 447 
 448     m_completedOnServerQueue.append({ &amp;operation, data });
 449 
 450     if (!m_currentlyCompletingRequest)
 451         scheduleCompletedOperationTimer();
 452 }
 453 
 454 void IDBTransaction::scheduleCompletedOperationTimer()
 455 {
 456     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 457 
 458     if (!m_completedOperationTimer.isActive())
 459         m_completedOperationTimer.startOneShot(0_s);
 460 }
 461 
 462 void IDBTransaction::completedOperationTimerFired()
 463 {
 464     LOG(IndexedDB, &quot;IDBTransaction::completedOperationTimerFired (%p)&quot;, this);
 465     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 466 
 467     if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)
 468         return;
 469 
 470     auto iterator = m_completedOnServerQueue.takeFirst();
 471     iterator.first-&gt;doComplete(iterator.second);
 472 
 473     if (!m_completedOnServerQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest)
 474         scheduleCompletedOperationTimer();
 475 }
 476 
 477 void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 478 {
 479     ASSERT(!m_currentlyCompletingRequest);
 480 
 481     request.completeRequestAndDispatchEvent(result);
 482 
 483     m_currentlyCompletingRequest = &amp;request;
 484 }
 485 
 486 void IDBTransaction::completeCursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 487 {
 488     ASSERT(!m_currentlyCompletingRequest);
 489 
 490     request.didOpenOrIterateCursor(result);
 491 
 492     m_currentlyCompletingRequest = &amp;request;
 493 }
 494 
 495 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
 496 {
 497     if (isFinishedOrFinishing())
 498         return;
 499 
 500     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
 501 
 502     m_currentlyCompletingRequest = nullptr;
 503     scheduleCompletedOperationTimer();
 504 }
 505 
 506 void IDBTransaction::commit()
 507 {
 508     LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
 509     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 510     ASSERT(!isFinishedOrFinishing());
 511 
 512     transitionedToFinishing(IndexedDB::TransactionState::Committing);
 513     m_database-&gt;willCommitTransaction(*this);
 514 
 515     LOG(IndexedDBOperations, &quot;IDB commit operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 516     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 517         protectedThis-&gt;commitOnServer(operation);
 518     }));
 519 }
 520 
 521 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
 522 {
 523     LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
 524     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 525 
 526     m_database-&gt;connectionProxy().commitTransaction(*this);
 527 
 528     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
 529     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 530     m_transactionOperationsInProgressQueue.removeLast();
 531 
 532     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 533     m_transactionOperationMap.remove(operation.identifier());
 534 }
 535 
 536 void IDBTransaction::finishAbortOrCommit()
 537 {
 538     ASSERT(m_state != IndexedDB::TransactionState::Finished);
 539     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 540 
 541     m_state = IndexedDB::TransactionState::Finished;
 542 }
 543 
 544 void IDBTransaction::didStart(const IDBError&amp; error)
 545 {
 546     LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
 547     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 548 
 549     m_database-&gt;didStartTransaction(*this);
 550 
 551     m_startedOnServer = true;
 552 
 553     // It&#39;s possible the transaction failed to start on the server.
 554     // That equates to an abort.
 555     if (!error.isNull()) {
 556         didAbort(error);
 557         return;
 558     }
 559 
 560     schedulePendingOperationTimer();
 561 }
 562 
 563 void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
 564 {
 565     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 566 
 567     m_database-&gt;didAbortTransaction(*this);
 568     m_idbError = error;
 569     fireOnAbort();
 570 
 571     if (isVersionChange() &amp;&amp; !m_contextStopped) {
 572         ASSERT(m_openDBRequest);
 573         m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 574     }
 575 }
 576 
 577 void IDBTransaction::didAbort(const IDBError&amp; error)
 578 {
 579     LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
 580     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 581 
 582     if (m_state == IndexedDB::TransactionState::Finished)
 583         return;
 584 
 585     notifyDidAbort(error);
 586 
 587     finishAbortOrCommit();
 588 }
 589 
 590 void IDBTransaction::didCommit(const IDBError&amp; error)
 591 {
 592     LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
 593     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 594     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 595 
 596     if (error.isNull()) {
 597         m_database-&gt;didCommitTransaction(*this);
 598         fireOnComplete();
 599     } else {
 600         m_database-&gt;willAbortTransaction(*this);
 601         notifyDidAbort(error);
 602     }
 603 
 604     finishAbortOrCommit();
 605 }
 606 
 607 void IDBTransaction::fireOnComplete()
 608 {
 609     LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
 610     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 611     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 612 }
 613 
 614 void IDBTransaction::fireOnAbort()
 615 {
 616     LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
 617     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 618     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 619 }
 620 
 621 void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
 622 {
 623     ASSERT(m_state != IndexedDB::TransactionState::Finished);
 624     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 625 
 626     if (!scriptExecutionContext() || m_contextStopped)
 627         return;
 628 
 629     event-&gt;setTarget(this);
 630     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));
 631 }
 632 
 633 void IDBTransaction::dispatchEvent(Event&amp; event)
 634 {
 635     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 636 
 637     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 638     ASSERT(scriptExecutionContext());
 639     ASSERT(!m_contextStopped);
 640     ASSERT(event.target() == this);
 641     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 642 
 643     auto protectedThis = makeRef(*this);
 644 
 645     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
 646     m_didDispatchAbortOrCommit = true;
 647 
 648     if (isVersionChange()) {
 649         ASSERT(m_openDBRequest);
 650         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 651 
 652         if (event.type() == eventNames().completeEvent) {
 653             if (m_database-&gt;isClosingOrClosed())
 654                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 655             else
 656                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 657         }
 658 
 659         m_openDBRequest = nullptr;
 660     }
 661 }
 662 
 663 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 664 {
 665     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 666     ASSERT(isVersionChange());
 667     ASSERT(scriptExecutionContext());
 668     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 669 
 670     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 671 
 672     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
 673     auto* rawObjectStore = objectStore.get();
 674     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 675 
 676     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 677     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 678         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 679     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 680         protectedThis-&gt;createObjectStoreOnServer(operation, info);
 681     }));
 682 
 683     return *rawObjectStore;
 684 }
 685 
 686 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 687 {
 688     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
 689     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 690     ASSERT(isVersionChange());
 691 
 692     m_database-&gt;connectionProxy().createObjectStore(operation, info);
 693 }
 694 
 695 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
 696 {
 697     LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
 698     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 699     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 700 }
 701 
 702 void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
 703 {
 704     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStore&quot;);
 705 
 706     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 707 
 708     ASSERT(isVersionChange());
 709     ASSERT(scriptExecutionContext());
 710     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 711 
 712     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
 713     ASSERT(!m_referencedObjectStores.contains(newName));
 714     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
 715 
 716     uint64_t objectStoreIdentifier = objectStore.info().identifier();
 717 
 718     LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
 719     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 720         protectedThis-&gt;didRenameObjectStoreOnServer(result);
 721     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 722         protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
 723     }));
 724 
 725     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 726 }
 727 
 728 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
 729 {
 730     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
 731     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 732     ASSERT(isVersionChange());
 733 
 734     m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 735 }
 736 
 737 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
 738 {
 739     LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
 740     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 741     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 742 }
 743 
 744 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 745 {
 746     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 747     ASSERT(isVersionChange());
 748     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 749 
 750     if (!scriptExecutionContext())
 751         return nullptr;
 752 
 753     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 754     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 755         protectedThis-&gt;didCreateIndexOnServer(result);
 756     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 757         protectedThis-&gt;createIndexOnServer(operation, info);
 758     }));
 759 
 760     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
 761 }
 762 
 763 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
 766     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().createIndex(operation, info);
 770 }
 771 
 772 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
 775     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 776 
 777     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 778         return;
 779 
 780     ASSERT(resultData.type() == IDBResultType::Error);
 781 
 782     // This operation might have failed because the transaction is already aborting.
 783     if (m_state == IndexedDB::TransactionState::Aborting)
 784         return;
 785 
 786     // Otherwise, failure to create an index forced abortion of the transaction.
 787     abortDueToFailedRequest(DOMException::create(resultData.error().message(), resultData.error().name()));
 788 }
 789 
 790 void IDBTransaction::renameIndex(IDBIndex&amp; index, const String&amp; newName)
 791 {
 792     LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
 793     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 794 
 795     ASSERT(isVersionChange());
 796     ASSERT(scriptExecutionContext());
 797     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 798 
 799     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
 800     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
 801 
 802     index.objectStore().renameReferencedIndex(index, newName);
 803 
 804     uint64_t objectStoreIdentifier = index.objectStore().info().identifier();
 805     uint64_t indexIdentifier = index.info().identifier();
 806 
 807     LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
 808     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 809         protectedThis-&gt;didRenameIndexOnServer(result);
 810     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 811         protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
 812     }));
 813 }
 814 
 815 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
 816 {
 817     LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
 818     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 819     ASSERT(isVersionChange());
 820 
 821     m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 822 }
 823 
 824 void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
 825 {
 826     LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
 827     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 828     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 829 }
 830 
 831 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)
 832 {
 833     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
 834     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 835 
 836     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 837         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 838 
 839     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 840 }
 841 
 842 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)
 843 {
 844     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
 845     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 846 
 847     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 848         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 849 
 850     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 851 }
 852 
 853 Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(ExecState&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)
 854 {
 855     ASSERT(isActive());
 856     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 857 
 858     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 859 
 860     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
 861     addRequest(request.get());
 862 
 863     LOG(IndexedDBOperations, &quot;IDB open cursor operation: %s&quot;, cursor-&gt;info().loggingString().utf8().data());
 864     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 865         protectedThis-&gt;didOpenCursorOnServer(request.get(), result);
 866     }, [protectedThis = makeRef(*this), info = cursor-&gt;info().isolatedCopy()] (auto&amp; operation) {
 867         protectedThis-&gt;openCursorOnServer(operation, info);
 868     }));
 869 
 870     return request;
 871 }
 872 
 873 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
 874 {
 875     LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
 876     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 877 
 878     m_database-&gt;connectionProxy().openCursor(operation, info);
 879 }
 880 
 881 void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 882 {
 883     LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
 884     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 885 
 886     completeCursorRequest(request, resultData);
 887 }
 888 
 889 void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
 890 {
 891     LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
 892     ASSERT(isActive());
 893     ASSERT(cursor.request());
 894     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 895 
 896     addRequest(*cursor.request());
 897 
 898     LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
 899     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
 900         protectedThis-&gt;didIterateCursorOnServer(request.get(), result);
 901     }, [protectedThis = makeRef(*this), data = data.isolatedCopy()] (auto&amp; operation) {
 902         protectedThis-&gt;iterateCursorOnServer(operation, data);
 903     }));
 904 }
 905 
 906 // FIXME: changes here
 907 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
 908 {
 909     LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
 910     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 911 
 912     m_database-&gt;connectionProxy().iterateCursor(operation, data);
 913 }
 914 
 915 void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 916 {
 917     LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
 918     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 919 
 920     completeCursorRequest(request, resultData);
 921 }
 922 
 923 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)
 924 {
 925     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
 926     ASSERT(isActive());
 927     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 928 
 929     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 930 
 931     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
 932     addRequest(request.get());
 933 
 934     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, objectStore.info().identifier(), 0 };
 935 
 936     LOG(IndexedDBOperations, &quot;IDB get all object store records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 937     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 938         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 939     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 940         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 941     }));
 942 
 943     return request;
 944 }
 945 
 946 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)
 947 {
 948     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
 949     ASSERT(isActive());
 950     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 951 
 952     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 953 
 954     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
 955     addRequest(request.get());
 956 
 957     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, index.objectStore().info().identifier(), index.info().identifier() };
 958 
 959     LOG(IndexedDBOperations, &quot;IDB get all index records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 960     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 961         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 962     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 963         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 964     }));
 965 
 966     return request;
 967 }
 968 
 969 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
 970 {
 971     LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
 972     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 973 
 974     m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
 975 }
 976 
 977 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 978 {
 979     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
 980     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 981 
 982     if (resultData.type() == IDBResultType::Error) {
 983         completeNoncursorRequest(request, resultData);
 984         return;
 985     }
 986 
 987     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 988 
 989     auto&amp; getAllResult = resultData.getAllResult();
 990     switch (getAllResult.type()) {
 991     case IndexedDB::GetAllType::Keys:
 992         request.setResult(getAllResult.keys());
 993         break;
 994     case IndexedDB::GetAllType::Values:
 995         request.setResult(getAllResult);
 996         break;
 997     }
 998 
 999     completeNoncursorRequest(request, resultData);
1000 }
1001 
1002 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)
1003 {
1004     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
1005     ASSERT(isActive());
1006     ASSERT(!getRecordData.keyRangeData.isNull);
1007     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1008 
1009     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1010 
1011     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
1012 
1013     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
1014     addRequest(request.get());
1015 
1016     LOG(IndexedDBOperations, &quot;IDB get record operation: %s %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1017     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1018         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1019     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1020         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1021     }));
1022 
1023     return request;
1024 }
1025 
1026 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
1027 {
1028     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1029     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1030 
1031     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
1032 }
1033 
1034 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
1035 {
1036     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1037     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1038 
1039     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
1040 }
1041 
1042 Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(ExecState&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)
1043 {
1044     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1045     ASSERT(isActive());
1046     ASSERT(!range.isNull);
1047     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1048 
1049     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1050 
1051     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
1052     addRequest(request.get());
1053 
1054     IDBGetRecordData getRecordData = { range, IDBGetRecordDataType::KeyAndValue };
1055 
1056     LOG(IndexedDBOperations, &quot;IDB get index record operation: %s %s&quot;, index.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1057     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1058         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1059     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1060         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1061     }));
1062 
1063     return request;
1064 }
1065 
1066 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
1067 {
1068     LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
1069     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1070 
1071     m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
1072 }
1073 
1074 void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1075 {
1076     LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
1077     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1078 
1079     if (resultData.type() == IDBResultType::Error) {
1080         completeNoncursorRequest(request, resultData);
1081         return;
1082     }
1083 
1084     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1085 
1086     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1087     if (!useResultKey)
1088         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1089 
1090     const IDBGetResult&amp; result = resultData.getResult();
1091 
1092     if (useResultKey) {
1093         if (!result.keyData().isNull())
1094             request.setResult(result.keyData());
1095         else
1096             request.setResultToUndefined();
1097     } else {
1098         if (resultData.getResult().value().data().data())
1099             request.setResultToStructuredClone(resultData.getResult());
1100         else
1101             request.setResultToUndefined();
1102     }
1103 
1104     completeNoncursorRequest(request, resultData);
1105 }
1106 
1107 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1108 {
1109     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1110     ASSERT(isActive());
1111     ASSERT(!range.isNull);
1112     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1113 
1114     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1115 
1116     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1117     addRequest(request.get());
1118 
1119     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1120     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1121         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1122     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1123         protectedThis-&gt;getCountOnServer(operation, range);
1124     }));
1125 
1126     return request;
1127 }
1128 
1129 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
1130 {
1131     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
1132     ASSERT(isActive());
1133     ASSERT(!range.isNull);
1134     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1135 
1136     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1137 
1138     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
1139     addRequest(request.get());
1140 
1141     LOG(IndexedDBOperations, &quot;IDB index count operation: %s, range %s&quot;, index.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1142     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1143         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1144     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1145         protectedThis-&gt;getCountOnServer(operation, range);
1146     }));
1147 
1148     return request;
1149 }
1150 
1151 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1152 {
1153     LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
1154     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1155 
1156     m_database-&gt;connectionProxy().getCount(operation, keyRange);
1157 }
1158 
1159 void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1160 {
1161     LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
1162     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1163 
1164     request.setResult(resultData.resultInteger());
1165     completeNoncursorRequest(request, resultData);
1166 }
1167 
1168 Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1169 {
1170     LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
1171     ASSERT(isActive());
1172     ASSERT(!range.isNull);
1173     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1174 
1175     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1176 
1177     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1178     addRequest(request.get());
1179 
1180     LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1181     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1182         protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
1183     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1184         protectedThis-&gt;deleteRecordOnServer(operation, range);
1185     }));
1186     return request;
1187 }
1188 
1189 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1190 {
1191     LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
1192     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1193 
1194     m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
1195 }
1196 
1197 void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1198 {
1199     LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
1200     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1201 
1202     request.setResultToUndefined();
1203     completeNoncursorRequest(request, resultData);
1204 }
1205 
1206 Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(ExecState&amp; state, IDBObjectStore&amp; objectStore)
1207 {
1208     LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
1209     ASSERT(isActive());
1210     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1211 
1212     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1213 
1214     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1215     addRequest(request.get());
1216 
1217     uint64_t objectStoreIdentifier = objectStore.info().identifier();
1218 
1219     LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
1220     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1221         protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
1222     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
1223         protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
1224     }));
1225 
1226     return request;
1227 }
1228 
1229 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
1230 {
1231     LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
1232     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1233 
1234     m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
1235 }
1236 
1237 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1238 {
1239     LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
1240     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1241 
1242     request.setResultToUndefined();
1243     completeNoncursorRequest(request, resultData);
1244 }
1245 
1246 Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(ExecState&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
1247 {
1248     LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
1249     ASSERT(isActive());
1250     ASSERT(!isReadOnly());
1251     ASSERT(objectStore.info().autoIncrement() || key);
1252     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1253 
1254     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1255 
1256     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1257     addRequest(request.get());
1258 
1259     LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
1260     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1261         protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
1262     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
1263         protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
1264     }));
1265 
1266     return request;
1267 }
1268 
1269 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1270 {
1271     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
1272     ASSERT(&amp;originThread() == &amp;Thread::current());
1273     ASSERT(!isReadOnly());
1274     ASSERT(value);
1275 
1276     if (!value-&gt;hasBlobURLs()) {
1277         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1278         return;
1279     }
1280 
1281     // Due to current limitations on our ability to post tasks back to a worker thread,
1282     // workers currently write blobs to disk synchronously.
1283     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1284     if (!isMainThread()) {
1285         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously(scriptExecutionContext()-&gt;sessionID());
1286         if (idbValue.data().data())
1287             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1288         else {
1289             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1290             // In that case, we cannot successfully store this record, so we callback with an error.
1291             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1292             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1293             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1294                 protectedOperation-&gt;doComplete(result);
1295             });
1296         }
1297         return;
1298     }
1299 
1300     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1301     // stop future requests from going to the server ahead of it.
1302     operation.setNextRequestCanGoToServer(false);
1303 
1304     value-&gt;writeBlobsToDiskForIndexedDB(scriptExecutionContext()-&gt;sessionID(), [protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {
1305         ASSERT(&amp;originThread() == &amp;Thread::current());
1306         ASSERT(isMainThread());
1307         if (idbValue.data().data()) {
1308             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1309             return;
1310         }
1311 
1312         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1313         // In that case, we cannot successfully store this record, so we callback with an error.
1314         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1315         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1316             protectedOperation-&gt;doComplete(result);
1317         });
1318     });
1319 }
1320 
1321 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1322 {
1323     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
1324     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1325 
1326     if (auto* result = resultData.resultKey())
1327         request.setResult(*result);
1328     else
1329         request.setResultToUndefined();
1330     completeNoncursorRequest(request, resultData);
1331 }
1332 
1333 void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
1334 {
1335     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
1336     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1337     ASSERT(isVersionChange());
1338 
1339     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1340 
1341     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
1342         objectStore-&gt;markAsDeleted();
1343         auto identifier = objectStore-&gt;info().identifier();
1344         m_deletedObjectStores.set(identifier, WTFMove(objectStore));
1345     }
1346 
1347     LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
1348     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1349         protectedThis-&gt;didDeleteObjectStoreOnServer(result);
1350     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
1351         protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
1352     }));
1353 }
1354 
1355 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
1356 {
1357     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
1358     ASSERT(isVersionChange());
1359     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1360 
1361     m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
1362 }
1363 
1364 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
1365 {
1366     LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
1367     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1368     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
1369 }
1370 
1371 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
1372 {
1373     LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
1374     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1375     ASSERT(isVersionChange());
1376 
1377     LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
1378     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1379         protectedThis-&gt;didDeleteIndexOnServer(result);
1380     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
1381         protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
1382     }));
1383 }
1384 
1385 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
1386 {
1387     LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
1388     ASSERT(isVersionChange());
1389     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1390 
1391     m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
1392 }
1393 
1394 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
1395 {
1396     LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
1397     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1398     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
1399 }
1400 
1401 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
1402 {
1403     LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
1404 
1405     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1406     ASSERT(&amp;operation.originThread() == &amp;Thread::current());
1407     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
1408     ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
1409 
1410     m_transactionOperationMap.remove(operation.identifier());
1411     m_transactionOperationsInProgressQueue.removeFirst();
1412 
1413     schedulePendingOperationTimer();
1414 }
1415 
1416 void IDBTransaction::establishOnServer()
1417 {
1418     LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
1419     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1420 
1421     m_database-&gt;connectionProxy().establishTransaction(*this);
1422 }
1423 
1424 void IDBTransaction::activate()
1425 {
1426     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1427 
1428     if (isFinishedOrFinishing())
1429         return;
1430 
1431     m_state = IndexedDB::TransactionState::Active;
1432 }
1433 
1434 void IDBTransaction::deactivate()
1435 {
1436     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1437 
1438     if (m_state == IndexedDB::TransactionState::Active)
1439         m_state = IndexedDB::TransactionState::Inactive;
1440 
1441     schedulePendingOperationTimer();
1442 }
1443 
1444 void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
1445 {
1446     LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
1447 
1448     m_database-&gt;willAbortTransaction(*this);
1449     m_state = IndexedDB::TransactionState::Aborting;
1450 
1451     abortInProgressOperations(error);
1452 
1453     auto operations = copyToVector(m_transactionOperationMap.values());
1454     for (auto&amp; operation : operations) {
1455         m_currentlyCompletingRequest = nullptr;
1456         m_transactionOperationsInProgressQueue.append(operation.get());
1457         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
1458         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
1459     }
1460     m_currentlyCompletingRequest = nullptr;
1461 
1462     connectionProxy().forgetActiveOperations(operations);
1463     connectionProxy().forgetTransaction(*this);
1464 
1465     m_pendingTransactionOperationQueue.clear();
1466     m_abortQueue.clear();
1467     m_transactionOperationMap.clear();
1468 
1469     m_idbError = error;
1470     m_domError = error.toDOMException();
1471     m_database-&gt;didAbortTransaction(*this);
1472     fireOnAbort();
1473 }
1474 
1475 void IDBTransaction::visitReferencedObjectStores(JSC::SlotVisitor&amp; visitor) const
1476 {
1477     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1478     for (auto&amp; objectStore : m_referencedObjectStores.values())
1479         visitor.addOpaqueRoot(objectStore.get());
1480     for (auto&amp; objectStore : m_deletedObjectStores.values())
1481         visitor.addOpaqueRoot(objectStore.get());
1482 }
1483 
1484 } // namespace WebCore
1485 
1486 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>