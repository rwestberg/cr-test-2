<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
  36 #include &quot;GetByIdStatus.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;MathCommon.h&quot;
  42 #include &quot;NumberConstructor.h&quot;
  43 #include &quot;Operations.h&quot;
  44 #include &quot;PutByIdStatus.h&quot;
  45 #include &quot;StringObject.h&quot;
<a name="2" id="anc2"></a>
  46 #include &quot;StructureRareDataInlines.h&quot;
  47 #include &lt;wtf/BooleanLattice.h&gt;
  48 #include &lt;wtf/CheckedArithmetic.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 template&lt;typename AbstractStateType&gt;
  53 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  54     : m_codeBlock(graph.m_codeBlock)
  55     , m_graph(graph)
  56     , m_vm(m_graph.m_vm)
  57     , m_state(state)
  58 {
  59     if (m_graph.m_form == SSA)
<a name="3" id="anc3"></a><span class="line-modified">  60         m_phiChildren = std::make_unique&lt;PhiChildren&gt;(m_graph);</span>
  61 }
  62 
  63 template&lt;typename AbstractStateType&gt;
  64 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  65 {
  66 }
  67 
  68 template&lt;typename AbstractStateType&gt;
  69 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  70 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  71     Node* node, AbstractValue&amp; value)
  72 {
  73     JSValue childConst = value.value();
  74     if (childConst) {
  75         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))
  76             return DefinitelyTrue;
  77         return DefinitelyFalse;
  78     }
  79 
  80     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
  81     if (isCellSpeculation(value.m_type) &amp;&amp; !value.m_structure.isTop()) {
  82         bool allTrue = true;
  83         for (unsigned i = value.m_structure.size(); i--;) {
  84             RegisteredStructure structure = value.m_structure[i];
  85             if (structure-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
  86                 || structure-&gt;typeInfo().type() == StringType) {
  87                 allTrue = false;
  88                 break;
  89             }
  90         }
  91         if (allTrue)
  92             return DefinitelyTrue;
  93     }
  94 
  95     return UnknownBooleanResult;
  96 }
  97 
  98 template&lt;typename AbstractStateType&gt;
  99 void AbstractInterpreter&lt;AbstractStateType&gt;::startExecuting()
 100 {
 101     ASSERT(m_state.block());
 102     ASSERT(m_state.isValid());
 103 
 104     m_state.setClobberState(AbstractInterpreterClobberState::NotClobbered);
 105 }
 106 
 107 template&lt;typename AbstractStateType&gt;
 108 class AbstractInterpreterExecuteEdgesFunc {
 109 public:
 110     AbstractInterpreterExecuteEdgesFunc(AbstractInterpreter&lt;AbstractStateType&gt;&amp; interpreter)
 111         : m_interpreter(interpreter)
 112     {
 113     }
 114 
 115     // This func is manually written out so that we can put ALWAYS_INLINE on it.
 116     ALWAYS_INLINE void operator()(Edge&amp; edge) const
 117     {
 118         m_interpreter.filterEdgeByUse(edge);
 119     }
 120 
 121 private:
 122     AbstractInterpreter&lt;AbstractStateType&gt;&amp; m_interpreter;
 123 };
 124 
 125 template&lt;typename AbstractStateType&gt;
 126 void AbstractInterpreter&lt;AbstractStateType&gt;::executeEdges(Node* node)
 127 {
 128     m_graph.doToChildren(node, AbstractInterpreterExecuteEdgesFunc&lt;AbstractStateType&gt;(*this));
 129 }
 130 
 131 template&lt;typename AbstractStateType&gt;
 132 void AbstractInterpreter&lt;AbstractStateType&gt;::executeKnownEdgeTypes(Node* node)
 133 {
 134     // Some use kinds are required to not have checks, because we know somehow that the incoming
 135     // value will already have the type we want. In those cases, AI may not be smart enough to
 136     // prove that this is indeed the case. But the existance of the edge is enough to prove that
 137     // it is indeed the case. Taking advantage of this is not optional, since otherwise the DFG
 138     // and FTL backends may emit checks in a node that lacks a valid exit origin.
 139     m_graph.doToChildren(
 140         node,
 141         [&amp;] (Edge&amp; edge) {
 142             if (mayHaveTypeCheck(edge.useKind()))
 143                 return;
 144 
 145             filterEdgeByUse(edge);
 146         });
 147 }
 148 
 149 template&lt;typename AbstractStateType&gt;
 150 ALWAYS_INLINE void AbstractInterpreter&lt;AbstractStateType&gt;::filterByType(Edge&amp; edge, SpeculatedType type)
 151 {
 152     AbstractValue&amp; value = m_state.forNodeWithoutFastForward(edge);
 153     if (value.isType(type)) {
 154         m_state.setProofStatus(edge, IsProved);
 155         return;
 156     }
 157     m_state.setProofStatus(edge, NeedsCheck);
 158     m_state.fastForwardAndFilterUnproven(value, type);
 159 }
 160 
 161 template&lt;typename AbstractStateType&gt;
 162 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdge(Node* node, Edge edge)
 163 {
 164     if (!(m_state.forNodeWithoutFastForward(edge).m_type &amp; ~typeFilterFor(edge.useKind())))
 165         return;
 166 
 167     DFG_CRASH(m_graph, node, toCString(&quot;Edge verification error: &quot;, node, &quot;-&gt;&quot;, edge, &quot; was expected to have type &quot;, SpeculationDump(typeFilterFor(edge.useKind())), &quot; but has type &quot;, SpeculationDump(forNode(edge).m_type), &quot; (&quot;, forNode(edge).m_type, &quot;)&quot;).data(), AbstractInterpreterInvalidType, node-&gt;op(), edge-&gt;op(), edge.useKind(), forNode(edge).m_type);
 168 }
 169 
 170 template&lt;typename AbstractStateType&gt;
 171 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdges(Node* node)
 172 {
 173     DFG_NODE_DO_TO_CHILDREN(m_graph, node, verifyEdge);
 174 }
 175 
 176 enum class ToThisResult {
 177     Identity,
 178     Undefined,
 179     GlobalThis,
 180     Dynamic,
 181 };
 182 inline ToThisResult isToThisAnIdentity(VM&amp; vm, bool isStrictMode, AbstractValue&amp; valueForNode)
 183 {
 184     // We look at the type first since that will cover most cases and does not require iterating all the structures.
 185     if (isStrictMode) {
 186         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; SpecObjectOther))
 187             return ToThisResult::Identity;
 188     } else {
 189         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; (~SpecObject | SpecObjectOther)))
 190             return ToThisResult::Identity;
 191     }
 192 
 193     if (JSValue value = valueForNode.value()) {
 194         if (value.isCell()) {
 195             auto* toThisMethod = value.asCell()-&gt;classInfo(vm)-&gt;methodTable.toThis;
 196             if (toThisMethod == &amp;JSObject::toThis)
 197                 return ToThisResult::Identity;
 198             if (toThisMethod == &amp;JSScope::toThis) {
 199                 if (isStrictMode)
 200                     return ToThisResult::Undefined;
 201                 return ToThisResult::GlobalThis;
 202             }
 203         }
 204     }
 205 
 206     if ((isStrictMode || (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; ~SpecObject))) &amp;&amp; valueForNode.m_structure.isFinite()) {
 207         bool allStructuresAreJSScope = !valueForNode.m_structure.isClear();
 208         bool overridesToThis = false;
 209         valueForNode.m_structure.forEach([&amp;](RegisteredStructure structure) {
 210             TypeInfo type = structure-&gt;typeInfo();
 211             ASSERT(type.isObject() || type.type() == StringType || type.type() == SymbolType || type.type() == BigIntType);
 212             if (!isStrictMode)
 213                 ASSERT(type.isObject());
 214             // We don&#39;t need to worry about strings/symbols here since either:
 215             // 1) We are in strict mode and strings/symbols are not wrapped
 216             // 2) The AI has proven that the type of this is a subtype of object
 217             if (type.isObject() &amp;&amp; type.overridesToThis())
 218                 overridesToThis = true;
 219 
 220             // If all the structures are JSScope&#39;s ones, we know the details of JSScope::toThis() operation.
 221             allStructuresAreJSScope &amp;= structure-&gt;classInfo()-&gt;methodTable.toThis == JSScope::info()-&gt;methodTable.toThis;
 222         });
 223         if (!overridesToThis)
 224             return ToThisResult::Identity;
 225         if (allStructuresAreJSScope) {
 226             if (isStrictMode)
 227                 return ToThisResult::Undefined;
 228             return ToThisResult::GlobalThis;
 229         }
 230     }
 231 
 232     return ToThisResult::Dynamic;
 233 }
 234 
<a name="4" id="anc4"></a>































































































 235 template&lt;typename AbstractStateType&gt;
 236 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 237 {
 238     verifyEdges(node);
 239 
 240     m_state.createValueForNode(node);
 241 
 242     switch (node-&gt;op()) {
 243     case JSConstant:
 244     case DoubleConstant:
 245     case Int52Constant: {
 246         setBuiltInConstant(node, *node-&gt;constant());
 247         break;
 248     }
 249 
 250     case LazyJSConstant: {
 251         LazyJSValue value = node-&gt;lazyJSValue();
 252         switch (value.kind()) {
 253         case LazyJSValue::KnownValue:
 254             setConstant(node, value.value()-&gt;value());
 255             break;
 256         case LazyJSValue::SingleCharacterString:
 257         case LazyJSValue::KnownStringImpl:
 258         case LazyJSValue::NewStringImpl:
 259             setTypeForNode(node, SpecString);
 260             break;
 261         }
 262         break;
 263     }
 264 
 265     case IdentityWithProfile:
 266     case Identity: {
 267         setForNode(node, forNode(node-&gt;child1()));
 268         if (forNode(node).value())
 269             m_state.setFoundConstants(true);
 270         break;
 271     }
 272 
 273     case ExtractCatchLocal:
 274     case ExtractOSREntryLocal: {
 275         makeBytecodeTopForNode(node);
 276         break;
 277     }
 278 
 279     case GetLocal: {
 280         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 281         AbstractValue value = m_state.operand(variableAccessData-&gt;local().offset());
 282         // The value in the local should already be checked.
 283         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
 284         if (value.value())
 285             m_state.setFoundConstants(true);
 286         setForNode(node, value);
 287         break;
 288     }
 289 
 290     case GetStack: {
 291         StackAccessData* data = node-&gt;stackAccessData();
 292         AbstractValue value = m_state.operand(data-&gt;local);
 293         // The value in the local should already be checked.
 294         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
 295         if (value.value())
 296             m_state.setFoundConstants(true);
 297         setForNode(node, value);
 298         break;
 299     }
 300 
 301     case SetLocal: {
 302         m_state.operand(node-&gt;local()) = forNode(node-&gt;child1());
 303         break;
 304     }
 305 
 306     case PutStack: {
 307         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());
 308         break;
 309     }
 310 
 311     case MovHint: {
 312         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 313         // in bytecode, but this code is just concerned with what is actually happening during
 314         // DFG execution.
 315         break;
 316     }
 317 
 318     case KillStack: {
 319         // This is just a hint telling us that the OSR state of the local is no longer inside the
 320         // flushed data.
 321         break;
 322     }
 323 
<a name="5" id="anc5"></a><span class="line-modified"> 324     case SetArgument:</span>
<span class="line-modified"> 325         // Assert that the state of arguments has been set. SetArgument means that someone set</span>
<span class="line-modified"> 326         // the argument values out-of-band, and currently this always means setting to a</span>

 327         // non-clear value.
 328         ASSERT(!m_state.operand(node-&gt;local()).isClear());
 329         break;
 330 
 331     case InitializeEntrypointArguments: {
 332         unsigned entrypointIndex = node-&gt;entrypointIndex();
 333         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 334         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 335             AbstractValue&amp; value = m_state.argument(argument);
 336             switch (argumentFormats[argument]) {
 337             case FlushedInt32:
 338                 value.setNonCellType(SpecInt32Only);
 339                 break;
 340             case FlushedBoolean:
 341                 value.setNonCellType(SpecBoolean);
 342                 break;
 343             case FlushedCell:
 344                 value.setType(m_graph, SpecCellCheck);
 345                 break;
 346             case FlushedJSValue:
 347                 value.makeBytecodeTop();
 348                 break;
 349             default:
 350                 DFG_CRASH(m_graph, node, &quot;Bad flush format for argument&quot;);
 351                 break;
 352             }
 353         }
 354         break;
 355     }
 356 
 357     case LoadVarargs:
 358     case ForwardVarargs: {
 359         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 360         // itself into a straight-line sequence of GetStack/PutStack.
 361         // https://bugs.webkit.org/show_bug.cgi?id=143071
 362         switch (node-&gt;op()) {
 363         case LoadVarargs:
 364             clobberWorld();
 365             break;
 366         case ForwardVarargs:
 367             break;
 368         default:
 369             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 370             break;
 371         }
 372         LoadVarargsData* data = node-&gt;loadVarargsData();
 373         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 374         for (unsigned i = data-&gt;limit - 1; i--;)
 375             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();
 376         break;
 377     }
 378 
<a name="6" id="anc6"></a><span class="line-modified"> 379     case ArithBitNot: {</span>
<span class="line-modified"> 380         if (node-&gt;child1().useKind() == UntypedUse) {</span>
<span class="line-modified"> 381             clobberWorld();</span>
<span class="line-modified"> 382             setNonCellTypeForNode(node, SpecInt32Only);</span>


 383             break;
 384         }
 385 
<a name="7" id="anc7"></a>










 386         JSValue operand = forNode(node-&gt;child1()).value();
 387         if (operand &amp;&amp; operand.isInt32()) {
 388             int32_t a = operand.asInt32();
 389             setConstant(node, JSValue(~a));
 390             break;
 391         }
 392 
 393         setNonCellTypeForNode(node, SpecInt32Only);
 394         break;
 395     }
 396 
 397     case ValueBitXor:
 398     case ValueBitAnd:
 399     case ValueBitOr:
<a name="8" id="anc8"></a>



 400         if (node-&gt;binaryUseKind() == BigIntUse)
 401             setTypeForNode(node, SpecBigInt);
 402         else {
 403             clobberWorld();
<a name="9" id="anc9"></a><span class="line-modified"> 404             setTypeForNode(node, SpecBoolInt32 | SpecBigInt);</span>
 405         }
 406         break;
<a name="10" id="anc10"></a>
 407 
 408     case ArithBitAnd:
 409     case ArithBitOr:
 410     case ArithBitXor:
 411     case BitRShift:
<a name="11" id="anc11"></a><span class="line-modified"> 412     case BitLShift:</span>
 413     case BitURShift: {
 414         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 415             clobberWorld();
 416             setNonCellTypeForNode(node, SpecInt32Only);
 417             break;
 418         }
 419 
<a name="12" id="anc12"></a><span class="line-modified"> 420         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 421         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-removed"> 422         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 423             int32_t a = left.asInt32();</span>
<span class="line-removed"> 424             int32_t b = right.asInt32();</span>
<span class="line-removed"> 425             switch (node-&gt;op()) {</span>
<span class="line-removed"> 426             case ArithBitAnd:</span>
<span class="line-removed"> 427                 setConstant(node, JSValue(a &amp; b));</span>
<span class="line-removed"> 428                 break;</span>
<span class="line-removed"> 429             case ArithBitOr:</span>
<span class="line-removed"> 430                 setConstant(node, JSValue(a | b));</span>
<span class="line-removed"> 431                 break;</span>
<span class="line-removed"> 432             case ArithBitXor:</span>
<span class="line-removed"> 433                 setConstant(node, JSValue(a ^ b));</span>
<span class="line-removed"> 434                 break;</span>
<span class="line-removed"> 435             case BitRShift:</span>
<span class="line-removed"> 436                 setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-removed"> 437                 break;</span>
<span class="line-removed"> 438             case BitLShift:</span>
<span class="line-removed"> 439                 setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-removed"> 440                 break;</span>
<span class="line-removed"> 441             case BitURShift:</span>
<span class="line-removed"> 442                 setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="line-removed"> 443                 break;</span>
<span class="line-removed"> 444             default:</span>
<span class="line-removed"> 445                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 446                 break;</span>
<span class="line-removed"> 447             }</span>
 448             break;
<a name="13" id="anc13"></a><span class="line-removed"> 449         }</span>
 450 
 451         if (node-&gt;op() == ArithBitAnd
 452             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 453                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 454             setNonCellTypeForNode(node, SpecBoolInt32);
 455             break;
 456         }
 457 
 458         setNonCellTypeForNode(node, SpecInt32Only);
 459         break;
 460     }
 461 
 462     case UInt32ToNumber: {
 463         JSValue child = forNode(node-&gt;child1()).value();
 464         if (doesOverflow(node-&gt;arithMode())) {
 465             if (enableInt52()) {
 466                 if (child &amp;&amp; child.isAnyInt()) {
 467                     int64_t machineInt = child.asAnyInt();
 468                     setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
 469                     break;
 470                 }
<a name="14" id="anc14"></a><span class="line-modified"> 471                 setNonCellTypeForNode(node, SpecAnyInt);</span>
 472                 break;
 473             }
 474             if (child &amp;&amp; child.isInt32()) {
 475                 uint32_t value = child.asInt32();
 476                 setConstant(node, jsNumber(value));
 477                 break;
 478             }
 479             setNonCellTypeForNode(node, SpecAnyIntAsDouble);
 480             break;
 481         }
 482         if (child &amp;&amp; child.isInt32()) {
 483             int32_t value = child.asInt32();
 484             if (value &gt;= 0) {
 485                 setConstant(node, jsNumber(value));
 486                 break;
 487             }
 488         }
 489         setNonCellTypeForNode(node, SpecInt32Only);
 490         break;
 491     }
 492 
 493     case BooleanToNumber: {
 494         JSValue concreteValue = forNode(node-&gt;child1()).value();
 495         if (concreteValue) {
 496             if (concreteValue.isBoolean())
 497                 setConstant(node, jsNumber(concreteValue.asBoolean()));
 498             else
 499                 setConstant(node, *m_graph.freeze(concreteValue));
 500             break;
 501         }
 502         AbstractValue&amp; value = forNode(node);
 503         value = forNode(node-&gt;child1());
 504         if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
 505             m_state.setFoundConstants(true);
 506         if (value.m_type &amp; SpecBoolean) {
 507             value.merge(SpecBoolInt32);
 508             value.filter(~SpecBoolean);
 509         }
 510         break;
 511     }
 512 
 513     case DoubleAsInt32: {
 514         JSValue child = forNode(node-&gt;child1()).value();
 515         if (child &amp;&amp; child.isNumber()) {
 516             double asDouble = child.asNumber();
 517             int32_t asInt = JSC::toInt32(asDouble);
 518             if (bitwise_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(asInt)) == bitwise_cast&lt;int64_t&gt;(asDouble)) {
 519                 setConstant(node, JSValue(asInt));
 520                 break;
 521             }
 522         }
 523         setNonCellTypeForNode(node, SpecInt32Only);
 524         break;
 525     }
 526 
 527     case ValueToInt32: {
 528         JSValue child = forNode(node-&gt;child1()).value();
 529         if (child) {
 530             if (child.isNumber()) {
 531                 if (child.isInt32())
 532                     setConstant(node, child);
 533                 else
 534                     setConstant(node, JSValue(JSC::toInt32(child.asDouble())));
 535                 break;
 536             }
 537             if (child.isBoolean()) {
 538                 setConstant(node, jsNumber(child.asBoolean()));
 539                 break;
 540             }
 541             if (child.isUndefinedOrNull()) {
 542                 setConstant(node, jsNumber(0));
 543                 break;
 544             }
 545         }
 546 
 547         if (isBooleanSpeculation(forNode(node-&gt;child1()).m_type)) {
 548             setNonCellTypeForNode(node, SpecBoolInt32);
 549             break;
 550         }
 551 
 552         setNonCellTypeForNode(node, SpecInt32Only);
 553         break;
 554     }
 555 
 556     case DoubleRep: {
 557         JSValue child = forNode(node-&gt;child1()).value();
 558         if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
 559             setConstant(node, jsDoubleNumber(*number));
 560             break;
 561         }
 562 
 563         SpeculatedType type = forNode(node-&gt;child1()).m_type;
 564         switch (node-&gt;child1().useKind()) {
 565         case NotCellUse: {
 566             if (type &amp; SpecOther) {
 567                 type &amp;= ~SpecOther;
 568                 type |= SpecDoublePureNaN | SpecBoolInt32; // Null becomes zero, undefined becomes NaN.
 569             }
 570             if (type &amp; SpecBoolean) {
 571                 type &amp;= ~SpecBoolean;
 572                 type |= SpecBoolInt32; // True becomes 1, false becomes 0.
 573             }
 574             type &amp;= SpecBytecodeNumber;
 575             break;
 576         }
 577 
 578         case Int52RepUse:
 579         case NumberUse:
 580         case RealNumberUse:
 581             break;
 582 
 583         default:
 584             RELEASE_ASSERT_NOT_REACHED();
 585         }
 586         setNonCellTypeForNode(node, type);
 587         forNode(node).fixTypeForRepresentation(m_graph, node);
 588         break;
 589     }
 590 
 591     case Int52Rep: {
 592         JSValue child = forNode(node-&gt;child1()).value();
 593         if (child &amp;&amp; child.isAnyInt()) {
 594             setConstant(node, child);
 595             break;
 596         }
 597 
<a name="15" id="anc15"></a><span class="line-modified"> 598         setNonCellTypeForNode(node, SpecAnyInt);</span>

 599         break;
 600     }
 601 
 602     case ValueRep: {
 603         JSValue value = forNode(node-&gt;child1()).value();
 604         if (value) {
 605             setConstant(node, value);
 606             break;
 607         }
 608 
 609         setTypeForNode(node, forNode(node-&gt;child1()).m_type &amp; ~SpecDoubleImpureNaN);
 610         forNode(node).fixTypeForRepresentation(m_graph, node);
 611         break;
 612     }
 613 
 614     case ValueSub:
 615     case ValueAdd: {
 616         DFG_ASSERT(m_graph, node, node-&gt;binaryUseKind() == UntypedUse || node-&gt;binaryUseKind() == BigIntUse);
 617         if (node-&gt;binaryUseKind() == BigIntUse)
 618             setTypeForNode(node, SpecBigInt);
 619         else {
 620             clobberWorld();
 621             setTypeForNode(node, SpecString | SpecBytecodeNumber | SpecBigInt);
 622         }
 623         break;
 624     }
 625 
 626     case StrCat: {
 627         setTypeForNode(node, SpecString);
 628         break;
 629     }
 630 
 631     case ArithAdd: {
 632         JSValue left = forNode(node-&gt;child1()).value();
 633         JSValue right = forNode(node-&gt;child2()).value();
 634         switch (node-&gt;binaryUseKind()) {
 635         case Int32Use:
 636             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 637                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 638                     setConstant(node, jsNumber(left.asInt32() + right.asInt32()));
 639                     break;
 640                 }
 641                 JSValue result = jsNumber(left.asNumber() + right.asNumber());
 642                 if (result.isInt32()) {
 643                     setConstant(node, result);
 644                     break;
 645                 }
 646             }
 647             setNonCellTypeForNode(node, SpecInt32Only);
 648             break;
 649         case Int52RepUse:
 650             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 651                 JSValue result = jsNumber(left.asAnyInt() + right.asAnyInt());
 652                 if (result.isAnyInt()) {
 653                     setConstant(node, result);
 654                     break;
 655                 }
 656             }
<a name="16" id="anc16"></a><span class="line-modified"> 657             setNonCellTypeForNode(node, SpecAnyInt);</span>
 658             break;
 659         case DoubleRepUse:
 660             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 661                 setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
 662                 break;
 663             }
 664             setNonCellTypeForNode(node,
 665                 typeOfDoubleSum(
 666                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 667             break;
 668         default:
 669             RELEASE_ASSERT_NOT_REACHED();
 670             break;
 671         }
 672         break;
 673     }
 674 
 675     case AtomicsIsLockFree: {
 676         if (node-&gt;child1().useKind() != Int32Use)
 677             clobberWorld();
 678         setNonCellTypeForNode(node, SpecBoolInt32);
 679         break;
 680     }
 681 
 682     case ArithClz32: {
 683         JSValue operand = forNode(node-&gt;child1()).value();
 684         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
 685             switch (node-&gt;child1().useKind()) {
 686             case Int32Use:
 687             case KnownInt32Use:
 688                 break;
 689             default:
 690                 didFoldClobberWorld();
 691                 break;
 692             }
 693             uint32_t value = toUInt32(*number);
<a name="17" id="anc17"></a><span class="line-modified"> 694             setConstant(node, jsNumber(clz32(value)));</span>
 695             break;
 696         }
 697         switch (node-&gt;child1().useKind()) {
 698         case Int32Use:
 699         case KnownInt32Use:
 700             break;
 701         default:
 702             clobberWorld();
 703             break;
 704         }
 705         setNonCellTypeForNode(node, SpecInt32Only);
 706         break;
 707     }
 708 
 709     case MakeRope: {
<a name="18" id="anc18"></a><span class="line-removed"> 710         unsigned numberOfChildren = 0;</span>
 711         unsigned numberOfRemovedChildren = 0;
<a name="19" id="anc19"></a><span class="line-removed"> 712         Optional&lt;unsigned&gt; nonEmptyIndex;</span>
 713         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 714             Edge&amp; edge = node-&gt;children.child(i);
 715             if (!edge)
 716                 break;
<a name="20" id="anc20"></a><span class="line-removed"> 717             ++numberOfChildren;</span>
<span class="line-removed"> 718 </span>
 719             JSValue childConstant = m_state.forNode(edge).value();
<a name="21" id="anc21"></a><span class="line-modified"> 720             if (!childConstant) {</span>
<span class="line-removed"> 721                 nonEmptyIndex = i;</span>
 722                 continue;
<a name="22" id="anc22"></a><span class="line-modified"> 723             }</span>
<span class="line-removed"> 724             if (!childConstant.isString()) {</span>
<span class="line-removed"> 725                 nonEmptyIndex = i;</span>
 726                 continue;
<a name="23" id="anc23"></a><span class="line-modified"> 727             }</span>
<span class="line-removed"> 728             if (asString(childConstant)-&gt;length()) {</span>
<span class="line-removed"> 729                 nonEmptyIndex = i;</span>
 730                 continue;
<a name="24" id="anc24"></a><span class="line-removed"> 731             }</span>
<span class="line-removed"> 732 </span>
 733             ++numberOfRemovedChildren;
 734         }
 735 
<a name="25" id="anc25"></a><span class="line-modified"> 736         if (numberOfRemovedChildren) {</span>
 737             m_state.setFoundConstants(true);
<a name="26" id="anc26"></a><span class="line-removed"> 738             if (numberOfRemovedChildren == numberOfChildren) {</span>
<span class="line-removed"> 739                 // Propagate the last child. This is the way taken in the constant folding phase.</span>
<span class="line-removed"> 740                 setForNode(node, forNode(node-&gt;children.child(numberOfChildren - 1)));</span>
<span class="line-removed"> 741                 break;</span>
<span class="line-removed"> 742             }</span>
<span class="line-removed"> 743             if ((numberOfRemovedChildren + 1) == numberOfChildren) {</span>
<span class="line-removed"> 744                 ASSERT(nonEmptyIndex);</span>
<span class="line-removed"> 745                 setForNode(node, forNode(node-&gt;children.child(nonEmptyIndex.value())));</span>
<span class="line-removed"> 746                 break;</span>
<span class="line-removed"> 747             }</span>
<span class="line-removed"> 748         }</span>
 749         setForNode(node, m_vm.stringStructure.get());
 750         break;
 751     }
 752 
 753     case ArithSub: {
 754         JSValue left = forNode(node-&gt;child1()).value();
 755         JSValue right = forNode(node-&gt;child2()).value();
 756         switch (node-&gt;binaryUseKind()) {
 757         case Int32Use:
 758             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 759                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 760                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 761                     break;
 762                 }
 763                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 764                 if (result.isInt32()) {
 765                     setConstant(node, result);
 766                     break;
 767                 }
 768             }
 769             setNonCellTypeForNode(node, SpecInt32Only);
 770             break;
 771         case Int52RepUse:
 772             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 773                 JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
<a name="27" id="anc27"></a><span class="line-modified"> 774                 if (result.isAnyInt() || !shouldCheckOverflow(node-&gt;arithMode())) {</span>
 775                     setConstant(node, result);
 776                     break;
 777                 }
 778             }
<a name="28" id="anc28"></a><span class="line-modified"> 779             setNonCellTypeForNode(node, SpecAnyInt);</span>
 780             break;
 781         case DoubleRepUse:
 782             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 783                 setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
 784                 break;
 785             }
 786             setNonCellTypeForNode(node,
 787                 typeOfDoubleDifference(
 788                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 789             break;
 790         case UntypedUse:
 791             clobberWorld();
 792             setNonCellTypeForNode(node, SpecBytecodeNumber);
 793             break;
 794         default:
 795             RELEASE_ASSERT_NOT_REACHED();
 796             break;
 797         }
 798         break;
 799     }
 800 
 801     case ValueNegate: {
 802         clobberWorld();
 803         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 804         break;
 805     }
 806 
 807     case ArithNegate: {
 808         JSValue child = forNode(node-&gt;child1()).value();
 809         switch (node-&gt;child1().useKind()) {
 810         case Int32Use:
 811             if (child &amp;&amp; child.isInt32()) {
 812                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 813                     setConstant(node, jsNumber(-child.asInt32()));
 814                     break;
 815                 }
 816                 double doubleResult;
 817                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 818                     doubleResult = -child.asNumber();
 819                 else
 820                     doubleResult = 0 - child.asNumber();
 821                 JSValue valueResult = jsNumber(doubleResult);
 822                 if (valueResult.isInt32()) {
 823                     setConstant(node, valueResult);
 824                     break;
 825                 }
 826             }
 827             setNonCellTypeForNode(node, SpecInt32Only);
 828             break;
 829         case Int52RepUse:
 830             if (child &amp;&amp; child.isAnyInt()) {
 831                 double doubleResult;
 832                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 833                     doubleResult = -child.asNumber();
 834                 else
 835                     doubleResult = 0 - child.asNumber();
 836                 JSValue valueResult = jsNumber(doubleResult);
 837                 if (valueResult.isAnyInt()) {
 838                     setConstant(node, valueResult);
 839                     break;
 840                 }
 841             }
<a name="29" id="anc29"></a><span class="line-modified"> 842             setNonCellTypeForNode(node, SpecAnyInt);</span>
 843             break;
 844         case DoubleRepUse:
 845             if (child &amp;&amp; child.isNumber()) {
 846                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 847                 break;
 848             }
 849             setNonCellTypeForNode(node,
 850                 typeOfDoubleNegation(
 851                     forNode(node-&gt;child1()).m_type));
 852             break;
 853         default:
 854             RELEASE_ASSERT_NOT_REACHED();
 855             break;
 856         }
 857         break;
 858     }
 859 
<a name="30" id="anc30"></a>




















 860     case ValueMul: {
 861         if (node-&gt;binaryUseKind() == BigIntUse)
 862             setTypeForNode(node, SpecBigInt);
 863         else {
 864             clobberWorld();
 865             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 866         }
 867         break;
 868     }
 869 
 870     case ArithMul: {
 871         JSValue left = forNode(node-&gt;child1()).value();
 872         JSValue right = forNode(node-&gt;child2()).value();
 873         switch (node-&gt;binaryUseKind()) {
 874         case Int32Use:
 875             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 876                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 877                     setConstant(node, jsNumber(left.asInt32() * right.asInt32()));
 878                     break;
 879                 }
 880                 double doubleResult = left.asNumber() * right.asNumber();
 881                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 882                     doubleResult += 0; // Sanitizes zero.
 883                 JSValue valueResult = jsNumber(doubleResult);
 884                 if (valueResult.isInt32()) {
 885                     setConstant(node, valueResult);
 886                     break;
 887                 }
 888             }
 889             setNonCellTypeForNode(node, SpecInt32Only);
 890             break;
 891         case Int52RepUse:
 892             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 893                 double doubleResult = left.asNumber() * right.asNumber();
 894                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 895                     doubleResult += 0;
 896                 JSValue valueResult = jsNumber(doubleResult);
 897                 if (valueResult.isAnyInt()) {
 898                     setConstant(node, valueResult);
 899                     break;
 900                 }
 901             }
<a name="31" id="anc31"></a><span class="line-modified"> 902             setNonCellTypeForNode(node, SpecAnyInt);</span>
 903             break;
 904         case DoubleRepUse:
 905             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 906                 setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
 907                 break;
 908             }
 909             setNonCellTypeForNode(node,
 910                 typeOfDoubleProduct(
 911                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 912             break;
 913         default:
 914             RELEASE_ASSERT_NOT_REACHED();
 915             break;
 916         }
 917         break;
 918     }
 919 
<a name="32" id="anc32"></a>
 920     case ValueDiv: {
<a name="33" id="anc33"></a>


 921         if (node-&gt;binaryUseKind() == BigIntUse)
 922             setTypeForNode(node, SpecBigInt);
 923         else {
 924             clobberWorld();
 925             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 926         }
 927         break;
 928     }
 929 
<a name="34" id="anc34"></a>
 930     case ArithDiv: {
<a name="35" id="anc35"></a><span class="line-modified"> 931         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 932         JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-removed"> 933         switch (node-&gt;binaryUseKind()) {</span>
<span class="line-removed"> 934         case Int32Use:</span>
<span class="line-removed"> 935             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 936                 double doubleResult = left.asNumber() / right.asNumber();</span>
<span class="line-removed"> 937                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-removed"> 938                     doubleResult = toInt32(doubleResult);</span>
<span class="line-removed"> 939                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-removed"> 940                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-removed"> 941                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-removed"> 942                 if (valueResult.isInt32()) {</span>
<span class="line-removed"> 943                     setConstant(node, valueResult);</span>
<span class="line-removed"> 944                     break;</span>
<span class="line-removed"> 945                 }</span>
<span class="line-removed"> 946             }</span>
<span class="line-removed"> 947             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="line-removed"> 948             break;</span>
<span class="line-removed"> 949         case DoubleRepUse:</span>
<span class="line-removed"> 950             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-removed"> 951                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-removed"> 952                 break;</span>
<span class="line-removed"> 953             }</span>
<span class="line-removed"> 954             setNonCellTypeForNode(node,</span>
<span class="line-removed"> 955                 typeOfDoubleQuotient(</span>
<span class="line-removed"> 956                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="line-removed"> 957             break;</span>
<span class="line-removed"> 958         default:</span>
<span class="line-removed"> 959             RELEASE_ASSERT_NOT_REACHED();</span>
 960             break;
<a name="36" id="anc36"></a><span class="line-removed"> 961         }</span>
<span class="line-removed"> 962         break;</span>
<span class="line-removed"> 963     }</span>
 964 
<a name="37" id="anc37"></a><span class="line-removed"> 965     case ArithMod: {</span>
<span class="line-removed"> 966         JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-removed"> 967         JSValue right = forNode(node-&gt;child2()).value();</span>
 968         switch (node-&gt;binaryUseKind()) {
 969         case Int32Use:
<a name="38" id="anc38"></a><span class="line-removed"> 970             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-removed"> 971                 double doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="line-removed"> 972                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-removed"> 973                     doubleResult = toInt32(doubleResult);</span>
<span class="line-removed"> 974                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-removed"> 975                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-removed"> 976                 JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-removed"> 977                 if (valueResult.isInt32()) {</span>
<span class="line-removed"> 978                     setConstant(node, valueResult);</span>
<span class="line-removed"> 979                     break;</span>
<span class="line-removed"> 980                 }</span>
<span class="line-removed"> 981             }</span>
 982             setNonCellTypeForNode(node, SpecInt32Only);
 983             break;
 984         case DoubleRepUse:
<a name="39" id="anc39"></a><span class="line-modified"> 985             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-modified"> 986                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-modified"> 987                 break;</span>





 988             }
<a name="40" id="anc40"></a><span class="line-modified"> 989             setNonCellTypeForNode(node,</span>
<span class="line-removed"> 990                 typeOfDoubleBinaryOp(</span>
<span class="line-removed"> 991                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
 992             break;
 993         default:
 994             RELEASE_ASSERT_NOT_REACHED();
 995             break;
 996         }
 997         break;
 998     }
 999 
1000     case ArithMin: {
1001         JSValue left = forNode(node-&gt;child1()).value();
1002         JSValue right = forNode(node-&gt;child2()).value();
1003         switch (node-&gt;binaryUseKind()) {
1004         case Int32Use:
1005             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1006                 setConstant(node, jsNumber(std::min(left.asInt32(), right.asInt32())));
1007                 break;
1008             }
1009             setNonCellTypeForNode(node, SpecInt32Only);
1010             break;
1011         case DoubleRepUse:
1012             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1013                 double a = left.asNumber();
1014                 double b = right.asNumber();
1015                 setConstant(node, jsDoubleNumber(a &lt; b ? a : (b &lt;= a ? b : a + b)));
1016                 break;
1017             }
1018             setNonCellTypeForNode(node,
1019                 typeOfDoubleMinMax(
1020                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1021             break;
1022         default:
1023             RELEASE_ASSERT_NOT_REACHED();
1024             break;
1025         }
1026         break;
1027     }
1028 
1029     case ArithMax: {
1030         JSValue left = forNode(node-&gt;child1()).value();
1031         JSValue right = forNode(node-&gt;child2()).value();
1032         switch (node-&gt;binaryUseKind()) {
1033         case Int32Use:
1034             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1035                 setConstant(node, jsNumber(std::max(left.asInt32(), right.asInt32())));
1036                 break;
1037             }
1038             setNonCellTypeForNode(node, SpecInt32Only);
1039             break;
1040         case DoubleRepUse:
1041             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1042                 double a = left.asNumber();
1043                 double b = right.asNumber();
1044                 setConstant(node, jsDoubleNumber(a &gt; b ? a : (b &gt;= a ? b : a + b)));
1045                 break;
1046             }
1047             setNonCellTypeForNode(node,
1048                 typeOfDoubleMinMax(
1049                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1050             break;
1051         default:
1052             RELEASE_ASSERT_NOT_REACHED();
1053             break;
1054         }
1055         break;
1056     }
1057 
1058     case ArithAbs: {
1059         JSValue child = forNode(node-&gt;child1()).value();
1060         switch (node-&gt;child1().useKind()) {
1061         case Int32Use:
1062             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1063                 JSValue result = jsNumber(fabs(*number));
1064                 if (result.isInt32()) {
1065                     setConstant(node, result);
1066                     break;
1067                 }
1068             }
1069             setNonCellTypeForNode(node, SpecInt32Only);
1070             break;
1071         case DoubleRepUse:
1072             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1073                 setConstant(node, jsDoubleNumber(fabs(*number)));
1074                 break;
1075             }
1076             setNonCellTypeForNode(node, typeOfDoubleAbs(forNode(node-&gt;child1()).m_type));
1077             break;
1078         default:
1079             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1080             clobberWorld();
1081             setNonCellTypeForNode(node, SpecBytecodeNumber);
1082             break;
1083         }
1084         break;
1085     }
1086 
1087     case ArithPow: {
1088         JSValue childY = forNode(node-&gt;child2()).value();
1089         if (childY &amp;&amp; childY.isNumber()) {
1090             if (!childY.asNumber()) {
1091                 setConstant(node, jsDoubleNumber(1));
1092                 break;
1093             }
1094 
1095             JSValue childX = forNode(node-&gt;child1()).value();
1096             if (childX &amp;&amp; childX.isNumber()) {
1097                 setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
1098                 break;
1099             }
1100         }
1101         setNonCellTypeForNode(node, typeOfDoublePow(forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1102         break;
1103     }
1104 
1105     case ArithRandom: {
1106         setNonCellTypeForNode(node, SpecDoubleReal);
1107         break;
1108     }
1109 
1110     case ArithRound:
1111     case ArithFloor:
1112     case ArithCeil:
1113     case ArithTrunc: {
1114         JSValue operand = forNode(node-&gt;child1()).value();
1115         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
1116             if (node-&gt;child1().useKind() != DoubleRepUse)
1117                 didFoldClobberWorld();
1118 
1119             double roundedValue = 0;
1120             if (node-&gt;op() == ArithRound)
1121                 roundedValue = jsRound(*number);
1122             else if (node-&gt;op() == ArithFloor)
1123                 roundedValue = floor(*number);
1124             else if (node-&gt;op() == ArithCeil)
1125                 roundedValue = ceil(*number);
1126             else {
1127                 ASSERT(node-&gt;op() == ArithTrunc);
1128                 roundedValue = trunc(*number);
1129             }
1130 
1131             if (node-&gt;child1().useKind() == UntypedUse) {
1132                 setConstant(node, jsNumber(roundedValue));
1133                 break;
1134             }
1135             if (producesInteger(node-&gt;arithRoundingMode())) {
1136                 int32_t roundedValueAsInt32 = static_cast&lt;int32_t&gt;(roundedValue);
1137                 if (roundedValueAsInt32 == roundedValue) {
1138                     if (shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
1139                         if (roundedValueAsInt32 || !std::signbit(roundedValue)) {
1140                             setConstant(node, jsNumber(roundedValueAsInt32));
1141                             break;
1142                         }
1143                     } else {
1144                         setConstant(node, jsNumber(roundedValueAsInt32));
1145                         break;
1146                     }
1147                 }
1148             } else {
1149                 setConstant(node, jsDoubleNumber(roundedValue));
1150                 break;
1151             }
1152         }
1153         if (node-&gt;child1().useKind() == DoubleRepUse) {
1154             if (producesInteger(node-&gt;arithRoundingMode()))
1155                 setNonCellTypeForNode(node, SpecInt32Only);
1156             else if (node-&gt;child1().useKind() == DoubleRepUse)
1157                 setNonCellTypeForNode(node, typeOfDoubleRounding(forNode(node-&gt;child1()).m_type));
1158         } else {
1159             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1160             clobberWorld();
1161             setNonCellTypeForNode(node, SpecBytecodeNumber);
1162         }
1163         break;
1164     }
1165 
1166     case ArithSqrt:
1167         executeDoubleUnaryOpEffects(node, sqrt);
1168         break;
1169 
1170     case ArithFRound:
1171         executeDoubleUnaryOpEffects(node, [](double value) -&gt; double { return static_cast&lt;float&gt;(value); });
1172         break;
1173 
1174     case ArithUnary:
1175         executeDoubleUnaryOpEffects(node, arithUnaryFunction(node-&gt;arithUnaryType()));
1176         break;
1177 
1178     case LogicalNot: {
1179         switch (booleanResult(node, forNode(node-&gt;child1()))) {
1180         case DefinitelyTrue:
1181             setConstant(node, jsBoolean(false));
1182             break;
1183         case DefinitelyFalse:
1184             setConstant(node, jsBoolean(true));
1185             break;
1186         default:
1187             setNonCellTypeForNode(node, SpecBoolean);
1188             break;
1189         }
1190         break;
1191     }
1192 
1193     case MapHash: {
1194         if (JSValue key = forNode(node-&gt;child1()).value()) {
1195             if (Optional&lt;uint32_t&gt; hash = concurrentJSMapHash(key)) {
1196                 // Although C++ code uses uint32_t for the hash, the closest type in DFG IR is Int32
1197                 // and that&#39;s what MapHash returns. So, we have to cast to int32_t to avoid large
1198                 // unsigned values becoming doubles. This casting between signed and unsigned
1199                 // happens in the assembly code we emit when we don&#39;t constant fold this node.
1200                 setConstant(node, jsNumber(static_cast&lt;int32_t&gt;(*hash)));
1201                 break;
1202             }
1203         }
1204         setNonCellTypeForNode(node, SpecInt32Only);
1205         break;
1206     }
1207 
1208     case NormalizeMapKey: {
1209         if (JSValue key = forNode(node-&gt;child1()).value()) {
1210             setConstant(node, *m_graph.freeze(normalizeMapKey(key)));
1211             break;
1212         }
1213 
1214         SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
1215         if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
1216             m_state.setFoundConstants(true);
1217             forNode(node) = forNode(node-&gt;child1());
1218             break;
1219         }
1220 
1221         makeHeapTopForNode(node);
1222         break;
1223     }
1224 
1225     case StringValueOf: {
1226         clobberWorld();
1227         setTypeForNode(node, SpecString);
1228         break;
1229     }
1230 
1231     case StringSlice: {
1232         setTypeForNode(node, SpecString);
1233         break;
1234     }
1235 
1236     case ToLowerCase: {
1237         setTypeForNode(node, SpecString);
1238         break;
1239     }
1240 
1241     case LoadKeyFromMapBucket:
1242     case LoadValueFromMapBucket:
1243     case ExtractValueFromWeakMapGet:
1244         makeHeapTopForNode(node);
1245         break;
1246 
1247     case GetMapBucket:
1248     case GetMapBucketHead:
1249         if (node-&gt;child1().useKind() == MapObjectUse)
1250             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1251         else {
1252             ASSERT(node-&gt;child1().useKind() == SetObjectUse);
1253             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1254         }
1255         break;
1256 
1257     case GetMapBucketNext:
1258         if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
1259             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1260         else {
1261             ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
1262             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1263         }
1264         break;
1265 
1266     case SetAdd:
1267         setForNode(node, m_vm.hashMapBucketSetStructure.get());
1268         break;
1269 
1270     case MapSet:
1271         setForNode(node, m_vm.hashMapBucketMapStructure.get());
1272         break;
1273 
1274     case WeakSetAdd:
1275     case WeakMapSet:
1276         break;
1277 
1278     case WeakMapGet:
1279         makeBytecodeTopForNode(node);
1280         break;
1281 
1282     case IsEmpty:
1283     case IsUndefined:
1284     case IsUndefinedOrNull:
1285     case IsBoolean:
1286     case IsNumber:
1287     case NumberIsInteger:
1288     case IsObject:
1289     case IsObjectOrNull:
1290     case IsFunction:
1291     case IsCellWithType:
1292     case IsTypedArrayView: {
1293         AbstractValue child = forNode(node-&gt;child1());
1294         if (child.value()) {
1295             bool constantWasSet = true;
1296             switch (node-&gt;op()) {
1297             case IsCellWithType:
1298                 setConstant(node, jsBoolean(child.value().isCell() &amp;&amp; child.value().asCell()-&gt;type() == node-&gt;queriedType()));
1299                 break;
1300             case IsUndefined:
1301                 setConstant(node, jsBoolean(
1302                     child.value().isCell()
1303                     ? child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
1304                     : child.value().isUndefined()));
1305                 break;
1306             case IsUndefinedOrNull:
1307                 setConstant(node, jsBoolean(child.value().isUndefinedOrNull()));
1308                 break;
1309             case IsBoolean:
1310                 setConstant(node, jsBoolean(child.value().isBoolean()));
1311                 break;
1312             case IsNumber:
1313                 setConstant(node, jsBoolean(child.value().isNumber()));
1314                 break;
1315             case NumberIsInteger:
1316                 setConstant(node, jsBoolean(NumberConstructor::isIntegerImpl(child.value())));
1317                 break;
1318             case IsObject:
1319                 setConstant(node, jsBoolean(child.value().isObject()));
1320                 break;
1321             case IsObjectOrNull:
1322                 if (child.value().isObject()) {
1323                     JSObject* object = asObject(child.value());
1324                     if (object-&gt;type() == JSFunctionType)
1325                         setConstant(node, jsBoolean(false));
1326                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1327                         setConstant(node, jsBoolean(!child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))));
1328                     else {
1329                         // FIXME: This could just call getCallData.
1330                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1331                         constantWasSet = false;
1332                     }
1333                 } else
1334                     setConstant(node, jsBoolean(child.value().isNull()));
1335                 break;
1336             case IsFunction:
1337                 if (child.value().isObject()) {
1338                     JSObject* object = asObject(child.value());
1339                     if (object-&gt;type() == JSFunctionType)
1340                         setConstant(node, jsBoolean(true));
1341                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1342                         setConstant(node, jsBoolean(false));
1343                     else {
1344                         // FIXME: This could just call getCallData.
1345                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1346                         constantWasSet = false;
1347                     }
1348                 } else
1349                     setConstant(node, jsBoolean(false));
1350                 break;
1351             case IsEmpty:
1352                 setConstant(node, jsBoolean(child.value().isEmpty()));
1353                 break;
1354             case IsTypedArrayView:
1355                 setConstant(node, jsBoolean(child.value().isObject() &amp;&amp; isTypedView(child.value().getObject()-&gt;classInfo(m_vm)-&gt;typedArrayStorageType)));
1356                 break;
1357             default:
1358                 constantWasSet = false;
1359                 break;
1360             }
1361             if (constantWasSet)
1362                 break;
1363         }
1364 
1365         // FIXME: This code should really use AbstractValue::isType() and
1366         // AbstractValue::couldBeType().
1367         // https://bugs.webkit.org/show_bug.cgi?id=146870
1368 
1369         bool constantWasSet = false;
1370         switch (node-&gt;op()) {
1371         case IsEmpty: {
1372             if (child.m_type &amp;&amp; !(child.m_type &amp; SpecEmpty)) {
1373                 setConstant(node, jsBoolean(false));
1374                 constantWasSet = true;
1375                 break;
1376             }
1377 
1378             if (child.m_type &amp;&amp; !(child.m_type &amp; ~SpecEmpty)) {
1379                 setConstant(node, jsBoolean(true));
1380                 constantWasSet = true;
1381                 break;
1382             }
1383 
1384             break;
1385         }
1386         case IsUndefined:
1387             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1388             // https://bugs.webkit.org/show_bug.cgi?id=144456
1389 
1390             if (!(child.m_type &amp; (SpecOther | SpecObjectOther))) {
1391                 setConstant(node, jsBoolean(false));
1392                 constantWasSet = true;
1393                 break;
1394             }
1395 
1396             break;
1397         case IsUndefinedOrNull:
1398             if (!(child.m_type &amp; ~SpecOther)) {
1399                 setConstant(node, jsBoolean(true));
1400                 constantWasSet = true;
1401                 break;
1402             }
1403 
1404             if (!(child.m_type &amp; SpecOther)) {
1405                 setConstant(node, jsBoolean(false));
1406                 constantWasSet = true;
1407                 break;
1408             }
1409             break;
1410         case IsBoolean:
1411             if (!(child.m_type &amp; ~SpecBoolean)) {
1412                 setConstant(node, jsBoolean(true));
1413                 constantWasSet = true;
1414                 break;
1415             }
1416 
1417             if (!(child.m_type &amp; SpecBoolean)) {
1418                 setConstant(node, jsBoolean(false));
1419                 constantWasSet = true;
1420                 break;
1421             }
1422 
1423             break;
1424         case IsNumber:
1425             if (!(child.m_type &amp; ~SpecFullNumber)) {
1426                 setConstant(node, jsBoolean(true));
1427                 constantWasSet = true;
1428                 break;
1429             }
1430 
1431             if (!(child.m_type &amp; SpecFullNumber)) {
1432                 setConstant(node, jsBoolean(false));
1433                 constantWasSet = true;
1434                 break;
1435             }
1436 
1437             break;
1438 
1439         case NumberIsInteger:
1440             if (!(child.m_type &amp; ~SpecInt32Only)) {
1441                 setConstant(node, jsBoolean(true));
1442                 constantWasSet = true;
1443                 break;
1444             }
1445 
1446             if (!(child.m_type &amp; SpecFullNumber)) {
1447                 setConstant(node, jsBoolean(false));
1448                 constantWasSet = true;
1449                 break;
1450             }
1451 
1452             break;
1453 
1454         case IsObject:
1455             if (!(child.m_type &amp; ~SpecObject)) {
1456                 setConstant(node, jsBoolean(true));
1457                 constantWasSet = true;
1458                 break;
1459             }
1460 
1461             if (!(child.m_type &amp; SpecObject)) {
1462                 setConstant(node, jsBoolean(false));
1463                 constantWasSet = true;
1464                 break;
1465             }
1466 
1467             break;
1468         case IsObjectOrNull:
1469             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1470             // https://bugs.webkit.org/show_bug.cgi?id=144456
1471 
1472             // These expressions are complicated to parse. A helpful way to parse this is that
1473             // &quot;!(T &amp; ~S)&quot; means &quot;T is a subset of S&quot;. Conversely, &quot;!(T &amp; S)&quot; means &quot;T is a
1474             // disjoint set from S&quot;. Things like &quot;T - S&quot; means that, provided that S is a
1475             // subset of T, it&#39;s the &quot;set of all things in T but not in S&quot;. Things like &quot;T | S&quot;
1476             // mean the &quot;union of T and S&quot;.
1477 
1478             // Is the child&#39;s type an object that isn&#39;t an other-object (i.e. object that could
1479             // have masquaredes-as-undefined traps) and isn&#39;t a function?  Then: we should fold
1480             // this to true.
1481             if (!(child.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1482                 setConstant(node, jsBoolean(true));
1483                 constantWasSet = true;
1484                 break;
1485             }
1486 
1487             // Is the child&#39;s type definitely not either of: an object that isn&#39;t a function,
1488             // or either undefined or null?  Then: we should fold this to false.  This means
1489             // for example that if it&#39;s any non-function object, including those that have
1490             // masquerades-as-undefined traps, then we don&#39;t fold. It also means we won&#39;t fold
1491             // if it&#39;s undefined-or-null, since the type bits don&#39;t distinguish between
1492             // undefined (which should fold to false) and null (which should fold to true).
1493             if (!(child.m_type &amp; ((SpecObject - SpecFunction) | SpecOther))) {
1494                 setConstant(node, jsBoolean(false));
1495                 constantWasSet = true;
1496                 break;
1497             }
1498 
1499             break;
1500         case IsFunction:
1501             if (!(child.m_type &amp; ~SpecFunction)) {
1502                 setConstant(node, jsBoolean(true));
1503                 constantWasSet = true;
1504                 break;
1505             }
1506 
1507             if (!(child.m_type &amp; (SpecFunction | SpecObjectOther | SpecProxyObject))) {
1508                 setConstant(node, jsBoolean(false));
1509                 constantWasSet = true;
1510                 break;
1511             }
1512             break;
1513 
1514         case IsCellWithType:
1515             if (!(child.m_type &amp; ~node-&gt;speculatedTypeForQuery())) {
1516                 setConstant(node, jsBoolean(true));
1517                 constantWasSet = true;
1518                 break;
1519             }
1520             if (!(child.m_type &amp; node-&gt;speculatedTypeForQuery())) {
1521                 setConstant(node, jsBoolean(false));
1522                 constantWasSet = true;
1523                 break;
1524             }
1525             break;
1526 
1527         case IsTypedArrayView:
1528             if (!(child.m_type &amp; ~SpecTypedArrayView)) {
1529                 setConstant(node, jsBoolean(true));
1530                 constantWasSet = true;
1531                 break;
1532             }
1533             if (!(child.m_type &amp; SpecTypedArrayView)) {
1534                 setConstant(node, jsBoolean(false));
1535                 constantWasSet = true;
1536                 break;
1537             }
1538             break;
1539 
1540         default:
1541             break;
1542         }
1543         if (constantWasSet)
1544             break;
1545 
1546         setNonCellTypeForNode(node, SpecBoolean);
1547         break;
1548     }
1549 
1550     case TypeOf: {
1551         JSValue child = forNode(node-&gt;child1()).value();
1552         AbstractValue&amp; abstractChild = forNode(node-&gt;child1());
1553         if (child) {
1554             JSValue typeString = jsTypeStringForValue(m_vm, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic), child);
1555             setConstant(node, *m_graph.freeze(typeString));
1556             break;
1557         }
1558 
1559         if (isFullNumberSpeculation(abstractChild.m_type)) {
1560             setConstant(node, *m_graph.freeze(m_vm.smallStrings.numberString()));
1561             break;
1562         }
1563 
1564         if (isStringSpeculation(abstractChild.m_type)) {
1565             setConstant(node, *m_graph.freeze(m_vm.smallStrings.stringString()));
1566             break;
1567         }
1568 
1569         // FIXME: We could use the masquerades-as-undefined watchpoint here.
1570         // https://bugs.webkit.org/show_bug.cgi?id=144456
1571         if (!(abstractChild.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1572             setConstant(node, *m_graph.freeze(m_vm.smallStrings.objectString()));
1573             break;
1574         }
1575 
1576         if (isFunctionSpeculation(abstractChild.m_type)) {
1577             setConstant(node, *m_graph.freeze(m_vm.smallStrings.functionString()));
1578             break;
1579         }
1580 
1581         if (isBooleanSpeculation(abstractChild.m_type)) {
1582             setConstant(node, *m_graph.freeze(m_vm.smallStrings.booleanString()));
1583             break;
1584         }
1585 
1586         if (isSymbolSpeculation(abstractChild.m_type)) {
1587             setConstant(node, *m_graph.freeze(m_vm.smallStrings.symbolString()));
1588             break;
1589         }
1590 
1591         if (isBigIntSpeculation(abstractChild.m_type)) {
1592             setConstant(node, *m_graph.freeze(m_vm.smallStrings.bigintString()));
1593             break;
1594         }
1595 
1596         setTypeForNode(node, SpecStringIdent);
1597         break;
1598     }
1599 
1600     case CompareBelow:
1601     case CompareBelowEq: {
1602         JSValue leftConst = forNode(node-&gt;child1()).value();
1603         JSValue rightConst = forNode(node-&gt;child2()).value();
1604         if (leftConst &amp;&amp; rightConst) {
1605             if (leftConst.isInt32() &amp;&amp; rightConst.isInt32()) {
1606                 uint32_t a = static_cast&lt;uint32_t&gt;(leftConst.asInt32());
1607                 uint32_t b = static_cast&lt;uint32_t&gt;(rightConst.asInt32());
1608                 switch (node-&gt;op()) {
1609                 case CompareBelow:
1610                     setConstant(node, jsBoolean(a &lt; b));
1611                     break;
1612                 case CompareBelowEq:
1613                     setConstant(node, jsBoolean(a &lt;= b));
1614                     break;
1615                 default:
1616                     RELEASE_ASSERT_NOT_REACHED();
1617                     break;
1618                 }
1619                 break;
1620             }
1621         }
1622 
1623         if (node-&gt;child1() == node-&gt;child2()) {
1624             switch (node-&gt;op()) {
1625             case CompareBelow:
1626                 setConstant(node, jsBoolean(false));
1627                 break;
1628             case CompareBelowEq:
1629                 setConstant(node, jsBoolean(true));
1630                 break;
1631             default:
1632                 DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1633                 break;
1634             }
1635             break;
1636         }
1637         setNonCellTypeForNode(node, SpecBoolean);
1638         break;
1639     }
1640 
1641     case CompareLess:
1642     case CompareLessEq:
1643     case CompareGreater:
1644     case CompareGreaterEq:
1645     case CompareEq: {
1646         bool isClobbering = node-&gt;isBinaryUseKind(UntypedUse);
1647 
1648         if (isClobbering)
1649             didFoldClobberWorld();
1650 
1651         JSValue leftConst = forNode(node-&gt;child1()).value();
1652         JSValue rightConst = forNode(node-&gt;child2()).value();
1653         if (leftConst &amp;&amp; rightConst) {
1654             if (leftConst.isNumber() &amp;&amp; rightConst.isNumber()) {
1655                 double a = leftConst.asNumber();
1656                 double b = rightConst.asNumber();
1657                 switch (node-&gt;op()) {
1658                 case CompareLess:
1659                     setConstant(node, jsBoolean(a &lt; b));
1660                     break;
1661                 case CompareLessEq:
1662                     setConstant(node, jsBoolean(a &lt;= b));
1663                     break;
1664                 case CompareGreater:
1665                     setConstant(node, jsBoolean(a &gt; b));
1666                     break;
1667                 case CompareGreaterEq:
1668                     setConstant(node, jsBoolean(a &gt;= b));
1669                     break;
1670                 case CompareEq:
1671                     setConstant(node, jsBoolean(a == b));
1672                     break;
1673                 default:
1674                     RELEASE_ASSERT_NOT_REACHED();
1675                     break;
1676                 }
1677                 break;
1678             }
1679 
1680             if (leftConst.isString() &amp;&amp; rightConst.isString()) {
1681                 const StringImpl* a = asString(leftConst)-&gt;tryGetValueImpl();
1682                 const StringImpl* b = asString(rightConst)-&gt;tryGetValueImpl();
1683                 if (a &amp;&amp; b) {
1684                     bool result;
1685                     if (node-&gt;op() == CompareEq)
1686                         result = WTF::equal(a, b);
1687                     else if (node-&gt;op() == CompareLess)
1688                         result = codePointCompare(a, b) &lt; 0;
1689                     else if (node-&gt;op() == CompareLessEq)
1690                         result = codePointCompare(a, b) &lt;= 0;
1691                     else if (node-&gt;op() == CompareGreater)
1692                         result = codePointCompare(a, b) &gt; 0;
1693                     else if (node-&gt;op() == CompareGreaterEq)
1694                         result = codePointCompare(a, b) &gt;= 0;
1695                     else
1696                         RELEASE_ASSERT_NOT_REACHED();
1697                     setConstant(node, jsBoolean(result));
1698                     break;
1699                 }
1700             }
1701 
1702             if (node-&gt;op() == CompareEq &amp;&amp; leftConst.isSymbol() &amp;&amp; rightConst.isSymbol()) {
1703                 setConstant(node, jsBoolean(asSymbol(leftConst) == asSymbol(rightConst)));
1704                 break;
1705             }
1706         }
1707 
1708         if (node-&gt;op() == CompareEq) {
1709             SpeculatedType leftType = forNode(node-&gt;child1()).m_type;
1710             SpeculatedType rightType = forNode(node-&gt;child2()).m_type;
1711             if (!valuesCouldBeEqual(leftType, rightType)) {
1712                 setConstant(node, jsBoolean(false));
1713                 break;
1714             }
1715 
1716             if (leftType == SpecOther)
1717                 std::swap(leftType, rightType);
1718             if (rightType == SpecOther) {
1719                 // Undefined and Null are always equal when compared to eachother.
1720                 if (!(leftType &amp; ~SpecOther)) {
1721                     setConstant(node, jsBoolean(true));
1722                     break;
1723                 }
1724 
1725                 // Any other type compared to Null or Undefined is always false
1726                 // as long as the MasqueradesAsUndefined watchpoint is valid.
1727                 //
1728                 // MasqueradesAsUndefined only matters for SpecObjectOther, other
1729                 // cases are always &quot;false&quot;.
1730                 if (!(leftType &amp; (SpecObjectOther | SpecOther))) {
1731                     setConstant(node, jsBoolean(false));
1732                     break;
1733                 }
1734 
1735                 if (!(leftType &amp; SpecOther) &amp;&amp; m_graph.masqueradesAsUndefinedWatchpointIsStillValid(node-&gt;origin.semantic)) {
1736                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1737                     m_graph.watchpoints().addLazily(globalObject-&gt;masqueradesAsUndefinedWatchpoint());
1738                     setConstant(node, jsBoolean(false));
1739                     break;
1740                 }
1741             }
1742         }
1743 
1744         if (node-&gt;child1() == node-&gt;child2()) {
1745             if (node-&gt;isBinaryUseKind(Int32Use) ||
1746                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1747                 node-&gt;isBinaryUseKind(StringUse) ||
1748                 node-&gt;isBinaryUseKind(BooleanUse) ||
1749                 node-&gt;isBinaryUseKind(SymbolUse) ||
1750                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1751                 node-&gt;isBinaryUseKind(ObjectUse) ||
1752                 node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse) ||
1753                 node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
1754                 switch (node-&gt;op()) {
1755                 case CompareLess:
1756                 case CompareGreater:
1757                     setConstant(node, jsBoolean(false));
1758                     break;
1759                 case CompareLessEq:
1760                 case CompareGreaterEq:
1761                 case CompareEq:
1762                     setConstant(node, jsBoolean(true));
1763                     break;
1764                 default:
1765                     DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1766                     break;
1767                 }
1768                 break;
1769             }
1770         }
1771 
1772         if (isClobbering)
1773             clobberWorld();
1774         setNonCellTypeForNode(node, SpecBoolean);
1775         break;
1776     }
1777 
1778     case CompareStrictEq:
1779     case SameValue: {
1780         Node* leftNode = node-&gt;child1().node();
1781         Node* rightNode = node-&gt;child2().node();
1782         JSValue left = forNode(leftNode).value();
1783         JSValue right = forNode(rightNode).value();
1784         if (left &amp;&amp; right) {
1785             if (left.isString() &amp;&amp; right.isString()) {
1786                 // We need this case because JSValue::strictEqual is otherwise too racy for
1787                 // string comparisons.
1788                 const StringImpl* a = asString(left)-&gt;tryGetValueImpl();
1789                 const StringImpl* b = asString(right)-&gt;tryGetValueImpl();
1790                 if (a &amp;&amp; b) {
1791                     setConstant(node, jsBoolean(WTF::equal(a, b)));
1792                     break;
1793                 }
1794             } else {
1795                 if (node-&gt;op() == CompareStrictEq)
1796                     setConstant(node, jsBoolean(JSValue::strictEqual(nullptr, left, right)));
1797                 else
1798                     setConstant(node, jsBoolean(sameValue(nullptr, left, right)));
1799                 break;
1800             }
1801         }
1802 
1803         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1804             // FIXME: Revisit this condition when introducing BigInt to JSC.
1805             auto isNonStringCellConstant = [] (JSValue value) {
1806                 return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
1807             };
1808 
1809             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
1810                 m_state.setFoundConstants(true);
1811                 setNonCellTypeForNode(node, SpecBoolean);
1812                 break;
1813             }
1814         }
1815 
1816         SpeculatedType leftLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(leftNode).m_type);
1817         SpeculatedType rightLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(rightNode).m_type);
1818         if (!(leftLUB &amp; rightLUB)) {
1819             setConstant(node, jsBoolean(false));
1820             break;
1821         }
1822 
1823         if (node-&gt;child1() == node-&gt;child2()) {
1824             if (node-&gt;isBinaryUseKind(BooleanUse) ||
1825                 node-&gt;isBinaryUseKind(Int32Use) ||
1826                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1827                 node-&gt;isBinaryUseKind(StringUse) ||
1828                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1829                 node-&gt;isBinaryUseKind(SymbolUse) ||
1830                 node-&gt;isBinaryUseKind(ObjectUse) ||
1831                 node-&gt;isBinaryUseKind(MiscUse, UntypedUse) ||
1832                 node-&gt;isBinaryUseKind(UntypedUse, MiscUse) ||
1833                 node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse) ||
1834                 node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse) ||
1835                 node-&gt;isBinaryUseKind(StringUse, UntypedUse) ||
1836                 node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
1837                 setConstant(node, jsBoolean(true));
1838                 break;
1839             }
1840         }
1841 
1842         setNonCellTypeForNode(node, SpecBoolean);
1843         break;
1844     }
1845 
1846     case CompareEqPtr: {
1847         Node* childNode = node-&gt;child1().node();
1848         JSValue childValue = forNode(childNode).value();
1849         if (childValue) {
1850             setConstant(node, jsBoolean(childValue.isCell() &amp;&amp; childValue.asCell() == node-&gt;cellOperand()-&gt;cell()));
1851             break;
1852         }
1853 
1854         setNonCellTypeForNode(node, SpecBoolean);
1855         break;
1856     }
1857 
1858     case StringCharCodeAt:
1859         setNonCellTypeForNode(node, SpecInt32Only);
1860         break;
1861 
1862     case StringFromCharCode:
1863         switch (node-&gt;child1().useKind()) {
1864         case Int32Use:
1865             break;
1866         case UntypedUse:
1867             clobberWorld();
1868             break;
1869         default:
1870             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
1871             break;
1872         }
1873         setTypeForNode(node, SpecString);
1874         break;
1875 
1876     case StringCharAt:
1877         setForNode(node, m_vm.stringStructure.get());
1878         break;
1879 
1880     case GetByVal:
1881     case AtomicsAdd:
1882     case AtomicsAnd:
1883     case AtomicsCompareExchange:
1884     case AtomicsExchange:
1885     case AtomicsLoad:
1886     case AtomicsOr:
1887     case AtomicsStore:
1888     case AtomicsSub:
1889     case AtomicsXor: {
1890         if (node-&gt;op() == GetByVal) {
1891             auto foldGetByValOnConstantProperty = [&amp;] (Edge&amp; arrayEdge, Edge&amp; indexEdge) {
1892                 // FIXME: We can expand this for non x86 environments.
1893                 // https://bugs.webkit.org/show_bug.cgi?id=134641
1894                 if (!isX86())
1895                     return false;
1896 
1897                 AbstractValue&amp; arrayValue = forNode(arrayEdge);
1898 
1899                 // Check the structure set is finite. This means that this constant&#39;s structure is watched and guaranteed the one of this set.
1900                 // When the structure is changed, this code should be invalidated. This is important since the following code relies on the
1901                 // constant object&#39;s is not changed.
1902                 if (!arrayValue.m_structure.isFinite())
1903                     return false;
1904 
1905                 JSValue arrayConstant = arrayValue.value();
1906                 if (!arrayConstant)
1907                     return false;
1908 
1909                 JSObject* array = jsDynamicCast&lt;JSObject*&gt;(m_vm, arrayConstant);
1910                 if (!array)
1911                     return false;
1912 
1913                 JSValue indexConstant = forNode(indexEdge).value();
1914                 if (!indexConstant || !indexConstant.isInt32() || indexConstant.asInt32() &lt; 0)
1915                     return false;
1916                 uint32_t index = indexConstant.asUInt32();
1917 
1918                 // Check that the early StructureID is not nuked, get the butterfly, and check the late StructureID again.
1919                 // And we check the indexing mode of the structure. If the indexing mode is CoW, the butterfly is
1920                 // definitely JSImmutableButterfly.
1921                 StructureID structureIDEarly = array-&gt;structureID();
1922                 if (isNuked(structureIDEarly))
1923                     return false;
1924 
1925                 if (node-&gt;arrayMode().arrayClass() == Array::OriginalCopyOnWriteArray) {
1926 
1927                     WTF::loadLoadFence();
1928                     Butterfly* butterfly = array-&gt;butterfly();
1929 
1930                     WTF::loadLoadFence();
1931                     StructureID structureIDLate = array-&gt;structureID();
1932 
1933                     if (structureIDEarly != structureIDLate)
1934                         return false;
1935 
1936                     Structure* structure = m_vm.getStructure(structureIDLate);
1937                     switch (node-&gt;arrayMode().type()) {
1938                     case Array::Int32:
1939                     case Array::Contiguous:
1940                     case Array::Double:
1941                         if (structure-&gt;indexingMode() != (toIndexingShape(node-&gt;arrayMode().type()) | CopyOnWrite | IsArray))
1942                             return false;
1943                         break;
1944                     default:
1945                         return false;
1946                     }
1947                     ASSERT(isCopyOnWrite(structure-&gt;indexingMode()));
1948 
1949                     JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::fromButterfly(butterfly);
1950                     if (index &lt; immutableButterfly-&gt;length()) {
1951                         JSValue value = immutableButterfly-&gt;get(index);
1952                         ASSERT(value);
1953                         if (value.isCell())
1954                             setConstant(node, *m_graph.freeze(value.asCell()));
1955                         else
1956                             setConstant(node, value);
1957                         return true;
1958                     }
1959 
1960                     if (node-&gt;arrayMode().isOutOfBounds()) {
1961                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1962                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(m_vm);
1963                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_vm);
1964                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1965                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1966                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
1967                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
1968                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
1969                             // Note that Array::Double and Array::Int32 return JSValue if array mode is OutOfBounds.
1970                             setConstant(node, jsUndefined());
1971                             return true;
1972                         }
1973                     }
1974                     return false;
1975                 }
1976 
1977                 if (node-&gt;arrayMode().type() == Array::ArrayStorage || node-&gt;arrayMode().type() == Array::SlowPutArrayStorage) {
1978                     JSValue value;
1979                     {
1980                         // ArrayStorage&#39;s Butterfly can be half-broken state.
1981                         auto locker = holdLock(array-&gt;cellLock());
1982 
1983                         WTF::loadLoadFence();
1984                         Butterfly* butterfly = array-&gt;butterfly();
1985 
1986                         WTF::loadLoadFence();
1987                         StructureID structureIDLate = array-&gt;structureID();
1988 
1989                         if (structureIDEarly != structureIDLate)
1990                             return false;
1991 
1992                         Structure* structure = m_vm.getStructure(structureIDLate);
1993                         if (!hasAnyArrayStorage(structure-&gt;indexingMode()))
1994                             return false;
1995 
1996                         if (structure-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
1997                             return false;
1998 
1999                         ArrayStorage* storage = butterfly-&gt;arrayStorage();
2000                         if (index &gt;= storage-&gt;length())
2001                             return false;
2002 
2003                         if (index &lt; storage-&gt;vectorLength())
2004                             return false;
2005 
2006                         SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2007                         if (!map)
2008                             return false;
2009 
2010                         value = map-&gt;getConcurrently(index);
2011                     }
2012                     if (!value)
2013                         return false;
2014 
2015                     if (value.isCell())
2016                         setConstant(node, *m_graph.freeze(value.asCell()));
2017                     else
2018                         setConstant(node, value);
2019                     return true;
2020                 }
2021 
2022                 return false;
2023             };
2024 
2025             bool didFold = false;
2026             switch (node-&gt;arrayMode().type()) {
2027             case Array::Generic:
2028             case Array::Int32:
2029             case Array::Double:
2030             case Array::Contiguous:
2031             case Array::ArrayStorage:
2032             case Array::SlowPutArrayStorage:
2033                 if (foldGetByValOnConstantProperty(m_graph.child(node, 0), m_graph.child(node, 1))) {
2034                     if (!node-&gt;arrayMode().isInBounds())
2035                         didFoldClobberWorld();
2036                     didFold = true;
2037                 }
2038                 break;
2039             default:
2040                 break;
2041             }
2042 
2043             if (didFold)
2044                 break;
2045         }
2046 
2047         if (node-&gt;op() != GetByVal) {
2048             unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2049             Edge storageEdge = m_graph.child(node, 2 + numExtraArgs);
2050             if (!storageEdge)
2051                 clobberWorld();
2052         }
2053         switch (node-&gt;arrayMode().type()) {
2054         case Array::SelectUsingPredictions:
2055         case Array::Unprofiled:
2056         case Array::SelectUsingArguments:
2057             RELEASE_ASSERT_NOT_REACHED();
2058             break;
2059         case Array::ForceExit:
2060             m_state.setIsValid(false);
2061             break;
2062         case Array::Undecided: {
2063             JSValue index = forNode(m_graph.child(node, 1)).value();
2064             if (index &amp;&amp; index.isInt32() &amp;&amp; index.asInt32() &gt;= 0) {
2065                 setConstant(node, jsUndefined());
2066                 break;
2067             }
2068             setNonCellTypeForNode(node, SpecOther);
2069             break;
2070         }
2071         case Array::Generic:
2072             clobberWorld();
2073             makeHeapTopForNode(node);
2074             break;
2075         case Array::String:
2076             if (node-&gt;arrayMode().isOutOfBounds()) {
2077                 // If the watchpoint was still valid we could totally set this to be
2078                 // SpecString | SpecOther. Except that we&#39;d have to be careful. If we
2079                 // tested the watchpoint state here then it could change by the time
2080                 // we got to the backend. So to do this right, we&#39;d have to get the
2081                 // fixup phase to check the watchpoint state and then bake into the
2082                 // GetByVal operation the fact that we&#39;re using a watchpoint, using
2083                 // something like Array::SaneChain (except not quite, because that
2084                 // implies an in-bounds access). None of this feels like it&#39;s worth it,
2085                 // so we&#39;re going with TOP for now. The same thing applies to
2086                 // clobbering the world.
2087                 clobberWorld();
2088                 makeHeapTopForNode(node);
2089             } else
2090                 setForNode(node, m_vm.stringStructure.get());
2091             break;
2092         case Array::DirectArguments:
2093         case Array::ScopedArguments:
2094             if (node-&gt;arrayMode().isOutOfBounds())
2095                 clobberWorld();
2096             makeHeapTopForNode(node);
2097             break;
2098         case Array::Int32:
2099             if (node-&gt;arrayMode().isOutOfBounds()) {
2100                 clobberWorld();
2101                 makeHeapTopForNode(node);
2102             } else
2103                 setNonCellTypeForNode(node, SpecInt32Only);
2104             break;
2105         case Array::Double:
2106             if (node-&gt;arrayMode().isOutOfBounds()) {
2107                 clobberWorld();
2108                 makeHeapTopForNode(node);
2109             } else if (node-&gt;arrayMode().isSaneChain())
2110                 setNonCellTypeForNode(node, SpecBytecodeDouble);
2111             else
2112                 setNonCellTypeForNode(node, SpecDoubleReal);
2113             break;
2114         case Array::Contiguous:
2115         case Array::ArrayStorage:
2116         case Array::SlowPutArrayStorage:
2117             if (node-&gt;arrayMode().isOutOfBounds())
2118                 clobberWorld();
2119             makeHeapTopForNode(node);
2120             break;
2121         case Array::Int8Array:
2122             setNonCellTypeForNode(node, SpecInt32Only);
2123             break;
2124         case Array::Int16Array:
2125             setNonCellTypeForNode(node, SpecInt32Only);
2126             break;
2127         case Array::Int32Array:
2128             setNonCellTypeForNode(node, SpecInt32Only);
2129             break;
2130         case Array::Uint8Array:
2131             setNonCellTypeForNode(node, SpecInt32Only);
2132             break;
2133         case Array::Uint8ClampedArray:
2134             setNonCellTypeForNode(node, SpecInt32Only);
2135             break;
2136         case Array::Uint16Array:
2137             setNonCellTypeForNode(node, SpecInt32Only);
2138             break;
2139         case Array::Uint32Array:
2140             if (node-&gt;shouldSpeculateInt32())
2141                 setNonCellTypeForNode(node, SpecInt32Only);
<a name="41" id="anc41"></a><span class="line-modified">2142             else if (enableInt52() &amp;&amp; node-&gt;shouldSpeculateAnyInt())</span>
<span class="line-modified">2143                 setNonCellTypeForNode(node, SpecAnyInt);</span>
2144             else
2145                 setNonCellTypeForNode(node, SpecAnyIntAsDouble);
2146             break;
2147         case Array::Float32Array:
2148             setNonCellTypeForNode(node, SpecFullDouble);
2149             break;
2150         case Array::Float64Array:
2151             setNonCellTypeForNode(node, SpecFullDouble);
2152             break;
2153         default:
2154             RELEASE_ASSERT_NOT_REACHED();
2155             break;
2156         }
2157         break;
2158     }
2159 
2160     case PutByValDirect:
2161     case PutByVal:
2162     case PutByValAlias: {
2163         switch (node-&gt;arrayMode().modeForPut().type()) {
2164         case Array::ForceExit:
2165             m_state.setIsValid(false);
2166             break;
2167         case Array::Generic:
2168             clobberWorld();
2169             break;
2170         case Array::Int32:
2171             if (node-&gt;arrayMode().isOutOfBounds())
2172                 clobberWorld();
2173             break;
2174         case Array::Double:
2175             if (node-&gt;arrayMode().isOutOfBounds())
2176                 clobberWorld();
2177             break;
2178         case Array::Contiguous:
2179         case Array::ArrayStorage:
2180             if (node-&gt;arrayMode().isOutOfBounds())
2181                 clobberWorld();
2182             break;
2183         case Array::SlowPutArrayStorage:
2184             if (node-&gt;arrayMode().mayStoreToHole())
2185                 clobberWorld();
2186             break;
2187         default:
2188             break;
2189         }
2190         break;
2191     }
2192 
2193     case ArrayPush:
2194         clobberWorld();
2195         setNonCellTypeForNode(node, SpecBytecodeNumber);
2196         break;
2197 
2198     case ArraySlice: {
2199         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2200 
2201         // FIXME: We could do better here if we prove that the
2202         // incoming value has only a single structure.
2203         RegisteredStructureSet structureSet;
2204         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithInt32)));
2205         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous)));
2206         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithDouble)));
2207 
2208         setForNode(node, structureSet);
2209         break;
2210     }
2211 
2212     case ArrayIndexOf: {
2213         setNonCellTypeForNode(node, SpecInt32Only);
2214         break;
2215     }
2216 
2217     case ArrayPop:
2218         clobberWorld();
2219         makeHeapTopForNode(node);
2220         break;
2221 
2222     case GetMyArgumentByVal:
2223     case GetMyArgumentByValOutOfBounds: {
2224         JSValue index = forNode(node-&gt;child2()).m_value;
<a name="42" id="anc42"></a><span class="line-modified">2225         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
2226 
2227         if (index &amp;&amp; index.isUInt32()) {
2228             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2229             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2230             // paths as unreachable, or to return undefined. We could implement that eventually.
2231 
2232             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2233             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2234             unsigned argumentIndex;
2235             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2236                 if (inlineCallFrame) {
2237                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {
2238                         setForNode(node, m_state.operand(
2239                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));
2240                         m_state.setFoundConstants(true);
2241                         break;
2242                     }
2243                 } else {
2244                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2245                         setForNode(node, m_state.argument(argumentIndex + 1));
2246                         m_state.setFoundConstants(true);
2247                         break;
2248                     }
2249                 }
2250             }
2251         }
2252 
2253         if (inlineCallFrame) {
2254             // We have a bound on the types even though it&#39;s random access. Take advantage of this.
2255 
2256             AbstractValue result;
2257             for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
2258                 result.merge(
2259                     m_state.operand(
2260                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset));
2261             }
2262 
2263             if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
2264                 result.merge(SpecOther);
2265 
2266             if (result.value())
2267                 m_state.setFoundConstants(true);
2268 
2269             setForNode(node, result);
2270             break;
2271         }
2272 
2273         makeHeapTopForNode(node);
2274         break;
2275     }
2276 
2277     case RegExpExec:
2278     case RegExpExecNonGlobalOrSticky:
2279         if (node-&gt;op() == RegExpExec) {
2280             // Even if we&#39;ve proven known input types as RegExpObject and String,
2281             // accessing lastIndex is effectful if it&#39;s a global regexp.
2282             clobberWorld();
2283         }
2284 
2285         if (JSValue globalObjectValue = forNode(node-&gt;child1()).m_value) {
2286             if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
2287                 if (!globalObject-&gt;isHavingABadTime()) {
2288                     m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2289                     RegisteredStructureSet structureSet;
2290                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));
2291                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayWithGroupsStructure()));
2292                     setForNode(node, structureSet);
2293                     forNode(node).merge(SpecOther);
2294                     break;
2295                 }
2296             }
2297         }
2298         setTypeForNode(node, SpecOther | SpecArray);
2299         break;
2300 
2301     case RegExpTest:
2302         // Even if we&#39;ve proven known input types as RegExpObject and String,
2303         // accessing lastIndex is effectful if it&#39;s a global regexp.
2304         clobberWorld();
2305         setNonCellTypeForNode(node, SpecBoolean);
2306         break;
2307 
2308     case RegExpMatchFast:
2309         ASSERT(node-&gt;child2().useKind() == RegExpObjectUse);
2310         ASSERT(node-&gt;child3().useKind() == StringUse || node-&gt;child3().useKind() == KnownStringUse);
2311         setTypeForNode(node, SpecOther | SpecArray);
2312         break;
2313 
2314     case RegExpMatchFastGlobal:
2315         ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == KnownStringUse);
2316         setTypeForNode(node, SpecOther | SpecArray);
2317         break;
2318 
2319     case StringReplace:
2320     case StringReplaceRegExp:
2321         if (node-&gt;child1().useKind() == StringUse
2322             &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
2323             &amp;&amp; node-&gt;child3().useKind() == StringUse) {
2324             // This doesn&#39;t clobber the world. It just reads and writes regexp state.
2325         } else
2326             clobberWorld();
2327         setForNode(node, m_vm.stringStructure.get());
2328         break;
2329 
2330     case Jump:
2331         break;
2332 
2333     case Branch: {
2334         Node* child = node-&gt;child1().node();
2335         BooleanResult result = booleanResult(node, forNode(child));
2336         if (result == DefinitelyTrue) {
2337             m_state.setBranchDirection(TakeTrue);
2338             break;
2339         }
2340         if (result == DefinitelyFalse) {
2341             m_state.setBranchDirection(TakeFalse);
2342             break;
2343         }
2344         // FIXME: The above handles the trivial cases of sparse conditional
2345         // constant propagation, but we can do better:
2346         // We can specialize the source variable&#39;s value on each direction of
2347         // the branch.
2348         m_state.setBranchDirection(TakeBoth);
2349         break;
2350     }
2351 
2352     case Switch: {
2353         // Nothing to do for now.
2354         // FIXME: Do sparse conditional things.
2355         break;
2356     }
2357 
2358     case EntrySwitch:
2359         break;
2360 
2361     case Return:
2362         m_state.setIsValid(false);
2363         break;
2364 
2365     case Throw:
2366     case ThrowStaticError:
2367     case TailCall:
2368     case DirectTailCall:
2369     case TailCallVarargs:
2370     case TailCallForwardVarargs:
2371         clobberWorld();
2372         m_state.setIsValid(false);
2373         break;
2374 
2375     case ToPrimitive: {
2376         JSValue childConst = forNode(node-&gt;child1()).value();
2377         if (childConst &amp;&amp; childConst.isNumber()) {
2378             didFoldClobberWorld();
2379             setConstant(node, childConst);
2380             break;
2381         }
2382 
2383         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2384 
2385         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
2386             m_state.setFoundConstants(true);
2387             didFoldClobberWorld();
2388             setForNode(node, forNode(node-&gt;child1()));
2389             break;
2390         }
2391 
2392         clobberWorld();
2393 
2394         setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
2395         break;
2396     }
2397 
2398     case ToNumber: {
2399         JSValue childConst = forNode(node-&gt;child1()).value();
2400         if (childConst &amp;&amp; childConst.isNumber()) {
2401             didFoldClobberWorld();
2402             setConstant(node, childConst);
2403             break;
2404         }
2405 
2406         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2407 
2408         if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
2409             m_state.setFoundConstants(true);
2410             didFoldClobberWorld();
2411             setForNode(node, forNode(node-&gt;child1()));
2412             break;
2413         }
2414 
2415         clobberWorld();
2416         setNonCellTypeForNode(node, SpecBytecodeNumber);
2417         break;
2418     }
2419 
2420     case ToString:
2421     case CallStringConstructor: {
2422         switch (node-&gt;child1().useKind()) {
2423         case StringObjectUse:
2424         case StringOrStringObjectUse:
2425         case Int32Use:
2426         case Int52RepUse:
2427         case DoubleRepUse:
2428         case NotCellUse:
2429             break;
2430         case CellUse:
2431         case UntypedUse:
2432             clobberWorld();
2433             break;
2434         default:
2435             RELEASE_ASSERT_NOT_REACHED();
2436             break;
2437         }
2438         setForNode(node, m_vm.stringStructure.get());
2439         break;
2440     }
2441 
2442     case NumberToStringWithRadix: {
2443         JSValue radixValue = forNode(node-&gt;child2()).m_value;
2444         if (radixValue &amp;&amp; radixValue.isInt32()) {
2445             int32_t radix = radixValue.asInt32();
2446             if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
2447                 m_state.setFoundConstants(true);
2448                 didFoldClobberWorld();
2449                 setForNode(node, m_graph.m_vm.stringStructure.get());
2450                 break;
2451             }
2452         }
2453         clobberWorld();
2454         setForNode(node, m_graph.m_vm.stringStructure.get());
2455         break;
2456     }
2457 
2458     case NumberToStringWithValidRadixConstant: {
2459         setForNode(node, m_graph.m_vm.stringStructure.get());
2460         break;
2461     }
2462 
2463     case NewStringObject: {
2464         ASSERT(node-&gt;structure()-&gt;classInfo() == StringObject::info());
2465         setForNode(node, node-&gt;structure());
2466         break;
2467     }
2468 
2469     case NewSymbol: {
2470         setForNode(node, m_vm.symbolStructure.get());
2471         break;
2472     }
2473 
2474     case NewArray:
2475         ASSERT(node-&gt;indexingMode() == node-&gt;indexingType()); // Copy on write arrays should only be created by NewArrayBuffer.
2476         setForNode(node,
2477             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
2478         break;
2479 
2480     case NewArrayWithSpread:
2481         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2482             // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
2483             // with StructureRegisterationPhase we must say we produce an original array
2484             // allocation structure.
2485             setForNode(node,
2486                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
2487         } else {
2488             setForNode(node,
2489                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
2490         }
2491 
2492         break;
2493 
2494     case Spread:
2495         switch (node-&gt;child1()-&gt;op()) {
2496         case PhantomNewArrayBuffer:
2497         case PhantomCreateRest:
2498             break;
2499         default:
2500             if (!m_graph.canDoFastSpread(node, forNode(node-&gt;child1())))
2501                 clobberWorld();
2502             else
2503                 didFoldClobberWorld();
2504             break;
2505         }
2506 
2507         setForNode(node,
2508             m_vm.fixedArrayStructure.get());
2509         break;
2510 
2511     case NewArrayBuffer:
2512         setForNode(node,
2513             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
2514         break;
2515 
2516     case NewArrayWithSize:
2517         setTypeForNode(node, SpecArray);
2518         break;
2519 
2520     case NewTypedArray:
2521         switch (node-&gt;child1().useKind()) {
2522         case Int32Use:
2523             break;
2524         case UntypedUse:
2525             clobberWorld();
2526             break;
2527         default:
2528             RELEASE_ASSERT_NOT_REACHED();
2529             break;
2530         }
2531         setForNode(node,
2532             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2533                 node-&gt;typedArrayType()));
2534         break;
2535 
2536     case NewRegexp:
2537         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2538         break;
2539 
2540     case ToThis: {
2541         AbstractValue&amp; source = forNode(node-&gt;child1());
2542         AbstractValue&amp; destination = forNode(node);
<a name="43" id="anc43"></a><span class="line-modified">2543         bool strictMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;isStrictMode();</span>
2544 
2545         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2546         switch (result) {
2547         case ToThisResult::Identity:
2548             m_state.setFoundConstants(true);
2549             destination = source;
2550             break;
2551         case ToThisResult::Undefined:
2552             setConstant(node, jsUndefined());
2553             break;
2554         case ToThisResult::GlobalThis:
2555             m_state.setFoundConstants(true);
2556             destination.setType(m_graph, SpecObject);
2557             break;
2558         case ToThisResult::Dynamic:
2559             if (strictMode)
2560                 destination.makeHeapTop();
2561             else {
2562                 destination = source;
2563                 destination.merge(SpecObject);
2564             }
2565             break;
2566         }
2567         break;
2568     }
2569 
2570     case CreateThis: {
2571         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2572             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2573                 if (FunctionRareData* rareData = function-&gt;rareData()) {
2574                     if (Structure* structure = rareData-&gt;objectAllocationStructure()) {
2575                         m_graph.freeze(rareData);
2576                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
2577                         m_state.setFoundConstants(true);
2578                         didFoldClobberWorld();
2579                         setForNode(node, structure);
2580                         break;
2581                     }
2582                 }
2583             }
2584         }
2585         clobberWorld();
2586         setTypeForNode(node, SpecFinalObject);
2587         break;
2588     }
2589 
2590     case NewObject:
2591         ASSERT(!!node-&gt;structure().get());
2592         setForNode(node, node-&gt;structure());
2593         break;
2594 
2595     case ObjectCreate: {
2596         if (JSValue base = forNode(node-&gt;child1()).m_value) {
<a name="44" id="anc44"></a><span class="line-modified">2597             if (base.isNull()) {</span>
<span class="line-modified">2598                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>






2599                 m_state.setFoundConstants(true);
2600                 if (node-&gt;child1().useKind() == UntypedUse)
2601                     didFoldClobberWorld();
<a name="45" id="anc45"></a><span class="line-modified">2602                 setForNode(node, globalObject-&gt;nullPrototypeObjectStructure());</span>
2603                 break;
2604             }
<a name="46" id="anc46"></a><span class="line-removed">2605             // FIXME: We should get a structure for a constant prototype. We need to allow concurrent</span>
<span class="line-removed">2606             // access to StructureCache from compiler threads.</span>
<span class="line-removed">2607             // https://bugs.webkit.org/show_bug.cgi?id=186199</span>
2608         }
2609         if (node-&gt;child1().useKind() == UntypedUse)
2610             clobberWorld();
2611         setTypeForNode(node, SpecFinalObject);
2612         break;
2613     }
2614 
2615     case ObjectKeys: {
2616         if (node-&gt;child1().useKind() == ObjectUse) {
2617             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2618             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2619                 RegisteredStructure structure = structureSet.onlyStructure();
2620                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2621                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2622                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2623                             m_state.setFoundConstants(true);
2624                             didFoldClobberWorld();
2625                             setTypeForNode(node, SpecArray);
2626                             break;
2627                         }
2628                     }
2629                 }
2630             }
2631         }
2632 
2633         clobberWorld();
2634         setTypeForNode(node, SpecArray);
2635         break;
2636     }
2637 
2638     case ToObject:
2639     case CallObjectConstructor: {
2640         AbstractValue&amp; source = forNode(node-&gt;child1());
2641         AbstractValue&amp; destination = forNode(node);
2642 
2643         if (!(source.m_type &amp; ~SpecObject)) {
2644             m_state.setFoundConstants(true);
2645             if (node-&gt;op() == ToObject)
2646                 didFoldClobberWorld();
2647             destination = source;
2648             break;
2649         }
2650 
2651         if (node-&gt;op() == ToObject)
2652             clobberWorld();
2653         setTypeForNode(node, SpecObject);
2654         break;
2655     }
2656 
2657     case PhantomNewObject:
2658     case PhantomNewFunction:
2659     case PhantomNewGeneratorFunction:
2660     case PhantomNewAsyncGeneratorFunction:
2661     case PhantomNewAsyncFunction:
2662     case PhantomCreateActivation:
2663     case PhantomDirectArguments:
2664     case PhantomClonedArguments:
2665     case PhantomCreateRest:
2666     case PhantomSpread:
2667     case PhantomNewArrayWithSpread:
2668     case PhantomNewArrayBuffer:
2669     case PhantomNewRegexp:
2670     case BottomValue: {
2671         clearForNode(node);
2672         break;
2673     }
2674 
2675     case PutHint:
2676         break;
2677 
2678     case MaterializeNewObject: {
2679         setForNode(node, node-&gt;structureSet());
2680         break;
2681     }
2682 
2683     case PushWithScope:
2684         // We don&#39;t use the more precise withScopeStructure() here because it is a LazyProperty and may not yet be allocated.
2685         setTypeForNode(node, SpecObjectOther);
2686         break;
2687 
2688     case CreateActivation:
2689     case MaterializeCreateActivation:
2690         setForNode(node,
2691             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;activationStructure());
2692         break;
2693 
2694     case CreateDirectArguments:
2695         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
2696         break;
2697 
2698     case CreateScopedArguments:
2699         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure());
2700         break;
2701 
2702     case CreateClonedArguments:
2703         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2704             setTypeForNode(node, SpecObject);
2705             break;
2706         }
2707         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
2708         break;
2709 
2710     case NewGeneratorFunction:
2711         setForNode(node,
2712             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
2713         break;
2714 
2715     case NewAsyncGeneratorFunction:
2716         setForNode(node,
2717             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
2718         break;
2719 
2720     case NewAsyncFunction:
2721         setForNode(node,
2722             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
2723         break;
2724 
2725     case NewFunction: {
2726         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
2727         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
2728         setForNode(node, structure);
2729         break;
2730     }
2731 
2732     case GetCallee:
2733         if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
<a name="47" id="anc47"></a><span class="line-modified">2734             InferredValue* singleton = executable-&gt;singletonFunction();</span>
<span class="line-modified">2735             if (JSValue value = singleton-&gt;inferredValue()) {</span>
<span class="line-removed">2736                 m_graph.watchpoints().addLazily(singleton);</span>
<span class="line-removed">2737                 JSFunction* function = jsCast&lt;JSFunction*&gt;(value);</span>
2738                 setConstant(node, *m_graph.freeze(function));
2739                 break;
2740             }
2741         }
<a name="48" id="anc48"></a><span class="line-modified">2742         setTypeForNode(node, SpecFunction);</span>
2743         break;
2744 
2745     case GetArgumentCountIncludingThis:
2746         setTypeForNode(node, SpecInt32Only);
2747         break;
2748 
2749     case SetCallee:
2750     case SetArgumentCountIncludingThis:
2751         break;
2752 
2753     case GetRestLength:
2754         setNonCellTypeForNode(node, SpecInt32Only);
2755         break;
2756 
2757     case GetGetter: {
<a name="49" id="anc49"></a><span class="line-modified">2758         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="line-modified">2759         if (base) {</span>
<span class="line-modified">2760             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="line-removed">2761             if (!getterSetter-&gt;isGetterNull()) {</span>
2762                 setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
2763                 break;
2764             }
2765         }
2766 
2767         setTypeForNode(node, SpecObject);
2768         break;
2769     }
2770 
2771     case GetSetter: {
<a name="50" id="anc50"></a><span class="line-modified">2772         JSValue base = forNode(node-&gt;child1()).m_value;</span>
<span class="line-modified">2773         if (base) {</span>
<span class="line-modified">2774             GetterSetter* getterSetter = jsCast&lt;GetterSetter*&gt;(base);</span>
<span class="line-removed">2775             if (!getterSetter-&gt;isSetterNull()) {</span>
2776                 setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
2777                 break;
2778             }
2779         }
2780 
2781         setTypeForNode(node, SpecObject);
2782         break;
2783     }
2784 
2785     case GetScope:
2786         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2787             if (JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2788                 setConstant(node, *m_graph.freeze(function-&gt;scope()));
2789                 break;
2790             }
2791         }
2792         setTypeForNode(node, SpecObjectOther);
2793         break;
2794 
2795     case SkipScope: {
<a name="51" id="anc51"></a><span class="line-modified">2796         JSValue child = forNode(node-&gt;child1()).value();</span>
<span class="line-modified">2797         if (child) {</span>
<span class="line-modified">2798             setConstant(node, *m_graph.freeze(JSValue(jsCast&lt;JSScope*&gt;(child.asCell())-&gt;next())));</span>
<span class="line-modified">2799             break;</span>



2800         }
2801         setTypeForNode(node, SpecObjectOther);
2802         break;
2803     }
2804 
2805     case GetGlobalObject: {
2806         JSValue child = forNode(node-&gt;child1()).value();
2807         if (child) {
2808             setConstant(node, *m_graph.freeze(JSValue(asObject(child)-&gt;globalObject(m_vm))));
2809             break;
2810         }
2811 
2812         if (forNode(node-&gt;child1()).m_structure.isFinite()) {
2813             JSGlobalObject* globalObject = nullptr;
2814             bool ok = true;
2815             forNode(node-&gt;child1()).m_structure.forEach(
2816                 [&amp;] (RegisteredStructure structure) {
2817                     if (!globalObject)
2818                         globalObject = structure-&gt;globalObject();
2819                     else if (globalObject != structure-&gt;globalObject())
2820                         ok = false;
2821                 });
2822             if (globalObject &amp;&amp; ok) {
2823                 setConstant(node, *m_graph.freeze(JSValue(globalObject)));
2824                 break;
2825             }
2826         }
2827 
2828         setTypeForNode(node, SpecObjectOther);
2829         break;
2830     }
2831 
2832     case GetGlobalThis: {
2833         setTypeForNode(node, SpecObject);
2834         break;
2835     }
2836 
2837     case GetClosureVar:
2838         if (JSValue value = m_graph.tryGetConstantClosureVar(forNode(node-&gt;child1()), node-&gt;scopeOffset())) {
2839             setConstant(node, *m_graph.freeze(value));
2840             break;
2841         }
2842         makeBytecodeTopForNode(node);
2843         break;
2844 
2845     case PutClosureVar:
2846         break;
2847 
2848     case GetRegExpObjectLastIndex:
2849         makeHeapTopForNode(node);
2850         break;
2851 
2852     case SetRegExpObjectLastIndex:
2853     case RecordRegExpCachedResult:
2854         break;
2855 
2856     case GetFromArguments:
2857         makeHeapTopForNode(node);
2858         break;
2859 
2860     case PutToArguments:
2861         break;
2862 
2863     case GetArgument:
2864         makeHeapTopForNode(node);
2865         break;
2866 
2867     case TryGetById:
2868         // FIXME: This should constant fold at least as well as the normal GetById case.
2869         // https://bugs.webkit.org/show_bug.cgi?id=156422
2870         makeHeapTopForNode(node);
2871         break;
2872 
2873     case GetByIdDirect:
2874     case GetByIdDirectFlush:
2875     case GetById:
2876     case GetByIdFlush: {
2877         AbstractValue&amp; value = forNode(node-&gt;child1());
2878         if (value.m_structure.isFinite()
2879             &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
2880             UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
2881             GetByIdStatus status = GetByIdStatus::computeFor(value.m_structure.toStructureSet(), uid);
2882             if (status.isSimple()) {
2883                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
2884                 // something more subtle?
2885                 AbstractValue result;
2886                 for (unsigned i = status.numVariants(); i--;) {
2887                     // This thing won&#39;t give us a variant that involves prototypes. If it did, we&#39;d
2888                     // have more work to do here.
2889                     DFG_ASSERT(m_graph, node, status[i].conditionSet().isEmpty());
2890 
2891                     result.merge(
2892                         m_graph.inferredValueForProperty(
2893                             value, status[i].offset(), m_state.structureClobberState()));
2894                 }
2895 
2896                 m_state.setFoundConstants(true);
2897                 didFoldClobberWorld();
2898                 forNode(node) = result;
2899                 break;
2900             }
2901         }
2902 
2903         clobberWorld();
2904         makeHeapTopForNode(node);
2905         break;
2906     }
2907 
2908     case GetByValWithThis:
2909     case GetByIdWithThis:
2910         clobberWorld();
2911         makeHeapTopForNode(node);
2912         break;
2913 
2914     case GetArrayLength: {
2915         JSArrayBufferView* view = m_graph.tryGetFoldableView(
2916             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
2917         if (view) {
2918             setConstant(node, jsNumber(view-&gt;length()));
2919             break;
2920         }
2921         setNonCellTypeForNode(node, SpecInt32Only);
2922         break;
2923     }
2924 
2925     case GetVectorLength: {
2926         setNonCellTypeForNode(node, SpecInt32Only);
2927         break;
2928     }
2929 
2930     case DeleteById:
2931     case DeleteByVal: {
2932         // FIXME: This could decide if the delete will be successful based on the set of structures that
2933         // we get from our base value. https://bugs.webkit.org/show_bug.cgi?id=156611
2934         clobberWorld();
2935         setNonCellTypeForNode(node, SpecBoolean);
2936         break;
2937     }
2938 
2939     case CheckStructure: {
2940         AbstractValue&amp; value = forNode(node-&gt;child1());
2941 
2942         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
2943 
2944         // It&#39;s interesting that we could have proven that the object has a larger structure set
2945         // that includes the set we&#39;re testing. In that case we could make the structure check
2946         // more efficient. We currently don&#39;t.
2947 
2948         if (value.m_structure.isSubsetOf(set))
2949             m_state.setFoundConstants(true);
2950 
2951         SpeculatedType admittedTypes = SpecNone;
2952         switch (node-&gt;child1().useKind()) {
2953         case CellUse:
2954         case KnownCellUse:
2955             admittedTypes = SpecNone;
2956             break;
2957         case CellOrOtherUse:
2958             admittedTypes = SpecOther;
2959             break;
2960         default:
2961             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
2962             break;
2963         }
2964 
2965         filter(value, set, admittedTypes);
2966         break;
2967     }
2968 
2969     case CheckStructureOrEmpty: {
2970         AbstractValue&amp; value = forNode(node-&gt;child1());
2971 
2972         bool mayBeEmpty = value.m_type &amp; SpecEmpty;
2973         if (!mayBeEmpty)
2974             m_state.setFoundConstants(true);
2975 
2976         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
2977         filter(value, node-&gt;structureSet(), admittedTypes);
2978         break;
2979     }
2980 
2981     case CheckStructureImmediate: {
2982         // FIXME: This currently can only reason about one structure at a time.
2983         // https://bugs.webkit.org/show_bug.cgi?id=136988
2984 
2985         AbstractValue&amp; value = forNode(node-&gt;child1());
2986         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
2987 
2988         if (value.value()) {
2989             if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
2990                 if (set.contains(m_graph.registerStructure(structure))) {
2991                     m_state.setFoundConstants(true);
2992                     break;
2993                 }
2994             }
2995             m_state.setIsValid(false);
2996             break;
2997         }
2998 
2999         if (m_phiChildren) {
3000             bool allGood = true;
3001             m_phiChildren-&gt;forAllTransitiveIncomingValues(
3002                 node,
3003                 [&amp;] (Node* incoming) {
3004                     if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_vm)) {
3005                         if (set.contains(m_graph.registerStructure(structure)))
3006                             return;
3007                     }
3008                     allGood = false;
3009                 });
3010             if (allGood) {
3011                 m_state.setFoundConstants(true);
3012                 break;
3013             }
3014         }
3015 
3016         if (RegisteredStructure structure = set.onlyStructure()) {
3017             filterByValue(node-&gt;child1(), *m_graph.freeze(structure.get()));
3018             break;
3019         }
3020 
3021         // Aw shucks, we can&#39;t do anything!
3022         break;
3023     }
3024 
3025     case PutStructure:
3026         if (!forNode(node-&gt;child1()).m_structure.isClear()) {
3027             if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
3028                 didFoldClobberStructures();
3029                 m_state.setFoundConstants(true);
3030             } else {
3031                 observeTransition(
3032                     clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
3033                 forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
3034             }
3035         } else {
3036             // We&#39;re going to exit before we get here, but for the sake of validation, we&#39;ve folded our write to StructureID.
3037             didFoldClobberStructures();
3038         }
3039         break;
3040     case GetButterfly:
3041     case AllocatePropertyStorage:
3042     case ReallocatePropertyStorage:
3043     case NukeStructureAndSetButterfly:
3044         // FIXME: We don&#39;t model the fact that the structureID is nuked, simply because currently
3045         // nobody would currently benefit from having that information. But it&#39;s a bug nonetheless.
3046         if (node-&gt;op() == NukeStructureAndSetButterfly)
3047             didFoldClobberStructures();
3048         clearForNode(node); // The result is not a JS value.
3049         break;
3050     case CheckSubClass: {
3051         JSValue constant = forNode(node-&gt;child1()).value();
3052         if (constant) {
3053             if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
3054                 m_state.setFoundConstants(true);
3055                 ASSERT(constant);
3056                 break;
3057             }
3058         }
3059 
3060         AbstractValue&amp; value = forNode(node-&gt;child1());
3061 
3062         if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
3063             m_state.setFoundConstants(true);
3064 
3065         filterClassInfo(value, node-&gt;classInfo());
3066         break;
3067     }
3068     case CallDOMGetter: {
3069         CallDOMGetterData* callDOMGetterData = node-&gt;callDOMGetterData();
3070         DOMJIT::CallDOMGetterSnippet* snippet = callDOMGetterData-&gt;snippet;
3071         if (!snippet || snippet-&gt;effect.writes)
3072             clobberWorld();
3073         if (callDOMGetterData-&gt;domJIT)
3074             setTypeForNode(node, callDOMGetterData-&gt;domJIT-&gt;resultType());
3075         else
3076             makeBytecodeTopForNode(node);
3077         break;
3078     }
3079     case CallDOM: {
3080         const DOMJIT::Signature* signature = node-&gt;signature();
3081         if (signature-&gt;effect.writes)
3082             clobberWorld();
3083         setTypeForNode(node, signature-&gt;result);
3084         break;
3085     }
3086     case CheckArray: {
3087         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3088             m_state.setFoundConstants(true);
3089             break;
3090         }
3091         switch (node-&gt;arrayMode().type()) {
3092         case Array::String:
3093             filter(node-&gt;child1(), SpecString);
3094             break;
3095         case Array::Int32:
3096         case Array::Double:
3097         case Array::Contiguous:
3098         case Array::Undecided:
3099         case Array::ArrayStorage:
3100         case Array::SlowPutArrayStorage:
3101             break;
3102         case Array::DirectArguments:
3103             filter(node-&gt;child1(), SpecDirectArguments);
3104             break;
3105         case Array::ScopedArguments:
3106             filter(node-&gt;child1(), SpecScopedArguments);
3107             break;
3108         case Array::Int8Array:
3109             filter(node-&gt;child1(), SpecInt8Array);
3110             break;
3111         case Array::Int16Array:
3112             filter(node-&gt;child1(), SpecInt16Array);
3113             break;
3114         case Array::Int32Array:
3115             filter(node-&gt;child1(), SpecInt32Array);
3116             break;
3117         case Array::Uint8Array:
3118             filter(node-&gt;child1(), SpecUint8Array);
3119             break;
3120         case Array::Uint8ClampedArray:
3121             filter(node-&gt;child1(), SpecUint8ClampedArray);
3122             break;
3123         case Array::Uint16Array:
3124             filter(node-&gt;child1(), SpecUint16Array);
3125             break;
3126         case Array::Uint32Array:
3127             filter(node-&gt;child1(), SpecUint32Array);
3128             break;
3129         case Array::Float32Array:
3130             filter(node-&gt;child1(), SpecFloat32Array);
3131             break;
3132         case Array::Float64Array:
3133             filter(node-&gt;child1(), SpecFloat64Array);
3134             break;
3135         case Array::AnyTypedArray:
3136             filter(node-&gt;child1(), SpecTypedArrayView);
3137             break;
3138         default:
3139             RELEASE_ASSERT_NOT_REACHED();
3140             break;
3141         }
3142         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3143         break;
3144     }
3145     case Arrayify: {
3146         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3147             didFoldClobberStructures();
3148             m_state.setFoundConstants(true);
3149             break;
3150         }
3151         ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
3152         clobberStructures();
3153         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3154         break;
3155     }
3156     case ArrayifyToStructure: {
3157         AbstractValue&amp; value = forNode(node-&gt;child1());
3158         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
3159             m_state.setFoundConstants(true);
3160         clobberStructures();
3161 
3162         // We have a bunch of options of how to express the abstract set at this point. Let set S
3163         // be the set of structures that the value had before clobbering and assume that all of
3164         // them are watchable. The new value should be the least expressible upper bound of the
3165         // intersection of &quot;values that currently have structure = node-&gt;structure()&quot; and &quot;values
3166         // that have structure in S plus any structure transition-reachable from S&quot;. Assume that
3167         // node-&gt;structure() is not in S but it is transition-reachable from S. Then we would
3168         // like to say that the result is &quot;values that have structure = node-&gt;structure() until
3169         // we invalidate&quot;, but there is no way to express this using the AbstractValue syntax. So
3170         // we must choose between:
3171         //
3172         // 1) &quot;values that currently have structure = node-&gt;structure()&quot;. This is a valid
3173         //    superset of the value that we really want, and it&#39;s specific enough to satisfy the
3174         //    preconditions of the array access that this is guarding. It&#39;s also specific enough
3175         //    to allow relevant optimizations in the case that we didn&#39;t have a contradiction
3176         //    like in this example. Notice that in the abscence of any contradiction, this result
3177         //    is precise rather than being a conservative LUB.
3178         //
3179         // 2) &quot;values that currently hava structure in S plus any structure transition-reachable
3180         //    from S&quot;. This is also a valid superset of the value that we really want, but it&#39;s
3181         //    not specific enough to satisfy the preconditions of the array access that this is
3182         //    guarding - so playing such shenanigans would preclude us from having assertions on
3183         //    the typing preconditions of any array accesses. This would also not be a desirable
3184         //    answer in the absence of a contradiction.
3185         //
3186         // Note that it&#39;s tempting to simply say that the resulting value is BOTTOM because of
3187         // the contradiction. That would be wrong, since we haven&#39;t hit an invalidation point,
3188         // yet.
3189         forNode(node-&gt;child1()).set(m_graph, node-&gt;structure());
3190         break;
3191     }
3192     case GetIndexedPropertyStorage: {
3193         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3194             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3195         if (view)
3196             m_state.setFoundConstants(true);
3197         clearForNode(node);
3198         break;
3199     }
3200     case ConstantStoragePointer: {
3201         clearForNode(node);
3202         break;
3203     }
3204 
3205     case GetTypedArrayByteOffset: {
3206         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
3207         if (view) {
3208             setConstant(node, jsNumber(view-&gt;byteOffset()));
3209             break;
3210         }
3211         setNonCellTypeForNode(node, SpecInt32Only);
3212         break;
3213     }
3214 
3215     case GetPrototypeOf: {
3216         AbstractValue&amp; value = forNode(node-&gt;child1());
3217         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
3218             bool canFold = !value.m_structure.isClear();
3219             JSValue prototype;
3220             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3221                 auto getPrototypeMethod = structure-&gt;classInfo()-&gt;methodTable.getPrototype;
3222                 MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
3223                 if (getPrototypeMethod != defaultGetPrototype) {
3224                     canFold = false;
3225                     return;
3226                 }
3227 
3228                 if (structure-&gt;hasPolyProto()) {
3229                     canFold = false;
3230                     return;
3231                 }
3232                 if (!prototype)
3233                     prototype = structure-&gt;storedPrototype();
3234                 else if (prototype != structure-&gt;storedPrototype())
3235                     canFold = false;
3236             });
3237 
3238             if (prototype &amp;&amp; canFold) {
3239                 switch (node-&gt;child1().useKind()) {
3240                 case ArrayUse:
3241                 case FunctionUse:
3242                 case FinalObjectUse:
3243                     break;
3244                 default:
3245                     didFoldClobberWorld();
3246                     break;
3247                 }
3248                 setConstant(node, *m_graph.freeze(prototype));
3249                 break;
3250             }
3251         }
3252 
3253         switch (node-&gt;child1().useKind()) {
3254         case ArrayUse:
3255         case FunctionUse:
3256         case FinalObjectUse:
3257             break;
3258         default:
3259             clobberWorld();
3260             break;
3261         }
3262         setTypeForNode(node, SpecObject | SpecOther);
3263         break;
3264     }
3265 
3266     case GetByOffset: {
3267         StorageAccessData&amp; data = node-&gt;storageAccessData();
3268 
3269         // FIXME: The part of this that handles inferred property types relies on AI knowing the structure
3270         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3271         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3272         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3273         // on the type that ByteCodeParser was able to prove.
3274         AbstractValue value = m_graph.inferredValueForProperty(
3275             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3276 
3277         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3278         // because the compilation was already invalidated.
3279         if (value.isClear())
3280             m_state.setIsValid(false);
3281 
3282         setForNode(node, value);
3283         if (value.m_value)
3284             m_state.setFoundConstants(true);
3285         break;
3286     }
3287 
3288     case GetGetterSetterByOffset: {
3289         StorageAccessData&amp; data = node-&gt;storageAccessData();
<a name="52" id="anc52"></a><span class="line-modified">3290         JSValue result = m_graph.tryGetConstantProperty(forNode(node-&gt;child2()), data.offset);</span>

3291         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3292             setConstant(node, *m_graph.freeze(result));
3293             break;
3294         }
3295 
<a name="53" id="anc53"></a><span class="line-modified">3296         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;getterSetterStructure());</span>





3297         break;
3298     }
3299 
3300     case MultiGetByOffset: {
3301         // This code will filter the base value in a manner that is possibly different (either more
3302         // or less precise) than the way it would be filtered if this was strength-reduced to a
3303         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3304         // different things about the code, so long as all of them are sound. That even includes
3305         // one guy proving that code should never execute (due to a contradiction) and another guy
3306         // not finding that contradiction. If someone ever proved that there would be a
3307         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3308         // realize it. This is the case here.
3309 
3310         // Ordinarily you have to be careful with calling setFoundConstants()
3311         // because of the effect on compile times, but this node is FTL-only.
3312         m_state.setFoundConstants(true);
3313 
3314         AbstractValue base = forNode(node-&gt;child1());
3315         RegisteredStructureSet baseSet;
3316         AbstractValue result;
3317         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
3318             RegisteredStructureSet set = getCase.set();
3319             set.filter(base);
3320             if (set.isEmpty())
3321                 continue;
3322             baseSet.merge(set);
3323 
3324             switch (getCase.method().kind()) {
3325             case GetByOffsetMethod::Constant: {
3326                 AbstractValue thisResult;
3327                 thisResult.set(
3328                     m_graph,
3329                     *getCase.method().constant(),
3330                     m_state.structureClobberState());
3331                 result.merge(thisResult);
3332                 break;
3333             }
3334 
3335             default: {
3336                 result.makeHeapTop();
3337                 break;
3338             } }
3339         }
3340 
3341         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3342             m_state.setIsValid(false);
3343 
3344         setForNode(node, result);
3345         break;
3346     }
3347 
3348     case PutByOffset: {
3349         break;
3350     }
3351 
3352     case MultiPutByOffset: {
3353         RegisteredStructureSet newSet;
3354         TransitionVector transitions;
3355 
3356         // Ordinarily you have to be careful with calling setFoundConstants()
3357         // because of the effect on compile times, but this node is FTL-only.
3358         m_state.setFoundConstants(true);
3359 
3360         AbstractValue base = forNode(node-&gt;child1());
3361         AbstractValue originalValue = forNode(node-&gt;child2());
3362         AbstractValue resultingValue;
3363 
3364         if (node-&gt;multiPutByOffsetData().writesStructures())
3365             didFoldClobberStructures();
3366 
3367         for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
3368             const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
3369             RegisteredStructureSet thisSet = *m_graph.addStructureSet(variant.oldStructure());
3370             thisSet.filter(base);
3371             if (thisSet.isEmpty())
3372                 continue;
3373 
3374             AbstractValue thisValue = originalValue;
3375             resultingValue.merge(thisValue);
3376 
3377             if (variant.kind() == PutByIdVariant::Transition) {
3378                 RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3379                 if (thisSet.onlyStructure() != newStructure) {
3380                     transitions.append(
3381                         Transition(m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3382                 } // else this is really a replace.
3383                 newSet.add(newStructure);
3384             } else {
3385                 ASSERT(variant.kind() == PutByIdVariant::Replace);
3386                 newSet.merge(thisSet);
3387             }
3388         }
3389 
3390         // We need to order AI executing these effects in the same order as they&#39;re executed
3391         // at runtime. This is critical when you have JS code like `o.f = o;`. We first
3392         // filter types on o, then transition o. Not the other way around. If we got
3393         // this ordering wrong, we could end up with the wrong type representing o.
3394         setForNode(node-&gt;child2(), resultingValue);
3395         if (!!originalValue &amp;&amp; !resultingValue)
3396             m_state.setIsValid(false);
3397 
3398         observeTransitions(clobberLimit, transitions);
3399         if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3400             m_state.setIsValid(false);
3401         break;
3402     }
3403 
3404     case GetExecutable: {
3405         JSValue value = forNode(node-&gt;child1()).value();
3406         if (value) {
3407             JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
3408             if (function) {
3409                 setConstant(node, *m_graph.freeze(function-&gt;executable()));
3410                 break;
3411             }
3412         }
3413         setTypeForNode(node, SpecCellOther);
3414         break;
3415     }
3416 
3417     case CheckCell: {
3418         JSValue value = forNode(node-&gt;child1()).value();
3419         if (value == node-&gt;cellOperand()-&gt;value()) {
3420             m_state.setFoundConstants(true);
3421             ASSERT(value);
3422             break;
3423         }
3424         filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
3425         break;
3426     }
3427 
3428     case AssertNotEmpty:
3429     case CheckNotEmpty: {
3430         AbstractValue&amp; value = forNode(node-&gt;child1());
3431         if (!(value.m_type &amp; SpecEmpty)) {
3432             m_state.setFoundConstants(true);
3433             break;
3434         }
3435 
3436         filter(value, ~SpecEmpty);
3437         break;
3438     }
3439 
3440     case CheckStringIdent: {
3441         AbstractValue&amp; value = forNode(node-&gt;child1());
3442         UniquedStringImpl* uid = node-&gt;uidOperand();
3443         ASSERT(!(value.m_type &amp; ~SpecStringIdent)); // Edge filtering should have already ensured this.
3444 
3445         JSValue childConstant = value.value();
3446         if (childConstant) {
3447             ASSERT(childConstant.isString());
3448             if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {
3449                 m_state.setFoundConstants(true);
3450                 break;
3451             }
3452         }
3453 
3454         filter(value, SpecStringIdent);
3455         break;
3456     }
3457 
3458     case CheckInBounds: {
3459         JSValue left = forNode(node-&gt;child1()).value();
3460         JSValue right = forNode(node-&gt;child2()).value();
3461         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
3462             m_state.setFoundConstants(true);
3463 
3464         // We claim we result in Int32. It&#39;s not really important what our result is (though we
3465         // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
3466         // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
3467         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
3468         // thing to do here. We pick NodeResultJS because it makes converting this to an identity
3469         // easier.
3470         setNonCellTypeForNode(node, SpecInt32Only);
3471         break;
3472     }
3473 
3474     case PutById:
3475     case PutByIdFlush:
3476     case PutByIdDirect: {
3477         AbstractValue&amp; value = forNode(node-&gt;child1());
3478         if (value.m_structure.isFinite()) {
3479             PutByIdStatus status = PutByIdStatus::computeFor(
3480                 m_graph.globalObjectFor(node-&gt;origin.semantic),
3481                 value.m_structure.toStructureSet(),
3482                 m_graph.identifiers()[node-&gt;identifierNumber()],
3483                 node-&gt;op() == PutByIdDirect);
3484 
3485             if (status.isSimple()) {
3486                 RegisteredStructureSet newSet;
3487                 TransitionVector transitions;
3488 
3489                 for (unsigned i = status.numVariants(); i--;) {
3490                     const PutByIdVariant&amp; variant = status[i];
3491                     if (variant.kind() == PutByIdVariant::Transition) {
3492                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3493                         transitions.append(
3494                             Transition(
3495                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3496                         newSet.add(newStructure);
3497                     } else {
3498                         ASSERT(variant.kind() == PutByIdVariant::Replace);
3499                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
3500                     }
3501                 }
3502 
3503                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
3504                     m_state.setFoundConstants(true);
3505 
3506                 didFoldClobberWorld();
3507                 observeTransitions(clobberLimit, transitions);
3508                 if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3509                     m_state.setIsValid(false);
3510                 break;
3511             }
3512         }
3513 
3514         clobberWorld();
3515         break;
3516     }
3517 
3518     case PutByValWithThis:
3519     case PutByIdWithThis:
3520         clobberWorld();
3521         break;
3522 
3523     case PutGetterById:
3524     case PutSetterById:
3525     case PutGetterSetterById:
3526     case PutGetterByVal:
3527     case PutSetterByVal: {
3528         clobberWorld();
3529         break;
3530     }
3531 
3532     case DefineDataProperty:
3533     case DefineAccessorProperty:
3534         clobberWorld();
3535         break;
3536 
3537     case InById: {
3538         // FIXME: We can determine when the property definitely exists based on abstract
3539         // value information.
3540         clobberWorld();
3541         filter(node-&gt;child1(), SpecObject);
3542         setNonCellTypeForNode(node, SpecBoolean);
3543         break;
3544     }
3545 
3546     case InByVal: {
3547         AbstractValue&amp; property = forNode(node-&gt;child2());
3548         if (JSValue constant = property.value()) {
3549             if (constant.isString()) {
3550                 JSString* string = asString(constant);
3551                 const StringImpl* impl = string-&gt;tryGetValueImpl();
<a name="54" id="anc54"></a><span class="line-modified">3552                 if (impl &amp;&amp; impl-&gt;isAtomic())</span>
3553                     m_state.setFoundConstants(true);
3554             }
3555         }
3556 
3557         // FIXME: We can determine when the property definitely exists based on abstract
3558         // value information.
3559         clobberWorld();
3560         filter(node-&gt;child1(), SpecObject);
3561         setNonCellTypeForNode(node, SpecBoolean);
3562         break;
3563     }
3564 
3565     case HasOwnProperty: {
3566         clobberWorld();
3567         setNonCellTypeForNode(node, SpecBoolean);
3568         break;
3569     }
3570 
3571     case GetEnumerableLength: {
3572         setNonCellTypeForNode(node, SpecInt32Only);
3573         break;
3574     }
3575     case HasGenericProperty: {
3576         setNonCellTypeForNode(node, SpecBoolean);
3577         clobberWorld();
3578         break;
3579     }
3580     case HasStructureProperty: {
3581         setNonCellTypeForNode(node, SpecBoolean);
3582         clobberWorld();
3583         break;
3584     }
3585     case HasIndexedProperty: {
3586         ArrayMode mode = node-&gt;arrayMode();
3587         switch (mode.type()) {
3588         case Array::Int32:
3589         case Array::Double:
3590         case Array::Contiguous:
3591         case Array::ArrayStorage: {
3592             break;
3593         }
3594         default: {
3595             clobberWorld();
3596             break;
3597         }
3598         }
3599         setNonCellTypeForNode(node, SpecBoolean);
3600         break;
3601     }
3602     case GetDirectPname: {
3603         clobberWorld();
3604         makeHeapTopForNode(node);
3605         break;
3606     }
3607     case GetPropertyEnumerator: {
3608         setTypeForNode(node, SpecCell);
3609         clobberWorld();
3610         break;
3611     }
3612     case GetEnumeratorStructurePname: {
3613         setTypeForNode(node, SpecString | SpecOther);
3614         break;
3615     }
3616     case GetEnumeratorGenericPname: {
3617         setTypeForNode(node, SpecString | SpecOther);
3618         break;
3619     }
3620     case ToIndexString: {
3621         setTypeForNode(node, SpecString);
3622         break;
3623     }
3624 
3625     case GetGlobalVar:
3626         makeHeapTopForNode(node);
3627         break;
3628 
3629     case GetGlobalLexicalVariable:
3630         makeBytecodeTopForNode(node);
3631         break;
3632 
3633     case GetDynamicVar:
3634         clobberWorld();
3635         makeBytecodeTopForNode(node);
3636         break;
3637 
3638     case PutDynamicVar:
3639         clobberWorld();
3640         break;
3641 
3642     case ResolveScope:
3643         clobberWorld();
3644         setTypeForNode(node, SpecObject);
3645         break;
3646 
3647     case ResolveScopeForHoistingFuncDeclInEval:
3648         clobberWorld();
3649         makeBytecodeTopForNode(node);
3650         break;
3651 
3652     case PutGlobalVariable:
3653     case NotifyWrite:
3654         break;
3655 
3656     case OverridesHasInstance:
3657         setNonCellTypeForNode(node, SpecBoolean);
3658         break;
3659 
3660     case InstanceOf:
3661         clobberWorld();
3662         setNonCellTypeForNode(node, SpecBoolean);
3663         break;
3664 
3665     case InstanceOfCustom:
3666         clobberWorld();
3667         setNonCellTypeForNode(node, SpecBoolean);
3668         break;
3669 
3670     case MatchStructure: {
3671         AbstractValue base = forNode(node-&gt;child1());
3672         RegisteredStructureSet baseSet;
3673 
3674         BooleanLattice result = BooleanLattice::Bottom;
3675         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
3676             RegisteredStructure structure = variant.structure;
3677             if (!base.contains(structure)) {
3678                 m_state.setFoundConstants(true);
3679                 continue;
3680             }
3681 
3682             baseSet.add(structure);
3683             result = leastUpperBoundOfBooleanLattices(
3684                 result, variant.result ? BooleanLattice::True : BooleanLattice::False);
3685         }
3686 
3687         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3688             m_state.setIsValid(false);
3689 
3690         switch (result) {
3691         case BooleanLattice::False:
3692             setConstant(node, jsBoolean(false));
3693             break;
3694         case BooleanLattice::True:
3695             setConstant(node, jsBoolean(true));
3696             break;
3697         default:
3698             setNonCellTypeForNode(node, SpecBoolean);
3699             break;
3700         }
3701         break;
3702     }
3703 
3704     case Phi:
3705         RELEASE_ASSERT(m_graph.m_form == SSA);
3706         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
3707         // The state of this node would have already been decided, but it may have become a
3708         // constant, in which case we&#39;d like to know.
3709         if (forNode(node).m_value)
3710             m_state.setFoundConstants(true);
3711         break;
3712 
3713     case Upsilon: {
3714         NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
3715         if (shadow.isStillValid()) {
3716             m_state.createValueForNode(shadow);
3717             setForNode(shadow, forNode(node-&gt;child1()));
3718         }
3719         break;
3720     }
3721 
3722     case Flush:
3723     case PhantomLocal:
3724         break;
3725 
3726     case Call:
3727     case TailCallInlinedCaller:
3728     case Construct:
3729     case CallVarargs:
3730     case CallForwardVarargs:
3731     case TailCallVarargsInlinedCaller:
3732     case ConstructVarargs:
3733     case ConstructForwardVarargs:
3734     case TailCallForwardVarargsInlinedCaller:
3735     case CallEval:
3736     case DirectCall:
3737     case DirectConstruct:
3738     case DirectTailCallInlinedCaller:
3739         clobberWorld();
3740         makeHeapTopForNode(node);
3741         break;
3742 
3743     case ForceOSRExit:
3744     case CheckBadCell:
3745         m_state.setIsValid(false);
3746         break;
3747 
3748     case InvalidationPoint:
3749         m_state.setStructureClobberState(StructuresAreWatched);
3750         m_state.observeInvalidationPoint();
3751         break;
3752 
3753     case CPUIntrinsic:
3754         if (node-&gt;intrinsic() == CPURdtscIntrinsic)
3755             setNonCellTypeForNode(node, SpecInt32Only);
3756         else
3757             setNonCellTypeForNode(node, SpecOther);
3758         break;
3759 
3760     case CheckTraps:
3761     case LogShadowChickenPrologue:
3762     case LogShadowChickenTail:
3763     case ProfileType:
3764     case ProfileControlFlow:
3765     case Phantom:
3766     case CountExecution:
3767     case CheckTierUpInLoop:
3768     case CheckTierUpAtReturn:
3769     case SuperSamplerBegin:
3770     case SuperSamplerEnd:
3771     case CheckTierUpAndOSREnter:
3772     case LoopHint:
3773     case ZombieHint:
3774     case ExitOK:
3775     case FilterCallLinkStatus:
3776     case FilterGetByIdStatus:
3777     case FilterPutByIdStatus:
3778     case FilterInByIdStatus:
3779     case ClearCatchLocals:
3780         break;
3781 
3782     case CheckTypeInfoFlags: {
3783         const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
3784         unsigned bits = node-&gt;typeInfoOperand();
3785         ASSERT(bits);
3786         if (bits == ImplementsDefaultHasInstance) {
3787             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
3788                 m_state.setFoundConstants(true);
3789                 break;
3790             }
3791         }
3792 
3793         if (JSValue value = abstractValue.value()) {
3794             if (value.isCell()) {
3795                 // This works because if we see a cell here, we know it&#39;s fully constructed
3796                 // and we can read its inline type info flags. These flags don&#39;t change over the
3797                 // object&#39;s lifetime.
3798                 if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
3799                     m_state.setFoundConstants(true);
3800                     break;
3801                 }
3802             }
3803         }
3804 
3805         if (abstractValue.m_structure.isFinite()) {
3806             bool ok = true;
3807             abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3808                 ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
3809             });
3810             if (ok) {
3811                 m_state.setFoundConstants(true);
3812                 break;
3813             }
3814         }
3815 
3816         break;
3817     }
3818 
3819     case ParseInt: {
3820         AbstractValue value = forNode(node-&gt;child1());
3821         if (value.m_type &amp;&amp; !(value.m_type &amp; ~SpecInt32Only)) {
3822             JSValue radix;
3823             if (!node-&gt;child2())
3824                 radix = jsNumber(0);
3825             else
3826                 radix = forNode(node-&gt;child2()).m_value;
3827 
3828             if (radix.isNumber()
3829                 &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
3830                 m_state.setFoundConstants(true);
3831                 if (node-&gt;child1().useKind() == UntypedUse)
3832                     didFoldClobberWorld();
3833                 setNonCellTypeForNode(node, SpecInt32Only);
3834                 break;
3835             }
3836         }
3837 
3838         if (node-&gt;child1().useKind() == UntypedUse)
3839             clobberWorld();
3840         setNonCellTypeForNode(node, SpecBytecodeNumber);
3841         break;
3842     }
3843 
3844     case CreateRest:
3845         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
3846             // This means we&#39;re already having a bad time.
3847             clobberWorld();
3848             setTypeForNode(node, SpecArray);
3849             break;
3850         }
3851         setForNode(node,
3852             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure());
3853         break;
3854 
3855     case CheckVarargs:
3856     case Check: {
3857         // Simplify out checks that don&#39;t actually do checking.
3858         m_graph.doToChildren(node, [&amp;] (Edge edge) {
3859             if (!edge)
3860                 return;
3861             if (edge.isProved() || edge.willNotHaveCheck())
3862                 m_state.setFoundConstants(true);
3863         });
3864         break;
3865     }
3866 
3867     case SetFunctionName: {
3868         clobberWorld();
3869         break;
3870     }
3871 
3872     case StoreBarrier:
3873     case FencedStoreBarrier: {
3874         filter(node-&gt;child1(), SpecCell);
3875         break;
3876     }
3877 
3878     case DataViewGetInt: {
3879         DataViewData data = node-&gt;dataViewData();
3880         if (data.byteSize &lt; 4)
3881             setNonCellTypeForNode(node, SpecInt32Only);
3882         else {
3883             ASSERT(data.byteSize == 4);
3884             if (data.isSigned)
3885                 setNonCellTypeForNode(node, SpecInt32Only);
3886             else
<a name="55" id="anc55"></a><span class="line-modified">3887                 setNonCellTypeForNode(node, SpecAnyInt);</span>
3888         }
3889         break;
3890     }
3891 
3892     case DataViewGetFloat: {
3893         setNonCellTypeForNode(node, SpecFullDouble);
3894         break;
3895     }
3896 
3897     case DataViewSet: {
3898         break;
3899     }
3900 
3901     case Unreachable:
3902         // It may be that during a previous run of AI we proved that something was unreachable, but
3903         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
3904         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
3905         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
3906         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
3907         m_state.setIsValid(false);
3908         break;
3909 
3910     case LastNodeType:
3911     case ArithIMul:
3912     case FiatInt52:
3913         DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
3914         break;
3915     }
3916 
3917     return m_state.isValid();
3918 }
3919 
3920 template&lt;typename AbstractStateType&gt;
3921 void AbstractInterpreter&lt;AbstractStateType&gt;::filterICStatus(Node* node)
3922 {
3923     switch (node-&gt;op()) {
3924     case FilterCallLinkStatus:
3925         if (JSValue value = forNode(node-&gt;child1()).m_value)
3926             node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
3927         break;
3928 
3929     case FilterGetByIdStatus: {
3930         AbstractValue&amp; value = forNode(node-&gt;child1());
3931         if (value.m_structure.isFinite())
3932             node-&gt;getByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3933         break;
3934     }
3935 
3936     case FilterInByIdStatus: {
3937         AbstractValue&amp; value = forNode(node-&gt;child1());
3938         if (value.m_structure.isFinite())
3939             node-&gt;inByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3940         break;
3941     }
3942 
3943     case FilterPutByIdStatus: {
3944         AbstractValue&amp; value = forNode(node-&gt;child1());
3945         if (value.m_structure.isFinite())
3946             node-&gt;putByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3947         break;
3948     }
3949 
3950     default:
3951         RELEASE_ASSERT_NOT_REACHED();
3952         break;
3953     }
3954 }
3955 
3956 template&lt;typename AbstractStateType&gt;
3957 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned indexInBlock)
3958 {
3959     return executeEffects(indexInBlock, m_state.block()-&gt;at(indexInBlock));
3960 }
3961 
3962 template&lt;typename AbstractStateType&gt;
3963 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(unsigned indexInBlock)
3964 {
3965     Node* node = m_state.block()-&gt;at(indexInBlock);
3966 
3967     startExecuting();
3968     executeEdges(node);
3969     return executeEffects(indexInBlock, node);
3970 }
3971 
3972 template&lt;typename AbstractStateType&gt;
3973 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(Node* node)
3974 {
3975     startExecuting();
3976     executeEdges(node);
3977     return executeEffects(UINT_MAX, node);
3978 }
3979 
3980 template&lt;typename AbstractStateType&gt;
3981 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberWorld()
3982 {
3983     clobberStructures();
3984 }
3985 
3986 template&lt;typename AbstractStateType&gt;
3987 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberWorld()
3988 {
3989     didFoldClobberStructures();
3990 }
3991 
3992 template&lt;typename AbstractStateType&gt;
3993 template&lt;typename Functor&gt;
3994 void AbstractInterpreter&lt;AbstractStateType&gt;::forAllValues(
3995     unsigned clobberLimit, Functor&amp; functor)
3996 {
3997     if (clobberLimit &gt;= m_state.block()-&gt;size())
3998         clobberLimit = m_state.block()-&gt;size();
3999     else
4000         clobberLimit++;
4001     ASSERT(clobberLimit &lt;= m_state.block()-&gt;size());
4002     for (size_t i = clobberLimit; i--;) {
4003         NodeFlowProjection::forEach(
4004             m_state.block()-&gt;at(i),
4005             [&amp;] (NodeFlowProjection nodeProjection) {
4006                 functor(forNode(nodeProjection));
4007             });
4008     }
4009     if (m_graph.m_form == SSA) {
4010         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4011             if (node.isStillValid())
4012                 functor(forNode(node));
4013         }
4014     }
4015     for (size_t i = m_state.numberOfArguments(); i--;)
4016         functor(m_state.argument(i));
4017     for (size_t i = m_state.numberOfLocals(); i--;)
4018         functor(m_state.local(i));
4019 }
4020 
4021 template&lt;typename AbstractStateType&gt;
4022 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberStructures()
4023 {
4024     m_state.clobberStructures();
4025     m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
4026     m_state.setStructureClobberState(StructuresAreClobbered);
4027 }
4028 
4029 template&lt;typename AbstractStateType&gt;
4030 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberStructures()
4031 {
4032     m_state.mergeClobberState(AbstractInterpreterClobberState::FoldedClobber);
4033 }
4034 
4035 template&lt;typename AbstractStateType&gt;
4036 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
4037     unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
4038 {
<a name="56" id="anc56"></a>







4039     AbstractValue::TransitionObserver transitionObserver(from, to);
4040     forAllValues(clobberLimit, transitionObserver);
4041 
4042     ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
4043 
4044     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4045 }
4046 
4047 template&lt;typename AbstractStateType&gt;
4048 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4049     unsigned clobberLimit, const TransitionVector&amp; vector)
4050 {
4051     if (vector.isEmpty())
4052         return;
4053 
<a name="57" id="anc57"></a>







4054     AbstractValue::TransitionsObserver transitionsObserver(vector);
4055     forAllValues(clobberLimit, transitionsObserver);
4056 
4057     if (!ASSERT_DISABLED) {
4058         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4059         for (unsigned i = vector.size(); i--;)
4060             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4061     }
4062 
4063     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4064 }
4065 
4066 template&lt;typename AbstractStateType&gt;
4067 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4068 {
4069     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4070 }
4071 
4072 template&lt;typename AbstractStateType&gt;
4073 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
4074 {
4075     CommaPrinter comma(&quot; &quot;);
4076     HashSet&lt;NodeFlowProjection&gt; seen;
4077     if (m_graph.m_form == SSA) {
4078         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4079             seen.add(node);
4080             AbstractValue&amp; value = forNode(node);
4081             if (value.isClear())
4082                 continue;
4083             out.print(comma, node, &quot;:&quot;, value);
4084         }
4085     }
4086     for (size_t i = 0; i &lt; m_state.block()-&gt;size(); ++i) {
4087         NodeFlowProjection::forEach(
4088             m_state.block()-&gt;at(i), [&amp;] (NodeFlowProjection nodeProjection) {
4089                 seen.add(nodeProjection);
4090                 AbstractValue&amp; value = forNode(nodeProjection);
4091                 if (value.isClear())
4092                     return;
4093                 out.print(comma, nodeProjection, &quot;:&quot;, value);
4094             });
4095     }
4096     if (m_graph.m_form == SSA) {
4097         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtTail) {
4098             if (seen.contains(node))
4099                 continue;
4100             AbstractValue&amp; value = forNode(node);
4101             if (value.isClear())
4102                 continue;
4103             out.print(comma, node, &quot;:&quot;, value);
4104         }
4105     }
4106 }
4107 
4108 template&lt;typename AbstractStateType&gt;
4109 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4110     AbstractValue&amp; value, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes)
4111 {
4112     if (value.filter(m_graph, set, admittedTypes) == FiltrationOK)
4113         return FiltrationOK;
4114     m_state.setIsValid(false);
4115     return Contradiction;
4116 }
4117 
4118 template&lt;typename AbstractStateType&gt;
4119 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
4120     AbstractValue&amp; value, ArrayModes arrayModes)
4121 {
4122     if (value.filterArrayModes(arrayModes) == FiltrationOK)
4123         return FiltrationOK;
4124     m_state.setIsValid(false);
4125     return Contradiction;
4126 }
4127 
4128 template&lt;typename AbstractStateType&gt;
4129 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4130     AbstractValue&amp; value, SpeculatedType type)
4131 {
4132     if (value.filter(type) == FiltrationOK)
4133         return FiltrationOK;
4134     m_state.setIsValid(false);
4135     return Contradiction;
4136 }
4137 
4138 template&lt;typename AbstractStateType&gt;
4139 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterByValue(
4140     AbstractValue&amp; abstractValue, FrozenValue concreteValue)
4141 {
4142     if (abstractValue.filterByValue(concreteValue) == FiltrationOK)
4143         return FiltrationOK;
4144     m_state.setIsValid(false);
4145     return Contradiction;
4146 }
4147 
4148 template&lt;typename AbstractStateType&gt;
4149 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterClassInfo(
4150     AbstractValue&amp; value, const ClassInfo* classInfo)
4151 {
4152     if (value.filterClassInfo(m_graph, classInfo) == FiltrationOK)
4153         return FiltrationOK;
4154     m_state.setIsValid(false);
4155     return Contradiction;
4156 }
4157 
4158 template&lt;typename AbstractStateType&gt;
4159 void AbstractInterpreter&lt;AbstractStateType&gt;::executeDoubleUnaryOpEffects(Node* node, double(*equivalentFunction)(double))
4160 {
4161     JSValue child = forNode(node-&gt;child1()).value();
4162     if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
4163         if (node-&gt;child1().useKind() != DoubleRepUse)
4164             didFoldClobberWorld();
4165         setConstant(node, jsDoubleNumber(equivalentFunction(*number)));
4166         return;
4167     }
4168     SpeculatedType type;
4169     if (node-&gt;child1().useKind() == DoubleRepUse)
4170         type = typeOfDoubleUnaryOp(forNode(node-&gt;child1()).m_type);
4171     else {
4172         clobberWorld();
4173         type = SpecBytecodeNumber;
4174     }
4175     setNonCellTypeForNode(node, type);
4176 }
4177 
4178 } } // namespace JSC::DFG
4179 
4180 #endif // ENABLE(DFG_JIT)
<a name="58" id="anc58"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="58" type="hidden" />
</body>
</html>