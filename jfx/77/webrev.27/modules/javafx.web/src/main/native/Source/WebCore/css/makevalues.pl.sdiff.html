<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/makevalues.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="makeprop.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="mathml.css.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/makevalues.pl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57   } else {
 58     $namesHash{$_} = 1;
 59   }
 60   push @names, $_;
 61   push @lower_names, lc $_;
 62 }
 63 
 64 if (@duplicates &gt; 0) {
 65     die &#39;Duplicate CSS value keywords  values: &#39;, join(&#39;, &#39;, @duplicates) . &quot;\n&quot;;
 66 }
 67 
 68 open GPERF, &quot;&gt;CSSValueKeywords.gperf&quot; || die &quot;Could not open CSSValueKeywords.gperf for writing&quot;;
 69 print GPERF &lt;&lt; &quot;EOF&quot;;
 70 %{
 71 /* This file is automatically generated from CSSValueKeywords.in by makevalues, do not edit */
 72 
 73 #include \&quot;config.h\&quot;
 74 #include \&quot;CSSValueKeywords.h\&quot;
 75 #include \&quot;HashTools.h\&quot;
 76 #include &lt;wtf/ASCIICType.h&gt;
<span class="line-modified"> 77 #include &lt;wtf/text/AtomicString.h&gt;</span>
 78 #include &lt;wtf/text/WTFString.h&gt;
 79 #include &lt;string.h&gt;
 80 
 81 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 82 
 83 // Older versions of gperf like to use the `register` keyword.
 84 #define register
 85 
 86 namespace WebCore {
 87 %}
 88 %struct-type
 89 struct Value;
 90 %omit-struct-type
 91 %language=C++
 92 %readonly-tables
 93 %compare-strncmp
 94 %define class-name CSSValueKeywordsHash
 95 %define lookup-function-name findValueImpl
 96 %define hash-function-name value_hash_function
 97 %define word-array-name value_word_list
</pre>
<hr />
<pre>
114 foreach my $name (@names) {
115   print GPERF &quot;    \&quot;&quot; . $name . &quot;\&quot;,\n&quot;;
116 }
117 
118 print GPERF &lt;&lt; &quot;EOF&quot;;
119     0
120 };
121 
122 const Value* findValue(const char* str, unsigned int len)
123 {
124     return CSSValueKeywordsHash::findValueImpl(str, len);
125 }
126 
127 const char* getValueName(unsigned short id)
128 {
129     if (id &gt; lastCSSValueKeyword)
130         return 0;
131     return valueList[id];
132 }
133 
<span class="line-modified">134 const AtomicString&amp; getValueNameAtomicString(CSSValueID id)</span>
135 {
136     if (id &lt; firstCSSValueKeyword || id &gt; lastCSSValueKeyword)
137         return nullAtom();
138 
<span class="line-modified">139     static AtomicString* valueKeywordStrings = new AtomicString[numCSSValueKeywords]; // Leaked intentionally.</span>
<span class="line-modified">140     AtomicString&amp; valueKeywordString = valueKeywordStrings[id];</span>
141     if (valueKeywordString.isNull())
142         valueKeywordString = getValueName(id);
143     return valueKeywordString;
144 }
145 
146 String getValueNameString(CSSValueID id)
147 {
<span class="line-modified">148     // We share the StringImpl with the AtomicStrings.</span>
<span class="line-modified">149     return getValueNameAtomicString(id).string();</span>
150 }
151 
152 } // namespace WebCore
153 
154 IGNORE_WARNINGS_END
155 EOF
156 close GPERF;
157 
158 
159 open HEADER, &quot;&gt;CSSValueKeywords.h&quot; || die &quot;Could not open CSSValueKeywords.h for writing&quot;;
160 print HEADER &lt;&lt; &quot;EOF&quot;;
161 /* This file is automatically generated from CSSValueKeywords.in by makevalues, do not edit */
162 
163 #pragma once
164 
165 #include &lt;string.h&gt;
166 #include &lt;wtf/Forward.h&gt;
167 
168 namespace WebCore {
169 
</pre>
<hr />
<pre>
177 foreach my $name (@names) {
178   my $id = $name;
179   $id =~ s/(^[^-])|-(.)/uc($1||$2)/ge;
180   print HEADER &quot;    CSSValue&quot; . $id . &quot; = &quot; . $i . &quot;,\n&quot;;
181   $i = $i + 1;
182   if (length($name) &gt; $maxLen) {
183     $maxLen = length($name);
184   }
185 }
186 my $num = $i - $first;
187 my $last = $i - 1;
188 
189 print HEADER &quot;};\n\n&quot;;
190 print HEADER &quot;const int firstCSSValueKeyword = $first;\n&quot;;
191 print HEADER &quot;const int numCSSValueKeywords = $num;\n&quot;;
192 print HEADER &quot;const int lastCSSValueKeyword = $last;\n&quot;;
193 print HEADER &quot;const size_t maxCSSValueKeywordLength = &quot; . $maxLen . &quot;;\n&quot;;
194 print HEADER &lt;&lt; &quot;EOF&quot;;
195 
196 const char* getValueName(unsigned short id);
<span class="line-modified">197 const WTF::AtomicString&amp; getValueNameAtomicString(CSSValueID id);</span>
198 WTF::String getValueNameString(CSSValueID id);
199 
200 inline CSSValueID convertToCSSValueID(int value)
201 {
202     ASSERT(value &gt;= firstCSSValueKeyword &amp;&amp; value &lt;= lastCSSValueKeyword);
203     return static_cast&lt;CSSValueID&gt;(value);
204 }
205 
206 } // namespace WebCore
207 EOF
208 close HEADER;
209 
210 if (not $gperf) {
211     $gperf = $ENV{GPERF} ? $ENV{GPERF} : &quot;gperf&quot;;
212 }
213 system(&quot;\&quot;$gperf\&quot; --key-positions=\&quot;*\&quot; -D -n -s 2 CSSValueKeywords.gperf --output-file=CSSValueKeywords.cpp&quot;) == 0 || die &quot;calling gperf failed: $?&quot;;
</pre>
</td>
<td>
<hr />
<pre>
 57   } else {
 58     $namesHash{$_} = 1;
 59   }
 60   push @names, $_;
 61   push @lower_names, lc $_;
 62 }
 63 
 64 if (@duplicates &gt; 0) {
 65     die &#39;Duplicate CSS value keywords  values: &#39;, join(&#39;, &#39;, @duplicates) . &quot;\n&quot;;
 66 }
 67 
 68 open GPERF, &quot;&gt;CSSValueKeywords.gperf&quot; || die &quot;Could not open CSSValueKeywords.gperf for writing&quot;;
 69 print GPERF &lt;&lt; &quot;EOF&quot;;
 70 %{
 71 /* This file is automatically generated from CSSValueKeywords.in by makevalues, do not edit */
 72 
 73 #include \&quot;config.h\&quot;
 74 #include \&quot;CSSValueKeywords.h\&quot;
 75 #include \&quot;HashTools.h\&quot;
 76 #include &lt;wtf/ASCIICType.h&gt;
<span class="line-modified"> 77 #include &lt;wtf/text/AtomString.h&gt;</span>
 78 #include &lt;wtf/text/WTFString.h&gt;
 79 #include &lt;string.h&gt;
 80 
 81 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 82 
 83 // Older versions of gperf like to use the `register` keyword.
 84 #define register
 85 
 86 namespace WebCore {
 87 %}
 88 %struct-type
 89 struct Value;
 90 %omit-struct-type
 91 %language=C++
 92 %readonly-tables
 93 %compare-strncmp
 94 %define class-name CSSValueKeywordsHash
 95 %define lookup-function-name findValueImpl
 96 %define hash-function-name value_hash_function
 97 %define word-array-name value_word_list
</pre>
<hr />
<pre>
114 foreach my $name (@names) {
115   print GPERF &quot;    \&quot;&quot; . $name . &quot;\&quot;,\n&quot;;
116 }
117 
118 print GPERF &lt;&lt; &quot;EOF&quot;;
119     0
120 };
121 
122 const Value* findValue(const char* str, unsigned int len)
123 {
124     return CSSValueKeywordsHash::findValueImpl(str, len);
125 }
126 
127 const char* getValueName(unsigned short id)
128 {
129     if (id &gt; lastCSSValueKeyword)
130         return 0;
131     return valueList[id];
132 }
133 
<span class="line-modified">134 const AtomString&amp; getValueNameAtomString(CSSValueID id)</span>
135 {
136     if (id &lt; firstCSSValueKeyword || id &gt; lastCSSValueKeyword)
137         return nullAtom();
138 
<span class="line-modified">139     static AtomString* valueKeywordStrings = new AtomString[numCSSValueKeywords]; // Leaked intentionally.</span>
<span class="line-modified">140     AtomString&amp; valueKeywordString = valueKeywordStrings[id];</span>
141     if (valueKeywordString.isNull())
142         valueKeywordString = getValueName(id);
143     return valueKeywordString;
144 }
145 
146 String getValueNameString(CSSValueID id)
147 {
<span class="line-modified">148     // We share the StringImpl with the AtomStrings.</span>
<span class="line-modified">149     return getValueNameAtomString(id).string();</span>
150 }
151 
152 } // namespace WebCore
153 
154 IGNORE_WARNINGS_END
155 EOF
156 close GPERF;
157 
158 
159 open HEADER, &quot;&gt;CSSValueKeywords.h&quot; || die &quot;Could not open CSSValueKeywords.h for writing&quot;;
160 print HEADER &lt;&lt; &quot;EOF&quot;;
161 /* This file is automatically generated from CSSValueKeywords.in by makevalues, do not edit */
162 
163 #pragma once
164 
165 #include &lt;string.h&gt;
166 #include &lt;wtf/Forward.h&gt;
167 
168 namespace WebCore {
169 
</pre>
<hr />
<pre>
177 foreach my $name (@names) {
178   my $id = $name;
179   $id =~ s/(^[^-])|-(.)/uc($1||$2)/ge;
180   print HEADER &quot;    CSSValue&quot; . $id . &quot; = &quot; . $i . &quot;,\n&quot;;
181   $i = $i + 1;
182   if (length($name) &gt; $maxLen) {
183     $maxLen = length($name);
184   }
185 }
186 my $num = $i - $first;
187 my $last = $i - 1;
188 
189 print HEADER &quot;};\n\n&quot;;
190 print HEADER &quot;const int firstCSSValueKeyword = $first;\n&quot;;
191 print HEADER &quot;const int numCSSValueKeywords = $num;\n&quot;;
192 print HEADER &quot;const int lastCSSValueKeyword = $last;\n&quot;;
193 print HEADER &quot;const size_t maxCSSValueKeywordLength = &quot; . $maxLen . &quot;;\n&quot;;
194 print HEADER &lt;&lt; &quot;EOF&quot;;
195 
196 const char* getValueName(unsigned short id);
<span class="line-modified">197 const WTF::AtomString&amp; getValueNameAtomString(CSSValueID id);</span>
198 WTF::String getValueNameString(CSSValueID id);
199 
200 inline CSSValueID convertToCSSValueID(int value)
201 {
202     ASSERT(value &gt;= firstCSSValueKeyword &amp;&amp; value &lt;= lastCSSValueKeyword);
203     return static_cast&lt;CSSValueID&gt;(value);
204 }
205 
206 } // namespace WebCore
207 EOF
208 close HEADER;
209 
210 if (not $gperf) {
211     $gperf = $ENV{GPERF} ? $ENV{GPERF} : &quot;gperf&quot;;
212 }
213 system(&quot;\&quot;$gperf\&quot; --key-positions=\&quot;*\&quot; -D -n -s 2 CSSValueKeywords.gperf --output-file=CSSValueKeywords.cpp&quot;) == 0 || die &quot;calling gperf failed: $?&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="makeprop.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="mathml.css.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>