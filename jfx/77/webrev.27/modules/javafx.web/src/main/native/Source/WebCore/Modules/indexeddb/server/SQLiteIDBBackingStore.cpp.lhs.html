<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SQLiteIDBBackingStore.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
<a name="1" id="anc1"></a>
  32 #include &quot;IDBGetAllRecordsData.h&quot;
  33 #include &quot;IDBGetAllResult.h&quot;
  34 #include &quot;IDBGetRecordData.h&quot;
  35 #include &quot;IDBGetResult.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyData.h&quot;
  38 #include &quot;IDBObjectStoreInfo.h&quot;
  39 #include &quot;IDBSerialization.h&quot;
<a name="2" id="anc2"></a>
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;IndexKey.h&quot;
  43 #include &quot;Logging.h&quot;
  44 #include &quot;SQLiteDatabase.h&quot;
  45 #include &quot;SQLiteFileSystem.h&quot;
  46 #include &quot;SQLiteIDBCursor.h&quot;
  47 #include &quot;SQLiteStatement.h&quot;
  48 #include &quot;SQLiteTransaction.h&quot;
  49 #include &quot;ThreadSafeDataBuffer.h&quot;
  50 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<a name="3" id="anc3"></a><span class="line-modified">  51 #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
<span class="line-removed">  52 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;</span>
<span class="line-removed">  53 #include &lt;JavaScriptCore/JSGlobalObject.h&gt;</span>
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<a name="4" id="anc4"></a><span class="line-removed">  55 #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  56 #include &lt;wtf/FileSystem.h&gt;
  57 #include &lt;wtf/NeverDestroyed.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 namespace IDBServer {
  63 
  64 // Current version of the metadata schema being used in the metadata database.
  65 static const int currentMetadataVersion = 1;
  66 
  67 // The IndexedDatabase spec defines the max key generator value as 2^53.
  68 static const uint64_t maxGeneratorValue = 0x20000000000000;
  69 
  70 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  71 {
  72     IDBKeyData a, b;
  73     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  74         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  75 
  76         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  77         // We arbitrarily choose &quot;A &gt; B&quot;
  78         return 1;
  79     }
  80     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(bBuffer), bLength, b)) {
  81         LOG_ERROR(&quot;Unable to deserialize key B in collation function.&quot;);
  82 
  83         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  84         // We arbitrarily choose &quot;A &gt; B&quot;
  85         return 1;
  86     }
  87 
  88     return a.compare(b);
  89 }
  90 
  91 static const String v1RecordsTableSchema(const String&amp; tableName)
  92 {
  93     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value NOT NULL ON CONFLICT FAIL)&quot;);
  94 }
  95 
  96 static const String&amp; v1RecordsTableSchema()
  97 {
  98     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;Records&quot;));
  99     return v1RecordsTableSchemaString;
 100 }
 101 
 102 static const String&amp; v1RecordsTableSchemaAlternate()
 103 {
 104     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 105     return v1RecordsTableSchemaString;
 106 }
 107 
 108 static const String v2RecordsTableSchema(const String&amp; tableName)
 109 {
 110     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 111 }
 112 
 113 static const String&amp; v2RecordsTableSchema()
 114 {
 115     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;Records&quot;));
 116     return v2RecordsTableSchemaString;
 117 }
 118 
 119 static const String&amp; v2RecordsTableSchemaAlternate()
 120 {
 121     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 122     return v2RecordsTableSchemaString;
 123 }
 124 
 125 static const String v3RecordsTableSchema(const String&amp; tableName)
 126 {
 127     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL, recordID INTEGER PRIMARY KEY)&quot;);
 128 }
 129 
 130 static const String&amp; v3RecordsTableSchema()
 131 {
 132     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;Records&quot;));
 133     return v3RecordsTableSchemaString;
 134 }
 135 
 136 static const String&amp; v3RecordsTableSchemaAlternate()
 137 {
 138     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 139     return v3RecordsTableSchemaString;
 140 }
 141 
 142 static const String v1IndexRecordsTableSchema(const String&amp; tableName)
 143 {
 144     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 145 }
 146 
 147 static const String&amp; v1IndexRecordsTableSchema()
 148 {
 149     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 150     return v1IndexRecordsTableSchemaString;
 151 }
 152 
 153 static const String&amp; v1IndexRecordsTableSchemaAlternate()
 154 {
 155     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 156     return v1IndexRecordsTableSchemaString;
 157 }
 158 
 159 static const String v2IndexRecordsTableSchema(const String&amp; tableName)
 160 {
 161     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL)&quot;);
 162 }
 163 
 164 static const String&amp; v2IndexRecordsTableSchema()
 165 {
 166     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 167     return v2IndexRecordsTableSchemaString;
 168 }
 169 
 170 static const String&amp; v2IndexRecordsTableSchemaAlternate()
 171 {
 172     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 173     return v2IndexRecordsTableSchemaString;
 174 }
 175 
 176 static const String v3IndexRecordsTableSchema(const String&amp; tableName)
 177 {
 178     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, objectStoreRecordID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 179 }
 180 
 181 static const String v3IndexRecordsTableSchema()
 182 {
 183     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;IndexRecords&quot;);
 184     return indexRecordsTableSchemaString;
 185 }
 186 
 187 static const String v3IndexRecordsTableSchemaAlternate()
 188 {
 189     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
 190     return indexRecordsTableSchemaString;
 191 }
 192 
 193 static const String&amp; v1IndexRecordsIndexSchema()
 194 {
 195     static NeverDestroyed&lt;WTF::String&gt; indexRecordsIndexSchemaString(&quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (key)&quot;);
 196     return indexRecordsIndexSchemaString;
 197 }
 198 
 199 static const String blobRecordsTableSchema(const String&amp; tableName)
 200 {
 201     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
 202 }
 203 
 204 static const String&amp; blobRecordsTableSchema()
 205 {
 206     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;BlobRecords&quot;));
 207     return blobRecordsTableSchemaString;
 208 }
 209 
 210 static const String&amp; blobRecordsTableSchemaAlternate()
 211 {
 212     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;\&quot;BlobRecords\&quot;&quot;));
 213     return blobRecordsTableSchemaString;
 214 }
 215 
 216 static const String blobFilesTableSchema(const String&amp; tableName)
 217 {
 218     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 219 }
 220 
 221 static const String&amp; blobFilesTableSchema()
 222 {
 223     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 224     return blobFilesTableSchemaString;
 225 }
 226 
 227 static const String&amp; blobFilesTableSchemaAlternate()
 228 {
 229     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 230     return blobFilesTableSchemaString;
 231 }
 232 
<a name="5" id="anc5"></a><span class="line-modified"> 233 SQLiteIDBBackingStore::SQLiteIDBBackingStore(const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, uint64_t quota)</span>
<span class="line-modified"> 234     : m_identifier(identifier)</span>


 235     , m_temporaryFileHandler(fileHandler)
<a name="6" id="anc6"></a><span class="line-modified"> 236     , m_quota(quota)</span>
 237 {
<a name="7" id="anc7"></a><span class="line-modified"> 238     m_absoluteDatabaseDirectory = identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory);</span>
 239 }
 240 
 241 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 242 {
 243     if (m_sqliteDB)
 244         closeSQLiteDB();
<a name="8" id="anc8"></a><span class="line-removed"> 245 </span>
<span class="line-removed"> 246     if (m_vm) {</span>
<span class="line-removed"> 247         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed"> 248         m_globalObject.clear();</span>
<span class="line-removed"> 249         m_vm = nullptr;</span>
<span class="line-removed"> 250     }</span>
<span class="line-removed"> 251 }</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254 void SQLiteIDBBackingStore::initializeVM()</span>
<span class="line-removed"> 255 {</span>
<span class="line-removed"> 256     if (!m_vm) {</span>
<span class="line-removed"> 257         ASSERT(!m_globalObject);</span>
<span class="line-removed"> 258         m_vm = VM::create();</span>
<span class="line-removed"> 259 </span>
<span class="line-removed"> 260         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed"> 261         m_globalObject.set(*m_vm, JSGlobalObject::create(*m_vm, JSGlobalObject::createStructure(*m_vm, jsNull())));</span>
<span class="line-removed"> 262     }</span>
<span class="line-removed"> 263 }</span>
<span class="line-removed"> 264 </span>
<span class="line-removed"> 265 VM&amp; SQLiteIDBBackingStore::vm()</span>
<span class="line-removed"> 266 {</span>
<span class="line-removed"> 267     initializeVM();</span>
<span class="line-removed"> 268     return *m_vm;</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271 JSGlobalObject&amp; SQLiteIDBBackingStore::globalObject()</span>
<span class="line-removed"> 272 {</span>
<span class="line-removed"> 273     initializeVM();</span>
<span class="line-removed"> 274     return **m_globalObject;</span>
 275 }
 276 
 277 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 278 {
 279     String currentSchema;
 280     {
 281         // Fetch the schema for an existing records table.
 282         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 283         if (statement.prepare() != SQLITE_OK) {
 284             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 285             return false;
 286         }
 287 
 288         int sqliteResult = statement.step();
 289 
 290         // If there is no Records table at all, create it and then bail.
 291         if (sqliteResult == SQLITE_DONE) {
 292             if (!database.executeCommand(v3RecordsTableSchema())) {
 293                 LOG_ERROR(&quot;Could not create Records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 294                 return false;
 295             }
 296 
 297             return true;
 298         }
 299 
 300         if (sqliteResult != SQLITE_ROW) {
 301             LOG_ERROR(&quot;Error executing statement to fetch schema for the Records table.&quot;);
 302             return false;
 303         }
 304 
 305         currentSchema = statement.getColumnText(1);
 306     }
 307 
 308     ASSERT(!currentSchema.isEmpty());
 309 
 310     // If the schema in the backing store is the current schema, we&#39;re done.
 311     if (currentSchema == v3RecordsTableSchema() || currentSchema == v3RecordsTableSchemaAlternate())
 312         return true;
 313 
 314     // If the record table is not the current schema then it must be one of the previous schemas.
 315     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 316     if (currentSchema != v1RecordsTableSchema() &amp;&amp; currentSchema != v1RecordsTableSchemaAlternate()
 317         &amp;&amp; currentSchema != v2RecordsTableSchema() &amp;&amp; currentSchema != v2RecordsTableSchemaAlternate())
 318         RELEASE_ASSERT_NOT_REACHED();
 319 
 320     SQLiteTransaction transaction(database);
 321     transaction.begin();
 322 
 323     // Create a temporary table with the correct schema and migrate all existing content over.
 324     if (!database.executeCommand(v3RecordsTableSchema(&quot;_Temp_Records&quot;))) {
 325         LOG_ERROR(&quot;Could not create temporary records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 326         return false;
 327     }
 328 
 329     if (!database.executeCommand(&quot;INSERT INTO _Temp_Records (objectStoreID, key, value) SELECT objectStoreID, CAST(key AS TEXT), value FROM Records&quot;)) {
 330         LOG_ERROR(&quot;Could not migrate existing Records content (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 331         return false;
 332     }
 333 
 334     if (!database.executeCommand(&quot;DROP TABLE Records&quot;)) {
 335         LOG_ERROR(&quot;Could not drop existing Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 336         return false;
 337     }
 338 
 339     if (!database.executeCommand(&quot;ALTER TABLE _Temp_Records RENAME TO Records&quot;)) {
 340         LOG_ERROR(&quot;Could not rename temporary Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 341         return false;
 342     }
 343 
 344     transaction.commit();
 345 
 346     return true;
 347 }
 348 
 349 bool SQLiteIDBBackingStore::ensureValidBlobTables()
 350 {
 351     ASSERT(m_sqliteDB);
 352     ASSERT(m_sqliteDB-&gt;isOpen());
 353 
 354     String currentSchema;
 355     {
 356         // Fetch the schema for an existing blob record table.
 357         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobRecords&#39;&quot;);
 358         if (statement.prepare() != SQLITE_OK) {
 359             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobRecords table.&quot;);
 360             return false;
 361         }
 362 
 363         int sqliteResult = statement.step();
 364 
 365         // If there is no BlobRecords table at all, create it..
 366         if (sqliteResult == SQLITE_DONE) {
 367             if (!m_sqliteDB-&gt;executeCommand(blobRecordsTableSchema())) {
 368                 LOG_ERROR(&quot;Could not create BlobRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 369                 return false;
 370             }
 371 
 372             currentSchema = blobRecordsTableSchema();
 373         } else if (sqliteResult != SQLITE_ROW) {
 374             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobRecords table.&quot;);
 375             return false;
 376         } else
 377             currentSchema = statement.getColumnText(1);
 378     }
 379 
 380     if (currentSchema != blobRecordsTableSchema() &amp;&amp; currentSchema != blobRecordsTableSchemaAlternate()) {
 381         LOG_ERROR(&quot;Invalid BlobRecords table schema found&quot;);
 382         return false;
 383     }
 384 
 385     {
 386         // Fetch the schema for an existing blob file table.
 387         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobFiles&#39;&quot;);
 388         if (statement.prepare() != SQLITE_OK) {
 389             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobFiles table.&quot;);
 390             return false;
 391         }
 392 
 393         int sqliteResult = statement.step();
 394 
 395         // If there is no BlobFiles table at all, create it and then bail.
 396         if (sqliteResult == SQLITE_DONE) {
 397             if (!m_sqliteDB-&gt;executeCommand(blobFilesTableSchema())) {
 398                 LOG_ERROR(&quot;Could not create BlobFiles table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 399                 return false;
 400             }
 401 
 402             return true;
 403         }
 404 
 405         if (sqliteResult != SQLITE_ROW) {
 406             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobFiles table.&quot;);
 407             return false;
 408         }
 409 
 410         currentSchema = statement.getColumnText(1);
 411     }
 412 
 413     if (currentSchema != blobFilesTableSchema() &amp;&amp; currentSchema != blobFilesTableSchemaAlternate()) {
 414         LOG_ERROR(&quot;Invalid BlobFiles table schema found&quot;);
 415         return false;
 416     }
 417 
 418     return true;
 419 }
 420 
 421 bool SQLiteIDBBackingStore::ensureValidRecordsTable()
 422 {
 423     ASSERT(m_sqliteDB);
 424     ASSERT(m_sqliteDB-&gt;isOpen());
 425 
 426     if (!createOrMigrateRecordsTableIfNecessary(*m_sqliteDB))
 427         return false;
 428 
 429     // Whether the updated records table already existed or if it was just created and the data migrated over,
 430     // make sure the uniqueness index exists.
 431     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE UNIQUE INDEX IF NOT EXISTS RecordsIndex ON Records (objectStoreID, key);&quot;)) {
 432         LOG_ERROR(&quot;Could not create RecordsIndex on Records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 433         return false;
 434     }
 435 
 436     return true;
 437 }
 438 
 439 bool SQLiteIDBBackingStore::ensureValidIndexRecordsTable()
 440 {
 441     ASSERT(m_sqliteDB);
 442     ASSERT(m_sqliteDB-&gt;isOpen());
 443 
 444     String currentSchema;
 445     {
 446         // Fetch the schema for an existing index record table.
 447         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;IndexRecords&#39;&quot;);
 448         if (statement.prepare() != SQLITE_OK) {
 449             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecords table.&quot;);
 450             return false;
 451         }
 452 
 453         int sqliteResult = statement.step();
 454 
 455         // If there is no IndexRecords table at all, create it and then bail.
 456         if (sqliteResult == SQLITE_DONE) {
 457             if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema())) {
 458                 LOG_ERROR(&quot;Could not create IndexRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 459                 return false;
 460             }
 461 
 462             return true;
 463         }
 464 
 465         if (sqliteResult != SQLITE_ROW) {
 466             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecords table.&quot;);
 467             return false;
 468         }
 469 
 470         currentSchema = statement.getColumnText(1);
 471     }
 472 
 473     ASSERT(!currentSchema.isEmpty());
 474 
 475     // If the schema in the backing store is the current schema, we&#39;re done.
 476     if (currentSchema == v3IndexRecordsTableSchema() || currentSchema == v3IndexRecordsTableSchemaAlternate())
 477         return true;
 478 
 479     // If the record table is not the current schema then it must be one of the previous schemas.
 480     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 481     if (currentSchema != v1IndexRecordsTableSchema() &amp;&amp; currentSchema != v1IndexRecordsTableSchemaAlternate()
 482         &amp;&amp; currentSchema != v2IndexRecordsTableSchema() &amp;&amp; currentSchema != v2IndexRecordsTableSchemaAlternate())
 483         RELEASE_ASSERT_NOT_REACHED();
 484 
 485     SQLiteTransaction transaction(*m_sqliteDB);
 486     transaction.begin();
 487 
 488     // Create a temporary table with the correct schema and migrate all existing content over.
 489     if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema(&quot;_Temp_IndexRecords&quot;))) {
 490         LOG_ERROR(&quot;Could not create temporary index records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 491         return false;
 492     }
 493 
 494     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_IndexRecords SELECT IndexRecords.indexID, IndexRecords.objectStoreID, IndexRecords.key, IndexRecords.value, Records.rowid FROM IndexRecords INNER JOIN Records ON Records.key = IndexRecords.value AND Records.objectStoreID = IndexRecords.objectStoreID&quot;)) {
 495         LOG_ERROR(&quot;Could not migrate existing IndexRecords content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 496         return false;
 497     }
 498 
 499     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE IndexRecords&quot;)) {
 500         LOG_ERROR(&quot;Could not drop existing IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 501         return false;
 502     }
 503 
 504     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_IndexRecords RENAME TO IndexRecords&quot;)) {
 505         LOG_ERROR(&quot;Could not rename temporary IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 506         return false;
 507     }
 508 
 509     transaction.commit();
 510 
 511     return true;
 512 }
 513 
 514 bool SQLiteIDBBackingStore::ensureValidIndexRecordsIndex()
 515 {
 516     ASSERT(m_sqliteDB);
 517     ASSERT(m_sqliteDB-&gt;isOpen());
 518 
 519     String currentSchema;
 520     {
 521         // Fetch the schema for an existing index record index.
 522         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsIndex&#39;&quot;);
 523         if (statement.prepare() != SQLITE_OK) {
 524             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsIndex index.&quot;);
 525             return false;
 526         }
 527 
 528         int sqliteResult = statement.step();
 529 
 530         // If there is no IndexRecordsIndex index at all, create it and then bail.
 531         if (sqliteResult == SQLITE_DONE) {
 532             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsIndexSchema())) {
 533                 LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 534                 return false;
 535             }
 536 
 537             return true;
 538         }
 539 
 540         if (sqliteResult != SQLITE_ROW) {
 541             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsIndex index.&quot;);
 542             return false;
 543         }
 544 
 545         currentSchema = statement.getColumnText(0);
 546     }
 547 
 548     ASSERT(!currentSchema.isEmpty());
 549 
 550     // If the schema in the backing store is the current schema, we&#39;re done.
 551     if (currentSchema == v1IndexRecordsIndexSchema())
 552         return true;
 553 
 554     // There is currently no outdated schema for the IndexRecordsIndex, so any other existing schema means this database is invalid.
 555     return false;
 556 }
 557 
 558 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 559 {
 560     ASSERT(m_sqliteDB);
 561     ASSERT(m_sqliteDB-&gt;isOpen());
 562 
 563     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IDBDatabaseInfo (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
 564         LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 565         closeSQLiteDB();
 566         return nullptr;
 567     }
 568 
 569     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 570         LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 571         closeSQLiteDB();
 572         return nullptr;
 573     }
 574 
 575     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IndexInfo (id INTEGER NOT NULL ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, isUnique INTEGER NOT NULL ON CONFLICT FAIL, multiEntry INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 576         LOG_ERROR(&quot;Could not create IndexInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 577         closeSQLiteDB();
 578         return nullptr;
 579     }
 580 
 581     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE KeyGenerators (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, currentKey INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 582         LOG_ERROR(&quot;Could not create KeyGenerators table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 583         closeSQLiteDB();
 584         return nullptr;
 585     }
 586 
 587     {
 588         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MetadataVersion&#39;, ?);&quot;_s);
 589         if (sql.prepare() != SQLITE_OK
 590             || sql.bindInt(1, currentMetadataVersion) != SQLITE_OK
 591             || sql.step() != SQLITE_DONE) {
 592             LOG_ERROR(&quot;Could not insert database metadata version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 593             closeSQLiteDB();
 594             return nullptr;
 595         }
 596     }
 597     {
 598         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseName&#39;, ?);&quot;_s);
 599         if (sql.prepare() != SQLITE_OK
 600             || sql.bindText(1, m_identifier.databaseName()) != SQLITE_OK
 601             || sql.step() != SQLITE_DONE) {
 602             LOG_ERROR(&quot;Could not insert database name into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 603             closeSQLiteDB();
 604             return nullptr;
 605         }
 606     }
 607     {
 608         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 609         // Therefore we&#39;ll store the version as a String.
 610         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 611         if (sql.prepare() != SQLITE_OK
 612             || sql.bindText(1, String::number(0)) != SQLITE_OK
 613             || sql.step() != SQLITE_DONE) {
 614             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 615             closeSQLiteDB();
 616             return nullptr;
 617         }
 618     }
 619 
 620     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 621         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 622         closeSQLiteDB();
 623         return nullptr;
 624     }
 625 
 626     // This initial database info matches the default values we just put into the metadata database.
<a name="9" id="anc9"></a><span class="line-modified"> 627     return std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
 628 }
 629 
 630 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 631 {
 632     ASSERT(m_sqliteDB);
 633 
 634     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 635         return nullptr;
 636 
 637     String databaseName;
 638     {
 639         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 640         if (sql.isColumnNull(0))
 641             return nullptr;
 642         databaseName = sql.getColumnText(0);
 643         if (databaseName != m_identifier.databaseName()) {
 644             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 645             return nullptr;
 646         }
 647     }
 648     uint64_t databaseVersion;
 649     {
 650         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 651         if (sql.isColumnNull(0))
 652             return nullptr;
 653         String stringVersion = sql.getColumnText(0);
 654         bool ok;
 655         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 656         if (!ok) {
 657             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 658             return nullptr;
 659         }
 660     }
 661 
<a name="10" id="anc10"></a><span class="line-modified"> 662     auto databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
 663 
 664     {
 665         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
 666         if (sql.prepare() != SQLITE_OK)
 667             return nullptr;
 668 
 669         int result = sql.step();
 670         while (result == SQLITE_ROW) {
 671             uint64_t objectStoreID = sql.getColumnInt64(0);
 672             String objectStoreName = sql.getColumnText(1);
 673 
 674             Vector&lt;char&gt; keyPathBuffer;
 675             sql.getColumnBlobAsVector(2, keyPathBuffer);
 676 
 677             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 678             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 679                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 680                 return nullptr;
 681             }
 682 
 683             bool autoIncrement = sql.getColumnInt(3);
 684 
 685             databaseInfo-&gt;addExistingObjectStore({ objectStoreID, objectStoreName, WTFMove(objectStoreKeyPath), autoIncrement });
 686 
 687             result = sql.step();
 688         }
 689 
 690         if (result != SQLITE_DONE) {
 691             LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
 692             return nullptr;
 693         }
 694     }
 695 
 696     {
 697         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
 698         if (sql.prepare() != SQLITE_OK)
 699             return nullptr;
 700 
 701         int result = sql.step();
 702         while (result == SQLITE_ROW) {
 703             uint64_t indexID = sql.getColumnInt64(0);
 704             String indexName = sql.getColumnText(1);
 705             uint64_t objectStoreID = sql.getColumnInt64(2);
 706 
 707             Vector&lt;char&gt; keyPathBuffer;
 708             sql.getColumnBlobAsVector(3, keyPathBuffer);
 709 
 710             Optional&lt;IDBKeyPath&gt; indexKeyPath;
 711             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), indexKeyPath)) {
 712                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 713                 return nullptr;
 714             }
 715             if (!indexKeyPath) {
 716                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 717                 return nullptr;
 718             }
 719 
 720             bool unique = sql.getColumnInt(4);
 721             bool multiEntry = sql.getColumnInt(5);
 722 
 723             auto objectStore = databaseInfo-&gt;infoForExistingObjectStore(objectStoreID);
 724             if (!objectStore) {
 725                 LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
 726                 return nullptr;
 727             }
 728 
 729             objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
 730 
 731             result = sql.step();
 732         }
 733 
 734         if (result != SQLITE_DONE) {
 735             LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
 736             return nullptr;
 737         }
 738     }
 739 
 740     return databaseInfo;
 741 }
 742 
 743 String SQLiteIDBBackingStore::databaseNameFromEncodedFilename(const String&amp; encodedName)
 744 {
 745     if (encodedName == &quot;%00&quot;_s)
 746         return { };
 747 
 748     String partiallyDecoded = encodedName;
 749     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 750 
 751     return FileSystem::decodeFromFilename(partiallyDecoded);
 752 }
 753 
 754 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 755 {
 756     ASSERT(!m_identifier.databaseName().isNull());
 757 
 758     if (m_identifier.databaseName().isEmpty())
 759         return &quot;%00&quot;;
 760 
 761     String filename = FileSystem::encodeForFileName(m_identifier.databaseName());
 762     filename.replace(&#39;.&#39;, &quot;%2E&quot;);
 763 
 764     return filename;
 765 }
 766 
<a name="11" id="anc11"></a><span class="line-modified"> 767 String SQLiteIDBBackingStore::fullDatabaseDirectory() const</span>
 768 {
<a name="12" id="anc12"></a><span class="line-modified"> 769     ASSERT(!m_identifier.databaseName().isNull());</span>
<span class="line-removed"> 770 </span>
<span class="line-removed"> 771     return FileSystem::pathByAppendingComponent(m_absoluteDatabaseDirectory, filenameForDatabaseName());</span>
 772 }
 773 
 774 String SQLiteIDBBackingStore::fullDatabasePath() const
 775 {
<a name="13" id="anc13"></a><span class="line-modified"> 776     ASSERT(!m_identifier.databaseName().isNull());</span>

 777 
<a name="14" id="anc14"></a><span class="line-modified"> 778     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory(), &quot;IndexedDB.sqlite3&quot;);</span>


































 779 }
 780 
 781 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 782 {
 783     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
 784 
 785     if (m_databaseInfo) {
 786         info = *m_databaseInfo;
 787         return IDBError { };
 788     }
 789 
<a name="15" id="anc15"></a><span class="line-removed"> 790     FileSystem::makeAllDirectories(fullDatabaseDirectory());</span>
 791     String dbFilename = fullDatabasePath();
 792 
<a name="16" id="anc16"></a><span class="line-modified"> 793     m_sqliteDB = std::make_unique&lt;SQLiteDatabase&gt;();</span>
 794     if (!m_sqliteDB-&gt;open(dbFilename)) {
 795         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 796         closeSQLiteDB();
 797     }
 798 
 799     if (!m_sqliteDB)
 800         return IDBError { UnknownError, &quot;Unable to open database file on disk&quot;_s };
 801 
 802     m_sqliteDB-&gt;setCollationFunction(&quot;IDBKEY&quot;, [](int aLength, const void* a, int bLength, const void* b) {
 803         return idbKeyCollate(aLength, a, bLength, b);
 804     });
 805 
 806     if (!ensureValidRecordsTable()) {
 807         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 808         closeSQLiteDB();
 809         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 810     }
 811 
 812     if (!ensureValidIndexRecordsTable()) {
 813         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
 814         closeSQLiteDB();
 815         return IDBError { UnknownError, &quot;Error creating or migrating Index Records table in database&quot;_s };
 816     }
 817 
 818     if (!ensureValidIndexRecordsIndex()) {
 819         LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
 820         closeSQLiteDB();
 821         return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
 822     }
 823 
 824     if (!ensureValidBlobTables()) {
 825         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
 826         closeSQLiteDB();
 827         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
 828     }
 829 
 830     auto databaseInfo = extractExistingDatabaseInfo();
 831     if (!databaseInfo)
 832         databaseInfo = createAndPopulateInitialDatabaseInfo();
 833 
 834     if (!databaseInfo) {
 835         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 836         closeSQLiteDB();
 837         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
 838     }
 839 
 840     m_databaseInfo = WTFMove(databaseInfo);
 841     info = *m_databaseInfo;
 842     return IDBError { };
 843 }
 844 
<a name="17" id="anc17"></a><span class="line-modified"> 845 uint64_t SQLiteIDBBackingStore::quotaForOrigin() const</span>
<span class="line-removed"> 846 {</span>
<span class="line-removed"> 847     ASSERT(!isMainThread());</span>
<span class="line-removed"> 848     uint64_t diskFreeSpaceSize = 0;</span>
<span class="line-removed"> 849     FileSystem::getVolumeFreeSpace(m_absoluteDatabaseDirectory, diskFreeSpaceSize);</span>
<span class="line-removed"> 850     return std::min(diskFreeSpaceSize / 2, m_quota);</span>
<span class="line-removed"> 851 }</span>
<span class="line-removed"> 852 </span>
<span class="line-removed"> 853 uint64_t SQLiteIDBBackingStore::maximumSize() const</span>
 854 {
<a name="18" id="anc18"></a><span class="line-removed"> 855     ASSERT(!isMainThread());</span>
<span class="line-removed"> 856 </span>
<span class="line-removed"> 857     // The maximum size for one database file is the quota for its origin, minus size of all databases within that origin,</span>
<span class="line-removed"> 858     // and plus current size of the database file.</span>
<span class="line-removed"> 859     uint64_t databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
<span class="line-removed"> 860     uint64_t quota = quotaForOrigin();</span>
<span class="line-removed"> 861 </span>
 862     uint64_t diskUsage = 0;
<a name="19" id="anc19"></a><span class="line-modified"> 863     for (auto&amp; directory : FileSystem::listDirectory(m_absoluteDatabaseDirectory, &quot;*&quot;)) {</span>
<span class="line-modified"> 864         for (auto&amp; file : FileSystem::listDirectory(directory, &quot;*.sqlite3&quot;_s))</span>
 865             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
 866     }
<a name="20" id="anc20"></a><span class="line-modified"> 867     ASSERT(diskUsage &gt;= databaseFileSize);</span>
<span class="line-modified"> 868 </span>
<span class="line-removed"> 869     if (quota &lt; diskUsage)</span>
<span class="line-removed"> 870         return databaseFileSize;</span>
 871 
<a name="21" id="anc21"></a><span class="line-modified"> 872     return quota - diskUsage + databaseFileSize;</span>



 873 }
 874 
 875 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 876 {
 877     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
 878 
 879     ASSERT(m_sqliteDB);
 880     ASSERT(m_sqliteDB-&gt;isOpen());
 881     ASSERT(m_databaseInfo);
 882 
<a name="22" id="anc22"></a><span class="line-removed"> 883     m_sqliteDB-&gt;setMaximumSize(maximumSize());</span>
 884     auto addResult = m_transactions.add(info.identifier(), nullptr);
 885     if (!addResult.isNewEntry) {
 886         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
 887         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
 888     }
 889 
<a name="23" id="anc23"></a><span class="line-modified"> 890     addResult.iterator-&gt;value = std::make_unique&lt;SQLiteIDBTransaction&gt;(*this, info);</span>
 891 
 892     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
 893     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
<a name="24" id="anc24"></a><span class="line-modified"> 894         m_originalDatabaseInfoBeforeVersionChange = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);</span>
 895 
 896         SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
 897         if (sql.prepare() != SQLITE_OK
 898             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
 899             || sql.step() != SQLITE_DONE) {
<a name="25" id="anc25"></a><span class="line-modified"> 900             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed"> 901                 error = IDBError { QuotaExceededError, &quot;Failed to store new database version in database because no enough space for domain&quot;_s };</span>
<span class="line-removed"> 902             else</span>
<span class="line-removed"> 903                 error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };</span>
 904         }
 905     }
 906 
 907     return error;
 908 }
 909 
 910 IDBError SQLiteIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; identifier)
 911 {
 912     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::abortTransaction - %s&quot;, identifier.loggingString().utf8().data());
 913 
 914     ASSERT(m_sqliteDB);
 915     ASSERT(m_sqliteDB-&gt;isOpen());
 916 
 917     auto transaction = m_transactions.take(identifier);
 918     if (!transaction) {
 919         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 920         return IDBError { UnknownError, &quot;Attempt to abort a transaction that hasn&#39;t been established&quot;_s };
 921     }
 922 
 923     if (transaction-&gt;mode() == IDBTransactionMode::Versionchange &amp;&amp; m_originalDatabaseInfoBeforeVersionChange)
 924         m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 925 
 926     return transaction-&gt;abort();
 927 }
 928 
 929 IDBError SQLiteIDBBackingStore::commitTransaction(const IDBResourceIdentifier&amp; identifier)
 930 {
 931     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::commitTransaction - %s&quot;, identifier.loggingString().utf8().data());
 932 
 933     ASSERT(m_sqliteDB);
 934     ASSERT(m_sqliteDB-&gt;isOpen());
 935 
 936     auto transaction = m_transactions.take(identifier);
 937     if (!transaction) {
 938         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
 939         return IDBError { UnknownError, &quot;Attempt to commit a transaction that hasn&#39;t been established&quot;_s };
 940     }
 941 
 942     auto error = transaction-&gt;commit();
 943     if (!error.isNull()) {
 944         if (transaction-&gt;mode() == IDBTransactionMode::Versionchange) {
 945             ASSERT(m_originalDatabaseInfoBeforeVersionChange);
 946             m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
 947         }
 948     } else
 949         m_originalDatabaseInfoBeforeVersionChange = nullptr;
 950 
 951     return error;
 952 }
 953 
 954 IDBError SQLiteIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 955 {
 956     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
 957 
 958     ASSERT(m_sqliteDB);
 959     ASSERT(m_sqliteDB-&gt;isOpen());
 960 
 961     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="26" id="anc26"></a><span class="line-modified"> 962     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed"> 963         LOG_ERROR(&quot;Attempt to create an object store without an in-progress transaction&quot;);</span>
 964         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
<a name="27" id="anc27"></a><span class="line-modified"> 965     }</span>
 966     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
 967         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
 968         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
 969     }
 970 
 971     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
 972     if (!keyPathBlob) {
 973         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
 974         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
 975     }
 976 
 977     {
 978         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);
 979         if (!sql
 980             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 981             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
 982             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
 983             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
 984             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK
 985             || sql-&gt;step() != SQLITE_DONE) {
 986             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="28" id="anc28"></a><span class="line-removed"> 987             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed"> 988                 return IDBError { QuotaExceededError, &quot;Could not create object store because no enough space for domain&quot;_s };</span>
 989             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
 990         }
 991     }
 992 
 993     {
 994         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
 995         if (!sql
 996             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 997             || sql-&gt;step() != SQLITE_DONE) {
 998             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="29" id="anc29"></a><span class="line-removed"> 999             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1000                 return IDBError { QuotaExceededError, &quot;Could not seed initial key generator value for object store because no enough space for domain&quot;_s };</span>
1001             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
1002         }
1003     }
1004 
1005     m_databaseInfo-&gt;addExistingObjectStore(info);
1006 
1007     return IDBError { };
1008 }
1009 
1010 IDBError SQLiteIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1011 {
1012     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1013 
1014     ASSERT(m_sqliteDB);
1015     ASSERT(m_sqliteDB-&gt;isOpen());
1016 
1017     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="30" id="anc30"></a><span class="line-modified">1018     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1019         LOG_ERROR(&quot;Attempt to delete an object store without an in-progress transaction&quot;);</span>
1020         return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
<a name="31" id="anc31"></a><span class="line-modified">1021     }</span>
1022     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1023         LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
1024         return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
1025     }
1026 
1027     // Delete the ObjectStore record
1028     {
1029         auto* sql = cachedStatement(SQL::DeleteObjectStoreInfo, &quot;DELETE FROM ObjectStoreInfo WHERE id = ?;&quot;_s);
1030         if (!sql
1031             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1032             || sql-&gt;step() != SQLITE_DONE) {
1033             LOG_ERROR(&quot;Could not delete object store id %&quot; PRIi64 &quot; from ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1034             return IDBError { UnknownError, &quot;Could not delete object store&quot;_s };
1035         }
1036     }
1037 
1038     // Delete the ObjectStore&#39;s key generator record if there is one.
1039     {
1040         auto* sql = cachedStatement(SQL::DeleteObjectStoreKeyGenerator, &quot;DELETE FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
1041         if (!sql
1042             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1043             || sql-&gt;step() != SQLITE_DONE) {
1044             LOG_ERROR(&quot;Could not delete object store from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1045             return IDBError { UnknownError, &quot;Could not delete key generator for deleted object store&quot;_s };
1046         }
1047     }
1048 
1049     // Delete all associated records
1050     {
1051         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1052         if (!sql
1053             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1054             || sql-&gt;step() != SQLITE_DONE) {
1055             LOG_ERROR(&quot;Could not delete records for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1056             return IDBError { UnknownError, &quot;Could not delete records for deleted object store&quot;_s };
1057         }
1058     }
1059 
1060     // Delete all associated Indexes
1061     {
1062         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexInfo, &quot;DELETE FROM IndexInfo WHERE objectStoreID = ?;&quot;_s);
1063         if (!sql
1064             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1065             || sql-&gt;step() != SQLITE_DONE) {
1066             LOG_ERROR(&quot;Could not delete index from IndexInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1067             return IDBError { UnknownError, &quot;Could not delete IDBIndex for deleted object store&quot;_s };
1068         }
1069     }
1070 
1071     // Delete all associated Index records
1072     {
1073         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1074         if (!sql
1075             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1076             || sql-&gt;step() != SQLITE_DONE) {
1077             LOG_ERROR(&quot;Could not delete index records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1078             return IDBError { UnknownError, &quot;Could not delete IDBIndex records for deleted object store&quot;_s };
1079         }
1080     }
1081 
1082     // Delete all unused Blob URL records.
1083     {
1084         auto* sql = cachedStatement(SQL::DeleteObjectStoreBlobRecords, &quot;DELETE FROM BlobRecords WHERE objectStoreRow NOT IN (SELECT recordID FROM Records)&quot;_s);
1085         if (!sql
1086             || sql-&gt;step() != SQLITE_DONE) {
1087             LOG_ERROR(&quot;Could not delete Blob URL records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1088             return IDBError { UnknownError, &quot;Could not delete stored blob records for deleted object store&quot;_s };
1089         }
1090     }
1091 
1092     // Delete all unused Blob File records.
1093     auto error = deleteUnusedBlobFileRecords(*transaction);
1094     if (!error.isNull())
1095         return error;
1096 
1097     m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
1098 
1099     return IDBError { };
1100 }
1101 
1102 IDBError SQLiteIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
1103 {
1104     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1105 
1106     ASSERT(m_sqliteDB);
1107     ASSERT(m_sqliteDB-&gt;isOpen());
1108 
1109     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="32" id="anc32"></a><span class="line-modified">1110     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1111         LOG_ERROR(&quot;Attempt to rename an object store without an in-progress transaction&quot;);</span>
1112         return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
<a name="33" id="anc33"></a><span class="line-modified">1113     }</span>
1114     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1115         LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
1116         return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
1117     }
1118 
1119     {
1120         auto* sql = cachedStatement(SQL::RenameObjectStore, &quot;UPDATE ObjectStoreInfo SET name = ? WHERE id = ?;&quot;_s);
1121         if (!sql
1122             || sql-&gt;bindText(1, newName) != SQLITE_OK
1123             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1124             || sql-&gt;step() != SQLITE_DONE) {
1125             LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="34" id="anc34"></a><span class="line-removed">1126             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1127                 return IDBError { QuotaExceededError, &quot;Could not rename object store because no enough space for domain&quot;_s };</span>
1128             return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
1129         }
1130     }
1131 
1132     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
1133 
1134     return IDBError { };
1135 }
1136 
1137 IDBError SQLiteIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID)
1138 {
1139     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::clearObjectStore - object store %&quot; PRIu64, objectStoreID);
1140 
1141     ASSERT(m_sqliteDB);
1142     ASSERT(m_sqliteDB-&gt;isOpen());
1143 
1144     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="35" id="anc35"></a><span class="line-modified">1145     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1146         LOG_ERROR(&quot;Attempt to clear an object store without an in-progress transaction&quot;);</span>
1147         return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
<a name="36" id="anc36"></a><span class="line-modified">1148     }</span>
1149     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1150         LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
1151         return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
1152     }
1153 
1154     {
1155         auto* sql = cachedStatement(SQL::ClearObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1156         if (!sql
1157             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1158             || sql-&gt;step() != SQLITE_DONE) {
1159             LOG_ERROR(&quot;Could not clear records from object store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1160             return IDBError { UnknownError, &quot;Unable to clear object store&quot;_s };
1161         }
1162     }
1163 
1164     {
1165         auto* sql = cachedStatement(SQL::ClearObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1166         if (!sql
1167             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1168             || sql-&gt;step() != SQLITE_DONE) {
1169             LOG_ERROR(&quot;Could not delete records from index record store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1170             return IDBError { UnknownError, &quot;Unable to delete index records while clearing object store&quot;_s };
1171         }
1172     }
1173 
1174     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1175 
1176     return IDBError { };
1177 }
1178 
1179 IDBError SQLiteIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1180 {
1181     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
1182     ASSERT(m_sqliteDB);
1183     ASSERT(m_sqliteDB-&gt;isOpen());
1184 
1185     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="37" id="anc37"></a><span class="line-modified">1186     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1187         LOG_ERROR(&quot;Attempt to create an index without an in-progress transaction&quot;);</span>
1188         return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
<a name="38" id="anc38"></a><span class="line-modified">1189     }</span>
1190     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1191         LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
1192         return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
1193     }
1194 
1195     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1196     if (!keyPathBlob) {
1197         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database&quot;);
1198         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to create index in database&quot;_s };
1199     }
1200 
1201     auto* sql = cachedStatement(SQL::CreateIndexInfo, &quot;INSERT INTO IndexInfo VALUES (?, ?, ?, ?, ?, ?);&quot;_s);
1202     if (!sql
1203         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1204         || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1205         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1206         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1207         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1208         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1209         || sql-&gt;step() != SQLITE_DONE) {
1210         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="39" id="anc39"></a><span class="line-removed">1211         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1212             return IDBError { QuotaExceededError, &quot;Unable to create index in database because no enough space for domain&quot;_s };</span>
1213         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1214     }
1215 
1216     // Write index records for any records that already exist in this object store.
1217 
1218     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1219 
1220     if (!cursor) {
1221         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1222         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1223     }
1224 
1225     while (!cursor-&gt;currentKey().isNull()) {
1226         auto&amp; key = cursor-&gt;currentKey();
1227         auto* value = cursor-&gt;currentValue();
1228         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();
1229 
1230         ASSERT(cursor-&gt;currentRecordRowID());
1231 
1232         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1233         if (!error.isNull()) {
1234             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1235             if (!sql
1236                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1237                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1238                 || sql-&gt;step() != SQLITE_DONE) {
1239                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1240                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1241             }
1242 
1243             return error;
1244         }
1245 
1246         if (!cursor-&gt;advance(1)) {
1247             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1248             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1249         }
1250     }
1251 
<a name="40" id="anc40"></a>





1252     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1253     ASSERT(objectStore);
1254     objectStore-&gt;addExistingIndex(info);
1255 
1256     return IDBError { };
1257 }
1258 
1259 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1260 {
1261     hasRecord = false;
1262 
1263     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1264     if (!indexKeyBuffer) {
1265         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1266         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1267     }
1268 
1269     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1270     if (!sql
1271         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1272         || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1273         || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {
1274         LOG_ERROR(&quot;Error checking for index record in database&quot;);
1275         return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
1276     }
1277 
1278     int sqlResult = sql-&gt;step();
1279     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1280         return IDBError { };
1281 
1282     if (sqlResult != SQLITE_ROW) {
1283         // There was an error fetching the record from the database.
1284         LOG_ERROR(&quot;Could not check if key exists in index (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1285         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in index&quot;_s };
1286     }
1287 
1288     hasRecord = true;
1289     return IDBError { };
1290 }
1291 
1292 IDBError SQLiteIDBBackingStore::uncheckedPutIndexKey(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const IndexKey&amp; indexKey, int64_t recordID)
1293 {
1294     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexKey - (%&quot; PRIu64 &quot;) %s, %s&quot;, info.identifier(), key.loggingString().utf8().data(), indexKey.asOneKey().loggingString().utf8().data());
1295 
1296     Vector&lt;IDBKeyData&gt; indexKeys;
1297     if (info.multiEntry())
1298         indexKeys = indexKey.multiEntry();
1299     else
1300         indexKeys.append(indexKey.asOneKey());
1301 
1302     if (info.unique()) {
1303         bool hasRecord;
1304         IDBError error;
1305         for (auto&amp; indexKey : indexKeys) {
1306             if (!indexKey.isValid())
1307                 continue;
1308             error = uncheckedHasIndexRecord(info, indexKey, hasRecord);
1309             if (!error.isNull())
1310                 return error;
1311             if (hasRecord)
1312                 return IDBError(ConstraintError);
1313         }
1314     }
1315 
1316     for (auto&amp; indexKey : indexKeys) {
1317         if (!indexKey.isValid())
1318             continue;
1319         auto error = uncheckedPutIndexRecord(info.objectStoreIdentifier(), info.identifier(), key, indexKey, recordID);
1320         if (!error.isNull()) {
1321             LOG_ERROR(&quot;Unable to put index record for newly created index&quot;);
1322             return error;
1323         }
1324     }
1325 
1326     return IDBError { };
1327 }
1328 
1329 IDBError SQLiteIDBBackingStore::uncheckedPutIndexRecord(int64_t objectStoreID, int64_t indexID, const WebCore::IDBKeyData&amp; keyValue, const WebCore::IDBKeyData&amp; indexKey, int64_t recordID)
1330 {
1331     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexRecord - %s, %s&quot;, keyValue.loggingString().utf8().data(), indexKey.loggingString().utf8().data());
1332 
1333     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1334     if (!indexKeyBuffer) {
1335         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1336         return IDBError { UnknownError, &quot;Unable to serialize index key to be stored in the database&quot;_s };
1337     }
1338 
1339     RefPtr&lt;SharedBuffer&gt; valueBuffer = serializeIDBKeyData(keyValue);
1340     if (!valueBuffer) {
1341         LOG_ERROR(&quot;Unable to serialize the value to be stored in the database&quot;);
1342         return IDBError { UnknownError, &quot;Unable to serialize value to be stored in the database&quot;_s };
1343     }
1344 
1345     {
1346         auto* sql = cachedStatement(SQL::PutIndexRecord, &quot;INSERT INTO IndexRecords VALUES (?, ?, CAST(? AS TEXT), CAST(? AS TEXT), ?);&quot;_s);
1347         if (!sql
1348             || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
1349             || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
1350             || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
1351             || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
1352             || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
1353             || sql-&gt;step() != SQLITE_DONE) {
1354             LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="41" id="anc41"></a><span class="line-removed">1355             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1356                 return IDBError { QuotaExceededError, &quot;Error putting index record into database because no enough space for domain&quot;_s };</span>
1357             return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
1358         }
1359     }
1360 
1361     return IDBError { };
1362 }
1363 
1364 
1365 IDBError SQLiteIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1366 {
1367     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteIndex - object store %&quot; PRIu64, objectStoreIdentifier);
1368 
1369     ASSERT(m_sqliteDB);
1370     ASSERT(m_sqliteDB-&gt;isOpen());
1371 
1372     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="42" id="anc42"></a><span class="line-modified">1373     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1374         LOG_ERROR(&quot;Attempt to delete index without an in-progress transaction&quot;);</span>
1375         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
<a name="43" id="anc43"></a><span class="line-removed">1376     }</span>
1377 
1378     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1379         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1380         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1381     }
1382 
1383     {
1384         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1385         if (!sql
1386             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1387             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1388             || sql-&gt;step() != SQLITE_DONE) {
1389             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1390             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1391         }
1392     }
1393 
1394     {
1395         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);
1396         if (!sql
1397             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1398             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1399             || sql-&gt;step() != SQLITE_DONE) {
1400             LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1401             return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
1402         }
1403     }
1404 
1405     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1406     ASSERT(objectStore);
1407     objectStore-&gt;deleteIndex(indexIdentifier);
1408 
1409     return IDBError { };
1410 }
1411 
1412 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1413 {
1414     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1415 
1416     ASSERT(m_sqliteDB);
1417     ASSERT(m_sqliteDB-&gt;isOpen());
1418 
1419     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1420     if (!objectStoreInfo)
1421         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1422 
1423     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1424     if (!indexInfo)
1425         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1426 
1427     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="44" id="anc44"></a><span class="line-modified">1428     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1429         LOG_ERROR(&quot;Attempt to rename an index without an in-progress transaction&quot;);</span>
1430         return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
<a name="45" id="anc45"></a><span class="line-removed">1431     }</span>
1432 
1433     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1434         LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
1435         return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
1436     }
1437 
1438     {
1439         auto* sql = cachedStatement(SQL::RenameIndex, &quot;UPDATE IndexInfo SET name = ? WHERE objectStoreID = ? AND id = ?;&quot;_s);
1440         if (!sql
1441             || sql-&gt;bindText(1, newName) != SQLITE_OK
1442             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1443             || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
1444             || sql-&gt;step() != SQLITE_DONE) {
1445             LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="46" id="anc46"></a><span class="line-removed">1446             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1447                 return IDBError { QuotaExceededError, &quot;Could not rename index because no enough space for domain&quot;_s };</span>
1448             return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1449         }
1450     }
1451 
1452     indexInfo-&gt;rename(newName);
1453 
1454     return IDBError { };
1455 }
1456 
1457 IDBError SQLiteIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyData&amp; keyData, bool&amp; keyExists)
1458 {
1459     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::keyExistsInObjectStore - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1460 
1461     ASSERT(m_sqliteDB);
1462     ASSERT(m_sqliteDB-&gt;isOpen());
1463 
1464     keyExists = false;
1465 
1466     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="47" id="anc47"></a><span class="line-modified">1467     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1468         LOG_ERROR(&quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;);</span>
1469         return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
<a name="48" id="anc48"></a><span class="line-removed">1470     }</span>
1471 
1472     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1473     if (!keyBuffer) {
1474         LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
1475         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
1476     }
1477     auto* sql = cachedStatement(SQL::KeyExistsInObjectStore, &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT) LIMIT 1;&quot;_s);
1478     if (!sql
1479         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1480         || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1481         LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1482         return IDBError { UnknownError, &quot;Unable to check for existence of IDBKey in object store&quot;_s };
1483     }
1484 
1485     int sqlResult = sql-&gt;step();
1486     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1487         return IDBError { };
1488 
1489     if (sqlResult != SQLITE_ROW) {
1490         // There was an error fetching the record from the database.
1491         LOG_ERROR(&quot;Could not check if key exists in object store (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1492         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in object store&quot;_s };
1493     }
1494 
1495     keyExists = true;
1496     return IDBError { };
1497 }
1498 
1499 IDBError SQLiteIDBBackingStore::deleteUnusedBlobFileRecords(SQLiteIDBTransaction&amp; transaction)
1500 {
1501     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteUnusedBlobFileRecords&quot;);
1502 
1503     // Gather the set of blob URLs and filenames that are no longer in use.
1504     HashSet&lt;String&gt; removedBlobFilenames;
1505     {
1506         auto* sql = cachedStatement(SQL::GetUnusedBlobFilenames, &quot;SELECT fileName FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1507 
1508         if (!sql) {
1509             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1510             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1511         }
1512 
1513         int result = sql-&gt;step();
1514         while (result == SQLITE_ROW) {
1515             removedBlobFilenames.add(sql-&gt;getColumnText(0));
1516             result = sql-&gt;step();
1517         }
1518 
1519         if (result != SQLITE_DONE) {
1520             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1521             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1522         }
1523     }
1524 
1525     // Remove the blob records that are no longer in use.
1526     if (!removedBlobFilenames.isEmpty()) {
1527         auto* sql = cachedStatement(SQL::DeleteUnusedBlobs, &quot;DELETE FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1528 
1529         if (!sql
1530             || sql-&gt;step() != SQLITE_DONE) {
1531             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not delete blobFile records) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1532             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1533         }
1534     }
1535 
1536     for (auto&amp; file : removedBlobFilenames)
1537         transaction.addRemovedBlobFile(file);
1538 
1539     return IDBError { };
1540 }
1541 
1542 IDBError SQLiteIDBBackingStore::deleteRecord(SQLiteIDBTransaction&amp; transaction, int64_t objectStoreID, const IDBKeyData&amp; keyData)
1543 {
1544     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1545 
1546     ASSERT(m_sqliteDB);
1547     ASSERT(m_sqliteDB-&gt;isOpen());
1548     ASSERT(transaction.inProgress());
1549     ASSERT(transaction.mode() != IDBTransactionMode::Readonly);
1550     UNUSED_PARAM(transaction);
1551 
1552     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1553     if (!keyBuffer) {
1554         LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
1555         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
1556     }
1557 
1558     // Get the record ID
1559     int64_t recordID;
1560     {
1561         auto* sql = cachedStatement(SQL::GetObjectStoreRecordID, &quot;SELECT recordID FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1562 
1563         if (!sql
1564             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1565             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1566             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1567             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1568         }
1569 
1570         int result = sql-&gt;step();
1571 
1572         // If there&#39;s no record ID, there&#39;s no record to delete.
1573         if (result == SQLITE_DONE)
1574             return IDBError { };
1575 
1576         if (result != SQLITE_ROW) {
1577             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1578             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1579         }
1580 
1581         recordID = sql-&gt;getColumnInt64(0);
1582     }
1583 
1584     if (recordID &lt; 1) {
1585         LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1586         return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1587     }
1588 
1589     // Delete the blob records for this object store record.
1590     {
1591         auto* sql = cachedStatement(SQL::DeleteBlobRecord, &quot;DELETE FROM BlobRecords WHERE objectStoreRow = ?;&quot;_s);
1592 
1593         if (!sql
1594             || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1595             || sql-&gt;step() != SQLITE_DONE) {
1596             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (Could not delete BlobRecords records) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1597             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1598         }
1599     }
1600 
1601     auto error = deleteUnusedBlobFileRecords(transaction);
1602     if (!error.isNull())
1603         return error;
1604 
1605     // Delete record from object store
1606     {
1607         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1608 
1609         if (!sql
1610             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1611             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1612             || sql-&gt;step() != SQLITE_DONE) {
1613             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1614             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1615         }
1616     }
1617 
1618     // Delete record from indexes store
1619     {
1620         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1621 
1622         if (!sql
1623             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1624             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1625             || sql-&gt;step() != SQLITE_DONE) {
1626             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1627             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1628         }
1629     }
1630 
1631     return IDBError { };
1632 }
1633 
1634 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1635 {
1636     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1637 
1638     ASSERT(m_sqliteDB);
1639     ASSERT(m_sqliteDB-&gt;isOpen());
1640 
1641     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="49" id="anc49"></a><span class="line-modified">1642     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1643         LOG_ERROR(&quot;Attempt to delete range from database without an in-progress transaction&quot;);</span>
1644         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
<a name="50" id="anc50"></a><span class="line-modified">1645     }</span>
1646     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1647         LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
1648         return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
1649     }
1650 
1651     // If the range to delete is exactly one key we can delete it right now.
1652     if (keyRange.isExactlyOneKey()) {
1653         auto error = deleteRecord(*transaction, objectStoreID, keyRange.lowerKey);
1654         if (!error.isNull()) {
1655             LOG_ERROR(&quot;Failed to delete record for key &#39;%s&#39;&quot;, keyRange.lowerKey.loggingString().utf8().data());
1656             return error;
1657         }
1658 
1659         transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1660 
1661         return IDBError { };
1662     }
1663 
1664     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, 0, keyRange);
1665     if (!cursor) {
1666         LOG_ERROR(&quot;Cannot open cursor to delete range of records from the database&quot;);
1667         return IDBError { UnknownError, &quot;Cannot open cursor to delete range of records from the database&quot;_s };
1668     }
1669 
1670     Vector&lt;IDBKeyData&gt; keys;
1671     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError()) {
1672         keys.append(cursor-&gt;currentKey());
1673         cursor-&gt;advance(1);
1674     }
1675 
1676     if (cursor-&gt;didError()) {
1677         LOG_ERROR(&quot;Cursor failed while accumulating range of records from the database&quot;);
1678         return IDBError { UnknownError, &quot;Cursor failed while accumulating range of records from the database&quot;_s };
1679     }
1680 
1681     IDBError error;
1682     for (auto&amp; key : keys) {
1683         error = deleteRecord(*transaction, objectStoreID, key);
1684         if (!error.isNull()) {
1685             LOG_ERROR(&quot;deleteRange: Error deleting keys in range&quot;);
1686             break;
1687         }
1688     }
1689 
1690     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1691 
1692     return error;
1693 }
1694 
1695 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1696 {
<a name="51" id="anc51"></a><span class="line-modified">1697     JSLockHolder locker(vm());</span>
1698 
<a name="52" id="anc52"></a><span class="line-modified">1699     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
1700     if (jsValue.isUndefinedOrNull())
1701         return IDBError { };
1702 
1703     IndexKey indexKey;
<a name="53" id="anc53"></a><span class="line-modified">1704     generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), info, jsValue, indexKey);</span>


1705 
1706     if (indexKey.isNull())
1707         return IDBError { };
1708 
1709     return uncheckedPutIndexKey(info, key, indexKey, recordID);
1710 }
1711 
1712 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1713 {
<a name="54" id="anc54"></a><span class="line-modified">1714     JSLockHolder locker(vm());</span>
1715 
<a name="55" id="anc55"></a><span class="line-modified">1716     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
1717     if (jsValue.isUndefinedOrNull())
1718         return IDBError { };
1719 
1720     IDBError error;
1721     bool anyRecordsSucceeded = false;
1722     for (auto&amp; index : info.indexMap().values()) {
1723         IndexKey indexKey;
<a name="56" id="anc56"></a><span class="line-modified">1724         generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), index, jsValue, indexKey);</span>
1725 
1726         if (indexKey.isNull())
1727             continue;
1728 
1729         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1730         if (!error.isNull())
1731             break;
1732 
1733         anyRecordsSucceeded = true;
1734     }
1735 
1736     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
1737         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);
1738 
1739         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);
1740 
1741         if (!sql
1742             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1743             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1744             || sql-&gt;step() != SQLITE_DONE) {
1745             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1746             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1747         }
1748     }
1749 
1750     return error;
1751 }
1752 
1753 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1754 {
1755     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1756 
1757     ASSERT(m_sqliteDB);
1758     ASSERT(m_sqliteDB-&gt;isOpen());
1759     ASSERT(value.data().data());
1760     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1761 
1762     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="57" id="anc57"></a><span class="line-modified">1763     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1764         LOG_ERROR(&quot;Attempt to store a record in an object store without an in-progress transaction&quot;);</span>
1765         return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
<a name="58" id="anc58"></a><span class="line-modified">1766     }</span>
1767     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1768         LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
1769         return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
1770     }
1771 
1772     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1773     if (!keyBuffer) {
1774         LOG_ERROR(&quot;Unable to serialize IDBKey to be stored in an object store&quot;);
1775         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to be stored in an object store&quot;_s };
1776     }
1777 
1778     int64_t recordID = 0;
1779     {
1780         auto* sql = cachedStatement(SQL::AddObjectStoreRecord, &quot;INSERT INTO Records VALUES (?, CAST(? AS TEXT), ?, NULL);&quot;_s);
1781         if (!sql
1782             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1783             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1784             || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
1785             || sql-&gt;step() != SQLITE_DONE) {
1786             LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="59" id="anc59"></a><span class="line-removed">1787             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1788                 return IDBError { QuotaExceededError, &quot;Unable to store record in object store because no enough space for domain&quot;_s };</span>
1789             return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
1790         }
1791 
1792         recordID = m_sqliteDB-&gt;lastInsertRowID();
1793     }
1794 
1795     auto error = updateAllIndexesForAddRecord(objectStoreInfo, keyData, value.data(), recordID);
1796 
1797     if (!error.isNull()) {
1798         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1799         if (!sql
1800             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1801             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1802             || sql-&gt;step() != SQLITE_DONE) {
1803             LOG_ERROR(&quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;);
1804             return IDBError { UnknownError, &quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;_s };
1805         }
1806 
1807         return error;
1808     }
1809 
1810     const Vector&lt;String&gt;&amp; blobURLs = value.blobURLs();
1811     const Vector&lt;String&gt;&amp; blobFiles = value.blobFilePaths();
1812     for (size_t i = 0; i &lt; blobURLs.size(); ++i) {
1813         auto&amp; url = blobURLs[i];
1814         {
1815             auto* sql = cachedStatement(SQL::AddBlobRecord, &quot;INSERT INTO BlobRecords VALUES (?, ?);&quot;_s);
1816             if (!sql
1817                 || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1818                 || sql-&gt;bindText(2, url) != SQLITE_OK
1819                 || sql-&gt;step() != SQLITE_DONE) {
1820                 LOG_ERROR(&quot;Unable to record Blob record in database&quot;);
<a name="60" id="anc60"></a><span class="line-removed">1821                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1822                     return IDBError { QuotaExceededError, &quot;Unable to record Blob record in database because no enough space for domain&quot;_s };</span>
1823                 return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
1824             }
1825         }
1826         int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
1827 
1828         // If we already have a file for this blobURL, nothing left to do.
1829         {
1830             auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1831             if (!sql
1832                 || sql-&gt;bindText(1, url) != SQLITE_OK) {
1833                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1834                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1835             }
1836 
1837             int result = sql-&gt;step();
1838             if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
1839                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1840                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1841             }
1842 
1843             if (result == SQLITE_ROW)
1844                 continue;
1845         }
1846 
1847         // We don&#39;t already have a file for this blobURL, so commit our file as a unique filename
1848         String storedFilename = makeString(potentialFileNameInteger, &quot;.blob&quot;);
1849         {
1850             auto* sql = cachedStatement(SQL::AddBlobFilename, &quot;INSERT INTO BlobFiles VALUES (?, ?);&quot;_s);
1851             if (!sql
1852                 || sql-&gt;bindText(1, url) != SQLITE_OK
1853                 || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
1854                 || sql-&gt;step() != SQLITE_DONE) {
1855                 LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);
<a name="61" id="anc61"></a><span class="line-removed">1856                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">1857                     return IDBError { QuotaExceededError, &quot;Unable to record Blob file in database because no enough space for domain&quot;_s };</span>
1858                 return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
1859             }
1860         }
1861 
1862         transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
1863     }
1864 
1865     transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
1866 
1867     return error;
1868 }
1869 
<a name="62" id="anc62"></a><span class="line-modified">1870 IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, PAL::SessionID&amp; sessionID, Vector&lt;String&gt;&amp; blobFilePaths)</span>
1871 {
1872     ASSERT(objectStoreRecord);
1873 
1874     HashSet&lt;String&gt; blobURLSet;
1875     {
1876         auto* sql = cachedStatement(SQL::GetBlobURL, &quot;SELECT blobURL FROM BlobRecords WHERE objectStoreRow = ?&quot;_s);
1877         if (!sql
1878             || sql-&gt;bindInt64(1, objectStoreRecord) != SQLITE_OK) {
1879             LOG_ERROR(&quot;Could not prepare statement to fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1880             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1881         }
1882 
1883         int sqlResult = sql-&gt;step();
1884         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
1885             // There are no blobURLs in the database for this object store record.
1886             return IDBError { };
1887         }
1888 
1889         while (sqlResult == SQLITE_ROW) {
1890             blobURLSet.add(sql-&gt;getColumnText(0));
1891             sqlResult = sql-&gt;step();
1892         }
1893 
1894         if (sqlResult != SQLITE_DONE) {
1895             LOG_ERROR(&quot;Could not fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1896             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1897         }
1898     }
1899 
1900     ASSERT(!blobURLSet.isEmpty());
<a name="63" id="anc63"></a><span class="line-removed">1901     String databaseDirectory = fullDatabaseDirectory();</span>
1902     for (auto&amp; blobURL : blobURLSet) {
1903         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1904         if (!sql
1905             || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
1906             LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1907             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1908         }
1909 
1910         if (sql-&gt;step() != SQLITE_ROW) {
1911             LOG_ERROR(&quot;Entry for blob filename for blob url %s does not exist (%i) - %s&quot;, blobURL.utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1912             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
1913         }
1914 
1915         blobURLs.append(blobURL);
1916 
1917         String fileName = sql-&gt;getColumnText(0);
<a name="64" id="anc64"></a><span class="line-modified">1918         blobFilePaths.append(FileSystem::pathByAppendingComponent(databaseDirectory, fileName));</span>
1919     }
<a name="65" id="anc65"></a><span class="line-removed">1920     sessionID = m_identifier.sessionID();</span>
<span class="line-removed">1921 </span>
1922     return IDBError { };
1923 }
1924 
1925 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
1926 {
1927     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getRecord - key range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1928 
1929     ASSERT(m_sqliteDB);
1930     ASSERT(m_sqliteDB-&gt;isOpen());
1931 
1932     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="66" id="anc66"></a><span class="line-modified">1933     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">1934         LOG_ERROR(&quot;Attempt to get a record from database without an in-progress transaction&quot;);</span>
1935         return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
<a name="67" id="anc67"></a><span class="line-removed">1936     }</span>
1937 
1938     auto key = keyRange.lowerKey;
1939     if (key.isNull())
1940         key = IDBKeyData::minimum();
1941     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
1942     if (!lowerBuffer) {
1943         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
1944         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
1945     }
1946 
1947     key = keyRange.upperKey;
1948     if (key.isNull())
1949         key = IDBKeyData::maximum();
1950     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(key);
1951     if (!upperBuffer) {
1952         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
1953         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
1954     }
1955 
1956     int64_t recordID = 0;
<a name="68" id="anc68"></a><span class="line-modified">1957     ThreadSafeDataBuffer resultBuffer;</span>
1958     {
<a name="69" id="anc69"></a><span class="line-modified">1959         static const char* const lowerOpenUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1960         static const char* const lowerOpenUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1961         static const char* const lowerClosedUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">1962         static const char* const lowerClosedUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
1963 
1964         static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1965         static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1966         static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
1967         static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
1968 
1969         SQLiteStatement* sql = nullptr;
1970 
1971         switch (type) {
1972         case IDBGetRecordDataType::KeyAndValue:
1973             if (keyRange.lowerOpen) {
1974                 if (keyRange.upperOpen)
1975                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpen);
1976                 else
1977                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosed);
1978             } else {
1979                 if (keyRange.upperOpen)
1980                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpen);
1981                 else
1982                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosed);
1983             }
1984             break;
1985         case IDBGetRecordDataType::KeyOnly:
1986             if (keyRange.lowerOpen) {
1987                 if (keyRange.upperOpen)
1988                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKeyOnly);
1989                 else
1990                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKeyOnly);
1991             } else {
1992                 if (keyRange.upperOpen)
1993                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKeyOnly);
1994                 else
1995                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKeyOnly);
1996             }
1997         }
1998 
1999         if (!sql
2000             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2001             || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2002             || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2003             LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2004             return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2005         }
2006 
2007         int sqlResult = sql-&gt;step();
2008 
2009         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
2010             // There was no record for the key in the database.
2011             return IDBError { };
2012         }
2013         if (sqlResult != SQLITE_ROW) {
2014             // There was an error fetching the record from the database.
2015             LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2016             return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2017         }
2018 
<a name="70" id="anc70"></a><span class="line-modified">2019         Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">2020         sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">2021         resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
2022 
<a name="71" id="anc71"></a><span class="line-modified">2023         if (type == IDBGetRecordDataType::KeyAndValue)</span>
<span class="line-modified">2024             recordID = sql-&gt;getColumnInt64(1);</span>




2025     }
2026 
<a name="72" id="anc72"></a><span class="line-modified">2027     if (type == IDBGetRecordDataType::KeyOnly) {</span>
<span class="line-modified">2028         auto* vector = resultBuffer.data();</span>
<span class="line-modified">2029         if (!vector) {</span>
<span class="line-modified">2030             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">2031             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-removed">2032         }</span>
2033 
<a name="73" id="anc73"></a><span class="line-modified">2034         IDBKeyData keyData;</span>
<span class="line-modified">2035         if (!deserializeIDBKeyData(vector-&gt;data(), vector-&gt;size(), keyData)) {</span>
<span class="line-modified">2036             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">2037             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-modified">2038         }</span>
2039 
<a name="74" id="anc74"></a>
2040         resultValue = { keyData };
2041         return IDBError { };
2042     }
2043 
2044     ASSERT(recordID);
2045     Vector&lt;String&gt; blobURLs, blobFilePaths;
<a name="75" id="anc75"></a><span class="line-modified">2046     PAL::SessionID sessionID;</span>
<span class="line-removed">2047     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2048     ASSERT(blobURLs.size() == blobFilePaths.size());
2049 
2050     if (!error.isNull())
2051         return error;
2052 
<a name="76" id="anc76"></a><span class="line-modified">2053     resultValue = { { resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) } };</span>


2054     return IDBError { };
2055 }
2056 
2057 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2058 {
2059     return getAllRecordsData.indexIdentifier ? getAllIndexRecords(transactionIdentifier, getAllRecordsData, result) : getAllObjectStoreRecords(transactionIdentifier, getAllRecordsData, result);
2060 }
2061 
2062 SQLiteStatement* SQLiteIDBBackingStore::cachedStatementForGetAllObjectStoreRecords(const IDBGetAllRecordsData&amp; getAllRecordsData)
2063 {
2064     static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2065     static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2066     static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2067     static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<a name="77" id="anc77"></a><span class="line-modified">2068     static const char* const lowerOpenUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2069     static const char* const lowerOpenUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2070     static const char* const lowerClosedUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">2071     static const char* const lowerClosedUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
2072 
2073     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
2074         if (getAllRecordsData.keyRangeData.lowerOpen) {
2075             if (getAllRecordsData.keyRangeData.upperOpen)
2076                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
2077             return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKey);
2078         }
2079 
2080         if (getAllRecordsData.keyRangeData.upperOpen)
2081             return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKey);
2082         return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKey);
2083     }
2084 
2085     if (getAllRecordsData.keyRangeData.lowerOpen) {
2086         if (getAllRecordsData.keyRangeData.upperOpen)
2087             return cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpenValue);
2088         return cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosedValue);
2089     }
2090 
2091     if (getAllRecordsData.keyRangeData.upperOpen)
2092         return cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpenValue);
2093     return cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosedValue);
2094 }
2095 
2096 IDBError SQLiteIDBBackingStore::getAllObjectStoreRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2097 {
2098     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllObjectStoreRecords&quot;);
2099 
2100     ASSERT(m_sqliteDB);
2101     ASSERT(m_sqliteDB-&gt;isOpen());
2102 
2103     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="78" id="anc78"></a><span class="line-modified">2104     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2105         LOG_ERROR(&quot;Attempt to get records from database without an in-progress transaction&quot;);</span>
2106         return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
<a name="79" id="anc79"></a><span class="line-removed">2107     }</span>
2108 
2109     auto key = getAllRecordsData.keyRangeData.lowerKey;
2110     if (key.isNull())
2111         key = IDBKeyData::minimum();
2112     auto lowerBuffer = serializeIDBKeyData(key);
2113     if (!lowerBuffer) {
2114         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2115         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2116     }
2117 
2118     key = getAllRecordsData.keyRangeData.upperKey;
2119     if (key.isNull())
2120         key = IDBKeyData::maximum();
2121     auto upperBuffer = serializeIDBKeyData(key);
2122     if (!upperBuffer) {
2123         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2124         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2125     }
2126 
2127     auto* sql = cachedStatementForGetAllObjectStoreRecords(getAllRecordsData);
2128     if (!sql
2129         || sql-&gt;bindInt64(1, getAllRecordsData.objectStoreIdentifier) != SQLITE_OK
2130         || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2131         || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2132         LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2133         return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2134     }
2135 
<a name="80" id="anc80"></a><span class="line-modified">2136     result = { getAllRecordsData.getAllType };</span>


2137 
2138     uint32_t targetResults;
2139     if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
2140         targetResults = getAllRecordsData.count.value();
2141     else
2142         targetResults = std::numeric_limits&lt;uint32_t&gt;::max();
2143 
2144     int sqlResult = sql-&gt;step();
2145     uint32_t returnedResults = 0;
2146 
2147     while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
<a name="81" id="anc81"></a>








2148         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
<a name="82" id="anc82"></a><span class="line-modified">2149             Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">2150             sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">2151             ThreadSafeDataBuffer resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
2152 
<a name="83" id="anc83"></a><span class="line-modified">2153             auto recordID = sql-&gt;getColumnInt64(1);</span>
2154 
2155             ASSERT(recordID);
2156             Vector&lt;String&gt; blobURLs, blobFilePaths;
<a name="84" id="anc84"></a><span class="line-modified">2157             PAL::SessionID sessionID;</span>
<span class="line-removed">2158             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2159             ASSERT(blobURLs.size() == blobFilePaths.size());
2160 
2161             if (!error.isNull())
2162                 return error;
2163 
<a name="85" id="anc85"></a><span class="line-modified">2164             result.addValue({ resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) });</span>
<span class="line-removed">2165         } else {</span>
<span class="line-removed">2166             Vector&lt;uint8_t&gt; keyData;</span>
<span class="line-removed">2167             IDBKeyData key;</span>
<span class="line-removed">2168             sql-&gt;getColumnBlobAsVector(0, keyData);</span>
<span class="line-removed">2169 </span>
<span class="line-removed">2170             if (!deserializeIDBKeyData(keyData.data(), keyData.size(), key)) {</span>
<span class="line-removed">2171                 LOG_ERROR(&quot;Unable to deserialize key data from database while getting all key records&quot;);</span>
<span class="line-removed">2172                 return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all key records&quot;_s };</span>
<span class="line-removed">2173             }</span>
<span class="line-removed">2174 </span>
<span class="line-removed">2175             result.addKey(WTFMove(key));</span>
2176         }
2177 
2178         ++returnedResults;
2179         sqlResult = sql-&gt;step();
2180     }
2181 
2182     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE || sqlResult == SQLITE_ROW) {
2183         // Finished getting results
2184         return IDBError { };
2185     }
2186 
2187     // There was an error fetching records from the database.
2188     LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2189     return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2190 }
2191 
2192 IDBError SQLiteIDBBackingStore::getAllIndexRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2193 {
2194     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllIndexRecords - %s&quot;, getAllRecordsData.keyRangeData.loggingString().utf8().data());
2195 
2196     ASSERT(m_sqliteDB);
2197     ASSERT(m_sqliteDB-&gt;isOpen());
2198 
2199     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="86" id="anc86"></a><span class="line-modified">2200     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2201         LOG_ERROR(&quot;Attempt to get all index records from database without an in-progress transaction&quot;);</span>
2202         return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
<a name="87" id="anc87"></a><span class="line-removed">2203     }</span>
2204 
2205     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
2206     if (!cursor) {
2207         LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
2208         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2209     }
2210 
2211     if (cursor-&gt;didError()) {
2212         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2213         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2214     }
2215 
<a name="88" id="anc88"></a><span class="line-modified">2216     result = { getAllRecordsData.getAllType };</span>



2217     uint32_t currentCount = 0;
2218     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2219     if (!targetCount)
2220         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2221     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
<a name="89" id="anc89"></a><span class="line-modified">2222         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {</span>
<span class="line-modified">2223             IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();</span>
<span class="line-modified">2224             result.addKey(WTFMove(keyCopy));</span>
<span class="line-removed">2225         } else</span>
2226             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
2227 
2228         ++currentCount;
2229         cursor-&gt;advance(1);
2230     }
2231 
2232     if (cursor-&gt;didError()) {
2233         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2234         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2235     }
2236 
2237     return IDBError { };
2238 }
2239 
2240 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2241 {
2242     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2243 
2244     ASSERT(m_sqliteDB);
2245     ASSERT(m_sqliteDB-&gt;isOpen());
2246 
2247     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="90" id="anc90"></a><span class="line-modified">2248     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2249         LOG_ERROR(&quot;Attempt to get an index record from database without an in-progress transaction&quot;);</span>
2250         return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
<a name="91" id="anc91"></a><span class="line-removed">2251     }</span>
2252 
2253     if (range.isExactlyOneKey())
2254         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
2255 
2256     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2257     if (!cursor) {
2258         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2259         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2260     }
2261 
2262     if (cursor-&gt;didError()) {
2263         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2264         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2265     }
2266 
2267     if (cursor-&gt;didComplete())
2268         getResult = { };
2269     else {
2270         if (type == IndexedDB::IndexRecordType::Key)
2271             getResult = { cursor-&gt;currentPrimaryKey() };
<a name="92" id="anc92"></a><span class="line-modified">2272         else</span>
<span class="line-modified">2273             getResult = { cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), cursor-&gt;currentPrimaryKey() };</span>



2274     }
2275 
2276     return IDBError { };
2277 }
2278 
2279 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2280 {
2281     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2282 
2283     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2284 
2285     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2286     if (!buffer) {
2287         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2288         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2289     }
2290 
2291     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);
2292 
2293     if (!sql
2294         || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
2295         || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
2296         || sql-&gt;bindBlob(3, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
2297         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2298         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2299     }
2300 
2301     int result = sql-&gt;step();
2302     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
2303         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2304         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2305     }
2306 
2307     if (result == SQLITE_DONE)
2308         return IDBError { };
2309 
2310     IDBKeyData objectStoreKey;
2311     Vector&lt;uint8_t&gt; keyVector;
2312     sql-&gt;getColumnBlobAsVector(0, keyVector);
2313 
2314     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2315         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2316         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
2317     }
2318 
2319     if (type == IndexedDB::IndexRecordType::Key) {
2320         getResult = { objectStoreKey };
2321         return IDBError { };
2322     }
2323 
<a name="93" id="anc93"></a><span class="line-modified">2324     sql-&gt;getColumnBlobAsVector(1, keyVector);</span>

2325 
2326     int64_t recordID = sql-&gt;getColumnInt64(2);
2327     Vector&lt;String&gt; blobURLs, blobFilePaths;
<a name="94" id="anc94"></a><span class="line-modified">2328     PAL::SessionID sessionID;</span>
<span class="line-removed">2329     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
2330     ASSERT(blobURLs.size() == blobFilePaths.size());
2331 
2332     if (!error.isNull())
2333         return error;
2334 
<a name="95" id="anc95"></a><span class="line-modified">2335     getResult = { { ThreadSafeDataBuffer::create(WTFMove(keyVector)), WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) }, objectStoreKey };</span>


2336     return IDBError { };
2337 }
2338 
2339 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2340 {
2341     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2342     ASSERT(m_sqliteDB);
2343     ASSERT(m_sqliteDB-&gt;isOpen());
2344 
2345     outCount = 0;
2346 
2347     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="96" id="anc96"></a><span class="line-modified">2348     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2349         LOG_ERROR(&quot;Attempt to get count from database without an in-progress transaction&quot;);</span>
2350         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
<a name="97" id="anc97"></a><span class="line-removed">2351     }</span>
2352 
2353     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
2354     if (!cursor) {
2355         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
2356         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
2357     }
2358 
2359     while (cursor-&gt;advance(1))
2360         ++outCount;
2361 
2362     return IDBError { };
2363 }
2364 
2365 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2366 {
2367     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2368     if (!sql
2369         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2370         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2371         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
2372     }
2373     int result = sql-&gt;step();
2374     if (result != SQLITE_ROW) {
2375         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2376         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2377     }
2378 
2379     int64_t value = sql-&gt;getColumnInt64(0);
2380     if (value &lt; 0)
2381         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
2382 
2383     outValue = value;
2384     return IDBError { };
2385 }
2386 
2387 IDBError SQLiteIDBBackingStore::uncheckedSetKeyGeneratorValue(int64_t objectStoreID, uint64_t value)
2388 {
2389     auto* sql = cachedStatement(SQL::SetKeyGeneratorValue, &quot;INSERT INTO KeyGenerators VALUES (?, ?);&quot;_s);
2390     if (!sql
2391         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2392         || sql-&gt;bindInt64(2, value) != SQLITE_OK
2393         || sql-&gt;step() != SQLITE_DONE) {
2394         LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<a name="98" id="anc98"></a><span class="line-removed">2395         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">2396             return IDBError { QuotaExceededError, &quot;Error storing new key generator value in database because no enough space for domain&quot;_s };</span>
2397         return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
2398     }
2399 
2400     return IDBError { };
2401 }
2402 
2403 IDBError SQLiteIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t&amp; generatedKey)
2404 {
2405     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::generateKeyNumber&quot;);
2406 
2407     ASSERT(m_sqliteDB);
2408     ASSERT(m_sqliteDB-&gt;isOpen());
2409 
2410     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="99" id="anc99"></a><span class="line-modified">2411     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2412         LOG_ERROR(&quot;Attempt to generate key in database without an in-progress transaction&quot;);</span>
2413         return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
<a name="100" id="anc100"></a><span class="line-modified">2414     }</span>
2415     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2416         LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
2417         return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
2418     }
2419 
2420     uint64_t currentValue;
2421     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2422     if (!error.isNull())
2423         return error;
2424 
2425     if (currentValue + 1 &gt; maxGeneratorValue)
2426         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
2427 
2428     generatedKey = currentValue + 1;
2429     return uncheckedSetKeyGeneratorValue(objectStoreID, generatedKey);
2430 }
2431 
2432 IDBError SQLiteIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t newKeyNumber)
2433 {
2434     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::revertGeneratedKeyNumber - object store %&quot; PRIu64 &quot;, reverted number %&quot; PRIu64, objectStoreID, newKeyNumber);
2435 
2436     ASSERT(m_sqliteDB);
2437     ASSERT(m_sqliteDB-&gt;isOpen());
2438 
2439     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="101" id="anc101"></a><span class="line-modified">2440     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2441         LOG_ERROR(&quot;Attempt to revert key generator value in database without an in-progress transaction&quot;);</span>
2442         return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
<a name="102" id="anc102"></a><span class="line-modified">2443     }</span>
2444     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2445         LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
2446         return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
2447     }
2448 
2449     ASSERT(newKeyNumber);
2450     return uncheckedSetKeyGeneratorValue(objectStoreID, newKeyNumber - 1);
2451 }
2452 
2453 IDBError SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, double newKeyNumber)
2454 {
2455     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
2456 
2457     ASSERT(m_sqliteDB);
2458     ASSERT(m_sqliteDB-&gt;isOpen());
2459 
2460     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="103" id="anc103"></a><span class="line-modified">2461     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2462         LOG_ERROR(&quot;Attempt to update key generator value in database without an in-progress transaction&quot;);</span>
2463         return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
<a name="104" id="anc104"></a><span class="line-modified">2464     }</span>
2465     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2466         LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
2467         return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
2468     }
2469 
2470     uint64_t currentValue;
2471     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2472     if (!error.isNull())
2473         return error;
2474 
2475     if (newKeyNumber &lt;= currentValue)
2476         return IDBError { };
2477 
2478     return uncheckedSetKeyGeneratorValue(objectStoreID, std::min(newKeyNumber, (double)maxGeneratorValue));
2479 }
2480 
2481 IDBError SQLiteIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; result)
2482 {
2483     ASSERT(m_sqliteDB);
2484     ASSERT(m_sqliteDB-&gt;isOpen());
2485 
2486     auto* transaction = m_transactions.get(transactionIdentifier);
<a name="105" id="anc105"></a><span class="line-modified">2487     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">2488         LOG_ERROR(&quot;Attempt to open a cursor in database without an in-progress transaction&quot;);</span>
2489         return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
<a name="106" id="anc106"></a><span class="line-removed">2490     }</span>
2491 
2492     auto* cursor = transaction-&gt;maybeOpenCursor(info);
2493     if (!cursor) {
2494         LOG_ERROR(&quot;Unable to open cursor&quot;);
2495         return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
2496     }
2497 
2498     m_cursors.set(cursor-&gt;identifier(), cursor);
2499 
<a name="107" id="anc107"></a><span class="line-modified">2500     cursor-&gt;currentData(result);</span>


2501     return IDBError { };
2502 }
2503 
2504 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
2505 {
2506     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::iterateCursor&quot;);
2507 
2508     ASSERT(m_sqliteDB);
2509     ASSERT(m_sqliteDB-&gt;isOpen());
2510 
2511     auto* cursor = m_cursors.get(cursorIdentifier);
2512     if (!cursor) {
2513         LOG_ERROR(&quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;);
2514         return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
2515     }
2516 
2517     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2518 
<a name="108" id="anc108"></a><span class="line-modified">2519     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress()) {</span>
<span class="line-removed">2520         LOG_ERROR(&quot;Attempt to iterate a cursor without an in-progress transaction&quot;);</span>
2521         return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
<a name="109" id="anc109"></a><span class="line-removed">2522     }</span>
2523 
2524     auto key = data.keyData;
2525     auto primaryKey = data.primaryKeyData;
2526     auto count = data.count;
2527 
2528     if (key.isValid()) {
2529         if (!cursor-&gt;iterate(key, primaryKey)) {
2530             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2531             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2532         }
2533     } else {
2534         ASSERT(!primaryKey.isValid());
2535         if (!count)
2536             count = 1;
2537         if (!cursor-&gt;advance(count)) {
2538             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2539             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2540         }
2541     }
2542 
<a name="110" id="anc110"></a><span class="line-modified">2543     cursor-&gt;currentData(result);</span>


2544     return IDBError { };
2545 }
2546 
2547 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
2548 {
2549     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);
2550 
2551     ASSERT(m_sqliteDB);
2552     ASSERT(m_sqliteDB-&gt;isOpen());
2553 
2554     auto* cursor = m_cursors.get(cursorIdentifier);
2555     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2556         return false;
2557 
2558     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2559 
2560     return cursor-&gt;prefetch();
2561 }
2562 
2563 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
2564 {
2565     ASSERT(m_databaseInfo);
2566     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
2567 }
2568 
2569 void SQLiteIDBBackingStore::deleteBackingStore()
2570 {
2571     String dbFilename = fullDatabasePath();
2572 
2573     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteBackingStore deleting file &#39;%s&#39; on disk&quot;, dbFilename.utf8().data());
2574 
2575     Vector&lt;String&gt; blobFiles;
2576     {
2577         bool errored = true;
2578 
2579         if (m_sqliteDB) {
2580             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
2581             if (sql.prepare() == SQLITE_OK) {
2582                 int result = sql.step();
2583                 while (result == SQLITE_ROW) {
2584                     blobFiles.append(sql.getColumnText(0));
2585                     result = sql.step();
2586                 }
2587 
2588                 if (result == SQLITE_DONE)
2589                     errored = false;
2590             }
2591         }
2592 
2593         if (errored)
2594             LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
2595     }
2596 
<a name="111" id="anc111"></a><span class="line-removed">2597     String databaseDirectory = fullDatabaseDirectory();</span>
2598     for (auto&amp; file : blobFiles) {
<a name="112" id="anc112"></a><span class="line-modified">2599         String fullPath = FileSystem::pathByAppendingComponent(databaseDirectory, file);</span>
2600         if (!FileSystem::deleteFile(fullPath))
2601             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2602     }
2603 
2604     if (m_sqliteDB)
2605         closeSQLiteDB();
2606 
2607     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
<a name="113" id="anc113"></a><span class="line-modified">2608     SQLiteFileSystem::deleteEmptyDatabaseDirectory(fullDatabaseDirectory());</span>
<span class="line-modified">2609     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_absoluteDatabaseDirectory);</span>
2610 }
2611 
2612 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2613 {
2614     ASSERT(m_cursors.contains(cursor.identifier()));
2615     m_cursors.remove(cursor.identifier());
2616 }
2617 
2618 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2619 {
2620     if (sql &gt;= SQL::Count) {
2621         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2622         return nullptr;
2623     }
2624 
2625     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2626         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2627             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2628         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2629     }
2630 
2631     if (m_sqliteDB) {
<a name="114" id="anc114"></a><span class="line-modified">2632         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = std::make_unique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);</span>
2633         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2634             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2635     }
2636 
2637     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2638 }
2639 
<a name="115" id="anc115"></a>




2640 void SQLiteIDBBackingStore::closeSQLiteDB()
2641 {
2642     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
2643         m_cachedStatements[i] = nullptr;
2644 
2645     if (m_sqliteDB)
2646         m_sqliteDB-&gt;close();
2647 
2648     m_sqliteDB = nullptr;
2649 }
2650 
<a name="116" id="anc116"></a>





2651 } // namespace IDBServer
2652 } // namespace WebCore
2653 
2654 #endif // ENABLE(INDEXED_DATABASE)
<a name="117" id="anc117"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="117" type="hidden" />
</body>
</html>