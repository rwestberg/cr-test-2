<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/persistence/PersistentCoders.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010, 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;utility&gt;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/SHA1.h&gt;
 33 #include &lt;wtf/Seconds.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
 35 #include &lt;wtf/WallTime.h&gt;
 36 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 37 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
 38 
 39 namespace WTF {
 40 namespace Persistence {
 41 
 42 template&lt;typename T, typename U&gt; struct Coder&lt;std::pair&lt;T, U&gt;&gt; {
 43     static void encode(Encoder&amp; encoder, const std::pair&lt;T, U&gt;&amp; pair)
 44     {
 45         encoder &lt;&lt; pair.first &lt;&lt; pair.second;
 46     }
 47 
 48     static bool decode(Decoder&amp; decoder, std::pair&lt;T, U&gt;&amp; pair)
 49     {
 50         T first;
 51         if (!decoder.decode(first))
 52             return false;
 53 
 54         U second;
 55         if (!decoder.decode(second))
 56             return false;
 57 
 58         pair.first = first;
 59         pair.second = second;
 60         return true;
 61     }
 62 };
 63 
 64 template&lt;typename T&gt; struct Coder&lt;Optional&lt;T&gt;&gt; {
 65     static void encode(Encoder&amp; encoder, const Optional&lt;T&gt;&amp; optional)
 66     {
 67         if (!optional) {
 68             encoder &lt;&lt; false;
 69             return;
 70         }
 71 
 72         encoder &lt;&lt; true;
 73         encoder &lt;&lt; optional.value();
 74     }
 75 
 76     static bool decode(Decoder&amp; decoder, Optional&lt;T&gt;&amp; optional)
 77     {
 78         bool isEngaged;
 79         if (!decoder.decode(isEngaged))
 80             return false;
 81 
 82         if (!isEngaged) {
 83             optional = WTF::nullopt;
 84             return true;
 85         }
 86 
 87         T value;
 88         if (!decoder.decode(value))
 89             return false;
 90 
 91         optional = WTFMove(value);
 92         return true;
 93     }
 94 };
 95 
 96 template&lt;typename KeyType, typename ValueType&gt; struct Coder&lt;WTF::KeyValuePair&lt;KeyType, ValueType&gt;&gt; {
 97     static void encode(Encoder&amp; encoder, const WTF::KeyValuePair&lt;KeyType, ValueType&gt;&amp; pair)
 98     {
 99         encoder &lt;&lt; pair.key &lt;&lt; pair.value;
100     }
101 
102     static bool decode(Decoder&amp; decoder, WTF::KeyValuePair&lt;KeyType, ValueType&gt;&amp; pair)
103     {
104         KeyType key;
105         if (!decoder.decode(key))
106             return false;
107 
108         ValueType value;
109         if (!decoder.decode(value))
110             return false;
111 
112         pair.key = key;
113         pair.value = value;
114         return true;
115     }
116 };
117 
118 template&lt;bool fixedSizeElements, typename T, size_t inlineCapacity&gt; struct VectorCoder;
119 
120 template&lt;typename T, size_t inlineCapacity&gt; struct VectorCoder&lt;false, T, inlineCapacity&gt; {
121     static void encode(Encoder&amp; encoder, const Vector&lt;T, inlineCapacity&gt;&amp; vector)
122     {
123         encoder &lt;&lt; static_cast&lt;uint64_t&gt;(vector.size());
124         for (size_t i = 0; i &lt; vector.size(); ++i)
125             encoder &lt;&lt; vector[i];
126     }
127 
128     static bool decode(Decoder&amp; decoder, Vector&lt;T, inlineCapacity&gt;&amp; vector)
129     {
130         uint64_t size;
131         if (!decoder.decode(size))
132             return false;
133 
134         Vector&lt;T, inlineCapacity&gt; tmp;
135         for (size_t i = 0; i &lt; size; ++i) {
136             T element;
137             if (!decoder.decode(element))
138                 return false;
139 
140             tmp.append(WTFMove(element));
141         }
142 
143         tmp.shrinkToFit();
144         vector.swap(tmp);
145         return true;
146     }
147 };
148 
149 template&lt;typename T, size_t inlineCapacity&gt; struct VectorCoder&lt;true, T, inlineCapacity&gt; {
150     static void encode(Encoder&amp; encoder, const Vector&lt;T, inlineCapacity&gt;&amp; vector)
151     {
152         encoder &lt;&lt; static_cast&lt;uint64_t&gt;(vector.size());
<a name="1" id="anc1"></a><span class="line-modified">153         encoder.encodeFixedLengthData(reinterpret_cast&lt;const uint8_t*&gt;(vector.data()), vector.size() * sizeof(T));</span>
154     }
155 
156     static bool decode(Decoder&amp; decoder, Vector&lt;T, inlineCapacity&gt;&amp; vector)
157     {
158         uint64_t decodedSize;
159         if (!decoder.decode(decodedSize))
160             return false;
161 
162         auto size = safeCast&lt;size_t&gt;(decodedSize);
163 
164         // Since we know the total size of the elements, we can allocate the vector in
165         // one fell swoop. Before allocating we must however make sure that the decoder buffer
166         // is big enough.
167         if (!decoder.bufferIsLargeEnoughToContain&lt;T&gt;(size))
168             return false;
169 
170         Vector&lt;T, inlineCapacity&gt; temp;
171         temp.grow(size);
172 
173         decoder.decodeFixedLengthData(reinterpret_cast&lt;uint8_t*&gt;(temp.data()), size * sizeof(T));
174 
175         vector.swap(temp);
176         return true;
177     }
178 };
179 
180 template&lt;typename T, size_t inlineCapacity&gt; struct Coder&lt;Vector&lt;T, inlineCapacity&gt;&gt; : VectorCoder&lt;std::is_arithmetic&lt;T&gt;::value, T, inlineCapacity&gt; { };
181 
182 template&lt;typename KeyArg, typename MappedArg, typename HashArg, typename KeyTraitsArg, typename MappedTraitsArg&gt; struct Coder&lt;HashMap&lt;KeyArg, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&gt; {
183     typedef HashMap&lt;KeyArg, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg&gt; HashMapType;
184 
185     static void encode(Encoder&amp; encoder, const HashMapType&amp; hashMap)
186     {
187         encoder &lt;&lt; static_cast&lt;uint64_t&gt;(hashMap.size());
188         for (typename HashMapType::const_iterator it = hashMap.begin(), end = hashMap.end(); it != end; ++it)
189             encoder &lt;&lt; *it;
190     }
191 
192     static bool decode(Decoder&amp; decoder, HashMapType&amp; hashMap)
193     {
194         uint64_t hashMapSize;
195         if (!decoder.decode(hashMapSize))
196             return false;
197 
198         HashMapType tempHashMap;
<a name="2" id="anc2"></a><span class="line-added">199         tempHashMap.reserveInitialCapacity(static_cast&lt;unsigned&gt;(hashMapSize));</span>
200         for (uint64_t i = 0; i &lt; hashMapSize; ++i) {
201             KeyArg key;
202             MappedArg value;
203             if (!decoder.decode(key))
204                 return false;
205             if (!decoder.decode(value))
206                 return false;
207 
208             if (!tempHashMap.add(key, value).isNewEntry) {
209                 // The hash map already has the specified key, bail.
210                 return false;
211             }
212         }
213 
214         hashMap.swap(tempHashMap);
215         return true;
216     }
217 };
218 
219 template&lt;typename KeyArg, typename HashArg, typename KeyTraitsArg&gt; struct Coder&lt;HashSet&lt;KeyArg, HashArg, KeyTraitsArg&gt;&gt; {
220     typedef HashSet&lt;KeyArg, HashArg, KeyTraitsArg&gt; HashSetType;
221 
222     static void encode(Encoder&amp; encoder, const HashSetType&amp; hashSet)
223     {
224         encoder &lt;&lt; static_cast&lt;uint64_t&gt;(hashSet.size());
225         for (typename HashSetType::const_iterator it = hashSet.begin(), end = hashSet.end(); it != end; ++it)
226             encoder &lt;&lt; *it;
227     }
228 
229     static bool decode(Decoder&amp; decoder, HashSetType&amp; hashSet)
230     {
231         uint64_t hashSetSize;
232         if (!decoder.decode(hashSetSize))
233             return false;
234 
235         HashSetType tempHashSet;
236         for (uint64_t i = 0; i &lt; hashSetSize; ++i) {
237             KeyArg key;
238             if (!decoder.decode(key))
239                 return false;
240 
241             if (!tempHashSet.add(key).isNewEntry) {
242                 // The hash map already has the specified key, bail.
243                 return false;
244             }
245         }
246 
247         hashSet.swap(tempHashSet);
248         return true;
249     }
250 };
251 
252 template&lt;&gt; struct Coder&lt;Seconds&gt; {
253     static void encode(Encoder&amp; encoder, const Seconds&amp; seconds)
254     {
255         encoder &lt;&lt; seconds.value();
256     }
257 
258     static bool decode(Decoder&amp; decoder, Seconds&amp; result)
259     {
260         double value;
261         if (!decoder.decode(value))
262             return false;
263 
264         result = Seconds(value);
265         return true;
266     }
267 };
268 
269 template&lt;&gt; struct Coder&lt;WallTime&gt; {
270     static void encode(Encoder&amp; encoder, const WallTime&amp; time)
271     {
272         encoder &lt;&lt; time.secondsSinceEpoch().value();
273     }
274 
275     static bool decode(Decoder&amp; decoder, WallTime&amp; result)
276     {
277         double value;
278         if (!decoder.decode(value))
279             return false;
280 
281         result = WallTime::fromRawSeconds(value);
282         return true;
283     }
284 };
285 
<a name="3" id="anc3"></a><span class="line-modified">286 template&lt;&gt; struct Coder&lt;AtomString&gt; {</span>
<span class="line-modified">287     WTF_EXPORT_PRIVATE static void encode(Encoder&amp;, const AtomString&amp;);</span>
<span class="line-modified">288     WTF_EXPORT_PRIVATE static bool decode(Decoder&amp;, AtomString&amp;);</span>
289 };
290 
291 template&lt;&gt; struct Coder&lt;CString&gt; {
292     WTF_EXPORT_PRIVATE static void encode(Encoder&amp;, const CString&amp;);
293     WTF_EXPORT_PRIVATE static bool decode(Decoder&amp;, CString&amp;);
294 };
295 
296 template&lt;&gt; struct Coder&lt;String&gt; {
297     WTF_EXPORT_PRIVATE static void encode(Encoder&amp;, const String&amp;);
298     WTF_EXPORT_PRIVATE static bool decode(Decoder&amp;, String&amp;);
299 };
300 
301 template&lt;&gt; struct Coder&lt;SHA1::Digest&gt; {
302     WTF_EXPORT_PRIVATE static void encode(Encoder&amp;, const SHA1::Digest&amp;);
303     WTF_EXPORT_PRIVATE static bool decode(Decoder&amp;, SHA1::Digest&amp;);
304 };
305 
306 }
307 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>