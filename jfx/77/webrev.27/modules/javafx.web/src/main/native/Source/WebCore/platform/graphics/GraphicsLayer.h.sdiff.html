<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayerClient.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Animation.h&quot;
 29 #include &quot;Color.h&quot;

 30 #include &quot;FilterOperations.h&quot;
 31 #include &quot;FloatPoint.h&quot;
 32 #include &quot;FloatPoint3D.h&quot;
 33 #include &quot;FloatRoundedRect.h&quot;
 34 #include &quot;FloatSize.h&quot;
 35 #include &quot;GraphicsLayerClient.h&quot;
 36 #include &quot;Path.h&quot;
 37 #include &quot;PlatformLayer.h&quot;

 38 #include &quot;ScrollableArea.h&quot;
 39 #include &quot;TransformOperations.h&quot;
 40 #include &quot;WindRule.h&quot;
 41 #include &lt;wtf/Function.h&gt;
 42 #include &lt;wtf/TypeCasts.h&gt;
 43 
 44 #if ENABLE(CSS_COMPOSITING)
 45 #include &quot;GraphicsTypes.h&quot;
 46 #endif
 47 
 48 namespace WTF {
 49 class TextStream;
 50 }
 51 
 52 namespace WebCore {
 53 
 54 class GraphicsContext;
 55 class GraphicsLayerFactory;
 56 class Image;
 57 class TiledBacking;
</pre>
<hr />
<pre>
 92 
 93 private:
 94     void operator=(const AnimationValue&amp;) = delete;
 95 
 96     double m_keyTime;
 97     RefPtr&lt;TimingFunction&gt; m_timingFunction;
 98 };
 99 
100 // Used to store one float value of an animation.
101 // FIXME: Should be moved to its own header file.
102 class FloatAnimationValue : public AnimationValue {
103 public:
104     FloatAnimationValue(double keyTime, float value, TimingFunction* timingFunction = nullptr)
105         : AnimationValue(keyTime, timingFunction)
106         , m_value(value)
107     {
108     }
109 
110     std::unique_ptr&lt;AnimationValue&gt; clone() const override
111     {
<span class="line-modified">112         return std::make_unique&lt;FloatAnimationValue&gt;(*this);</span>
113     }
114 
115     float value() const { return m_value; }
116 
117 private:
118     float m_value;
119 };
120 
121 // Used to store one transform value in a keyframe list.
122 // FIXME: Should be moved to its own header file.
123 class TransformAnimationValue : public AnimationValue {
124 public:
125     TransformAnimationValue(double keyTime, const TransformOperations&amp; value, TimingFunction* timingFunction = nullptr)
126         : AnimationValue(keyTime, timingFunction)
127         , m_value(value)
128     {
129     }
130 
131     std::unique_ptr&lt;AnimationValue&gt; clone() const override
132     {
<span class="line-modified">133         return std::make_unique&lt;TransformAnimationValue&gt;(*this);</span>
134     }
135 
136     TransformAnimationValue(const TransformAnimationValue&amp; other)
137         : AnimationValue(other)
138     {
139         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
140         for (auto&amp; operation : other.m_value.operations())
141             m_value.operations().uncheckedAppend(operation-&gt;clone());
142     }
143 
144     TransformAnimationValue(TransformAnimationValue&amp;&amp;) = default;
145 
146     const TransformOperations&amp; value() const { return m_value; }
147 
148 private:
149     TransformOperations m_value;
150 };
151 
152 // Used to store one filter value in a keyframe list.
153 // FIXME: Should be moved to its own header file.
154 class FilterAnimationValue : public AnimationValue {
155 public:
156     FilterAnimationValue(double keyTime, const FilterOperations&amp; value, TimingFunction* timingFunction = nullptr)
157         : AnimationValue(keyTime, timingFunction)
158         , m_value(value)
159     {
160     }
161 
162     std::unique_ptr&lt;AnimationValue&gt; clone() const override
163     {
<span class="line-modified">164         return std::make_unique&lt;FilterAnimationValue&gt;(*this);</span>
165     }
166 
167     FilterAnimationValue(const FilterAnimationValue&amp; other)
168         : AnimationValue(other)
169     {
170         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
171         for (auto&amp; operation : other.m_value.operations())
172             m_value.operations().uncheckedAppend(operation-&gt;clone());
173     }
174 
175     FilterAnimationValue(FilterAnimationValue&amp;&amp;) = default;
176 
177     const FilterOperations&amp; value() const { return m_value; }
178 
179 private:
180     FilterOperations m_value;
181 };
182 
183 // Used to store a series of values in a keyframe list.
184 // Values will all be of the same type, which can be inferred from the property.
</pre>
<hr />
<pre>
221     const AnimationValue&amp; at(size_t i) const { return *m_values.at(i); }
222 
223     // Insert, sorted by keyTime.
224     WEBCORE_EXPORT void insert(std::unique_ptr&lt;const AnimationValue&gt;);
225 
226 protected:
227     Vector&lt;std::unique_ptr&lt;const AnimationValue&gt;&gt; m_values;
228     AnimatedPropertyID m_property;
229 };
230 
231 // GraphicsLayer is an abstraction for a rendering surface with backing store,
232 // which may have associated transformation and animations.
233 
234 class GraphicsLayer : public RefCounted&lt;GraphicsLayer&gt; {
235     WTF_MAKE_FAST_ALLOCATED;
236 public:
237     enum class Type : uint8_t {
238         Normal,
239         PageTiledBacking,
240         ScrollContainer,

241         Shape
242     };
243 
244     WEBCORE_EXPORT static Ref&lt;GraphicsLayer&gt; create(GraphicsLayerFactory*, GraphicsLayerClient&amp;, Type = Type::Normal);
245 
246     WEBCORE_EXPORT virtual ~GraphicsLayer();
247 
248     // Unparent, clear the client, and clear the RefPtr.
249     WEBCORE_EXPORT static void unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp;);
250     // Clear the client, and clear the RefPtr, but leave parented.
251     WEBCORE_EXPORT static void clear(RefPtr&lt;GraphicsLayer&gt;&amp;);
252 
253     WEBCORE_EXPORT void clearClient();
254     WEBCORE_EXPORT void setClient(GraphicsLayerClient&amp;);
255 
256     Type type() const { return m_type; }
257 
258     virtual void initialize(Type) { }
259 
260     using PlatformLayerID = uint64_t;
</pre>
<hr />
<pre>
394 
395     float opacity() const { return m_opacity; }
396     virtual void setOpacity(float opacity) { m_opacity = opacity; }
397 
398     const FilterOperations&amp; filters() const { return m_filters; }
399     // Returns true if filter can be rendered by the compositor.
400     virtual bool setFilters(const FilterOperations&amp; filters) { m_filters = filters; return true; }
401 
402     const FilterOperations&amp; backdropFilters() const { return m_backdropFilters; }
403     virtual bool setBackdropFilters(const FilterOperations&amp; filters) { m_backdropFilters = filters; return true; }
404 
405     virtual void setBackdropFiltersRect(const FloatRoundedRect&amp; backdropFiltersRect) { m_backdropFiltersRect = backdropFiltersRect; }
406     const FloatRoundedRect&amp; backdropFiltersRect() const { return m_backdropFiltersRect; }
407 
408 #if ENABLE(CSS_COMPOSITING)
409     BlendMode blendMode() const { return m_blendMode; }
410     virtual void setBlendMode(BlendMode blendMode) { m_blendMode = blendMode; }
411 #endif
412 
413     // Some GraphicsLayers paint only the foreground or the background content
<span class="line-modified">414     GraphicsLayerPaintingPhase paintingPhase() const { return m_paintingPhase; }</span>
<span class="line-modified">415     void setPaintingPhase(GraphicsLayerPaintingPhase phase) { m_paintingPhase = phase; }</span>
416 
417     enum ShouldClipToLayer {
418         DoNotClipToLayer,
419         ClipToLayer
420     };
421 
422     virtual void setNeedsDisplay() = 0;
423     // mark the given rect (in layer coords) as needing dispay. Never goes deep.
424     virtual void setNeedsDisplayInRect(const FloatRect&amp;, ShouldClipToLayer = ClipToLayer) = 0;
425 
426     virtual void setContentsNeedsDisplay() { };
427 
428     // The tile phase is relative to the GraphicsLayer bounds.
429     virtual void setContentsTilePhase(const FloatSize&amp; p) { m_contentsTilePhase = p; }
430     FloatSize contentsTilePhase() const { return m_contentsTilePhase; }
431 
432     virtual void setContentsTileSize(const FloatSize&amp; s) { m_contentsTileSize = s; }
433     FloatSize contentsTileSize() const { return m_contentsTileSize; }
434     bool hasContentsTiling() const { return !m_contentsTileSize.isEmpty(); }
435 
436     // Set that the position/size of the contents (image or video).
437     FloatRect contentsRect() const { return m_contentsRect; }
438     virtual void setContentsRect(const FloatRect&amp; r) { m_contentsRect = r; }
439 
440     // Set a rounded rect that will be used to clip the layer contents.
441     FloatRoundedRect contentsClippingRect() const { return m_contentsClippingRect; }
442     virtual void setContentsClippingRect(const FloatRoundedRect&amp; roundedRect) { m_contentsClippingRect = roundedRect; }
443 
444     // Set a rounded rect that is used to clip this layer and its descendants (implies setting masksToBounds).
445     // Returns false if the platform can&#39;t support this rounded clip, and we should fall back to painting a mask.
446     FloatRoundedRect maskToBoundsRect() const { return m_masksToBoundsRect; };
447     virtual bool setMasksToBoundsRect(const FloatRoundedRect&amp; roundedRect) { m_masksToBoundsRect = roundedRect; return false; }
448 
449     Path shapeLayerPath() const;
450     virtual void setShapeLayerPath(const Path&amp;);
451 
452     WindRule shapeLayerWindRule() const;
453     virtual void setShapeLayerWindRule(WindRule);
454 



455     // Transitions are identified by a special animation name that cannot clash with a keyframe identifier.
456     static String animationNameForTransition(AnimatedPropertyID);
457 
458     // Return true if the animation is handled by the compositing system. If this returns
459     // false, the animation will be run by CSSAnimationController.
460     // These methods handle both transitions and keyframe animations.
461     virtual bool addAnimation(const KeyframeValueList&amp;, const FloatSize&amp; /*boxSize*/, const Animation*, const String&amp; /*animationName*/, double /*timeOffset*/)  { return false; }
462     virtual void pauseAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
463     virtual void seekAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
464     virtual void removeAnimation(const String&amp; /*animationName*/) { }
465 
466     WEBCORE_EXPORT virtual void suspendAnimations(MonotonicTime);
467     WEBCORE_EXPORT virtual void resumeAnimations();
468 
469     virtual Vector&lt;std::pair&lt;String, double&gt;&gt; acceleratedAnimationsForTesting() const { return { }; }
470 
471     // Layer contents
472     virtual void setContentsToImage(Image*) { }
473     virtual bool shouldDirectlyCompositeImage(Image*) const { return true; }
474 #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
534         DarkBackdrop
535     };
536     virtual void setCustomAppearance(CustomAppearance customAppearance) { m_customAppearance = customAppearance; }
537     CustomAppearance customAppearance() const { return m_customAppearance; }
538 
539     // z-position is the z-equivalent of position(). It&#39;s only used for debugging purposes.
540     virtual float zPosition() const { return m_zPosition; }
541     WEBCORE_EXPORT virtual void setZPosition(float);
542 
543     WEBCORE_EXPORT virtual void distributeOpacity(float);
544     WEBCORE_EXPORT virtual float accumulatedOpacity() const;
545 
546     virtual FloatSize pixelAlignmentOffset() const { return FloatSize(); }
547 
548     virtual void setAppliesPageScale(bool appliesScale = true) { m_appliesPageScale = appliesScale; }
549     virtual bool appliesPageScale() const { return m_appliesPageScale; }
550 
551     float pageScaleFactor() const { return client().pageScaleFactor(); }
552     float deviceScaleFactor() const { return client().deviceScaleFactor(); }
553 
<span class="line-modified">554     // Whether this layer is viewport constrained, implying that it&#39;s moved around externally from GraphicsLayer (e.g. by the scrolling tree).</span>
<span class="line-modified">555     virtual void setIsViewportConstrained(bool) { }</span>
<span class="line-modified">556     virtual bool isViewportConstrained() const { return false; }</span>
557 
558     virtual void deviceOrPageScaleFactorChanged() { }
559     WEBCORE_EXPORT void noteDeviceOrPageScaleFactorChangedIncludingDescendants();
560 
561     void setIsInWindow(bool);
562 
563     // Some compositing systems may do internal batching to synchronize compositing updates
564     // with updates drawn into the window. These methods flush internal batched state on this layer
565     // and descendant layers, and this layer only.
566     virtual void flushCompositingState(const FloatRect&amp; /* clipRect */) { }
567     virtual void flushCompositingStateForThisLayerOnly() { }
568 
569     // If the exposed rect of this layer changes, returns true if this or descendant layers need a flush,
570     // for example to allocate new tiles.
571     virtual bool visibleRectChangeRequiresFlush(const FloatRect&amp; /* clipRect */) const { return false; }
572 


573     // Return a string with a human readable form of the layer tree, If debug is true
574     // pointers for the layers and timing data will be included in the returned string.
575     WEBCORE_EXPORT String layerTreeAsText(LayerTreeAsTextBehavior = LayerTreeAsTextBehaviorNormal) const;
576 
577     // For testing.
578     virtual String displayListAsText(DisplayList::AsTextFlags) const { return String(); }
579 
580     virtual void setIsTrackingDisplayListReplay(bool isTracking) { m_isTrackingDisplayListReplay = isTracking; }
581     virtual bool isTrackingDisplayListReplay() const { return m_isTrackingDisplayListReplay; }
582     virtual String replayDisplayListAsText(DisplayList::AsTextFlags) const { return String(); }
583 
584     // Return an estimate of the backing store memory cost (in bytes). May be incorrect for tiled layers.
585     WEBCORE_EXPORT virtual double backingStoreMemoryEstimate() const;
586 
587     virtual bool backingStoreAttached() const { return true; }
588     virtual bool backingStoreAttachedForTesting() const { return backingStoreAttached(); }
589 
<span class="line-removed">590     void setCanDetachBackingStore(bool b) { m_canDetachBackingStore = b; }</span>
<span class="line-removed">591     bool canDetachBackingStore() const { return m_canDetachBackingStore; }</span>
<span class="line-removed">592 </span>
593     virtual TiledBacking* tiledBacking() const { return 0; }
594 
595     void resetTrackedRepaints();
596     void addRepaintRect(const FloatRect&amp;);
597 
598     static bool supportsBackgroundColorContent();
599     static bool supportsLayerType(Type);
600     static bool supportsContentsTiling();
601     static bool supportsSubpixelAntialiasedLayerText();
602 
603     void updateDebugIndicators();
604 
605     virtual bool canThrottleLayerFlush() const { return false; }
606 
607     virtual bool isGraphicsLayerCA() const { return false; }
608     virtual bool isGraphicsLayerCARemote() const { return false; }
609     virtual bool isGraphicsLayerTextureMapper() const { return false; }
610     virtual bool isCoordinatedGraphicsLayer() const { return false; }
611 
612     const Optional&lt;FloatRect&gt;&amp; animationExtent() const { return m_animationExtent; }
</pre>
<hr />
<pre>
668     FloatPoint3D m_anchorPoint { 0.5f, 0.5f, 0 };
669     FloatSize m_size;
670     FloatPoint m_boundsOrigin;
671 
672     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
673     std::unique_ptr&lt;TransformationMatrix&gt; m_childrenTransform;
674 
675     Color m_backgroundColor;
676     float m_opacity { 1 };
677     float m_zPosition { 0 };
678 
679     FilterOperations m_filters;
680     FilterOperations m_backdropFilters;
681 
682 #if ENABLE(CSS_COMPOSITING)
683     BlendMode m_blendMode { BlendMode::Normal };
684 #endif
685 
686     const Type m_type;
687     CustomAppearance m_customAppearance { CustomAppearance::None };
<span class="line-modified">688     GraphicsLayerPaintingPhase m_paintingPhase { GraphicsLayerPaintAllWithOverflowClip };</span>
689     CompositingCoordinatesOrientation m_contentsOrientation { CompositingCoordinatesOrientation::TopDown }; // affects orientation of layer contents
690 
691     bool m_beingDestroyed : 1;
692     bool m_contentsOpaque : 1;
693     bool m_supportsSubpixelAntialiasedText : 1;
694     bool m_preserves3D: 1;
695     bool m_backfaceVisibility : 1;
696     bool m_masksToBounds : 1;
697     bool m_drawsContent : 1;
698     bool m_contentsVisible : 1;
699     bool m_acceleratesDrawing : 1;
700     bool m_usesDisplayListDrawing : 1;
701     bool m_appliesPageScale : 1; // Set for the layer which has the page scale applied to it.
702     bool m_showDebugBorder : 1;
703     bool m_showRepaintCounter : 1;
704     bool m_isMaskLayer : 1;
705     bool m_isTrackingDisplayListReplay : 1;
706     bool m_userInteractionEnabled : 1;
707     bool m_canDetachBackingStore : 1;
708 
709     int m_repaintCount { 0 };
710 
711     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; m_children;
712     GraphicsLayer* m_parent { nullptr };
713 
714     RefPtr&lt;GraphicsLayer&gt; m_maskLayer { nullptr }; // Reference to mask layer.
715 
716     RefPtr&lt;GraphicsLayer&gt; m_replicaLayer { nullptr }; // A layer that replicates this layer. We only allow one, for now.
717                                    // The replica is not parented; this is the primary reference to it.
718     GraphicsLayer* m_replicatedLayer { nullptr }; // For a replica layer, a reference to the original layer.
719     FloatPoint m_replicatedLayerPosition; // For a replica layer, the position of the replica.
720 
721     FloatRect m_contentsRect;
722     FloatRoundedRect m_contentsClippingRect;
723     FloatRoundedRect m_masksToBoundsRect;
724     FloatSize m_contentsTilePhase;
725     FloatSize m_contentsTileSize;
726     FloatRoundedRect m_backdropFiltersRect;
727     Optional&lt;FloatRect&gt; m_animationExtent;
728 

729 #if USE(CA)
730     WindRule m_shapeLayerWindRule { WindRule::NonZero };
731     Path m_shapeLayerPath;
732 #endif
733 };
734 

735 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp;);
736 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsLayer::CustomAppearance&amp;);
737 
738 } // namespace WebCore
739 
740 #define SPECIALIZE_TYPE_TRAITS_GRAPHICSLAYER(ToValueTypeName, predicate) \
741 SPECIALIZE_TYPE_TRAITS_BEGIN(ToValueTypeName) \
742     static bool isType(const WebCore::GraphicsLayer&amp; layer) { return layer.predicate; } \
743 SPECIALIZE_TYPE_TRAITS_END()
744 
745 #if ENABLE(TREE_DEBUGGING)
746 // Outside the WebCore namespace for ease of invocation from the debugger.
747 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer);
748 #endif
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Animation.h&quot;
 29 #include &quot;Color.h&quot;
<span class="line-added"> 30 #include &quot;EventRegion.h&quot;</span>
 31 #include &quot;FilterOperations.h&quot;
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;FloatPoint3D.h&quot;
 34 #include &quot;FloatRoundedRect.h&quot;
 35 #include &quot;FloatSize.h&quot;
 36 #include &quot;GraphicsLayerClient.h&quot;
 37 #include &quot;Path.h&quot;
 38 #include &quot;PlatformLayer.h&quot;
<span class="line-added"> 39 #include &quot;Region.h&quot;</span>
 40 #include &quot;ScrollableArea.h&quot;
 41 #include &quot;TransformOperations.h&quot;
 42 #include &quot;WindRule.h&quot;
 43 #include &lt;wtf/Function.h&gt;
 44 #include &lt;wtf/TypeCasts.h&gt;
 45 
 46 #if ENABLE(CSS_COMPOSITING)
 47 #include &quot;GraphicsTypes.h&quot;
 48 #endif
 49 
 50 namespace WTF {
 51 class TextStream;
 52 }
 53 
 54 namespace WebCore {
 55 
 56 class GraphicsContext;
 57 class GraphicsLayerFactory;
 58 class Image;
 59 class TiledBacking;
</pre>
<hr />
<pre>
 94 
 95 private:
 96     void operator=(const AnimationValue&amp;) = delete;
 97 
 98     double m_keyTime;
 99     RefPtr&lt;TimingFunction&gt; m_timingFunction;
100 };
101 
102 // Used to store one float value of an animation.
103 // FIXME: Should be moved to its own header file.
104 class FloatAnimationValue : public AnimationValue {
105 public:
106     FloatAnimationValue(double keyTime, float value, TimingFunction* timingFunction = nullptr)
107         : AnimationValue(keyTime, timingFunction)
108         , m_value(value)
109     {
110     }
111 
112     std::unique_ptr&lt;AnimationValue&gt; clone() const override
113     {
<span class="line-modified">114         return makeUnique&lt;FloatAnimationValue&gt;(*this);</span>
115     }
116 
117     float value() const { return m_value; }
118 
119 private:
120     float m_value;
121 };
122 
123 // Used to store one transform value in a keyframe list.
124 // FIXME: Should be moved to its own header file.
125 class TransformAnimationValue : public AnimationValue {
126 public:
127     TransformAnimationValue(double keyTime, const TransformOperations&amp; value, TimingFunction* timingFunction = nullptr)
128         : AnimationValue(keyTime, timingFunction)
129         , m_value(value)
130     {
131     }
132 
133     std::unique_ptr&lt;AnimationValue&gt; clone() const override
134     {
<span class="line-modified">135         return makeUnique&lt;TransformAnimationValue&gt;(*this);</span>
136     }
137 
138     TransformAnimationValue(const TransformAnimationValue&amp; other)
139         : AnimationValue(other)
140     {
141         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
142         for (auto&amp; operation : other.m_value.operations())
143             m_value.operations().uncheckedAppend(operation-&gt;clone());
144     }
145 
146     TransformAnimationValue(TransformAnimationValue&amp;&amp;) = default;
147 
148     const TransformOperations&amp; value() const { return m_value; }
149 
150 private:
151     TransformOperations m_value;
152 };
153 
154 // Used to store one filter value in a keyframe list.
155 // FIXME: Should be moved to its own header file.
156 class FilterAnimationValue : public AnimationValue {
157 public:
158     FilterAnimationValue(double keyTime, const FilterOperations&amp; value, TimingFunction* timingFunction = nullptr)
159         : AnimationValue(keyTime, timingFunction)
160         , m_value(value)
161     {
162     }
163 
164     std::unique_ptr&lt;AnimationValue&gt; clone() const override
165     {
<span class="line-modified">166         return makeUnique&lt;FilterAnimationValue&gt;(*this);</span>
167     }
168 
169     FilterAnimationValue(const FilterAnimationValue&amp; other)
170         : AnimationValue(other)
171     {
172         m_value.operations().reserveInitialCapacity(other.m_value.operations().size());
173         for (auto&amp; operation : other.m_value.operations())
174             m_value.operations().uncheckedAppend(operation-&gt;clone());
175     }
176 
177     FilterAnimationValue(FilterAnimationValue&amp;&amp;) = default;
178 
179     const FilterOperations&amp; value() const { return m_value; }
180 
181 private:
182     FilterOperations m_value;
183 };
184 
185 // Used to store a series of values in a keyframe list.
186 // Values will all be of the same type, which can be inferred from the property.
</pre>
<hr />
<pre>
223     const AnimationValue&amp; at(size_t i) const { return *m_values.at(i); }
224 
225     // Insert, sorted by keyTime.
226     WEBCORE_EXPORT void insert(std::unique_ptr&lt;const AnimationValue&gt;);
227 
228 protected:
229     Vector&lt;std::unique_ptr&lt;const AnimationValue&gt;&gt; m_values;
230     AnimatedPropertyID m_property;
231 };
232 
233 // GraphicsLayer is an abstraction for a rendering surface with backing store,
234 // which may have associated transformation and animations.
235 
236 class GraphicsLayer : public RefCounted&lt;GraphicsLayer&gt; {
237     WTF_MAKE_FAST_ALLOCATED;
238 public:
239     enum class Type : uint8_t {
240         Normal,
241         PageTiledBacking,
242         ScrollContainer,
<span class="line-added">243         ScrolledContents,</span>
244         Shape
245     };
246 
247     WEBCORE_EXPORT static Ref&lt;GraphicsLayer&gt; create(GraphicsLayerFactory*, GraphicsLayerClient&amp;, Type = Type::Normal);
248 
249     WEBCORE_EXPORT virtual ~GraphicsLayer();
250 
251     // Unparent, clear the client, and clear the RefPtr.
252     WEBCORE_EXPORT static void unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp;);
253     // Clear the client, and clear the RefPtr, but leave parented.
254     WEBCORE_EXPORT static void clear(RefPtr&lt;GraphicsLayer&gt;&amp;);
255 
256     WEBCORE_EXPORT void clearClient();
257     WEBCORE_EXPORT void setClient(GraphicsLayerClient&amp;);
258 
259     Type type() const { return m_type; }
260 
261     virtual void initialize(Type) { }
262 
263     using PlatformLayerID = uint64_t;
</pre>
<hr />
<pre>
397 
398     float opacity() const { return m_opacity; }
399     virtual void setOpacity(float opacity) { m_opacity = opacity; }
400 
401     const FilterOperations&amp; filters() const { return m_filters; }
402     // Returns true if filter can be rendered by the compositor.
403     virtual bool setFilters(const FilterOperations&amp; filters) { m_filters = filters; return true; }
404 
405     const FilterOperations&amp; backdropFilters() const { return m_backdropFilters; }
406     virtual bool setBackdropFilters(const FilterOperations&amp; filters) { m_backdropFilters = filters; return true; }
407 
408     virtual void setBackdropFiltersRect(const FloatRoundedRect&amp; backdropFiltersRect) { m_backdropFiltersRect = backdropFiltersRect; }
409     const FloatRoundedRect&amp; backdropFiltersRect() const { return m_backdropFiltersRect; }
410 
411 #if ENABLE(CSS_COMPOSITING)
412     BlendMode blendMode() const { return m_blendMode; }
413     virtual void setBlendMode(BlendMode blendMode) { m_blendMode = blendMode; }
414 #endif
415 
416     // Some GraphicsLayers paint only the foreground or the background content
<span class="line-modified">417     OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase() const { return m_paintingPhase; }</span>
<span class="line-modified">418     void setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt;);</span>
419 
420     enum ShouldClipToLayer {
421         DoNotClipToLayer,
422         ClipToLayer
423     };
424 
425     virtual void setNeedsDisplay() = 0;
426     // mark the given rect (in layer coords) as needing dispay. Never goes deep.
427     virtual void setNeedsDisplayInRect(const FloatRect&amp;, ShouldClipToLayer = ClipToLayer) = 0;
428 
429     virtual void setContentsNeedsDisplay() { };
430 
431     // The tile phase is relative to the GraphicsLayer bounds.
432     virtual void setContentsTilePhase(const FloatSize&amp; p) { m_contentsTilePhase = p; }
433     FloatSize contentsTilePhase() const { return m_contentsTilePhase; }
434 
435     virtual void setContentsTileSize(const FloatSize&amp; s) { m_contentsTileSize = s; }
436     FloatSize contentsTileSize() const { return m_contentsTileSize; }
437     bool hasContentsTiling() const { return !m_contentsTileSize.isEmpty(); }
438 
439     // Set that the position/size of the contents (image or video).
440     FloatRect contentsRect() const { return m_contentsRect; }
441     virtual void setContentsRect(const FloatRect&amp; r) { m_contentsRect = r; }
442 
443     // Set a rounded rect that will be used to clip the layer contents.
444     FloatRoundedRect contentsClippingRect() const { return m_contentsClippingRect; }
445     virtual void setContentsClippingRect(const FloatRoundedRect&amp; roundedRect) { m_contentsClippingRect = roundedRect; }
446 
447     // Set a rounded rect that is used to clip this layer and its descendants (implies setting masksToBounds).
448     // Returns false if the platform can&#39;t support this rounded clip, and we should fall back to painting a mask.
449     FloatRoundedRect maskToBoundsRect() const { return m_masksToBoundsRect; };
450     virtual bool setMasksToBoundsRect(const FloatRoundedRect&amp; roundedRect) { m_masksToBoundsRect = roundedRect; return false; }
451 
452     Path shapeLayerPath() const;
453     virtual void setShapeLayerPath(const Path&amp;);
454 
455     WindRule shapeLayerWindRule() const;
456     virtual void setShapeLayerWindRule(WindRule);
457 
<span class="line-added">458     const EventRegion&amp; eventRegion() const { return m_eventRegion; }</span>
<span class="line-added">459     virtual void setEventRegion(EventRegion&amp;&amp;);</span>
<span class="line-added">460 </span>
461     // Transitions are identified by a special animation name that cannot clash with a keyframe identifier.
462     static String animationNameForTransition(AnimatedPropertyID);
463 
464     // Return true if the animation is handled by the compositing system. If this returns
465     // false, the animation will be run by CSSAnimationController.
466     // These methods handle both transitions and keyframe animations.
467     virtual bool addAnimation(const KeyframeValueList&amp;, const FloatSize&amp; /*boxSize*/, const Animation*, const String&amp; /*animationName*/, double /*timeOffset*/)  { return false; }
468     virtual void pauseAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
469     virtual void seekAnimation(const String&amp; /*animationName*/, double /*timeOffset*/) { }
470     virtual void removeAnimation(const String&amp; /*animationName*/) { }
471 
472     WEBCORE_EXPORT virtual void suspendAnimations(MonotonicTime);
473     WEBCORE_EXPORT virtual void resumeAnimations();
474 
475     virtual Vector&lt;std::pair&lt;String, double&gt;&gt; acceleratedAnimationsForTesting() const { return { }; }
476 
477     // Layer contents
478     virtual void setContentsToImage(Image*) { }
479     virtual bool shouldDirectlyCompositeImage(Image*) const { return true; }
480 #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
540         DarkBackdrop
541     };
542     virtual void setCustomAppearance(CustomAppearance customAppearance) { m_customAppearance = customAppearance; }
543     CustomAppearance customAppearance() const { return m_customAppearance; }
544 
545     // z-position is the z-equivalent of position(). It&#39;s only used for debugging purposes.
546     virtual float zPosition() const { return m_zPosition; }
547     WEBCORE_EXPORT virtual void setZPosition(float);
548 
549     WEBCORE_EXPORT virtual void distributeOpacity(float);
550     WEBCORE_EXPORT virtual float accumulatedOpacity() const;
551 
552     virtual FloatSize pixelAlignmentOffset() const { return FloatSize(); }
553 
554     virtual void setAppliesPageScale(bool appliesScale = true) { m_appliesPageScale = appliesScale; }
555     virtual bool appliesPageScale() const { return m_appliesPageScale; }
556 
557     float pageScaleFactor() const { return client().pageScaleFactor(); }
558     float deviceScaleFactor() const { return client().deviceScaleFactor(); }
559 
<span class="line-modified">560     // Whether this layer can throw away backing store to save memory. False for layers that can be revealed by async scrolling.</span>
<span class="line-modified">561     virtual void setAllowsBackingStoreDetaching(bool) { }</span>
<span class="line-modified">562     virtual bool allowsBackingStoreDetaching() const { return true; }</span>
563 
564     virtual void deviceOrPageScaleFactorChanged() { }
565     WEBCORE_EXPORT void noteDeviceOrPageScaleFactorChangedIncludingDescendants();
566 
567     void setIsInWindow(bool);
568 
569     // Some compositing systems may do internal batching to synchronize compositing updates
570     // with updates drawn into the window. These methods flush internal batched state on this layer
571     // and descendant layers, and this layer only.
572     virtual void flushCompositingState(const FloatRect&amp; /* clipRect */) { }
573     virtual void flushCompositingStateForThisLayerOnly() { }
574 
575     // If the exposed rect of this layer changes, returns true if this or descendant layers need a flush,
576     // for example to allocate new tiles.
577     virtual bool visibleRectChangeRequiresFlush(const FloatRect&amp; /* clipRect */) const { return false; }
578 
<span class="line-added">579     static FloatRect adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect);</span>
<span class="line-added">580 </span>
581     // Return a string with a human readable form of the layer tree, If debug is true
582     // pointers for the layers and timing data will be included in the returned string.
583     WEBCORE_EXPORT String layerTreeAsText(LayerTreeAsTextBehavior = LayerTreeAsTextBehaviorNormal) const;
584 
585     // For testing.
586     virtual String displayListAsText(DisplayList::AsTextFlags) const { return String(); }
587 
588     virtual void setIsTrackingDisplayListReplay(bool isTracking) { m_isTrackingDisplayListReplay = isTracking; }
589     virtual bool isTrackingDisplayListReplay() const { return m_isTrackingDisplayListReplay; }
590     virtual String replayDisplayListAsText(DisplayList::AsTextFlags) const { return String(); }
591 
592     // Return an estimate of the backing store memory cost (in bytes). May be incorrect for tiled layers.
593     WEBCORE_EXPORT virtual double backingStoreMemoryEstimate() const;
594 
595     virtual bool backingStoreAttached() const { return true; }
596     virtual bool backingStoreAttachedForTesting() const { return backingStoreAttached(); }
597 



598     virtual TiledBacking* tiledBacking() const { return 0; }
599 
600     void resetTrackedRepaints();
601     void addRepaintRect(const FloatRect&amp;);
602 
603     static bool supportsBackgroundColorContent();
604     static bool supportsLayerType(Type);
605     static bool supportsContentsTiling();
606     static bool supportsSubpixelAntialiasedLayerText();
607 
608     void updateDebugIndicators();
609 
610     virtual bool canThrottleLayerFlush() const { return false; }
611 
612     virtual bool isGraphicsLayerCA() const { return false; }
613     virtual bool isGraphicsLayerCARemote() const { return false; }
614     virtual bool isGraphicsLayerTextureMapper() const { return false; }
615     virtual bool isCoordinatedGraphicsLayer() const { return false; }
616 
617     const Optional&lt;FloatRect&gt;&amp; animationExtent() const { return m_animationExtent; }
</pre>
<hr />
<pre>
673     FloatPoint3D m_anchorPoint { 0.5f, 0.5f, 0 };
674     FloatSize m_size;
675     FloatPoint m_boundsOrigin;
676 
677     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
678     std::unique_ptr&lt;TransformationMatrix&gt; m_childrenTransform;
679 
680     Color m_backgroundColor;
681     float m_opacity { 1 };
682     float m_zPosition { 0 };
683 
684     FilterOperations m_filters;
685     FilterOperations m_backdropFilters;
686 
687 #if ENABLE(CSS_COMPOSITING)
688     BlendMode m_blendMode { BlendMode::Normal };
689 #endif
690 
691     const Type m_type;
692     CustomAppearance m_customAppearance { CustomAppearance::None };
<span class="line-modified">693     OptionSet&lt;GraphicsLayerPaintingPhase&gt; m_paintingPhase { GraphicsLayerPaintingPhase::Foreground, GraphicsLayerPaintingPhase::Background };</span>
694     CompositingCoordinatesOrientation m_contentsOrientation { CompositingCoordinatesOrientation::TopDown }; // affects orientation of layer contents
695 
696     bool m_beingDestroyed : 1;
697     bool m_contentsOpaque : 1;
698     bool m_supportsSubpixelAntialiasedText : 1;
699     bool m_preserves3D: 1;
700     bool m_backfaceVisibility : 1;
701     bool m_masksToBounds : 1;
702     bool m_drawsContent : 1;
703     bool m_contentsVisible : 1;
704     bool m_acceleratesDrawing : 1;
705     bool m_usesDisplayListDrawing : 1;
706     bool m_appliesPageScale : 1; // Set for the layer which has the page scale applied to it.
707     bool m_showDebugBorder : 1;
708     bool m_showRepaintCounter : 1;
709     bool m_isMaskLayer : 1;
710     bool m_isTrackingDisplayListReplay : 1;
711     bool m_userInteractionEnabled : 1;
712     bool m_canDetachBackingStore : 1;
713 
714     int m_repaintCount { 0 };
715 
716     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; m_children;
717     GraphicsLayer* m_parent { nullptr };
718 
719     RefPtr&lt;GraphicsLayer&gt; m_maskLayer { nullptr }; // Reference to mask layer.
720 
721     RefPtr&lt;GraphicsLayer&gt; m_replicaLayer { nullptr }; // A layer that replicates this layer. We only allow one, for now.
722                                    // The replica is not parented; this is the primary reference to it.
723     GraphicsLayer* m_replicatedLayer { nullptr }; // For a replica layer, a reference to the original layer.
724     FloatPoint m_replicatedLayerPosition; // For a replica layer, the position of the replica.
725 
726     FloatRect m_contentsRect;
727     FloatRoundedRect m_contentsClippingRect;
728     FloatRoundedRect m_masksToBoundsRect;
729     FloatSize m_contentsTilePhase;
730     FloatSize m_contentsTileSize;
731     FloatRoundedRect m_backdropFiltersRect;
732     Optional&lt;FloatRect&gt; m_animationExtent;
733 
<span class="line-added">734     EventRegion m_eventRegion;</span>
735 #if USE(CA)
736     WindRule m_shapeLayerWindRule { WindRule::NonZero };
737     Path m_shapeLayerPath;
738 #endif
739 };
740 
<span class="line-added">741 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const WebCore::GraphicsLayerPaintingPhase);</span>
742 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp;);
743 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsLayer::CustomAppearance&amp;);
744 
745 } // namespace WebCore
746 
747 #define SPECIALIZE_TYPE_TRAITS_GRAPHICSLAYER(ToValueTypeName, predicate) \
748 SPECIALIZE_TYPE_TRAITS_BEGIN(ToValueTypeName) \
749     static bool isType(const WebCore::GraphicsLayer&amp; layer) { return layer.predicate; } \
750 SPECIALIZE_TYPE_TRAITS_END()
751 
752 #if ENABLE(TREE_DEBUGGING)
753 // Outside the WebCore namespace for ease of invocation from the debugger.
754 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer);
755 #endif
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayerClient.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>