<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;EventHandler.h&quot;
  30 
  31 #include &quot;AutoscrollController.h&quot;
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
  37 #include &quot;CursorList.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;DragController.h&quot;
  40 #include &quot;DragState.h&quot;
  41 #include &quot;Editing.h&quot;
  42 #include &quot;Editor.h&quot;
  43 #include &quot;EditorClient.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FileList.h&quot;
  46 #include &quot;FloatPoint.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameSelection.h&quot;
  52 #include &quot;FrameTree.h&quot;
  53 #include &quot;FrameView.h&quot;
<a name="1" id="anc1"></a>
  54 #include &quot;HTMLDocument.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLIFrameElement.h&quot;
  59 #include &quot;HTMLInputElement.h&quot;
  60 #include &quot;HTMLNames.h&quot;
  61 #include &quot;HitTestRequest.h&quot;
  62 #include &quot;HitTestResult.h&quot;
  63 #include &quot;Image.h&quot;
  64 #include &quot;InspectorInstrumentation.h&quot;
  65 #include &quot;KeyboardEvent.h&quot;
  66 #include &quot;Logging.h&quot;
  67 #include &quot;MouseEvent.h&quot;
  68 #include &quot;MouseEventWithHitTestResults.h&quot;
  69 #include &quot;NotImplemented.h&quot;
  70 #include &quot;Page.h&quot;
  71 #include &quot;PageOverlayController.h&quot;
  72 #include &quot;Pasteboard.h&quot;
  73 #include &quot;PlatformEvent.h&quot;
  74 #include &quot;PlatformKeyboardEvent.h&quot;
  75 #include &quot;PlatformWheelEvent.h&quot;
  76 #include &quot;PluginDocument.h&quot;
  77 #include &quot;Range.h&quot;
  78 #include &quot;RenderFrameSet.h&quot;
  79 #include &quot;RenderLayer.h&quot;
  80 #include &quot;RenderListBox.h&quot;
  81 #include &quot;RenderTextControlSingleLine.h&quot;
  82 #include &quot;RenderView.h&quot;
  83 #include &quot;RenderWidget.h&quot;
  84 #include &quot;ResourceLoadObserver.h&quot;
  85 #include &quot;RuntimeApplicationChecks.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGNames.h&quot;
  88 #include &quot;ScrollLatchingState.h&quot;
  89 #include &quot;Scrollbar.h&quot;
  90 #include &quot;Settings.h&quot;
  91 #include &quot;ShadowRoot.h&quot;
  92 #include &quot;SpatialNavigation.h&quot;
  93 #include &quot;StaticPasteboard.h&quot;
  94 #include &quot;StyleCachedImage.h&quot;
  95 #include &quot;TextEvent.h&quot;
  96 #include &quot;TextIterator.h&quot;
  97 #include &quot;UserGestureIndicator.h&quot;
  98 #include &quot;UserTypingGestureIndicator.h&quot;
  99 #include &quot;ValidationMessageClient.h&quot;
 100 #include &quot;VisibleUnits.h&quot;
 101 #include &quot;WheelEvent.h&quot;
 102 #include &quot;WheelEventDeltaFilter.h&quot;
 103 #include &quot;WindowsKeyboardCodes.h&quot;
 104 #include &lt;wtf/Assertions.h&gt;
 105 #include &lt;wtf/NeverDestroyed.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 
 108 #if ENABLE(IOS_TOUCH_EVENTS)
 109 #include &quot;PlatformTouchEventIOS.h&quot;
 110 #endif
 111 
 112 #if ENABLE(TOUCH_EVENTS)
 113 #include &quot;TouchEvent.h&quot;
 114 #include &quot;TouchList.h&quot;
 115 #endif
 116 
 117 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 118 #include &quot;PlatformTouchEvent.h&quot;
 119 #endif
 120 
 121 #if ENABLE(MAC_GESTURE_EVENTS)
 122 #include &quot;PlatformGestureEventMac.h&quot;
 123 #endif
 124 
 125 #if ENABLE(POINTER_LOCK)
 126 #include &quot;PointerLockController.h&quot;
 127 #endif
 128 
<a name="2" id="anc2"></a>







 129 namespace WebCore {
 130 
 131 using namespace HTMLNames;
 132 
 133 #if ENABLE(DRAG_SUPPORT)
 134 // The link drag hysteresis is much larger than the others because there
 135 // needs to be enough space to cancel the link press without starting a link drag,
 136 // and because dragging links is rare.
 137 const int LinkDragHysteresis = 40;
 138 const int ImageDragHysteresis = 5;
 139 const int TextDragHysteresis = 3;
 140 const int ColorDragHystersis = 3;
 141 const int GeneralDragHysteresis = 3;
 142 #if PLATFORM(MAC)
 143 const Seconds EventHandler::TextDragDelay { 150_ms };
 144 #else
 145 const Seconds EventHandler::TextDragDelay { 0_s };
 146 #endif
 147 #endif // ENABLE(DRAG_SUPPORT)
 148 
 149 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 150 const float GestureUnknown = 0;
 151 #endif
 152 
 153 #if ENABLE(IOS_TOUCH_EVENTS)
 154 // FIXME: Share this constant with EventHandler and SliderThumbElement.
 155 const unsigned InvalidTouchIdentifier = 0;
 156 #endif
 157 
 158 // Match key code of composition keydown event on windows.
 159 // IE sends VK_PROCESSKEY which has value 229;
 160 const int CompositionEventKeyCode = 229;
 161 
 162 using namespace SVGNames;
 163 
 164 #if !ENABLE(IOS_TOUCH_EVENTS)
 165 // The amount of time to wait before sending a fake mouse event, triggered
 166 // during a scroll. The short interval is used if the content responds to the mouse events
 167 // in fakeMouseMoveDurationThreshold or less, otherwise the long interval is used.
 168 const double fakeMouseMoveDurationThreshold = 0.01;
 169 const Seconds fakeMouseMoveShortInterval = { 100_ms };
 170 const Seconds fakeMouseMoveLongInterval = { 250_ms };
 171 #endif
 172 
 173 #if ENABLE(CURSOR_SUPPORT)
 174 // The amount of time to wait for a cursor update on style and layout changes
 175 // Set to 50Hz, no need to be faster than common screen refresh rate
 176 static const Seconds cursorUpdateInterval { 20_ms };
 177 
 178 const int maximumCursorSize = 128;
 179 #endif
 180 
 181 #if ENABLE(MOUSE_CURSOR_SCALE)
 182 // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
 183 // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
 184 // dividing cursor sizes (limited above) by the scale.
 185 const double minimumCursorScale = 0.001;
 186 #endif
 187 
 188 class MaximumDurationTracker {
 189 public:
 190     explicit MaximumDurationTracker(double *maxDuration)
 191         : m_maxDuration(maxDuration)
 192         , m_start(MonotonicTime::now())
 193     {
 194     }
 195 
 196     ~MaximumDurationTracker()
 197     {
 198         *m_maxDuration = std::max(*m_maxDuration, (MonotonicTime::now() - m_start).seconds());
 199     }
 200 
 201 private:
 202     double* m_maxDuration;
 203     MonotonicTime m_start;
 204 };
 205 
 206 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 207 class SyntheticTouchPoint : public PlatformTouchPoint {
 208 public:
 209 
 210     // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 211     explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
 212     {
 213         const static int idDefaultValue = 0;
 214         const static int radiusYDefaultValue = 1;
 215         const static int radiusXDefaultValue = 1;
 216         const static float rotationAngleDefaultValue = 0.0f;
 217         const static float forceDefaultValue = 1.0f;
 218 
 219         m_id = idDefaultValue; // There is only one active TouchPoint.
 220         m_screenPos = event.globalPosition();
 221         m_pos = event.position();
 222         m_radiusY = radiusYDefaultValue;
 223         m_radiusX = radiusXDefaultValue;
 224         m_rotationAngle = rotationAngleDefaultValue;
 225         m_force = forceDefaultValue;
 226 
 227         PlatformEvent::Type type = event.type();
 228         ASSERT(type == PlatformEvent::MouseMoved || type == PlatformEvent::MousePressed || type == PlatformEvent::MouseReleased);
 229 
 230         switch (type) {
 231         case PlatformEvent::MouseMoved:
 232             m_state = TouchMoved;
 233             break;
 234         case PlatformEvent::MousePressed:
 235             m_state = TouchPressed;
 236             break;
 237         case PlatformEvent::MouseReleased:
 238             m_state = TouchReleased;
 239             break;
 240         default:
 241             ASSERT_NOT_REACHED();
 242             break;
 243         }
 244     }
 245 };
 246 
 247 class SyntheticSingleTouchEvent : public PlatformTouchEvent {
 248 public:
 249     explicit SyntheticSingleTouchEvent(const PlatformMouseEvent&amp; event)
 250     {
 251         switch (event.type()) {
 252         case PlatformEvent::MouseMoved:
 253             m_type = TouchMove;
 254             break;
 255         case PlatformEvent::MousePressed:
 256             m_type = TouchStart;
 257             break;
 258         case PlatformEvent::MouseReleased:
 259             m_type = TouchEnd;
 260             break;
 261         default:
 262             ASSERT_NOT_REACHED();
 263             m_type = NoType;
 264             break;
 265         }
 266         m_timestamp = event.timestamp();
 267         m_modifiers = event.modifiers();
 268         m_touchPoints.append(SyntheticTouchPoint(event));
 269     }
 270 };
 271 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 272 
 273 static inline ScrollGranularity wheelGranularityToScrollGranularity(unsigned deltaMode)
 274 {
 275     switch (deltaMode) {
 276     case WheelEvent::DOM_DELTA_PAGE:
 277         return ScrollByPage;
 278     case WheelEvent::DOM_DELTA_LINE:
 279         return ScrollByLine;
 280     case WheelEvent::DOM_DELTA_PIXEL:
 281         return ScrollByPixel;
 282     default:
 283         return ScrollByPixel;
 284     }
 285 }
 286 
 287 static inline bool didScrollInScrollableArea(ScrollableArea* scrollableArea, WheelEvent&amp; wheelEvent)
 288 {
 289     ScrollGranularity scrollGranularity = wheelGranularityToScrollGranularity(wheelEvent.deltaMode());
 290     bool didHandleWheelEvent = false;
 291     if (float absoluteDelta = std::abs(wheelEvent.deltaX()))
 292         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaX() &gt; 0 ? ScrollRight : ScrollLeft, scrollGranularity, absoluteDelta);
 293 
 294     if (float absoluteDelta = std::abs(wheelEvent.deltaY()))
 295         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
 296 
 297     return didHandleWheelEvent;
 298 }
 299 
 300 static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, Element** stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)
 301 {
 302     bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
 303 #if PLATFORM(MAC)
 304     shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
 305 #if ENABLE(CSS_SCROLL_SNAP)
 306     shouldHandleEvent |= wheelEvent.momentumPhase() == PlatformWheelEventPhaseEnded;
 307 #endif
 308 #endif
 309     if (!startNode-&gt;renderer() || !shouldHandleEvent)
 310         return false;
 311 
 312     RenderBox&amp; initialEnclosingBox = startNode-&gt;renderer()-&gt;enclosingBox();
 313     if (initialEnclosingBox.isListBox())
 314         return didScrollInScrollableArea(static_cast&lt;RenderListBox*&gt;(&amp;initialEnclosingBox), wheelEvent);
 315 
 316     RenderBox* currentEnclosingBox = &amp;initialEnclosingBox;
 317     while (currentEnclosingBox) {
 318         if (RenderLayer* boxLayer = currentEnclosingBox-&gt;layer()) {
 319             auto platformEvent = wheelEvent.underlyingPlatformEvent();
 320             bool scrollingWasHandled;
 321             if (platformEvent) {
 322                 auto copiedEvent = platformEvent-&gt;copyWithDeltasAndVelocity(filteredPlatformDelta.width(), filteredPlatformDelta.height(), filteredVelocity);
 323                 scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
 324             } else
 325                 scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
 326 
 327             if (scrollingWasHandled) {
 328                 if (stopElement)
 329                     *stopElement = currentEnclosingBox-&gt;element();
 330                 return true;
 331             }
 332         }
 333 
 334         if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == currentEnclosingBox-&gt;element())
 335             return true;
 336 
 337         currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
 338         if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
 339             return false;
 340     }
 341     return false;
 342 }
 343 
 344 #if (ENABLE(TOUCH_EVENTS) &amp;&amp; !PLATFORM(IOS_FAMILY))
 345 static inline bool shouldGesturesTriggerActive()
 346 {
 347     // If the platform we&#39;re on supports GestureTapDown and GestureTapCancel then we&#39;ll
 348     // rely on them to set the active state. Unfortunately there&#39;s no generic way to
 349     // know in advance what event types are supported.
 350     return false;
 351 }
 352 #endif
 353 
 354 #if !PLATFORM(COCOA)
 355 
 356 inline bool EventHandler::eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;)
 357 {
 358     return false;
 359 }
 360 
 361 #if ENABLE(DRAG_SUPPORT)
 362 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 363 {
 364     return false;
 365 }
 366 #endif
 367 
 368 #endif
 369 
 370 EventHandler::EventHandler(Frame&amp; frame)
 371     : m_frame(frame)
 372     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
 373 #if ENABLE(CURSOR_SUPPORT)
 374     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
 375 #endif
 376 #if PLATFORM(MAC)
 377     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 378 #endif
<a name="3" id="anc3"></a><span class="line-modified"> 379     , m_autoscrollController(std::make_unique&lt;AutoscrollController&gt;())</span>
 380 #if !ENABLE(IOS_TOUCH_EVENTS)
 381     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 382 #endif
 383 #if ENABLE(CURSOR_VISIBILITY)
 384     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 385 #endif
 386 {
 387 }
 388 
 389 EventHandler::~EventHandler()
 390 {
 391 #if !ENABLE(IOS_TOUCH_EVENTS)
 392     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 393 #endif
 394 #if ENABLE(CURSOR_VISIBILITY)
 395     ASSERT(!m_autoHideCursorTimer.isActive());
 396 #endif
 397 }
 398 
 399 #if ENABLE(DRAG_SUPPORT)
 400 
 401 DragState&amp; EventHandler::dragState()
 402 {
 403     static NeverDestroyed&lt;DragState&gt; state;
 404     return state;
 405 }
 406 
 407 #endif
 408 
 409 void EventHandler::clear()
 410 {
 411     m_hoverTimer.stop();
 412 #if ENABLE(CURSOR_SUPPORT)
 413     m_cursorUpdateTimer.stop();
 414 #endif
 415 #if !ENABLE(IOS_TOUCH_EVENTS)
 416     m_fakeMouseMoveEventTimer.stop();
 417 #endif
 418 #if ENABLE(CURSOR_VISIBILITY)
 419     cancelAutoHideCursorTimer();
 420 #endif
 421     m_resizeLayer = nullptr;
 422     m_elementUnderMouse = nullptr;
 423     m_lastElementUnderMouse = nullptr;
 424     m_lastMouseMoveEventSubframe = nullptr;
 425     m_lastScrollbarUnderMouse = nullptr;
 426     m_clickCount = 0;
 427     m_clickNode = nullptr;
 428 #if ENABLE(IOS_GESTURE_EVENTS)
 429     m_gestureInitialDiameter = GestureUnknown;
 430     m_gestureInitialRotation = GestureUnknown;
 431 #endif
 432 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 433     m_gestureLastDiameter = GestureUnknown;
 434     m_gestureLastRotation = GestureUnknown;
 435     m_gestureTargets.clear();
 436 #endif
 437 #if ENABLE(IOS_TOUCH_EVENTS)
 438     m_touches.clear();
 439     m_firstTouchID = InvalidTouchIdentifier;
 440     m_touchEventTargetSubframe = nullptr;
 441 #endif
 442     m_frameSetBeingResized = nullptr;
 443 #if ENABLE(DRAG_SUPPORT)
 444     m_dragTarget = nullptr;
 445     m_shouldOnlyFireDragOverEvent = false;
 446 #endif
 447     m_mousePositionIsUnknown = true;
 448     m_lastKnownMousePosition = IntPoint();
 449     m_lastKnownMouseGlobalPosition = IntPoint();
 450     m_mousePressNode = nullptr;
 451     m_mousePressed = false;
 452     m_capturesDragging = false;
 453     m_capturingMouseEventsElement = nullptr;
 454     clearLatchedState();
 455 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 456     m_originatingTouchPointTargets.clear();
 457     m_originatingTouchPointDocument = nullptr;
 458     m_originatingTouchPointTargetKey = 0;
 459 #endif
 460     m_maxMouseMovedDuration = 0;
 461     m_didStartDrag = false;
 462 }
 463 
 464 void EventHandler::nodeWillBeRemoved(Node&amp; nodeToBeRemoved)
 465 {
 466     if (nodeToBeRemoved.contains(m_clickNode.get()))
 467         m_clickNode = nullptr;
 468 }
 469 
 470 static void setSelectionIfNeeded(FrameSelection&amp; selection, const VisibleSelection&amp; newSelection)
 471 {
 472     if (selection.selection() != newSelection &amp;&amp; selection.shouldChangeSelection(newSelection))
 473         selection.setSelection(newSelection);
 474 }
 475 
 476 static inline bool dispatchSelectStart(Node* node)
 477 {
 478     if (!node || !node-&gt;renderer())
 479         return true;
 480 
 481     auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
 482     node-&gt;dispatchEvent(event);
 483     return !event-&gt;defaultPrevented();
 484 }
 485 
 486 static Node* nodeToSelectOnMouseDownForNode(Node&amp; targetNode)
 487 {
 488 #if ENABLE(USERSELECT_ALL)
 489     if (Node* rootUserSelectAll = Position::rootUserSelectAllForNode(&amp;targetNode))
 490         return rootUserSelectAll;
 491 #endif
 492 
 493     if (targetNode.shouldSelectOnMouseDown())
 494         return &amp;targetNode;
 495 
 496     return nullptr;
 497 }
 498 
 499 static VisibleSelection expandSelectionToRespectSelectOnMouseDown(Node&amp; targetNode, const VisibleSelection&amp; selection)
 500 {
 501     Node* nodeToSelect = nodeToSelectOnMouseDownForNode(targetNode);
 502     if (!nodeToSelect)
 503         return selection;
 504 
 505     VisibleSelection newSelection(selection);
 506     newSelection.setBase(positionBeforeNode(nodeToSelect).upstream(CanCrossEditingBoundary));
 507     newSelection.setExtent(positionAfterNode(nodeToSelect).downstream(CanCrossEditingBoundary));
 508 
 509     return newSelection;
 510 }
 511 
 512 bool EventHandler::updateSelectionForMouseDownDispatchingSelectStart(Node* targetNode, const VisibleSelection&amp; selection, TextGranularity granularity)
 513 {
 514     if (Position::nodeIsUserSelectNone(targetNode))
 515         return false;
 516 
 517     if (!dispatchSelectStart(targetNode)) {
 518         m_mouseDownMayStartSelect = false;
 519         return false;
 520     }
 521 
 522     if (selection.isRange())
 523         m_selectionInitiationState = ExtendedSelection;
 524     else {
 525         granularity = CharacterGranularity;
 526         m_selectionInitiationState = PlacedCaret;
 527     }
 528 
 529     m_frame.selection().setSelectionByMouseIfDifferent(selection, granularity);
 530 
 531     return true;
 532 }
 533 
 534 void EventHandler::selectClosestWordFromHitTestResult(const HitTestResult&amp; result, AppendTrailingWhitespace appendTrailingWhitespace)
 535 {
 536     Node* targetNode = result.targetNode();
 537     VisibleSelection newSelection;
 538 
 539     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 540         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 541         if (pos.isNotNull()) {
 542             newSelection = VisibleSelection(pos);
 543             newSelection.expandUsingGranularity(WordGranularity);
 544         }
 545 
 546         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 547             newSelection.appendTrailingWhitespace();
 548 
 549         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 550     }
 551 }
 552 
 553 static AppendTrailingWhitespace shouldAppendTrailingWhitespace(const MouseEventWithHitTestResults&amp; result, const Frame&amp; frame)
 554 {
 555     return (result.event().clickCount() == 2 &amp;&amp; frame.editor().isSelectTrailingWhitespaceEnabled()) ? ShouldAppendTrailingWhitespace : DontAppendTrailingWhitespace;
 556 }
 557 
 558 void EventHandler::selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 559 {
 560     if (m_mouseDownMayStartSelect)
 561         selectClosestWordFromHitTestResult(result.hitTestResult(), shouldAppendTrailingWhitespace(result, m_frame));
 562 }
 563 
 564 #if !PLATFORM(MAC)
 565 VisibleSelection EventHandler::selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;)
 566 {
 567     return VisibleSelection();
 568 }
 569 #endif
 570 
 571 void EventHandler::selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent)
 572 {
 573     Node* targetNode = mouseEvent.targetNode();
 574     const HitTestResult&amp; result = mouseEvent.hitTestResult();
 575     VisibleSelection newSelection;
 576     bool appendTrailingWhitespace = shouldAppendTrailingWhitespace(mouseEvent, m_frame);
 577 
 578     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 579         newSelection = selectClosestWordFromHitTestResultBasedOnLookup(result);
 580         if (newSelection.isNone()) {
 581             VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 582             if (pos.isNotNull()) {
 583                 newSelection = VisibleSelection(pos);
 584                 newSelection.expandUsingGranularity(WordGranularity);
 585             }
 586         }
 587 
 588         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 589             newSelection.appendTrailingWhitespace();
 590 
 591         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 592     }
 593 }
 594 
 595 void EventHandler::selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 596 {
 597     Element* urlElement = result.hitTestResult().URLElement();
 598     if (!urlElement || !isDraggableLink(*urlElement)) {
 599         if (Node* targetNode = result.targetNode()) {
 600             if (isEditableNode(*targetNode))
 601                 return selectClosestWordFromMouseEvent(result);
 602         }
 603 
 604         return selectClosestContextualWordFromMouseEvent(result);
 605     }
 606 
 607     Node* targetNode = result.targetNode();
 608 
 609     if (targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect) {
 610         VisibleSelection newSelection;
 611         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 612         if (pos.isNotNull() &amp;&amp; pos.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*urlElement))
 613             newSelection = VisibleSelection::selectionFromContentsOfNode(urlElement);
 614 
 615         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 616     }
 617 }
 618 
 619 bool EventHandler::handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp; event)
 620 {
 621     if (event.event().button() != LeftButton)
 622         return false;
 623 
 624     if (m_frame.selection().isRange())
 625         // A double-click when range is already selected
 626         // should not change the selection.  So, do not call
 627         // selectClosestWordFromMouseEvent, but do set
 628         // m_beganSelectingText to prevent handleMouseReleaseEvent
 629         // from setting caret selection.
 630         m_selectionInitiationState = ExtendedSelection;
 631     else
 632         selectClosestWordFromMouseEvent(event);
 633 
 634     return true;
 635 }
 636 
 637 bool EventHandler::handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp; event)
 638 {
 639     if (event.event().button() != LeftButton)
 640         return false;
 641 
 642     Node* targetNode = event.targetNode();
 643     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 644         return false;
 645 
 646     VisibleSelection newSelection;
 647     VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 648     if (pos.isNotNull()) {
 649         newSelection = VisibleSelection(pos);
 650         newSelection.expandUsingGranularity(ParagraphGranularity);
 651     }
 652 
 653     return updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), ParagraphGranularity);
 654 }
 655 
 656 static int textDistance(const Position&amp; start, const Position&amp; end)
 657 {
 658     auto range = Range::create(start.anchorNode()-&gt;document(), start, end);
 659     return TextIterator::rangeLength(range.ptr(), true);
 660 }
 661 
 662 bool EventHandler::handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp; event)
 663 {
 664     Ref&lt;Frame&gt; protectedFrame(m_frame);
 665 
 666     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 667     Node* targetNode = event.targetNode();
 668     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 669         return false;
 670 
 671     // Extend the selection if the Shift key is down, unless the click is in a link.
 672     bool extendSelection = event.event().shiftKey() &amp;&amp; !event.isOverLink();
 673 
 674     // Don&#39;t restart the selection when the mouse is pressed on an
 675     // existing selection so we can allow for text dragging.
 676     if (FrameView* view = m_frame.view()) {
 677         LayoutPoint vPoint = view-&gt;windowToContents(event.event().position());
 678         if (!extendSelection &amp;&amp; m_frame.selection().contains(vPoint)) {
 679             m_mouseDownWasSingleClickInSelection = true;
 680             return false;
 681         }
 682     }
 683 
 684     VisiblePosition visiblePos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 685     if (visiblePos.isNull())
 686         visiblePos = VisiblePosition(firstPositionInOrBeforeNode(targetNode), DOWNSTREAM);
 687     Position pos = visiblePos.deepEquivalent();
 688 
 689     VisibleSelection newSelection = m_frame.selection().selection();
 690     TextGranularity granularity = CharacterGranularity;
 691 
<a name="4" id="anc4"></a><span class="line-modified"> 692 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 693     // The text selection assistant will handle selection in the case where we are already editing the node</span>
<span class="line-removed"> 694     if (newSelection.rootEditableElement() == targetNode-&gt;rootEditableElement())</span>
 695         return true;
<a name="5" id="anc5"></a><span class="line-removed"> 696 #endif</span>
 697 
 698     if (extendSelection &amp;&amp; newSelection.isCaretOrRange()) {
 699         VisibleSelection selectionInUserSelectAll = expandSelectionToRespectSelectOnMouseDown(*targetNode, VisibleSelection(pos));
 700         if (selectionInUserSelectAll.isRange()) {
 701             if (comparePositions(selectionInUserSelectAll.start(), newSelection.start()) &lt; 0)
 702                 pos = selectionInUserSelectAll.start();
 703             else if (comparePositions(newSelection.end(), selectionInUserSelectAll.end()) &lt; 0)
 704                 pos = selectionInUserSelectAll.end();
 705         }
 706 
 707         if (!m_frame.editor().behavior().shouldConsiderSelectionAsDirectional() &amp;&amp; pos.isNotNull()) {
 708             // See &lt;rdar://problem/3668157&gt; REGRESSION (Mail): shift-click deselects when selection
 709             // was created right-to-left
 710             Position start = newSelection.start();
 711             Position end = newSelection.end();
 712             int distanceToStart = textDistance(start, pos);
 713             int distanceToEnd = textDistance(pos, end);
 714             if (distanceToStart &lt;= distanceToEnd)
 715                 newSelection = VisibleSelection(end, pos);
 716             else
 717                 newSelection = VisibleSelection(start, pos);
 718         } else
 719             newSelection.setExtent(pos);
 720 
 721         if (m_frame.selection().granularity() != CharacterGranularity) {
 722             granularity = m_frame.selection().granularity();
 723             newSelection.expandUsingGranularity(m_frame.selection().granularity());
 724         }
 725     } else
 726         newSelection = expandSelectionToRespectSelectOnMouseDown(*targetNode, visiblePos);
 727 
 728     bool handled = updateSelectionForMouseDownDispatchingSelectStart(targetNode, newSelection, granularity);
 729 
 730     if (event.event().button() == MiddleButton) {
 731         // Ignore handled, since we want to paste to where the caret was placed anyway.
 732         handled = handlePasteGlobalSelection(event.event()) || handled;
 733     }
 734     return handled;
 735 }
 736 
 737 static inline bool canMouseDownStartSelect(Node* node)
 738 {
 739     if (!node || !node-&gt;renderer())
 740         return true;
 741 
 742     return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
 743 }
 744 
 745 bool EventHandler::handleMousePressEvent(const MouseEventWithHitTestResults&amp; event)
 746 {
 747     Ref&lt;Frame&gt; protectedFrame(m_frame);
 748 
 749 #if ENABLE(DRAG_SUPPORT)
 750     // Reset drag state.
 751     dragState().source = nullptr;
 752 #endif
 753 
 754 #if !ENABLE(IOS_TOUCH_EVENTS)
 755     cancelFakeMouseMoveEvent();
 756 #endif
 757 
 758     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 759 
 760     if (ScrollView* scrollView = m_frame.view()) {
 761         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 762             return false;
 763     }
 764 
 765     bool singleClick = event.event().clickCount() &lt;= 1;
 766 
 767     // If we got the event back, that must mean it wasn&#39;t prevented,
 768     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
 769     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();
 770 
 771 #if ENABLE(DRAG_SUPPORT)
 772     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 773     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 774     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 775 
 776     // Single mouse down on links or images can always trigger drag-n-drop.
 777     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
<a name="6" id="anc6"></a><span class="line-modified"> 778     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage);</span>
 779 #endif
 780 
 781     m_mouseDownWasSingleClickInSelection = false;
 782 
 783     m_mouseDown = event.event();
 784 
 785     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 786         m_immediateActionStage = ImmediateActionStage::None;
 787 
 788     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 789         return true;
 790 
 791     if (is&lt;SVGDocument&gt;(*m_frame.document()) &amp;&amp; downcast&lt;SVGDocument&gt;(*m_frame.document()).zoomAndPanEnabled()) {
 792         if (event.event().shiftKey() &amp;&amp; singleClick) {
 793             m_svgPan = true;
 794             downcast&lt;SVGDocument&gt;(*m_frame.document()).startPan(m_frame.view()-&gt;windowToContents(event.event().position()));
 795             return true;
 796         }
 797     }
 798 
 799     // We don&#39;t do this at the start of mouse down handling,
 800     // because we don&#39;t want to do it until we know we didn&#39;t hit a widget.
 801     if (singleClick)
 802         focusDocumentView();
 803 
 804     m_mousePressNode = event.targetNode();
 805     m_frame.document()-&gt;setFocusNavigationStartingNode(event.targetNode());
 806 
 807 #if ENABLE(DRAG_SUPPORT)
 808     m_dragStartPosition = event.event().position();
 809 #endif
 810 
 811     m_mousePressed = true;
 812     m_selectionInitiationState = HaveNotStartedSelection;
 813 
 814     bool swallowEvent = false;
 815     if (event.event().clickCount() == 2)
 816         swallowEvent = handleMousePressEventDoubleClick(event);
 817     else if (event.event().clickCount() &gt;= 3)
 818         swallowEvent = handleMousePressEventTripleClick(event);
 819     else
 820         swallowEvent = handleMousePressEventSingleClick(event);
 821 
 822     m_mouseDownMayStartAutoscroll = m_mouseDownMayStartSelect
 823         || (m_mousePressNode &amp;&amp; m_mousePressNode-&gt;renderBox() &amp;&amp; m_mousePressNode-&gt;renderBox()-&gt;canBeProgramaticallyScrolled());
 824 
 825     return swallowEvent;
 826 }
 827 
 828 VisiblePosition EventHandler::selectionExtentRespectingEditingBoundary(const VisibleSelection&amp; selection, const LayoutPoint&amp; localPoint, Node* targetNode)
 829 {
 830     FloatPoint selectionEndPoint = localPoint;
 831     Element* editableElement = selection.rootEditableElement();
 832 
 833     if (!targetNode || !targetNode-&gt;renderer())
 834         return VisiblePosition();
 835 
 836     if (editableElement &amp;&amp; !editableElement-&gt;contains(targetNode)) {
 837         if (!editableElement-&gt;renderer())
 838             return VisiblePosition();
 839 
 840         FloatPoint absolutePoint = targetNode-&gt;renderer()-&gt;localToAbsolute(FloatPoint(selectionEndPoint));
 841         selectionEndPoint = editableElement-&gt;renderer()-&gt;absoluteToLocal(absolutePoint);
 842         targetNode = editableElement;
 843     }
 844 
 845     return targetNode-&gt;renderer()-&gt;positionForPoint(LayoutPoint(selectionEndPoint), nullptr);
 846 }
 847 
 848 #if ENABLE(DRAG_SUPPORT)
<a name="7" id="anc7"></a>














 849 bool EventHandler::handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
 850 {
 851     if (!m_mousePressed)
 852         return false;
 853 
 854     Ref&lt;Frame&gt; protectedFrame(m_frame);
 855 
 856     if (handleDrag(event, checkDragHysteresis))
 857         return true;
 858 
 859     Node* targetNode = event.targetNode();
 860     if (event.event().button() != LeftButton || !targetNode)
 861         return false;
 862 
 863     RenderObject* renderer = targetNode-&gt;renderer();
 864     if (!renderer) {
 865         Element* parent = targetNode-&gt;parentOrShadowHostElement();
 866         if (!parent)
 867             return false;
 868 
 869         renderer = parent-&gt;renderer();
 870         if (!renderer || !renderer-&gt;isListBox())
 871             return false;
 872     }
 873 
 874 #if PLATFORM(COCOA) // FIXME: Why does this assertion fire on other platforms?
 875     ASSERT(m_mouseDownMayStartSelect || m_mouseDownMayStartAutoscroll);
 876 #endif
 877 
 878     m_mouseDownMayStartDrag = false;
 879 
 880     if (m_mouseDownMayStartAutoscroll &amp;&amp; !panScrollInProgress()) {
 881         m_autoscrollController-&gt;startAutoscrollForSelection(renderer);
 882         m_mouseDownMayStartAutoscroll = false;
 883     }
 884 
 885     if (m_selectionInitiationState != ExtendedSelection) {
 886         HitTestResult result(m_mouseDownPos);
 887         m_frame.document()-&gt;hitTest(HitTestRequest(), result);
 888 
 889         updateSelectionForMouseDrag(result);
 890     }
 891     updateSelectionForMouseDrag(event.hitTestResult());
 892     return true;
 893 }
 894 
 895 bool EventHandler::eventMayStartDrag(const PlatformMouseEvent&amp; event) const
 896 {
 897     // This is a pre-flight check of whether the event might lead to a drag being started.  Be careful
 898     // that its logic needs to stay in sync with handleMouseMoveEvent() and the way we setMouseDownMayStartDrag
 899     // in handleMousePressEvent
 900     auto* document = m_frame.document();
 901     if (!document)
 902         return false;
 903 
 904     if (event.button() != LeftButton || event.clickCount() != 1)
 905         return false;
 906 
 907     FrameView* view = m_frame.view();
 908     if (!view)
 909         return false;
 910 
 911     Page* page = m_frame.page();
 912     if (!page)
 913         return false;
 914 
 915     Ref&lt;Frame&gt; protectedFrame(m_frame);
 916 
 917     updateDragSourceActionsAllowed();
 918     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
 919     HitTestResult result(view-&gt;windowToContents(event.position()));
 920     document-&gt;hitTest(request, result);
 921     DragState state;
 922     Element* targetElement = result.targetElement();
 923     return targetElement &amp;&amp; page-&gt;dragController().draggableElement(&amp;m_frame, targetElement, result.roundedPointInInnerNodeFrame(), state);
 924 }
 925 
 926 void EventHandler::updateSelectionForMouseDrag()
 927 {
<a name="8" id="anc8"></a>


 928     FrameView* view = m_frame.view();
 929     if (!view)
 930         return;
 931     auto* document = m_frame.document();
 932     if (!document)
 933         return;
 934 
 935     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
 936     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
 937     document-&gt;hitTest(request, result);
 938     updateSelectionForMouseDrag(result);
 939 }
 940 
 941 void EventHandler::updateSelectionForMouseDrag(const HitTestResult&amp; hitTestResult)
 942 {
<a name="9" id="anc9"></a>


 943     if (!m_mouseDownMayStartSelect)
 944         return;
 945 
 946     Node* target = hitTestResult.targetNode();
 947     if (!target)
 948         return;
 949 
 950     VisiblePosition targetPosition = selectionExtentRespectingEditingBoundary(m_frame.selection().selection(), hitTestResult.localPoint(), target);
 951 
 952     // Don&#39;t modify the selection if we&#39;re not on a node.
 953     if (targetPosition.isNull())
 954         return;
 955 
 956     // Restart the selection if this is the first mouse move. This work is usually
 957     // done in handleMousePressEvent, but not if the mouse press was on an existing selection.
 958     VisibleSelection newSelection = m_frame.selection().selection();
 959 
 960     // Special case to limit selection to the containing block for SVG text.
 961     // FIXME: Isn&#39;t there a better non-SVG-specific way to do this?
 962     if (Node* selectionBaseNode = newSelection.base().deprecatedNode()) {
 963         if (RenderObject* selectionBaseRenderer = selectionBaseNode-&gt;renderer()) {
 964             if (selectionBaseRenderer-&gt;isSVGText()) {
 965                 if (target-&gt;renderer()-&gt;containingBlock() != selectionBaseRenderer-&gt;containingBlock())
 966                     return;
 967             }
 968         }
 969     }
 970 
 971 
 972     if (m_selectionInitiationState == HaveNotStartedSelection &amp;&amp; !dispatchSelectStart(target)) {
 973         m_mouseDownMayStartSelect = false;
 974         return;
 975     }
 976 
 977     if (m_selectionInitiationState != ExtendedSelection) {
 978         // Always extend selection here because it&#39;s caused by a mouse drag
 979         m_selectionInitiationState = ExtendedSelection;
 980         newSelection = VisibleSelection(targetPosition);
 981     }
 982 
 983 #if ENABLE(USERSELECT_ALL)
 984     Node* rootUserSelectAllForMousePressNode = Position::rootUserSelectAllForNode(m_mousePressNode.get());
 985     if (rootUserSelectAllForMousePressNode &amp;&amp; rootUserSelectAllForMousePressNode == Position::rootUserSelectAllForNode(target)) {
 986         newSelection.setBase(positionBeforeNode(rootUserSelectAllForMousePressNode).upstream(CanCrossEditingBoundary));
 987         newSelection.setExtent(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
 988     } else {
 989         // Reset base for user select all when base is inside user-select-all area and extent &lt; base.
 990         if (rootUserSelectAllForMousePressNode &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
 991             newSelection.setBase(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
 992 
 993         Node* rootUserSelectAllForTarget = Position::rootUserSelectAllForNode(target);
 994         if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer() &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
 995             newSelection.setExtent(positionBeforeNode(rootUserSelectAllForTarget).upstream(CanCrossEditingBoundary));
 996         else if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer())
 997             newSelection.setExtent(positionAfterNode(rootUserSelectAllForTarget).downstream(CanCrossEditingBoundary));
 998         else
 999             newSelection.setExtent(targetPosition);
1000     }
1001 #else
1002     newSelection.setExtent(targetPosition);
1003 #endif
1004 
1005     if (m_frame.selection().granularity() != CharacterGranularity)
1006         newSelection.expandUsingGranularity(m_frame.selection().granularity());
1007 
1008     m_frame.selection().setSelectionByMouseIfDifferent(newSelection, m_frame.selection().granularity(),
1009         FrameSelection::AdjustEndpointsAtBidiBoundary);
1010 }
1011 #endif // ENABLE(DRAG_SUPPORT)
1012 
1013 void EventHandler::lostMouseCapture()
1014 {
1015     m_frame.selection().setCaretBlinkingSuspended(false);
1016 }
1017 
1018 bool EventHandler::handleMouseUp(const MouseEventWithHitTestResults&amp; event)
1019 {
1020     if (eventLoopHandleMouseUp(event))
1021         return true;
1022 
1023     // If this was the first click in the window, we don&#39;t even want to clear the selection.
1024     // This case occurs when the user clicks on a draggable element, since we have to process
1025     // the mouse down and drag events to see if we might start a drag.  For other first clicks
1026     // in a window, we just don&#39;t acceptFirstMouse, and the whole down-drag-up sequence gets
1027     // ignored upstream of this layer.
1028     return eventActivatedView(event.event());
1029 }
1030 
1031 bool EventHandler::handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp; event)
1032 {
1033     if (autoscrollInProgress())
1034         stopAutoscrollTimer();
1035 
1036     Ref&lt;Frame&gt; protectedFrame(m_frame);
1037 
1038     if (handleMouseUp(event))
1039         return true;
1040 
1041     // Used to prevent mouseMoveEvent from initiating a drag before
1042     // the mouse is pressed again.
1043     m_mousePressed = false;
1044     m_capturesDragging = false;
1045 #if ENABLE(DRAG_SUPPORT)
1046     m_mouseDownMayStartDrag = false;
1047 #endif
1048     m_mouseDownMayStartSelect = false;
1049     m_mouseDownMayStartAutoscroll = false;
1050     m_mouseDownWasInSubframe = false;
1051 
1052     bool handled = false;
1053 
1054     // Clear the selection if the mouse didn&#39;t move after the last mouse
1055     // press and it&#39;s not a context menu click.  We do this so when clicking
1056     // on the selection, the selection goes away.  However, if we are
1057     // editing, place the caret.
1058     if (m_mouseDownWasSingleClickInSelection &amp;&amp; m_selectionInitiationState != ExtendedSelection
1059 #if ENABLE(DRAG_SUPPORT)
1060             &amp;&amp; m_dragStartPosition == event.event().position()
1061 #endif
1062             &amp;&amp; m_frame.selection().isRange()
1063             &amp;&amp; event.event().button() != RightButton) {
1064         VisibleSelection newSelection;
1065         Node* node = event.targetNode();
1066         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
1067         bool allowSelectionChanges = true;
1068         if (node &amp;&amp; node-&gt;renderer() &amp;&amp; (caretBrowsing || node-&gt;hasEditableStyle())) {
1069             VisiblePosition pos = node-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr);
1070             newSelection = VisibleSelection(pos);
1071 #if PLATFORM(IOS_FAMILY)
1072             // On iOS, selection changes are triggered using platform-specific text interaction gestures rather than
1073             // default behavior on click or mouseup. As such, the only time we should allow click events to change the
1074             // selection on iOS is when we focus a different editable element, in which case the text interaction
1075             // gestures will fail.
1076             allowSelectionChanges = m_frame.selection().selection().rootEditableElement() != newSelection.rootEditableElement();
1077 #endif
1078         }
1079 
1080         if (allowSelectionChanges)
1081             setSelectionIfNeeded(m_frame.selection(), newSelection);
1082 
1083         handled = true;
1084     }
1085 
1086     if (event.event().button() == MiddleButton) {
1087         // Ignore handled, since we want to paste to where the caret was placed anyway.
1088         handled = handlePasteGlobalSelection(event.event()) || handled;
1089     }
1090 
1091     return handled;
1092 }
1093 
1094 #if ENABLE(PAN_SCROLLING)
1095 
1096 void EventHandler::didPanScrollStart()
1097 {
1098     m_autoscrollController-&gt;didPanScrollStart();
1099 }
1100 
1101 void EventHandler::didPanScrollStop()
1102 {
1103     m_autoscrollController-&gt;didPanScrollStop();
1104 }
1105 
1106 void EventHandler::startPanScrolling(RenderElement&amp; renderer)
1107 {
1108 #if !PLATFORM(IOS_FAMILY)
1109     if (!is&lt;RenderBox&gt;(renderer))
1110         return;
1111     m_autoscrollController-&gt;startPanScrolling(&amp;downcast&lt;RenderBox&gt;(renderer), lastKnownMousePosition());
1112     invalidateClick();
1113 #endif
1114 }
1115 
1116 #endif // ENABLE(PAN_SCROLLING)
1117 
1118 RenderBox* EventHandler::autoscrollRenderer() const
1119 {
1120     return m_autoscrollController-&gt;autoscrollRenderer();
1121 }
1122 
1123 void EventHandler::updateAutoscrollRenderer()
1124 {
1125     m_autoscrollController-&gt;updateAutoscrollRenderer();
1126 }
1127 
1128 bool EventHandler::autoscrollInProgress() const
1129 {
1130     return m_autoscrollController-&gt;autoscrollInProgress();
1131 }
1132 
1133 bool EventHandler::panScrollInProgress() const
1134 {
1135     return m_autoscrollController-&gt;panScrollInProgress();
1136 }
1137 
1138 #if ENABLE(DRAG_SUPPORT)
1139 DragSourceAction EventHandler::updateDragSourceActionsAllowed() const
1140 {
1141     Page* page = m_frame.page();
1142     if (!page)
1143         return DragSourceActionNone;
1144 
1145     FrameView* view = m_frame.view();
1146     if (!view)
1147         return DragSourceActionNone;
1148 
1149     return page-&gt;dragController().delegateDragSourceAction(view-&gt;contentsToRootView(m_mouseDownPos));
1150 }
1151 #endif // ENABLE(DRAG_SUPPORT)
1152 
1153 HitTestResult EventHandler::hitTestResultAtPoint(const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType, const LayoutSize&amp; padding) const
1154 {
1155     ASSERT((hitType &amp; HitTestRequest::CollectMultipleElements) || padding.isEmpty());
1156 
1157     Ref&lt;Frame&gt; protectedFrame(m_frame);
1158 
1159     // We always send hitTestResultAtPoint to the main frame if we have one,
1160     // otherwise we might hit areas that are obscured by higher frames.
1161     if (!m_frame.isMainFrame()) {
1162         Frame&amp; mainFrame = m_frame.mainFrame();
1163         FrameView* frameView = m_frame.view();
1164         FrameView* mainView = mainFrame.view();
1165         if (frameView &amp;&amp; mainView) {
1166             IntPoint mainFramePoint = mainView-&gt;rootViewToContents(frameView-&gt;contentsToRootView(roundedIntPoint(point)));
1167             return mainFrame.eventHandler().hitTestResultAtPoint(mainFramePoint, hitType, padding);
1168         }
1169     }
1170 
1171     unsigned nonNegativePaddingWidth = std::max&lt;LayoutUnit&gt;(0, padding.width()).toUnsigned();
1172     unsigned nonNegativePaddingHeight = std::max&lt;LayoutUnit&gt;(0, padding.height()).toUnsigned();
1173 
1174     // We should always start hit testing a clean tree.
1175     if (auto* frameView = m_frame.view())
1176         frameView-&gt;updateLayoutAndStyleIfNeededRecursive();
1177 
1178     HitTestResult result(point, nonNegativePaddingHeight, nonNegativePaddingWidth, nonNegativePaddingHeight, nonNegativePaddingWidth);
1179     auto* document = m_frame.document();
1180     if (!document)
1181         return result;
1182 
<a name="10" id="anc10"></a><span class="line-modified">1183     // hitTestResultAtPoint is specifically used to hitTest into all frames, thus it always allows child frame content.</span>
<span class="line-removed">1184     HitTestRequest request(hitType | HitTestRequest::AllowChildFrameContent);</span>
1185     document-&gt;hitTest(request, result);
1186     if (!request.readOnly())
1187         m_frame.document()-&gt;updateHoverActiveState(request, result.targetElement());
1188 
1189     if (request.disallowsUserAgentShadowContent())
1190         result.setToNonUserAgentShadowAncestor();
1191 
1192     return result;
1193 }
1194 
1195 void EventHandler::stopAutoscrollTimer(bool rendererIsBeingDestroyed)
1196 {
1197     m_autoscrollController-&gt;stopAutoscrollTimer(rendererIsBeingDestroyed);
1198 }
1199 
1200 bool EventHandler::scrollOverflow(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1201 {
1202     Node* node = startingNode;
1203 
1204     if (!node)
1205         node = m_frame.document()-&gt;focusedElement();
1206 
1207     if (!node)
1208         node = m_mousePressNode.get();
1209 
1210     if (node) {
1211         auto r = node-&gt;renderer();
1212         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().scroll(direction, granularity)) {
1213             setFrameWasScrolledByUser();
1214             return true;
1215         }
1216     }
1217 
1218     return false;
1219 }
1220 
1221 bool EventHandler::logicalScrollOverflow(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1222 {
1223     Node* node = startingNode;
1224 
1225     if (!node)
1226         node = m_frame.document()-&gt;focusedElement();
1227 
1228     if (!node)
1229         node = m_mousePressNode.get();
1230 
1231     if (node) {
1232         auto r = node-&gt;renderer();
1233         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().logicalScroll(direction, granularity)) {
1234             setFrameWasScrolledByUser();
1235             return true;
1236         }
1237     }
1238 
1239     return false;
1240 }
1241 
1242 bool EventHandler::scrollRecursively(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1243 {
1244     Ref&lt;Frame&gt; protectedFrame(m_frame);
1245 
1246     // The layout needs to be up to date to determine if we can scroll. We may be
1247     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1248     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1249     if (scrollOverflow(direction, granularity, startingNode))
1250         return true;
1251     Frame* frame = &amp;m_frame;
1252     FrameView* view = frame-&gt;view();
1253     if (view &amp;&amp; view-&gt;scroll(direction, granularity))
1254         return true;
1255     frame = frame-&gt;tree().parent();
1256     if (!frame)
1257         return false;
1258     return frame-&gt;eventHandler().scrollRecursively(direction, granularity, m_frame.ownerElement());
1259 }
1260 
1261 bool EventHandler::logicalScrollRecursively(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1262 {
1263     Ref&lt;Frame&gt; protectedFrame(m_frame);
1264 
1265     // The layout needs to be up to date to determine if we can scroll. We may be
1266     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1267     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1268     if (logicalScrollOverflow(direction, granularity, startingNode))
1269         return true;
1270     Frame* frame = &amp;m_frame;
1271     FrameView* view = frame-&gt;view();
1272 
1273     bool scrolled = false;
1274 #if PLATFORM(COCOA)
1275     // Mac also resets the scroll position in the inline direction.
1276     if (granularity == ScrollByDocument &amp;&amp; view &amp;&amp; view-&gt;logicalScroll(ScrollInlineDirectionBackward, ScrollByDocument))
1277         scrolled = true;
1278 #endif
1279     if (view &amp;&amp; view-&gt;logicalScroll(direction, granularity))
1280         scrolled = true;
1281 
1282     if (scrolled)
1283         return true;
1284 
1285     frame = frame-&gt;tree().parent();
1286     if (!frame)
1287         return false;
1288 
1289     return frame-&gt;eventHandler().logicalScrollRecursively(direction, granularity, m_frame.ownerElement());
1290 }
1291 
1292 IntPoint EventHandler::lastKnownMousePosition() const
1293 {
1294     return m_lastKnownMousePosition;
1295 }
1296 
1297 Frame* EventHandler::subframeForHitTestResult(const MouseEventWithHitTestResults&amp; hitTestResult)
1298 {
1299     if (!hitTestResult.isOverWidget())
1300         return 0;
1301     return subframeForTargetNode(hitTestResult.targetNode());
1302 }
1303 
1304 Frame* EventHandler::subframeForTargetNode(Node* node)
1305 {
1306     if (!node)
1307         return nullptr;
1308 
1309     auto renderer = node-&gt;renderer();
1310     if (!is&lt;RenderWidget&gt;(renderer))
1311         return nullptr;
1312 
1313     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
1314     if (!is&lt;FrameView&gt;(widget))
1315         return nullptr;
1316 
1317     return &amp;downcast&lt;FrameView&gt;(*widget).frame();
1318 }
1319 
1320 #if ENABLE(CURSOR_SUPPORT)
1321 static bool isSubmitImage(Node* node)
1322 {
1323     return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
1324 }
1325 
1326 // Returns true if the node&#39;s editable block is not current focused for editing
1327 static bool nodeIsNotBeingEdited(const Node&amp; node, const Frame&amp; frame)
1328 {
1329     return frame.selection().selection().rootEditableElement() != node.rootEditableElement();
1330 }
1331 
1332 bool EventHandler::useHandCursor(Node* node, bool isOverLink, bool shiftKey)
1333 {
1334     if (!node)
1335         return false;
1336 
1337     bool editable = node-&gt;hasEditableStyle();
1338     bool editableLinkEnabled = false;
1339 
1340     // If the link is editable, then we need to check the settings to see whether or not the link should be followed
1341     if (editable) {
1342         switch (m_frame.settings().editableLinkBehavior()) {
1343         default:
1344         case EditableLinkDefaultBehavior:
1345         case EditableLinkAlwaysLive:
1346             editableLinkEnabled = true;
1347             break;
1348 
1349         case EditableLinkNeverLive:
1350             editableLinkEnabled = false;
1351             break;
1352 
1353         case EditableLinkLiveWhenNotFocused:
1354             editableLinkEnabled = nodeIsNotBeingEdited(*node, m_frame) || shiftKey;
1355             break;
1356 
1357         case EditableLinkOnlyLiveWithShiftKey:
1358             editableLinkEnabled = shiftKey;
1359             break;
1360         }
1361     }
1362 
1363     return ((isOverLink || isSubmitImage(node)) &amp;&amp; (!editable || editableLinkEnabled));
1364 }
1365 
1366 void EventHandler::cursorUpdateTimerFired()
1367 {
1368     ASSERT(m_frame.document());
1369     updateCursor();
1370 }
1371 
1372 void EventHandler::updateCursor()
1373 {
1374     if (m_mousePositionIsUnknown)
1375         return;
1376 
1377     FrameView* view = m_frame.view();
1378     if (!view)
1379         return;
1380 
1381     auto* document = m_frame.document();
1382     if (!document)
1383         return;
1384 
1385     if (!view-&gt;shouldSetCursor())
1386         return;
1387 
1388     bool shiftKey;
1389     bool ctrlKey;
1390     bool altKey;
1391     bool metaKey;
1392     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
1393 
1394     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::AllowFrameScrollbars);
1395     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
1396     document-&gt;hitTest(request, result);
1397 
1398     updateCursor(*view, result, shiftKey);
1399 }
1400 
1401 void EventHandler::updateCursor(FrameView&amp; view, const HitTestResult&amp; result, bool shiftKey)
1402 {
1403     if (auto optionalCursor = selectCursor(result, shiftKey)) {
1404         m_currentMouseCursor = WTFMove(optionalCursor.value());
1405         view.setCursor(m_currentMouseCursor);
1406     }
1407 }
1408 
1409 Optional&lt;Cursor&gt; EventHandler::selectCursor(const HitTestResult&amp; result, bool shiftKey)
1410 {
1411     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1412         return WTF::nullopt;
1413 
1414     if (!m_frame.page())
1415         return WTF::nullopt;
1416 
1417 #if ENABLE(PAN_SCROLLING)
1418     if (m_frame.mainFrame().eventHandler().panScrollInProgress())
1419         return WTF::nullopt;
1420 #endif
1421 
1422     Ref&lt;Frame&gt; protectedFrame(m_frame);
1423 
1424     // Use always pointer cursor for scrollbars.
1425     if (result.scrollbar()) {
1426 #if ENABLE(CURSOR_VISIBILITY)
1427         cancelAutoHideCursorTimer();
1428 #endif
1429         return pointerCursor();
1430     }
1431 
1432     Node* node = result.targetNode();
1433     if (!node)
1434         return WTF::nullopt;
1435 
1436     auto renderer = node-&gt;renderer();
1437     auto* style = renderer ? &amp;renderer-&gt;style() : nullptr;
1438     bool horizontalText = !style || style-&gt;isHorizontalWritingMode();
1439     const Cursor&amp; iBeam = horizontalText ? iBeamCursor() : verticalTextCursor();
1440 
1441 #if ENABLE(CURSOR_VISIBILITY)
1442     if (style &amp;&amp; style-&gt;cursorVisibility() == CursorVisibility::AutoHide)
1443         startAutoHideCursorTimer();
1444     else
1445         cancelAutoHideCursorTimer();
1446 #endif
1447 
1448     if (renderer) {
1449         Cursor overrideCursor;
1450         switch (renderer-&gt;getCursor(roundedIntPoint(result.localPoint()), overrideCursor)) {
1451         case SetCursorBasedOnStyle:
1452             break;
1453         case SetCursor:
1454             return overrideCursor;
1455         case DoNotSetCursor:
1456             return WTF::nullopt;
1457         }
1458     }
1459 
1460     if (style &amp;&amp; style-&gt;cursors()) {
1461         const CursorList* cursors = style-&gt;cursors();
1462         for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i) {
1463             StyleImage* styleImage = (*cursors)[i].image();
1464             if (!styleImage)
1465                 continue;
1466             CachedImage* cachedImage = styleImage-&gt;cachedImage();
1467             if (!cachedImage)
1468                 continue;
1469             float scale = styleImage-&gt;imageScaleFactor();
1470             // Get hotspot and convert from logical pixels to physical pixels.
1471             IntPoint hotSpot = (*cursors)[i].hotSpot();
1472             FloatSize size = cachedImage-&gt;imageForRenderer(renderer)-&gt;size();
1473             if (cachedImage-&gt;errorOccurred())
1474                 continue;
1475             // Limit the size of cursors (in UI pixels) so that they cannot be
1476             // used to cover UI elements in chrome.
1477             size.scale(1 / scale);
1478             if (size.width() &gt; maximumCursorSize || size.height() &gt; maximumCursorSize)
1479                 continue;
1480 
1481             Image* image = cachedImage-&gt;imageForRenderer(renderer);
1482 #if ENABLE(MOUSE_CURSOR_SCALE)
1483             // Ensure no overflow possible in calculations above.
1484             if (scale &lt; minimumCursorScale)
1485                 continue;
1486             return Cursor(image, hotSpot, scale);
1487 #else
1488             ASSERT(scale == 1);
1489             return Cursor(image, hotSpot);
1490 #endif // ENABLE(MOUSE_CURSOR_SCALE)
1491         }
1492     }
1493 
1494     // During selection, use an I-beam regardless of the content beneath the cursor.
1495     // If a drag may be starting or we&#39;re capturing mouse events for a particular node, don&#39;t treat this as a selection.
1496     if (m_mousePressed
1497         &amp;&amp; m_mouseDownMayStartSelect
1498 #if ENABLE(DRAG_SUPPORT)
1499         &amp;&amp; !m_mouseDownMayStartDrag
1500 #endif
1501         &amp;&amp; m_frame.selection().isCaretOrRange()
1502         &amp;&amp; !m_capturingMouseEventsElement)
1503         return iBeam;
1504 
1505     switch (style ? style-&gt;cursor() : CursorType::Auto) {
1506     case CursorType::Auto: {
1507         bool editable = node-&gt;hasEditableStyle();
1508 
1509         if (useHandCursor(node, result.isOverLink(), shiftKey))
1510             return handCursor();
1511 
1512         bool inResizer = false;
1513         if (renderer) {
1514             if (RenderLayer* layer = renderer-&gt;enclosingLayer()) {
1515                 if (FrameView* view = m_frame.view())
1516                     inResizer = layer-&gt;isPointInResizeControl(view-&gt;windowToContents(roundedIntPoint(result.localPoint())));
1517             }
1518         }
1519 
1520         if ((editable || (renderer &amp;&amp; renderer-&gt;isText() &amp;&amp; node-&gt;canStartSelection())) &amp;&amp; !inResizer &amp;&amp; !result.scrollbar())
1521             return iBeam;
1522         return pointerCursor();
1523     }
1524     case CursorType::Default:
1525         return pointerCursor();
1526     case CursorType::None:
1527         return noneCursor();
1528     case CursorType::ContextMenu:
1529         return contextMenuCursor();
1530     case CursorType::Help:
1531         return helpCursor();
1532     case CursorType::Pointer:
1533         return handCursor();
1534     case CursorType::Progress:
1535         return progressCursor();
1536     case CursorType::Wait:
1537         return waitCursor();
1538     case CursorType::Cell:
1539         return cellCursor();
1540     case CursorType::Crosshair:
1541         return crossCursor();
1542     case CursorType::Text:
1543         return iBeamCursor();
1544     case CursorType::VerticalText:
1545         return verticalTextCursor();
1546     case CursorType::Alias:
1547         return aliasCursor();
1548     case CursorType::Copy:
1549         return copyCursor();
1550     case CursorType::Move:
1551         return moveCursor();
1552     case CursorType::NoDrop:
1553         return noDropCursor();
1554     case CursorType::NotAllowed:
1555         return notAllowedCursor();
1556     case CursorType::Grab:
1557         return grabCursor();
1558     case CursorType::Grabbing:
1559         return grabbingCursor();
1560     case CursorType::EResize:
1561         return eastResizeCursor();
1562     case CursorType::NResize:
1563         return northResizeCursor();
1564     case CursorType::NEResize:
1565         return northEastResizeCursor();
1566     case CursorType::NWResize:
1567         return northWestResizeCursor();
1568     case CursorType::SResize:
1569         return southResizeCursor();
1570     case CursorType::SEResize:
1571         return southEastResizeCursor();
1572     case CursorType::SWResize:
1573         return southWestResizeCursor();
1574     case CursorType::WResize:
1575         return westResizeCursor();
1576     case CursorType::EWResize:
1577         return eastWestResizeCursor();
1578     case CursorType::NSResize:
1579         return northSouthResizeCursor();
1580     case CursorType::NESWResize:
1581         return northEastSouthWestResizeCursor();
1582     case CursorType::NWSEResize:
1583         return northWestSouthEastResizeCursor();
1584     case CursorType::ColumnResize:
1585         return columnResizeCursor();
1586     case CursorType::RowResize:
1587         return rowResizeCursor();
1588     case CursorType::AllScroll:
1589         return moveCursor();
1590     case CursorType::ZoomIn:
1591         return zoomInCursor();
1592     case CursorType::ZoomOut:
1593         return zoomOutCursor();
1594     }
1595     return pointerCursor();
1596 }
1597 #endif // ENABLE(CURSOR_SUPPORT)
1598 
1599 #if ENABLE(CURSOR_VISIBILITY)
1600 void EventHandler::startAutoHideCursorTimer()
1601 {
1602     Page* page = m_frame.page();
1603     if (!page)
1604         return;
1605 
1606     m_autoHideCursorTimer.startOneShot(page-&gt;settings().timeWithoutMouseMovementBeforeHidingControls());
1607 
1608 #if !ENABLE(IOS_TOUCH_EVENTS)
1609     // The fake mouse move event screws up the auto-hide feature (by resetting the auto-hide timer)
1610     // so cancel any pending fake mouse moves.
1611     if (m_fakeMouseMoveEventTimer.isActive())
1612         m_fakeMouseMoveEventTimer.stop();
1613 #endif
1614 }
1615 
1616 void EventHandler::cancelAutoHideCursorTimer()
1617 {
1618     if (m_autoHideCursorTimer.isActive())
1619         m_autoHideCursorTimer.stop();
1620 }
1621 
1622 void EventHandler::autoHideCursorTimerFired()
1623 {
1624     FrameView* view = m_frame.view();
1625     if (!view || !view-&gt;isActive())
1626         return;
1627 
1628     if (auto page = m_frame.page())
1629         page-&gt;chrome().setCursorHiddenUntilMouseMoves(true);
1630 }
1631 #endif
1632 
1633 static LayoutPoint documentPointForWindowPoint(Frame&amp; frame, const IntPoint&amp; windowPoint)
1634 {
1635     FrameView* view = frame.view();
1636     // FIXME: Is it really OK to use the wrong coordinates here when view is 0?
1637     // Historically the code would just crash; this is clearly no worse than that.
1638     return view ? view-&gt;windowToContents(windowPoint) : windowPoint;
1639 }
1640 
1641 static Scrollbar* scrollbarForMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent, FrameView* view)
1642 {
1643     if (view) {
1644         if (auto* scrollbar = view-&gt;scrollbarAtPoint(mouseEvent.event().position()))
1645             return scrollbar;
1646     }
1647     return mouseEvent.scrollbar();
1648 
1649 }
1650 
1651 bool EventHandler::handleMousePressEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1652 {
1653     Ref&lt;Frame&gt; protectedFrame(m_frame);
1654     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1655 
1656     if (InspectorInstrumentation::handleMousePress(m_frame)) {
1657         invalidateClick();
1658         return true;
1659     }
1660 
1661 #if ENABLE(POINTER_LOCK)
1662     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1663         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousedownEvent);
1664         return true;
1665     }
1666 #endif
1667 
1668     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
1669         return true;
1670 
1671 #if ENABLE(TOUCH_EVENTS)
1672     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1673     if (defaultPrevented)
1674         return true;
1675 #endif
1676 
1677     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1678 
1679     // FIXME (bug 68185): this call should be made at another abstraction layer
1680     m_frame.loader().resetMultipleFormSubmissionProtection();
1681 
1682 #if !ENABLE(IOS_TOUCH_EVENTS)
1683     cancelFakeMouseMoveEvent();
1684 #endif
1685     m_mousePressed = true;
1686     m_capturesDragging = true;
1687     setLastKnownMousePosition(platformMouseEvent);
1688     m_mouseDownTimestamp = platformMouseEvent.timestamp();
1689 #if ENABLE(DRAG_SUPPORT)
1690     m_mouseDownMayStartDrag = false;
1691 #endif
1692     m_mouseDownMayStartSelect = false;
1693     m_mouseDownMayStartAutoscroll = false;
1694     if (FrameView* view = m_frame.view())
1695         m_mouseDownPos = view-&gt;windowToContents(platformMouseEvent.position());
1696     else {
1697         invalidateClick();
1698         return false;
1699     }
1700     m_mouseDownWasInSubframe = false;
1701 
1702     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
1703     // Save the document point we generate in case the window coordinate is invalidated by what happens
1704     // when we dispatch the event.
1705     LayoutPoint documentPoint = documentPointForWindowPoint(m_frame, platformMouseEvent.position());
1706     MouseEventWithHitTestResults mouseEvent = m_frame.document()-&gt;prepareMouseEvent(request, documentPoint, platformMouseEvent);
1707 
1708     if (!mouseEvent.targetNode()) {
1709         invalidateClick();
1710         return false;
1711     }
1712 
1713     m_mousePressNode = mouseEvent.targetNode();
1714     m_frame.document()-&gt;setFocusNavigationStartingNode(mouseEvent.targetNode());
1715 
1716     Scrollbar* scrollbar = scrollbarForMouseEvent(mouseEvent, m_frame.view());
1717     updateLastScrollbarUnderMouse(scrollbar, SetOrClearLastScrollbar::Set);
1718     bool passedToScrollbar = scrollbar &amp;&amp; passMousePressEventToScrollbar(mouseEvent, scrollbar);
1719 
1720     if (!passedToScrollbar) {
1721         RefPtr&lt;Frame&gt; subframe = subframeForHitTestResult(mouseEvent);
1722         if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe.get())) {
1723             // Start capturing future events for this frame. We only do this if we didn&#39;t clear
1724             // the m_mousePressed flag, which may happen if an AppKit widget entered a modal event loop.
1725             m_capturesDragging = subframe-&gt;eventHandler().capturesDragging();
1726             if (m_mousePressed &amp;&amp; m_capturesDragging) {
1727                 m_capturingMouseEventsElement = subframe-&gt;ownerElement();
1728                 m_eventHandlerWillResetCapturingMouseEventsElement = true;
1729             }
1730             invalidateClick();
1731             return true;
1732         }
1733     }
1734 
1735 #if ENABLE(PAN_SCROLLING)
1736     // We store whether pan scrolling is in progress before calling stopAutoscrollTimer()
1737     // because it will set m_autoscrollType to NoAutoscroll on return.
1738     bool isPanScrollInProgress = m_frame.mainFrame().eventHandler().panScrollInProgress();
1739     stopAutoscrollTimer();
1740     if (isPanScrollInProgress) {
1741         // We invalidate the click when exiting pan scrolling so that we don&#39;t inadvertently navigate
1742         // away from the current page (e.g. the click was on a hyperlink). See &lt;rdar://problem/6095023&gt;.
1743         invalidateClick();
1744         return true;
1745     }
1746 #endif
1747 
1748     m_clickCount = platformMouseEvent.clickCount();
1749     m_clickNode = mouseEvent.targetNode();
1750 
1751     if (!m_clickNode) {
1752         invalidateClick();
1753         return false;
1754     }
1755 
1756     if (FrameView* view = m_frame.view()) {
1757         RenderLayer* layer = m_clickNode-&gt;renderer() ? m_clickNode-&gt;renderer()-&gt;enclosingLayer() : 0;
1758         IntPoint p = view-&gt;windowToContents(platformMouseEvent.position());
1759         if (layer &amp;&amp; layer-&gt;isPointInResizeControl(p)) {
1760             layer-&gt;setInResizeMode(true);
1761             m_resizeLayer = layer;
1762             m_offsetFromResizeCorner = layer-&gt;offsetFromResizeCorner(p);
1763             invalidateClick();
1764             return true;
1765         }
1766     }
1767 
1768     m_frame.selection().setCaretBlinkingSuspended(true);
1769 
1770     bool swallowEvent = !dispatchMouseEvent(eventNames().mousedownEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1771     m_capturesDragging = !swallowEvent || mouseEvent.scrollbar();
1772 
1773     // If the hit testing originally determined the event was in a scrollbar, refetch the MouseEventWithHitTestResults
1774     // in case the scrollbar widget was destroyed when the mouse event was handled.
1775     if (mouseEvent.scrollbar()) {
1776         const bool wasLastScrollBar = mouseEvent.scrollbar() == m_lastScrollbarUnderMouse;
1777         mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1778         if (wasLastScrollBar &amp;&amp; mouseEvent.scrollbar() != m_lastScrollbarUnderMouse)
1779             m_lastScrollbarUnderMouse = nullptr;
1780     }
1781 
1782     if (!swallowEvent) {
1783         // Refetch the event target node if it currently is the shadow node inside an &lt;input&gt; element.
1784         // If a mouse event handler changes the input element type to one that has a widget associated,
1785         // we&#39;d like to EventHandler::handleMousePressEvent to pass the event to the widget and thus the
1786         // event target node can&#39;t still be the shadow node.
1787         if (is&lt;ShadowRoot&gt;(*mouseEvent.targetNode()) &amp;&amp; is&lt;HTMLInputElement&gt;(*downcast&lt;ShadowRoot&gt;(*mouseEvent.targetNode()).host()))
1788             mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1789     }
1790 
1791     if (!swallowEvent) {
1792         if (passedToScrollbar)
1793             swallowEvent = true;
1794         else
1795             swallowEvent = handleMousePressEvent(mouseEvent);
1796     }
1797     return swallowEvent;
1798 }
1799 
1800 // This method only exists for platforms that don&#39;t know how to deliver
1801 bool EventHandler::handleMouseDoubleClickEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1802 {
1803     Ref&lt;Frame&gt; protectedFrame(m_frame);
1804     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1805 
1806     m_frame.selection().setCaretBlinkingSuspended(false);
1807 
1808     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1809 
1810 #if ENABLE(POINTER_LOCK)
1811     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1812         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
1813         return true;
1814     }
1815 #endif
1816 
1817     // We get this instead of a second mouse-up
1818     m_mousePressed = false;
1819     setLastKnownMousePosition(platformMouseEvent);
1820 
1821     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
1822     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1823     Frame* subframe = subframeForHitTestResult(mouseEvent);
1824     if (m_eventHandlerWillResetCapturingMouseEventsElement)
1825         m_capturingMouseEventsElement = nullptr;
1826     if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe))
1827         return true;
1828 
1829     m_clickCount = platformMouseEvent.clickCount();
1830     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
1831 
1832     bool swallowClickEvent = platformMouseEvent.button() != RightButton &amp;&amp; mouseEvent.targetNode() == m_clickNode &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1833 
1834     if (m_lastScrollbarUnderMouse)
1835         swallowMouseUpEvent = m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
1836 
1837     bool swallowMouseReleaseEvent = !swallowMouseUpEvent &amp;&amp; handleMouseReleaseEvent(mouseEvent);
1838 
1839     invalidateClick();
1840 
1841     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
1842 }
1843 
1844 static ScrollableArea* enclosingScrollableArea(Node* node)
1845 {
1846     for (auto ancestor = node; ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode()) {
1847         if (is&lt;HTMLIFrameElement&gt;(*ancestor) || is&lt;HTMLHtmlElement&gt;(*ancestor) || is&lt;HTMLDocument&gt;(*ancestor))
1848             return nullptr;
1849 
1850         auto renderer = ancestor-&gt;renderer();
1851         if (!renderer)
1852             continue;
1853 
1854         if (is&lt;RenderListBox&gt;(*renderer))
1855             return downcast&lt;RenderListBox&gt;(renderer);
1856 
1857         return renderer-&gt;enclosingLayer();
1858     }
1859 
1860     return nullptr;
1861 }
1862 
1863 bool EventHandler::mouseMoved(const PlatformMouseEvent&amp; event)
1864 {
1865     Ref&lt;Frame&gt; protectedFrame(m_frame);
1866     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1867     MaximumDurationTracker maxDurationTracker(&amp;m_maxMouseMovedDuration);
1868 
1869     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;pageOverlayController().handleMouseEvent(event))
1870         return true;
1871 
1872     HitTestResult hoveredNode = HitTestResult(LayoutPoint());
1873     bool result = handleMouseMoveEvent(event, &amp;hoveredNode);
1874 
1875     Page* page = m_frame.page();
1876     if (!page)
1877         return result;
1878 
1879     if (auto scrolledArea = enclosingScrollableArea(hoveredNode.innerNode())) {
1880         if (FrameView* frameView = m_frame.view()) {
1881             if (frameView-&gt;containsScrollableArea(scrolledArea))
1882                 scrolledArea-&gt;mouseMovedInContentArea();
1883         }
1884     }
1885 
1886     if (FrameView* frameView = m_frame.view())
1887         frameView-&gt;mouseMovedInContentArea();
1888 
1889     hoveredNode.setToNonUserAgentShadowAncestor();
1890     page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());
1891     page-&gt;chrome().setToolTip(hoveredNode);
1892     return result;
1893 }
1894 
1895 bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
1896 {
1897     HitTestResult hoveredNode;
1898     return handleMouseMoveEvent(event, &amp;hoveredNode, true);
1899 }
1900 
1901 bool EventHandler::handleMouseMoveEvent(const PlatformMouseEvent&amp; platformMouseEvent, HitTestResult* hoveredNode, bool onlyUpdateScrollbars)
1902 {
1903 #if ENABLE(TOUCH_EVENTS)
1904     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1905     if (defaultPrevented)
1906         return true;
1907 #endif
1908 
1909     Ref&lt;Frame&gt; protectedFrame(m_frame);
1910     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1911 
1912 #if ENABLE(POINTER_LOCK)
1913     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1914         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousemoveEvent);
1915         return true;
1916     }
1917 #endif
1918 
1919     setLastKnownMousePosition(platformMouseEvent);
1920 
1921     if (m_hoverTimer.isActive())
1922         m_hoverTimer.stop();
1923 
1924 #if ENABLE(CURSOR_SUPPORT)
1925     m_cursorUpdateTimer.stop();
1926 #endif
1927 
1928 #if !ENABLE(IOS_TOUCH_EVENTS)
1929     cancelFakeMouseMoveEvent();
1930 #endif
1931 
1932     if (m_svgPan) {
1933         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
1934         return true;
1935     }
1936 
1937     if (m_frameSetBeingResized)
1938         return !dispatchMouseEvent(eventNames().mousemoveEvent, m_frameSetBeingResized.get(), false, 0, platformMouseEvent, false);
1939 
1940     // On iOS, our scrollbars are managed by UIKit.
1941 #if !PLATFORM(IOS_FAMILY)
1942     // Send events right to a scrollbar if the mouse is pressed.
1943     if (m_lastScrollbarUnderMouse &amp;&amp; m_mousePressed)
1944         return m_lastScrollbarUnderMouse-&gt;mouseMoved(platformMouseEvent);
1945 #endif
1946 
1947     HitTestRequest::HitTestRequestType hitType = HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowFrameScrollbars;
1948     if (m_mousePressed)
1949         hitType |= HitTestRequest::Active;
1950     else if (onlyUpdateScrollbars) {
1951         // Mouse events should be treated as &quot;read-only&quot; if we&#39;re updating only scrollbars. This
1952         // means that :hover and :active freeze in the state they were in, rather than updating
1953         // for nodes the mouse moves while the window is not key (which will be the case if
1954         // onlyUpdateScrollbars is true).
1955         hitType |= HitTestRequest::ReadOnly;
1956     }
1957 
1958 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
1959     // Treat any mouse move events as readonly if the user is currently touching the screen.
1960     if (m_touchPressed)
1961         hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
1962 #endif
1963     HitTestRequest request(hitType);
1964     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1965     if (hoveredNode)
1966         *hoveredNode = mouseEvent.hitTestResult();
1967 
1968     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1969         m_resizeLayer-&gt;resize(platformMouseEvent, m_offsetFromResizeCorner);
1970     else {
1971         Scrollbar* scrollbar = mouseEvent.scrollbar();
1972         updateLastScrollbarUnderMouse(scrollbar, m_mousePressed ? SetOrClearLastScrollbar::Clear : SetOrClearLastScrollbar::Set);
1973 
1974         // On iOS, our scrollbars are managed by UIKit.
1975 #if !PLATFORM(IOS_FAMILY)
1976         if (!m_mousePressed &amp;&amp; scrollbar)
1977             scrollbar-&gt;mouseMoved(platformMouseEvent); // Handle hover effects on platforms that support visual feedback on scrollbar hovering.
1978 #endif
1979         if (onlyUpdateScrollbars) {
1980             if (shouldSendMouseEventsToInactiveWindows())
<a name="11" id="anc11"></a><span class="line-modified">1981                 updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, true);</span>
1982 
1983             return true;
1984         }
1985     }
1986 
1987     bool swallowEvent = false;
1988     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
1989 
1990     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
1991     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
1992         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
1993 
1994     if (newSubframe) {
1995         // Update over/out state before passing the event to the subframe.
<a name="12" id="anc12"></a><span class="line-modified">1996         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, true);</span>
1997 
1998         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
1999         // node to be detached from its FrameView, in which case the event should not be passed.
2000         if (newSubframe-&gt;view())
2001             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2002     }
2003 
2004     if (!newSubframe || mouseEvent.scrollbar()) {
2005 #if ENABLE(CURSOR_SUPPORT)
2006         if (auto* view = m_frame.view())
2007             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
2008 #endif
2009     }
2010 
2011     m_lastMouseMoveEventSubframe = newSubframe;
2012 
2013     if (swallowEvent)
2014         return true;
2015 
2016     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
2017 #if ENABLE(DRAG_SUPPORT)
2018     if (!swallowEvent)
2019         swallowEvent = handleMouseDraggedEvent(mouseEvent);
2020 #endif
2021 
2022     return swallowEvent;
2023 }
2024 
2025 bool EventHandler::shouldSendMouseEventsToInactiveWindows() const
2026 {
2027 #if PLATFORM(GTK)
2028     return true;
2029 #endif
2030     return false;
2031 }
2032 
2033 void EventHandler::invalidateClick()
2034 {
2035     m_clickCount = 0;
2036     m_clickNode = nullptr;
2037 }
2038 
2039 static Node* targetNodeForClickEvent(Node* mousePressNode, Node* mouseReleaseNode)
2040 {
2041     if (!mousePressNode || !mouseReleaseNode)
2042         return nullptr;
2043 
2044     if (mousePressNode == mouseReleaseNode)
2045         return mouseReleaseNode;
2046 
2047     // If mousePressNode and mouseReleaseNode differ, we should fire the event at their common ancestor if there is one.
2048     if (&amp;mousePressNode-&gt;document() == &amp;mouseReleaseNode-&gt;document()) {
2049         if (auto* commonAncestor = Range::commonAncestorContainer(mousePressNode, mouseReleaseNode))
2050             return commonAncestor;
2051     }
2052 
2053     Element* mouseReleaseShadowHost = mouseReleaseNode-&gt;shadowHost();
2054     if (mouseReleaseShadowHost &amp;&amp; mouseReleaseShadowHost == mousePressNode-&gt;shadowHost()) {
2055         // We want to dispatch the click to the shadow tree host element to give listeners the illusion that the
2056         // shadom tree is a single element. For example, we want to give the illusion that &lt;input type=&quot;range&quot;&gt;
2057         // is a single element even though it is a composition of multiple shadom tree elements.
2058         return mouseReleaseShadowHost;
2059     }
2060     return nullptr;
2061 }
2062 
2063 bool EventHandler::handleMouseReleaseEvent(const PlatformMouseEvent&amp; platformMouseEvent)
2064 {
2065     Ref&lt;Frame&gt; protectedFrame(m_frame);
2066     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2067 
2068     m_frame.selection().setCaretBlinkingSuspended(false);
2069 
2070 #if ENABLE(POINTER_LOCK)
2071     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2072         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
2073         return true;
2074     }
2075 #endif
2076 
2077     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
2078         return true;
2079 
2080 #if ENABLE(TOUCH_EVENTS)
2081     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
2082     if (defaultPrevented)
2083         return true;
2084 #endif
2085 
2086     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
2087 
2088 #if ENABLE(PAN_SCROLLING)
2089     m_autoscrollController-&gt;handleMouseReleaseEvent(platformMouseEvent);
2090 #endif
2091 
2092     m_mousePressed = false;
2093     setLastKnownMousePosition(platformMouseEvent);
2094 
2095     if (m_svgPan) {
2096         m_svgPan = false;
2097         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
2098         return true;
2099     }
2100 
2101     if (m_frameSetBeingResized)
2102         return !dispatchMouseEvent(eventNames().mouseupEvent, m_frameSetBeingResized.get(), true, m_clickCount, platformMouseEvent, false);
2103 
2104     // If an immediate action began or was completed using this series of mouse events, then we should send mouseup to
2105     // the DOM and return now so that we don&#39;t perform our own default behaviors.
2106     if (m_immediateActionStage == ImmediateActionStage::ActionCompleted || m_immediateActionStage == ImmediateActionStage::ActionUpdated || m_immediateActionStage == ImmediateActionStage::ActionCancelledAfterUpdate) {
2107         m_immediateActionStage = ImmediateActionStage::None;
2108         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), true, m_clickCount, platformMouseEvent, false);
2109     }
2110     m_immediateActionStage = ImmediateActionStage::None;
2111 
2112     if (m_lastScrollbarUnderMouse) {
2113         invalidateClick();
2114         m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
2115         bool cancelable = true;
2116         bool setUnder = false;
2117         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), cancelable, m_clickCount, platformMouseEvent, setUnder);
2118     }
2119 
2120     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
2121     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
2122     Frame* subframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2123     if (m_eventHandlerWillResetCapturingMouseEventsElement)
2124         m_capturingMouseEventsElement = nullptr;
2125     if (subframe &amp;&amp; passMouseReleaseEventToSubframe(mouseEvent, subframe))
2126         return true;
2127 
2128     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
2129 
2130     bool contextMenuEvent = platformMouseEvent.button() == RightButton;
2131 
2132     Node* nodeToClick = targetNodeForClickEvent(m_clickNode.get(), mouseEvent.targetNode());
2133     bool swallowClickEvent = m_clickCount &gt; 0 &amp;&amp; !contextMenuEvent &amp;&amp; nodeToClick &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, nodeToClick, true, m_clickCount, platformMouseEvent, true);
2134 
2135     if (m_resizeLayer) {
2136         m_resizeLayer-&gt;setInResizeMode(false);
2137         m_resizeLayer = nullptr;
2138     }
2139 
2140     bool swallowMouseReleaseEvent = false;
2141     if (!swallowMouseUpEvent)
2142         swallowMouseReleaseEvent = handleMouseReleaseEvent(mouseEvent);
2143 
2144     invalidateClick();
2145 
2146     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
2147 }
2148 
2149 #if ENABLE(MOUSE_FORCE_EVENTS)
2150 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; event)
2151 {
2152     Ref&lt;Frame&gt; protectedFrame(m_frame);
2153     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2154 
2155 #if ENABLE(POINTER_LOCK)
2156     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2157         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcechangedEvent);
2158         if (event.type() == PlatformEvent::MouseForceDown)
2159             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcedownEvent);
2160         if (event.type() == PlatformEvent::MouseForceUp)
2161             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforceupEvent);
2162         return true;
2163     }
2164 #endif
2165 
2166     setLastKnownMousePosition(event);
2167 
2168     HitTestRequest::HitTestRequestType hitType = HitTestRequest::DisallowUserAgentShadowContent;
2169 
2170     if (event.force())
2171         hitType |= HitTestRequest::Active;
2172 
2173     HitTestRequest request(hitType);
2174     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2175 
2176     bool swallowedEvent = !dispatchMouseEvent(eventNames().webkitmouseforcechangedEvent, mouseEvent.targetNode(), false, 0, event, false);
2177     if (event.type() == PlatformEvent::MouseForceDown)
2178         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforcedownEvent, mouseEvent.targetNode(), false, 0, event, false);
2179     if (event.type() == PlatformEvent::MouseForceUp)
2180         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforceupEvent, mouseEvent.targetNode(), false, 0, event, false);
2181 
2182     return swallowedEvent;
2183 }
2184 #else
2185 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; )
2186 {
2187     return false;
2188 }
2189 #endif // #if ENABLE(MOUSE_FORCE_EVENTS)
2190 
2191 bool EventHandler::handlePasteGlobalSelection(const PlatformMouseEvent&amp; platformMouseEvent)
2192 {
2193     // If the event was a middle click, attempt to copy global selection in after
2194     // the newly set caret position.
2195     //
2196     // This code is called from either the mouse up or mouse down handling. There
2197     // is some debate about when the global selection is pasted:
2198     //   xterm: pastes on up.
2199     //   GTK: pastes on down.
2200     //   Qt: pastes on up.
2201     //   Firefox: pastes on up.
2202     //   Chromium: pastes on up.
2203     //
2204     // There is something of a webcompat angle to this well, as highlighted by
2205     // crbug.com/14608. Pages can clear text boxes &#39;onclick&#39; and, if we paste on
2206     // down then the text is pasted just before the onclick handler runs and
2207     // clears the text box. So it&#39;s important this happens after the event
2208     // handlers have been fired.
2209 #if PLATFORM(GTK)
2210     if (platformMouseEvent.type() != PlatformEvent::MousePressed)
2211         return false;
2212 #else
2213     if (platformMouseEvent.type() != PlatformEvent::MouseReleased)
2214         return false;
2215 #endif
2216 
2217     if (!m_frame.page())
2218         return false;
2219     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2220     // Do not paste here if the focus was moved somewhere else.
2221     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2222         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2223 
2224     return false;
2225 }
2226 
2227 #if ENABLE(DRAG_SUPPORT)
2228 
<a name="13" id="anc13"></a><span class="line-modified">2229 bool EventHandler::dispatchDragEvent(const AtomicString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)</span>
2230 {
2231     Ref&lt;Frame&gt; protectedFrame(m_frame);
2232     FrameView* view = m_frame.view();
2233 
2234     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2235     if (!view)
2236         return false;
2237 
2238     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2239     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.
2240     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,
2241         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2242         event.globalPosition(), event.position(),
2243 #if ENABLE(POINTER_LOCK)
2244         event.movementDelta(),
2245 #else
2246         { },
2247 #endif
2248         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2249 
2250     dragTarget.dispatchEvent(me);
2251     return me-&gt;defaultPrevented();
2252 }
2253 
2254 static bool targetIsFrame(Node* target, Frame*&amp; frame)
2255 {
2256     if (!is&lt;HTMLFrameElementBase&gt;(target))
2257         return false;
2258 
2259     frame = downcast&lt;HTMLFrameElementBase&gt;(*target).contentFrame();
2260     return true;
2261 }
2262 
2263 static DragOperation convertDropZoneOperationToDragOperation(const String&amp; dragOperation)
2264 {
2265     if (dragOperation == &quot;copy&quot;)
2266         return DragOperationCopy;
2267     if (dragOperation == &quot;move&quot;)
2268         return DragOperationMove;
2269     if (dragOperation == &quot;link&quot;)
2270         return DragOperationLink;
2271     return DragOperationNone;
2272 }
2273 
2274 static String convertDragOperationToDropZoneOperation(DragOperation operation)
2275 {
2276     switch (operation) {
2277     case DragOperationCopy:
2278         return &quot;copy&quot;_s;
2279     case DragOperationMove:
2280         return &quot;move&quot;_s;
2281     case DragOperationLink:
2282         return &quot;link&quot;_s;
2283     default:
2284         return &quot;copy&quot;_s;
2285     }
2286 }
2287 
2288 static bool hasDropZoneType(DataTransfer&amp; dataTransfer, const String&amp; keyword)
2289 {
2290     if (keyword.startsWith(&quot;file:&quot;))
2291         return dataTransfer.hasFileOfType(keyword.substring(5));
2292 
2293     if (keyword.startsWith(&quot;string:&quot;))
2294         return dataTransfer.hasStringOfType(keyword.substring(7));
2295 
2296     return false;
2297 }
2298 
2299 static bool findDropZone(Node&amp; target, DataTransfer&amp; dataTransfer)
2300 {
2301     RefPtr&lt;Element&gt; element = is&lt;Element&gt;(target) ? &amp;downcast&lt;Element&gt;(target) : target.parentElement();
2302     for (; element; element = element-&gt;parentElement()) {
2303         SpaceSplitString keywords(element-&gt;attributeWithoutSynchronization(webkitdropzoneAttr), true);
2304         bool matched = false;
2305         DragOperation dragOperation = DragOperationNone;
2306         for (unsigned i = 0, size = keywords.size(); i &lt; size; ++i) {
2307             DragOperation op = convertDropZoneOperationToDragOperation(keywords[i]);
2308             if (op != DragOperationNone) {
2309                 if (dragOperation == DragOperationNone)
2310                     dragOperation = op;
2311             } else
2312                 matched = matched || hasDropZoneType(dataTransfer, keywords[i].string());
2313             if (matched &amp;&amp; dragOperation != DragOperationNone)
2314                 break;
2315         }
2316         if (matched) {
2317             dataTransfer.setDropEffect(convertDragOperationToDropZoneOperation(dragOperation));
2318             return true;
2319         }
2320     }
2321     return false;
2322 }
2323 
<a name="14" id="anc14"></a><span class="line-modified">2324 EventHandler::DragTargetResponse EventHandler::dispatchDragEnterOrDragOverEvent(const AtomicString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp; event,</span>
2325     std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2326 {
2327     auto dataTransfer = DataTransfer::createForUpdatingDropTarget(target.document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2328     bool accept = dispatchDragEvent(eventType, target, event, dataTransfer.get());
2329     if (!accept)
2330         accept = findDropZone(target, dataTransfer);
2331     dataTransfer-&gt;makeInvalidForSecurity();
2332     if (accept &amp;&amp; !dataTransfer-&gt;dropEffectIsUninitialized())
2333         return { true, dataTransfer-&gt;destinationOperation() };
2334     return { accept, WTF::nullopt };
2335 }
2336 
2337 EventHandler::DragTargetResponse EventHandler::updateDragAndDrop(const PlatformMouseEvent&amp; event, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp; makePasteboard, DragOperation sourceOperation, bool draggingFiles)
2338 {
2339     Ref&lt;Frame&gt; protectedFrame(m_frame);
2340     if (!m_frame.view())
2341         return { };
2342 
2343     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2344     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2345 
2346     RefPtr&lt;Element&gt; newTarget;
2347     if (Node* targetNode = mouseEvent.targetNode()) {
2348         // Drag events should never go to non-element nodes (following IE, and proper mouseover/out dispatch)
2349         if (!is&lt;Element&gt;(*targetNode))
2350             newTarget = targetNode-&gt;parentOrShadowHostElement();
2351         else
2352             newTarget = downcast&lt;Element&gt;(targetNode);
2353     }
2354 
2355     m_autoscrollController-&gt;updateDragAndDrop(newTarget.get(), event.position(), event.timestamp());
2356 
2357     DragTargetResponse response;
2358     if (m_dragTarget != newTarget) {
2359         // FIXME: this ordering was explicitly chosen to match WinIE. However,
2360         // it is sometimes incorrect when dragging within subframes, as seen with
2361         // LayoutTests/fast/events/drag-in-frames.html.
2362         //
2363         // Moreover, this ordering conforms to section 7.9.4 of the HTML 5 spec. &lt;http://dev.w3.org/html5/spec/Overview.html#drag-and-drop-processing-model&gt;.
2364         Frame* targetFrame;
2365         if (targetIsFrame(newTarget.get(), targetFrame)) {
2366             if (targetFrame)
2367                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2368         } else if (newTarget) {
2369             // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
2370             if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2371                 dispatchDragSrcEvent(eventNames().dragEvent, event);
2372             response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2373         }
2374 
2375         if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2376             // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
2377             if (targetFrame)
2378                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2379         } else if (m_dragTarget) {
2380             auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), makePasteboard(), sourceOperation, draggingFiles);
2381             dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2382             dataTransfer-&gt;makeInvalidForSecurity();
2383         }
2384 
2385         if (newTarget) {
2386             // We do not explicitly call dispatchDragEvent here because it could ultimately result in the appearance that
2387             // two dragover events fired. So, we mark that we should only fire a dragover event on the next call to this function.
2388             m_shouldOnlyFireDragOverEvent = true;
2389         }
2390     } else {
2391         Frame* targetFrame;
2392         if (targetIsFrame(newTarget.get(), targetFrame)) {
2393             if (targetFrame)
2394                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2395         } else if (newTarget) {
2396             // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
2397             if (!m_shouldOnlyFireDragOverEvent &amp;&amp; dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2398                 dispatchDragSrcEvent(eventNames().dragEvent, event);
2399             response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2400             m_shouldOnlyFireDragOverEvent = false;
2401         }
2402     }
2403     m_dragTarget = WTFMove(newTarget);
2404     return response;
2405 }
2406 
2407 void EventHandler::cancelDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2408 {
2409     Ref&lt;Frame&gt; protectedFrame(m_frame);
2410 
2411     Frame* targetFrame;
2412     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2413         if (targetFrame)
2414             targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2415     } else if (m_dragTarget) {
2416         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)
2417             dispatchDragSrcEvent(eventNames().dragEvent, event);
2418 
2419         auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2420         dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2421         dataTransfer-&gt;makeInvalidForSecurity();
2422     }
2423     clearDragState();
2424 }
2425 
2426 bool EventHandler::performDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2427 {
2428     Ref&lt;Frame&gt; protectedFrame(m_frame);
2429 
2430     Frame* targetFrame;
2431     bool preventedDefault = false;
2432     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2433         if (targetFrame)
2434             preventedDefault = targetFrame-&gt;eventHandler().performDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2435     } else if (m_dragTarget) {
2436         auto dataTransfer = DataTransfer::createForDrop(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2437         preventedDefault = dispatchDragEvent(eventNames().dropEvent, *m_dragTarget, event, dataTransfer);
2438         dataTransfer-&gt;makeInvalidForSecurity();
2439     }
2440     clearDragState();
2441     return preventedDefault;
2442 }
2443 
2444 void EventHandler::clearDragState()
2445 {
2446     stopAutoscrollTimer();
2447     m_dragTarget = nullptr;
2448     m_capturingMouseEventsElement = nullptr;
2449     m_shouldOnlyFireDragOverEvent = false;
2450 #if PLATFORM(COCOA)
2451     m_sendingEventToSubview = false;
2452 #endif
2453 }
2454 
2455 #endif // ENABLE(DRAG_SUPPORT)
2456 
2457 void EventHandler::setCapturingMouseEventsElement(Element* element)
2458 {
2459     m_capturingMouseEventsElement = element;
2460     m_eventHandlerWillResetCapturingMouseEventsElement = false;
2461 }
2462 
<a name="15" id="anc15"></a>












2463 MouseEventWithHitTestResults EventHandler::prepareMouseEvent(const HitTestRequest&amp; request, const PlatformMouseEvent&amp; mouseEvent)
2464 {
<a name="16" id="anc16"></a>


2465     Ref&lt;Frame&gt; protectedFrame(m_frame);
2466     ASSERT(m_frame.document());
2467     return m_frame.document()-&gt;prepareMouseEvent(request, documentPointForWindowPoint(m_frame, mouseEvent.position()), mouseEvent);
2468 }
2469 
<a name="17" id="anc17"></a><span class="line-modified">2470 static bool hierarchyHasCapturingEventListeners(Element* element, const AtomicString&amp; eventName)</span>
2471 {
2472     for (ContainerNode* curr = element; curr; curr = curr-&gt;parentInComposedTree()) {
<a name="18" id="anc18"></a><span class="line-modified">2473         if (curr-&gt;hasCapturingEventListeners(eventName))</span>
2474             return true;
2475     }
2476     return false;
2477 }
2478 
<a name="19" id="anc19"></a><span class="line-modified">2479 void EventHandler::updateMouseEventTargetNode(Node* targetNode, const PlatformMouseEvent&amp; platformMouseEvent, bool fireMouseOverOut)</span>
2480 {
2481     Ref&lt;Frame&gt; protectedFrame(m_frame);
2482     Element* targetElement = nullptr;
2483 
2484     // If we&#39;re capturing, we always go right to that element.
2485     if (m_capturingMouseEventsElement)
2486         targetElement = m_capturingMouseEventsElement.get();
2487     else if (targetNode) {
2488         // If the target node is a non-element, dispatch on the parent. &lt;rdar://problem/4196646&gt;
2489         while (targetNode &amp;&amp; !is&lt;Element&gt;(*targetNode))
2490             targetNode = targetNode-&gt;parentInComposedTree();
2491         targetElement = downcast&lt;Element&gt;(targetNode);
2492     }
2493 
2494     m_elementUnderMouse = targetElement;
2495 
2496     // Fire mouseout/mouseover if the mouse has shifted to a different node.
<a name="20" id="anc20"></a><span class="line-modified">2497     if (fireMouseOverOut) {</span>
2498         auto scrollableAreaForLastNode = enclosingScrollableArea(m_lastElementUnderMouse.get());
2499         auto scrollableAreaForNodeUnderMouse = enclosingScrollableArea(m_elementUnderMouse.get());
2500         Page* page = m_frame.page();
2501 
2502         if (m_lastElementUnderMouse &amp;&amp; (!m_elementUnderMouse || &amp;m_elementUnderMouse-&gt;document() != m_frame.document())) {
2503             // The mouse has moved between frames.
2504             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2505                 if (FrameView* frameView = frame-&gt;view())
2506                     frameView-&gt;mouseExitedContentArea();
2507             }
2508         } else if (page &amp;&amp; (scrollableAreaForLastNode &amp;&amp; (!scrollableAreaForNodeUnderMouse || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2509             // The mouse has moved between layers.
2510             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2511                 if (FrameView* frameView = frame-&gt;view()) {
2512                     if (frameView-&gt;containsScrollableArea(scrollableAreaForLastNode))
2513                         scrollableAreaForLastNode-&gt;mouseExitedContentArea();
2514                 }
2515             }
2516         }
2517 
2518         if (m_elementUnderMouse &amp;&amp; (!m_lastElementUnderMouse || &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document())) {
2519             // The mouse has moved between frames.
2520             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2521                 if (FrameView* frameView = frame-&gt;view())
2522                     frameView-&gt;mouseEnteredContentArea();
2523             }
2524         } else if (page &amp;&amp; (scrollableAreaForNodeUnderMouse &amp;&amp; (!scrollableAreaForLastNode || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2525             // The mouse has moved between layers.
2526             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2527                 if (FrameView* frameView = frame-&gt;view()) {
2528                     if (frameView-&gt;containsScrollableArea(scrollableAreaForNodeUnderMouse))
2529                         scrollableAreaForNodeUnderMouse-&gt;mouseEnteredContentArea();
2530                 }
2531             }
2532         }
2533 
2534         if (m_lastElementUnderMouse &amp;&amp; &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document()) {
2535             m_lastElementUnderMouse = nullptr;
2536             m_lastScrollbarUnderMouse = nullptr;
2537         }
2538 
2539         if (m_lastElementUnderMouse != m_elementUnderMouse) {
2540             // mouseenter and mouseleave events are only dispatched if there is a capturing eventhandler on an ancestor
2541             // or a normal eventhandler on the element itself (they don&#39;t bubble).
2542             // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks.
<a name="21" id="anc21"></a><span class="line-modified">2543             bool hasCapturingMouseEnterListener = hierarchyHasCapturingEventListeners(m_elementUnderMouse.get(), eventNames().mouseenterEvent);</span>
<span class="line-modified">2544             bool hasCapturingMouseLeaveListener = hierarchyHasCapturingEventListeners(m_lastElementUnderMouse.get(), eventNames().mouseleaveEvent);</span>
2545 
2546             Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;
2547             for (Element* element = m_lastElementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2548                 leftElementsChain.append(*element);
2549             Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;
2550             for (Element* element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2551                 enteredElementsChain.append(*element);
2552 
2553             if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {
2554                 size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());
2555                 size_t i;
2556                 for (i = 0; i &lt; minHeight; ++i) {
2557                     if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())
2558                         break;
2559                 }
2560                 leftElementsChain.shrink(leftElementsChain.size() - i);
2561                 enteredElementsChain.shrink(enteredElementsChain.size() - i);
2562             }
2563 
2564             if (m_lastElementUnderMouse)
2565                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2566 
2567             for (auto&amp; chain : leftElementsChain) {
<a name="22" id="anc22"></a><span class="line-modified">2568                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))</span>
2569                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2570             }
2571 
2572             if (m_elementUnderMouse)
2573                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2574 
<a name="23" id="anc23"></a><span class="line-modified">2575             for (auto&amp; chain : enteredElementsChain) {</span>
<span class="line-modified">2576                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))</span>
2577                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2578             }
2579         }
2580         m_lastElementUnderMouse = m_elementUnderMouse;
2581     }
2582 }
2583 
<a name="24" id="anc24"></a><span class="line-modified">2584 bool EventHandler::dispatchMouseEvent(const AtomicString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)</span>
2585 {
2586     Ref&lt;Frame&gt; protectedFrame(m_frame);
2587 
2588     if (auto* view = m_frame.view())
2589         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2590 
<a name="25" id="anc25"></a><span class="line-modified">2591     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder);</span>
2592 
2593     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2594         return false;
2595 
2596     if (eventType != eventNames().mousedownEvent)
2597         return true;
2598 
2599     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2600     auto* view = m_frame.view();
2601     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2602         return true;
2603 
2604     // The layout needs to be up to date to determine if an element is focusable.
2605     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2606 
2607     // Remove focus from the currently focused element when a link or button is clicked.
2608     // This is expected by some sites that rely on change event handlers running
2609     // from form fields before the button click is processed, behavior that was inherited
2610     // from the user interface of Windows, where pushing a button moves focus to the button.
2611 
2612     // Walk up the DOM tree to search for an element to focus.
2613     RefPtr&lt;Element&gt; element;
2614     for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {
2615         if (element-&gt;isMouseFocusable())
2616             break;
2617     }
2618 
2619     // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
2620     // element on mouse down if it&#39;s selected and inside a focused element. It will be
2621     // focused if the user does a mouseup over it, however, because the mouseup
2622     // will set a selection inside it, which will also set the focused element.
2623     if (element &amp;&amp; m_frame.selection().isRange()) {
2624         if (auto range = m_frame.selection().toNormalizedRange()) {
2625             auto result = range-&gt;compareNode(*element);
2626             if (!result.hasException() &amp;&amp; result.releaseReturnValue() == Range::NODE_INSIDE &amp;&amp; element-&gt;isDescendantOf(m_frame.document()-&gt;focusedElement()))
2627                 return true;
2628         }
2629     }
2630 
2631     // Only change the focus when clicking scrollbars if it can be transferred to a mouse focusable node.
2632     if (!element &amp;&amp; isInsideScrollbar(platformMouseEvent.position()))
2633         return false;
2634 
2635     // If focus shift is blocked, we eat the event.
2636     auto* page = m_frame.page();
2637     if (page &amp;&amp; !page-&gt;focusController().setFocusedElement(element.get(), m_frame))
2638         return false;
2639 
2640     return true;
2641 }
2642 
2643 bool EventHandler::isInsideScrollbar(const IntPoint&amp; windowPoint) const
2644 {
2645     if (auto* document = m_frame.document()) {
2646         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2647         HitTestResult result(windowPoint);
2648         document-&gt;hitTest(request, result);
2649         return result.scrollbar();
2650     }
2651 
2652     return false;
2653 }
2654 
2655 #if !USE(GLIB)
2656 
2657 bool EventHandler::shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const
2658 {
2659     return false;
2660 }
2661 
2662 #endif
2663 
2664 #if !PLATFORM(MAC)
2665 
2666 void EventHandler::platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp;, RefPtr&lt;ContainerNode&gt;&amp;, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp;)
2667 {
2668 }
2669 
2670 void EventHandler::platformRecordWheelEvent(const PlatformWheelEvent&amp; event)
2671 {
2672     if (auto* page = m_frame.page())
2673         page-&gt;wheelEventDeltaFilter()-&gt;updateFromDelta(FloatSize(event.deltaX(), event.deltaY()));
2674 }
2675 
2676 bool EventHandler::platformCompleteWheelEvent(const PlatformWheelEvent&amp; event, ContainerNode*, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2677 {
2678     Ref&lt;Frame&gt; protectedFrame(m_frame);
2679 
2680     // We do another check on the frame view because the event handler can run JS which results in the frame getting destroyed.
2681     FrameView* view = m_frame.view();
2682 
2683     bool didHandleEvent = view ? view-&gt;wheelEvent(event) : false;
2684     m_isHandlingWheelEvent = false;
2685     return didHandleEvent;
2686 }
2687 
2688 bool EventHandler::platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode*)
2689 {
2690     return true;
2691 }
2692 
2693 void EventHandler::platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2694 {
2695 }
2696 
2697 void EventHandler::clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;)
2698 {
2699     clearLatchedState();
2700 }
2701 
2702 #if !PLATFORM(IOS_FAMILY)
2703 
2704 IntPoint EventHandler::targetPositionInWindowForSelectionAutoscroll() const
2705 {
2706     return m_lastKnownMousePosition;
2707 }
2708 
2709 #endif // !PLATFORM(IOS_FAMILY)
2710 
2711 #endif // !PLATFORM(MAC)
2712 
2713 #if !PLATFORM(IOS_FAMILY)
2714 
2715 bool EventHandler::shouldUpdateAutoscroll()
2716 {
2717     return mousePressed();
2718 }
2719 
2720 #endif // !PLATFORM(IOS_FAMILY)
2721 
2722 Widget* EventHandler::widgetForEventTarget(Element* eventTarget)
2723 {
2724     if (!eventTarget)
2725         return nullptr;
2726 
2727     auto* target = eventTarget-&gt;renderer();
2728     if (!is&lt;RenderWidget&gt;(target))
2729         return nullptr;
2730 
2731     return downcast&lt;RenderWidget&gt;(*target).widget();
2732 }
2733 
2734 static WeakPtr&lt;Widget&gt; widgetForElement(const Element&amp; element)
2735 {
2736     auto target = element.renderer();
2737     if (!is&lt;RenderWidget&gt;(target) || !downcast&lt;RenderWidget&gt;(*target).widget())
2738         return { };
2739 
2740     return makeWeakPtr(*downcast&lt;RenderWidget&gt;(*target).widget());
2741 }
2742 
2743 bool EventHandler::completeWidgetWheelEvent(const PlatformWheelEvent&amp; event, const WeakPtr&lt;Widget&gt;&amp; widget, const WeakPtr&lt;ScrollableArea&gt;&amp; scrollableArea, ContainerNode* scrollableContainer)
2744 {
2745     m_isHandlingWheelEvent = false;
2746 
2747     // We do another check on the widget because the event handler can run JS which results in the frame getting destroyed.
2748     if (!widget)
2749         return false;
2750 
2751     if (scrollableArea)
<a name="26" id="anc26"></a><span class="line-modified">2752         scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2753 
2754     platformNotifyIfEndGesture(event, scrollableArea);
2755 
2756     if (!widget-&gt;platformWidget())
2757         return true;
2758 
2759     return platformCompletePlatformWidgetWheelEvent(event, *widget.get(), scrollableContainer);
2760 }
2761 
2762 bool EventHandler::handleWheelEvent(const PlatformWheelEvent&amp; event)
2763 {
2764     auto* document = m_frame.document();
2765     if (!document)
2766         return false;
2767 
2768     Ref&lt;Frame&gt; protectedFrame(m_frame);
2769     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2770 
2771     FrameView* view = m_frame.view();
2772     if (!view)
2773         return false;
2774 
2775 #if ENABLE(POINTER_LOCK)
2776     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2777         m_frame.page()-&gt;pointerLockController().dispatchLockedWheelEvent(event);
2778         return true;
2779     }
2780 #endif
2781 
2782     m_isHandlingWheelEvent = true;
2783     setFrameWasScrolledByUser();
2784 
2785     HitTestRequest request;
2786     HitTestResult result(view-&gt;windowToContents(event.position()));
2787     document-&gt;hitTest(request, result);
2788 
2789     RefPtr&lt;Element&gt; element = result.targetElement();
2790     RefPtr&lt;ContainerNode&gt; scrollableContainer;
2791     WeakPtr&lt;ScrollableArea&gt; scrollableArea;
2792     bool isOverWidget = result.isOverWidget();
2793     platformPrepareForWheelEvents(event, result, element, scrollableContainer, scrollableArea, isOverWidget);
2794 
2795 #if PLATFORM(MAC)
2796     if (event.phase() == PlatformWheelEventPhaseNone &amp;&amp; event.momentumPhase() == PlatformWheelEventPhaseNone &amp;&amp; m_frame.page())
2797         m_frame.page()-&gt;resetLatchingState();
2798 #endif
2799 
2800     // FIXME: It should not be necessary to do this mutation here.
2801     // Instead, the handlers should know convert vertical scrolls appropriately.
2802     PlatformWheelEvent adjustedEvent = shouldSwapScrollDirection(result, event) ? event.copySwappingDirection() : event;
2803     platformRecordWheelEvent(adjustedEvent);
2804 
2805     if (element) {
2806         if (isOverWidget) {
2807             if (WeakPtr&lt;Widget&gt; widget = widgetForElement(*element)) {
2808                 if (widgetDidHandleWheelEvent(event, *widget.get()))
2809                     return completeWidgetWheelEvent(adjustedEvent, widget, scrollableArea, scrollableContainer.get());
2810             }
2811         }
2812 
2813         if (!element-&gt;dispatchWheelEvent(adjustedEvent)) {
2814             m_isHandlingWheelEvent = false;
<a name="27" id="anc27"></a><span class="line-modified">2815             if (scrollableArea &amp;&amp; scrollableArea-&gt;isScrolledProgrammatically()) {</span>
2816                 // Web developer is controlling scrolling, so don&#39;t attempt to latch.
2817                 clearLatchedState();
<a name="28" id="anc28"></a><span class="line-modified">2818                 scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2819             }
2820 
2821             platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2822             return true;
2823         }
2824     }
2825 
2826     if (scrollableArea)
<a name="29" id="anc29"></a><span class="line-modified">2827         scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2828 
2829     bool handledEvent = platformCompleteWheelEvent(adjustedEvent, scrollableContainer.get(), scrollableArea);
2830     platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2831     return handledEvent;
2832 }
2833 
2834 void EventHandler::clearLatchedState()
2835 {
2836     auto* page = m_frame.page();
2837     if (!page)
2838         return;
2839 
2840 #if PLATFORM(MAC)
2841     page-&gt;resetLatchingState();
2842 #endif
2843     if (auto filter = page-&gt;wheelEventDeltaFilter())
2844         filter-&gt;endFilteringDeltas();
2845 }
2846 
2847 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
2848 {
2849     if (!startNode)
2850         return;
2851 
2852     auto protectedFrame = makeRef(m_frame);
2853 
2854     FloatSize filteredPlatformDelta(wheelEvent.deltaX(), wheelEvent.deltaY());
2855     FloatSize filteredVelocity;
2856     if (auto platformWheelEvent = wheelEvent.underlyingPlatformEvent()) {
2857         filteredPlatformDelta.setWidth(platformWheelEvent-&gt;deltaX());
2858         filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
2859     }
2860 
2861 #if PLATFORM(MAC)
2862     ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
2863     Element* stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;
2864 
2865     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
2866         filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
2867         filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
2868     }
2869 #else
2870     Element* stopElement = nullptr;
2871 #endif
2872 
2873     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, &amp;stopElement, filteredPlatformDelta, filteredVelocity))
2874         wheelEvent.setDefaultHandled();
2875 
2876 #if PLATFORM(MAC)
2877     if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
2878         latchedState-&gt;setPreviousWheelScrolledElement(stopElement);
2879 #endif
2880 }
2881 
2882 #if ENABLE(CONTEXT_MENUS)
2883 bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
2884 {
2885     Ref&lt;Frame&gt; protectedFrame(m_frame);
2886 
2887     Document* doc = m_frame.document();
2888     FrameView* view = m_frame.view();
2889     if (!view)
2890         return false;
2891 
2892     // Caret blinking is normally un-suspended in handleMouseReleaseEvent, but we
2893     // won&#39;t receive that event once the context menu is up.
2894     m_frame.selection().setCaretBlinkingSuspended(false);
2895     // Clear mouse press state to avoid initiating a drag while context menu is up.
2896     m_mousePressed = false;
2897     bool swallowEvent;
2898     LayoutPoint viewportPos = view-&gt;windowToContents(event.position());
2899     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
2900     MouseEventWithHitTestResults mouseEvent = doc-&gt;prepareMouseEvent(request, viewportPos, event);
2901 
2902     // Do not show context menus when clicking on scrollbars.
2903     if (mouseEvent.scrollbar() || view-&gt;scrollbarAtPoint(event.position()))
2904         return false;
2905 
2906     if (m_frame.editor().behavior().shouldSelectOnContextualMenuClick()
2907         &amp;&amp; !m_frame.selection().contains(viewportPos)
2908         // FIXME: In the editable case, word selection sometimes selects content that isn&#39;t underneath the mouse.
2909         // If the selection is non-editable, we do word selection to make it easier to use the contextual menu items
2910         // available for text selections.  But only if we&#39;re above text.
2911         &amp;&amp; (m_frame.selection().selection().isContentEditable() || (mouseEvent.targetNode() &amp;&amp; mouseEvent.targetNode()-&gt;isTextNode()))) {
2912         m_mouseDownMayStartSelect = true; // context menu events are always allowed to perform a selection
2913         selectClosestContextualWordOrLinkFromMouseEvent(mouseEvent);
2914     }
2915 
2916     swallowEvent = !dispatchMouseEvent(eventNames().contextmenuEvent, mouseEvent.targetNode(), true, 0, event, false);
2917 
2918     return swallowEvent;
2919 }
2920 
2921 bool EventHandler::sendContextMenuEventForKey()
2922 {
2923     Ref&lt;Frame&gt; protectedFrame(m_frame);
2924 
2925     FrameView* view = m_frame.view();
2926     if (!view)
2927         return false;
2928 
2929     Document* doc = m_frame.document();
2930     if (!doc)
2931         return false;
2932 
2933     // Clear mouse press state to avoid initiating a drag while context menu is up.
2934     m_mousePressed = false;
2935 
2936     static const int kContextMenuMargin = 1;
2937 
2938 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
2939     int rightAligned = ::GetSystemMetrics(SM_MENUDROPALIGNMENT);
2940 #else
2941     int rightAligned = 0;
2942 #endif
2943     IntPoint location;
2944 
2945     Element* focusedElement = doc-&gt;focusedElement();
2946     const VisibleSelection&amp; selection = m_frame.selection().selection();
2947     Position start = selection.start();
2948 
2949     if (start.deprecatedNode() &amp;&amp; (selection.rootEditableElement() || selection.isRange())) {
2950         RefPtr&lt;Range&gt; selectionRange = selection.toNormalizedRange();
2951         IntRect firstRect = m_frame.editor().firstRectForRange(selectionRange.get());
2952 
2953         int x = rightAligned ? firstRect.maxX() : firstRect.x();
2954         // In a multiline edit, firstRect.maxY() would endup on the next line, so -1.
2955         int y = firstRect.maxY() ? firstRect.maxY() - 1 : 0;
2956         location = IntPoint(x, y);
2957     } else if (focusedElement) {
2958         RenderBoxModelObject* box = focusedElement-&gt;renderBoxModelObject();
2959         if (!box)
2960             return false;
2961 
2962         IntRect boundingBoxRect = box-&gt;absoluteBoundingBoxRect(true);
2963         location = IntPoint(boundingBoxRect.x(), boundingBoxRect.maxY() - 1);
2964     } else {
2965         location = IntPoint(
2966             rightAligned ? view-&gt;contentsWidth() - kContextMenuMargin : kContextMenuMargin,
2967             kContextMenuMargin);
2968     }
2969 
2970     m_frame.view()-&gt;setCursor(pointerCursor());
2971 
2972     IntPoint position = view-&gt;contentsToRootView(location);
2973     IntPoint globalPosition = view-&gt;hostWindow()-&gt;rootViewToScreen(IntRect(position, IntSize())).location();
2974 
2975     Node* targetNode = doc-&gt;focusedElement();
2976     if (!targetNode)
2977         targetNode = doc;
2978 
2979     // Use the focused node as the target for hover and active.
2980     HitTestResult result(position);
2981     result.setInnerNode(targetNode);
2982     doc-&gt;updateHoverActiveState(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent, result.targetElement());
2983 
2984     // The contextmenu event is a mouse event even when invoked using the keyboard.
2985     // This is required for web compatibility.
2986 
2987 #if OS(WINDOWS)
2988     PlatformEvent::Type eventType = PlatformEvent::MouseReleased;
2989 #else
2990     PlatformEvent::Type eventType = PlatformEvent::MousePressed;
2991 #endif
2992 
2993     PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
2994 
2995     return sendContextMenuEvent(platformMouseEvent);
2996 }
2997 #endif // ENABLE(CONTEXT_MENUS)
2998 
2999 void EventHandler::scheduleHoverStateUpdate()
3000 {
3001     if (!m_hoverTimer.isActive())
3002         m_hoverTimer.startOneShot(0_s);
3003 }
3004 
3005 #if ENABLE(CURSOR_SUPPORT)
3006 void EventHandler::scheduleCursorUpdate()
3007 {
3008     if (!m_cursorUpdateTimer.isActive())
3009         m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
3010 }
3011 #endif
3012 
3013 void EventHandler::dispatchFakeMouseMoveEventSoon()
3014 {
3015 #if !ENABLE(IOS_TOUCH_EVENTS)
3016     if (m_mousePressed)
3017         return;
3018 
3019     if (m_mousePositionIsUnknown)
3020         return;
3021 
3022     if (Page* page = m_frame.page()) {
3023         if (!page-&gt;chrome().client().shouldDispatchFakeMouseMoveEvents())
3024             return;
3025     }
3026 
3027     // If the content has ever taken longer than fakeMouseMoveShortInterval we
3028     // reschedule the timer and use a longer time. This will cause the content
3029     // to receive these moves only after the user is done scrolling, reducing
3030     // pauses during the scroll.
3031     if (m_fakeMouseMoveEventTimer.isActive())
3032         m_fakeMouseMoveEventTimer.stop();
3033     m_fakeMouseMoveEventTimer.startOneShot(m_maxMouseMovedDuration &gt; fakeMouseMoveDurationThreshold ? fakeMouseMoveLongInterval : fakeMouseMoveShortInterval);
3034 #endif
3035 }
3036 
3037 void EventHandler::dispatchFakeMouseMoveEventSoonInQuad(const FloatQuad&amp; quad)
3038 {
3039 #if ENABLE(IOS_TOUCH_EVENTS)
3040     UNUSED_PARAM(quad);
3041 #else
3042     FrameView* view = m_frame.view();
3043     if (!view)
3044         return;
3045 
3046     if (!quad.containsPoint(view-&gt;windowToContents(m_lastKnownMousePosition)))
3047         return;
3048 
3049     dispatchFakeMouseMoveEventSoon();
3050 #endif
3051 }
3052 
3053 #if !ENABLE(IOS_TOUCH_EVENTS)
3054 void EventHandler::cancelFakeMouseMoveEvent()
3055 {
3056     m_fakeMouseMoveEventTimer.stop();
3057 }
3058 
3059 void EventHandler::fakeMouseMoveEventTimerFired()
3060 {
3061     ASSERT(!m_mousePressed);
3062 
3063     FrameView* view = m_frame.view();
3064     if (!view)
3065         return;
3066 
3067     if (!m_frame.page() || !m_frame.page()-&gt;isVisible() || !m_frame.page()-&gt;focusController().isActive())
3068         return;
3069 
3070     bool shiftKey;
3071     bool ctrlKey;
3072     bool altKey;
3073     bool metaKey;
3074     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
3075     PlatformMouseEvent fakeMouseMoveEvent(m_lastKnownMousePosition, m_lastKnownMouseGlobalPosition, NoButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey, metaKey, WallTime::now(), 0, NoTap);
3076     mouseMoved(fakeMouseMoveEvent);
3077 }
3078 #endif // !ENABLE(IOS_TOUCH_EVENTS)
3079 
3080 void EventHandler::setResizingFrameSet(HTMLFrameSetElement* frameSet)
3081 {
3082     m_frameSetBeingResized = frameSet;
3083 }
3084 
3085 void EventHandler::resizeLayerDestroyed()
3086 {
3087     ASSERT(m_resizeLayer);
3088     m_resizeLayer = nullptr;
3089 }
3090 
3091 void EventHandler::hoverTimerFired()
3092 {
3093     m_hoverTimer.stop();
3094 
3095     ASSERT(m_frame.document());
3096 
3097     Ref&lt;Frame&gt; protectedFrame(m_frame);
3098 
3099     if (auto* document = m_frame.document()) {
3100         if (FrameView* view = m_frame.view()) {
3101             HitTestRequest request(HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
3102             HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
3103             document-&gt;hitTest(request, result);
3104             document-&gt;updateHoverActiveState(request, result.targetElement());
3105         }
3106     }
3107 }
3108 
3109 bool EventHandler::handleAccessKey(const PlatformKeyboardEvent&amp; event)
3110 {
3111     // FIXME: Ignoring the state of Shift key is what neither IE nor Firefox do.
3112     // IE matches lower and upper case access keys regardless of Shift key state - but if both upper and
3113     // lower case variants are present in a document, the correct element is matched based on Shift key state.
3114     // Firefox only matches an access key if Shift is not pressed, and does that case-insensitively.
3115     ASSERT(!accessKeyModifiers().contains(PlatformEvent::Modifier::ShiftKey));
3116 
3117     if ((event.modifiers() - PlatformEvent::Modifier::ShiftKey) != accessKeyModifiers())
3118         return false;
3119     auto* element = m_frame.document()-&gt;elementForAccessKey(event.unmodifiedText());
3120     if (!element)
3121         return false;
3122     element-&gt;accessKeyAction(false);
3123     return true;
3124 }
3125 
3126 #if !PLATFORM(MAC)
3127 bool EventHandler::needsKeyboardEventDisambiguationQuirks() const
3128 {
3129     return false;
3130 }
3131 #endif
3132 
3133 #if ENABLE(FULLSCREEN_API)
3134 bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp; keyEvent) const
3135 {
3136     Document* document = m_frame.document();
<a name="30" id="anc30"></a><span class="line-modified">3137     if (document-&gt;webkitFullScreenKeyboardInputAllowed())</span>
3138         return true;
3139 
3140     if (keyEvent.type() == PlatformKeyboardEvent::Char) {
3141         if (keyEvent.text().length() != 1)
3142             return false;
3143         UChar character = keyEvent.text()[0];
3144         return character == &#39; &#39;;
3145     }
3146 
3147     int keyCode = keyEvent.windowsVirtualKeyCode();
3148     return (keyCode &gt;= VK_BACK &amp;&amp; keyCode &lt;= VK_CAPITAL)
3149         || (keyCode &gt;= VK_SPACE &amp;&amp; keyCode &lt;= VK_DELETE)
3150         || (keyCode &gt;= VK_OEM_1 &amp;&amp; keyCode &lt;= VK_OEM_PLUS)
3151         || (keyCode &gt;= VK_MULTIPLY &amp;&amp; keyCode &lt;= VK_OEM_8);
3152 }
3153 #endif
3154 
3155 bool EventHandler::keyEvent(const PlatformKeyboardEvent&amp; keyEvent)
3156 {
3157     Document* topDocument = m_frame.document() ? &amp;m_frame.document()-&gt;topDocument() : nullptr;
3158     MonotonicTime savedLastHandledUserGestureTimestamp;
3159     bool savedUserDidInteractWithPage = topDocument ? topDocument-&gt;userDidInteractWithPage() : false;
3160 
3161     if (m_frame.document())
3162         savedLastHandledUserGestureTimestamp = m_frame.document()-&gt;lastHandledUserGestureTimestamp();
3163 
3164     bool wasHandled = internalKeyEvent(keyEvent);
3165 
3166     // If the key event was not handled, do not treat it as user interaction with the page.
3167     if (topDocument) {
3168         if (!wasHandled)
3169             topDocument-&gt;setUserDidInteractWithPage(savedUserDidInteractWithPage);
3170         else
3171             ResourceLoadObserver::shared().logUserInteractionWithReducedTimeResolution(*topDocument);
3172     }
3173 
3174     if (!wasHandled &amp;&amp; m_frame.document())
3175         m_frame.document()-&gt;updateLastHandledUserGestureTimestamp(savedLastHandledUserGestureTimestamp);
3176 
3177     return wasHandled;
3178 }
3179 
3180 void EventHandler::capsLockStateMayHaveChanged() const
3181 {
3182     auto* focusedElement = m_frame.document()-&gt;focusedElement();
3183     if (!is&lt;HTMLInputElement&gt;(focusedElement))
3184         return;
3185     downcast&lt;HTMLInputElement&gt;(*focusedElement).capsLockStateMayHaveChanged();
3186 }
3187 
3188 bool EventHandler::internalKeyEvent(const PlatformKeyboardEvent&amp; initialKeyEvent)
3189 {
3190     Ref&lt;Frame&gt; protectedFrame(m_frame);
3191     RefPtr&lt;FrameView&gt; protector(m_frame.view());
3192 
3193     LOG(Editing, &quot;EventHandler %p keyEvent (text %s keyIdentifier %s)&quot;, this, initialKeyEvent.text().utf8().data(), initialKeyEvent.keyIdentifier().utf8().data());
3194 
3195 #if ENABLE(POINTER_LOCK)
3196     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE &amp;&amp; m_frame.page()-&gt;pointerLockController().element()) {
3197         m_frame.page()-&gt;pointerLockController().requestPointerUnlockAndForceCursorVisible();
3198     }
3199 #endif
3200 
3201     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3202         if (auto* page = m_frame.page()) {
3203             if (auto* validationMessageClient = page-&gt;validationMessageClient())
3204                 validationMessageClient-&gt;hideAnyValidationMessage();
3205         }
3206     }
3207 
3208 #if ENABLE(FULLSCREEN_API)
<a name="31" id="anc31"></a><span class="line-modified">3209     if (m_frame.document()-&gt;webkitIsFullScreen()) {</span>
3210         if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
<a name="32" id="anc32"></a><span class="line-modified">3211             m_frame.document()-&gt;webkitCancelFullScreen();</span>
3212             return true;
3213         }
3214 
3215         if (!isKeyEventAllowedInFullScreen(initialKeyEvent))
3216             return false;
3217     }
3218 #endif
3219 
3220     if (initialKeyEvent.windowsVirtualKeyCode() == VK_CAPITAL)
3221         capsLockStateMayHaveChanged();
3222 
3223 #if ENABLE(PAN_SCROLLING)
3224     if (m_frame.mainFrame().eventHandler().panScrollInProgress()) {
3225         // If a key is pressed while the panScroll is in progress then we want to stop
3226         if (initialKeyEvent.type() == PlatformEvent::KeyDown || initialKeyEvent.type() == PlatformEvent::RawKeyDown)
3227             stopAutoscrollTimer();
3228 
3229         // If we were in panscroll mode, we swallow the key event
3230         return true;
3231     }
3232 #endif
3233 
3234     // Check for cases where we are too early for events -- possible unmatched key up
3235     // from pressing return in the location bar.
3236     RefPtr&lt;Element&gt; element = eventTargetElementForDocument(m_frame.document());
3237     if (!element)
3238         return false;
3239 
3240     UserGestureType gestureType = UserGestureType::Other;
3241     if (initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE)
3242         gestureType = UserGestureType::EscapeKey;
3243 
3244     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document(), gestureType, UserGestureIndicator::ProcessInteractionStyle::Delayed);
3245     UserTypingGestureIndicator typingGestureIndicator(m_frame);
3246 
3247     if (FrameView* view = m_frame.view())
3248         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3249 
3250     // FIXME (bug 68185): this call should be made at another abstraction layer
3251     m_frame.loader().resetMultipleFormSubmissionProtection();
3252 
3253     // In IE, access keys are special, they are handled after default keydown processing, but cannot be canceled - this is hard to match.
3254     // On Mac OS X, we process them before dispatching keydown, as the default keydown handler implements Emacs key bindings, which may conflict
3255     // with access keys. Then we dispatch keydown, but suppress its default handling.
3256     // On Windows, WebKit explicitly calls handleAccessKey() instead of dispatching a keypress event for WM_SYSCHAR messages.
3257     // Other platforms currently match either Mac or Windows behavior, depending on whether they send combined KeyDown events.
3258     bool matchedAnAccessKey = false;
3259     if (initialKeyEvent.type() == PlatformEvent::KeyDown)
3260         matchedAnAccessKey = handleAccessKey(initialKeyEvent);
3261 
3262     // FIXME: it would be fair to let an input method handle KeyUp events before DOM dispatch.
3263     if (initialKeyEvent.type() == PlatformEvent::KeyUp || initialKeyEvent.type() == PlatformEvent::Char)
3264         return !element-&gt;dispatchKeyEvent(initialKeyEvent);
3265 
3266     bool backwardCompatibilityMode = needsKeyboardEventDisambiguationQuirks();
3267 
3268     PlatformKeyboardEvent keyDownEvent = initialKeyEvent;
3269     if (keyDownEvent.type() != PlatformEvent::RawKeyDown)
3270         keyDownEvent.disambiguateKeyDownEvent(PlatformEvent::RawKeyDown, backwardCompatibilityMode);
3271     auto keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3272     if (matchedAnAccessKey)
3273         keydown-&gt;preventDefault();
3274     keydown-&gt;setTarget(element);
3275 
3276     if (initialKeyEvent.type() == PlatformEvent::RawKeyDown) {
3277         element-&gt;dispatchEvent(keydown);
3278         // If frame changed as a result of keydown dispatch, then return true to avoid sending a subsequent keypress message to the new frame.
3279         bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3280         return keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3281     }
3282 
3283     // Run input method in advance of DOM event handling.  This may result in the IM
3284     // modifying the page prior the keydown event, but this behaviour is necessary
3285     // in order to match IE:
3286     // 1. preventing default handling of keydown and keypress events has no effect on IM input;
3287     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3288     m_frame.editor().handleInputMethodKeydown(keydown.get());
3289 
3290     bool handledByInputMethod = keydown-&gt;defaultHandled();
3291 
3292     if (handledByInputMethod) {
3293         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3294         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3295         keydown-&gt;setTarget(element);
3296         keydown-&gt;setIsDefaultEventHandlerIgnored();
3297     }
3298 
3299     if (accessibilityPreventsEventPropagation(keydown))
3300         keydown-&gt;stopPropagation();
3301 
<a name="33" id="anc33"></a>



3302     element-&gt;dispatchEvent(keydown);
3303     if (handledByInputMethod)
3304         return true;
3305 
3306     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3307     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3308     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3309     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3310         return keydownResult;
3311 
3312     // Focus may have changed during keydown handling, so refetch element.
3313     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3314     if (!keydownResult) {
3315         element = eventTargetElementForDocument(m_frame.document());
3316         if (!element)
3317             return false;
3318     }
3319 
3320     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3321     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3322     if (keyPressEvent.text().isEmpty())
3323         return keydownResult;
3324     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
3325     keypress-&gt;setTarget(element);
3326     if (keydownResult)
3327         keypress-&gt;preventDefault();
3328 #if PLATFORM(COCOA)
3329     keypress-&gt;keypressCommands() = keydown-&gt;keypressCommands();
3330 #endif
3331     element-&gt;dispatchEvent(keypress);
3332 
3333     return keydownResult || keypress-&gt;defaultPrevented() || keypress-&gt;defaultHandled();
3334 }
3335 
<a name="34" id="anc34"></a><span class="line-modified">3336 static FocusDirection focusDirectionForKey(const AtomicString&amp; keyIdentifier)</span>
3337 {
<a name="35" id="anc35"></a><span class="line-modified">3338     static NeverDestroyed&lt;AtomicString&gt; Down(&quot;Down&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3339     static NeverDestroyed&lt;AtomicString&gt; Up(&quot;Up&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3340     static NeverDestroyed&lt;AtomicString&gt; Left(&quot;Left&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3341     static NeverDestroyed&lt;AtomicString&gt; Right(&quot;Right&quot;, AtomicString::ConstructFromLiteral);</span>
3342 
3343     FocusDirection retVal = FocusDirectionNone;
3344 
3345     if (keyIdentifier == Down)
3346         retVal = FocusDirectionDown;
3347     else if (keyIdentifier == Up)
3348         retVal = FocusDirectionUp;
3349     else if (keyIdentifier == Left)
3350         retVal = FocusDirectionLeft;
3351     else if (keyIdentifier == Right)
3352         retVal = FocusDirectionRight;
3353 
3354     return retVal;
3355 }
3356 
3357 static void setInitialKeyboardSelection(Frame&amp; frame, SelectionDirection direction)
3358 {
3359     Document* document = frame.document();
3360     if (!document)
3361         return;
3362 
3363     FrameSelection&amp; selection = frame.selection();
3364 
3365     if (!selection.isNone())
3366         return;
3367 
3368     Element* focusedElement = document-&gt;focusedElement();
3369     VisiblePosition visiblePosition;
3370 
3371     switch (direction) {
3372     case DirectionBackward:
3373     case DirectionLeft:
3374         if (focusedElement)
3375             visiblePosition = VisiblePosition(positionBeforeNode(focusedElement));
3376         else
3377             visiblePosition = endOfDocument(document);
3378         break;
3379     case DirectionForward:
3380     case DirectionRight:
3381         if (focusedElement)
3382             visiblePosition = VisiblePosition(positionAfterNode(focusedElement));
3383         else
3384             visiblePosition = startOfDocument(document);
3385         break;
3386     }
3387 
3388     AXTextStateChangeIntent intent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
3389     selection.setSelection(visiblePosition, FrameSelection::defaultSetSelectionOptions(UserTriggered), intent);
3390 }
3391 
3392 static void handleKeyboardSelectionMovement(Frame&amp; frame, KeyboardEvent&amp; event)
3393 {
3394     FrameSelection&amp; selection = frame.selection();
3395 
3396     bool isCommanded = event.getModifierState(&quot;Meta&quot;);
3397     bool isOptioned = event.getModifierState(&quot;Alt&quot;);
3398     bool isSelection = !selection.isNone();
3399 
3400     FrameSelection::EAlteration alternation = event.getModifierState(&quot;Shift&quot;) ? FrameSelection::AlterationExtend : FrameSelection::AlterationMove;
3401     SelectionDirection direction = DirectionForward;
3402     TextGranularity granularity = CharacterGranularity;
3403 
3404     switch (focusDirectionForKey(event.keyIdentifier())) {
3405     case FocusDirectionNone:
3406         return;
3407     case FocusDirectionForward:
3408     case FocusDirectionBackward:
3409         ASSERT_NOT_REACHED();
3410         return;
3411     case FocusDirectionUp:
3412         direction = DirectionBackward;
3413         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3414         break;
3415     case FocusDirectionDown:
3416         direction = DirectionForward;
3417         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3418         break;
3419     case FocusDirectionLeft:
3420         direction = DirectionLeft;
3421         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3422         break;
3423     case FocusDirectionRight:
3424         direction = DirectionRight;
3425         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3426         break;
3427     }
3428 
3429     if (isSelection)
3430         selection.modify(alternation, direction, granularity, UserTriggered);
3431     else
3432         setInitialKeyboardSelection(frame, direction);
3433 
3434     event.setDefaultHandled();
3435 }
3436 
3437 void EventHandler::handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp; event)
3438 {
3439     if (event.type() == eventNames().keydownEvent) {
3440         if (AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3441             handleKeyboardSelectionMovement(m_frame, event);
3442     }
3443 }
3444 
3445 bool EventHandler::accessibilityPreventsEventPropagation(KeyboardEvent&amp; event)
3446 {
3447 #if PLATFORM(COCOA)
3448     if (!AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3449         return false;
3450 
3451     if (!m_frame.settings().preventKeyboardDOMEventDispatch())
3452         return false;
3453 
3454     // Check for key events that are relevant to accessibility: tab and arrows keys that change focus
3455     if (event.keyIdentifier() == &quot;U+0009&quot;)
3456         return true;
3457     FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3458     if (direction != FocusDirectionNone)
3459         return true;
3460 #else
3461     UNUSED_PARAM(event);
3462 #endif
3463     return false;
3464 }
3465 
3466 void EventHandler::defaultKeyboardEventHandler(KeyboardEvent&amp; event)
3467 {
3468     Ref&lt;Frame&gt; protectedFrame(m_frame);
3469 
3470     if (event.type() == eventNames().keydownEvent) {
3471         m_frame.editor().handleKeyboardEvent(event);
3472         if (event.defaultHandled())
3473             return;
3474         if (event.keyIdentifier() == &quot;U+0009&quot;)
3475             defaultTabEventHandler(event);
3476         else if (event.keyIdentifier() == &quot;U+0008&quot;)
3477             defaultBackspaceEventHandler(event);
3478         else {
3479             FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3480             if (direction != FocusDirectionNone)
3481                 defaultArrowEventHandler(direction, event);
3482         }
3483 
3484         handleKeyboardSelectionMovementForAccessibility(event);
3485     }
3486     if (event.type() == eventNames().keypressEvent) {
3487         m_frame.editor().handleKeyboardEvent(event);
3488         if (event.defaultHandled())
3489             return;
3490         if (event.charCode() == &#39; &#39;)
3491             defaultSpaceEventHandler(event);
3492     }
3493 }
3494 
3495 #if ENABLE(DRAG_SUPPORT)
3496 bool EventHandler::dragHysteresisExceeded(const IntPoint&amp; floatDragViewportLocation) const
3497 {
3498     FloatPoint dragViewportLocation(floatDragViewportLocation.x(), floatDragViewportLocation.y());
3499     return dragHysteresisExceeded(dragViewportLocation);
3500 }
3501 
3502 bool EventHandler::dragHysteresisExceeded(const FloatPoint&amp; dragViewportLocation) const
3503 {
3504     int threshold = GeneralDragHysteresis;
3505     switch (dragState().type) {
3506     case DragSourceActionSelection:
3507         threshold = TextDragHysteresis;
3508         break;
3509     case DragSourceActionImage:
3510 #if ENABLE(ATTACHMENT_ELEMENT)
3511     case DragSourceActionAttachment:
3512 #endif
3513         threshold = ImageDragHysteresis;
3514         break;
3515     case DragSourceActionLink:
3516         threshold = LinkDragHysteresis;
3517         break;
3518 #if ENABLE(INPUT_TYPE_COLOR)
3519     case DragSourceActionColor:
3520         threshold = ColorDragHystersis;
3521         break;
3522 #endif
3523     case DragSourceActionDHTML:
3524         break;
3525     case DragSourceActionNone:
3526     case DragSourceActionAny:
3527         ASSERT_NOT_REACHED();
3528     }
3529 
3530     return mouseMovementExceedsThreshold(dragViewportLocation, threshold);
3531 }
3532 
3533 void EventHandler::invalidateDataTransfer()
3534 {
3535     if (!dragState().dataTransfer)
3536         return;
3537     dragState().dataTransfer-&gt;makeInvalidForSecurity();
3538     dragState().dataTransfer = nullptr;
3539 }
3540 
3541 static void removeDraggedContentDocumentMarkersFromAllFramesInPage(Page&amp; page)
3542 {
3543     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
3544         if (auto* document = frame-&gt;document())
3545             document-&gt;markers().removeMarkers(DocumentMarker::DraggedContent);
3546     }
3547 
3548     if (auto* mainFrameRenderer = page.mainFrame().contentRenderer())
3549         mainFrameRenderer-&gt;repaintRootContents();
3550 }
3551 
3552 void EventHandler::dragCancelled()
3553 {
3554 #if ENABLE(DATA_INTERACTION)
3555     if (auto* page = m_frame.page())
3556         removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3557 #endif
3558 }
3559 
3560 void EventHandler::didStartDrag()
3561 {
3562 #if ENABLE(DATA_INTERACTION)
3563     auto dragSource = dragState().source;
3564     if (!dragSource)
3565         return;
3566 
3567     auto* renderer = dragSource-&gt;renderer();
3568     if (!renderer)
3569         return;
3570 
3571     RefPtr&lt;Range&gt; draggedContentRange;
3572     if (dragState().type &amp; DragSourceActionSelection)
3573         draggedContentRange = m_frame.selection().selection().toNormalizedRange();
3574     else {
3575         Position startPosition(dragSource.get(), Position::PositionIsBeforeAnchor);
3576         Position endPosition(dragSource.get(), Position::PositionIsAfterAnchor);
3577         draggedContentRange = Range::create(dragSource-&gt;document(), startPosition, endPosition);
3578     }
3579 
3580     if (draggedContentRange) {
3581         draggedContentRange-&gt;ownerDocument().markers().addDraggedContentMarker(*draggedContentRange);
3582         if (auto* renderer = m_frame.contentRenderer())
3583             renderer-&gt;repaintRootContents();
3584     }
3585 #endif
3586 }
3587 
3588 void EventHandler::dragSourceEndedAt(const PlatformMouseEvent&amp; event, DragOperation operation, MayExtendDragSession mayExtendDragSession)
3589 {
3590     // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
3591     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
3592     prepareMouseEvent(request, event);
3593 
3594     if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {
3595         dragState().dataTransfer-&gt;setDestinationOperation(operation);
3596         dispatchDragSrcEvent(eventNames().dragendEvent, event);
3597     }
3598     invalidateDataTransfer();
3599 
3600     if (mayExtendDragSession == MayExtendDragSession::No) {
3601         if (auto* page = m_frame.page())
3602             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3603     }
3604 
3605     dragState().source = nullptr;
3606     // In case the drag was ended due to an escape key press we need to ensure
3607     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3608     m_mouseDownMayStartDrag = false;
3609 }
3610 
3611 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3612 {
3613     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3614     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3615         dragState().source = &amp;rootEditableElement;
3616 }
3617 
<a name="36" id="anc36"></a><span class="line-modified">3618 void EventHandler::dispatchDragSrcEvent(const AtomicString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
3619 {
3620     ASSERT(dragState().dataTransfer);
3621     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);
3622 }
3623 
3624 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3625 {
3626     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3627 }
3628 
3629 static bool ExactlyOneBitSet(DragSourceAction n)
3630 {
3631     return n &amp;&amp; !(n &amp; (n - 1));
3632 }
3633 
3634 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3635 {
3636     return dragState().source;
3637 }
3638 
3639 bool EventHandler::handleDrag(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
3640 {
3641     if (event.event().button() != LeftButton || event.event().type() != PlatformEvent::MouseMoved) {
3642         // If we allowed the other side of the bridge to handle a drag
3643         // last time, then m_mousePressed might still be set. So we
3644         // clear it now to make sure the next move after a drag
3645         // doesn&#39;t look like a drag.
3646         m_mousePressed = false;
3647         return false;
3648     }
3649 
3650     Ref&lt;Frame&gt; protectedFrame(m_frame);
3651 
3652     if (eventLoopHandleMouseDragged(event))
3653         return true;
3654 
3655     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
3656 
3657     if (m_mouseDownMayStartDrag &amp;&amp; !dragState().source) {
3658         dragState().shouldDispatchEvents = (updateDragSourceActionsAllowed() &amp; DragSourceActionDHTML);
3659 
3660         // try to find an element that wants to be dragged
3661         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
3662         HitTestResult result(m_mouseDownPos);
3663         m_frame.document()-&gt;hitTest(request, result);
3664         if (m_frame.page())
3665             dragState().source = m_frame.page()-&gt;dragController().draggableElement(&amp;m_frame, result.targetElement(), m_mouseDownPos, dragState());
3666 
3667         if (!dragState().source)
3668             m_mouseDownMayStartDrag = false; // no element is draggable
3669         else
3670             m_dragMayStartSelectionInstead = (dragState().type &amp; DragSourceActionSelection);
3671     }
3672 
3673     // For drags starting in the selection, the user must wait between the mousedown and mousedrag,
3674     // or else we bail on the dragging stuff and allow selection to occur
3675     if (m_mouseDownMayStartDrag &amp;&amp; m_dragMayStartSelectionInstead &amp;&amp; (dragState().type &amp; DragSourceActionSelection) &amp;&amp; event.event().timestamp() - m_mouseDownTimestamp &lt; TextDragDelay) {
3676         ASSERT(event.event().type() == PlatformEvent::MouseMoved);
3677         if ((dragState().type &amp; DragSourceActionImage)) {
3678             // ... unless the mouse is over an image, then we start dragging just the image
3679             dragState().type = DragSourceActionImage;
3680         } else if (!(dragState().type &amp; (DragSourceActionDHTML | DragSourceActionLink))) {
3681             // ... but only bail if we&#39;re not over an unselectable element.
3682             m_mouseDownMayStartDrag = false;
3683             dragState().source = nullptr;
3684             // ... but if this was the first click in the window, we don&#39;t even want to start selection
3685             if (eventActivatedView(event.event()))
3686                 m_mouseDownMayStartSelect = false;
3687         } else {
3688             // Prevent the following case from occuring:
3689             // 1. User starts a drag immediately after mouse down over an unselectable element.
3690             // 2. We enter this block and decided that since we&#39;re over an unselectable element, don&#39;t cancel the drag.
3691             // 3. The drag gets resolved as a potential selection drag below /but/ we haven&#39;t exceeded the drag hysteresis yet.
3692             // 4. We enter this block again, and since it&#39;s now marked as a selection drag, we cancel the drag.
3693             m_dragMayStartSelectionInstead = false;
3694         }
3695     }
3696 
3697     if (!m_mouseDownMayStartDrag)
3698         return !mouseDownMayStartSelect() &amp;&amp; !m_mouseDownMayStartAutoscroll;
3699     ASSERT(dragState().source);
3700 
3701     if (!ExactlyOneBitSet(dragState().type)) {
3702         ASSERT(dragState().type &amp; DragSourceActionSelection);
3703         ASSERT(ExactlyOneBitSet(static_cast&lt;DragSourceAction&gt;(dragState().type &amp; ~DragSourceActionSelection)));
3704 
3705         dragState().type = DragSourceActionSelection;
3706     }
3707 
3708     // We are starting a text/image/url drag, so the cursor should be an arrow
3709     if (FrameView* view = m_frame.view()) {
3710         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3711         view-&gt;setCursor(pointerCursor());
3712     }
3713 
3714     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3715         return true;
3716 
3717     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3718     invalidateClick();
3719 
3720     DragOperation srcOp = DragOperationNone;
3721 
3722     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
3723     invalidateDataTransfer();
3724 
<a name="37" id="anc37"></a><span class="line-modified">3725     dragState().dataTransfer = DataTransfer::createForDrag();</span>
3726     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3727 
3728     if (dragState().shouldDispatchEvents) {
3729         ASSERT(dragState().source);
3730         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3731         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3732         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3733         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3734 
3735         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3736             dragState().source-&gt;document().updateStyleIfNeeded();
3737             if (auto* renderer = dragState().source-&gt;renderer()) {
3738                 auto absolutePosition = renderer-&gt;localToAbsolute();
3739                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3740                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3741             } else {
3742                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3743                 m_mouseDownMayStartDrag = false;
3744                 invalidateDataTransfer();
3745                 dragState().source = nullptr;
3746                 return true;
3747             }
3748         }
3749 
3750         dragState().dataTransfer-&gt;makeInvalidForSecurity();
3751 
3752         if (m_mouseDownMayStartDrag) {
3753             // Gather values from DHTML element, if it set any.
3754             srcOp = dragState().dataTransfer-&gt;sourceOperation();
3755 
3756             // Yuck, a draggedImage:moveTo: message can be fired as a result of kicking off the
3757             // drag with dragImage! Because of that dumb reentrancy, we may think we&#39;ve not
3758             // started the drag when that happens. So we have to assume it&#39;s started before we kick it off.
3759             dragState().dataTransfer-&gt;setDragHasStarted();
3760         }
3761     }
3762 
3763     if (m_mouseDownMayStartDrag) {
3764         Page* page = m_frame.page();
3765         m_didStartDrag = page &amp;&amp; page-&gt;dragController().startDrag(m_frame, dragState(), srcOp, event.event(), m_mouseDownPos, hasNonDefaultPasteboardData);
3766         // In WebKit2 we could re-enter this code and start another drag.
3767         // On OS X this causes problems with the ownership of the pasteboard and the promised types.
3768         if (m_didStartDrag) {
3769             m_mouseDownMayStartDrag = false;
3770             return true;
3771         }
3772         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {
3773             // Drag was canned at the last minute. We owe dragSource a dragend event.
3774             dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3775             m_mouseDownMayStartDrag = false;
3776         }
3777     }
3778 
3779     if (!m_mouseDownMayStartDrag) {
3780         // Something failed to start the drag, clean up.
3781         invalidateDataTransfer();
3782         dragState().source = nullptr;
3783     }
3784 
3785     // No more default handling (like selection), whether we&#39;re past the hysteresis bounds or not
3786     return true;
3787 }
3788 #endif // ENABLE(DRAG_SUPPORT)
3789 
3790 bool EventHandler::mouseMovementExceedsThreshold(const FloatPoint&amp; viewportLocation, int pointsThreshold) const
3791 {
3792     FrameView* view = m_frame.view();
3793     if (!view)
3794         return false;
3795     IntPoint location = view-&gt;windowToContents(flooredIntPoint(viewportLocation));
3796     IntSize delta = location - m_mouseDownPos;
3797 
3798     return abs(delta.width()) &gt;= pointsThreshold || abs(delta.height()) &gt;= pointsThreshold;
3799 }
3800 
3801 bool EventHandler::handleTextInputEvent(const String&amp; text, Event* underlyingEvent, TextEventInputType inputType)
3802 {
3803     LOG(Editing, &quot;EventHandler %p handleTextInputEvent (text %s)&quot;, this, text.utf8().data());
3804 
3805     // Platforms should differentiate real commands like selectAll from text input in disguise (like insertNewline),
3806     // and avoid dispatching text input events from keydown default handlers.
3807     ASSERT(!is&lt;KeyboardEvent&gt;(underlyingEvent) || downcast&lt;KeyboardEvent&gt;(*underlyingEvent).type() == eventNames().keypressEvent);
3808 
3809     Ref&lt;Frame&gt; protectedFrame(m_frame);
3810 
3811     EventTarget* target;
3812     if (underlyingEvent)
3813         target = underlyingEvent-&gt;target();
3814     else
3815         target = eventTargetElementForDocument(m_frame.document());
3816     if (!target)
3817         return false;
3818 
3819     if (FrameView* view = m_frame.view())
3820         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3821 
3822     auto event = TextEvent::create(&amp;m_frame.windowProxy(), text, inputType);
3823     event-&gt;setUnderlyingEvent(underlyingEvent);
3824 
3825     target-&gt;dispatchEvent(event);
3826     return event-&gt;defaultHandled();
3827 }
3828 
3829 bool EventHandler::isKeyboardOptionTab(KeyboardEvent&amp; event)
3830 {
3831     return (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent)
3832         &amp;&amp; event.altKey()
3833         &amp;&amp; event.keyIdentifier() == &quot;U+0009&quot;;
3834 }
3835 
3836 bool EventHandler::eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp; event)
3837 {
3838 #if PLATFORM(COCOA)
3839     return isKeyboardOptionTab(event);
3840 #else
3841     UNUSED_PARAM(event);
3842     return false;
3843 #endif
3844 }
3845 
3846 bool EventHandler::tabsToLinks(KeyboardEvent* event) const
3847 {
3848     // FIXME: This function needs a better name. It can be called for keypresses other than Tab when spatial navigation is enabled.
3849 
3850     Page* page = m_frame.page();
3851     if (!page)
3852         return false;
3853 
3854     bool tabsToLinksClientCallResult = page-&gt;chrome().client().keyboardUIMode() &amp; KeyboardAccessTabsToLinks;
3855     return (event &amp;&amp; eventInvertsTabsToLinksClientCallResult(*event)) ? !tabsToLinksClientCallResult : tabsToLinksClientCallResult;
3856 }
3857 
3858 void EventHandler::defaultTextInputEventHandler(TextEvent&amp; event)
3859 {
3860     if (m_frame.editor().handleTextEvent(event))
3861         event.setDefaultHandled();
3862 }
3863 
3864 
3865 void EventHandler::defaultSpaceEventHandler(KeyboardEvent&amp; event)
3866 {
3867     Ref&lt;Frame&gt; protectedFrame(m_frame);
3868 
3869     ASSERT(event.type() == eventNames().keypressEvent);
3870 
3871     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3872         return;
3873 
3874     ScrollLogicalDirection direction = event.shiftKey() ? ScrollBlockDirectionBackward : ScrollBlockDirectionForward;
3875     if (logicalScrollOverflow(direction, ScrollByPage)) {
3876         event.setDefaultHandled();
3877         return;
3878     }
3879 
3880     FrameView* view = m_frame.view();
3881     if (!view)
3882         return;
3883 
3884     if (view-&gt;logicalScroll(direction, ScrollByPage))
3885         event.setDefaultHandled();
3886 }
3887 
3888 void EventHandler::defaultBackspaceEventHandler(KeyboardEvent&amp; event)
3889 {
3890     ASSERT(event.type() == eventNames().keydownEvent);
3891 
3892     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3893         return;
3894 
3895     if (!m_frame.editor().behavior().shouldNavigateBackOnBackspace())
3896         return;
3897 
3898     Page* page = m_frame.page();
3899     if (!page)
3900         return;
3901 
3902     if (!m_frame.settings().backspaceKeyNavigationEnabled())
3903         return;
3904 
3905     bool handledEvent = false;
3906 
3907     if (event.shiftKey())
3908         handledEvent = page-&gt;backForward().goForward();
3909     else
3910         handledEvent = page-&gt;backForward().goBack();
3911 
3912     if (handledEvent)
3913         event.setDefaultHandled();
3914 }
3915 
3916 
3917 void EventHandler::defaultArrowEventHandler(FocusDirection focusDirection, KeyboardEvent&amp; event)
3918 {
3919     ASSERT(event.type() == eventNames().keydownEvent);
3920 
3921     if (event.ctrlKey() || event.metaKey() || event.altGraphKey() || event.shiftKey())
3922         return;
3923 
3924     Page* page = m_frame.page();
3925     if (!page)
3926         return;
3927 
3928     if (!isSpatialNavigationEnabled(&amp;m_frame))
3929         return;
3930 
3931     // Arrows and other possible directional navigation keys can be used in design
3932     // mode editing.
3933     if (m_frame.document()-&gt;inDesignMode())
3934         return;
3935 
3936     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
3937         event.setDefaultHandled();
3938 }
3939 
3940 void EventHandler::defaultTabEventHandler(KeyboardEvent&amp; event)
3941 {
3942     Ref&lt;Frame&gt; protectedFrame(m_frame);
3943 
3944     ASSERT(event.type() == eventNames().keydownEvent);
3945 
3946     // We should only advance focus on tabs if no special modifier keys are held down.
3947     if (event.ctrlKey() || event.metaKey() || event.altGraphKey())
3948         return;
3949 
3950     Page* page = m_frame.page();
3951     if (!page)
3952         return;
3953     if (!page-&gt;tabKeyCyclesThroughElements())
3954         return;
3955 
3956     FocusDirection focusDirection = event.shiftKey() ? FocusDirectionBackward : FocusDirectionForward;
3957 
3958     // Tabs can be used in design mode editing.
3959     if (m_frame.document()-&gt;inDesignMode())
3960         return;
3961 
3962     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
3963         event.setDefaultHandled();
3964 }
3965 
3966 void EventHandler::sendScrollEvent()
3967 {
3968     Ref&lt;Frame&gt; protectedFrame(m_frame);
3969     setFrameWasScrolledByUser();
3970     if (m_frame.view() &amp;&amp; m_frame.document())
3971         m_frame.document()-&gt;eventQueue().enqueueOrDispatchScrollEvent(*m_frame.document());
3972 }
3973 
3974 void EventHandler::setFrameWasScrolledByUser()
3975 {
3976     FrameView* v = m_frame.view();
3977     if (v)
3978         v-&gt;setWasScrolledByUser(true);
3979 }
3980 
3981 bool EventHandler::passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp; mouseEvent, Scrollbar* scrollbar)
3982 {
3983     if (!scrollbar || !scrollbar-&gt;enabled())
3984         return false;
3985     setFrameWasScrolledByUser();
3986     return scrollbar-&gt;mouseDown(mouseEvent.event());
3987 }
3988 
3989 // If scrollbar (under mouse) is different from last, send a mouse exited.
3990 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
3991 {
3992     if (m_lastScrollbarUnderMouse != scrollbar) {
3993         // Send mouse exited to the old scrollbar.
3994         if (m_lastScrollbarUnderMouse)
3995             m_lastScrollbarUnderMouse-&gt;mouseExited();
3996 
3997         // Send mouse entered if we&#39;re setting a new scrollbar.
3998         if (scrollbar &amp;&amp; setOrClear == SetOrClearLastScrollbar::Set) {
3999             scrollbar-&gt;mouseEntered();
4000             m_lastScrollbarUnderMouse = makeWeakPtr(*scrollbar);
4001         } else
4002             m_lastScrollbarUnderMouse = nullptr;
4003     }
4004 }
4005 
4006 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
<a name="38" id="anc38"></a><span class="line-modified">4007 static const AtomicString&amp; eventNameForTouchPointState(PlatformTouchPoint::State state)</span>
4008 {
4009     switch (state) {
4010     case PlatformTouchPoint::TouchReleased:
4011         return eventNames().touchendEvent;
4012     case PlatformTouchPoint::TouchCancelled:
4013         return eventNames().touchcancelEvent;
4014     case PlatformTouchPoint::TouchPressed:
4015         return eventNames().touchstartEvent;
4016     case PlatformTouchPoint::TouchMoved:
4017         return eventNames().touchmoveEvent;
4018     case PlatformTouchPoint::TouchStationary:
4019         // TouchStationary state is not converted to touch events, so fall through to assert.
4020     default:
4021         ASSERT_NOT_REACHED();
4022         return emptyAtom();
4023     }
4024 }
4025 
4026 static HitTestResult hitTestResultInFrame(Frame* frame, const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType)
4027 {
4028     HitTestResult result(point);
4029 
4030     if (!frame || !frame-&gt;contentRenderer())
4031         return result;
4032 
4033     if (frame-&gt;view()) {
4034         IntRect rect = frame-&gt;view()-&gt;visibleContentRect();
4035         if (!rect.contains(roundedIntPoint(point)))
4036             return result;
4037     }
4038     frame-&gt;document()-&gt;hitTest(HitTestRequest(hitType), result);
4039     return result;
4040 }
4041 
4042 bool EventHandler::handleTouchEvent(const PlatformTouchEvent&amp; event)
4043 {
4044     Ref&lt;Frame&gt; protectedFrame(m_frame);
4045 
4046     // First build up the lists to use for the &#39;touches&#39;, &#39;targetTouches&#39; and &#39;changedTouches&#39; attributes
4047     // in the JS event. See http://www.sitepen.com/blog/2008/07/10/touching-and-gesturing-on-the-iphone/
4048     // for an overview of how these lists fit together.
4049 
4050     // Holds the complete set of touches on the screen and will be used as the &#39;touches&#39; list in the JS event.
4051     RefPtr&lt;TouchList&gt; touches = TouchList::create();
4052 
4053     // A different view on the &#39;touches&#39; list above, filtered and grouped by event target. Used for the
4054     // &#39;targetTouches&#39; list in the JS event.
4055     typedef HashMap&lt;EventTarget*, RefPtr&lt;TouchList&gt;&gt; TargetTouchesMap;
4056     TargetTouchesMap touchesByTarget;
4057 
4058     // Array of touches per state, used to assemble the &#39;changedTouches&#39; list in the JS event.
4059     typedef HashSet&lt;RefPtr&lt;EventTarget&gt;&gt; EventTargetSet;
4060     struct {
4061         // The touches corresponding to the particular change state this struct instance represents.
4062         RefPtr&lt;TouchList&gt; m_touches;
4063         // Set of targets involved in m_touches.
4064         EventTargetSet m_targets;
4065     } changedTouches[PlatformTouchPoint::TouchStateEnd];
4066 
4067     const Vector&lt;PlatformTouchPoint&gt;&amp; points = event.touchPoints();
4068 
4069     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
4070 
4071     bool freshTouchEvents = true;
4072     bool allTouchReleased = true;
4073     for (auto&amp; point : points) {
4074         if (point.state() != PlatformTouchPoint::TouchPressed)
4075             freshTouchEvents = false;
4076         if (point.state() != PlatformTouchPoint::TouchReleased &amp;&amp; point.state() != PlatformTouchPoint::TouchCancelled)
4077             allTouchReleased = false;
4078     }
4079 
4080     for (auto&amp; point : points) {
4081         PlatformTouchPoint::State pointState = point.state();
4082         LayoutPoint pagePoint = documentPointForWindowPoint(m_frame, point.pos());
4083 
4084         HitTestRequest::HitTestRequestType hitType = HitTestRequest::TouchEvent;
4085         // The HitTestRequest types used for mouse events map quite adequately
4086         // to touch events. Note that in addition to meaning that the hit test
4087         // should affect the active state of the current node if necessary,
4088         // HitTestRequest::Active signifies that the hit test is taking place
4089         // with the mouse (or finger in this case) being pressed.
4090         switch (pointState) {
4091         case PlatformTouchPoint::TouchPressed:
4092             hitType |= HitTestRequest::Active;
4093             break;
4094         case PlatformTouchPoint::TouchMoved:
4095             hitType |= HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::ReadOnly;
4096             break;
4097         case PlatformTouchPoint::TouchReleased:
4098         case PlatformTouchPoint::TouchCancelled:
4099             hitType |= HitTestRequest::Release;
4100             break;
4101         case PlatformTouchPoint::TouchStationary:
4102             hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
4103             break;
4104         default:
4105             ASSERT_NOT_REACHED();
4106             break;
4107         }
4108 
4109         if (shouldGesturesTriggerActive())
4110             hitType |= HitTestRequest::ReadOnly;
4111 
4112         // Increment the platform touch id by 1 to avoid storing a key of 0 in the hashmap.
4113         unsigned touchPointTargetKey = point.id() + 1;
4114         RefPtr&lt;EventTarget&gt; touchTarget;
4115         if (pointState == PlatformTouchPoint::TouchPressed) {
4116             HitTestResult result;
4117             if (freshTouchEvents) {
<a name="39" id="anc39"></a><span class="line-modified">4118                 result = hitTestResultAtPoint(pagePoint, hitType);</span>
4119                 m_originatingTouchPointTargetKey = touchPointTargetKey;
4120             } else if (m_originatingTouchPointDocument.get() &amp;&amp; m_originatingTouchPointDocument-&gt;frame()) {
4121                 LayoutPoint pagePointInOriginatingDocument = documentPointForWindowPoint(*m_originatingTouchPointDocument-&gt;frame(), point.pos());
4122                 result = hitTestResultInFrame(m_originatingTouchPointDocument-&gt;frame(), pagePointInOriginatingDocument, hitType);
4123                 if (!result.innerNode())
4124                     continue;
4125             } else
4126                 continue;
4127 
4128             Element* element = result.targetElement();
4129             ASSERT(element);
4130 
4131             if (element &amp;&amp; InspectorInstrumentation::handleTouchEvent(m_frame, *element))
4132                 return true;
4133 
4134             Document&amp; doc = element-&gt;document();
4135             // Record the originating touch document even if it does not have a touch listener.
4136             if (freshTouchEvents) {
4137                 m_originatingTouchPointDocument = &amp;doc;
4138                 freshTouchEvents = false;
4139             }
4140             if (!doc.hasTouchEventHandlers())
4141                 continue;
4142             m_originatingTouchPointTargets.set(touchPointTargetKey, element);
4143             touchTarget = element;
4144         } else if (pointState == PlatformTouchPoint::TouchReleased || pointState == PlatformTouchPoint::TouchCancelled) {
4145             // No need to perform a hit-test since we only need to unset :hover and :active states.
4146             if (!shouldGesturesTriggerActive() &amp;&amp; allTouchReleased)
4147                 m_frame.document()-&gt;updateHoverActiveState(hitType, 0);
4148             if (touchPointTargetKey == m_originatingTouchPointTargetKey)
4149                 m_originatingTouchPointTargetKey = 0;
4150 
4151             // The target should be the original target for this touch, so get it from the hashmap. As it&#39;s a release or cancel
4152             // we also remove it from the map.
4153             touchTarget = m_originatingTouchPointTargets.take(touchPointTargetKey);
4154         } else
4155             // No hittest is performed on move or stationary, since the target is not allowed to change anyway.
4156             touchTarget = m_originatingTouchPointTargets.get(touchPointTargetKey);
4157 
4158         if (!is&lt;Node&gt;(touchTarget))
4159             continue;
4160         auto&amp; document = downcast&lt;Node&gt;(*touchTarget).document();
4161         if (!document.hasTouchEventHandlers())
4162             continue;
4163         auto* targetFrame = document.frame();
4164         if (!targetFrame)
4165             continue;
4166 
4167         if (&amp;m_frame != targetFrame) {
4168             // pagePoint should always be relative to the target elements containing frame.
4169             pagePoint = documentPointForWindowPoint(*targetFrame, point.pos());
4170         }
4171 
4172         float scaleFactor = targetFrame-&gt;pageZoomFactor() * targetFrame-&gt;frameScaleFactor();
4173 
4174         int adjustedPageX = lroundf(pagePoint.x() / scaleFactor);
4175         int adjustedPageY = lroundf(pagePoint.y() / scaleFactor);
4176 
4177         auto touch = Touch::create(targetFrame, touchTarget.get(), point.id(),
4178             point.screenPos().x(), point.screenPos().y(), adjustedPageX, adjustedPageY,
4179             point.radiusX(), point.radiusY(), point.rotationAngle(), point.force());
4180 
4181         // Ensure this target&#39;s touch list exists, even if it ends up empty, so it can always be passed to TouchEvent::Create below.
4182         TargetTouchesMap::iterator targetTouchesIterator = touchesByTarget.find(touchTarget.get());
4183         if (targetTouchesIterator == touchesByTarget.end())
4184             targetTouchesIterator = touchesByTarget.set(touchTarget.get(), TouchList::create()).iterator;
4185 
4186         // touches and targetTouches should only contain information about touches still on the screen, so if this point is
4187         // released or cancelled it will only appear in the changedTouches list.
4188         if (pointState != PlatformTouchPoint::TouchReleased &amp;&amp; pointState != PlatformTouchPoint::TouchCancelled) {
4189             touches-&gt;append(touch.copyRef());
4190             targetTouchesIterator-&gt;value-&gt;append(touch.copyRef());
4191         }
4192 
4193         // Now build up the correct list for changedTouches.
4194         // Note that  any touches that are in the TouchStationary state (e.g. if
4195         // the user had several points touched but did not move them all) should
4196         // never be in the changedTouches list so we do not handle them explicitly here.
4197         // See https://bugs.webkit.org/show_bug.cgi?id=37609 for further discussion
4198         // about the TouchStationary state.
4199         if (pointState != PlatformTouchPoint::TouchStationary) {
4200             ASSERT(pointState &lt; PlatformTouchPoint::TouchStateEnd);
4201             if (!changedTouches[pointState].m_touches)
4202                 changedTouches[pointState].m_touches = TouchList::create();
4203             changedTouches[pointState].m_touches-&gt;append(WTFMove(touch));
4204             changedTouches[pointState].m_targets.add(touchTarget);
4205         }
4206     }
4207     m_touchPressed = touches-&gt;length() &gt; 0;
4208     if (allTouchReleased)
4209         m_originatingTouchPointDocument = nullptr;
4210 
4211     // Now iterate the changedTouches list and m_targets within it, sending events to the targets as required.
4212     bool swallowedEvent = false;
4213     RefPtr&lt;TouchList&gt; emptyList = TouchList::create();
4214     for (unsigned state = 0; state != PlatformTouchPoint::TouchStateEnd; ++state) {
4215         if (!changedTouches[state].m_touches)
4216             continue;
4217 
4218         // When sending a touch cancel event, use empty touches and targetTouches lists.
4219         bool isTouchCancelEvent = (state == PlatformTouchPoint::TouchCancelled);
4220         RefPtr&lt;TouchList&gt;&amp; effectiveTouches(isTouchCancelEvent ? emptyList : touches);
<a name="40" id="anc40"></a><span class="line-modified">4221         const AtomicString&amp; stateName(eventNameForTouchPointState(static_cast&lt;PlatformTouchPoint::State&gt;(state)));</span>
4222 
4223         for (auto&amp; target : changedTouches[state].m_targets) {
4224             ASSERT(is&lt;Node&gt;(target));
4225 
4226             RefPtr&lt;TouchList&gt; targetTouches(isTouchCancelEvent ? emptyList : touchesByTarget.get(target.get()));
4227             ASSERT(targetTouches);
4228 
4229             Ref&lt;TouchEvent&gt; touchEvent = TouchEvent::create(effectiveTouches.get(), targetTouches.get(), changedTouches[state].m_touches.get(),
4230                 stateName, downcast&lt;Node&gt;(*target).document().windowProxy(), { }, event.modifiers());
4231             target-&gt;dispatchEvent(touchEvent);
4232             swallowedEvent = swallowedEvent || touchEvent-&gt;defaultPrevented() || touchEvent-&gt;defaultHandled();
4233         }
4234     }
4235 
4236     return swallowedEvent;
4237 }
4238 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4239 
4240 #if ENABLE(TOUCH_EVENTS)
4241 bool EventHandler::dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp; platformMouseEvent)
4242 {
4243 #if ENABLE(IOS_TOUCH_EVENTS)
4244     UNUSED_PARAM(platformMouseEvent);
4245     return false;
4246 #else
4247     if (!m_frame.settings().isTouchEventEmulationEnabled())
4248         return false;
4249 
4250     PlatformEvent::Type eventType = platformMouseEvent.type();
4251     if (eventType != PlatformEvent::MouseMoved &amp;&amp; eventType != PlatformEvent::MousePressed &amp;&amp; eventType != PlatformEvent::MouseReleased)
4252         return false;
4253 
4254     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
4255     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
4256     if (mouseEvent.scrollbar() || subframeForHitTestResult(mouseEvent))
4257         return false;
4258 
4259     // The order is important. This check should follow the subframe test: http://webkit.org/b/111292.
4260     if (eventType == PlatformEvent::MouseMoved &amp;&amp; !m_touchPressed)
4261         return true;
4262 
4263     SyntheticSingleTouchEvent touchEvent(platformMouseEvent);
4264     return handleTouchEvent(touchEvent);
4265 #endif
4266 }
4267 #endif // ENABLE(TOUCH_EVENTS)
4268 
4269 void EventHandler::setLastKnownMousePosition(const PlatformMouseEvent&amp; event)
4270 {
4271     m_mousePositionIsUnknown = false;
4272     m_lastKnownMousePosition = event.position();
4273     m_lastKnownMouseGlobalPosition = event.globalPosition();
4274 }
4275 
4276 void EventHandler::setImmediateActionStage(ImmediateActionStage stage)
4277 {
4278     m_immediateActionStage = stage;
4279 }
4280 
4281 #if !PLATFORM(COCOA)
4282 OptionSet&lt;PlatformEvent::Modifier&gt; EventHandler::accessKeyModifiers()
4283 {
4284     return PlatformEvent::Modifier::AltKey;
4285 }
4286 
4287 bool EventHandler::passMousePressEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4288 {
4289     subframe-&gt;eventHandler().handleMousePressEvent(mev.event());
4290     return true;
4291 }
4292 
4293 bool EventHandler::passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4294 {
4295     subframe-&gt;eventHandler().handleMouseReleaseEvent(mev.event());
4296     return true;
4297 }
4298 
4299 bool EventHandler::widgetDidHandleWheelEvent(const PlatformWheelEvent&amp; event, Widget&amp; widget)
4300 {
4301     if (!is&lt;FrameView&gt;(widget))
4302         return false;
4303 
4304     return downcast&lt;FrameView&gt;(widget).frame().eventHandler().handleWheelEvent(event);
4305 }
4306 
4307 bool EventHandler::tabsToAllFormControls(KeyboardEvent*) const
4308 {
4309     // We always allow tabs to all controls
4310     return true;
4311 }
4312 
4313 bool EventHandler::passWidgetMouseDownEventToWidget(RenderWidget* renderWidget)
4314 {
4315     return passMouseDownEventToWidget(renderWidget-&gt;widget());
4316 }
4317 
4318 bool EventHandler::passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp; event)
4319 {
4320     // Figure out which view to send the event to.
4321     RenderObject* target = event.targetNode() ? event.targetNode()-&gt;renderer() : nullptr;
4322     if (!is&lt;RenderWidget&gt;(target))
4323         return false;
4324     return passMouseDownEventToWidget(downcast&lt;RenderWidget&gt;(*target).widget());
4325 }
4326 
4327 bool EventHandler::passMouseDownEventToWidget(Widget*)
4328 {
4329     notImplemented();
4330     return false;
4331 }
4332 
4333 void EventHandler::focusDocumentView()
4334 {
4335     if (Page* page = m_frame.page())
4336         page-&gt;focusController().setFocusedFrame(&amp;m_frame);
4337 }
4338 #endif // !PLATFORM(COCOA)
4339 
4340 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(JAVA)
4341 bool EventHandler::eventActivatedView(const PlatformMouseEvent&amp;) const
4342 {
4343     notImplemented();
4344     return false;
4345 }
4346 
4347 bool EventHandler::passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe, HitTestResult* hoveredNode)
4348 {
4349     subframe-&gt;eventHandler().handleMouseMoveEvent(mev.event(), hoveredNode);
4350     return true;
4351 }
4352 #endif // !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN)
4353 
4354 } // namespace WebCore
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>