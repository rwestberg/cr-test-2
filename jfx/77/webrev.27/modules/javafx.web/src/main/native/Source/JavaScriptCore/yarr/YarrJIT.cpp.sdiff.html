<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55     static const RegisterID returnRegister2 = ARMRegisters::r1;
  56 
  57 #define HAVE_INITIAL_START_REG
  58 #elif CPU(ARM64)
  59     // Argument registers
  60     static const RegisterID input = ARM64Registers::x0;
  61     static const RegisterID index = ARM64Registers::x1;
  62     static const RegisterID length = ARM64Registers::x2;
  63     static const RegisterID output = ARM64Registers::x3;
  64     static const RegisterID freelistRegister = ARM64Registers::x4;
  65     static const RegisterID freelistSizeRegister = ARM64Registers::x5;
  66 
  67     // Scratch registers
  68     static const RegisterID regT0 = ARM64Registers::x6;
  69     static const RegisterID regT1 = ARM64Registers::x7;
  70     static const RegisterID regT2 = ARM64Registers::x8;
  71     static const RegisterID remainingMatchCount = ARM64Registers::x9;
  72     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
  73     static const RegisterID initialStart = ARM64Registers::x11;
  74     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
<span class="line-modified">  75     static const RegisterID surrogateTagMask = ARM64Registers::x13;</span>
<span class="line-modified">  76     static const RegisterID leadingSurrogateTag = ARM64Registers::x14;</span>
<span class="line-modified">  77     static const RegisterID trailingSurrogateTag = ARM64Registers::x15;</span>
  78 
  79     static const RegisterID returnRegister = ARM64Registers::x0;
  80     static const RegisterID returnRegister2 = ARM64Registers::x1;
  81 

  82 #define HAVE_INITIAL_START_REG
  83 #define JIT_UNICODE_EXPRESSIONS
  84 #elif CPU(MIPS)
  85     static const RegisterID input = MIPSRegisters::a0;
  86     static const RegisterID index = MIPSRegisters::a1;
  87     static const RegisterID length = MIPSRegisters::a2;
  88     static const RegisterID output = MIPSRegisters::a3;
  89 
  90     static const RegisterID regT0 = MIPSRegisters::t4;
  91     static const RegisterID regT1 = MIPSRegisters::t5;
  92     static const RegisterID initialStart = MIPSRegisters::t6;
  93 
  94     static const RegisterID returnRegister = MIPSRegisters::v0;
  95     static const RegisterID returnRegister2 = MIPSRegisters::v1;
  96 
  97 #define HAVE_INITIAL_START_REG
  98 #elif CPU(X86)
  99     static const RegisterID input = X86Registers::eax;
 100     static const RegisterID index = X86Registers::edx;
 101     static const RegisterID length = X86Registers::ecx;
</pre>
<hr />
<pre>
 126 #endif
 127 
 128     // Scratch registers
 129     static const RegisterID regT0 = X86Registers::eax;
 130 #if !OS(WINDOWS)
 131     static const RegisterID regT1 = X86Registers::r9;
 132     static const RegisterID regT2 = X86Registers::r10;
 133 #else
 134     static const RegisterID regT1 = X86Registers::ecx;
 135     static const RegisterID regT2 = X86Registers::edi;
 136 #endif
 137 
 138     static const RegisterID initialStart = X86Registers::ebx;
 139 #if !OS(WINDOWS)
 140     static const RegisterID remainingMatchCount = X86Registers::r12;
 141 #else
 142     static const RegisterID remainingMatchCount = X86Registers::esi;
 143 #endif
 144     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
 145     static const RegisterID leadingSurrogateTag = X86Registers::r14;
<span class="line-modified"> 146     static const RegisterID trailingSurrogateTag = X86Registers::r15;</span>
 147 
 148     static const RegisterID returnRegister = X86Registers::eax;
 149     static const RegisterID returnRegister2 = X86Registers::edx;
 150 
 151     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);

 152     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
 153 #define HAVE_INITIAL_START_REG
 154 #define JIT_UNICODE_EXPRESSIONS
 155 #endif
 156 
 157 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 158     struct ParenContextSizes {
 159         size_t m_numSubpatterns;
 160         size_t m_frameSlots;
 161 
 162         ParenContextSizes(size_t numSubpatterns, size_t frameSlots)
 163             : m_numSubpatterns(numSubpatterns)
 164             , m_frameSlots(frameSlots)
 165         {
 166         }
 167 
 168         size_t numSubpatterns() { return m_numSubpatterns; }
 169 
 170         size_t frameSlots() { return m_frameSlots; }
 171     };
</pre>
<hr />
<pre>
 209         static ptrdiff_t subpatternOffset(size_t subpattern)
 210         {
 211             return offsetof(ParenContext, subpatterns) + (subpattern - 1) * sizeof(Subpatterns);
 212         }
 213 
 214         static ptrdiff_t savedFrameOffset(ParenContextSizes&amp; parenContextSizes)
 215         {
 216             return offsetof(ParenContext, subpatterns) + (parenContextSizes.numSubpatterns()) * sizeof(Subpatterns);
 217         }
 218     };
 219 
 220     void initParenContextFreeList()
 221     {
 222         RegisterID parenContextPointer = regT0;
 223         RegisterID nextParenContextPointer = regT2;
 224 
 225         size_t parenContextSize = ParenContext::sizeFor(m_parenContextSizes);
 226 
 227         parenContextSize = WTF::roundUpToMultipleOf&lt;sizeof(uintptr_t)&gt;(parenContextSize);
 228 
<span class="line-modified"> 229         // Check that the paren context is a reasonable size.</span>
<span class="line-modified"> 230         if (parenContextSize &gt; INT16_MAX)</span>
<span class="line-modified"> 231             m_abortExecution.append(jump());</span>

 232 
 233         Jump emptyFreeList = branchTestPtr(Zero, freelistRegister);
 234         move(freelistRegister, parenContextPointer);
 235         addPtr(TrustedImm32(parenContextSize), freelistRegister, nextParenContextPointer);
 236         addPtr(freelistRegister, freelistSizeRegister);
 237         subPtr(TrustedImm32(parenContextSize), freelistSizeRegister);
 238 
 239         Label loopTop(this);
 240         Jump initDone = branchPtr(Above, nextParenContextPointer, freelistSizeRegister);
 241         storePtr(nextParenContextPointer, Address(parenContextPointer, ParenContext::nextOffset()));
 242         move(nextParenContextPointer, parenContextPointer);
 243         addPtr(TrustedImm32(parenContextSize), parenContextPointer, nextParenContextPointer);
 244         jump(loopTop);
 245 
 246         initDone.link(this);
 247         storePtr(TrustedImmPtr(nullptr), Address(parenContextPointer, ParenContext::nextOffset()));
 248         emptyFreeList.link(this);
 249     }
 250 
 251     void allocateParenContext(RegisterID result)
</pre>
<hr />
<pre>
 302         subpatternBaseFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
 303         for (unsigned frameLocation = subpatternBaseFrameLocation; frameLocation &lt; m_parenContextSizes.frameSlots(); frameLocation++) {
 304             loadPtr(Address(parenContextReg, ParenContext::savedFrameOffset(m_parenContextSizes) + frameLocation * sizeof(uintptr_t)), tempReg);
 305             storeToFrame(tempReg, frameLocation);
 306         }
 307     }
 308 #endif
 309 
 310     void optimizeAlternative(PatternAlternative* alternative)
 311     {
 312         if (!alternative-&gt;m_terms.size())
 313             return;
 314 
 315         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size() - 1; ++i) {
 316             PatternTerm&amp; term = alternative-&gt;m_terms[i];
 317             PatternTerm&amp; nextTerm = alternative-&gt;m_terms[i + 1];
 318 
 319             // We can move BMP only character classes after fixed character terms.
 320             if ((term.type == PatternTerm::TypeCharacterClass)
 321                 &amp;&amp; (term.quantityType == QuantifierFixedCount)
<span class="line-modified"> 322                 &amp;&amp; (!m_decodeSurrogatePairs || (!term.characterClass-&gt;m_hasNonBMPCharacters &amp;&amp; !term.m_invert))</span>
 323                 &amp;&amp; (nextTerm.type == PatternTerm::TypePatternCharacter)
 324                 &amp;&amp; (nextTerm.quantityType == QuantifierFixedCount)) {
 325                 PatternTerm termCopy = term;
 326                 alternative-&gt;m_terms[i] = nextTerm;
 327                 alternative-&gt;m_terms[i + 1] = termCopy;
 328             }
 329         }
 330     }
 331 
 332     void matchCharacterClassRange(RegisterID character, JumpList&amp; failures, JumpList&amp; matchDest, const CharacterRange* ranges, unsigned count, unsigned* matchIndex, const UChar32* matches, unsigned matchCount)
 333     {
 334         do {
 335             // pick which range we&#39;re going to generate
 336             int which = count &gt;&gt; 1;
 337             char lo = ranges[which].begin;
 338             char hi = ranges[which].end;
 339 
 340             // check if there are any ranges or matches below lo.  If not, just jl to failure -
 341             // if there is anything else to check, check that first, if it falls through jmp to failure.
 342             if ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt; lo)) {
</pre>
<hr />
<pre>
 366             while ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt;= hi))
 367                 ++*matchIndex;
 368 
 369             matchDest.append(branch32(LessThanOrEqual, character, Imm32((unsigned short)hi)));
 370             // fall through to here, the value is above hi.
 371 
 372             // shuffle along &amp; loop around if there are any more matches to handle.
 373             unsigned next = which + 1;
 374             ranges += next;
 375             count -= next;
 376         } while (count);
 377     }
 378 
 379     void matchCharacterClass(RegisterID character, JumpList&amp; matchDest, const CharacterClass* charClass)
 380     {
 381         if (charClass-&gt;m_table &amp;&amp; !m_decodeSurrogatePairs) {
 382             ExtendedAddress tableEntry(character, reinterpret_cast&lt;intptr_t&gt;(charClass-&gt;m_table));
 383             matchDest.append(branchTest8(charClass-&gt;m_tableInverted ? Zero : NonZero, tableEntry));
 384             return;
 385         }

 386         JumpList unicodeFail;
 387         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size()) {
 388             JumpList isAscii;
 389             if (charClass-&gt;m_matches.size() || charClass-&gt;m_ranges.size())
 390                 isAscii.append(branch32(LessThanOrEqual, character, TrustedImm32(0x7f)));
 391 
 392             if (charClass-&gt;m_matchesUnicode.size()) {
 393                 for (unsigned i = 0; i &lt; charClass-&gt;m_matchesUnicode.size(); ++i) {
 394                     UChar32 ch = charClass-&gt;m_matchesUnicode[i];
 395                     matchDest.append(branch32(Equal, character, Imm32(ch)));
 396                 }
 397             }
 398 
 399             if (charClass-&gt;m_rangesUnicode.size()) {
 400                 for (unsigned i = 0; i &lt; charClass-&gt;m_rangesUnicode.size(); ++i) {
 401                     UChar32 lo = charClass-&gt;m_rangesUnicode[i].begin;
 402                     UChar32 hi = charClass-&gt;m_rangesUnicode[i].end;
 403 
 404                     Jump below = branch32(LessThan, character, Imm32(lo));
 405                     matchDest.append(branch32(LessThanOrEqual, character, Imm32(hi)));
</pre>
<hr />
<pre>
 431                         matchesAZaz.append(ch);
 432                         continue;
 433                     }
 434                     if (isASCIIUpper(ch))
 435                         continue;
 436                 }
 437                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)ch)));
 438             }
 439 
 440             if (unsigned countAZaz = matchesAZaz.size()) {
 441                 or32(TrustedImm32(32), character);
 442                 for (unsigned i = 0; i &lt; countAZaz; ++i)
 443                     matchDest.append(branch32(Equal, character, TrustedImm32(matchesAZaz[i])));
 444             }
 445         }
 446 
 447         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size())
 448             unicodeFail.link(this);
 449     }
 450 

















 451     // Jumps if input not available; will have (incorrectly) incremented already!
 452     Jump jumpIfNoAvailableInput(unsigned countToCheck = 0)
 453     {
 454         if (countToCheck)
 455             add32(Imm32(countToCheck), index);
 456         return branch32(Above, index, length);
 457     }
 458 
 459     Jump jumpIfAvailableInput(unsigned countToCheck)
 460     {
 461         add32(Imm32(countToCheck), index);
 462         return branch32(BelowOrEqual, index, length);
 463     }
 464 
 465     Jump checkNotEnoughInput(RegisterID additionalAmount)
 466     {
 467         add32(index, additionalAmount);
 468         return branch32(Above, additionalAmount, length);
 469     }
 470 
</pre>
<hr />
<pre>
 503                 if (m_charSize != Char8)
 504                     subPtr(TrustedImm32(offsetAdjustAmount), base);
 505                 negativeCharacterOffset -= offsetAdjustAmount;
 506             }
 507         }
 508 
 509         Checked&lt;int32_t&gt; characterOffset(-static_cast&lt;int32_t&gt;(negativeCharacterOffset.unsafeGet()));
 510 
 511         if (m_charSize == Char8)
 512             return BaseIndex(input, indexReg, TimesOne, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(char))).unsafeGet());
 513 
 514         return BaseIndex(input, indexReg, TimesTwo, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(UChar))).unsafeGet());
 515     }
 516 
 517 #ifdef JIT_UNICODE_EXPRESSIONS
 518     void tryReadUnicodeCharImpl(RegisterID resultReg)
 519     {
 520         ASSERT(m_charSize == Char16);
 521 
 522         JumpList notUnicode;

 523         load16Unaligned(regUnicodeInputAndTrail, resultReg);
 524         and32(surrogateTagMask, resultReg, regT2);
 525         notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
 526         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
<span class="line-modified"> 527         getEffectiveAddress(BaseIndex(input, length, TimesTwo), regT2);</span>
<span class="line-removed"> 528         notUnicode.append(branch32(AboveOrEqual, regUnicodeInputAndTrail, regT2));</span>
 529         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
 530         and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
 531         notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
 532         sub32(leadingSurrogateTag, resultReg);
 533         sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
 534         lshift32(TrustedImm32(10), resultReg);
 535         or32(regUnicodeInputAndTrail, resultReg);
 536         add32(supplementaryPlanesBase, resultReg);
 537         notUnicode.link(this);
 538     }
 539 
 540     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
 541     {
 542         ASSERT(m_charSize == Char16);
 543 
 544         getEffectiveAddress(address, regUnicodeInputAndTrail);
 545 
 546         if (resultReg == regT0)
 547             m_tryReadUnicodeCharacterCalls.append(nearCall());
 548         else
</pre>
<hr />
<pre>
 601 
 602 #if CPU(ARM64) || CPU(X86_64)
 603     void storeToFrame(TrustedImmPtr imm, unsigned frameLocation)
 604     {
 605         poke(imm, frameLocation);
 606     }
 607 #endif
 608 
 609     DataLabelPtr storeToFrameWithPatch(unsigned frameLocation)
 610     {
 611         return storePtrWithPatch(TrustedImmPtr(nullptr), Address(stackPointerRegister, frameLocation * sizeof(void*)));
 612     }
 613 
 614     void loadFromFrame(unsigned frameLocation, RegisterID reg)
 615     {
 616         peek(reg, frameLocation);
 617     }
 618 
 619     void loadFromFrameAndJump(unsigned frameLocation)
 620     {
<span class="line-modified"> 621         jump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);</span>
 622     }
 623 
 624     unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
 625     {
 626         if (!callFrameSize)
 627             return 0;
 628 
 629         callFrameSize *= sizeof(void*);
 630         if (callFrameSize / sizeof(void*) != m_pattern.m_body-&gt;m_callFrameSize)
 631             CRASH();
 632         callFrameSize = (callFrameSize + 0x3f) &amp; ~0x3f;
 633         return callFrameSize;
 634     }
 635     void initCallFrame()
 636     {
 637         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 638         if (callFrameSizeInBytes) {
 639 #if CPU(X86_64) || CPU(ARM64)
 640             if (Options::zeroStackFrame()) {
 641                 // We need to start from the stack pointer, because we could have spilled callee saves
</pre>
<hr />
<pre>
 733     //    vector, store the match start in the output vector.
 734     // 3) If we&#39;re compiling MatchOnly, &#39;output&#39; is unused, store the match start directly
 735     //    in this register.
 736     void setMatchStart(RegisterID reg)
 737     {
 738         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 739         if (compileMode == IncludeSubpatterns)
 740             store32(reg, output);
 741         else
 742             move(reg, output);
 743     }
 744     void getMatchStart(RegisterID reg)
 745     {
 746         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 747         if (compileMode == IncludeSubpatterns)
 748             load32(output, reg);
 749         else
 750             move(output, reg);
 751     }
 752 
<span class="line-modified"> 753     enum YarrOpCode {</span>
 754         // These nodes wrap body alternatives - those in the main disjunction,
 755         // rather than subpatterns or assertions. These are chained together in
 756         // a doubly linked list, with a &#39;begin&#39; node for the first alternative,
 757         // a &#39;next&#39; node for each subsequent alternative, and an &#39;end&#39; node at
 758         // the end. In the case of repeating alternatives, the &#39;end&#39; node also
 759         // has a reference back to &#39;begin&#39;.
 760         OpBodyAlternativeBegin,
 761         OpBodyAlternativeNext,
 762         OpBodyAlternativeEnd,
 763         // Similar to the body alternatives, but used for subpatterns with two
 764         // or more alternatives.
 765         OpNestedAlternativeBegin,
 766         OpNestedAlternativeNext,
 767         OpNestedAlternativeEnd,
 768         // Used for alternatives in subpatterns where there is only a single
 769         // alternative (backtracking is easier in these cases), or for alternatives
 770         // which never need to be backtracked (those in parenthetical assertions,
 771         // terminal subpatterns).
 772         OpSimpleNestedAlternativeBegin,
 773         OpSimpleNestedAlternativeNext,
</pre>
<hr />
<pre>
 779         OpParenthesesSubpatternTerminalBegin,
 780         OpParenthesesSubpatternTerminalEnd,
 781         // Used to wrap generic captured matches
 782         OpParenthesesSubpatternBegin,
 783         OpParenthesesSubpatternEnd,
 784         // Used to wrap parenthetical assertions.
 785         OpParentheticalAssertionBegin,
 786         OpParentheticalAssertionEnd,
 787         // Wraps all simple terms (pattern characters, character classes).
 788         OpTerm,
 789         // Where an expression contains only &#39;once through&#39; body alternatives
 790         // and no repeating ones, this op is used to return match failure.
 791         OpMatchFailed
 792     };
 793 
 794     // This structure is used to hold the compiled opcode information,
 795     // including reference back to the original PatternTerm/PatternAlternatives,
 796     // and JIT compilation data structures.
 797     struct YarrOp {
 798         explicit YarrOp(PatternTerm* term)
<span class="line-modified"> 799             : m_op(OpTerm)</span>
<span class="line-modified"> 800             , m_term(term)</span>
 801             , m_isDeadCode(false)
 802         {
 803         }
 804 
 805         explicit YarrOp(YarrOpCode op)
 806             : m_op(op)
 807             , m_isDeadCode(false)
 808         {
 809         }
 810 
<span class="line-removed"> 811         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.</span>
<span class="line-removed"> 812         YarrOpCode m_op;</span>
<span class="line-removed"> 813         PatternTerm* m_term;</span>
<span class="line-removed"> 814 </span>
 815         // For alternatives, this holds the PatternAlternative and doubly linked
 816         // references to this alternative&#39;s siblings. In the case of the
 817         // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
 818         // m_nextOp will reference the OpBodyAlternativeBegin node of the first
 819         // repeating alternative.
 820         PatternAlternative* m_alternative;
 821         size_t m_previousOp;
 822         size_t m_nextOp;
 823 




 824         // Used to record a set of Jumps out of the generated code, typically
 825         // used for jumps out to backtracking code, and a single reentry back
 826         // into the code for a node (likely where a backtrack will trigger
 827         // rematching).
 828         Label m_reentry;
 829         JumpList m_jumps;
 830 
 831         // Used for backtracking when the prior alternative did not consume any
 832         // characters but matched.
 833         Jump m_zeroLengthMatch;
 834 
 835         // This flag is used to null out the second pattern character, when
 836         // two are fused to match a pair together.
 837         bool m_isDeadCode;
 838 
 839         // Currently used in the case of some of the more complex management of
 840         // &#39;m_checkedOffset&#39;, to cache the offset used in this alternative, to avoid
 841         // recalculating it.
 842         Checked&lt;unsigned&gt; m_checkAdjust;
 843 
</pre>
<hr />
<pre>
1335         failures.link(this);
1336         m_backtrackingState.fallthrough();
1337     }
1338 #endif
1339 
1340     void generatePatternCharacterOnce(size_t opIndex)
1341     {
1342         YarrOp&amp; op = m_ops[opIndex];
1343 
1344         if (op.m_isDeadCode)
1345             return;
1346 
1347         // m_ops always ends with a OpBodyAlternativeEnd or OpMatchFailed
1348         // node, so there must always be at least one more node.
1349         ASSERT(opIndex + 1 &lt; m_ops.size());
1350         YarrOp* nextOp = &amp;m_ops[opIndex + 1];
1351 
1352         PatternTerm* term = op.m_term;
1353         UChar32 ch = term-&gt;patternCharacter;
1354 
<span class="line-modified">1355         if ((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
1356             // Have a 16 bit pattern character and an 8 bit string - short circuit
1357             op.m_jumps.append(jump());
1358             return;
1359         }
1360 
1361         const RegisterID character = regT0;
1362 #if CPU(X86_64) || CPU(ARM64)
1363         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 8 : 4;
1364 #else
1365         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 4 : 2;
1366 #endif
1367         uint64_t ignoreCaseMask = 0;
1368 #if CPU(BIG_ENDIAN)
1369         uint64_t allCharacters = ch &lt;&lt; (m_charSize == Char8 ? 24 : 16);
1370 #else
1371         uint64_t allCharacters = ch;
1372 #endif
1373         unsigned numberCharacters;
1374         unsigned startTermPosition = term-&gt;inputPosition;
1375 
</pre>
<hr />
<pre>
1390 
1391             // YarrJIT handles decoded surrogate pair as one character if unicode flag is enabled.
1392             // Note that the numberCharacters become 1 while the width of the pattern character becomes 32bit in this case.
1393             if (nextTerm-&gt;type != PatternTerm::TypePatternCharacter
1394                 || nextTerm-&gt;quantityType != QuantifierFixedCount
1395                 || nextTerm-&gt;quantityMaxCount != 1
1396                 || nextTerm-&gt;inputPosition != (startTermPosition + numberCharacters)
1397                 || (U16_LENGTH(nextTerm-&gt;patternCharacter) != 1 &amp;&amp; m_decodeSurrogatePairs))
1398                 break;
1399 
1400             nextOp-&gt;m_isDeadCode = true;
1401 
1402 #if CPU(BIG_ENDIAN)
1403             int shiftAmount = (m_charSize == Char8 ? 24 : 16) - ((m_charSize == Char8 ? 8 : 16) * numberCharacters);
1404 #else
1405             int shiftAmount = (m_charSize == Char8 ? 8 : 16) * numberCharacters;
1406 #endif
1407 
1408             UChar32 currentCharacter = nextTerm-&gt;patternCharacter;
1409 
<span class="line-modified">1410             if ((currentCharacter &gt; 0xff) &amp;&amp; (m_charSize == Char8)) {</span>
1411                 // Have a 16 bit pattern character and an 8 bit string - short circuit
1412                 op.m_jumps.append(jump());
1413                 return;
1414             }
1415 
1416             // For case-insesitive compares, non-ascii characters that have different
1417             // upper &amp; lower case representations are converted to a character class.
1418             ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(currentCharacter) || isCanonicallyUnique(currentCharacter, m_canonicalMode));
1419 
1420             allCharacters |= (static_cast&lt;uint64_t&gt;(currentCharacter) &lt;&lt; shiftAmount);
1421 
1422             if ((m_pattern.ignoreCase()) &amp;&amp; (isASCIIAlpha(currentCharacter)))
1423                 ignoreCaseMask |= 32ULL &lt;&lt; shiftAmount;
1424         }
1425 
1426         if (m_decodeSurrogatePairs)
1427             op.m_jumps.append(jumpIfNoAvailableInput());
1428 
1429         if (m_charSize == Char8) {
1430             auto check1 = [&amp;] (Checked&lt;unsigned&gt; offset, UChar32 characters) {
</pre>
<hr />
<pre>
1585             add32(TrustedImm32(1), countRegister);
1586         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1587     }
1588     void backtrackPatternCharacterFixed(size_t opIndex)
1589     {
1590         backtrackTermDefault(opIndex);
1591     }
1592 
1593     void generatePatternCharacterGreedy(size_t opIndex)
1594     {
1595         YarrOp&amp; op = m_ops[opIndex];
1596         PatternTerm* term = op.m_term;
1597         UChar32 ch = term-&gt;patternCharacter;
1598 
1599         const RegisterID character = regT0;
1600         const RegisterID countRegister = regT1;
1601 
1602         move(TrustedImm32(0), countRegister);
1603 
1604         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">1605         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
1606             JumpList failures;
1607             Label loop(this);
1608             failures.append(atEndOfInput());
1609             failures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1610 
1611             add32(TrustedImm32(1), index);
1612 #ifdef JIT_UNICODE_EXPRESSIONS
1613             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1614                 Jump surrogatePairOk = notAtEndOfInput();
1615                 sub32(TrustedImm32(1), index);
1616                 failures.append(jump());
1617                 surrogatePairOk.link(this);
1618                 add32(TrustedImm32(1), index);
1619             }
1620 #endif
1621             add32(TrustedImm32(1), countRegister);
1622 
1623             if (term-&gt;quantityMaxCount == quantifyInfinite)
1624                 jump(loop);
1625             else
</pre>
<hr />
<pre>
1658         const RegisterID countRegister = regT1;
1659 
1660         move(TrustedImm32(0), countRegister);
1661         op.m_reentry = label();
1662         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex());
1663     }
1664     void backtrackPatternCharacterNonGreedy(size_t opIndex)
1665     {
1666         YarrOp&amp; op = m_ops[opIndex];
1667         PatternTerm* term = op.m_term;
1668         UChar32 ch = term-&gt;patternCharacter;
1669 
1670         const RegisterID character = regT0;
1671         const RegisterID countRegister = regT1;
1672 
1673         m_backtrackingState.link(this);
1674 
1675         loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
1676 
1677         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">1678         if (!((ch &gt; 0xff) &amp;&amp; (m_charSize == Char8))) {</span>
1679             JumpList nonGreedyFailures;
1680             nonGreedyFailures.append(atEndOfInput());
1681             if (term-&gt;quantityMaxCount != quantifyInfinite)
1682                 nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1683             nonGreedyFailures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1684 
1685             add32(TrustedImm32(1), index);
1686 #ifdef JIT_UNICODE_EXPRESSIONS
1687             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1688                 Jump surrogatePairOk = notAtEndOfInput();
1689                 sub32(TrustedImm32(1), index);
1690                 nonGreedyFailures.append(jump());
1691                 surrogatePairOk.link(this);
1692                 add32(TrustedImm32(1), index);
1693             }
1694 #endif
1695             add32(TrustedImm32(1), countRegister);
1696 
1697             jump(op.m_reentry);
1698             nonGreedyFailures.link(this);
</pre>
<hr />
<pre>
1717         if (m_decodeSurrogatePairs) {
1718             op.m_jumps.append(jumpIfNoAvailableInput());
1719             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1720         }
1721 
1722         JumpList matchDest;
1723         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1724         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1725         // character and don&#39;t need to match as it will always succeed.
1726         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1727             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1728 
1729             if (term-&gt;invert())
1730                 op.m_jumps.append(matchDest);
1731             else {
1732                 op.m_jumps.append(jump());
1733                 matchDest.link(this);
1734             }
1735         }
1736 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">1737         if (m_decodeSurrogatePairs) {</span>
1738             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);

1739             add32(TrustedImm32(1), index);
1740             isBMPChar.link(this);
1741         }
1742 #endif
1743     }
1744     void backtrackCharacterClassOnce(size_t opIndex)
1745     {
1746 #ifdef JIT_UNICODE_EXPRESSIONS
1747         if (m_decodeSurrogatePairs) {
1748             YarrOp&amp; op = m_ops[opIndex];
1749             PatternTerm* term = op.m_term;
1750 
1751             m_backtrackingState.link(this);
1752             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
1753             m_backtrackingState.fallthrough();
1754         }
1755 #endif
1756         backtrackTermDefault(opIndex);
1757     }
1758 
1759     void generateCharacterClassFixed(size_t opIndex)
1760     {
1761         YarrOp&amp; op = m_ops[opIndex];
1762         PatternTerm* term = op.m_term;
1763 
1764         const RegisterID character = regT0;
1765         const RegisterID countRegister = regT1;
1766 
1767         if (m_decodeSurrogatePairs)
1768             op.m_jumps.append(jumpIfNoAvailableInput());
1769 
1770         move(index, countRegister);
<span class="line-modified">1771         sub32(Imm32(term-&gt;quantityMaxCount.unsafeGet()), countRegister);</span>







1772 
1773         Label loop(this);
1774         JumpList matchDest;
<span class="line-modified">1775         readCharacter(m_checkedOffset - term-&gt;inputPosition - term-&gt;quantityMaxCount, character, countRegister);</span>
1776         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1777         // character and don&#39;t need to match as it will always succeed.
1778         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1779             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1780 
1781             if (term-&gt;invert())
1782                 op.m_jumps.append(matchDest);
1783             else {
1784                 op.m_jumps.append(jump());
1785                 matchDest.link(this);
1786             }
1787         }
1788 
<span class="line-removed">1789         add32(TrustedImm32(1), countRegister);</span>
1790 #ifdef JIT_UNICODE_EXPRESSIONS
1791         if (m_decodeSurrogatePairs) {
<span class="line-modified">1792             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-modified">1793             op.m_jumps.append(atEndOfInput());</span>
<span class="line-modified">1794             add32(TrustedImm32(1), countRegister);</span>
<span class="line-modified">1795             add32(TrustedImm32(1), index);</span>
<span class="line-modified">1796             isBMPChar.link(this);</span>
<span class="line-modified">1797         }</span>





1798 #endif

1799         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1800     }
1801     void backtrackCharacterClassFixed(size_t opIndex)
1802     {
1803         backtrackTermDefault(opIndex);
1804     }
1805 
1806     void generateCharacterClassGreedy(size_t opIndex)
1807     {
1808         YarrOp&amp; op = m_ops[opIndex];
1809         PatternTerm* term = op.m_term;
1810 
1811         const RegisterID character = regT0;
1812         const RegisterID countRegister = regT1;
1813 
<span class="line-modified">1814         if (m_decodeSurrogatePairs)</span>
1815             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1816         move(TrustedImm32(0), countRegister);
1817 
1818         JumpList failures;

1819         Label loop(this);
<span class="line-modified">1820         failures.append(atEndOfInput());</span>






1821 
1822         if (term-&gt;invert()) {
1823             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1824             matchCharacterClass(character, failures, term-&gt;characterClass);
1825         } else {
1826             JumpList matchDest;
1827             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">1828             // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">1829             // character and don&#39;t need to match as it will always succeed.</span>
1830             if (!term-&gt;characterClass-&gt;m_anyCharacter) {
1831                 matchCharacterClass(character, matchDest, term-&gt;characterClass);
1832                 failures.append(jump());
1833             }
1834             matchDest.link(this);
1835         }
1836 
<span class="line-removed">1837         add32(TrustedImm32(1), index);</span>
1838 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">1839         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">1840             failures.append(atEndOfInput());</span>
<span class="line-modified">1841             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">1842             add32(TrustedImm32(1), index);</span>
<span class="line-removed">1843             isBMPChar.link(this);</span>
<span class="line-removed">1844         }</span>
1845 #endif

1846         add32(TrustedImm32(1), countRegister);
1847 
1848         if (term-&gt;quantityMaxCount != quantifyInfinite) {
1849             branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
1850             failures.append(jump());
1851         } else
1852             jump(loop);
1853 





1854         failures.link(this);
1855         op.m_reentry = label();
1856 
1857         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1858     }
1859     void backtrackCharacterClassGreedy(size_t opIndex)
1860     {
1861         YarrOp&amp; op = m_ops[opIndex];
1862         PatternTerm* term = op.m_term;
1863 
1864         const RegisterID countRegister = regT1;
1865 
1866         m_backtrackingState.link(this);
1867 
1868         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1869         m_backtrackingState.append(branchTest32(Zero, countRegister));
1870         sub32(TrustedImm32(1), countRegister);


1871         if (!m_decodeSurrogatePairs)
1872             sub32(TrustedImm32(1), index);


1873         else {

1874             const RegisterID character = regT0;
1875 
1876             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
<span class="line-removed">1877             // Rematch one less</span>
<span class="line-removed">1878             storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());</span>
1879 
1880             Label rematchLoop(this);


1881             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1882 
1883             sub32(TrustedImm32(1), countRegister);
1884             add32(TrustedImm32(1), index);
1885 
1886 #ifdef JIT_UNICODE_EXPRESSIONS
1887             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
1888             add32(TrustedImm32(1), index);
1889             isBMPChar.link(this);
1890 #endif
1891 
<span class="line-modified">1892             branchTest32(Zero, countRegister).linkTo(rematchLoop, this);</span>

1893 
1894             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1895         }
1896         jump(op.m_reentry);
1897     }
1898 
1899     void generateCharacterClassNonGreedy(size_t opIndex)
1900     {
1901         YarrOp&amp; op = m_ops[opIndex];
1902         PatternTerm* term = op.m_term;
1903 
1904         const RegisterID countRegister = regT1;
1905 
1906         move(TrustedImm32(0), countRegister);
1907         op.m_reentry = label();
<span class="line-modified">1908         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">1909             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());</span>






1910         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1911     }
1912 
1913     void backtrackCharacterClassNonGreedy(size_t opIndex)
1914     {
1915         YarrOp&amp; op = m_ops[opIndex];
1916         PatternTerm* term = op.m_term;
1917 
1918         const RegisterID character = regT0;
1919         const RegisterID countRegister = regT1;
1920 
1921         JumpList nonGreedyFailures;

1922 
1923         m_backtrackingState.link(this);
1924 
<span class="line-modified">1925         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">1926             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);</span>





1927         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1928 
1929         nonGreedyFailures.append(atEndOfInput());
1930         nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1931 
1932         JumpList matchDest;
1933         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">1934         // If we are matching the &quot;any character&quot; builtin class we only need to read the</span>
<span class="line-modified">1935         // character and don&#39;t need to match as it will always succeed.</span>
1936         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1937             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1938 
1939             if (term-&gt;invert())
1940                 nonGreedyFailures.append(matchDest);
1941             else {
1942                 nonGreedyFailures.append(jump());
1943                 matchDest.link(this);
1944             }
1945         }
1946 
<span class="line-removed">1947         add32(TrustedImm32(1), index);</span>
1948 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">1949         if (m_decodeSurrogatePairs) {</span>
<span class="line-modified">1950             nonGreedyFailures.append(atEndOfInput());</span>
<span class="line-modified">1951             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-removed">1952             add32(TrustedImm32(1), index);</span>
<span class="line-removed">1953             isBMPChar.link(this);</span>
<span class="line-removed">1954         }</span>
1955 #endif

1956         add32(TrustedImm32(1), countRegister);
1957 
1958         jump(op.m_reentry);
1959 




1960         nonGreedyFailures.link(this);
1961         sub32(countRegister, index);
1962         m_backtrackingState.fallthrough();
1963     }
1964 
1965     void generateDotStarEnclosure(size_t opIndex)
1966     {
1967         YarrOp&amp; op = m_ops[opIndex];
1968         PatternTerm* term = op.m_term;
1969 
1970         const RegisterID character = regT0;
1971         const RegisterID matchPos = regT1;
1972 #ifndef HAVE_INITIAL_START_REG
1973         const RegisterID initialStart = character;
1974 #endif
1975 
1976         JumpList foundBeginningNewLine;
1977         JumpList saveStartIndex;
1978         JumpList foundEndingNewLine;
1979 
</pre>
<hr />
<pre>
2444                 // offsets only afterwards, at the point the results array is
2445                 // being accessed.
2446                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2447                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2448                     if (term-&gt;quantityType == QuantifierFixedCount)
2449                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2450                     if (inputOffset) {
2451                         move(index, indexTemporary);
2452                         sub32(Imm32(inputOffset), indexTemporary);
2453                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2454                     } else
2455                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2456                 }
2457                 break;
2458             }
2459             case OpParenthesesSubpatternOnceEnd: {
2460                 PatternTerm* term = op.m_term;
2461                 const RegisterID indexTemporary = regT0;
2462                 ASSERT(term-&gt;quantityMaxCount == 1);
2463 
<span class="line-modified">2464                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2465                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2466                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">2467                     Jump pastBreakpoint;</span>
<span class="line-modified">2468                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">2469                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2470                     pastBreakpoint.link(this);</span>
<span class="line-removed">2471                 }</span>
2472 
2473                 // If the parenthese are capturing, store the ending index value to the
2474                 // captures array, offsetting as necessary.
2475                 //
2476                 // FIXME: could avoid offsetting this value in JIT code, apply
2477                 // offsets only afterwards, at the point the results array is
2478                 // being accessed.
2479                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2480                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2481                     if (inputOffset) {
2482                         move(index, indexTemporary);
2483                         sub32(Imm32(inputOffset), indexTemporary);
2484                         setSubpatternEnd(indexTemporary, term-&gt;parentheses.subpatternId);
2485                     } else
2486                         setSubpatternEnd(index, term-&gt;parentheses.subpatternId);
2487                 }
2488 
2489                 // If the parentheses are quantified Greedy then add a label to jump back
2490                 // to if we get a failed match from after the parentheses. For NonGreedy
2491                 // parentheses, link the jump from before the subpattern to here.
</pre>
<hr />
<pre>
2498                 break;
2499             }
2500 
2501             // OpParenthesesSubpatternTerminalBegin/End
2502             case OpParenthesesSubpatternTerminalBegin: {
2503                 PatternTerm* term = op.m_term;
2504                 ASSERT(term-&gt;quantityType == QuantifierGreedy);
2505                 ASSERT(term-&gt;quantityMaxCount == quantifyInfinite);
2506                 ASSERT(!term-&gt;capture());
2507 
2508                 // Upon entry set a label to loop back to.
2509                 op.m_reentry = label();
2510 
2511                 // Store the start index of the current match; we need to reject zero
2512                 // length matches.
2513                 storeToFrame(index, term-&gt;frameLocation + BackTrackInfoParenthesesTerminal::beginIndex());
2514                 break;
2515             }
2516             case OpParenthesesSubpatternTerminalEnd: {
2517                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
<span class="line-modified">2518                 if (!ASSERT_DISABLED) {</span>
<span class="line-modified">2519                     PatternTerm* term = op.m_term;</span>
<span class="line-modified">2520 </span>
<span class="line-modified">2521                     // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2522                     // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2523                     Jump pastBreakpoint;</span>
<span class="line-modified">2524                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*)));</span>
<span class="line-removed">2525                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2526                     pastBreakpoint.link(this);</span>
<span class="line-removed">2527                 }</span>
2528 
2529                 // We know that the match is non-zero, we can accept it and
2530                 // loop back up to the head of the subpattern.
2531                 jump(beginOp.m_reentry);
2532 
2533                 // This is the entry point to jump to when we stop matching - we will
2534                 // do so once the subpattern cannot match any more.
2535                 op.m_reentry = label();
2536                 break;
2537             }
2538 
2539             // OpParenthesesSubpatternBegin/End
2540             //
2541             // These nodes support generic subpatterns.
2542             case OpParenthesesSubpatternBegin: {
2543 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2544                 PatternTerm* term = op.m_term;
2545                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2546 
2547                 // Upon entry to a Greedy quantified set of parenthese store the index.
</pre>
<hr />
<pre>
2590                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2591                     if (term-&gt;quantityType == QuantifierFixedCount)
2592                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2593                     if (inputOffset) {
2594                         move(index, indexTemporary);
2595                         sub32(Imm32(inputOffset), indexTemporary);
2596                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2597                     } else
2598                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2599                 }
2600 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
2601                 RELEASE_ASSERT_NOT_REACHED();
2602 #endif
2603                 break;
2604             }
2605             case OpParenthesesSubpatternEnd: {
2606 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2607                 PatternTerm* term = op.m_term;
2608                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2609 
<span class="line-modified">2610                 // Runtime ASSERT to make sure that the nested alternative handled the</span>
<span class="line-modified">2611                 // &quot;no input consumed&quot; check.</span>
<span class="line-modified">2612                 if (!ASSERT_DISABLED &amp;&amp; term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize) {</span>
<span class="line-modified">2613                     Jump pastBreakpoint;</span>
<span class="line-modified">2614                     pastBreakpoint = branch32(NotEqual, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*)));</span>
<span class="line-removed">2615                     abortWithReason(YARRNoInputConsumed);</span>
<span class="line-removed">2616                     pastBreakpoint.link(this);</span>
<span class="line-removed">2617                 }</span>
2618 
2619                 const RegisterID countTemporary = regT1;
2620 
2621                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
2622                 loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
2623                 add32(TrustedImm32(1), countTemporary);
2624                 storeToFrame(countTemporary, parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
2625 
2626                 // If the parenthese are capturing, store the ending index value to the
2627                 // captures array, offsetting as necessary.
2628                 //
2629                 // FIXME: could avoid offsetting this value in JIT code, apply
2630                 // offsets only afterwards, at the point the results array is
2631                 // being accessed.
2632                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2633                     const RegisterID indexTemporary = regT0;
2634 
2635                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2636                     if (inputOffset) {
2637                         move(index, indexTemporary);
</pre>
<hr />
<pre>
3369     // ====================
3370 
3371     // opCompileParenthesesSubpattern
3372     // Emits ops for a subpattern (set of parentheses). These consist
3373     // of a set of alternatives wrapped in an outer set of nodes for
3374     // the parentheses.
3375     // Supported types of parentheses are &#39;Once&#39; (quantityMaxCount == 1),
3376     // &#39;Terminal&#39; (non-capturing parentheses quantified as greedy
3377     // and infinite), and 0 based greedy / non-greedy quantified parentheses.
3378     // Alternatives will use the &#39;Simple&#39; set of ops if either the
3379     // subpattern is terminal (in which case we will never need to
3380     // backtrack), or if the subpattern only contains one alternative.
3381     void opCompileParenthesesSubpattern(PatternTerm* term)
3382     {
3383         YarrOpCode parenthesesBeginOpCode;
3384         YarrOpCode parenthesesEndOpCode;
3385         YarrOpCode alternativeBeginOpCode = OpSimpleNestedAlternativeBegin;
3386         YarrOpCode alternativeNextOpCode = OpSimpleNestedAlternativeNext;
3387         YarrOpCode alternativeEndOpCode = OpSimpleNestedAlternativeEnd;
3388 





3389         // We can currently only compile quantity 1 subpatterns that are
3390         // not copies. We generate a copy in the case of a range quantifier,
3391         // e.g. /(?:x){3,9}/, or /(?:x)+/ (These are effectively expanded to
3392         // /(?:x){3,3}(?:x){0,6}/ and /(?:x)(?:x)*/ repectively). The problem
3393         // comes where the subpattern is capturing, in which case we would
3394         // need to restore the capture from the first subpattern upon a
3395         // failure in the second.
3396         if (term-&gt;quantityMinCount &amp;&amp; term-&gt;quantityMinCount != term-&gt;quantityMaxCount) {
3397             m_failureReason = JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum;
3398             return;
3399         }
3400 
3401         if (term-&gt;quantityMaxCount == 1 &amp;&amp; !term-&gt;parentheses.isCopy) {
3402             // Select the &#39;Once&#39; nodes.
3403             parenthesesBeginOpCode = OpParenthesesSubpatternOnceBegin;
3404             parenthesesEndOpCode = OpParenthesesSubpatternOnceEnd;
3405 
3406             // If there is more than one alternative we cannot use the &#39;simple&#39; nodes.
3407             if (term-&gt;parentheses.disjunction-&gt;m_alternatives.size() != 1) {
3408                 alternativeBeginOpCode = OpNestedAlternativeBegin;
</pre>
<hr />
<pre>
3475         m_ops.append(parenthesesEndOpCode);
3476 
3477         m_ops[parenBegin].m_term = term;
3478         m_ops[parenBegin].m_previousOp = notFound;
3479         m_ops[parenBegin].m_nextOp = parenEnd;
3480         m_ops[parenEnd].m_term = term;
3481         m_ops[parenEnd].m_previousOp = parenBegin;
3482         m_ops[parenEnd].m_nextOp = notFound;
3483     }
3484 
3485     // opCompileParentheticalAssertion
3486     // Emits ops for a parenthetical assertion. These consist of an
3487     // OpSimpleNestedAlternativeBegin/Next/End set of nodes wrapping
3488     // the alternatives, with these wrapped by an outer pair of
3489     // OpParentheticalAssertionBegin/End nodes.
3490     // We can always use the OpSimpleNestedAlternative nodes in the
3491     // case of parenthetical assertions since these only ever match
3492     // once, and will never backtrack back into the assertion.
3493     void opCompileParentheticalAssertion(PatternTerm* term)
3494     {





3495         size_t parenBegin = m_ops.size();
3496         m_ops.append(OpParentheticalAssertionBegin);
3497 
3498         m_ops.append(OpSimpleNestedAlternativeBegin);
3499         m_ops.last().m_previousOp = notFound;
3500         m_ops.last().m_term = term;
3501         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives =  term-&gt;parentheses.disjunction-&gt;m_alternatives;
3502         for (unsigned i = 0; i &lt; alternatives.size(); ++i) {
3503             size_t lastOpIndex = m_ops.size() - 1;
3504 
3505             PatternAlternative* nestedAlternative = alternatives[i].get();
3506             opCompileAlternative(nestedAlternative);
3507 
3508             size_t thisOpIndex = m_ops.size();
3509             m_ops.append(YarrOp(OpSimpleNestedAlternativeNext));
3510 
3511             YarrOp&amp; lastOp = m_ops[lastOpIndex];
3512             YarrOp&amp; thisOp = m_ops[thisOpIndex];
3513 
3514             lastOp.m_alternative = nestedAlternative;
</pre>
<hr />
<pre>
3555                 m_ops.append(term);
3556             }
3557         }
3558     }
3559 
3560     // opCompileBody
3561     // This method compiles the body disjunction of the regular expression.
3562     // The body consists of two sets of alternatives - zero or more &#39;once
3563     // through&#39; (BOL anchored) alternatives, followed by zero or more
3564     // repeated alternatives.
3565     // For each of these two sets of alteratives, if not empty they will be
3566     // wrapped in a set of OpBodyAlternativeBegin/Next/End nodes (with the
3567     // &#39;begin&#39; node referencing the first alternative, and &#39;next&#39; nodes
3568     // referencing any further alternatives. The begin/next/end nodes are
3569     // linked together in a doubly linked list. In the case of repeating
3570     // alternatives, the end node is also linked back to the beginning.
3571     // If no repeating alternatives exist, then a OpMatchFailed node exists
3572     // to return the failing result.
3573     void opCompileBody(PatternDisjunction* disjunction)
3574     {





3575         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = disjunction-&gt;m_alternatives;
3576         size_t currentAlternativeIndex = 0;
3577 
3578         // Emit the &#39;once through&#39; alternatives.
3579         if (alternatives.size() &amp;&amp; alternatives[0]-&gt;onceThrough()) {
3580             m_ops.append(YarrOp(OpBodyAlternativeBegin));
3581             m_ops.last().m_previousOp = notFound;
3582 
3583             do {
3584                 size_t lastOpIndex = m_ops.size() - 1;
3585                 PatternAlternative* alternative = alternatives[currentAlternativeIndex].get();
3586                 opCompileAlternative(alternative);
3587 
3588                 size_t thisOpIndex = m_ops.size();
3589                 m_ops.append(YarrOp(OpBodyAlternativeNext));
3590 
3591                 YarrOp&amp; lastOp = m_ops[lastOpIndex];
3592                 YarrOp&amp; thisOp = m_ops[thisOpIndex];
3593 
3594                 lastOp.m_alternative = alternative;
</pre>
<hr />
<pre>
3668             push(X86Registers::ebx);
3669 
3670 #if OS(WINDOWS)
3671         push(X86Registers::edi);
3672 #endif
3673 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3674         if (m_containsNestedSubpatterns) {
3675 #if OS(WINDOWS)
3676             push(X86Registers::esi);
3677 #endif
3678             push(X86Registers::r12);
3679         }
3680 #endif
3681 
3682         if (m_decodeSurrogatePairs) {
3683             push(X86Registers::r13);
3684             push(X86Registers::r14);
3685             push(X86Registers::r15);
3686 
3687             move(TrustedImm32(0xd800), leadingSurrogateTag);
<span class="line-removed">3688             move(TrustedImm32(0xdc00), trailingSurrogateTag);</span>
3689         }
3690         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3691         zeroExtend32ToPtr(index, index);
3692         zeroExtend32ToPtr(length, length);
3693 #if OS(WINDOWS)
3694         if (compileMode == IncludeSubpatterns)
3695             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
3696         // rcx is the pointer to the allocated space for result in x64 Windows.
3697         push(X86Registers::ecx);
3698 #endif
3699 #elif CPU(X86)
3700         push(X86Registers::ebp);
3701         move(stackPointerRegister, X86Registers::ebp);
3702         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
3703         push(X86Registers::ebx);
3704         push(X86Registers::edi);
3705         push(X86Registers::esi);
3706         // load output into edi (2 = saved ebp + return address).
3707     #if COMPILER(MSVC)
3708         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
3709         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
3710         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
3711         if (compileMode == IncludeSubpatterns)
3712             loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);
3713     #else
3714         if (compileMode == IncludeSubpatterns)
3715             loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
3716     #endif
3717 #elif CPU(ARM64)
3718         tagReturnAddress();
3719         if (m_decodeSurrogatePairs) {
3720             pushPair(framePointerRegister, linkRegister);
3721             move(TrustedImm32(0x10000), supplementaryPlanesBase);
<span class="line-removed">3722             move(TrustedImm32(0xfffffc00), surrogateTagMask);</span>
3723             move(TrustedImm32(0xd800), leadingSurrogateTag);
3724             move(TrustedImm32(0xdc00), trailingSurrogateTag);
3725         }
3726 
3727         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3728         zeroExtend32ToPtr(index, index);
3729         zeroExtend32ToPtr(length, length);
3730 #elif CPU(ARM_THUMB2)
3731         push(ARMRegisters::r4);
3732         push(ARMRegisters::r5);
3733         push(ARMRegisters::r6);
3734         push(ARMRegisters::r8);
3735 #elif CPU(MIPS)
3736         // Do nothing.
3737 #endif
3738 
3739         store8(TrustedImm32(1), &amp;m_vm-&gt;isExecutingInRegExpJIT);
3740     }
3741 
3742     void generateReturn()
</pre>
<hr />
<pre>
3783 #elif CPU(ARM_THUMB2)
3784         pop(ARMRegisters::r8);
3785         pop(ARMRegisters::r6);
3786         pop(ARMRegisters::r5);
3787         pop(ARMRegisters::r4);
3788 #elif CPU(MIPS)
3789         // Do nothing
3790 #endif
3791         ret();
3792     }
3793 
3794 public:
3795     YarrGenerator(VM* vm, YarrPattern&amp; pattern, String&amp; patternString, YarrCodeBlock&amp; codeBlock, YarrCharSize charSize)
3796         : m_vm(vm)
3797         , m_pattern(pattern)
3798         , m_patternString(patternString)
3799         , m_codeBlock(codeBlock)
3800         , m_charSize(charSize)
3801         , m_decodeSurrogatePairs(m_charSize == Char16 &amp;&amp; m_pattern.unicode())
3802         , m_unicodeIgnoreCase(m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())

3803         , m_canonicalMode(m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
3804 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3805         , m_containsNestedSubpatterns(false)
3806         , m_parenContextSizes(compileMode == IncludeSubpatterns ? m_pattern.m_numSubpatterns : 0, m_pattern.m_body-&gt;m_callFrameSize)
3807 #endif
3808     {
3809     }
3810 
3811     void compile()
3812     {
3813         YarrCodeBlock&amp; codeBlock = m_codeBlock;
3814 
3815 #ifndef JIT_UNICODE_EXPRESSIONS
3816         if (m_decodeSurrogatePairs) {
3817             codeBlock.setFallBackWithFailureReason(JITFailureReason::DecodeSurrogatePair);
3818             return;
3819         }
3820 #endif
3821 
3822         if (m_pattern.m_containsBackreferences
3823 #if ENABLE(YARR_JIT_BACKREFERENCES)
3824             &amp;&amp; (compileMode == MatchOnly || (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8))
3825 #endif
3826             ) {
3827                 codeBlock.setFallBackWithFailureReason(JITFailureReason::BackReference);
3828                 return;
3829         }
3830 
3831         // We need to compile before generating code since we set flags based on compilation that
3832         // are used during generation.
3833         opCompileBody(m_pattern.m_body);
3834 
3835         if (m_failureReason) {
3836             codeBlock.setFallBackWithFailureReason(*m_failureReason);
3837             return;
3838         }
3839 
3840         if (UNLIKELY(Options::dumpDisassembly() || Options::dumpRegExpDisassembly()))
<span class="line-modified">3841             m_disassembler = std::make_unique&lt;YarrDisassembler&gt;(this);</span>
3842 
3843         if (m_disassembler)
3844             m_disassembler-&gt;setStartOfCode(label());
3845 
3846 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3847         if (m_containsNestedSubpatterns)
3848             codeBlock.setUsesPatternContextBuffer();
3849 #endif
3850 
3851         generateEnter();
3852 
3853         Jump hasInput = checkInput();
3854         generateFailReturn();
3855         hasInput.link(this);
3856 





3857 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3858         if (m_containsNestedSubpatterns)
3859             move(TrustedImm32(matchLimit), remainingMatchCount);
3860 #endif
3861 
3862         if (compileMode == IncludeSubpatterns) {
3863             for (unsigned i = 0; i &lt; m_pattern.m_numSubpatterns + 1; ++i)
3864                 store32(TrustedImm32(-1), Address(output, (i &lt;&lt; 1) * sizeof(int)));
3865         }
3866 
3867         if (!m_pattern.m_body-&gt;m_hasFixedSize)
3868             setMatchStart(index);
3869 
3870         initCallFrame();
3871 
3872 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<span class="line-modified">3873         if (m_containsNestedSubpatterns)</span>
3874             initParenContextFreeList();





3875 #endif
3876 
3877         if (m_pattern.m_saveInitialStartValue) {
3878 #ifdef HAVE_INITIAL_START_REG
3879             move(index, initialStart);
3880 #else
3881             storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);
3882 #endif
3883         }
3884 
3885         generate();
3886         if (m_disassembler)
3887             m_disassembler-&gt;setEndOfGenerate(label());
3888         backtrack();
3889         if (m_disassembler)
3890             m_disassembler-&gt;setEndOfBacktrack(label());
3891 
3892         generateTryReadUnicodeCharacterHelper();
3893 
3894         generateJITFailReturn();
</pre>
<hr />
<pre>
4131         }
4132 
4133         return(0);
4134     }
4135 
4136 private:
4137     VM* m_vm;
4138 
4139     YarrPattern&amp; m_pattern;
4140     String&amp; m_patternString;
4141 
4142     YarrCodeBlock&amp; m_codeBlock;
4143     YarrCharSize m_charSize;
4144 
4145     // Used to detect regular expression constructs that are not currently
4146     // supported in the JIT; fall back to the interpreter when this is detected.
4147     Optional&lt;JITFailureReason&gt; m_failureReason;
4148 
4149     bool m_decodeSurrogatePairs;
4150     bool m_unicodeIgnoreCase;

4151     CanonicalMode m_canonicalMode;
4152 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
4153     bool m_containsNestedSubpatterns;
4154     ParenContextSizes m_parenContextSizes;
4155 #endif
4156     JumpList m_abortExecution;
4157     JumpList m_hitMatchLimit;
4158     Vector&lt;Call&gt; m_tryReadUnicodeCharacterCalls;
4159     Label m_tryReadUnicodeCharacterEntry;
4160 
4161     // The regular expression expressed as a linear sequence of operations.
4162     Vector&lt;YarrOp, 128&gt; m_ops;
4163 
4164     // This records the current input offset being applied due to the current
4165     // set of alternatives we are nested within. E.g. when matching the
4166     // character &#39;b&#39; within the regular expression /abc/, we will know that
4167     // the minimum size for the alternative is 3, checked upon entry to the
4168     // alternative, and that &#39;b&#39; is at offset 1 from the start, and as such
4169     // when matching &#39;b&#39; we need to apply an offset of -2 to the load.
4170     //
</pre>
<hr />
<pre>
4183 {
4184     switch (failure) {
4185     case JITFailureReason::DecodeSurrogatePair:
4186         dataLog(&quot;Can&#39;t JIT a pattern decoding surrogate pairs\n&quot;);
4187         break;
4188     case JITFailureReason::BackReference:
4189         dataLog(&quot;Can&#39;t JIT some patterns containing back references\n&quot;);
4190         break;
4191     case JITFailureReason::ForwardReference:
4192         dataLog(&quot;Can&#39;t JIT a pattern containing forward references\n&quot;);
4193         break;
4194     case JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum:
4195         dataLog(&quot;Can&#39;t JIT a pattern containing a variable counted parenthesis with a non-zero minimum\n&quot;);
4196         break;
4197     case JITFailureReason::ParenthesizedSubpattern:
4198         dataLog(&quot;Can&#39;t JIT a pattern containing parenthesized subpatterns\n&quot;);
4199         break;
4200     case JITFailureReason::FixedCountParenthesizedSubpattern:
4201         dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
4202         break;



4203     case JITFailureReason::ExecutableMemoryAllocationFailure:
4204         dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
4205         break;
4206     }
4207 }
4208 
4209 void jitCompile(YarrPattern&amp; pattern, String&amp; patternString, YarrCharSize charSize, VM* vm, YarrCodeBlock&amp; codeBlock, YarrJITCompileMode mode)
4210 {
4211     if (mode == MatchOnly)
4212         YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4213     else
4214         YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4215 
4216     if (auto failureReason = codeBlock.failureReason()) {
4217         if (Options::dumpCompiledRegExpPatterns()) {
4218             pattern.dumpPatternString(WTF::dataFile(), patternString);
4219             dataLog(&quot; : &quot;);
4220             dumpCompileFailure(*failureReason);
4221         }
4222     }
</pre>
</td>
<td>
<hr />
<pre>
  55     static const RegisterID returnRegister2 = ARMRegisters::r1;
  56 
  57 #define HAVE_INITIAL_START_REG
  58 #elif CPU(ARM64)
  59     // Argument registers
  60     static const RegisterID input = ARM64Registers::x0;
  61     static const RegisterID index = ARM64Registers::x1;
  62     static const RegisterID length = ARM64Registers::x2;
  63     static const RegisterID output = ARM64Registers::x3;
  64     static const RegisterID freelistRegister = ARM64Registers::x4;
  65     static const RegisterID freelistSizeRegister = ARM64Registers::x5;
  66 
  67     // Scratch registers
  68     static const RegisterID regT0 = ARM64Registers::x6;
  69     static const RegisterID regT1 = ARM64Registers::x7;
  70     static const RegisterID regT2 = ARM64Registers::x8;
  71     static const RegisterID remainingMatchCount = ARM64Registers::x9;
  72     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
  73     static const RegisterID initialStart = ARM64Registers::x11;
  74     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
<span class="line-modified">  75     static const RegisterID leadingSurrogateTag = ARM64Registers::x13;</span>
<span class="line-modified">  76     static const RegisterID trailingSurrogateTag = ARM64Registers::x14;</span>
<span class="line-modified">  77     static const RegisterID endOfStringAddress = ARM64Registers::x15;</span>
  78 
  79     static const RegisterID returnRegister = ARM64Registers::x0;
  80     static const RegisterID returnRegister2 = ARM64Registers::x1;
  81 
<span class="line-added">  82     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);</span>
  83 #define HAVE_INITIAL_START_REG
  84 #define JIT_UNICODE_EXPRESSIONS
  85 #elif CPU(MIPS)
  86     static const RegisterID input = MIPSRegisters::a0;
  87     static const RegisterID index = MIPSRegisters::a1;
  88     static const RegisterID length = MIPSRegisters::a2;
  89     static const RegisterID output = MIPSRegisters::a3;
  90 
  91     static const RegisterID regT0 = MIPSRegisters::t4;
  92     static const RegisterID regT1 = MIPSRegisters::t5;
  93     static const RegisterID initialStart = MIPSRegisters::t6;
  94 
  95     static const RegisterID returnRegister = MIPSRegisters::v0;
  96     static const RegisterID returnRegister2 = MIPSRegisters::v1;
  97 
  98 #define HAVE_INITIAL_START_REG
  99 #elif CPU(X86)
 100     static const RegisterID input = X86Registers::eax;
 101     static const RegisterID index = X86Registers::edx;
 102     static const RegisterID length = X86Registers::ecx;
</pre>
<hr />
<pre>
 127 #endif
 128 
 129     // Scratch registers
 130     static const RegisterID regT0 = X86Registers::eax;
 131 #if !OS(WINDOWS)
 132     static const RegisterID regT1 = X86Registers::r9;
 133     static const RegisterID regT2 = X86Registers::r10;
 134 #else
 135     static const RegisterID regT1 = X86Registers::ecx;
 136     static const RegisterID regT2 = X86Registers::edi;
 137 #endif
 138 
 139     static const RegisterID initialStart = X86Registers::ebx;
 140 #if !OS(WINDOWS)
 141     static const RegisterID remainingMatchCount = X86Registers::r12;
 142 #else
 143     static const RegisterID remainingMatchCount = X86Registers::esi;
 144 #endif
 145     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
 146     static const RegisterID leadingSurrogateTag = X86Registers::r14;
<span class="line-modified"> 147     static const RegisterID endOfStringAddress = X86Registers::r15;</span>
 148 
 149     static const RegisterID returnRegister = X86Registers::eax;
 150     static const RegisterID returnRegister2 = X86Registers::edx;
 151 
 152     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
<span class="line-added"> 153     const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);</span>
 154     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
 155 #define HAVE_INITIAL_START_REG
 156 #define JIT_UNICODE_EXPRESSIONS
 157 #endif
 158 
 159 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 160     struct ParenContextSizes {
 161         size_t m_numSubpatterns;
 162         size_t m_frameSlots;
 163 
 164         ParenContextSizes(size_t numSubpatterns, size_t frameSlots)
 165             : m_numSubpatterns(numSubpatterns)
 166             , m_frameSlots(frameSlots)
 167         {
 168         }
 169 
 170         size_t numSubpatterns() { return m_numSubpatterns; }
 171 
 172         size_t frameSlots() { return m_frameSlots; }
 173     };
</pre>
<hr />
<pre>
 211         static ptrdiff_t subpatternOffset(size_t subpattern)
 212         {
 213             return offsetof(ParenContext, subpatterns) + (subpattern - 1) * sizeof(Subpatterns);
 214         }
 215 
 216         static ptrdiff_t savedFrameOffset(ParenContextSizes&amp; parenContextSizes)
 217         {
 218             return offsetof(ParenContext, subpatterns) + (parenContextSizes.numSubpatterns()) * sizeof(Subpatterns);
 219         }
 220     };
 221 
 222     void initParenContextFreeList()
 223     {
 224         RegisterID parenContextPointer = regT0;
 225         RegisterID nextParenContextPointer = regT2;
 226 
 227         size_t parenContextSize = ParenContext::sizeFor(m_parenContextSizes);
 228 
 229         parenContextSize = WTF::roundUpToMultipleOf&lt;sizeof(uintptr_t)&gt;(parenContextSize);
 230 
<span class="line-modified"> 231         if (parenContextSize &gt; VM::patternContextBufferSize) {</span>
<span class="line-modified"> 232             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-modified"> 233             return;</span>
<span class="line-added"> 234         }</span>
 235 
 236         Jump emptyFreeList = branchTestPtr(Zero, freelistRegister);
 237         move(freelistRegister, parenContextPointer);
 238         addPtr(TrustedImm32(parenContextSize), freelistRegister, nextParenContextPointer);
 239         addPtr(freelistRegister, freelistSizeRegister);
 240         subPtr(TrustedImm32(parenContextSize), freelistSizeRegister);
 241 
 242         Label loopTop(this);
 243         Jump initDone = branchPtr(Above, nextParenContextPointer, freelistSizeRegister);
 244         storePtr(nextParenContextPointer, Address(parenContextPointer, ParenContext::nextOffset()));
 245         move(nextParenContextPointer, parenContextPointer);
 246         addPtr(TrustedImm32(parenContextSize), parenContextPointer, nextParenContextPointer);
 247         jump(loopTop);
 248 
 249         initDone.link(this);
 250         storePtr(TrustedImmPtr(nullptr), Address(parenContextPointer, ParenContext::nextOffset()));
 251         emptyFreeList.link(this);
 252     }
 253 
 254     void allocateParenContext(RegisterID result)
</pre>
<hr />
<pre>
 305         subpatternBaseFrameLocation += YarrStackSpaceForBackTrackInfoParentheses;
 306         for (unsigned frameLocation = subpatternBaseFrameLocation; frameLocation &lt; m_parenContextSizes.frameSlots(); frameLocation++) {
 307             loadPtr(Address(parenContextReg, ParenContext::savedFrameOffset(m_parenContextSizes) + frameLocation * sizeof(uintptr_t)), tempReg);
 308             storeToFrame(tempReg, frameLocation);
 309         }
 310     }
 311 #endif
 312 
 313     void optimizeAlternative(PatternAlternative* alternative)
 314     {
 315         if (!alternative-&gt;m_terms.size())
 316             return;
 317 
 318         for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size() - 1; ++i) {
 319             PatternTerm&amp; term = alternative-&gt;m_terms[i];
 320             PatternTerm&amp; nextTerm = alternative-&gt;m_terms[i + 1];
 321 
 322             // We can move BMP only character classes after fixed character terms.
 323             if ((term.type == PatternTerm::TypeCharacterClass)
 324                 &amp;&amp; (term.quantityType == QuantifierFixedCount)
<span class="line-modified"> 325                 &amp;&amp; (!m_decodeSurrogatePairs || (term.characterClass-&gt;hasOneCharacterSize() &amp;&amp; !term.m_invert))</span>
 326                 &amp;&amp; (nextTerm.type == PatternTerm::TypePatternCharacter)
 327                 &amp;&amp; (nextTerm.quantityType == QuantifierFixedCount)) {
 328                 PatternTerm termCopy = term;
 329                 alternative-&gt;m_terms[i] = nextTerm;
 330                 alternative-&gt;m_terms[i + 1] = termCopy;
 331             }
 332         }
 333     }
 334 
 335     void matchCharacterClassRange(RegisterID character, JumpList&amp; failures, JumpList&amp; matchDest, const CharacterRange* ranges, unsigned count, unsigned* matchIndex, const UChar32* matches, unsigned matchCount)
 336     {
 337         do {
 338             // pick which range we&#39;re going to generate
 339             int which = count &gt;&gt; 1;
 340             char lo = ranges[which].begin;
 341             char hi = ranges[which].end;
 342 
 343             // check if there are any ranges or matches below lo.  If not, just jl to failure -
 344             // if there is anything else to check, check that first, if it falls through jmp to failure.
 345             if ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt; lo)) {
</pre>
<hr />
<pre>
 369             while ((*matchIndex &lt; matchCount) &amp;&amp; (matches[*matchIndex] &lt;= hi))
 370                 ++*matchIndex;
 371 
 372             matchDest.append(branch32(LessThanOrEqual, character, Imm32((unsigned short)hi)));
 373             // fall through to here, the value is above hi.
 374 
 375             // shuffle along &amp; loop around if there are any more matches to handle.
 376             unsigned next = which + 1;
 377             ranges += next;
 378             count -= next;
 379         } while (count);
 380     }
 381 
 382     void matchCharacterClass(RegisterID character, JumpList&amp; matchDest, const CharacterClass* charClass)
 383     {
 384         if (charClass-&gt;m_table &amp;&amp; !m_decodeSurrogatePairs) {
 385             ExtendedAddress tableEntry(character, reinterpret_cast&lt;intptr_t&gt;(charClass-&gt;m_table));
 386             matchDest.append(branchTest8(charClass-&gt;m_tableInverted ? Zero : NonZero, tableEntry));
 387             return;
 388         }
<span class="line-added"> 389 </span>
 390         JumpList unicodeFail;
 391         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size()) {
 392             JumpList isAscii;
 393             if (charClass-&gt;m_matches.size() || charClass-&gt;m_ranges.size())
 394                 isAscii.append(branch32(LessThanOrEqual, character, TrustedImm32(0x7f)));
 395 
 396             if (charClass-&gt;m_matchesUnicode.size()) {
 397                 for (unsigned i = 0; i &lt; charClass-&gt;m_matchesUnicode.size(); ++i) {
 398                     UChar32 ch = charClass-&gt;m_matchesUnicode[i];
 399                     matchDest.append(branch32(Equal, character, Imm32(ch)));
 400                 }
 401             }
 402 
 403             if (charClass-&gt;m_rangesUnicode.size()) {
 404                 for (unsigned i = 0; i &lt; charClass-&gt;m_rangesUnicode.size(); ++i) {
 405                     UChar32 lo = charClass-&gt;m_rangesUnicode[i].begin;
 406                     UChar32 hi = charClass-&gt;m_rangesUnicode[i].end;
 407 
 408                     Jump below = branch32(LessThan, character, Imm32(lo));
 409                     matchDest.append(branch32(LessThanOrEqual, character, Imm32(hi)));
</pre>
<hr />
<pre>
 435                         matchesAZaz.append(ch);
 436                         continue;
 437                     }
 438                     if (isASCIIUpper(ch))
 439                         continue;
 440                 }
 441                 matchDest.append(branch32(Equal, character, Imm32((unsigned short)ch)));
 442             }
 443 
 444             if (unsigned countAZaz = matchesAZaz.size()) {
 445                 or32(TrustedImm32(32), character);
 446                 for (unsigned i = 0; i &lt; countAZaz; ++i)
 447                     matchDest.append(branch32(Equal, character, TrustedImm32(matchesAZaz[i])));
 448             }
 449         }
 450 
 451         if (charClass-&gt;m_matchesUnicode.size() || charClass-&gt;m_rangesUnicode.size())
 452             unicodeFail.link(this);
 453     }
 454 
<span class="line-added"> 455 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added"> 456     void advanceIndexAfterCharacterClassTermMatch(const PatternTerm* term, JumpList&amp; failuresAfterIncrementingIndex, const RegisterID character)</span>
<span class="line-added"> 457     {</span>
<span class="line-added"> 458         ASSERT(term-&gt;type == PatternTerm::TypeCharacterClass);</span>
<span class="line-added"> 459 </span>
<span class="line-added"> 460         if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-added"> 461             add32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), index);</span>
<span class="line-added"> 462         else {</span>
<span class="line-added"> 463             add32(TrustedImm32(1), index);</span>
<span class="line-added"> 464             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-added"> 465             failuresAfterIncrementingIndex.append(atEndOfInput());</span>
<span class="line-added"> 466             add32(TrustedImm32(1), index);</span>
<span class="line-added"> 467             isBMPChar.link(this);</span>
<span class="line-added"> 468         }</span>
<span class="line-added"> 469     }</span>
<span class="line-added"> 470 #endif</span>
<span class="line-added"> 471 </span>
 472     // Jumps if input not available; will have (incorrectly) incremented already!
 473     Jump jumpIfNoAvailableInput(unsigned countToCheck = 0)
 474     {
 475         if (countToCheck)
 476             add32(Imm32(countToCheck), index);
 477         return branch32(Above, index, length);
 478     }
 479 
 480     Jump jumpIfAvailableInput(unsigned countToCheck)
 481     {
 482         add32(Imm32(countToCheck), index);
 483         return branch32(BelowOrEqual, index, length);
 484     }
 485 
 486     Jump checkNotEnoughInput(RegisterID additionalAmount)
 487     {
 488         add32(index, additionalAmount);
 489         return branch32(Above, additionalAmount, length);
 490     }
 491 
</pre>
<hr />
<pre>
 524                 if (m_charSize != Char8)
 525                     subPtr(TrustedImm32(offsetAdjustAmount), base);
 526                 negativeCharacterOffset -= offsetAdjustAmount;
 527             }
 528         }
 529 
 530         Checked&lt;int32_t&gt; characterOffset(-static_cast&lt;int32_t&gt;(negativeCharacterOffset.unsafeGet()));
 531 
 532         if (m_charSize == Char8)
 533             return BaseIndex(input, indexReg, TimesOne, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(char))).unsafeGet());
 534 
 535         return BaseIndex(input, indexReg, TimesTwo, (characterOffset * static_cast&lt;int32_t&gt;(sizeof(UChar))).unsafeGet());
 536     }
 537 
 538 #ifdef JIT_UNICODE_EXPRESSIONS
 539     void tryReadUnicodeCharImpl(RegisterID resultReg)
 540     {
 541         ASSERT(m_charSize == Char16);
 542 
 543         JumpList notUnicode;
<span class="line-added"> 544 </span>
 545         load16Unaligned(regUnicodeInputAndTrail, resultReg);
 546         and32(surrogateTagMask, resultReg, regT2);
 547         notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
 548         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
<span class="line-modified"> 549         notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));</span>

 550         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
 551         and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
 552         notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
 553         sub32(leadingSurrogateTag, resultReg);
 554         sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
 555         lshift32(TrustedImm32(10), resultReg);
 556         or32(regUnicodeInputAndTrail, resultReg);
 557         add32(supplementaryPlanesBase, resultReg);
 558         notUnicode.link(this);
 559     }
 560 
 561     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
 562     {
 563         ASSERT(m_charSize == Char16);
 564 
 565         getEffectiveAddress(address, regUnicodeInputAndTrail);
 566 
 567         if (resultReg == regT0)
 568             m_tryReadUnicodeCharacterCalls.append(nearCall());
 569         else
</pre>
<hr />
<pre>
 622 
 623 #if CPU(ARM64) || CPU(X86_64)
 624     void storeToFrame(TrustedImmPtr imm, unsigned frameLocation)
 625     {
 626         poke(imm, frameLocation);
 627     }
 628 #endif
 629 
 630     DataLabelPtr storeToFrameWithPatch(unsigned frameLocation)
 631     {
 632         return storePtrWithPatch(TrustedImmPtr(nullptr), Address(stackPointerRegister, frameLocation * sizeof(void*)));
 633     }
 634 
 635     void loadFromFrame(unsigned frameLocation, RegisterID reg)
 636     {
 637         peek(reg, frameLocation);
 638     }
 639 
 640     void loadFromFrameAndJump(unsigned frameLocation)
 641     {
<span class="line-modified"> 642         farJump(Address(stackPointerRegister, frameLocation * sizeof(void*)), YarrBacktrackPtrTag);</span>
 643     }
 644 
 645     unsigned alignCallFrameSizeInBytes(unsigned callFrameSize)
 646     {
 647         if (!callFrameSize)
 648             return 0;
 649 
 650         callFrameSize *= sizeof(void*);
 651         if (callFrameSize / sizeof(void*) != m_pattern.m_body-&gt;m_callFrameSize)
 652             CRASH();
 653         callFrameSize = (callFrameSize + 0x3f) &amp; ~0x3f;
 654         return callFrameSize;
 655     }
 656     void initCallFrame()
 657     {
 658         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body-&gt;m_callFrameSize);
 659         if (callFrameSizeInBytes) {
 660 #if CPU(X86_64) || CPU(ARM64)
 661             if (Options::zeroStackFrame()) {
 662                 // We need to start from the stack pointer, because we could have spilled callee saves
</pre>
<hr />
<pre>
 754     //    vector, store the match start in the output vector.
 755     // 3) If we&#39;re compiling MatchOnly, &#39;output&#39; is unused, store the match start directly
 756     //    in this register.
 757     void setMatchStart(RegisterID reg)
 758     {
 759         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 760         if (compileMode == IncludeSubpatterns)
 761             store32(reg, output);
 762         else
 763             move(reg, output);
 764     }
 765     void getMatchStart(RegisterID reg)
 766     {
 767         ASSERT(!m_pattern.m_body-&gt;m_hasFixedSize);
 768         if (compileMode == IncludeSubpatterns)
 769             load32(output, reg);
 770         else
 771             move(output, reg);
 772     }
 773 
<span class="line-modified"> 774     enum YarrOpCode : uint8_t {</span>
 775         // These nodes wrap body alternatives - those in the main disjunction,
 776         // rather than subpatterns or assertions. These are chained together in
 777         // a doubly linked list, with a &#39;begin&#39; node for the first alternative,
 778         // a &#39;next&#39; node for each subsequent alternative, and an &#39;end&#39; node at
 779         // the end. In the case of repeating alternatives, the &#39;end&#39; node also
 780         // has a reference back to &#39;begin&#39;.
 781         OpBodyAlternativeBegin,
 782         OpBodyAlternativeNext,
 783         OpBodyAlternativeEnd,
 784         // Similar to the body alternatives, but used for subpatterns with two
 785         // or more alternatives.
 786         OpNestedAlternativeBegin,
 787         OpNestedAlternativeNext,
 788         OpNestedAlternativeEnd,
 789         // Used for alternatives in subpatterns where there is only a single
 790         // alternative (backtracking is easier in these cases), or for alternatives
 791         // which never need to be backtracked (those in parenthetical assertions,
 792         // terminal subpatterns).
 793         OpSimpleNestedAlternativeBegin,
 794         OpSimpleNestedAlternativeNext,
</pre>
<hr />
<pre>
 800         OpParenthesesSubpatternTerminalBegin,
 801         OpParenthesesSubpatternTerminalEnd,
 802         // Used to wrap generic captured matches
 803         OpParenthesesSubpatternBegin,
 804         OpParenthesesSubpatternEnd,
 805         // Used to wrap parenthetical assertions.
 806         OpParentheticalAssertionBegin,
 807         OpParentheticalAssertionEnd,
 808         // Wraps all simple terms (pattern characters, character classes).
 809         OpTerm,
 810         // Where an expression contains only &#39;once through&#39; body alternatives
 811         // and no repeating ones, this op is used to return match failure.
 812         OpMatchFailed
 813     };
 814 
 815     // This structure is used to hold the compiled opcode information,
 816     // including reference back to the original PatternTerm/PatternAlternatives,
 817     // and JIT compilation data structures.
 818     struct YarrOp {
 819         explicit YarrOp(PatternTerm* term)
<span class="line-modified"> 820             : m_term(term)</span>
<span class="line-modified"> 821             , m_op(OpTerm)</span>
 822             , m_isDeadCode(false)
 823         {
 824         }
 825 
 826         explicit YarrOp(YarrOpCode op)
 827             : m_op(op)
 828             , m_isDeadCode(false)
 829         {
 830         }
 831 




 832         // For alternatives, this holds the PatternAlternative and doubly linked
 833         // references to this alternative&#39;s siblings. In the case of the
 834         // OpBodyAlternativeEnd node at the end of a section of repeating nodes,
 835         // m_nextOp will reference the OpBodyAlternativeBegin node of the first
 836         // repeating alternative.
 837         PatternAlternative* m_alternative;
 838         size_t m_previousOp;
 839         size_t m_nextOp;
 840 
<span class="line-added"> 841         // The operation, as a YarrOpCode, and also a reference to the PatternTerm.</span>
<span class="line-added"> 842         PatternTerm* m_term;</span>
<span class="line-added"> 843         YarrOpCode m_op;</span>
<span class="line-added"> 844 </span>
 845         // Used to record a set of Jumps out of the generated code, typically
 846         // used for jumps out to backtracking code, and a single reentry back
 847         // into the code for a node (likely where a backtrack will trigger
 848         // rematching).
 849         Label m_reentry;
 850         JumpList m_jumps;
 851 
 852         // Used for backtracking when the prior alternative did not consume any
 853         // characters but matched.
 854         Jump m_zeroLengthMatch;
 855 
 856         // This flag is used to null out the second pattern character, when
 857         // two are fused to match a pair together.
 858         bool m_isDeadCode;
 859 
 860         // Currently used in the case of some of the more complex management of
 861         // &#39;m_checkedOffset&#39;, to cache the offset used in this alternative, to avoid
 862         // recalculating it.
 863         Checked&lt;unsigned&gt; m_checkAdjust;
 864 
</pre>
<hr />
<pre>
1356         failures.link(this);
1357         m_backtrackingState.fallthrough();
1358     }
1359 #endif
1360 
1361     void generatePatternCharacterOnce(size_t opIndex)
1362     {
1363         YarrOp&amp; op = m_ops[opIndex];
1364 
1365         if (op.m_isDeadCode)
1366             return;
1367 
1368         // m_ops always ends with a OpBodyAlternativeEnd or OpMatchFailed
1369         // node, so there must always be at least one more node.
1370         ASSERT(opIndex + 1 &lt; m_ops.size());
1371         YarrOp* nextOp = &amp;m_ops[opIndex + 1];
1372 
1373         PatternTerm* term = op.m_term;
1374         UChar32 ch = term-&gt;patternCharacter;
1375 
<span class="line-modified">1376         if (!isLatin1(ch) &amp;&amp; (m_charSize == Char8)) {</span>
1377             // Have a 16 bit pattern character and an 8 bit string - short circuit
1378             op.m_jumps.append(jump());
1379             return;
1380         }
1381 
1382         const RegisterID character = regT0;
1383 #if CPU(X86_64) || CPU(ARM64)
1384         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 8 : 4;
1385 #else
1386         unsigned maxCharactersAtOnce = m_charSize == Char8 ? 4 : 2;
1387 #endif
1388         uint64_t ignoreCaseMask = 0;
1389 #if CPU(BIG_ENDIAN)
1390         uint64_t allCharacters = ch &lt;&lt; (m_charSize == Char8 ? 24 : 16);
1391 #else
1392         uint64_t allCharacters = ch;
1393 #endif
1394         unsigned numberCharacters;
1395         unsigned startTermPosition = term-&gt;inputPosition;
1396 
</pre>
<hr />
<pre>
1411 
1412             // YarrJIT handles decoded surrogate pair as one character if unicode flag is enabled.
1413             // Note that the numberCharacters become 1 while the width of the pattern character becomes 32bit in this case.
1414             if (nextTerm-&gt;type != PatternTerm::TypePatternCharacter
1415                 || nextTerm-&gt;quantityType != QuantifierFixedCount
1416                 || nextTerm-&gt;quantityMaxCount != 1
1417                 || nextTerm-&gt;inputPosition != (startTermPosition + numberCharacters)
1418                 || (U16_LENGTH(nextTerm-&gt;patternCharacter) != 1 &amp;&amp; m_decodeSurrogatePairs))
1419                 break;
1420 
1421             nextOp-&gt;m_isDeadCode = true;
1422 
1423 #if CPU(BIG_ENDIAN)
1424             int shiftAmount = (m_charSize == Char8 ? 24 : 16) - ((m_charSize == Char8 ? 8 : 16) * numberCharacters);
1425 #else
1426             int shiftAmount = (m_charSize == Char8 ? 8 : 16) * numberCharacters;
1427 #endif
1428 
1429             UChar32 currentCharacter = nextTerm-&gt;patternCharacter;
1430 
<span class="line-modified">1431             if (!isLatin1(currentCharacter) &amp;&amp; (m_charSize == Char8)) {</span>
1432                 // Have a 16 bit pattern character and an 8 bit string - short circuit
1433                 op.m_jumps.append(jump());
1434                 return;
1435             }
1436 
1437             // For case-insesitive compares, non-ascii characters that have different
1438             // upper &amp; lower case representations are converted to a character class.
1439             ASSERT(!m_pattern.ignoreCase() || isASCIIAlpha(currentCharacter) || isCanonicallyUnique(currentCharacter, m_canonicalMode));
1440 
1441             allCharacters |= (static_cast&lt;uint64_t&gt;(currentCharacter) &lt;&lt; shiftAmount);
1442 
1443             if ((m_pattern.ignoreCase()) &amp;&amp; (isASCIIAlpha(currentCharacter)))
1444                 ignoreCaseMask |= 32ULL &lt;&lt; shiftAmount;
1445         }
1446 
1447         if (m_decodeSurrogatePairs)
1448             op.m_jumps.append(jumpIfNoAvailableInput());
1449 
1450         if (m_charSize == Char8) {
1451             auto check1 = [&amp;] (Checked&lt;unsigned&gt; offset, UChar32 characters) {
</pre>
<hr />
<pre>
1606             add32(TrustedImm32(1), countRegister);
1607         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1608     }
1609     void backtrackPatternCharacterFixed(size_t opIndex)
1610     {
1611         backtrackTermDefault(opIndex);
1612     }
1613 
1614     void generatePatternCharacterGreedy(size_t opIndex)
1615     {
1616         YarrOp&amp; op = m_ops[opIndex];
1617         PatternTerm* term = op.m_term;
1618         UChar32 ch = term-&gt;patternCharacter;
1619 
1620         const RegisterID character = regT0;
1621         const RegisterID countRegister = regT1;
1622 
1623         move(TrustedImm32(0), countRegister);
1624 
1625         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">1626         if (!(!isLatin1(ch) &amp;&amp; (m_charSize == Char8))) {</span>
1627             JumpList failures;
1628             Label loop(this);
1629             failures.append(atEndOfInput());
1630             failures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1631 
1632             add32(TrustedImm32(1), index);
1633 #ifdef JIT_UNICODE_EXPRESSIONS
1634             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1635                 Jump surrogatePairOk = notAtEndOfInput();
1636                 sub32(TrustedImm32(1), index);
1637                 failures.append(jump());
1638                 surrogatePairOk.link(this);
1639                 add32(TrustedImm32(1), index);
1640             }
1641 #endif
1642             add32(TrustedImm32(1), countRegister);
1643 
1644             if (term-&gt;quantityMaxCount == quantifyInfinite)
1645                 jump(loop);
1646             else
</pre>
<hr />
<pre>
1679         const RegisterID countRegister = regT1;
1680 
1681         move(TrustedImm32(0), countRegister);
1682         op.m_reentry = label();
1683         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex());
1684     }
1685     void backtrackPatternCharacterNonGreedy(size_t opIndex)
1686     {
1687         YarrOp&amp; op = m_ops[opIndex];
1688         PatternTerm* term = op.m_term;
1689         UChar32 ch = term-&gt;patternCharacter;
1690 
1691         const RegisterID character = regT0;
1692         const RegisterID countRegister = regT1;
1693 
1694         m_backtrackingState.link(this);
1695 
1696         loadFromFrame(term-&gt;frameLocation + BackTrackInfoPatternCharacter::matchAmountIndex(), countRegister);
1697 
1698         // Unless have a 16 bit pattern character and an 8 bit string - short circuit
<span class="line-modified">1699         if (!(!isLatin1(ch) &amp;&amp; (m_charSize == Char8))) {</span>
1700             JumpList nonGreedyFailures;
1701             nonGreedyFailures.append(atEndOfInput());
1702             if (term-&gt;quantityMaxCount != quantifyInfinite)
1703                 nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1704             nonGreedyFailures.append(jumpIfCharNotEquals(ch, m_checkedOffset - term-&gt;inputPosition, character));
1705 
1706             add32(TrustedImm32(1), index);
1707 #ifdef JIT_UNICODE_EXPRESSIONS
1708             if (m_decodeSurrogatePairs &amp;&amp; !U_IS_BMP(ch)) {
1709                 Jump surrogatePairOk = notAtEndOfInput();
1710                 sub32(TrustedImm32(1), index);
1711                 nonGreedyFailures.append(jump());
1712                 surrogatePairOk.link(this);
1713                 add32(TrustedImm32(1), index);
1714             }
1715 #endif
1716             add32(TrustedImm32(1), countRegister);
1717 
1718             jump(op.m_reentry);
1719             nonGreedyFailures.link(this);
</pre>
<hr />
<pre>
1738         if (m_decodeSurrogatePairs) {
1739             op.m_jumps.append(jumpIfNoAvailableInput());
1740             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1741         }
1742 
1743         JumpList matchDest;
1744         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1745         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1746         // character and don&#39;t need to match as it will always succeed.
1747         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1748             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1749 
1750             if (term-&gt;invert())
1751                 op.m_jumps.append(matchDest);
1752             else {
1753                 op.m_jumps.append(jump());
1754                 matchDest.link(this);
1755             }
1756         }
1757 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">1758         if (m_decodeSurrogatePairs &amp;&amp; (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())) {</span>
1759             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
<span class="line-added">1760             op.m_jumps.append(atEndOfInput());</span>
1761             add32(TrustedImm32(1), index);
1762             isBMPChar.link(this);
1763         }
1764 #endif
1765     }
1766     void backtrackCharacterClassOnce(size_t opIndex)
1767     {
1768 #ifdef JIT_UNICODE_EXPRESSIONS
1769         if (m_decodeSurrogatePairs) {
1770             YarrOp&amp; op = m_ops[opIndex];
1771             PatternTerm* term = op.m_term;
1772 
1773             m_backtrackingState.link(this);
1774             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);
1775             m_backtrackingState.fallthrough();
1776         }
1777 #endif
1778         backtrackTermDefault(opIndex);
1779     }
1780 
1781     void generateCharacterClassFixed(size_t opIndex)
1782     {
1783         YarrOp&amp; op = m_ops[opIndex];
1784         PatternTerm* term = op.m_term;
1785 
1786         const RegisterID character = regT0;
1787         const RegisterID countRegister = regT1;
1788 
1789         if (m_decodeSurrogatePairs)
1790             op.m_jumps.append(jumpIfNoAvailableInput());
1791 
1792         move(index, countRegister);
<span class="line-modified">1793 </span>
<span class="line-added">1794         Checked&lt;unsigned&gt; scaledMaxCount = term-&gt;quantityMaxCount;</span>
<span class="line-added">1795 </span>
<span class="line-added">1796 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">1797         if (m_decodeSurrogatePairs &amp;&amp; term-&gt;characterClass-&gt;hasOnlyNonBMPCharacters() &amp;&amp; !term-&gt;invert())</span>
<span class="line-added">1798             scaledMaxCount *= 2;</span>
<span class="line-added">1799 #endif</span>
<span class="line-added">1800         sub32(Imm32(scaledMaxCount.unsafeGet()), countRegister);</span>
1801 
1802         Label loop(this);
1803         JumpList matchDest;
<span class="line-modified">1804         readCharacter(m_checkedOffset - term-&gt;inputPosition - scaledMaxCount, character, countRegister);</span>
1805         // If we are matching the &quot;any character&quot; builtin class we only need to read the
1806         // character and don&#39;t need to match as it will always succeed.
1807         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1808             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1809 
1810             if (term-&gt;invert())
1811                 op.m_jumps.append(matchDest);
1812             else {
1813                 op.m_jumps.append(jump());
1814                 matchDest.link(this);
1815             }
1816         }
1817 

1818 #ifdef JIT_UNICODE_EXPRESSIONS
1819         if (m_decodeSurrogatePairs) {
<span class="line-modified">1820             if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-modified">1821                 add32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), countRegister);</span>
<span class="line-modified">1822             else {</span>
<span class="line-modified">1823                 add32(TrustedImm32(1), countRegister);</span>
<span class="line-modified">1824                 Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);</span>
<span class="line-modified">1825                 op.m_jumps.append(atEndOfInput());</span>
<span class="line-added">1826                 add32(TrustedImm32(1), countRegister);</span>
<span class="line-added">1827                 add32(TrustedImm32(1), index);</span>
<span class="line-added">1828                 isBMPChar.link(this);</span>
<span class="line-added">1829             }</span>
<span class="line-added">1830         } else</span>
1831 #endif
<span class="line-added">1832             add32(TrustedImm32(1), countRegister);</span>
1833         branch32(NotEqual, countRegister, index).linkTo(loop, this);
1834     }
1835     void backtrackCharacterClassFixed(size_t opIndex)
1836     {
1837         backtrackTermDefault(opIndex);
1838     }
1839 
1840     void generateCharacterClassGreedy(size_t opIndex)
1841     {
1842         YarrOp&amp; op = m_ops[opIndex];
1843         PatternTerm* term = op.m_term;
1844 
1845         const RegisterID character = regT0;
1846         const RegisterID countRegister = regT1;
1847 
<span class="line-modified">1848         if (m_decodeSurrogatePairs &amp;&amp; (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert()))</span>
1849             storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());
1850         move(TrustedImm32(0), countRegister);
1851 
1852         JumpList failures;
<span class="line-added">1853         JumpList failuresDecrementIndex;</span>
1854         Label loop(this);
<span class="line-modified">1855 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">1856         if (term-&gt;isFixedWidthCharacterClass() &amp;&amp; term-&gt;characterClass-&gt;hasNonBMPCharacters()) {</span>
<span class="line-added">1857             move(TrustedImm32(1), character);</span>
<span class="line-added">1858             failures.append(checkNotEnoughInput(character));</span>
<span class="line-added">1859         } else</span>
<span class="line-added">1860 #endif</span>
<span class="line-added">1861             failures.append(atEndOfInput());</span>
1862 
1863         if (term-&gt;invert()) {
1864             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1865             matchCharacterClass(character, failures, term-&gt;characterClass);
1866         } else {
1867             JumpList matchDest;
1868             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">1869             // If we are matching the &quot;any character&quot; builtin class for non-unicode patterns,</span>
<span class="line-modified">1870             // we only need to read the character and don&#39;t need to match as it will always succeed.</span>
1871             if (!term-&gt;characterClass-&gt;m_anyCharacter) {
1872                 matchCharacterClass(character, matchDest, term-&gt;characterClass);
1873                 failures.append(jump());
1874             }
1875             matchDest.link(this);
1876         }
1877 

1878 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">1879         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">1880             advanceIndexAfterCharacterClassTermMatch(term, failuresDecrementIndex, character);</span>
<span class="line-modified">1881         else</span>



1882 #endif
<span class="line-added">1883             add32(TrustedImm32(1), index);</span>
1884         add32(TrustedImm32(1), countRegister);
1885 
1886         if (term-&gt;quantityMaxCount != quantifyInfinite) {
1887             branch32(NotEqual, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())).linkTo(loop, this);
1888             failures.append(jump());
1889         } else
1890             jump(loop);
1891 
<span class="line-added">1892         if (!failuresDecrementIndex.empty()) {</span>
<span class="line-added">1893             failuresDecrementIndex.link(this);</span>
<span class="line-added">1894             sub32(TrustedImm32(1), index);</span>
<span class="line-added">1895         }</span>
<span class="line-added">1896 </span>
1897         failures.link(this);
1898         op.m_reentry = label();
1899 
1900         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1901     }
1902     void backtrackCharacterClassGreedy(size_t opIndex)
1903     {
1904         YarrOp&amp; op = m_ops[opIndex];
1905         PatternTerm* term = op.m_term;
1906 
1907         const RegisterID countRegister = regT1;
1908 
1909         m_backtrackingState.link(this);
1910 
1911         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1912         m_backtrackingState.append(branchTest32(Zero, countRegister));
1913         sub32(TrustedImm32(1), countRegister);
<span class="line-added">1914         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());</span>
<span class="line-added">1915 </span>
1916         if (!m_decodeSurrogatePairs)
1917             sub32(TrustedImm32(1), index);
<span class="line-added">1918         else if (term-&gt;isFixedWidthCharacterClass())</span>
<span class="line-added">1919             sub32(TrustedImm32(term-&gt;characterClass-&gt;hasNonBMPCharacters() ? 2 : 1), index);</span>
1920         else {
<span class="line-added">1921             // Rematch one less</span>
1922             const RegisterID character = regT0;
1923 
1924             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);


1925 
1926             Label rematchLoop(this);
<span class="line-added">1927             Jump doneRematching = branchTest32(Zero, countRegister);</span>
<span class="line-added">1928 </span>
1929             readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
1930 
1931             sub32(TrustedImm32(1), countRegister);
1932             add32(TrustedImm32(1), index);
1933 
1934 #ifdef JIT_UNICODE_EXPRESSIONS
1935             Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
1936             add32(TrustedImm32(1), index);
1937             isBMPChar.link(this);
1938 #endif
1939 
<span class="line-modified">1940             jump(rematchLoop);</span>
<span class="line-added">1941             doneRematching.link(this);</span>
1942 
1943             loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1944         }
1945         jump(op.m_reentry);
1946     }
1947 
1948     void generateCharacterClassNonGreedy(size_t opIndex)
1949     {
1950         YarrOp&amp; op = m_ops[opIndex];
1951         PatternTerm* term = op.m_term;
1952 
1953         const RegisterID countRegister = regT1;
1954 
1955         move(TrustedImm32(0), countRegister);
1956         op.m_reentry = label();
<span class="line-modified">1957 </span>
<span class="line-modified">1958 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">1959         if (m_decodeSurrogatePairs) {</span>
<span class="line-added">1960             if (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())</span>
<span class="line-added">1961                 storeToFrame(index, term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex());</span>
<span class="line-added">1962         }</span>
<span class="line-added">1963 #endif</span>
<span class="line-added">1964 </span>
1965         storeToFrame(countRegister, term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex());
1966     }
1967 
1968     void backtrackCharacterClassNonGreedy(size_t opIndex)
1969     {
1970         YarrOp&amp; op = m_ops[opIndex];
1971         PatternTerm* term = op.m_term;
1972 
1973         const RegisterID character = regT0;
1974         const RegisterID countRegister = regT1;
1975 
1976         JumpList nonGreedyFailures;
<span class="line-added">1977         JumpList nonGreedyFailuresDecrementIndex;</span>
1978 
1979         m_backtrackingState.link(this);
1980 
<span class="line-modified">1981 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-modified">1982         if (m_decodeSurrogatePairs) {</span>
<span class="line-added">1983             if (!term-&gt;characterClass-&gt;hasOneCharacterSize() || term-&gt;invert())</span>
<span class="line-added">1984                 loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::beginIndex(), index);</span>
<span class="line-added">1985         }</span>
<span class="line-added">1986 #endif</span>
<span class="line-added">1987 </span>
1988         loadFromFrame(term-&gt;frameLocation + BackTrackInfoCharacterClass::matchAmountIndex(), countRegister);
1989 
1990         nonGreedyFailures.append(atEndOfInput());
1991         nonGreedyFailures.append(branch32(Equal, countRegister, Imm32(term-&gt;quantityMaxCount.unsafeGet())));
1992 
1993         JumpList matchDest;
1994         readCharacter(m_checkedOffset - term-&gt;inputPosition, character);
<span class="line-modified">1995         // If we are matching the &quot;any character&quot; builtin class for non-unicode patterns,</span>
<span class="line-modified">1996         // we only need to read the character and don&#39;t need to match as it will always succeed.</span>
1997         if (term-&gt;invert() || !term-&gt;characterClass-&gt;m_anyCharacter) {
1998             matchCharacterClass(character, matchDest, term-&gt;characterClass);
1999 
2000             if (term-&gt;invert())
2001                 nonGreedyFailures.append(matchDest);
2002             else {
2003                 nonGreedyFailures.append(jump());
2004                 matchDest.link(this);
2005             }
2006         }
2007 

2008 #ifdef JIT_UNICODE_EXPRESSIONS
<span class="line-modified">2009         if (m_decodeSurrogatePairs)</span>
<span class="line-modified">2010             advanceIndexAfterCharacterClassTermMatch(term, nonGreedyFailuresDecrementIndex, character);</span>
<span class="line-modified">2011         else</span>



2012 #endif
<span class="line-added">2013             add32(TrustedImm32(1), index);</span>
2014         add32(TrustedImm32(1), countRegister);
2015 
2016         jump(op.m_reentry);
2017 
<span class="line-added">2018         if (!nonGreedyFailuresDecrementIndex.empty()) {</span>
<span class="line-added">2019             nonGreedyFailuresDecrementIndex.link(this);</span>
<span class="line-added">2020             breakpoint();</span>
<span class="line-added">2021         }</span>
2022         nonGreedyFailures.link(this);
2023         sub32(countRegister, index);
2024         m_backtrackingState.fallthrough();
2025     }
2026 
2027     void generateDotStarEnclosure(size_t opIndex)
2028     {
2029         YarrOp&amp; op = m_ops[opIndex];
2030         PatternTerm* term = op.m_term;
2031 
2032         const RegisterID character = regT0;
2033         const RegisterID matchPos = regT1;
2034 #ifndef HAVE_INITIAL_START_REG
2035         const RegisterID initialStart = character;
2036 #endif
2037 
2038         JumpList foundBeginningNewLine;
2039         JumpList saveStartIndex;
2040         JumpList foundEndingNewLine;
2041 
</pre>
<hr />
<pre>
2506                 // offsets only afterwards, at the point the results array is
2507                 // being accessed.
2508                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2509                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2510                     if (term-&gt;quantityType == QuantifierFixedCount)
2511                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2512                     if (inputOffset) {
2513                         move(index, indexTemporary);
2514                         sub32(Imm32(inputOffset), indexTemporary);
2515                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2516                     } else
2517                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2518                 }
2519                 break;
2520             }
2521             case OpParenthesesSubpatternOnceEnd: {
2522                 PatternTerm* term = op.m_term;
2523                 const RegisterID indexTemporary = regT0;
2524                 ASSERT(term-&gt;quantityMaxCount == 1);
2525 
<span class="line-modified">2526                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">2527                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">2528                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">2529                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">2530                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*))));</span>



2531 
2532                 // If the parenthese are capturing, store the ending index value to the
2533                 // captures array, offsetting as necessary.
2534                 //
2535                 // FIXME: could avoid offsetting this value in JIT code, apply
2536                 // offsets only afterwards, at the point the results array is
2537                 // being accessed.
2538                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2539                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2540                     if (inputOffset) {
2541                         move(index, indexTemporary);
2542                         sub32(Imm32(inputOffset), indexTemporary);
2543                         setSubpatternEnd(indexTemporary, term-&gt;parentheses.subpatternId);
2544                     } else
2545                         setSubpatternEnd(index, term-&gt;parentheses.subpatternId);
2546                 }
2547 
2548                 // If the parentheses are quantified Greedy then add a label to jump back
2549                 // to if we get a failed match from after the parentheses. For NonGreedy
2550                 // parentheses, link the jump from before the subpattern to here.
</pre>
<hr />
<pre>
2557                 break;
2558             }
2559 
2560             // OpParenthesesSubpatternTerminalBegin/End
2561             case OpParenthesesSubpatternTerminalBegin: {
2562                 PatternTerm* term = op.m_term;
2563                 ASSERT(term-&gt;quantityType == QuantifierGreedy);
2564                 ASSERT(term-&gt;quantityMaxCount == quantifyInfinite);
2565                 ASSERT(!term-&gt;capture());
2566 
2567                 // Upon entry set a label to loop back to.
2568                 op.m_reentry = label();
2569 
2570                 // Store the start index of the current match; we need to reject zero
2571                 // length matches.
2572                 storeToFrame(index, term-&gt;frameLocation + BackTrackInfoParenthesesTerminal::beginIndex());
2573                 break;
2574             }
2575             case OpParenthesesSubpatternTerminalEnd: {
2576                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
<span class="line-modified">2577                 PatternTerm* term = op.m_term;</span>
<span class="line-modified">2578 </span>
<span class="line-modified">2579                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">2580                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">2581                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">2582                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">2583                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, term-&gt;frameLocation * sizeof(void*))));</span>



2584 
2585                 // We know that the match is non-zero, we can accept it and
2586                 // loop back up to the head of the subpattern.
2587                 jump(beginOp.m_reentry);
2588 
2589                 // This is the entry point to jump to when we stop matching - we will
2590                 // do so once the subpattern cannot match any more.
2591                 op.m_reentry = label();
2592                 break;
2593             }
2594 
2595             // OpParenthesesSubpatternBegin/End
2596             //
2597             // These nodes support generic subpatterns.
2598             case OpParenthesesSubpatternBegin: {
2599 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2600                 PatternTerm* term = op.m_term;
2601                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2602 
2603                 // Upon entry to a Greedy quantified set of parenthese store the index.
</pre>
<hr />
<pre>
2646                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2647                     if (term-&gt;quantityType == QuantifierFixedCount)
2648                         inputOffset += term-&gt;parentheses.disjunction-&gt;m_minimumSize;
2649                     if (inputOffset) {
2650                         move(index, indexTemporary);
2651                         sub32(Imm32(inputOffset), indexTemporary);
2652                         setSubpatternStart(indexTemporary, term-&gt;parentheses.subpatternId);
2653                     } else
2654                         setSubpatternStart(index, term-&gt;parentheses.subpatternId);
2655                 }
2656 #else // !YARR_JIT_ALL_PARENS_EXPRESSIONS
2657                 RELEASE_ASSERT_NOT_REACHED();
2658 #endif
2659                 break;
2660             }
2661             case OpParenthesesSubpatternEnd: {
2662 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
2663                 PatternTerm* term = op.m_term;
2664                 unsigned parenthesesFrameLocation = term-&gt;frameLocation;
2665 
<span class="line-modified">2666                 // If the nested alternative matched without consuming any characters, punt this back to the interpreter.</span>
<span class="line-modified">2667                 // FIXME: &lt;https://bugs.webkit.org/show_bug.cgi?id=200786&gt; Add ability for the YARR JIT to properly</span>
<span class="line-modified">2668                 // handle nested expressions that can match without consuming characters</span>
<span class="line-modified">2669                 if (term-&gt;quantityType != QuantifierFixedCount &amp;&amp; !term-&gt;parentheses.disjunction-&gt;m_minimumSize)</span>
<span class="line-modified">2670                     m_abortExecution.append(branch32(Equal, index, Address(stackPointerRegister, parenthesesFrameLocation * sizeof(void*))));</span>



2671 
2672                 const RegisterID countTemporary = regT1;
2673 
2674                 YarrOp&amp; beginOp = m_ops[op.m_previousOp];
2675                 loadFromFrame(parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex(), countTemporary);
2676                 add32(TrustedImm32(1), countTemporary);
2677                 storeToFrame(countTemporary, parenthesesFrameLocation + BackTrackInfoParentheses::matchAmountIndex());
2678 
2679                 // If the parenthese are capturing, store the ending index value to the
2680                 // captures array, offsetting as necessary.
2681                 //
2682                 // FIXME: could avoid offsetting this value in JIT code, apply
2683                 // offsets only afterwards, at the point the results array is
2684                 // being accessed.
2685                 if (term-&gt;capture() &amp;&amp; compileMode == IncludeSubpatterns) {
2686                     const RegisterID indexTemporary = regT0;
2687 
2688                     unsigned inputOffset = (m_checkedOffset - term-&gt;inputPosition).unsafeGet();
2689                     if (inputOffset) {
2690                         move(index, indexTemporary);
</pre>
<hr />
<pre>
3422     // ====================
3423 
3424     // opCompileParenthesesSubpattern
3425     // Emits ops for a subpattern (set of parentheses). These consist
3426     // of a set of alternatives wrapped in an outer set of nodes for
3427     // the parentheses.
3428     // Supported types of parentheses are &#39;Once&#39; (quantityMaxCount == 1),
3429     // &#39;Terminal&#39; (non-capturing parentheses quantified as greedy
3430     // and infinite), and 0 based greedy / non-greedy quantified parentheses.
3431     // Alternatives will use the &#39;Simple&#39; set of ops if either the
3432     // subpattern is terminal (in which case we will never need to
3433     // backtrack), or if the subpattern only contains one alternative.
3434     void opCompileParenthesesSubpattern(PatternTerm* term)
3435     {
3436         YarrOpCode parenthesesBeginOpCode;
3437         YarrOpCode parenthesesEndOpCode;
3438         YarrOpCode alternativeBeginOpCode = OpSimpleNestedAlternativeBegin;
3439         YarrOpCode alternativeNextOpCode = OpSimpleNestedAlternativeNext;
3440         YarrOpCode alternativeEndOpCode = OpSimpleNestedAlternativeEnd;
3441 
<span class="line-added">3442         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">3443             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">3444             return;</span>
<span class="line-added">3445         }</span>
<span class="line-added">3446 </span>
3447         // We can currently only compile quantity 1 subpatterns that are
3448         // not copies. We generate a copy in the case of a range quantifier,
3449         // e.g. /(?:x){3,9}/, or /(?:x)+/ (These are effectively expanded to
3450         // /(?:x){3,3}(?:x){0,6}/ and /(?:x)(?:x)*/ repectively). The problem
3451         // comes where the subpattern is capturing, in which case we would
3452         // need to restore the capture from the first subpattern upon a
3453         // failure in the second.
3454         if (term-&gt;quantityMinCount &amp;&amp; term-&gt;quantityMinCount != term-&gt;quantityMaxCount) {
3455             m_failureReason = JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum;
3456             return;
3457         }
3458 
3459         if (term-&gt;quantityMaxCount == 1 &amp;&amp; !term-&gt;parentheses.isCopy) {
3460             // Select the &#39;Once&#39; nodes.
3461             parenthesesBeginOpCode = OpParenthesesSubpatternOnceBegin;
3462             parenthesesEndOpCode = OpParenthesesSubpatternOnceEnd;
3463 
3464             // If there is more than one alternative we cannot use the &#39;simple&#39; nodes.
3465             if (term-&gt;parentheses.disjunction-&gt;m_alternatives.size() != 1) {
3466                 alternativeBeginOpCode = OpNestedAlternativeBegin;
</pre>
<hr />
<pre>
3533         m_ops.append(parenthesesEndOpCode);
3534 
3535         m_ops[parenBegin].m_term = term;
3536         m_ops[parenBegin].m_previousOp = notFound;
3537         m_ops[parenBegin].m_nextOp = parenEnd;
3538         m_ops[parenEnd].m_term = term;
3539         m_ops[parenEnd].m_previousOp = parenBegin;
3540         m_ops[parenEnd].m_nextOp = notFound;
3541     }
3542 
3543     // opCompileParentheticalAssertion
3544     // Emits ops for a parenthetical assertion. These consist of an
3545     // OpSimpleNestedAlternativeBegin/Next/End set of nodes wrapping
3546     // the alternatives, with these wrapped by an outer pair of
3547     // OpParentheticalAssertionBegin/End nodes.
3548     // We can always use the OpSimpleNestedAlternative nodes in the
3549     // case of parenthetical assertions since these only ever match
3550     // once, and will never backtrack back into the assertion.
3551     void opCompileParentheticalAssertion(PatternTerm* term)
3552     {
<span class="line-added">3553         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">3554             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">3555             return;</span>
<span class="line-added">3556         }</span>
<span class="line-added">3557 </span>
3558         size_t parenBegin = m_ops.size();
3559         m_ops.append(OpParentheticalAssertionBegin);
3560 
3561         m_ops.append(OpSimpleNestedAlternativeBegin);
3562         m_ops.last().m_previousOp = notFound;
3563         m_ops.last().m_term = term;
3564         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives =  term-&gt;parentheses.disjunction-&gt;m_alternatives;
3565         for (unsigned i = 0; i &lt; alternatives.size(); ++i) {
3566             size_t lastOpIndex = m_ops.size() - 1;
3567 
3568             PatternAlternative* nestedAlternative = alternatives[i].get();
3569             opCompileAlternative(nestedAlternative);
3570 
3571             size_t thisOpIndex = m_ops.size();
3572             m_ops.append(YarrOp(OpSimpleNestedAlternativeNext));
3573 
3574             YarrOp&amp; lastOp = m_ops[lastOpIndex];
3575             YarrOp&amp; thisOp = m_ops[thisOpIndex];
3576 
3577             lastOp.m_alternative = nestedAlternative;
</pre>
<hr />
<pre>
3618                 m_ops.append(term);
3619             }
3620         }
3621     }
3622 
3623     // opCompileBody
3624     // This method compiles the body disjunction of the regular expression.
3625     // The body consists of two sets of alternatives - zero or more &#39;once
3626     // through&#39; (BOL anchored) alternatives, followed by zero or more
3627     // repeated alternatives.
3628     // For each of these two sets of alteratives, if not empty they will be
3629     // wrapped in a set of OpBodyAlternativeBegin/Next/End nodes (with the
3630     // &#39;begin&#39; node referencing the first alternative, and &#39;next&#39; nodes
3631     // referencing any further alternatives. The begin/next/end nodes are
3632     // linked together in a doubly linked list. In the case of repeating
3633     // alternatives, the end node is also linked back to the beginning.
3634     // If no repeating alternatives exist, then a OpMatchFailed node exists
3635     // to return the failing result.
3636     void opCompileBody(PatternDisjunction* disjunction)
3637     {
<span class="line-added">3638         if (UNLIKELY(!m_vm-&gt;isSafeToRecurse())) {</span>
<span class="line-added">3639             m_failureReason = JITFailureReason::ParenthesisNestedTooDeep;</span>
<span class="line-added">3640             return;</span>
<span class="line-added">3641         }</span>
<span class="line-added">3642 </span>
3643         Vector&lt;std::unique_ptr&lt;PatternAlternative&gt;&gt;&amp; alternatives = disjunction-&gt;m_alternatives;
3644         size_t currentAlternativeIndex = 0;
3645 
3646         // Emit the &#39;once through&#39; alternatives.
3647         if (alternatives.size() &amp;&amp; alternatives[0]-&gt;onceThrough()) {
3648             m_ops.append(YarrOp(OpBodyAlternativeBegin));
3649             m_ops.last().m_previousOp = notFound;
3650 
3651             do {
3652                 size_t lastOpIndex = m_ops.size() - 1;
3653                 PatternAlternative* alternative = alternatives[currentAlternativeIndex].get();
3654                 opCompileAlternative(alternative);
3655 
3656                 size_t thisOpIndex = m_ops.size();
3657                 m_ops.append(YarrOp(OpBodyAlternativeNext));
3658 
3659                 YarrOp&amp; lastOp = m_ops[lastOpIndex];
3660                 YarrOp&amp; thisOp = m_ops[thisOpIndex];
3661 
3662                 lastOp.m_alternative = alternative;
</pre>
<hr />
<pre>
3736             push(X86Registers::ebx);
3737 
3738 #if OS(WINDOWS)
3739         push(X86Registers::edi);
3740 #endif
3741 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3742         if (m_containsNestedSubpatterns) {
3743 #if OS(WINDOWS)
3744             push(X86Registers::esi);
3745 #endif
3746             push(X86Registers::r12);
3747         }
3748 #endif
3749 
3750         if (m_decodeSurrogatePairs) {
3751             push(X86Registers::r13);
3752             push(X86Registers::r14);
3753             push(X86Registers::r15);
3754 
3755             move(TrustedImm32(0xd800), leadingSurrogateTag);

3756         }
3757         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3758         zeroExtend32ToPtr(index, index);
3759         zeroExtend32ToPtr(length, length);
3760 #if OS(WINDOWS)
3761         if (compileMode == IncludeSubpatterns)
3762             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
3763         // rcx is the pointer to the allocated space for result in x64 Windows.
3764         push(X86Registers::ecx);
3765 #endif
3766 #elif CPU(X86)
3767         push(X86Registers::ebp);
3768         move(stackPointerRegister, X86Registers::ebp);
3769         // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
3770         push(X86Registers::ebx);
3771         push(X86Registers::edi);
3772         push(X86Registers::esi);
3773         // load output into edi (2 = saved ebp + return address).
3774     #if COMPILER(MSVC)
3775         loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
3776         loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
3777         loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
3778         if (compileMode == IncludeSubpatterns)
3779             loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);
3780     #else
3781         if (compileMode == IncludeSubpatterns)
3782             loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
3783     #endif
3784 #elif CPU(ARM64)
3785         tagReturnAddress();
3786         if (m_decodeSurrogatePairs) {
3787             pushPair(framePointerRegister, linkRegister);
3788             move(TrustedImm32(0x10000), supplementaryPlanesBase);

3789             move(TrustedImm32(0xd800), leadingSurrogateTag);
3790             move(TrustedImm32(0xdc00), trailingSurrogateTag);
3791         }
3792 
3793         // The ABI doesn&#39;t guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
3794         zeroExtend32ToPtr(index, index);
3795         zeroExtend32ToPtr(length, length);
3796 #elif CPU(ARM_THUMB2)
3797         push(ARMRegisters::r4);
3798         push(ARMRegisters::r5);
3799         push(ARMRegisters::r6);
3800         push(ARMRegisters::r8);
3801 #elif CPU(MIPS)
3802         // Do nothing.
3803 #endif
3804 
3805         store8(TrustedImm32(1), &amp;m_vm-&gt;isExecutingInRegExpJIT);
3806     }
3807 
3808     void generateReturn()
</pre>
<hr />
<pre>
3849 #elif CPU(ARM_THUMB2)
3850         pop(ARMRegisters::r8);
3851         pop(ARMRegisters::r6);
3852         pop(ARMRegisters::r5);
3853         pop(ARMRegisters::r4);
3854 #elif CPU(MIPS)
3855         // Do nothing
3856 #endif
3857         ret();
3858     }
3859 
3860 public:
3861     YarrGenerator(VM* vm, YarrPattern&amp; pattern, String&amp; patternString, YarrCodeBlock&amp; codeBlock, YarrCharSize charSize)
3862         : m_vm(vm)
3863         , m_pattern(pattern)
3864         , m_patternString(patternString)
3865         , m_codeBlock(codeBlock)
3866         , m_charSize(charSize)
3867         , m_decodeSurrogatePairs(m_charSize == Char16 &amp;&amp; m_pattern.unicode())
3868         , m_unicodeIgnoreCase(m_pattern.unicode() &amp;&amp; m_pattern.ignoreCase())
<span class="line-added">3869         , m_fixedSizedAlternative(false)</span>
3870         , m_canonicalMode(m_pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
3871 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3872         , m_containsNestedSubpatterns(false)
3873         , m_parenContextSizes(compileMode == IncludeSubpatterns ? m_pattern.m_numSubpatterns : 0, m_pattern.m_body-&gt;m_callFrameSize)
3874 #endif
3875     {
3876     }
3877 
3878     void compile()
3879     {
3880         YarrCodeBlock&amp; codeBlock = m_codeBlock;
3881 
3882 #ifndef JIT_UNICODE_EXPRESSIONS
3883         if (m_decodeSurrogatePairs) {
3884             codeBlock.setFallBackWithFailureReason(JITFailureReason::DecodeSurrogatePair);
3885             return;
3886         }
3887 #endif
3888 
3889         if (m_pattern.m_containsBackreferences
3890 #if ENABLE(YARR_JIT_BACKREFERENCES)
3891             &amp;&amp; (compileMode == MatchOnly || (m_pattern.ignoreCase() &amp;&amp; m_charSize != Char8))
3892 #endif
3893             ) {
3894                 codeBlock.setFallBackWithFailureReason(JITFailureReason::BackReference);
3895                 return;
3896         }
3897 
3898         // We need to compile before generating code since we set flags based on compilation that
3899         // are used during generation.
3900         opCompileBody(m_pattern.m_body);
3901 
3902         if (m_failureReason) {
3903             codeBlock.setFallBackWithFailureReason(*m_failureReason);
3904             return;
3905         }
3906 
3907         if (UNLIKELY(Options::dumpDisassembly() || Options::dumpRegExpDisassembly()))
<span class="line-modified">3908             m_disassembler = makeUnique&lt;YarrDisassembler&gt;(this);</span>
3909 
3910         if (m_disassembler)
3911             m_disassembler-&gt;setStartOfCode(label());
3912 
3913 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3914         if (m_containsNestedSubpatterns)
3915             codeBlock.setUsesPatternContextBuffer();
3916 #endif
3917 
3918         generateEnter();
3919 
3920         Jump hasInput = checkInput();
3921         generateFailReturn();
3922         hasInput.link(this);
3923 
<span class="line-added">3924 #ifdef JIT_UNICODE_EXPRESSIONS</span>
<span class="line-added">3925         if (m_decodeSurrogatePairs)</span>
<span class="line-added">3926             getEffectiveAddress(BaseIndex(input, length, TimesTwo), endOfStringAddress);</span>
<span class="line-added">3927 #endif</span>
<span class="line-added">3928 </span>
3929 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
3930         if (m_containsNestedSubpatterns)
3931             move(TrustedImm32(matchLimit), remainingMatchCount);
3932 #endif
3933 
3934         if (compileMode == IncludeSubpatterns) {
3935             for (unsigned i = 0; i &lt; m_pattern.m_numSubpatterns + 1; ++i)
3936                 store32(TrustedImm32(-1), Address(output, (i &lt;&lt; 1) * sizeof(int)));
3937         }
3938 
3939         if (!m_pattern.m_body-&gt;m_hasFixedSize)
3940             setMatchStart(index);
3941 
3942         initCallFrame();
3943 
3944 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
<span class="line-modified">3945         if (m_containsNestedSubpatterns) {</span>
3946             initParenContextFreeList();
<span class="line-added">3947             if (m_failureReason) {</span>
<span class="line-added">3948                 codeBlock.setFallBackWithFailureReason(*m_failureReason);</span>
<span class="line-added">3949                 return;</span>
<span class="line-added">3950             }</span>
<span class="line-added">3951         }</span>
3952 #endif
3953 
3954         if (m_pattern.m_saveInitialStartValue) {
3955 #ifdef HAVE_INITIAL_START_REG
3956             move(index, initialStart);
3957 #else
3958             storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);
3959 #endif
3960         }
3961 
3962         generate();
3963         if (m_disassembler)
3964             m_disassembler-&gt;setEndOfGenerate(label());
3965         backtrack();
3966         if (m_disassembler)
3967             m_disassembler-&gt;setEndOfBacktrack(label());
3968 
3969         generateTryReadUnicodeCharacterHelper();
3970 
3971         generateJITFailReturn();
</pre>
<hr />
<pre>
4208         }
4209 
4210         return(0);
4211     }
4212 
4213 private:
4214     VM* m_vm;
4215 
4216     YarrPattern&amp; m_pattern;
4217     String&amp; m_patternString;
4218 
4219     YarrCodeBlock&amp; m_codeBlock;
4220     YarrCharSize m_charSize;
4221 
4222     // Used to detect regular expression constructs that are not currently
4223     // supported in the JIT; fall back to the interpreter when this is detected.
4224     Optional&lt;JITFailureReason&gt; m_failureReason;
4225 
4226     bool m_decodeSurrogatePairs;
4227     bool m_unicodeIgnoreCase;
<span class="line-added">4228     bool m_fixedSizedAlternative;</span>
4229     CanonicalMode m_canonicalMode;
4230 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
4231     bool m_containsNestedSubpatterns;
4232     ParenContextSizes m_parenContextSizes;
4233 #endif
4234     JumpList m_abortExecution;
4235     JumpList m_hitMatchLimit;
4236     Vector&lt;Call&gt; m_tryReadUnicodeCharacterCalls;
4237     Label m_tryReadUnicodeCharacterEntry;
4238 
4239     // The regular expression expressed as a linear sequence of operations.
4240     Vector&lt;YarrOp, 128&gt; m_ops;
4241 
4242     // This records the current input offset being applied due to the current
4243     // set of alternatives we are nested within. E.g. when matching the
4244     // character &#39;b&#39; within the regular expression /abc/, we will know that
4245     // the minimum size for the alternative is 3, checked upon entry to the
4246     // alternative, and that &#39;b&#39; is at offset 1 from the start, and as such
4247     // when matching &#39;b&#39; we need to apply an offset of -2 to the load.
4248     //
</pre>
<hr />
<pre>
4261 {
4262     switch (failure) {
4263     case JITFailureReason::DecodeSurrogatePair:
4264         dataLog(&quot;Can&#39;t JIT a pattern decoding surrogate pairs\n&quot;);
4265         break;
4266     case JITFailureReason::BackReference:
4267         dataLog(&quot;Can&#39;t JIT some patterns containing back references\n&quot;);
4268         break;
4269     case JITFailureReason::ForwardReference:
4270         dataLog(&quot;Can&#39;t JIT a pattern containing forward references\n&quot;);
4271         break;
4272     case JITFailureReason::VariableCountedParenthesisWithNonZeroMinimum:
4273         dataLog(&quot;Can&#39;t JIT a pattern containing a variable counted parenthesis with a non-zero minimum\n&quot;);
4274         break;
4275     case JITFailureReason::ParenthesizedSubpattern:
4276         dataLog(&quot;Can&#39;t JIT a pattern containing parenthesized subpatterns\n&quot;);
4277         break;
4278     case JITFailureReason::FixedCountParenthesizedSubpattern:
4279         dataLog(&quot;Can&#39;t JIT a pattern containing fixed count parenthesized subpatterns\n&quot;);
4280         break;
<span class="line-added">4281     case JITFailureReason::ParenthesisNestedTooDeep:</span>
<span class="line-added">4282         dataLog(&quot;Can&#39;t JIT pattern due to parentheses nested too deeply\n&quot;);</span>
<span class="line-added">4283         break;</span>
4284     case JITFailureReason::ExecutableMemoryAllocationFailure:
4285         dataLog(&quot;Can&#39;t JIT because of failure of allocation of executable memory\n&quot;);
4286         break;
4287     }
4288 }
4289 
4290 void jitCompile(YarrPattern&amp; pattern, String&amp; patternString, YarrCharSize charSize, VM* vm, YarrCodeBlock&amp; codeBlock, YarrJITCompileMode mode)
4291 {
4292     if (mode == MatchOnly)
4293         YarrGenerator&lt;MatchOnly&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4294     else
4295         YarrGenerator&lt;IncludeSubpatterns&gt;(vm, pattern, patternString, codeBlock, charSize).compile();
4296 
4297     if (auto failureReason = codeBlock.failureReason()) {
4298         if (Options::dumpCompiledRegExpPatterns()) {
4299             pattern.dumpPatternString(WTF::dataFile(), patternString);
4300             dataLog(&quot; : &quot;);
4301             dumpCompileFailure(*failureReason);
4302         }
4303     }
</pre>
</td>
</tr>
</table>
<center><a href="YarrInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>