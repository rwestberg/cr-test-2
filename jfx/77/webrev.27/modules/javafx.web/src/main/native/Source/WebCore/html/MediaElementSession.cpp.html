<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaElementSession.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;DocumentLoader.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;FullscreenManager.h&quot;
 37 #include &quot;HTMLAudioElement.h&quot;
 38 #include &quot;HTMLMediaElement.h&quot;
 39 #include &quot;HTMLNames.h&quot;
 40 #include &quot;HTMLVideoElement.h&quot;
 41 #include &quot;HitTestResult.h&quot;
 42 #include &quot;Logging.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PlatformMediaSessionManager.h&quot;
 45 #include &quot;Quirks.h&quot;
 46 #include &quot;RenderMedia.h&quot;
 47 #include &quot;RenderView.h&quot;
 48 #include &quot;ScriptController.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;SourceBuffer.h&quot;
 51 #include &lt;wtf/text/StringBuilder.h&gt;
 52 
 53 #if PLATFORM(IOS_FAMILY)
 54 #include &quot;AudioSession.h&quot;
 55 #include &quot;RuntimeApplicationChecks.h&quot;
 56 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 57 #endif
 58 
 59 namespace WebCore {
 60 
 61 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
 62 static const Seconds elementMainContentCheckInterval { 250_ms };
 63 
 64 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp;);
 65 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp;, MediaSessionMainContentPurpose);
 66 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp;, bool shouldHitTestMainFrame);
 67 
 68 #if !RELEASE_LOG_DISABLED
 69 static String restrictionNames(MediaElementSession::BehaviorRestrictions restriction)
 70 {
 71     StringBuilder restrictionBuilder;
 72 #define CASE(restrictionType) \
 73     if (restriction &amp; MediaElementSession::restrictionType) { \
 74         if (!restrictionBuilder.isEmpty()) \
 75             restrictionBuilder.appendLiteral(&quot;, &quot;); \
 76         restrictionBuilder.append(#restrictionType); \
 77     } \
 78 
 79     CASE(NoRestrictions)
 80     CASE(RequireUserGestureForLoad)
 81     CASE(RequireUserGestureForVideoRateChange)
 82     CASE(RequireUserGestureForAudioRateChange)
 83     CASE(RequireUserGestureForFullscreen)
 84     CASE(RequirePageConsentToLoadMedia)
 85     CASE(RequirePageConsentToResumeMedia)
 86     CASE(RequireUserGestureToShowPlaybackTargetPicker)
 87     CASE(WirelessVideoPlaybackDisabled)
 88     CASE(RequireUserGestureToAutoplayToExternalDevice)
 89     CASE(AutoPreloadingNotPermitted)
 90     CASE(InvisibleAutoplayNotPermitted)
 91     CASE(OverrideUserGestureRequirementForMainContent)
 92     CASE(RequireUserGestureToControlControlsManager)
 93     CASE(RequirePlaybackToControlControlsManager)
 94     CASE(RequireUserGestureForVideoDueToLowPowerMode)
 95 
 96     return restrictionBuilder.toString();
 97 }
 98 #endif
 99 
100 static bool pageExplicitlyAllowsElementToAutoplayInline(const HTMLMediaElement&amp; element)
101 {
102     Document&amp; document = element.document();
103     Page* page = document.page();
104     return document.isMediaDocument() &amp;&amp; !document.ownerElement() &amp;&amp; page &amp;&amp; page-&gt;allowsMediaDocumentInlinePlayback();
105 }
106 
107 MediaElementSession::MediaElementSession(HTMLMediaElement&amp; element)
108     : PlatformMediaSession(element)
109     , m_element(element)
110     , m_restrictions(NoRestrictions)
111 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
112     , m_targetAvailabilityChangedTimer(*this, &amp;MediaElementSession::targetAvailabilityChangedTimerFired)
113     , m_hasPlaybackTargets(PlatformMediaSessionManager::sharedManager().hasWirelessTargetsAvailable())
114 #endif
115     , m_mainContentCheckTimer(*this, &amp;MediaElementSession::mainContentCheckTimerFired)
116     , m_clientDataBufferingTimer(*this, &amp;MediaElementSession::clientDataBufferingTimerFired)
117 #if !RELEASE_LOG_DISABLED
118     , m_logIdentifier(element.logIdentifier())
119 #endif
120 {
121 }
122 
123 void MediaElementSession::registerWithDocument(Document&amp; document)
124 {
125 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
126     document.addPlaybackTargetPickerClient(*this);
127 #else
128     UNUSED_PARAM(document);
129 #endif
130 }
131 
132 void MediaElementSession::unregisterWithDocument(Document&amp; document)
133 {
134 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
135     document.removePlaybackTargetPickerClient(*this);
136 #else
137     UNUSED_PARAM(document);
138 #endif
139 }
140 
141 void MediaElementSession::clientWillBeginAutoplaying()
142 {
143     PlatformMediaSession::clientWillBeginAutoplaying();
144     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
145     updateClientDataBuffering();
146 }
147 
148 bool MediaElementSession::clientWillBeginPlayback()
149 {
150     if (!PlatformMediaSession::clientWillBeginPlayback())
151         return false;
152 
153     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
154     updateClientDataBuffering();
155     return true;
156 }
157 
158 bool MediaElementSession::clientWillPausePlayback()
159 {
160     if (!PlatformMediaSession::clientWillPausePlayback())
161         return false;
162 
163     updateClientDataBuffering();
164     return true;
165 }
166 
167 void MediaElementSession::visibilityChanged()
168 {
169     scheduleClientDataBufferingCheck();
170 
171     if (m_element.elementIsHidden() &amp;&amp; !m_element.isFullscreen())
172         m_elementIsHiddenUntilVisibleInViewport = true;
173     else if (m_element.isVisibleInViewport())
174         m_elementIsHiddenUntilVisibleInViewport = false;
175 }
176 
177 void MediaElementSession::isVisibleInViewportChanged()
178 {
179     scheduleClientDataBufferingCheck();
180 
181     if (m_element.isFullscreen() || m_element.isVisibleInViewport())
182         m_elementIsHiddenUntilVisibleInViewport = false;
183 }
184 
185 void MediaElementSession::inActiveDocumentChanged()
186 {
187     m_elementIsHiddenBecauseItWasRemovedFromDOM = !m_element.inActiveDocument();
188     scheduleClientDataBufferingCheck();
189 }
190 
191 void MediaElementSession::scheduleClientDataBufferingCheck()
192 {
193     if (!m_clientDataBufferingTimer.isActive())
194         m_clientDataBufferingTimer.startOneShot(clientDataBufferingTimerThrottleDelay);
195 }
196 
197 void MediaElementSession::clientDataBufferingTimerFired()
198 {
199     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, m_element.elementIsHidden());
200 
201     updateClientDataBuffering();
202 
203 #if PLATFORM(IOS_FAMILY)
204     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
205 #endif
206 
207     if (state() != Playing || !m_element.elementIsHidden())
208         return;
209 
210     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType());
211     if ((restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) == PlatformMediaSessionManager::BackgroundTabPlaybackRestricted)
212         pauseSession();
213 }
214 
215 void MediaElementSession::updateClientDataBuffering()
216 {
217     if (m_clientDataBufferingTimer.isActive())
218         m_clientDataBufferingTimer.stop();
219 
220     m_element.setBufferingPolicy(preferredBufferingPolicy());
221 }
222 
223 void MediaElementSession::addBehaviorRestriction(BehaviorRestrictions restrictions)
224 {
225     if (restrictions &amp; ~m_restrictions)
226         INFO_LOG(LOGIDENTIFIER, &quot;adding &quot;, restrictionNames(restrictions &amp; ~m_restrictions));
227 
228     m_restrictions |= restrictions;
229 
230     if (restrictions &amp; OverrideUserGestureRequirementForMainContent)
231         m_mainContentCheckTimer.startRepeating(elementMainContentCheckInterval);
232 }
233 
234 void MediaElementSession::removeBehaviorRestriction(BehaviorRestrictions restriction)
235 {
236     if (restriction &amp; RequireUserGestureToControlControlsManager) {
237         m_mostRecentUserInteractionTime = MonotonicTime::now();
238         if (auto page = m_element.document().page())
239             page-&gt;setAllowsPlaybackControlsForAutoplayingAudio(true);
240     }
241 
242     if (!(m_restrictions &amp; restriction))
243         return;
244 
245     INFO_LOG(LOGIDENTIFIER, &quot;removed &quot;, restrictionNames(m_restrictions &amp; restriction));
246     m_restrictions &amp;= ~restriction;
247 }
248 
249 SuccessOr&lt;MediaPlaybackDenialReason&gt; MediaElementSession::playbackPermitted() const
250 {
251     if (m_element.isSuspended()) {
252         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is suspended&quot;);
253         return MediaPlaybackDenialReason::InvalidState;
254     }
255 
256     auto&amp; document = m_element.document();
257     auto* page = document.page();
258     if (!page || page-&gt;mediaPlaybackIsSuspended()) {
259         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because media playback is suspended&quot;);
260         return MediaPlaybackDenialReason::PageConsentRequired;
261     }
262 
263     if (document.isMediaDocument() &amp;&amp; !document.ownerElement())
264         return { };
265 
266     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
267         return { };
268 
269     if (requiresFullscreenForVideoPlayback() &amp;&amp; !fullscreenPermitted()) {
270         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of fullscreen restriction&quot;);
271         return MediaPlaybackDenialReason::FullscreenRequired;
272     }
273 
274     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
275         return { };
276 
277 #if ENABLE(MEDIA_STREAM)
278     if (m_element.hasMediaStreamSrcObject()) {
279         if (document.isCapturing())
280             return { };
281         if (document.mediaState() &amp; MediaProducer::IsPlayingAudio)
282             return { };
283     }
284 #endif
285 
286     // FIXME: Why are we checking top-level document only for PerDocumentAutoplayBehavior?
287     const auto&amp; topDocument = document.topDocument();
288     if (topDocument.mediaState() &amp; MediaProducer::HasUserInteractedWithMediaElement &amp;&amp; topDocument.quirks().needsPerDocumentAutoplayBehavior())
289         return { };
290 
291     if (document.hasHadUserInteraction() &amp;&amp; document.quirks().shouldAutoplayForArbitraryUserGesture())
292         return { };
293 
294     if (m_restrictions &amp; RequireUserGestureForVideoRateChange &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
295         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
296         return MediaPlaybackDenialReason::UserGestureRequired;
297     }
298 
299     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
300         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
301         return MediaPlaybackDenialReason::UserGestureRequired;
302     }
303 
304     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
305         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
306         return MediaPlaybackDenialReason::UserGestureRequired;
307     }
308 
309     return { };
310 }
311 
312 bool MediaElementSession::autoplayPermitted() const
313 {
314     const Document&amp; document = m_element.document();
315     if (document.pageCacheState() != Document::NotInPageCache)
316         return false;
317     if (document.activeDOMObjectsAreSuspended())
318         return false;
319 
320     if (!hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
321         return true;
322 
323     // If the media element is audible, allow autoplay even when not visible as pausing it would be observable by the user.
324     if ((!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume())
325         return true;
326 
327     auto* renderer = m_element.renderer();
328     if (!renderer) {
329         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element has no renderer&quot;);
330         return false;
331     }
332     if (renderer-&gt;style().visibility() != Visibility::Visible) {
333         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible&quot;);
334         return false;
335     }
336     if (renderer-&gt;view().frameView().isOffscreen()) {
337         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because frame is offscreen&quot;);
338         return false;
339     }
340     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes) {
341         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible in the viewport&quot;);
342         return false;
343     }
344     return true;
345 }
346 
347 bool MediaElementSession::dataLoadingPermitted() const
348 {
349     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
350         return true;
351 
352     if (m_restrictions &amp; RequireUserGestureForLoad &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
353         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
354         return false;
355     }
356 
357     return true;
358 }
359 
360 MediaPlayer::BufferingPolicy MediaElementSession::preferredBufferingPolicy() const
361 {
362     if (isSuspended())
363         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;
364 
365     if (bufferingSuspended())
366         return MediaPlayer::BufferingPolicy::LimitReadAhead;
367 
368     if (state() == PlatformMediaSession::Playing)
369         return MediaPlayer::BufferingPolicy::Default;
370 
371     if (shouldOverrideBackgroundLoadingRestriction())
372         return MediaPlayer::BufferingPolicy::Default;
373 
374 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
375     if (m_shouldPlayToPlaybackTarget)
376         return MediaPlayer::BufferingPolicy::Default;
377 #endif
378 
379     if (m_elementIsHiddenUntilVisibleInViewport || m_elementIsHiddenBecauseItWasRemovedFromDOM || m_element.elementIsHidden())
380         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;
381 
382     return MediaPlayer::BufferingPolicy::Default;
383 }
384 
385 bool MediaElementSession::fullscreenPermitted() const
386 {
387     if (m_restrictions &amp; RequireUserGestureForFullscreen &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
388         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
389         return false;
390     }
391 
392     return true;
393 }
394 
395 bool MediaElementSession::pageAllowsDataLoading() const
396 {
397     Page* page = m_element.document().page();
398     if (m_restrictions &amp; RequirePageConsentToLoadMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
399         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
400         return false;
401     }
402 
403     return true;
404 }
405 
406 bool MediaElementSession::pageAllowsPlaybackAfterResuming() const
407 {
408     Page* page = m_element.document().page();
409     if (m_restrictions &amp; RequirePageConsentToResumeMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
410         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
411         return false;
412     }
413 
414     return true;
415 }
416 
417 bool MediaElementSession::canShowControlsManager(PlaybackControlsPurpose purpose) const
418 {
419     if (m_element.isSuspended() || !m_element.inActiveDocument()) {
420         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: isSuspended()&quot;);
421         return false;
422     }
423 
424     if (m_element.isFullscreen()) {
425         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is fullscreen&quot;);
426         return true;
427     }
428 
429     if (m_element.muted()) {
430         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: muted&quot;);
431         return false;
432     }
433 
434     if (m_element.document().isMediaDocument() &amp;&amp; (m_element.document().frame() &amp;&amp; m_element.document().frame()-&gt;isMainFrame())) {
435         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is media document&quot;);
436         return true;
437     }
438 
439     if (client().presentationType() == Audio) {
440         if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
441             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: audio element with user gesture&quot;);
442             return true;
443         }
444 
445         if (m_element.isPlaying() &amp;&amp; allowsPlaybackControlsForAutoplayingAudio()) {
446             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: user has played media before&quot;);
447             return true;
448         }
449 
450         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: audio element is not suitable&quot;);
451         return false;
452     }
453 
454     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; !isElementRectMostlyInMainFrame(m_element)) {
455         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: not in main frame&quot;);
456         return false;
457     }
458 
459     if (!m_element.hasAudio() &amp;&amp; !m_element.hasEverHadAudio()) {
460         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no audio&quot;);
461         return false;
462     }
463 
464     if (!playbackPermitted()) {
465         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: playback not permitted&quot;);
466         return false;
467     }
468 
469     if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
470         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: no user gesture required&quot;);
471         return true;
472     }
473 
474     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; hasBehaviorRestriction(RequirePlaybackToControlControlsManager) &amp;&amp; !m_element.isPlaying()) {
475         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: needs to be playing&quot;);
476         return false;
477     }
478 
479     if (!m_element.hasEverNotifiedAboutPlaying()) {
480         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: hasn&#39;t fired playing notification&quot;);
481         return false;
482     }
483 
484 #if ENABLE(FULLSCREEN_API)
485     // Elements which are not descendents of the current fullscreen element cannot be main content.
486     auto* fullscreenElement = m_element.document().fullscreenManager().currentFullscreenElement();
487     if (fullscreenElement &amp;&amp; !m_element.isDescendantOf(*fullscreenElement)) {
488         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: outside of full screen&quot;);
489         return false;
490     }
491 #endif
492 
493     // Only allow the main content heuristic to forbid videos from showing up if our purpose is the controls manager.
494     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; m_element.isVideo()) {
495         if (!m_element.renderer()) {
496             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no renderer&quot;);
497             return false;
498         }
499 
500         if (!m_element.hasVideo() &amp;&amp; !m_element.hasEverHadVideo()) {
501             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no video&quot;);
502             return false;
503         }
504 
505         if (isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls)) {
506             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is main content&quot;);
507             return true;
508         }
509     }
510 
511     if (purpose == PlaybackControlsPurpose::NowPlaying) {
512         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: potentially plays audio&quot;);
513         return true;
514     }
515 
516     INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no user gesture&quot;);
517     return false;
518 }
519 
520 bool MediaElementSession::isLargeEnoughForMainContent(MediaSessionMainContentPurpose purpose) const
521 {
522     return isElementLargeEnoughForMainContent(m_element, purpose);
523 }
524 
525 bool MediaElementSession::isMainContentForPurposesOfAutoplayEvents() const
526 {
527     return isElementMainContentForPurposesOfAutoplay(m_element, false);
528 }
529 
530 MonotonicTime MediaElementSession::mostRecentUserInteractionTime() const
531 {
532     return m_mostRecentUserInteractionTime;
533 }
534 
535 bool MediaElementSession::wantsToObserveViewportVisibilityForMediaControls() const
536 {
537     return isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls);
538 }
539 
540 bool MediaElementSession::wantsToObserveViewportVisibilityForAutoplay() const
541 {
542     return m_element.isVideo();
543 }
544 
545 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
546 void MediaElementSession::showPlaybackTargetPicker()
547 {
548     INFO_LOG(LOGIDENTIFIER);
549 
550     auto&amp; document = m_element.document();
551     if (m_restrictions &amp; RequireUserGestureToShowPlaybackTargetPicker &amp;&amp; !document.processingUserGestureForMedia()) {
552         INFO_LOG(LOGIDENTIFIER, &quot;returning early because of permissions&quot;);
553         return;
554     }
555 
556     if (!document.page()) {
557         INFO_LOG(LOGIDENTIFIER, &quot;returning early because page is NULL&quot;);
558         return;
559     }
560 
561 #if !PLATFORM(IOS_FAMILY)
562     if (m_element.readyState() &lt; HTMLMediaElementEnums::HAVE_METADATA) {
563         INFO_LOG(LOGIDENTIFIER, &quot;returning early because element is not playable&quot;);
564         return;
565     }
566 #endif
567 
568     auto&amp; audioSession = AudioSession::sharedSession();
569     document.showPlaybackTargetPicker(*this, is&lt;HTMLVideoElement&gt;(m_element), audioSession.routeSharingPolicy(), audioSession.routingContextUID());
570 }
571 
572 bool MediaElementSession::hasWirelessPlaybackTargets() const
573 {
574     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, m_hasPlaybackTargets);
575 
576     return m_hasPlaybackTargets;
577 }
578 
579 bool MediaElementSession::wirelessVideoPlaybackDisabled() const
580 {
581     if (!m_element.document().settings().allowsAirPlayForMediaPlayback()) {
582         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of settings&quot;);
583         return true;
584     }
585 
586     if (m_element.hasAttributeWithoutSynchronization(HTMLNames::webkitwirelessvideoplaybackdisabledAttr)) {
587         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of attribute&quot;);
588         return true;
589     }
590 
591 #if PLATFORM(IOS_FAMILY)
592     auto&amp; legacyAirplayAttributeValue = m_element.attributeWithoutSynchronization(HTMLNames::webkitairplayAttr);
593     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;deny&quot;)) {
594         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of legacy attribute&quot;);
595         return true;
596     }
597     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;allow&quot;)) {
598         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE because of legacy attribute&quot;);
599         return false;
600     }
601 #endif
602 
603     auto player = m_element.player();
604     if (!player)
605         return true;
606 
607     bool disabled = player-&gt;wirelessVideoPlaybackDisabled();
608     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, disabled, &quot; because media engine says so&quot;);
609 
610     return disabled;
611 }
612 
613 void MediaElementSession::setWirelessVideoPlaybackDisabled(bool disabled)
614 {
615     if (disabled)
616         addBehaviorRestriction(WirelessVideoPlaybackDisabled);
617     else
618         removeBehaviorRestriction(WirelessVideoPlaybackDisabled);
619 
620     auto player = m_element.player();
621     if (!player)
622         return;
623 
624     INFO_LOG(LOGIDENTIFIER, disabled);
625     player-&gt;setWirelessVideoPlaybackDisabled(disabled);
626 }
627 
628 void MediaElementSession::setHasPlaybackTargetAvailabilityListeners(bool hasListeners)
629 {
630     INFO_LOG(LOGIDENTIFIER, hasListeners);
631 
632 #if PLATFORM(IOS_FAMILY)
633     m_hasPlaybackTargetAvailabilityListeners = hasListeners;
634     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
635 #else
636     UNUSED_PARAM(hasListeners);
637     m_element.document().playbackTargetPickerClientStateDidChange(*this, m_element.mediaState());
638 #endif
639 }
640 
641 void MediaElementSession::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
642 {
643     m_playbackTarget = WTFMove(device);
644     client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
645 }
646 
647 void MediaElementSession::targetAvailabilityChangedTimerFired()
648 {
649     client().wirelessRoutesAvailableDidChange();
650 }
651 
652 void MediaElementSession::externalOutputDeviceAvailableDidChange(bool hasTargets)
653 {
654     if (m_hasPlaybackTargets == hasTargets)
655         return;
656 
657     INFO_LOG(LOGIDENTIFIER, hasTargets);
658 
659     m_hasPlaybackTargets = hasTargets;
660     m_targetAvailabilityChangedTimer.startOneShot(0_s);
661 }
662 
663 bool MediaElementSession::isPlayingToWirelessPlaybackTarget() const
664 {
665 #if !PLATFORM(IOS_FAMILY)
666     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute())
667         return false;
668 #endif
669 
670     return client().isPlayingToWirelessPlaybackTarget();
671 }
672 
673 void MediaElementSession::setShouldPlayToPlaybackTarget(bool shouldPlay)
674 {
675     INFO_LOG(LOGIDENTIFIER, shouldPlay);
676     m_shouldPlayToPlaybackTarget = shouldPlay;
677     updateClientDataBuffering();
678     client().setShouldPlayToPlaybackTarget(shouldPlay);
679 }
680 
681 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
682 {
683     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
684 }
685 #endif
686 
687 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
688 {
689     MediaPlayer::Preload preload = m_element.preloadValue();
690 
691     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
692         return preload;
693 
694     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
695         if (preload &gt; MediaPlayer::MetaData)
696             return MediaPlayer::MetaData;
697     }
698 
699     return preload;
700 }
701 
702 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
703 {
704     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
705         return false;
706 
707     if (is&lt;HTMLAudioElement&gt;(m_element))
708         return false;
709 
710     if (m_element.document().isMediaDocument()) {
711         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
712         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
713         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
714             return false;
715     }
716 
717     if (m_element.isTemporarilyAllowingInlinePlaybackAfterFullscreen())
718         return false;
719 
720     if (!m_element.document().settings().allowsInlineMediaPlayback())
721         return true;
722 
723     if (!m_element.document().settings().inlineMediaPlaybackRequiresPlaysInlineAttribute())
724         return false;
725 
726 #if PLATFORM(IOS_FAMILY)
727     if (IOSApplication::isIBooks())
728         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr) &amp;&amp; !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
729     if (dyld_get_program_sdk_version() &lt; DYLD_IOS_VERSION_10_0)
730         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr);
731 #endif
732 
733     if (m_element.document().isMediaDocument() &amp;&amp; m_element.document().ownerElement())
734         return false;
735 
736     return !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
737 }
738 
739 bool MediaElementSession::allowsAutomaticMediaDataLoading() const
740 {
741     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
742         return true;
743 
744     if (m_element.document().settings().mediaDataLoadsAutomatically())
745         return true;
746 
747     return false;
748 }
749 
750 void MediaElementSession::mediaEngineUpdated()
751 {
752     INFO_LOG(LOGIDENTIFIER);
753 
754 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
755     if (m_restrictions &amp; WirelessVideoPlaybackDisabled)
756         setWirelessVideoPlaybackDisabled(true);
757     if (m_playbackTarget)
758         client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
759     if (m_shouldPlayToPlaybackTarget)
760         client().setShouldPlayToPlaybackTarget(true);
761 #endif
762 
763 }
764 
765 void MediaElementSession::resetPlaybackSessionState()
766 {
767     m_mostRecentUserInteractionTime = MonotonicTime();
768     addBehaviorRestriction(RequireUserGestureToControlControlsManager | RequirePlaybackToControlControlsManager);
769 }
770 
771 void MediaElementSession::suspendBuffering()
772 {
773     updateClientDataBuffering();
774 }
775 
776 void MediaElementSession::resumeBuffering()
777 {
778     updateClientDataBuffering();
779 }
780 
781 bool MediaElementSession::bufferingSuspended() const
782 {
783     if (auto* page = m_element.document().page())
784         return page-&gt;mediaBufferingIsSuspended();
785     return true;
786 }
787 
788 bool MediaElementSession::allowsPictureInPicture() const
789 {
790     return m_element.document().settings().allowsPictureInPictureMediaPlayback();
791 }
792 
793 #if PLATFORM(IOS_FAMILY)
794 bool MediaElementSession::requiresPlaybackTargetRouteMonitoring() const
795 {
796     return m_hasPlaybackTargetAvailabilityListeners &amp;&amp; !m_element.elementIsHidden();
797 }
798 #endif
799 
800 #if ENABLE(MEDIA_SOURCE)
801 size_t MediaElementSession::maximumMediaSourceBufferSize(const SourceBuffer&amp; buffer) const
802 {
803     // A good quality 1080p video uses 8,000 kbps and stereo audio uses 384 kbps, so assume 95% for video and 5% for audio.
804     const float bufferBudgetPercentageForVideo = .95;
805     const float bufferBudgetPercentageForAudio = .05;
806 
807     size_t maximum = buffer.document().settings().maximumSourceBufferSize();
808 
809     // Allow a SourceBuffer to buffer as though it is audio-only even if it doesn&#39;t have any active tracks (yet).
810     size_t bufferSize = static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForAudio);
811     if (buffer.hasVideo())
812         bufferSize += static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForVideo);
813 
814     // FIXME: we might want to modify this algorithm to:
815     // - decrease the maximum size for background tabs
816     // - decrease the maximum size allowed for inactive elements when a process has more than one
817     //   element, eg. so a page with many elements which are played one at a time doesn&#39;t keep
818     //   everything buffered after an element has finished playing.
819 
820     return bufferSize;
821 }
822 #endif
823 
824 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp; element, bool shouldHitTestMainFrame)
825 {
826     Document&amp; document = element.document();
827     if (!document.hasLivingRenderTree() || document.activeDOMObjectsAreStopped() || element.isSuspended() || !element.hasAudio() || !element.hasVideo())
828         return false;
829 
830     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
831     auto* renderer = element.renderer();
832     if (!renderer)
833         return false;
834 
835     if (!isElementLargeEnoughForMainContent(element, MediaSessionMainContentPurpose::Autoplay))
836         return false;
837 
838     // Elements which are hidden by style, or have been scrolled out of view, cannot be main content.
839     // But elements which have audio &amp; video and are already playing should not stop playing because
840     // they are scrolled off the page.
841     if (renderer-&gt;style().visibility() != Visibility::Visible)
842         return false;
843     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes &amp;&amp; !element.isPlaying())
844         return false;
845 
846     // Main content elements must be in the main frame.
847     if (!document.frame() || !document.frame()-&gt;isMainFrame())
848         return false;
849 
850     auto&amp; mainFrame = document.frame()-&gt;mainFrame();
851     if (!mainFrame.view() || !mainFrame.view()-&gt;renderView())
852         return false;
853 
854     if (!shouldHitTestMainFrame)
855         return true;
856 
857     // Hit test the area of the main frame where the element appears, to determine if the element is being obscured.
858     IntRect rectRelativeToView = element.clientRect();
859     ScrollPosition scrollPosition = mainFrame.view()-&gt;documentScrollPositionRelativeToViewOrigin();
860     IntRect rectRelativeToTopDocument(rectRelativeToView.location() + scrollPosition, rectRelativeToView.size());
861     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent | HitTestRequest::IgnoreClipping | HitTestRequest::DisallowUserAgentShadowContent);
862     HitTestResult result(rectRelativeToTopDocument.center());
863 
864     // Elements which are obscured by other elements cannot be main content.
865     if (!mainFrame.document())
866         return false;
867     mainFrame.document()-&gt;hitTest(request, result);
868     result.setToNonUserAgentShadowAncestor();
869     RefPtr&lt;Element&gt; hitElement = result.targetElement();
870     if (hitElement != &amp;element)
871         return false;
872 
873     return true;
874 }
875 
876 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp; element)
877 {
878     if (!element.renderer())
879         return false;
880 
881     auto documentFrame = makeRefPtr(element.document().frame());
882     if (!documentFrame)
883         return false;
884 
885     auto mainFrameView = documentFrame-&gt;mainFrame().view();
886     if (!mainFrameView)
887         return false;
888 
889     IntRect mainFrameRectAdjustedForScrollPosition = IntRect(-mainFrameView-&gt;documentScrollPositionRelativeToViewOrigin(), mainFrameView-&gt;contentsSize());
890     IntRect elementRectInMainFrame = element.clientRect();
891     auto totalElementArea = elementRectInMainFrame.area&lt;RecordOverflow&gt;();
892     if (totalElementArea.hasOverflowed())
893         return false;
894 
895     elementRectInMainFrame.intersect(mainFrameRectAdjustedForScrollPosition);
896 
897     return elementRectInMainFrame.area().unsafeGet() &gt; totalElementArea.unsafeGet() / 2;
898 }
899 
900 static bool isElementLargeRelativeToMainFrame(const HTMLMediaElement&amp; element)
901 {
902     static const double minimumPercentageOfMainFrameAreaForMainContent = 0.9;
903     auto* renderer = element.renderer();
904     if (!renderer)
905         return false;
906 
907     auto documentFrame = makeRefPtr(element.document().frame());
908     if (!documentFrame)
909         return false;
910 
911     if (!documentFrame-&gt;mainFrame().view())
912         return false;
913 
914     auto&amp; mainFrameView = *documentFrame-&gt;mainFrame().view();
915     auto maxVisibleClientWidth = std::min(renderer-&gt;clientWidth().toInt(), mainFrameView.visibleWidth());
916     auto maxVisibleClientHeight = std::min(renderer-&gt;clientHeight().toInt(), mainFrameView.visibleHeight());
917 
918     return maxVisibleClientWidth * maxVisibleClientHeight &gt; minimumPercentageOfMainFrameAreaForMainContent * mainFrameView.visibleWidth() * mainFrameView.visibleHeight();
919 }
920 
921 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp; element, MediaSessionMainContentPurpose purpose)
922 {
923     static const double elementMainContentAreaMinimum = 400 * 300;
924     static const double maximumAspectRatio = purpose == MediaSessionMainContentPurpose::MediaControls ? 3 : 1.8;
925     static const double minimumAspectRatio = .5; // Slightly smaller than 9:16.
926 
927     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
928     auto* renderer = element.renderer();
929     if (!renderer)
930         return false;
931 
932     double width = renderer-&gt;clientWidth();
933     double height = renderer-&gt;clientHeight();
934     double area = width * height;
935     double aspectRatio = width / height;
936 
937     if (area &lt; elementMainContentAreaMinimum)
938         return false;
939 
940     if (aspectRatio &gt;= minimumAspectRatio &amp;&amp; aspectRatio &lt;= maximumAspectRatio)
941         return true;
942 
943     return isElementLargeRelativeToMainFrame(element);
944 }
945 
946 void MediaElementSession::mainContentCheckTimerFired()
947 {
948     if (!hasBehaviorRestriction(OverrideUserGestureRequirementForMainContent))
949         return;
950 
951     updateIsMainContent();
952 }
953 
954 bool MediaElementSession::updateIsMainContent() const
955 {
956     if (m_element.isSuspended())
957         return false;
958 
959     bool wasMainContent = m_isMainContent;
960     m_isMainContent = isElementMainContentForPurposesOfAutoplay(m_element, true);
961 
962     if (m_isMainContent != wasMainContent)
963         m_element.updateShouldPlay();
964 
965     return m_isMainContent;
966 }
967 
968 bool MediaElementSession::allowsNowPlayingControlsVisibility() const
969 {
970     auto page = m_element.document().page();
971     return page &amp;&amp; !page-&gt;isVisibleAndActive();
972 }
973 
974 bool MediaElementSession::allowsPlaybackControlsForAutoplayingAudio() const
975 {
976     auto page = m_element.document().page();
977     return page &amp;&amp; page-&gt;allowsPlaybackControlsForAutoplayingAudio();
978 }
979 
980 String convertEnumerationToString(const MediaPlaybackDenialReason enumerationValue)
981 {
982     static const NeverDestroyed&lt;String&gt; values[] = {
983         MAKE_STATIC_STRING_IMPL(&quot;UserGestureRequired&quot;),
984         MAKE_STATIC_STRING_IMPL(&quot;FullscreenRequired&quot;),
985         MAKE_STATIC_STRING_IMPL(&quot;PageConsentRequired&quot;),
986         MAKE_STATIC_STRING_IMPL(&quot;InvalidState&quot;),
987     };
988     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::UserGestureRequired) == 0, &quot;MediaPlaybackDenialReason::UserGestureRequired is not 0 as expected&quot;);
989     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::FullscreenRequired) == 1, &quot;MediaPlaybackDenialReason::FullscreenRequired is not 1 as expected&quot;);
990     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::PageConsentRequired) == 2, &quot;MediaPlaybackDenialReason::PageConsentRequired is not 2 as expected&quot;);
991     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::InvalidState) == 3, &quot;MediaPlaybackDenialReason::InvalidState is not 3 as expected&quot;);
992     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
993     return values[static_cast&lt;size_t&gt;(enumerationValue)];
994 }
995 
996 }
997 
998 #endif // ENABLE(VIDEO)
    </pre>
  </body>
</html>