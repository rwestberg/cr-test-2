<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/DatabaseTracker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatabaseThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DatabaseTracker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/DatabaseTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  63     for (auto&amp; string : original)
  64         copy.uncheckedAppend(string.isolatedCopy());
  65     return copy;
  66 }
  67 
  68 std::unique_ptr&lt;DatabaseTracker&gt; DatabaseTracker::trackerWithDatabasePath(const String&amp; databasePath)
  69 {
  70     return std::unique_ptr&lt;DatabaseTracker&gt;(new DatabaseTracker(databasePath));
  71 }
  72 
  73 static DatabaseTracker* staticTracker = nullptr;
  74 
  75 void DatabaseTracker::initializeTracker(const String&amp; databasePath)
  76 {
  77     ASSERT(!staticTracker);
  78     if (staticTracker)
  79         return;
  80     staticTracker = new DatabaseTracker(databasePath);
  81 }
  82 





  83 DatabaseTracker&amp; DatabaseTracker::singleton()
  84 {
  85     if (!staticTracker)
  86         staticTracker = new DatabaseTracker(emptyString());
  87     return *staticTracker;
  88 }
  89 
  90 DatabaseTracker::DatabaseTracker(const String&amp; databasePath)
  91     : m_databaseDirectoryPath(databasePath.isolatedCopy())
  92 {
  93 }
  94 
  95 String DatabaseTracker::trackerDatabasePath() const
  96 {
  97     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), &quot;Databases.db&quot;);
  98 }
  99 
 100 void DatabaseTracker::openTrackerDatabase(TrackerCreationAction createAction)
 101 {
 102     ASSERT(!m_databaseGuard.tryLock());
</pre>
<hr />
<pre>
 172     if (!result.hasException())
 173         return { };
 174 
 175     // If we get here, then we do not have enough quota for one of the
 176     // following reasons as indicated by the set error:
 177     //
 178     // If the error is DatabaseSizeOverflowed, then this means the requested
 179     // estimatedSize if so unreasonably large that it can cause an overflow in
 180     // the usage budget computation. In that case, there&#39;s nothing more we can
 181     // do, and there&#39;s no need for a retry. Hence, we should indicate that
 182     // we&#39;re done with our attempt to create the database.
 183     //
 184     // If the error is DatabaseSizeExceededQuota, then we&#39;ll give the client
 185     // a chance to update the quota and call retryCanEstablishDatabase() to try
 186     // again. Hence, we don&#39;t call doneCreatingDatabase() yet in that case.
 187 
 188     auto exception = result.releaseException();
 189     if (exception.code() != QuotaExceededError)
 190         doneCreatingDatabase(origin, name);
 191 
<span class="line-modified"> 192     return WTFMove(exception);</span>
 193 }
 194 
 195 // Note: a thought about performance: hasAdequateQuotaForOrigin() was also
 196 // called in canEstablishDatabase(), and hence, we&#39;re repeating some work within
 197 // hasAdequateQuotaForOrigin(). However, retryCanEstablishDatabase() should only
 198 // be called in the rare even if canEstablishDatabase() fails. Since it is rare,
 199 // we should not bother optimizing it. It is more beneficial to keep
 200 // hasAdequateQuotaForOrigin() simple and correct (i.e. bug free), and just
 201 // re-use it. Also note that the path for opening a database involves IO, and
 202 // hence should not be a performance critical path anyway.
 203 ExceptionOr&lt;void&gt; DatabaseTracker::retryCanEstablishDatabase(DatabaseContext&amp; context, const String&amp; name, unsigned long long estimatedSize)
 204 {
 205     LockHolder lockDatabase(m_databaseGuard);
 206 
 207     // FIXME: What guarantees context.securityOrigin() is non-null?
 208     auto origin = context.securityOrigin();
 209 
 210     // We have already eliminated other types of errors in canEstablishDatabase().
 211     // The only reason we&#39;re in retryCanEstablishDatabase() is because we gave
 212     // the client a chance to update the quota and are rechecking it here.
 213     // If we fail this check, the only possible reason this time should be due
 214     // to inadequate quota.
 215     auto result = hasAdequateQuotaForOrigin(origin, estimatedSize);
 216     if (!result.hasException())
 217         return { };
 218 
 219     auto exception = result.releaseException();
 220     ASSERT(exception.code() == QuotaExceededError);
 221     doneCreatingDatabase(origin, name);
 222 
<span class="line-modified"> 223     return WTFMove(exception);</span>
 224 }
 225 
 226 bool DatabaseTracker::hasEntryForOriginNoLock(const SecurityOriginData&amp; origin)
 227 {
 228     ASSERT(!m_databaseGuard.tryLock());
 229     openTrackerDatabase(DontCreateIfDoesNotExist);
 230     if (!m_database.isOpen())
 231         return false;
 232 
 233     SQLiteStatement statement(m_database, &quot;SELECT origin FROM Origins where origin=?;&quot;);
 234     if (statement.prepare() != SQLITE_OK) {
 235         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 236         return false;
 237     }
 238 
 239     statement.bindText(1, origin.databaseIdentifier());
 240 
 241     return statement.step() == SQLITE_ROW;
 242 }
 243 
</pre>
<hr />
<pre>
 254     SQLiteStatement statement(m_database, &quot;SELECT guid FROM Databases WHERE origin=? AND name=?;&quot;);
 255 
 256     if (statement.prepare() != SQLITE_OK)
 257         return false;
 258 
 259     statement.bindText(1, origin.databaseIdentifier());
 260     statement.bindText(2, databaseIdentifier);
 261 
 262     return statement.step() == SQLITE_ROW;
 263 }
 264 
 265 unsigned long long DatabaseTracker::maximumSize(Database&amp; database)
 266 {
 267     // The maximum size for a database is the full quota for its origin, minus the current usage within the origin,
 268     // plus the current usage of the given database
 269     LockHolder lockDatabase(m_databaseGuard);
 270     auto origin = database.securityOrigin();
 271 
 272     unsigned long long quota = quotaNoLock(origin);
 273     unsigned long long diskUsage = usage(origin);
<span class="line-modified"> 274     unsigned long long databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(database.fileName());</span>
 275     ASSERT(databaseFileSize &lt;= diskUsage);
 276 
 277     if (diskUsage &gt; quota)
 278         return databaseFileSize;
 279 
 280     // A previous error may have allowed the origin to exceed its quota, or may
 281     // have allowed this database to exceed our cached estimate of the origin
 282     // disk usage. Don&#39;t multiply that error through integer underflow, or the
 283     // effective quota will permanently become 2^64.
 284     unsigned long long maxSize = quota - diskUsage + databaseFileSize;
 285     if (maxSize &gt; quota)
 286         maxSize = databaseFileSize;
 287     return maxSize;
 288 }
 289 
 290 void DatabaseTracker::closeAllDatabases(CurrentQueryBehavior currentQueryBehavior)
 291 {
<span class="line-modified"> 292     Vector&lt;Ref&lt;Database&gt;&gt; openDatabases;</span>
<span class="line-removed"> 293     {</span>
<span class="line-removed"> 294         LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);</span>
<span class="line-removed"> 295         if (!m_openDatabaseMap)</span>
<span class="line-removed"> 296             return;</span>
<span class="line-removed"> 297         for (auto&amp; nameMap : m_openDatabaseMap-&gt;values()) {</span>
<span class="line-removed"> 298             for (auto&amp; set : nameMap-&gt;values()) {</span>
<span class="line-removed"> 299                 for (auto&amp; database : *set)</span>
<span class="line-removed"> 300                     openDatabases.append(*database);</span>
<span class="line-removed"> 301             }</span>
<span class="line-removed"> 302         }</span>
<span class="line-removed"> 303     }</span>
<span class="line-removed"> 304     for (auto&amp; database : openDatabases) {</span>
 305         if (currentQueryBehavior == CurrentQueryBehavior::Interrupt)
 306             database-&gt;interrupt();
 307         database-&gt;close();
 308     }
 309 }
 310 
 311 String DatabaseTracker::originPath(const SecurityOriginData&amp; origin) const
 312 {
 313     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), origin.databaseIdentifier());
 314 }
 315 
 316 static String generateDatabaseFileName()
 317 {
<span class="line-modified"> 318     StringBuilder stringBuilder;</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     stringBuilder.append(createCanonicalUUIDString());</span>
<span class="line-removed"> 321     stringBuilder.appendLiteral(&quot;.db&quot;);</span>
<span class="line-removed"> 322 </span>
<span class="line-removed"> 323     return stringBuilder.toString();</span>
 324 }
 325 
 326 String DatabaseTracker::fullPathForDatabaseNoLock(const SecurityOriginData&amp; origin, const String&amp; name, bool createIfNotExists)
 327 {
 328     ASSERT(!m_databaseGuard.tryLock());
 329 
 330     String originIdentifier = origin.databaseIdentifier();
 331     String originPath = this-&gt;originPath(origin);
 332 
 333     // Make sure the path for this SecurityOrigin exists
 334     if (createIfNotExists &amp;&amp; !SQLiteFileSystem::ensureDatabaseDirectoryExists(originPath))
 335         return String();
 336 
 337     // See if we have a path for this database yet
 338     if (!m_database.isOpen())
 339         return String();
 340     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
 341 
 342     if (statement.prepare() != SQLITE_OK)
 343         return String();
</pre>
<hr />
<pre>
 513     SQLiteStatement updateStatement(m_database, &quot;UPDATE Databases SET displayName=?, estimatedSize=? WHERE guid=?&quot;);
 514     if (updateStatement.prepare() != SQLITE_OK)
 515         return;
 516 
 517     updateStatement.bindText(1, displayName);
 518     updateStatement.bindInt64(2, estimatedSize);
 519     updateStatement.bindInt64(3, guid);
 520 
 521     if (updateStatement.step() != SQLITE_DONE) {
 522         LOG_ERROR(&quot;Failed to update details for database %s in origin %s&quot;, name.utf8().data(), originIdentifier.utf8().data());
 523         return;
 524     }
 525 
 526     if (m_client)
 527         m_client-&gt;dispatchDidModifyDatabase(origin, name);
 528 }
 529 
 530 void DatabaseTracker::doneCreatingDatabase(Database&amp; database)
 531 {
 532     LockHolder lockDatabase(m_databaseGuard);
<span class="line-modified"> 533     doneCreatingDatabase(database.securityOrigin(), database.stringIdentifier());</span>


















 534 }
 535 
 536 void DatabaseTracker::addOpenDatabase(Database&amp; database)
 537 {
 538     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 539 
 540     if (!m_openDatabaseMap)
<span class="line-modified"> 541         m_openDatabaseMap = std::make_unique&lt;DatabaseOriginMap&gt;();</span>
 542 
 543     auto origin = database.securityOrigin();
 544 
 545     auto* nameMap = m_openDatabaseMap-&gt;get(origin);
 546     if (!nameMap) {
 547         nameMap = new DatabaseNameMap;
 548         m_openDatabaseMap-&gt;add(origin.isolatedCopy(), nameMap);
 549     }
 550 
<span class="line-modified"> 551     String name = database.stringIdentifier();</span>
 552     auto* databaseSet = nameMap-&gt;get(name);
 553     if (!databaseSet) {
 554         databaseSet = new DatabaseSet;
 555         nameMap-&gt;set(name.isolatedCopy(), databaseSet);
 556     }
 557 
 558     databaseSet-&gt;add(&amp;database);
 559 
<span class="line-modified"> 560     LOG(StorageAPI, &quot;Added open Database %s (%p)\n&quot;, database.stringIdentifier().utf8().data(), &amp;database);</span>
 561 }
 562 
 563 void DatabaseTracker::removeOpenDatabase(Database&amp; database)
 564 {
 565     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 566 
 567     if (!m_openDatabaseMap) {
 568         ASSERT_NOT_REACHED();
 569         return;
 570     }
 571 
 572     DatabaseNameMap* nameMap = m_openDatabaseMap-&gt;get(database.securityOrigin());
 573     if (!nameMap) {
 574         ASSERT_NOT_REACHED();
 575         return;
 576     }
 577 
<span class="line-modified"> 578     String name = database.stringIdentifier();</span>
 579     auto* databaseSet = nameMap-&gt;get(name);
 580     if (!databaseSet) {
 581         ASSERT_NOT_REACHED();
 582         return;
 583     }
 584 
 585     databaseSet-&gt;remove(&amp;database);
 586 
<span class="line-modified"> 587     LOG(StorageAPI, &quot;Removed open Database %s (%p)\n&quot;, database.stringIdentifier().utf8().data(), &amp;database);</span>
 588 
 589     if (!databaseSet-&gt;isEmpty())
 590         return;
 591 
 592     nameMap-&gt;remove(name);
 593     delete databaseSet;
 594 
 595     if (!nameMap-&gt;isEmpty())
 596         return;
 597 
 598     m_openDatabaseMap-&gt;remove(database.securityOrigin());
 599     delete nameMap;
 600 }
 601 
 602 RefPtr&lt;OriginLock&gt; DatabaseTracker::originLockFor(const SecurityOriginData&amp; origin)
 603 {
 604     LockHolder lockDatabase(m_databaseGuard);
 605     String databaseIdentifier = origin.databaseIdentifier();
 606 
 607     // The originLockMap is accessed from multiple DatabaseThreads since
</pre>
<hr />
<pre>
 632     // For example, if the OriginLock lock file was created by a previous run of
 633     // the browser which has now terminated, and the current browser process
 634     // has not executed any database transactions from this origin that would
 635     // have created the OriginLock instance in memory. In this case, we will have
 636     // a lock file but not an OriginLock instance in memory.
 637 
 638     // This function is only called if we are already deleting all the database
 639     // files in this origin. We&#39;ll give the OriginLock one chance to do an
 640     // orderly clean up first when we remove its ref from the m_originLockMap.
 641     // This may or may not be possible depending on whether other threads are
 642     // also using the OriginLock at the same time. After that, we will delete the lock file.
 643 
 644     m_originLockMap.remove(origin.databaseIdentifier());
 645     OriginLock::deleteLockFile(originPath(origin));
 646 }
 647 
 648 unsigned long long DatabaseTracker::usage(const SecurityOriginData&amp; origin)
 649 {
 650     String originPath = this-&gt;originPath(origin);
 651     unsigned long long diskUsage = 0;
<span class="line-modified"> 652     for (auto&amp; fileName : FileSystem::listDirectory(originPath, &quot;*.db&quot;_s)) {</span>
<span class="line-modified"> 653         long long size;</span>
<span class="line-removed"> 654         FileSystem::getFileSize(fileName, size);</span>
<span class="line-removed"> 655         diskUsage += size;</span>
<span class="line-removed"> 656     }</span>
 657     return diskUsage;
 658 }
 659 
 660 unsigned long long DatabaseTracker::quotaNoLock(const SecurityOriginData&amp; origin)
 661 {
 662     ASSERT(!m_databaseGuard.tryLock());
 663     unsigned long long quota = 0;
 664 
 665     openTrackerDatabase(DontCreateIfDoesNotExist);
 666     if (!m_database.isOpen())
 667         return quota;
 668 
 669     SQLiteStatement statement(m_database, &quot;SELECT quota FROM Origins where origin=?;&quot;);
 670     if (statement.prepare() != SQLITE_OK) {
 671         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 672         return quota;
 673     }
 674     statement.bindText(1, origin.databaseIdentifier());
 675 
 676     if (statement.step() == SQLITE_ROW)
</pre>
<hr />
<pre>
 931                 m_client-&gt;dispatchDidModifyDatabase(origin, name);
 932         }
 933     }
 934     return true;
 935 }
 936 
 937 bool DatabaseTracker::isDeletingDatabaseOrOriginFor(const SecurityOriginData&amp; origin, const String&amp; name)
 938 {
 939     ASSERT(!m_databaseGuard.tryLock());
 940     // Can&#39;t create a database while someone else is deleting it; there&#39;s a risk of leaving untracked database debris on the disk.
 941     return isDeletingDatabase(origin, name) || isDeletingOrigin(origin);
 942 }
 943 
 944 void DatabaseTracker::recordCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 945 {
 946     ASSERT(!m_databaseGuard.tryLock());
 947 
 948     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 949     auto* nameSet = m_beingCreated.get(origin);
 950     if (!nameSet) {
<span class="line-modified"> 951         auto ownedSet = std::make_unique&lt;HashCountedSet&lt;String&gt;&gt;();</span>
 952         nameSet = ownedSet.get();
 953         m_beingCreated.add(origin.isolatedCopy(), WTFMove(ownedSet));
 954     }
 955     nameSet-&gt;add(name.isolatedCopy());
 956 }
 957 
 958 void DatabaseTracker::doneCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 959 {
 960     ASSERT(!m_databaseGuard.tryLock());
 961 
 962     ASSERT(m_beingCreated.contains(origin));
 963 
 964     auto iterator = m_beingCreated.find(origin);
 965     if (iterator == m_beingCreated.end())
 966         return;
 967 
 968     auto&amp; countedSet = *iterator-&gt;value;
 969     ASSERT(countedSet.contains(name));
 970 
 971     if (countedSet.remove(name) &amp;&amp; countedSet.isEmpty())
</pre>
<hr />
<pre>
 977     ASSERT(!m_databaseGuard.tryLock());
 978 
 979     auto iterator = m_beingCreated.find(origin);
 980     return iterator != m_beingCreated.end() &amp;&amp; iterator-&gt;value-&gt;contains(name);
 981 }
 982 
 983 bool DatabaseTracker::canDeleteDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 984 {
 985     ASSERT(!m_databaseGuard.tryLock());
 986     return !creatingDatabase(origin, name) &amp;&amp; !isDeletingDatabase(origin, name);
 987 }
 988 
 989 void DatabaseTracker::recordDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 990 {
 991     ASSERT(!m_databaseGuard.tryLock());
 992     ASSERT(canDeleteDatabase(origin, name));
 993 
 994     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 995     auto* nameSet = m_beingDeleted.get(origin);
 996     if (!nameSet) {
<span class="line-modified"> 997         auto ownedSet = std::make_unique&lt;HashSet&lt;String&gt;&gt;();</span>
 998         nameSet = ownedSet.get();
 999         m_beingDeleted.add(origin.isolatedCopy(), WTFMove(ownedSet));
1000     }
1001     ASSERT(!nameSet-&gt;contains(name));
1002     nameSet-&gt;add(name.isolatedCopy());
1003 }
1004 
1005 void DatabaseTracker::doneDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
1006 {
1007     ASSERT(!m_databaseGuard.tryLock());
1008     ASSERT(m_beingDeleted.contains(origin));
1009 
1010     auto iterator = m_beingDeleted.find(origin);
1011     if (iterator == m_beingDeleted.end())
1012         return;
1013 
1014     ASSERT(iterator-&gt;value-&gt;contains(name));
1015     iterator-&gt;value-&gt;remove(name);
1016     if (iterator-&gt;value-&gt;isEmpty())
1017         m_beingDeleted.remove(iterator);
</pre>
<hr />
<pre>
1190                 // it still matches the path stored in the opened database object.
1191                 for (auto&amp; databases : *databaseNameMap) {
1192                     String databaseName = databases.key;
1193                     String databaseFileName;
1194                     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
1195                     if (statement.prepare() == SQLITE_OK) {
1196                         statement.bindText(1, origin.databaseIdentifier());
1197                         statement.bindText(2, databaseName);
1198                         if (statement.step() == SQLITE_ROW)
1199                             databaseFileName = statement.getColumnText(0);
1200                         statement.finalize();
1201                     }
1202 
1203                     bool foundDeletedDatabase = false;
1204                     for (auto&amp; db : *databases.value) {
1205                         // We are done if this database has already been marked as deleted.
1206                         if (db-&gt;deleted())
1207                             continue;
1208 
1209                         // If this database has been deleted or if its database file no longer matches the current version, this database is no longer valid and it should be marked as deleted.
<span class="line-modified">1210                         if (databaseFileName.isNull() || databaseFileName != FileSystem::pathGetFileName(db-&gt;fileName())) {</span>
1211                             deletedDatabases.append(db);
1212                             foundDeletedDatabase = true;
1213                         }
1214                     }
1215 
1216                     // If the database no longer exists, we should remember to send that information to the client later.
1217                     if (m_client &amp;&amp; foundDeletedDatabase &amp;&amp; databaseFileName.isNull())
1218                         deletedDatabaseNamesForThisOrigin.append(databaseName);
1219                 }
1220 
1221                 if (!deletedDatabaseNamesForThisOrigin.isEmpty())
1222                     deletedDatabaseNames.append({ origin, WTFMove(deletedDatabaseNamesForThisOrigin) });
1223             }
1224         }
1225     }
1226 
1227     for (auto&amp; deletedDatabase : deletedDatabases)
1228         deletedDatabase-&gt;markAsDeletedAndClose();
1229 
1230     for (auto&amp; deletedDatabase : deletedDatabaseNames) {
</pre>
</td>
<td>
<hr />
<pre>
  63     for (auto&amp; string : original)
  64         copy.uncheckedAppend(string.isolatedCopy());
  65     return copy;
  66 }
  67 
  68 std::unique_ptr&lt;DatabaseTracker&gt; DatabaseTracker::trackerWithDatabasePath(const String&amp; databasePath)
  69 {
  70     return std::unique_ptr&lt;DatabaseTracker&gt;(new DatabaseTracker(databasePath));
  71 }
  72 
  73 static DatabaseTracker* staticTracker = nullptr;
  74 
  75 void DatabaseTracker::initializeTracker(const String&amp; databasePath)
  76 {
  77     ASSERT(!staticTracker);
  78     if (staticTracker)
  79         return;
  80     staticTracker = new DatabaseTracker(databasePath);
  81 }
  82 
<span class="line-added">  83 bool DatabaseTracker::isInitialized()</span>
<span class="line-added">  84 {</span>
<span class="line-added">  85     return !!staticTracker;</span>
<span class="line-added">  86 }</span>
<span class="line-added">  87 </span>
  88 DatabaseTracker&amp; DatabaseTracker::singleton()
  89 {
  90     if (!staticTracker)
  91         staticTracker = new DatabaseTracker(emptyString());
  92     return *staticTracker;
  93 }
  94 
  95 DatabaseTracker::DatabaseTracker(const String&amp; databasePath)
  96     : m_databaseDirectoryPath(databasePath.isolatedCopy())
  97 {
  98 }
  99 
 100 String DatabaseTracker::trackerDatabasePath() const
 101 {
 102     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), &quot;Databases.db&quot;);
 103 }
 104 
 105 void DatabaseTracker::openTrackerDatabase(TrackerCreationAction createAction)
 106 {
 107     ASSERT(!m_databaseGuard.tryLock());
</pre>
<hr />
<pre>
 177     if (!result.hasException())
 178         return { };
 179 
 180     // If we get here, then we do not have enough quota for one of the
 181     // following reasons as indicated by the set error:
 182     //
 183     // If the error is DatabaseSizeOverflowed, then this means the requested
 184     // estimatedSize if so unreasonably large that it can cause an overflow in
 185     // the usage budget computation. In that case, there&#39;s nothing more we can
 186     // do, and there&#39;s no need for a retry. Hence, we should indicate that
 187     // we&#39;re done with our attempt to create the database.
 188     //
 189     // If the error is DatabaseSizeExceededQuota, then we&#39;ll give the client
 190     // a chance to update the quota and call retryCanEstablishDatabase() to try
 191     // again. Hence, we don&#39;t call doneCreatingDatabase() yet in that case.
 192 
 193     auto exception = result.releaseException();
 194     if (exception.code() != QuotaExceededError)
 195         doneCreatingDatabase(origin, name);
 196 
<span class="line-modified"> 197     return exception;</span>
 198 }
 199 
 200 // Note: a thought about performance: hasAdequateQuotaForOrigin() was also
 201 // called in canEstablishDatabase(), and hence, we&#39;re repeating some work within
 202 // hasAdequateQuotaForOrigin(). However, retryCanEstablishDatabase() should only
 203 // be called in the rare even if canEstablishDatabase() fails. Since it is rare,
 204 // we should not bother optimizing it. It is more beneficial to keep
 205 // hasAdequateQuotaForOrigin() simple and correct (i.e. bug free), and just
 206 // re-use it. Also note that the path for opening a database involves IO, and
 207 // hence should not be a performance critical path anyway.
 208 ExceptionOr&lt;void&gt; DatabaseTracker::retryCanEstablishDatabase(DatabaseContext&amp; context, const String&amp; name, unsigned long long estimatedSize)
 209 {
 210     LockHolder lockDatabase(m_databaseGuard);
 211 
 212     // FIXME: What guarantees context.securityOrigin() is non-null?
 213     auto origin = context.securityOrigin();
 214 
 215     // We have already eliminated other types of errors in canEstablishDatabase().
 216     // The only reason we&#39;re in retryCanEstablishDatabase() is because we gave
 217     // the client a chance to update the quota and are rechecking it here.
 218     // If we fail this check, the only possible reason this time should be due
 219     // to inadequate quota.
 220     auto result = hasAdequateQuotaForOrigin(origin, estimatedSize);
 221     if (!result.hasException())
 222         return { };
 223 
 224     auto exception = result.releaseException();
 225     ASSERT(exception.code() == QuotaExceededError);
 226     doneCreatingDatabase(origin, name);
 227 
<span class="line-modified"> 228     return exception;</span>
 229 }
 230 
 231 bool DatabaseTracker::hasEntryForOriginNoLock(const SecurityOriginData&amp; origin)
 232 {
 233     ASSERT(!m_databaseGuard.tryLock());
 234     openTrackerDatabase(DontCreateIfDoesNotExist);
 235     if (!m_database.isOpen())
 236         return false;
 237 
 238     SQLiteStatement statement(m_database, &quot;SELECT origin FROM Origins where origin=?;&quot;);
 239     if (statement.prepare() != SQLITE_OK) {
 240         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 241         return false;
 242     }
 243 
 244     statement.bindText(1, origin.databaseIdentifier());
 245 
 246     return statement.step() == SQLITE_ROW;
 247 }
 248 
</pre>
<hr />
<pre>
 259     SQLiteStatement statement(m_database, &quot;SELECT guid FROM Databases WHERE origin=? AND name=?;&quot;);
 260 
 261     if (statement.prepare() != SQLITE_OK)
 262         return false;
 263 
 264     statement.bindText(1, origin.databaseIdentifier());
 265     statement.bindText(2, databaseIdentifier);
 266 
 267     return statement.step() == SQLITE_ROW;
 268 }
 269 
 270 unsigned long long DatabaseTracker::maximumSize(Database&amp; database)
 271 {
 272     // The maximum size for a database is the full quota for its origin, minus the current usage within the origin,
 273     // plus the current usage of the given database
 274     LockHolder lockDatabase(m_databaseGuard);
 275     auto origin = database.securityOrigin();
 276 
 277     unsigned long long quota = quotaNoLock(origin);
 278     unsigned long long diskUsage = usage(origin);
<span class="line-modified"> 279     unsigned long long databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(database.fileNameIsolatedCopy());</span>
 280     ASSERT(databaseFileSize &lt;= diskUsage);
 281 
 282     if (diskUsage &gt; quota)
 283         return databaseFileSize;
 284 
 285     // A previous error may have allowed the origin to exceed its quota, or may
 286     // have allowed this database to exceed our cached estimate of the origin
 287     // disk usage. Don&#39;t multiply that error through integer underflow, or the
 288     // effective quota will permanently become 2^64.
 289     unsigned long long maxSize = quota - diskUsage + databaseFileSize;
 290     if (maxSize &gt; quota)
 291         maxSize = databaseFileSize;
 292     return maxSize;
 293 }
 294 
 295 void DatabaseTracker::closeAllDatabases(CurrentQueryBehavior currentQueryBehavior)
 296 {
<span class="line-modified"> 297     for (auto&amp; database : openDatabases()) {</span>












 298         if (currentQueryBehavior == CurrentQueryBehavior::Interrupt)
 299             database-&gt;interrupt();
 300         database-&gt;close();
 301     }
 302 }
 303 
 304 String DatabaseTracker::originPath(const SecurityOriginData&amp; origin) const
 305 {
 306     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), origin.databaseIdentifier());
 307 }
 308 
 309 static String generateDatabaseFileName()
 310 {
<span class="line-modified"> 311     return makeString(createCanonicalUUIDString(), &quot;.db&quot;);</span>





 312 }
 313 
 314 String DatabaseTracker::fullPathForDatabaseNoLock(const SecurityOriginData&amp; origin, const String&amp; name, bool createIfNotExists)
 315 {
 316     ASSERT(!m_databaseGuard.tryLock());
 317 
 318     String originIdentifier = origin.databaseIdentifier();
 319     String originPath = this-&gt;originPath(origin);
 320 
 321     // Make sure the path for this SecurityOrigin exists
 322     if (createIfNotExists &amp;&amp; !SQLiteFileSystem::ensureDatabaseDirectoryExists(originPath))
 323         return String();
 324 
 325     // See if we have a path for this database yet
 326     if (!m_database.isOpen())
 327         return String();
 328     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
 329 
 330     if (statement.prepare() != SQLITE_OK)
 331         return String();
</pre>
<hr />
<pre>
 501     SQLiteStatement updateStatement(m_database, &quot;UPDATE Databases SET displayName=?, estimatedSize=? WHERE guid=?&quot;);
 502     if (updateStatement.prepare() != SQLITE_OK)
 503         return;
 504 
 505     updateStatement.bindText(1, displayName);
 506     updateStatement.bindInt64(2, estimatedSize);
 507     updateStatement.bindInt64(3, guid);
 508 
 509     if (updateStatement.step() != SQLITE_DONE) {
 510         LOG_ERROR(&quot;Failed to update details for database %s in origin %s&quot;, name.utf8().data(), originIdentifier.utf8().data());
 511         return;
 512     }
 513 
 514     if (m_client)
 515         m_client-&gt;dispatchDidModifyDatabase(origin, name);
 516 }
 517 
 518 void DatabaseTracker::doneCreatingDatabase(Database&amp; database)
 519 {
 520     LockHolder lockDatabase(m_databaseGuard);
<span class="line-modified"> 521     doneCreatingDatabase(database.securityOrigin(), database.stringIdentifierIsolatedCopy());</span>
<span class="line-added"> 522 }</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524 Vector&lt;Ref&lt;Database&gt;&gt; DatabaseTracker::openDatabases()</span>
<span class="line-added"> 525 {</span>
<span class="line-added"> 526     Vector&lt;Ref&lt;Database&gt;&gt; openDatabases;</span>
<span class="line-added"> 527     {</span>
<span class="line-added"> 528         LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530         if (m_openDatabaseMap) {</span>
<span class="line-added"> 531             for (auto&amp; nameMap : m_openDatabaseMap-&gt;values()) {</span>
<span class="line-added"> 532                 for (auto&amp; set : nameMap-&gt;values()) {</span>
<span class="line-added"> 533                     for (auto&amp; database : *set)</span>
<span class="line-added"> 534                         openDatabases.append(*database);</span>
<span class="line-added"> 535                 }</span>
<span class="line-added"> 536             }</span>
<span class="line-added"> 537         }</span>
<span class="line-added"> 538     }</span>
<span class="line-added"> 539     return openDatabases;</span>
 540 }
 541 
 542 void DatabaseTracker::addOpenDatabase(Database&amp; database)
 543 {
 544     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 545 
 546     if (!m_openDatabaseMap)
<span class="line-modified"> 547         m_openDatabaseMap = makeUnique&lt;DatabaseOriginMap&gt;();</span>
 548 
 549     auto origin = database.securityOrigin();
 550 
 551     auto* nameMap = m_openDatabaseMap-&gt;get(origin);
 552     if (!nameMap) {
 553         nameMap = new DatabaseNameMap;
 554         m_openDatabaseMap-&gt;add(origin.isolatedCopy(), nameMap);
 555     }
 556 
<span class="line-modified"> 557     String name = database.stringIdentifierIsolatedCopy();</span>
 558     auto* databaseSet = nameMap-&gt;get(name);
 559     if (!databaseSet) {
 560         databaseSet = new DatabaseSet;
 561         nameMap-&gt;set(name.isolatedCopy(), databaseSet);
 562     }
 563 
 564     databaseSet-&gt;add(&amp;database);
 565 
<span class="line-modified"> 566     LOG(StorageAPI, &quot;Added open Database %s (%p)\n&quot;, database.stringIdentifierIsolatedCopy().utf8().data(), &amp;database);</span>
 567 }
 568 
 569 void DatabaseTracker::removeOpenDatabase(Database&amp; database)
 570 {
 571     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 572 
 573     if (!m_openDatabaseMap) {
 574         ASSERT_NOT_REACHED();
 575         return;
 576     }
 577 
 578     DatabaseNameMap* nameMap = m_openDatabaseMap-&gt;get(database.securityOrigin());
 579     if (!nameMap) {
 580         ASSERT_NOT_REACHED();
 581         return;
 582     }
 583 
<span class="line-modified"> 584     String name = database.stringIdentifierIsolatedCopy();</span>
 585     auto* databaseSet = nameMap-&gt;get(name);
 586     if (!databaseSet) {
 587         ASSERT_NOT_REACHED();
 588         return;
 589     }
 590 
 591     databaseSet-&gt;remove(&amp;database);
 592 
<span class="line-modified"> 593     LOG(StorageAPI, &quot;Removed open Database %s (%p)\n&quot;, database.stringIdentifierIsolatedCopy().utf8().data(), &amp;database);</span>
 594 
 595     if (!databaseSet-&gt;isEmpty())
 596         return;
 597 
 598     nameMap-&gt;remove(name);
 599     delete databaseSet;
 600 
 601     if (!nameMap-&gt;isEmpty())
 602         return;
 603 
 604     m_openDatabaseMap-&gt;remove(database.securityOrigin());
 605     delete nameMap;
 606 }
 607 
 608 RefPtr&lt;OriginLock&gt; DatabaseTracker::originLockFor(const SecurityOriginData&amp; origin)
 609 {
 610     LockHolder lockDatabase(m_databaseGuard);
 611     String databaseIdentifier = origin.databaseIdentifier();
 612 
 613     // The originLockMap is accessed from multiple DatabaseThreads since
</pre>
<hr />
<pre>
 638     // For example, if the OriginLock lock file was created by a previous run of
 639     // the browser which has now terminated, and the current browser process
 640     // has not executed any database transactions from this origin that would
 641     // have created the OriginLock instance in memory. In this case, we will have
 642     // a lock file but not an OriginLock instance in memory.
 643 
 644     // This function is only called if we are already deleting all the database
 645     // files in this origin. We&#39;ll give the OriginLock one chance to do an
 646     // orderly clean up first when we remove its ref from the m_originLockMap.
 647     // This may or may not be possible depending on whether other threads are
 648     // also using the OriginLock at the same time. After that, we will delete the lock file.
 649 
 650     m_originLockMap.remove(origin.databaseIdentifier());
 651     OriginLock::deleteLockFile(originPath(origin));
 652 }
 653 
 654 unsigned long long DatabaseTracker::usage(const SecurityOriginData&amp; origin)
 655 {
 656     String originPath = this-&gt;originPath(origin);
 657     unsigned long long diskUsage = 0;
<span class="line-modified"> 658     for (auto&amp; fileName : FileSystem::listDirectory(originPath, &quot;*.db&quot;_s))</span>
<span class="line-modified"> 659         diskUsage += SQLiteFileSystem::getDatabaseFileSize(fileName);</span>



 660     return diskUsage;
 661 }
 662 
 663 unsigned long long DatabaseTracker::quotaNoLock(const SecurityOriginData&amp; origin)
 664 {
 665     ASSERT(!m_databaseGuard.tryLock());
 666     unsigned long long quota = 0;
 667 
 668     openTrackerDatabase(DontCreateIfDoesNotExist);
 669     if (!m_database.isOpen())
 670         return quota;
 671 
 672     SQLiteStatement statement(m_database, &quot;SELECT quota FROM Origins where origin=?;&quot;);
 673     if (statement.prepare() != SQLITE_OK) {
 674         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 675         return quota;
 676     }
 677     statement.bindText(1, origin.databaseIdentifier());
 678 
 679     if (statement.step() == SQLITE_ROW)
</pre>
<hr />
<pre>
 934                 m_client-&gt;dispatchDidModifyDatabase(origin, name);
 935         }
 936     }
 937     return true;
 938 }
 939 
 940 bool DatabaseTracker::isDeletingDatabaseOrOriginFor(const SecurityOriginData&amp; origin, const String&amp; name)
 941 {
 942     ASSERT(!m_databaseGuard.tryLock());
 943     // Can&#39;t create a database while someone else is deleting it; there&#39;s a risk of leaving untracked database debris on the disk.
 944     return isDeletingDatabase(origin, name) || isDeletingOrigin(origin);
 945 }
 946 
 947 void DatabaseTracker::recordCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 948 {
 949     ASSERT(!m_databaseGuard.tryLock());
 950 
 951     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 952     auto* nameSet = m_beingCreated.get(origin);
 953     if (!nameSet) {
<span class="line-modified"> 954         auto ownedSet = makeUnique&lt;HashCountedSet&lt;String&gt;&gt;();</span>
 955         nameSet = ownedSet.get();
 956         m_beingCreated.add(origin.isolatedCopy(), WTFMove(ownedSet));
 957     }
 958     nameSet-&gt;add(name.isolatedCopy());
 959 }
 960 
 961 void DatabaseTracker::doneCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 962 {
 963     ASSERT(!m_databaseGuard.tryLock());
 964 
 965     ASSERT(m_beingCreated.contains(origin));
 966 
 967     auto iterator = m_beingCreated.find(origin);
 968     if (iterator == m_beingCreated.end())
 969         return;
 970 
 971     auto&amp; countedSet = *iterator-&gt;value;
 972     ASSERT(countedSet.contains(name));
 973 
 974     if (countedSet.remove(name) &amp;&amp; countedSet.isEmpty())
</pre>
<hr />
<pre>
 980     ASSERT(!m_databaseGuard.tryLock());
 981 
 982     auto iterator = m_beingCreated.find(origin);
 983     return iterator != m_beingCreated.end() &amp;&amp; iterator-&gt;value-&gt;contains(name);
 984 }
 985 
 986 bool DatabaseTracker::canDeleteDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 987 {
 988     ASSERT(!m_databaseGuard.tryLock());
 989     return !creatingDatabase(origin, name) &amp;&amp; !isDeletingDatabase(origin, name);
 990 }
 991 
 992 void DatabaseTracker::recordDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 993 {
 994     ASSERT(!m_databaseGuard.tryLock());
 995     ASSERT(canDeleteDatabase(origin, name));
 996 
 997     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 998     auto* nameSet = m_beingDeleted.get(origin);
 999     if (!nameSet) {
<span class="line-modified">1000         auto ownedSet = makeUnique&lt;HashSet&lt;String&gt;&gt;();</span>
1001         nameSet = ownedSet.get();
1002         m_beingDeleted.add(origin.isolatedCopy(), WTFMove(ownedSet));
1003     }
1004     ASSERT(!nameSet-&gt;contains(name));
1005     nameSet-&gt;add(name.isolatedCopy());
1006 }
1007 
1008 void DatabaseTracker::doneDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
1009 {
1010     ASSERT(!m_databaseGuard.tryLock());
1011     ASSERT(m_beingDeleted.contains(origin));
1012 
1013     auto iterator = m_beingDeleted.find(origin);
1014     if (iterator == m_beingDeleted.end())
1015         return;
1016 
1017     ASSERT(iterator-&gt;value-&gt;contains(name));
1018     iterator-&gt;value-&gt;remove(name);
1019     if (iterator-&gt;value-&gt;isEmpty())
1020         m_beingDeleted.remove(iterator);
</pre>
<hr />
<pre>
1193                 // it still matches the path stored in the opened database object.
1194                 for (auto&amp; databases : *databaseNameMap) {
1195                     String databaseName = databases.key;
1196                     String databaseFileName;
1197                     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
1198                     if (statement.prepare() == SQLITE_OK) {
1199                         statement.bindText(1, origin.databaseIdentifier());
1200                         statement.bindText(2, databaseName);
1201                         if (statement.step() == SQLITE_ROW)
1202                             databaseFileName = statement.getColumnText(0);
1203                         statement.finalize();
1204                     }
1205 
1206                     bool foundDeletedDatabase = false;
1207                     for (auto&amp; db : *databases.value) {
1208                         // We are done if this database has already been marked as deleted.
1209                         if (db-&gt;deleted())
1210                             continue;
1211 
1212                         // If this database has been deleted or if its database file no longer matches the current version, this database is no longer valid and it should be marked as deleted.
<span class="line-modified">1213                         if (databaseFileName.isNull() || databaseFileName != FileSystem::pathGetFileName(db-&gt;fileNameIsolatedCopy())) {</span>
1214                             deletedDatabases.append(db);
1215                             foundDeletedDatabase = true;
1216                         }
1217                     }
1218 
1219                     // If the database no longer exists, we should remember to send that information to the client later.
1220                     if (m_client &amp;&amp; foundDeletedDatabase &amp;&amp; databaseFileName.isNull())
1221                         deletedDatabaseNamesForThisOrigin.append(databaseName);
1222                 }
1223 
1224                 if (!deletedDatabaseNamesForThisOrigin.isEmpty())
1225                     deletedDatabaseNames.append({ origin, WTFMove(deletedDatabaseNamesForThisOrigin) });
1226             }
1227         }
1228     }
1229 
1230     for (auto&amp; deletedDatabase : deletedDatabases)
1231         deletedDatabase-&gt;markAsDeletedAndClose();
1232 
1233     for (auto&amp; deletedDatabase : deletedDatabaseNames) {
</pre>
</td>
</tr>
</table>
<center><a href="DatabaseThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DatabaseTracker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>