<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/line/BreakingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All right reserved.
   4  * Copyright (C) 2010 Google Inc. All rights reserved.
   5  * Copyright (C) 2013 ChangSeok Oh &lt;shivamidow@gmail.com&gt;
   6  * Copyright (C) 2013 Adobe Systems Inc. All right reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #pragma once
  26 
  27 #include &quot;BreakLines.h&quot;
  28 #include &quot;Hyphenation.h&quot;
  29 #include &quot;LineBreaker.h&quot;
  30 #include &quot;LineInfo.h&quot;
  31 #include &quot;LineLayoutState.h&quot;
  32 #include &quot;LineWidth.h&quot;
  33 #include &quot;RenderCombineText.h&quot;
  34 #include &quot;RenderCounter.h&quot;
  35 #include &quot;RenderInline.h&quot;
  36 #include &quot;RenderLayer.h&quot;
  37 #include &quot;RenderLineBreak.h&quot;
  38 #include &quot;RenderListMarker.h&quot;
  39 #include &quot;RenderRubyRun.h&quot;
  40 #include &quot;RenderSVGInlineText.h&quot;
  41 #include &quot;TrailingObjects.h&quot;
  42 #include &lt;wtf/Function.h&gt;
  43 #include &lt;wtf/Optional.h&gt;
  44 #include &lt;wtf/text/StringView.h&gt;
  45 #include &lt;wtf/unicode/CharacterNames.h&gt;
  46 
  47 namespace WebCore {
  48 
  49 // We don&#39;t let our line box tree for a single line get any deeper than this.
  50 const unsigned cMaxLineDepth = 200;
  51 
  52 struct WordMeasurement {
  53     WordMeasurement()
  54         : renderer(0)
  55         , width(0)
  56         , startOffset(0)
  57         , endOffset(0)
  58     {
  59     }
  60 
  61     RenderText* renderer;
  62     float width;
  63     unsigned startOffset;
  64     unsigned endOffset;
  65     HashSet&lt;const Font*&gt; fallbackFonts;
  66 };
  67 
  68 struct WordTrailingSpace {
  69     WordTrailingSpace(const RenderStyle&amp; style, bool measuringWithTrailingWhitespaceEnabled = true)
  70         : m_style(style)
  71     {
  72         if (!measuringWithTrailingWhitespaceEnabled || !m_style.fontCascade().enableKerning())
  73             m_state = WordTrailingSpaceState::Initialized;
  74     }
  75 
  76     Optional&lt;float&gt; width(HashSet&lt;const Font*&gt;&amp; fallbackFonts)
  77     {
  78         if (m_state == WordTrailingSpaceState::Initialized)
  79             return m_width;
  80 
  81         auto&amp; font = m_style.fontCascade();
  82         m_width = font.width(RenderBlock::constructTextRun(&amp;space, 1, m_style), &amp;fallbackFonts) + font.wordSpacing();
  83         m_state = WordTrailingSpaceState::Initialized;
  84         return m_width;
  85     }
  86 
  87 private:
  88     enum class WordTrailingSpaceState { Uninitialized, Initialized };
  89     const RenderStyle&amp; m_style;
  90     WordTrailingSpaceState m_state { WordTrailingSpaceState::Uninitialized };
  91     Optional&lt;float&gt; m_width;
  92 };
  93 
  94 class BreakingContext {
  95 public:
  96     BreakingContext(LineBreaker&amp; lineBreaker, InlineBidiResolver&amp; resolver, LineInfo&amp; inLineInfo, LineWidth&amp; lineWidth, RenderTextInfo&amp; inRenderTextInfo, FloatingObject* inLastFloatFromPreviousLine, bool appliedStartWidth, RenderBlockFlow&amp; block)
  97         : m_lineBreaker(lineBreaker)
  98         , m_resolver(resolver)
  99         , m_current(resolver.position())
 100         , m_lineBreak(resolver.position())
 101         , m_block(block)
 102         , m_lastObject(m_current.renderer())
 103         , m_nextObject(nullptr)
 104         , m_currentStyle(nullptr)
 105         , m_blockStyle(block.style())
 106         , m_lineInfo(inLineInfo)
 107         , m_renderTextInfo(inRenderTextInfo)
 108         , m_lastFloatFromPreviousLine(inLastFloatFromPreviousLine)
 109         , m_width(lineWidth)
 110         , m_currWS(WhiteSpace::Normal)
 111         , m_lastWS(WhiteSpace::Normal)
 112         , m_preservesNewline(false)
 113         , m_atStart(true)
 114         , m_ignoringSpaces(false)
 115         , m_currentCharacterIsSpace(false)
 116         , m_currentCharacterIsWS(false)
<a name="1" id="anc1"></a>
 117         , m_appliedStartWidth(appliedStartWidth)
 118         , m_includeEndWidth(true)
 119         , m_autoWrap(false)
 120         , m_autoWrapWasEverTrueOnLine(false)
 121         , m_floatsFitOnLine(true)
 122         , m_collapseWhiteSpace(false)
 123         , m_startingNewParagraph(m_lineInfo.previousLineBrokeCleanly())
 124         , m_allowImagesToBreak(!block.document().inQuirksMode() || !block.isTableCell() || !m_blockStyle.logicalWidth().isIntrinsicOrAuto())
 125         , m_atEnd(false)
 126         , m_hadUncommittedWidthBeforeCurrent(false)
 127         , m_lineWhitespaceCollapsingState(resolver.whitespaceCollapsingState())
 128     {
 129         m_lineInfo.setPreviousLineBrokeCleanly(false);
 130     }
 131 
 132     RenderObject* currentObject() { return m_current.renderer(); }
 133     InlineIterator lineBreak() { return m_lineBreak; }
 134     LineWidth&amp; lineWidth() { return m_width; }
 135     bool atEnd() { return m_atEnd; }
 136 
 137     bool fitsOnLineOrHangsAtEnd() const { return m_width.fitsOnLine() || m_hangsAtEnd; }
 138 
 139     void initializeForCurrentObject();
 140 
 141     void increment();
 142 
 143     void handleBR(Clear&amp;);
 144     void handleOutOfFlowPositioned(Vector&lt;RenderBox*&gt;&amp; positionedObjects);
 145     void handleFloat();
 146     void handleEmptyInline();
 147     void handleReplaced();
 148     bool handleText(WordMeasurements&amp;, bool&amp; hyphenated, unsigned&amp; consecutiveHyphenatedLines);
<a name="2" id="anc2"></a>
 149     bool canBreakAtThisPosition();
 150     void commitAndUpdateLineBreakIfNeeded();
 151     InlineIterator handleEndOfLine();
 152 
 153     float computeAdditionalBetweenWordsWidth(RenderText&amp;, TextLayout*, UChar, WordTrailingSpace&amp;, HashSet&lt;const Font*&gt;&amp; fallbackFonts, WordMeasurements&amp;, const FontCascade&amp;, bool isFixedPitch, unsigned lastSpace, float lastSpaceWordSpacing, float wordSpacingForWordMeasurement, unsigned offset);
 154 
 155     void clearLineBreakIfFitsOnLine(bool ignoringTrailingSpace = false)
 156     {
 157         if (m_width.fitsOnLine(ignoringTrailingSpace) || m_lastWS == WhiteSpace::NoWrap || m_hangsAtEnd)
 158             m_lineBreak.clear();
 159         m_hangsAtEnd = false;
 160     }
 161 
 162     void commitLineBreakClear()
 163     {
 164         m_width.commit();
 165         m_lineBreak.clear();
 166         m_hangsAtEnd = false;
 167     }
 168 
 169     void commitLineBreakAtCurrentWidth(RenderObject&amp; object, unsigned offset = 0, Optional&lt;unsigned&gt; nextBreak = Optional&lt;unsigned&gt;())
 170     {
 171         m_width.commit();
 172         m_lineBreak.moveTo(object, offset, nextBreak);
 173         m_hangsAtEnd = false;
 174     }
 175 
 176 private:
 177     LineBreaker&amp; m_lineBreaker;
 178     InlineBidiResolver&amp; m_resolver;
 179 
 180     InlineIterator m_current;
 181     InlineIterator m_lineBreak;
 182     InlineIterator m_startOfIgnoredSpaces;
 183 
 184     RenderBlockFlow&amp; m_block;
 185     RenderObject* m_lastObject;
 186     RenderObject* m_nextObject;
 187 
 188     const RenderStyle* m_currentStyle;
 189 
 190     // Firefox and Opera will allow a table cell to grow to fit an image inside it under
 191     // very specific circumstances (in order to match common WinIE renderings).
 192     // Not supporting the quirk has caused us to mis-render some real sites. (See Bugzilla 10517.)
 193     const RenderStyle&amp; m_blockStyle;
 194 
 195     LineInfo&amp; m_lineInfo;
 196 
 197     RenderTextInfo&amp; m_renderTextInfo;
 198 
 199     FloatingObject* m_lastFloatFromPreviousLine;
 200 
 201     LineWidth m_width;
 202 
 203     WhiteSpace m_currWS;
 204     WhiteSpace m_lastWS;
 205 
 206     bool m_preservesNewline;
 207     bool m_atStart;
 208 
 209     // This variable is used only if whitespace isn&#39;t set to WhiteSpace::Pre, and it tells us whether
 210     // or not we are currently ignoring whitespace.
 211     bool m_ignoringSpaces;
 212 
 213     // This variable tracks whether the very last character we saw was a space. We use
 214     // this to detect when we encounter a second space so we know we have to terminate
 215     // a run.
 216     bool m_currentCharacterIsSpace;
 217     bool m_currentCharacterIsWS;
<a name="3" id="anc3"></a>
 218     bool m_appliedStartWidth;
 219     bool m_includeEndWidth;
 220     bool m_autoWrap;
 221     bool m_autoWrapWasEverTrueOnLine;
 222     bool m_floatsFitOnLine;
 223     bool m_collapseWhiteSpace;
 224     bool m_startingNewParagraph;
 225     bool m_allowImagesToBreak;
 226     bool m_atEnd;
 227     bool m_hadUncommittedWidthBeforeCurrent;
 228 
 229     bool m_hangsAtEnd { false };
 230 
 231     LineWhitespaceCollapsingState&amp; m_lineWhitespaceCollapsingState;
 232 
 233     TrailingObjects m_trailingObjects;
 234 };
 235 
 236 inline void BreakingContext::initializeForCurrentObject()
 237 {
 238     m_hadUncommittedWidthBeforeCurrent = !!m_width.uncommittedWidth();
 239 
 240     m_currentStyle = &amp;m_current.renderer()-&gt;style(); // FIXME: Should this be &amp;lineStyle(*m_current.renderer(), m_lineInfo); ?
 241 
 242     ASSERT(m_currentStyle);
 243 
 244     m_nextObject = bidiNextSkippingEmptyInlines(m_block, m_current.renderer());
 245     if (m_nextObject &amp;&amp; m_nextObject-&gt;parent() &amp;&amp; !m_nextObject-&gt;parent()-&gt;isDescendantOf(m_current.renderer()-&gt;parent()))
 246         m_includeEndWidth = true;
 247 
 248     m_currWS = m_current.renderer()-&gt;isReplaced() ? m_current.renderer()-&gt;parent()-&gt;style().whiteSpace() : m_currentStyle-&gt;whiteSpace();
 249     m_lastWS = m_lastObject-&gt;isReplaced() ? m_lastObject-&gt;parent()-&gt;style().whiteSpace() : m_lastObject-&gt;style().whiteSpace();
 250 
 251     m_autoWrap = RenderStyle::autoWrap(m_currWS);
 252     m_autoWrapWasEverTrueOnLine = m_autoWrapWasEverTrueOnLine || m_autoWrap;
 253 
 254     m_preservesNewline = m_current.renderer()-&gt;isSVGInlineText() ? false : RenderStyle::preserveNewline(m_currWS);
 255 
 256     m_collapseWhiteSpace = RenderStyle::collapseWhiteSpace(m_currWS);
 257 }
 258 
 259 inline void BreakingContext::increment()
 260 {
 261     // Clear out our character space bool, since inline &lt;pre&gt;s don&#39;t collapse whitespace
 262     // with adjacent inline normal/nowrap spans.
 263     if (!m_collapseWhiteSpace)
 264         m_currentCharacterIsSpace = false;
 265 
 266     if (m_nextObject)
 267         m_current.moveToStartOf(*m_nextObject);
 268     else
 269         m_current.clear();
 270     m_atStart = false;
 271 }
 272 
 273 inline void BreakingContext::handleBR(Clear&amp; clear)
 274 {
 275     if (fitsOnLineOrHangsAtEnd()) {
 276         RenderObject&amp; br = *m_current.renderer();
 277         m_lineBreak.moveToStartOf(br);
 278         m_lineBreak.increment();
 279 
 280         // A &lt;br&gt; always breaks a line, so don&#39;t let the line be collapsed
 281         // away. Also, the space at the end of a line with a &lt;br&gt; does not
 282         // get collapsed away. It only does this if the previous line broke
 283         // cleanly. Otherwise the &lt;br&gt; has no effect on whether the line is
 284         // empty or not.
 285         if (m_startingNewParagraph)
 286             m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 287         m_trailingObjects.clear();
 288         m_lineInfo.setPreviousLineBrokeCleanly(true);
 289 
 290         // A &lt;br&gt; with clearance always needs a linebox in case the lines below it get dirtied later and
 291         // need to check for floats to clear - so if we&#39;re ignoring spaces, stop ignoring them and add a
 292         // run for this object.
 293         if (m_ignoringSpaces &amp;&amp; m_currentStyle-&gt;clear() != Clear::None)
 294             m_lineWhitespaceCollapsingState.ensureLineBoxInsideIgnoredSpaces(br);
 295         // If we were preceded by collapsing space and are in a right-aligned container we need to ensure the space gets
 296         // collapsed away so that it doesn&#39;t push the text out from the container&#39;s right-hand edge.
 297         // FIXME: Do this regardless of the container&#39;s alignment - will require rebaselining a lot of test results.
 298         else if (m_ignoringSpaces &amp;&amp; (m_blockStyle.textAlign() == TextAlignMode::Right || m_blockStyle.textAlign() == TextAlignMode::WebKitRight))
 299             m_lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, m_current.renderer(), m_current.offset()));
 300 
 301         if (!m_lineInfo.isEmpty())
 302             clear = m_currentStyle-&gt;clear();
 303     }
 304     m_atEnd = true;
 305 }
 306 
 307 inline LayoutUnit borderPaddingMarginStart(const RenderInline&amp; child)
 308 {
 309     return child.marginStart() + child.paddingStart() + child.borderStart();
 310 }
 311 
 312 inline LayoutUnit borderPaddingMarginEnd(const RenderInline&amp; child)
 313 {
 314     return child.marginEnd() + child.paddingEnd() + child.borderEnd();
 315 }
 316 
 317 inline bool shouldAddBorderPaddingMargin(RenderObject* child)
 318 {
 319     if (!child)
 320         return true;
 321     // When deciding whether we&#39;re at the edge of an inline, adjacent collapsed whitespace is the same as no sibling at all.
 322     if (is&lt;RenderText&gt;(*child) &amp;&amp; !downcast&lt;RenderText&gt;(*child).text().length())
 323         return true;
 324 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 325     if (is&lt;RenderLineBreak&gt;(*child) &amp;&amp; child-&gt;parent()-&gt;style().boxDecorationBreak() == BoxDecorationBreak::Clone)
 326         return true;
 327 #endif
 328     return false;
 329 }
 330 
 331 inline RenderObject* previousInFlowSibling(RenderObject* child)
 332 {
 333     do {
 334         child = child-&gt;previousSibling();
 335     } while (child &amp;&amp; child-&gt;isOutOfFlowPositioned());
 336     return child;
 337 }
 338 
 339 inline LayoutUnit inlineLogicalWidth(RenderObject* child, bool checkStartEdge = true, bool checkEndEdge = true)
 340 {
 341     unsigned lineDepth = 1;
 342     LayoutUnit extraWidth;
 343     RenderElement* parent = child-&gt;parent();
 344     while (is&lt;RenderInline&gt;(*parent) &amp;&amp; lineDepth++ &lt; cMaxLineDepth) {
 345         const auto&amp; parentAsRenderInline = downcast&lt;RenderInline&gt;(*parent);
 346         if (!isEmptyInline(parentAsRenderInline)) {
 347             checkStartEdge = checkStartEdge &amp;&amp; shouldAddBorderPaddingMargin(previousInFlowSibling(child));
 348             if (checkStartEdge)
 349                 extraWidth += borderPaddingMarginStart(parentAsRenderInline);
 350             checkEndEdge = checkEndEdge &amp;&amp; shouldAddBorderPaddingMargin(child-&gt;nextSibling());
 351             if (checkEndEdge)
 352                 extraWidth += borderPaddingMarginEnd(parentAsRenderInline);
 353             if (!checkStartEdge &amp;&amp; !checkEndEdge)
 354                 return extraWidth;
 355         }
 356         child = parent;
 357         parent = child-&gt;parent();
 358     }
 359     return extraWidth;
 360 }
 361 
 362 inline void BreakingContext::handleOutOfFlowPositioned(Vector&lt;RenderBox*&gt;&amp; positionedObjects)
 363 {
 364     // If our original display wasn&#39;t an inline type, then we can determine our static inline position now.
 365     auto&amp; box = downcast&lt;RenderBox&gt;(*m_current.renderer());
 366     bool isInlineType = box.style().isOriginalDisplayInlineType();
 367     if (!isInlineType)
 368         m_block.setStaticInlinePositionForChild(box, m_block.logicalHeight(), m_block.startOffsetForContent(m_block.logicalHeight()));
 369     else {
 370         // If our original display was an DisplayType::Inline type, then we can determine our static y position now.
 371         box.layer()-&gt;setStaticBlockPosition(m_block.logicalHeight());
 372     }
 373 
 374     // If we&#39;re ignoring spaces, we have to stop and include this object and
 375     // then start ignoring spaces again.
 376     if (isInlineType || box.container()-&gt;isRenderInline()) {
 377         if (m_ignoringSpaces)
 378             m_lineWhitespaceCollapsingState.ensureLineBoxInsideIgnoredSpaces(box);
 379         m_trailingObjects.appendBoxIfNeeded(box);
 380     } else
 381         positionedObjects.append(&amp;box);
 382 
 383     m_width.addUncommittedWidth(inlineLogicalWidth(&amp;box));
 384     // Reset prior line break context characters.
 385     m_renderTextInfo.lineBreakIterator.resetPriorContext();
 386 }
 387 
 388 inline void BreakingContext::handleFloat()
 389 {
 390     auto&amp; floatBox = downcast&lt;RenderBox&gt;(*m_current.renderer());
 391     const auto&amp; floatingObject = *m_lineBreaker.insertFloatingObject(floatBox);
 392     // check if it fits in the current line.
 393     // If it does, position it now, otherwise, position
 394     // it after moving to next line (in clearFloats() func)
 395     if (m_floatsFitOnLine &amp;&amp; m_width.fitsOnLineExcludingTrailingWhitespace(m_block.logicalWidthForFloat(floatingObject))) {
 396         m_lineBreaker.positionNewFloatOnLine(floatingObject, m_lastFloatFromPreviousLine, m_lineInfo, m_width);
 397         if (m_lineBreak.renderer() == m_current.renderer()) {
 398             ASSERT(!m_lineBreak.offset());
 399             m_lineBreak.increment();
 400         }
 401     } else
 402         m_floatsFitOnLine = false;
 403     // Update prior line break context characters, using U+FFFD (OBJECT REPLACEMENT CHARACTER) for floating element.
 404     m_renderTextInfo.lineBreakIterator.updatePriorContext(replacementCharacter);
 405 }
 406 
 407 // This is currently just used for list markers and inline flows that have line boxes. Neither should
 408 // have an effect on whitespace at the start of the line.
 409 inline bool shouldSkipWhitespaceAfterStartObject(RenderBlockFlow&amp; block, RenderObject* o, LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState)
 410 {
 411     RenderObject* next = bidiNextSkippingEmptyInlines(block, o);
 412     while (next &amp;&amp; next-&gt;isFloatingOrOutOfFlowPositioned())
 413         next = bidiNextSkippingEmptyInlines(block, next);
 414 
 415     if (is&lt;RenderText&gt;(next) &amp;&amp; downcast&lt;RenderText&gt;(*next).text().length() &gt; 0) {
 416         RenderText&amp; nextText = downcast&lt;RenderText&gt;(*next);
 417         UChar nextChar = nextText.characterAt(0);
 418         if (nextText.style().isCollapsibleWhiteSpace(nextChar)) {
 419             lineWhitespaceCollapsingState.startIgnoringSpaces(InlineIterator(nullptr, o, 0));
 420             return true;
 421         }
 422     }
 423 
 424     return false;
 425 }
 426 
 427 inline void BreakingContext::handleEmptyInline()
 428 {
 429     RenderInline&amp; flowBox = downcast&lt;RenderInline&gt;(*m_current.renderer());
 430 
 431     // This should only end up being called on empty inlines
 432     ASSERT(isEmptyInline(flowBox));
 433 
 434     // Now that some inline flows have line boxes, if we are already ignoring spaces, we need
 435     // to make sure that we stop to include this object and then start ignoring spaces again.
 436     // If this object is at the start of the line, we need to behave like list markers and
 437     // start ignoring spaces.
 438     bool requiresLineBox = alwaysRequiresLineBox(flowBox);
 439     if (requiresLineBox || requiresLineBoxForContent(flowBox, m_lineInfo)) {
 440         // An empty inline that only has line-height, vertical-align or font-metrics will only get a
 441         // line box to affect the height of the line if the rest of the line is not empty.
 442         if (requiresLineBox)
 443             m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 444         if (m_ignoringSpaces) {
 445             m_trailingObjects.clear();
 446             m_lineWhitespaceCollapsingState.ensureLineBoxInsideIgnoredSpaces(*m_current.renderer());
 447         } else if (m_blockStyle.collapseWhiteSpace() &amp;&amp; m_resolver.position().renderer() == m_current.renderer()
 448             &amp;&amp; shouldSkipWhitespaceAfterStartObject(m_block, m_current.renderer(), m_lineWhitespaceCollapsingState)) {
 449             // Like with list markers, we start ignoring spaces to make sure that any
 450             // additional spaces we see will be discarded.
 451             m_currentCharacterIsSpace = true;
 452             m_currentCharacterIsWS = true;
 453             m_ignoringSpaces = true;
 454         } else
 455             m_trailingObjects.appendBoxIfNeeded(flowBox);
 456     }
 457 
 458     float inlineWidth = inlineLogicalWidth(m_current.renderer()) + borderPaddingMarginStart(flowBox) + borderPaddingMarginEnd(flowBox);
 459     m_width.addUncommittedWidth(inlineWidth);
 460     if (m_hangsAtEnd &amp;&amp; inlineWidth)
 461         m_hangsAtEnd = false;
 462 }
 463 
 464 inline void BreakingContext::handleReplaced()
 465 {
 466     auto&amp; replacedBox = downcast&lt;RenderBox&gt;(*m_current.renderer());
 467 
 468     if (m_atStart)
 469         m_width.updateAvailableWidth(replacedBox.logicalHeight());
 470 
 471     // Break on replaced elements if either has normal white-space.
 472     if ((m_autoWrap || RenderStyle::autoWrap(m_lastWS)) &amp;&amp; (!replacedBox.isImage() || m_allowImagesToBreak)
 473         &amp;&amp; (!is&lt;RenderRubyRun&gt;(replacedBox) || downcast&lt;RenderRubyRun&gt;(replacedBox).canBreakBefore(m_renderTextInfo.lineBreakIterator))) {
 474         if (auto* renderer = m_current.renderer())
 475             commitLineBreakAtCurrentWidth(*renderer);
 476         else
 477             commitLineBreakClear();
 478     } else
 479         m_hangsAtEnd = false;
 480 
 481     if (m_ignoringSpaces)
 482         m_lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, &amp;replacedBox, 0));
 483 
 484     m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 485     m_ignoringSpaces = false;
 486     m_currentCharacterIsSpace = false;
 487     m_currentCharacterIsWS = false;
 488     m_trailingObjects.clear();
 489 
 490     // Optimize for a common case. If we can&#39;t find whitespace after the list
 491     // item, then this is all moot.
 492     LayoutUnit replacedLogicalWidth = m_block.logicalWidthForChild(replacedBox) + m_block.marginStartForChild(replacedBox) + m_block.marginEndForChild(replacedBox) + inlineLogicalWidth(&amp;replacedBox);
 493     if (is&lt;RenderListMarker&gt;(replacedBox)) {
 494         if (m_blockStyle.collapseWhiteSpace() &amp;&amp; shouldSkipWhitespaceAfterStartObject(m_block, &amp;replacedBox, m_lineWhitespaceCollapsingState)) {
 495             // Like with inline flows, we start ignoring spaces to make sure that any
 496             // additional spaces we see will be discarded.
 497             m_currentCharacterIsSpace = true;
 498             m_currentCharacterIsWS = false;
 499             m_ignoringSpaces = true;
 500         }
 501         if (downcast&lt;RenderListMarker&gt;(replacedBox).isInside())
 502             m_width.addUncommittedReplacedWidth(replacedLogicalWidth);
 503     } else
 504         m_width.addUncommittedReplacedWidth(replacedLogicalWidth);
 505     if (is&lt;RenderRubyRun&gt;(replacedBox)) {
 506         m_width.applyOverhang(downcast&lt;RenderRubyRun&gt;(replacedBox), m_lastObject, m_nextObject);
 507         downcast&lt;RenderRubyRun&gt;(replacedBox).updatePriorContextFromCachedBreakIterator(m_renderTextInfo.lineBreakIterator);
 508     } else {
 509         // Update prior line break context characters, using U+FFFD (OBJECT REPLACEMENT CHARACTER) for replaced element.
 510         m_renderTextInfo.lineBreakIterator.updatePriorContext(replacementCharacter);
 511     }
 512 }
 513 
 514 inline float firstPositiveWidth(const WordMeasurements&amp; wordMeasurements)
 515 {
 516     for (size_t i = 0; i &lt; wordMeasurements.size(); ++i) {
 517         if (wordMeasurements[i].width &gt; 0)
 518             return wordMeasurements[i].width;
 519     }
 520     return 0;
 521 }
 522 
 523 inline bool iteratorIsBeyondEndOfRenderCombineText(const InlineIterator&amp; iter, RenderCombineText&amp; renderer)
 524 {
 525     return iter.renderer() == &amp;renderer &amp;&amp; iter.offset() &gt;= renderer.text().length();
 526 }
 527 
 528 inline void nextCharacter(UChar&amp; currentCharacter, UChar&amp; lastCharacter, UChar&amp; secondToLastCharacter)
 529 {
 530     secondToLastCharacter = lastCharacter;
 531     lastCharacter = currentCharacter;
 532 }
 533 
 534 // FIXME: Don&#39;t let counters mark themselves as needing pref width recalcs during layout
 535 // so we don&#39;t need this hack.
 536 inline void updateCounterIfNeeded(RenderText&amp; renderText)
 537 {
 538     if (!renderText.preferredLogicalWidthsDirty() || !is&lt;RenderCounter&gt;(renderText))
 539         return;
 540     downcast&lt;RenderCounter&gt;(renderText).updateCounter();
 541 }
 542 
 543 inline float measureHyphenWidth(RenderText&amp; renderer, const FontCascade&amp; font, HashSet&lt;const Font*&gt;* fallbackFonts = 0)
 544 {
 545     const RenderStyle&amp; style = renderer.style();
 546     return font.width(RenderBlock::constructTextRun(style.hyphenString().string(), style), fallbackFonts);
 547 }
 548 
 549 ALWAYS_INLINE float textWidth(RenderText&amp; text, unsigned from, unsigned len, const FontCascade&amp; font, float xPos, bool isFixedPitch, bool collapseWhiteSpace, HashSet&lt;const Font*&gt;&amp; fallbackFonts, TextLayout* layout = nullptr)
 550 {
 551     const RenderStyle&amp; style = text.style();
 552 
 553     GlyphOverflow glyphOverflow;
 554     // FIXME: This is not the right level of abstraction for isFixedPitch. Font fallback may make it such that the fixed pitch font is never actually used!
 555     if (isFixedPitch || (!from &amp;&amp; len == text.text().length()) || style.hasTextCombine())
 556         return text.width(from, len, font, xPos, &amp;fallbackFonts, &amp;glyphOverflow);
 557 
 558     if (layout)
 559         return FontCascade::width(*layout, from, len, &amp;fallbackFonts);
 560 
 561     TextRun run = RenderBlock::constructTextRun(text, from, len, style);
 562     run.setCharacterScanForCodePath(!text.canUseSimpleFontCodePath());
 563     run.setTabSize(!collapseWhiteSpace, style.tabSize());
 564     run.setXPos(xPos);
 565     return font.width(run, &amp;fallbackFonts, &amp;glyphOverflow);
 566 }
 567 
 568 // Adding a pair of whitespace collapsing transitions before a character will split it out into a new line box.
 569 inline void ensureCharacterGetsLineBox(LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState, InlineIterator&amp; textParagraphSeparator)
 570 {
 571     InlineIterator transition(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset());
 572     lineWhitespaceCollapsingState.startIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset() - 1));
 573     lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, textParagraphSeparator.renderer(), textParagraphSeparator.offset()));
 574 }
 575 
<a name="4" id="anc4"></a><span class="line-modified"> 576 inline void tryHyphenating(RenderText&amp; text, const FontCascade&amp; font, const AtomicString&amp; localeIdentifier, unsigned consecutiveHyphenatedLines, int consecutiveHyphenatedLinesLimit, int minimumPrefixLimit, int minimumSuffixLimit, unsigned lastSpace, unsigned pos, float xPos, float availableWidth, bool isFixedPitch, bool collapseWhiteSpace, int lastSpaceWordSpacing, InlineIterator&amp; lineBreak, Optional&lt;unsigned&gt; nextBreakable, bool&amp; hyphenated)</span>
 577 {
 578     // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 579     unsigned minimumPrefixLength;
 580     unsigned minimumSuffixLength;
 581 
 582     if (minimumPrefixLimit &lt; 0)
 583         minimumPrefixLength = 2;
 584     else
 585         minimumPrefixLength = static_cast&lt;unsigned&gt;(minimumPrefixLimit);
 586 
 587     if (minimumSuffixLimit &lt; 0)
 588         minimumSuffixLength = 2;
 589     else
 590         minimumSuffixLength = static_cast&lt;unsigned&gt;(minimumSuffixLimit);
 591 
 592     if (pos - lastSpace &lt;= minimumSuffixLength)
 593         return;
 594 
 595     if (consecutiveHyphenatedLinesLimit &gt;= 0 &amp;&amp; consecutiveHyphenatedLines &gt;= static_cast&lt;unsigned&gt;(consecutiveHyphenatedLinesLimit))
 596         return;
 597 
 598     float hyphenWidth = measureHyphenWidth(text, font);
 599 
 600     float maxPrefixWidth = availableWidth - xPos - hyphenWidth - lastSpaceWordSpacing;
 601     if (!enoughWidthForHyphenation(maxPrefixWidth, font.pixelSize()))
 602         return;
 603 
 604     const RenderStyle&amp; style = text.style();
 605     TextRun run = RenderBlock::constructTextRun(text, lastSpace, pos - lastSpace, style);
 606     run.setTabSize(!collapseWhiteSpace, style.tabSize());
 607     run.setXPos(xPos + lastSpaceWordSpacing);
 608 
 609     unsigned prefixLength = font.offsetForPosition(run, maxPrefixWidth, false);
 610     if (prefixLength &lt; minimumPrefixLength)
 611         return;
 612 
 613     prefixLength = lastHyphenLocation(StringView(text.text()).substring(lastSpace, pos - lastSpace), std::min(prefixLength, pos - lastSpace - minimumSuffixLength) + 1, localeIdentifier);
 614     if (!prefixLength || prefixLength &lt; minimumPrefixLength)
 615         return;
 616 
 617     // When lastSpace is a space, which it always is except sometimes at the beginning of a line or after collapsed
 618     // space, it should not count towards hyphenate-limit-before.
 619     if (prefixLength == minimumPrefixLength) {
 620         UChar characterAtLastSpace = text.characterAt(lastSpace);
 621         if (characterAtLastSpace == &#39; &#39; || characterAtLastSpace == &#39;\n&#39; || characterAtLastSpace == &#39;\t&#39; || characterAtLastSpace == noBreakSpace)
 622             return;
 623     }
 624 
 625     ASSERT(pos - lastSpace - prefixLength &gt;= minimumSuffixLength);
 626 
 627 #if !ASSERT_DISABLED
 628     HashSet&lt;const Font*&gt; fallbackFonts;
 629     float prefixWidth = hyphenWidth + textWidth(text, lastSpace, prefixLength, font, xPos, isFixedPitch, collapseWhiteSpace, fallbackFonts) + lastSpaceWordSpacing;
 630     ASSERT(xPos + prefixWidth &lt;= availableWidth);
 631 #else
 632     UNUSED_PARAM(isFixedPitch);
 633 #endif
 634 
 635     lineBreak.moveTo(text, lastSpace + prefixLength, nextBreakable);
 636     hyphenated = true;
 637 }
 638 
 639 inline float BreakingContext::computeAdditionalBetweenWordsWidth(RenderText&amp; renderText, TextLayout* textLayout, UChar currentCharacter, WordTrailingSpace&amp; wordTrailingSpace, HashSet&lt;const Font*&gt;&amp; fallbackFonts, WordMeasurements&amp; wordMeasurements, const FontCascade&amp; font, bool isFixedPitch, unsigned lastSpace, float lastSpaceWordSpacing, float wordSpacingForWordMeasurement, unsigned offset)
 640 {
 641     wordMeasurements.grow(wordMeasurements.size() + 1);
 642     WordMeasurement&amp; wordMeasurement = wordMeasurements.last();
 643 
 644     wordMeasurement.renderer = &amp;renderText;
 645     wordMeasurement.endOffset = offset;
 646     wordMeasurement.startOffset = lastSpace;
 647 
 648     float additionalTempWidth = 0;
 649     Optional&lt;float&gt; wordTrailingSpaceWidth;
 650     if (currentCharacter == &#39; &#39;)
 651         wordTrailingSpaceWidth = wordTrailingSpace.width(fallbackFonts);
 652     if (wordTrailingSpaceWidth)
 653         additionalTempWidth = textWidth(renderText, lastSpace, offset + 1 - lastSpace, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout) - wordTrailingSpaceWidth.value();
 654     else
 655         additionalTempWidth = textWidth(renderText, lastSpace, offset - lastSpace, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout);
 656 
 657     if (wordMeasurement.fallbackFonts.isEmpty() &amp;&amp; !fallbackFonts.isEmpty())
 658         wordMeasurement.fallbackFonts.swap(fallbackFonts);
 659     fallbackFonts.clear();
 660 
 661     wordMeasurement.width = additionalTempWidth + wordSpacingForWordMeasurement;
 662     additionalTempWidth += lastSpaceWordSpacing;
 663     return additionalTempWidth;
 664 }
 665 
 666 inline bool BreakingContext::handleText(WordMeasurements&amp; wordMeasurements, bool&amp; hyphenated,  unsigned&amp; consecutiveHyphenatedLines)
 667 {
 668     if (!m_current.offset())
 669         m_appliedStartWidth = false;
 670 
 671     RenderObject&amp; renderObject = *m_current.renderer();
 672     RenderText&amp; renderText = downcast&lt;RenderText&gt;(renderObject);
 673 
 674     bool isSVGText = renderText.isSVGInlineText();
 675 
 676     // If we have left a no-wrap inline and entered an autowrap inline while ignoring spaces
 677     // then we need to mark the start of the autowrap inline as a potential linebreak now.
 678     if (m_autoWrap &amp;&amp; !RenderStyle::autoWrap(m_lastWS) &amp;&amp; m_ignoringSpaces)
 679         commitLineBreakAtCurrentWidth(renderText);
 680 
 681     if (renderText.style().hasTextCombine() &amp;&amp; is&lt;RenderCombineText&gt;(*m_current.renderer())) {
 682         auto&amp; combineRenderer = downcast&lt;RenderCombineText&gt;(*m_current.renderer());
 683         combineRenderer.combineTextIfNeeded();
 684         // The length of the renderer&#39;s text may have changed. Increment stale iterator positions
 685         if (iteratorIsBeyondEndOfRenderCombineText(m_lineBreak, combineRenderer)) {
 686             ASSERT(iteratorIsBeyondEndOfRenderCombineText(m_resolver.position(), combineRenderer));
 687             m_lineBreak.increment();
 688             m_resolver.increment();
 689         }
 690     }
 691 
 692     const RenderStyle&amp; style = lineStyle(renderText, m_lineInfo);
 693     const FontCascade&amp; font = style.fontCascade();
 694     bool isFixedPitch = font.isFixedPitch();
 695     bool canHyphenate = style.hyphens() == Hyphens::Auto &amp;&amp; WebCore::canHyphenate(style.locale());
 696     bool canHangPunctuationAtStart = style.hangingPunctuation().contains(HangingPunctuation::First);
 697     bool canHangPunctuationAtEnd = style.hangingPunctuation().contains(HangingPunctuation::Last);
 698     bool canHangStopOrCommaAtLineEnd = style.hangingPunctuation().contains(HangingPunctuation::AllowEnd);
 699     int endPunctuationIndex = canHangPunctuationAtEnd &amp;&amp; m_collapseWhiteSpace ? renderText.lastCharacterIndexStrippingSpaces() : renderText.text().length() - 1;
 700     unsigned lastSpace = m_current.offset();
 701     float wordSpacing = m_currentStyle-&gt;fontCascade().wordSpacing();
 702     float lastSpaceWordSpacing = 0;
 703     float wordSpacingForWordMeasurement = 0;
 704 
 705     float wrapWidthOffset = m_width.uncommittedWidth() + inlineLogicalWidth(m_current.renderer(), !m_appliedStartWidth, true);
 706     float wrapW = wrapWidthOffset;
 707     float charWidth = 0;
 708     bool breakNBSP = m_autoWrap &amp;&amp; m_currentStyle-&gt;nbspMode() == NBSPMode::Space;
 709     // Auto-wrapping text should wrap in the middle of a word only if it could not wrap before the word,
 710     // which is only possible if the word is the first thing on the line.
 711     bool breakWords = m_currentStyle-&gt;breakWords() &amp;&amp; ((m_autoWrap &amp;&amp; (!m_width.committedWidth() &amp;&amp; !m_width.hasCommittedReplaced())) || m_currWS == WhiteSpace::Pre);
 712     bool midWordBreak = false;
<a name="5" id="anc5"></a><span class="line-modified"> 713     bool breakAll = m_currentStyle-&gt;wordBreak() == WordBreak::BreakAll &amp;&amp; m_autoWrap;</span>

 714     bool keepAllWords = m_currentStyle-&gt;wordBreak() == WordBreak::KeepAll;
 715     float hyphenWidth = 0;
 716     auto iteratorMode = mapLineBreakToIteratorMode(m_blockStyle.lineBreak());
 717     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 718     bool isLineEmpty = m_lineInfo.isEmpty();
 719 
 720     if (isSVGText) {
 721         breakWords = false;
 722         breakAll = false;
 723     }
 724 
 725     if (m_renderTextInfo.text != &amp;renderText) {
 726         updateCounterIfNeeded(renderText);
 727         m_renderTextInfo.text = &amp;renderText;
 728         m_renderTextInfo.font = &amp;font;
 729         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 730         m_renderTextInfo.lineBreakIterator.resetStringAndReleaseIterator(renderText.text(), style.locale(), iteratorMode);
 731     } else if (m_renderTextInfo.layout &amp;&amp; m_renderTextInfo.font != &amp;font) {
 732         m_renderTextInfo.font = &amp;font;
 733         m_renderTextInfo.layout = font.createLayout(renderText, m_width.currentWidth(), m_collapseWhiteSpace);
 734     }
 735 
 736     HashSet&lt;const Font*&gt; fallbackFonts;
<a name="6" id="anc6"></a>

 737     UChar lastCharacterFromPreviousRenderText = m_renderTextInfo.lineBreakIterator.lastCharacter();
 738     UChar lastCharacter = m_renderTextInfo.lineBreakIterator.lastCharacter();
 739     UChar secondToLastCharacter = m_renderTextInfo.lineBreakIterator.secondToLastCharacter();
 740     // Non-zero only when kerning is enabled and TextLayout isn&#39;t used, in which case we measure
 741     // words with their trailing space, then subtract its width.
 742     TextLayout* textLayout = m_renderTextInfo.layout.get();
 743     WordTrailingSpace wordTrailingSpace(style, !textLayout);
 744     for (; m_current.offset() &lt; renderText.text().length(); m_current.fastIncrementInTextNode()) {
 745         bool previousCharacterIsSpace = m_currentCharacterIsSpace;
 746         bool previousCharacterIsWS = m_currentCharacterIsWS;
 747         UChar c = m_current.current();
 748         m_currentCharacterIsSpace = c == &#39; &#39; || c == &#39;\t&#39; || (!m_preservesNewline &amp;&amp; (c == &#39;\n&#39;));
 749 
<a name="7" id="anc7"></a>







 750         if (canHangPunctuationAtStart &amp;&amp; m_width.isFirstLine() &amp;&amp; !m_width.committedWidth() &amp;&amp; !wrapW &amp;&amp; !inlineLogicalWidth(m_current.renderer(), true, false)) {
 751             m_width.addUncommittedWidth(-renderText.hangablePunctuationStartWidth(m_current.offset()));
 752             canHangPunctuationAtStart = false;
 753         }
 754 
 755         if (canHangPunctuationAtEnd &amp;&amp; !m_nextObject &amp;&amp; (int)m_current.offset() == endPunctuationIndex &amp;&amp; !inlineLogicalWidth(m_current.renderer(), false, true)) {
 756             m_width.addUncommittedWidth(-renderText.hangablePunctuationEndWidth(endPunctuationIndex));
 757             canHangPunctuationAtEnd = false;
 758         }
 759 
 760         if (!m_collapseWhiteSpace || !m_currentCharacterIsSpace)
 761             m_lineInfo.setEmpty(false, &amp;m_block, &amp;m_width);
 762 
 763         if (c == softHyphen &amp;&amp; m_autoWrap &amp;&amp; !hyphenWidth &amp;&amp; style.hyphens() != Hyphens::None) {
 764             hyphenWidth = measureHyphenWidth(renderText, font, &amp;fallbackFonts);
 765             m_width.addUncommittedWidth(hyphenWidth);
 766         }
 767 
 768         bool applyWordSpacing = false;
 769 
 770         m_currentCharacterIsWS = m_currentCharacterIsSpace || (breakNBSP &amp;&amp; c == noBreakSpace);
 771 
<a name="8" id="anc8"></a><span class="line-modified"> 772         if ((breakAll || breakWords) &amp;&amp; !midWordBreak &amp;&amp; (!m_currentCharacterIsSpace || style.whiteSpace() != WhiteSpace::PreWrap)) {</span>
 773             wrapW += charWidth;
 774             bool midWordBreakIsBeforeSurrogatePair = U16_IS_LEAD(c) &amp;&amp; U16_IS_TRAIL(renderText.characterAt(m_current.offset() + 1));
 775             charWidth = textWidth(renderText, m_current.offset(), midWordBreakIsBeforeSurrogatePair ? 2 : 1, font, m_width.committedWidth() + wrapW, isFixedPitch, m_collapseWhiteSpace, fallbackFonts, textLayout);
 776             midWordBreak = m_width.committedWidth() + wrapW + charWidth &gt; m_width.availableWidth();
 777         }
 778 
 779         Optional&lt;unsigned&gt; nextBreakablePosition = m_current.nextBreakablePosition();
<a name="9" id="anc9"></a><span class="line-modified"> 780         bool betweenWords = c == &#39;\n&#39; || (m_currWS != WhiteSpace::Pre &amp;&amp; !m_atStart &amp;&amp; isBreakable(m_renderTextInfo.lineBreakIterator, m_current.offset(), nextBreakablePosition, breakNBSP, canUseLineBreakShortcut, keepAllWords)</span>
 781             &amp;&amp; (style.hyphens() != Hyphens::None || (m_current.previousInSameNode() != softHyphen)));
 782         m_current.setNextBreakablePosition(nextBreakablePosition);
 783 
 784         if (canHangStopOrCommaAtLineEnd &amp;&amp; renderText.isHangableStopOrComma(c) &amp;&amp; m_width.fitsOnLine()) {
 785             // We need to see if a measurement that excludes the stop would fit. If so, then we should hang
 786             // the stop/comma at the end. First measure including the comma.
 787             m_hangsAtEnd = false;
 788             float inlineStartWidth = !m_appliedStartWidth ? inlineLogicalWidth(m_current.renderer(), true, false) : 0_lu;
 789             float widthIncludingComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, c, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset() + 1) + inlineStartWidth;
 790             m_width.addUncommittedWidth(widthIncludingComma);
 791             if (!m_width.fitsOnLine()) {
 792                 // See if we fit without the comma involved. If we do, then this is a potential hang point.
 793                 float widthWithoutStopOrComma = computeAdditionalBetweenWordsWidth(renderText, textLayout, lastCharacter, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset()) + inlineStartWidth;
 794                 m_width.addUncommittedWidth(widthWithoutStopOrComma - widthIncludingComma);
 795                 if (m_width.fitsOnLine())
 796                     m_hangsAtEnd = true;
 797             } else
 798                 m_width.addUncommittedWidth(-widthIncludingComma);
 799         }
 800 
 801         if (betweenWords || midWordBreak) {
 802             bool stoppedIgnoringSpaces = false;
 803             if (m_ignoringSpaces) {
 804                 lastSpaceWordSpacing = 0;
 805                 if (!m_currentCharacterIsSpace) {
 806                     // Stop ignoring spaces and begin at this new point.
 807                     m_ignoringSpaces = false;
 808                     wordSpacingForWordMeasurement = 0;
 809                     lastSpace = m_current.offset(); // e.g., &quot;Foo    goo&quot;, don&#39;t add in any of the ignored spaces.
 810                     m_lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(0, m_current.renderer(), m_current.offset()));
 811                     stoppedIgnoringSpaces = true;
 812                 } else {
 813                     // Just keep ignoring these spaces.
 814                     nextCharacter(c, lastCharacter, secondToLastCharacter);
 815                     continue;
 816                 }
 817             }
 818 
 819             float additionalTempWidth = computeAdditionalBetweenWordsWidth(renderText, textLayout, c, wordTrailingSpace, fallbackFonts, wordMeasurements, font, isFixedPitch, lastSpace, lastSpaceWordSpacing, wordSpacingForWordMeasurement, m_current.offset());
 820             m_width.addUncommittedWidth(additionalTempWidth);
 821 
 822             WordMeasurement&amp; wordMeasurement = wordMeasurements.last();
 823 
 824             if (m_collapseWhiteSpace &amp;&amp; previousCharacterIsSpace &amp;&amp; m_currentCharacterIsSpace &amp;&amp; additionalTempWidth)
 825                 m_width.setTrailingWhitespaceWidth(additionalTempWidth);
 826 
 827             if (!m_appliedStartWidth) {
 828                 float inlineStartWidth = inlineLogicalWidth(m_current.renderer(), true, false);
 829                 m_width.addUncommittedWidth(inlineStartWidth);
 830                 m_appliedStartWidth = true;
 831                 if (m_hangsAtEnd &amp;&amp; inlineStartWidth)
 832                     m_hangsAtEnd = false;
 833             }
 834 
 835             applyWordSpacing = wordSpacing &amp;&amp; m_currentCharacterIsSpace;
 836 
 837             if (!m_width.hasCommitted() &amp;&amp; m_autoWrap &amp;&amp; !fitsOnLineOrHangsAtEnd())
 838                 m_width.fitBelowFloats(m_lineInfo.isFirstLine());
 839 
 840             if (m_autoWrap || breakWords) {
 841                 // If we break only after white-space, consider the current character
 842                 // as candidate width for this line.
 843                 bool lineWasTooWide = false;
<a name="10" id="anc10"></a><span class="line-modified"> 844                 if (fitsOnLineOrHangsAtEnd() &amp;&amp; m_currentCharacterIsWS &amp;&amp; m_currentStyle-&gt;breakOnlyAfterWhiteSpace() &amp;&amp; !midWordBreak) {</span>
 845                     float charWidth = textWidth(renderText, m_current.offset(), 1, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout) + (applyWordSpacing ? wordSpacing : 0);
 846                     // Check if line is too big even without the extra space
 847                     // at the end of the line. If it is not, do nothing.
 848                     // If the line needs the extra whitespace to be too long,
 849                     // then move the line break to the space and skip all
 850                     // additional whitespace.
 851                     if (!m_width.fitsOnLineIncludingExtraWidth(charWidth)) {
 852                         lineWasTooWide = true;
<a name="11" id="anc11"></a><span class="line-modified"> 853                         m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());</span>
<span class="line-modified"> 854                         m_lineBreaker.skipTrailingWhitespace(m_lineBreak, m_lineInfo);</span>




 855                     }
 856                 }
 857                 if ((lineWasTooWide || !m_width.fitsOnLine()) &amp;&amp; !m_hangsAtEnd) {
 858                     // Don&#39;t try to hyphenate at the final break of a block, since this means there is
 859                     // no more content, and a hyphenated single word would end up on a line by itself. This looks
 860                     // bad so just don&#39;t allow it.
 861                     if (canHyphenate &amp;&amp; !m_width.fitsOnLine() &amp;&amp; (m_nextObject || !renderText.containsOnlyHTMLWhitespace(m_current.offset(), renderText.text().length() - m_current.offset()) || isLineEmpty)) {
 862                         tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
 863                         if (m_lineBreaker.m_hyphenated) {
 864                             m_atEnd = true;
 865                             return false;
 866                         }
 867                     }
 868                     if (m_lineBreak.atTextParagraphSeparator()) {
 869                         if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset() &gt; 0)
 870                             ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 871                         m_lineBreak.increment();
 872                         m_lineInfo.setPreviousLineBrokeCleanly(true);
 873                         wordMeasurement.endOffset = m_lineBreak.offset();
 874                     }
 875                     // Check if the last breaking position is a soft-hyphen.
 876                     if (!hyphenated &amp;&amp; style.hyphens() != Hyphens::None) {
 877                         Optional&lt;unsigned&gt; lastBreakingPositon;
 878                         const RenderObject* rendererAtBreakingPosition = nullptr;
 879                         if (m_lineBreak.offset() || m_lineBreak.nextBreakablePosition()) {
 880                             lastBreakingPositon = m_lineBreak.offset();
 881                             rendererAtBreakingPosition = m_lineBreak.renderer();
 882                         } else if (m_current.nextBreakablePosition() &amp;&amp; m_current.nextBreakablePosition().value() &lt;= m_current.offset()) {
 883                             // We might just be right after the soft-hyphen
 884                             lastBreakingPositon = m_current.nextBreakablePosition().value();
 885                             rendererAtBreakingPosition = m_current.renderer();
 886                         }
 887                         if (lastBreakingPositon) {
 888                             Optional&lt;UChar&gt; characterBeforeBreakingPosition;
 889                             // When last breaking position points to the start of the current context, we need to look at the last character from
 890                             // the previous non-empty text renderer.
 891                             if (!lastBreakingPositon.value())
 892                                 characterBeforeBreakingPosition = lastCharacterFromPreviousRenderText;
 893                             else if (is&lt;RenderText&gt;(rendererAtBreakingPosition)) {
 894                                 const auto&amp; textRenderer = downcast&lt;RenderText&gt;(*rendererAtBreakingPosition);
 895                                 ASSERT(lastBreakingPositon.value() &gt;= 1 &amp;&amp; textRenderer.text().length() &gt; (lastBreakingPositon.value() - 1));
 896                                 characterBeforeBreakingPosition = textRenderer.characterAt(lastBreakingPositon.value() - 1);
 897                             }
 898                             if (characterBeforeBreakingPosition)
 899                                 hyphenated = characterBeforeBreakingPosition.value() == softHyphen;
 900                         }
 901                     }
 902                     if (m_lineBreak.offset() &amp;&amp; m_lineBreak.offset() != (unsigned)wordMeasurement.endOffset &amp;&amp; !wordMeasurement.width) {
 903                         if (charWidth) {
 904                             wordMeasurement.endOffset = m_lineBreak.offset();
 905                             wordMeasurement.width = charWidth;
 906                         }
 907                     }
 908                     // Didn&#39;t fit. Jump to the end unless there&#39;s still an opportunity to collapse whitespace.
 909                     if (m_ignoringSpaces || !m_collapseWhiteSpace || !m_currentCharacterIsSpace || !previousCharacterIsSpace) {
 910                         m_atEnd = true;
 911                         return false;
 912                     }
 913                 } else {
 914                     if (!betweenWords || (midWordBreak &amp;&amp; !m_autoWrap))
 915                         m_width.addUncommittedWidth(-additionalTempWidth);
 916                     if (hyphenWidth) {
 917                         // Subtract the width of the soft hyphen out since we fit on a line.
 918                         m_width.addUncommittedWidth(-hyphenWidth);
 919                         hyphenWidth = 0;
 920                     }
 921                 }
 922             }
 923 
 924             if (c == &#39;\n&#39; &amp;&amp; m_preservesNewline) {
 925                 if (!stoppedIgnoringSpaces &amp;&amp; m_current.offset())
 926                     ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 927                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 928                 m_lineBreak.increment();
 929                 m_lineInfo.setPreviousLineBrokeCleanly(true);
 930                 return true;
 931             }
 932 
 933             if (m_autoWrap &amp;&amp; betweenWords) {
 934                 commitLineBreakAtCurrentWidth(renderObject, m_current.offset(), m_current.nextBreakablePosition());
 935                 wrapWidthOffset = 0;
 936                 wrapW = wrapWidthOffset;
 937                 // Auto-wrapping text should not wrap in the middle of a word once it has had an
 938                 // opportunity to break after a word.
<a name="12" id="anc12"></a>
 939                 breakWords = false;
<a name="13" id="anc13"></a>
 940             }
 941 
 942             if (midWordBreak &amp;&amp; !U16_IS_TRAIL(c) &amp;&amp; !(U_GET_GC_MASK(c) &amp; U_GC_M_MASK)) {
 943                 // Remember this as a breakable position in case
 944                 // adding the end width forces a break.
 945                 m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());
<a name="14" id="anc14"></a><span class="line-modified"> 946                 midWordBreak &amp;= (breakWords || breakAll);</span>
 947             }
 948 
 949             if (betweenWords) {
 950                 lastSpaceWordSpacing = applyWordSpacing ? wordSpacing : 0;
 951                 wordSpacingForWordMeasurement = (applyWordSpacing &amp;&amp; wordMeasurement.width) ? wordSpacing : 0;
 952                 lastSpace = m_current.offset();
 953             }
 954 
 955             if (!m_ignoringSpaces &amp;&amp; m_currentStyle-&gt;collapseWhiteSpace()) {
 956                 // If we encounter a newline, or if we encounter a second space,
 957                 // we need to break up this run and enter a mode where we start collapsing spaces.
 958                 if (m_currentCharacterIsSpace &amp;&amp; previousCharacterIsSpace) {
 959                     m_ignoringSpaces = true;
 960 
 961                     // We just entered a mode where we are ignoring
 962                     // spaces. Create a transition to terminate the run
 963                     // before the second space.
 964                     m_lineWhitespaceCollapsingState.startIgnoringSpaces(m_startOfIgnoredSpaces);
 965                     m_trailingObjects.updateWhitespaceCollapsingTransitionsForTrailingBoxes(m_lineWhitespaceCollapsingState, InlineIterator(), TrailingObjects::DoNotCollapseFirstSpace);
 966                 }
 967             }
 968             // Measuring the width of complex text character-by-character, rather than measuring it all together,
 969             // could produce considerably different width values.
 970             if (!renderText.canUseSimpleFontCodePath() &amp;&amp; midWordBreak &amp;&amp; m_width.fitsOnLine()) {
 971                 midWordBreak = false;
 972                 wrapW = wrapWidthOffset + additionalTempWidth;
 973             }
 974             isLineEmpty = m_lineInfo.isEmpty();
 975         } else {
 976             if (m_ignoringSpaces) {
 977                 // Stop ignoring spaces and begin at this new point.
 978                 m_ignoringSpaces = false;
 979                 lastSpaceWordSpacing = applyWordSpacing ? wordSpacing : 0;
 980                 wordSpacingForWordMeasurement = (applyWordSpacing &amp;&amp; wordMeasurements.last().width) ? wordSpacing : 0;
 981                 lastSpace = m_current.offset(); // e.g., &quot;Foo    goo&quot;, don&#39;t add in any of the ignored spaces.
 982                 m_lineWhitespaceCollapsingState.stopIgnoringSpaces(InlineIterator(nullptr, m_current.renderer(), m_current.offset()));
 983             }
 984             if (m_hangsAtEnd &amp;&amp; !renderText.isHangableStopOrComma(c))
 985                 m_hangsAtEnd = false;
 986         }
 987 
 988         if (isSVGText &amp;&amp; m_current.offset()) {
 989             // Force creation of new InlineBoxes for each absolute positioned character (those that start new text chunks).
 990             if (downcast&lt;RenderSVGInlineText&gt;(renderText).characterStartsNewTextChunk(m_current.offset()))
 991                 ensureCharacterGetsLineBox(m_lineWhitespaceCollapsingState, m_current);
 992         }
 993 
 994         if (m_currentCharacterIsSpace &amp;&amp; !previousCharacterIsSpace) {
 995             m_startOfIgnoredSpaces.setRenderer(m_current.renderer());
 996             m_startOfIgnoredSpaces.setOffset(m_current.offset());
 997             // Spaces after right-aligned text and before a line-break get collapsed away completely so that the trailing
 998             // space doesn&#39;t seem to push the text out from the right-hand edge.
 999             // FIXME: Do this regardless of the container&#39;s alignment - will require rebaselining a lot of test results.
1000             if (m_nextObject &amp;&amp; m_startOfIgnoredSpaces.offset() &amp;&amp; m_nextObject-&gt;isBR() &amp;&amp; (m_blockStyle.textAlign() == TextAlignMode::Right || m_blockStyle.textAlign() == TextAlignMode::WebKitRight)) {
1001                 m_startOfIgnoredSpaces.setOffset(m_startOfIgnoredSpaces.offset() - 1);
1002                 // If there&#39;s just a single trailing space start ignoring it now so it collapses away.
1003                 if (m_current.offset() == renderText.text().length() - 1)
1004                     m_lineWhitespaceCollapsingState.startIgnoringSpaces(m_startOfIgnoredSpaces);
1005             }
1006         }
1007 
1008         if (!m_currentCharacterIsWS &amp;&amp; previousCharacterIsWS) {
1009             if (m_autoWrap &amp;&amp; m_currentStyle-&gt;breakOnlyAfterWhiteSpace())
1010                 m_lineBreak.moveTo(renderObject, m_current.offset(), m_current.nextBreakablePosition());
1011         }
1012 
1013         if (m_collapseWhiteSpace &amp;&amp; m_currentCharacterIsSpace &amp;&amp; !m_ignoringSpaces)
1014             m_trailingObjects.setTrailingWhitespace(downcast&lt;RenderText&gt;(m_current.renderer()));
1015         else if (!m_currentStyle-&gt;collapseWhiteSpace() || !m_currentCharacterIsSpace)
1016             m_trailingObjects.clear();
1017 
1018         m_atStart = false;
1019         nextCharacter(c, lastCharacter, secondToLastCharacter);
1020     }
1021 
1022     m_renderTextInfo.lineBreakIterator.setPriorContext(lastCharacter, secondToLastCharacter);
1023 
1024     wordMeasurements.grow(wordMeasurements.size() + 1);
1025     WordMeasurement&amp; wordMeasurement = wordMeasurements.last();
1026     wordMeasurement.renderer = &amp;renderText;
1027 
1028     // IMPORTANT: current.m_pos is &gt; length here!
1029     float additionalTempWidth = m_ignoringSpaces ? 0 : textWidth(renderText, lastSpace, m_current.offset() - lastSpace, font, m_width.currentWidth(), isFixedPitch, m_collapseWhiteSpace, wordMeasurement.fallbackFonts, textLayout);
1030     wordMeasurement.startOffset = lastSpace;
1031     wordMeasurement.endOffset = m_current.offset();
1032     wordMeasurement.width = m_ignoringSpaces ? 0 : additionalTempWidth + wordSpacingForWordMeasurement;
1033     additionalTempWidth += lastSpaceWordSpacing;
1034 
1035     float inlineLogicalTempWidth = inlineLogicalWidth(m_current.renderer(), !m_appliedStartWidth, m_includeEndWidth);
1036     m_width.addUncommittedWidth(additionalTempWidth + inlineLogicalTempWidth);
1037     if (m_hangsAtEnd &amp;&amp; inlineLogicalTempWidth)
1038         m_hangsAtEnd = false;
1039 
1040     if (wordMeasurement.fallbackFonts.isEmpty() &amp;&amp; !fallbackFonts.isEmpty())
1041         wordMeasurement.fallbackFonts.swap(fallbackFonts);
1042     fallbackFonts.clear();
1043 
1044     if (m_collapseWhiteSpace &amp;&amp; m_currentCharacterIsSpace &amp;&amp; additionalTempWidth)
1045         m_width.setTrailingWhitespaceWidth(additionalTempWidth, inlineLogicalTempWidth);
1046 
1047     m_includeEndWidth = false;
1048 
1049     if (!fitsOnLineOrHangsAtEnd()) {
1050         // Don&#39;t try to hyphenate at the final break of a block, since this means there is
1051         // no more content, and a hyphenated single word would end up on a line by itself. This looks
1052         // bad so just don&#39;t allow it.
1053         if (canHyphenate &amp;&amp; (m_nextObject || isLineEmpty))
1054             tryHyphenating(renderText, font, style.locale(), consecutiveHyphenatedLines, m_blockStyle.hyphenationLimitLines(), style.hyphenationLimitBefore(), style.hyphenationLimitAfter(), lastSpace, m_current.offset(), m_width.currentWidth() - additionalTempWidth, m_width.availableWidth(), isFixedPitch, m_collapseWhiteSpace, lastSpaceWordSpacing, m_lineBreak, m_current.nextBreakablePosition(), m_lineBreaker.m_hyphenated);
1055 
1056         if (!hyphenated &amp;&amp; m_lineBreak.previousInSameNode() == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
1057             hyphenated = true;
1058             m_atEnd = true;
1059         }
1060     }
1061     return false;
1062 }
1063 
1064 inline bool textBeginsWithBreakablePosition(RenderText&amp; nextText)
1065 {
1066     UChar c = nextText.characterAt(0);
1067     return c == &#39; &#39; || c == &#39;\t&#39; || (c == &#39;\n&#39; &amp;&amp; !nextText.preservesNewline());
1068 }
1069 
<a name="15" id="anc15"></a>















1070 inline bool BreakingContext::canBreakAtThisPosition()
1071 {
1072     // If we are no-wrap and have found a line-breaking opportunity already then we should take it.
1073     if (m_width.committedWidth() &amp;&amp; !m_width.fitsOnLine(m_currentCharacterIsSpace) &amp;&amp; m_currWS == WhiteSpace::NoWrap)
1074         return true;
1075 
1076     // Avoid breaking on empty inlines.
1077     if (is&lt;RenderInline&gt;(*m_current.renderer()) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_current.renderer())))
1078         return false;
1079 
1080     // Avoid breaking before empty inlines (as long as the current object isn&#39;t replaced).
1081     if (!m_current.renderer()-&gt;isReplaced() &amp;&amp; is&lt;RenderInline&gt;(m_nextObject) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_nextObject)))
1082         return false;
1083 
1084     // Return early if we autowrap and the current character is a space as we will always want to break at such a position.
1085     if (m_autoWrap &amp;&amp; m_currentCharacterIsSpace)
1086         return true;
1087 
1088     if (m_nextObject &amp;&amp; m_nextObject-&gt;isLineBreakOpportunity())
1089         return m_autoWrap;
1090 
1091     bool nextIsAutoWrappingText = is&lt;RenderText&gt;(m_nextObject) &amp;&amp; (m_autoWrap || m_nextObject-&gt;style().autoWrap());
1092     if (!nextIsAutoWrappingText)
1093         return m_autoWrap;
1094     RenderText&amp; nextRenderText = downcast&lt;RenderText&gt;(*m_nextObject);
1095     bool currentIsTextOrEmptyInline = is&lt;RenderText&gt;(*m_current.renderer()) || (is&lt;RenderInline&gt;(*m_current.renderer()) &amp;&amp; isEmptyInline(downcast&lt;RenderInline&gt;(*m_current.renderer())));
1096     if (!currentIsTextOrEmptyInline)
1097         return m_autoWrap &amp;&amp; !m_current.renderer()-&gt;isRubyRun();
1098 
1099     bool canBreakHere = !m_currentCharacterIsSpace &amp;&amp; textBeginsWithBreakablePosition(nextRenderText);
1100 
1101     // See if attempting to fit below floats creates more available width on the line.
1102     if (!m_width.fitsOnLine() &amp;&amp; !m_width.hasCommitted())
1103         m_width.fitBelowFloats(m_lineInfo.isFirstLine());
1104 
1105     bool canPlaceOnLine = m_width.fitsOnLine() || !m_autoWrapWasEverTrueOnLine;
1106 
1107     if (canPlaceOnLine &amp;&amp; canBreakHere)
1108         commitLineBreakAtCurrentWidth(nextRenderText);
1109 
1110     return canBreakHere;
1111 }
1112 
1113 inline void BreakingContext::commitAndUpdateLineBreakIfNeeded()
1114 {
1115     bool checkForBreak = canBreakAtThisPosition();
1116 
1117     if (checkForBreak &amp;&amp; !m_width.fitsOnLine(m_ignoringSpaces) &amp;&amp; !m_hangsAtEnd) {
1118         // if we have floats, try to get below them.
1119         if (m_currentCharacterIsSpace &amp;&amp; !m_ignoringSpaces &amp;&amp; m_currentStyle-&gt;collapseWhiteSpace())
1120             m_trailingObjects.clear();
1121 
1122         if (m_width.committedWidth()) {
1123             m_atEnd = true;
1124             return;
1125         }
1126 
1127         if (!m_hangsAtEnd)
1128             m_width.fitBelowFloats(m_lineInfo.isFirstLine());
1129 
1130         // |width| may have been adjusted because we got shoved down past a float (thus
1131         // giving us more room), so we need to retest, and only jump to
1132         // the end label if we still don&#39;t fit on the line. -dwh
1133         if (!m_width.fitsOnLine(m_ignoringSpaces)) {
1134             m_atEnd = true;
1135             return;
1136         }
1137     } else if (m_blockStyle.autoWrap() &amp;&amp; !m_width.fitsOnLine() &amp;&amp; !m_width.hasCommitted() &amp;&amp; !m_hangsAtEnd) {
1138         // If the container autowraps but the current child does not then we still need to ensure that it
1139         // wraps and moves below any floats.
1140         m_width.fitBelowFloats(m_lineInfo.isFirstLine());
1141     }
1142 
1143     if (!m_current.renderer()-&gt;isFloatingOrOutOfFlowPositioned()) {
1144         m_lastObject = m_current.renderer();
1145         if (m_lastObject-&gt;isReplaced() &amp;&amp; m_autoWrap &amp;&amp; !m_lastObject-&gt;isRubyRun() &amp;&amp; (!m_lastObject-&gt;isImage() || m_allowImagesToBreak) &amp;&amp; (!is&lt;RenderListMarker&gt;(*m_lastObject) || downcast&lt;RenderListMarker&gt;(*m_lastObject).isInside())) {
1146             if (m_nextObject)
1147                 commitLineBreakAtCurrentWidth(*m_nextObject);
1148             else
1149                 commitLineBreakClear();
1150         }
1151     }
1152 }
1153 
1154 inline TrailingObjects::CollapseFirstSpaceOrNot checkWhitespaceCollapsingTransitions(LineWhitespaceCollapsingState&amp; lineWhitespaceCollapsingState, const InlineIterator&amp; lBreak)
1155 {
1156     // Check to see if our last transition is a start point beyond the line break. If so,
1157     // shave it off the list, and shave off a trailing space if the previous end point doesn&#39;t
1158     // preserve whitespace.
1159     if (lBreak.renderer() &amp;&amp; lineWhitespaceCollapsingState.numTransitions() &amp;&amp; !(lineWhitespaceCollapsingState.numTransitions() % 2)) {
1160         const InlineIterator* transitions = lineWhitespaceCollapsingState.transitions().data();
1161         const InlineIterator&amp; endpoint = transitions[lineWhitespaceCollapsingState.numTransitions() - 2];
1162         const InlineIterator&amp; startpoint = transitions[lineWhitespaceCollapsingState.numTransitions() - 1];
1163         InlineIterator currpoint = endpoint;
1164         while (!currpoint.atEnd() &amp;&amp; currpoint != startpoint &amp;&amp; currpoint != lBreak)
1165             currpoint.increment();
1166         if (currpoint == lBreak) {
1167             // We hit the line break before the start point. Shave off the start point.
1168             lineWhitespaceCollapsingState.decrementNumTransitions();
1169             if (endpoint.renderer()-&gt;style().collapseWhiteSpace() &amp;&amp; endpoint.renderer()-&gt;isText()) {
1170                 lineWhitespaceCollapsingState.decrementTransitionAt(lineWhitespaceCollapsingState.numTransitions() - 1);
1171                 return TrailingObjects::DoNotCollapseFirstSpace;
1172             }
1173         }
1174     }
1175     return TrailingObjects::CollapseFirstSpace;
1176 }
1177 
1178 inline InlineIterator BreakingContext::handleEndOfLine()
1179 {
1180     if (m_lineBreak == m_resolver.position()) {
1181         if (!m_lineBreak.renderer() || !m_lineBreak.renderer()-&gt;isBR()) {
1182             // we just add as much as possible
1183             if (m_blockStyle.whiteSpace() == WhiteSpace::Pre &amp;&amp; !m_current.offset()) {
1184                 if (m_lastObject)
1185                     commitLineBreakAtCurrentWidth(*m_lastObject, m_lastObject-&gt;isText() ? m_lastObject-&gt;length() : 0);
1186                 else
1187                     commitLineBreakClear();
1188             } else if (m_lineBreak.renderer()) {
1189                 // Don&#39;t ever break in the middle of a word if we can help it.
1190                 // There&#39;s no room at all. We just have to be on this line,
1191                 // even though we&#39;ll spill out.
1192                 commitLineBreakAtCurrentWidth(*m_current.renderer(), m_current.offset());
1193             }
1194         }
1195         // make sure we consume at least one char/object.
1196         if (m_lineBreak == m_resolver.position())
1197             m_lineBreak.increment();
1198     } else if (!m_current.offset() &amp;&amp; !m_width.committedWidth() &amp;&amp; m_width.uncommittedWidth() &amp;&amp; !m_hadUncommittedWidthBeforeCurrent) {
1199         // Do not push the current object to the next line, when this line has some content, but it is still considered empty.
1200         // Empty inline elements like &lt;span&gt;&lt;/span&gt; can produce such lines and now we just ignore these break opportunities
1201         // at the start of a line, if no width has been committed yet.
1202         // Behave as if it was actually empty and consume at least one object.
1203         m_lineBreak.increment();
1204     }
1205 
1206     // Sanity check our whitespace collapsing transitions.
1207     TrailingObjects::CollapseFirstSpaceOrNot collapsed = checkWhitespaceCollapsingTransitions(m_lineWhitespaceCollapsingState, m_lineBreak);
1208 
1209     m_trailingObjects.updateWhitespaceCollapsingTransitionsForTrailingBoxes(m_lineWhitespaceCollapsingState, m_lineBreak, collapsed);
1210 
1211     // We might have made lineBreak an iterator that points past the end
1212     // of the object. Do this adjustment to make it point to the start
1213     // of the next object instead to avoid confusing the rest of the
1214     // code.
1215     if (m_lineBreak.offset()) {
1216         m_lineBreak.setOffset(m_lineBreak.offset() - 1);
1217         m_lineBreak.increment();
1218     }
1219 
1220     return m_lineBreak;
1221 }
1222 
1223 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>