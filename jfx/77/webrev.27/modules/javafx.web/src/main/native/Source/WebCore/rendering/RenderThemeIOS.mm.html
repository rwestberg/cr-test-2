<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeIOS.mm</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #import &quot;config.h&quot;
  27 #import &quot;RenderThemeIOS.h&quot;
  28 
  29 #if PLATFORM(IOS_FAMILY)
  30 
  31 #import &quot;BitmapImage.h&quot;
  32 #import &quot;CSSPrimitiveValue.h&quot;
  33 #import &quot;CSSToLengthConversionData.h&quot;
  34 #import &quot;CSSValueKeywords.h&quot;
  35 #import &quot;ColorIOS.h&quot;
  36 #import &quot;DateComponents.h&quot;
  37 #import &quot;Document.h&quot;
  38 #import &quot;File.h&quot;
  39 #import &quot;FloatRoundedRect.h&quot;
  40 #import &quot;FontCache.h&quot;
  41 #import &quot;FontCascade.h&quot;
  42 #import &quot;Frame.h&quot;
  43 #import &quot;FrameSelection.h&quot;
  44 #import &quot;FrameView.h&quot;
  45 #import &quot;GeometryUtilities.h&quot;
  46 #import &quot;Gradient.h&quot;
  47 #import &quot;GraphicsContext.h&quot;
  48 #import &quot;GraphicsContextCG.h&quot;
  49 #import &quot;HTMLAttachmentElement.h&quot;
  50 #import &quot;HTMLInputElement.h&quot;
  51 #import &quot;HTMLNames.h&quot;
  52 #import &quot;HTMLSelectElement.h&quot;
  53 #import &quot;IOSurface.h&quot;
  54 #import &quot;Icon.h&quot;
  55 #import &quot;LocalCurrentTraitCollection.h&quot;
  56 #import &quot;LocalizedDateCache.h&quot;
  57 #import &quot;NodeRenderStyle.h&quot;
  58 #import &quot;Page.h&quot;
  59 #import &quot;PaintInfo.h&quot;
  60 #import &quot;PathUtilities.h&quot;
  61 #import &quot;PlatformLocale.h&quot;
  62 #import &quot;RenderAttachment.h&quot;
  63 #import &quot;RenderObject.h&quot;
  64 #import &quot;RenderProgress.h&quot;
  65 #import &quot;RenderStyle.h&quot;
  66 #import &quot;RenderView.h&quot;
  67 #import &quot;RuntimeEnabledFeatures.h&quot;
  68 #import &quot;UTIUtilities.h&quot;
  69 #import &quot;UserAgentScripts.h&quot;
  70 #import &quot;UserAgentStyleSheets.h&quot;
  71 #import &quot;WebCoreThreadRun.h&quot;
  72 #import &lt;CoreGraphics/CoreGraphics.h&gt;
  73 #import &lt;CoreImage/CoreImage.h&gt;
  74 #import &lt;objc/runtime.h&gt;
  75 #import &lt;pal/ios/UIKitSoftLink.h&gt;
  76 #import &lt;pal/spi/cocoa/CoreTextSPI.h&gt;
  77 #import &lt;pal/spi/ios/UIKitSPI.h&gt;
  78 #import &lt;wtf/NeverDestroyed.h&gt;
  79 #import &lt;wtf/ObjCRuntimeExtras.h&gt;
  80 #import &lt;wtf/RefPtr.h&gt;
  81 #import &lt;wtf/StdLibExtras.h&gt;
  82 
  83 @interface WebCoreRenderThemeBundle : NSObject
  84 @end
  85 
  86 @implementation WebCoreRenderThemeBundle
  87 @end
  88 
  89 namespace WebCore {
  90 
  91 using namespace HTMLNames;
  92 
  93 const float ControlBaseHeight = 20;
  94 const float ControlBaseFontSize = 11;
  95 
  96 struct IOSGradient {
  97     float* start; // points to static float[4]
  98     float* end; // points to static float[4]
  99     IOSGradient(float start[4], float end[4])
 100         : start(start)
 101         , end(end)
 102     {
 103     }
 104 };
 105 
 106 typedef IOSGradient* IOSGradientRef;
 107 
 108 enum Interpolation
 109 {
 110     LinearInterpolation,
 111     ExponentialInterpolation
 112 };
 113 
 114 static void interpolateLinearGradient(void *info, const CGFloat *inData, CGFloat *outData)
 115 {
 116     IOSGradientRef gradient = static_cast&lt;IOSGradientRef&gt;(info);
 117     float alpha = inData[0];
 118     float inverse = 1.0f - alpha;
 119 
 120     outData[0] = inverse * gradient-&gt;start[0] + alpha * gradient-&gt;end[0];
 121     outData[1] = inverse * gradient-&gt;start[1] + alpha * gradient-&gt;end[1];
 122     outData[2] = inverse * gradient-&gt;start[2] + alpha * gradient-&gt;end[2];
 123     outData[3] = inverse * gradient-&gt;start[3] + alpha * gradient-&gt;end[3];
 124 }
 125 
 126 static void interpolateExponentialGradient(void *info, const CGFloat *inData, CGFloat *outData)
 127 {
 128     IOSGradientRef gradient = static_cast&lt;IOSGradientRef&gt;(info);
 129     float a = inData[0];
 130     for (int paintInfo = 0; paintInfo &lt; 4; ++paintInfo) {
 131         float end = logf(std::max(gradient-&gt;end[paintInfo], 0.01f));
 132         float start = logf(std::max(gradient-&gt;start[paintInfo], 0.01f));
 133         outData[paintInfo] = expf(start - (end + start) * a);
 134     }
 135 }
 136 
 137 static CGFunctionRef getSharedFunctionRef(IOSGradientRef gradient, Interpolation interpolation)
 138 {
 139     CGFunctionRef function = nullptr;
 140 
 141     static HashMap&lt;IOSGradientRef, CGFunctionRef&gt;* linearFunctionRefs;
 142     static HashMap&lt;IOSGradientRef, CGFunctionRef&gt;* exponentialFunctionRefs;
 143 
 144     if (interpolation == LinearInterpolation) {
 145         if (!linearFunctionRefs)
 146             linearFunctionRefs = new HashMap&lt;IOSGradientRef, CGFunctionRef&gt;;
 147         else
 148             function = linearFunctionRefs-&gt;get(gradient);
 149     
 150         if (!function) {
 151             static struct CGFunctionCallbacks linearFunctionCallbacks =  { 0, interpolateLinearGradient, 0 };
 152             linearFunctionRefs-&gt;set(gradient, function = CGFunctionCreate(gradient, 1, nullptr, 4, nullptr, &amp;linearFunctionCallbacks));
 153         }
 154 
 155         return function;
 156     }
 157 
 158     if (!exponentialFunctionRefs)
 159         exponentialFunctionRefs = new HashMap&lt;IOSGradientRef, CGFunctionRef&gt;;
 160     else
 161         function = exponentialFunctionRefs-&gt;get(gradient);
 162 
 163     if (!function) {
 164         static struct CGFunctionCallbacks exponentialFunctionCallbacks =  { 0, interpolateExponentialGradient, 0 };
 165         exponentialFunctionRefs-&gt;set(gradient, function = CGFunctionCreate(gradient, 1, 0, 4, 0, &amp;exponentialFunctionCallbacks));
 166     }
 167 
 168     return function;
 169 }
 170 
 171 static void drawAxialGradient(CGContextRef context, IOSGradientRef gradient, const FloatPoint&amp; startPoint, const FloatPoint&amp; stopPoint, Interpolation interpolation)
 172 {
 173     RetainPtr&lt;CGShadingRef&gt; shading = adoptCF(CGShadingCreateAxial(sRGBColorSpaceRef(), startPoint, stopPoint, getSharedFunctionRef(gradient, interpolation), false, false));
 174     CGContextDrawShading(context, shading.get());
 175 }
 176 
 177 static void drawRadialGradient(CGContextRef context, IOSGradientRef gradient, const FloatPoint&amp; startPoint, float startRadius, const FloatPoint&amp; stopPoint, float stopRadius, Interpolation interpolation)
 178 {
 179     RetainPtr&lt;CGShadingRef&gt; shading = adoptCF(CGShadingCreateRadial(sRGBColorSpaceRef(), startPoint, startRadius, stopPoint, stopRadius, getSharedFunctionRef(gradient, interpolation), false, false));
 180     CGContextDrawShading(context, shading.get());
 181 }
 182 
 183 enum IOSGradientType {
 184     InsetGradient,
 185     ShineGradient,
 186     ShadeGradient,
 187     ConvexGradient,
 188     ConcaveGradient,
 189     SliderTrackGradient,
 190     ReadonlySliderTrackGradient,
 191     SliderThumbOpaquePressedGradient,
 192 };
 193 
 194 static IOSGradientRef getInsetGradient()
 195 {
 196     static float end[4] = { 0 / 255.0, 0 / 255.0, 0 / 255.0, 0 };
 197     static float start[4] = { 0 / 255.0, 0 / 255.0, 0 / 255.0, 0.2 };
 198     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 199     return &amp;gradient.get();
 200 }
 201 
 202 static IOSGradientRef getShineGradient()
 203 {
 204     static float end[4] = { 1, 1, 1, 0.8 };
 205     static float start[4] = { 1, 1, 1, 0 };
 206     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 207     return &amp;gradient.get();
 208 }
 209 
 210 static IOSGradientRef getShadeGradient()
 211 {
 212     static float end[4] = { 178 / 255.0, 178 / 255.0, 178 / 255.0, 0.65 };
 213     static float start[4] = { 252 / 255.0, 252 / 255.0, 252 / 255.0, 0.65 };
 214     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 215     return &amp;gradient.get();
 216 }
 217 
 218 static IOSGradientRef getConvexGradient()
 219 {
 220     static float end[4] = { 255 / 255.0, 255 / 255.0, 255 / 255.0, 0.05 };
 221     static float start[4] = { 255 / 255.0, 255 / 255.0, 255 / 255.0, 0.43 };
 222     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 223     return &amp;gradient.get();
 224 }
 225 
 226 static IOSGradientRef getConcaveGradient()
 227 {
 228     static float end[4] = { 255 / 255.0, 255 / 255.0, 255 / 255.0, 0.46 };
 229     static float start[4] = { 255 / 255.0, 255 / 255.0, 255 / 255.0, 0 };
 230     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 231     return &amp;gradient.get();
 232 }
 233 
 234 static IOSGradientRef getSliderTrackGradient()
 235 {
 236     static float end[4] = { 132 / 255.0, 132 / 255.0, 132 / 255.0, 1 };
 237     static float start[4] = { 74 / 255.0, 77 / 255.0, 80 / 255.0, 1 };
 238     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 239     return &amp;gradient.get();
 240 }
 241 
 242 static IOSGradientRef getReadonlySliderTrackGradient()
 243 {
 244     static float end[4] = { 132 / 255.0, 132 / 255.0, 132 / 255.0, 0.4 };
 245     static float start[4] = { 74 / 255.0, 77 / 255.0, 80 /255.0, 0.4 };
 246     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 247     return &amp;gradient.get();
 248 }
 249 
 250 static IOSGradientRef getSliderThumbOpaquePressedGradient()
 251 {
 252     static float end[4] = { 144 / 255.0, 144 / 255.0, 144 / 255.0, 1};
 253     static float start[4] = { 55 / 255.0, 55 / 255.0, 55 / 255.0, 1 };
 254     static NeverDestroyed&lt;IOSGradient&gt; gradient(start, end);
 255     return &amp;gradient.get();
 256 }
 257 
 258 static IOSGradientRef gradientWithName(IOSGradientType gradientType)
 259 {
 260     switch (gradientType) {
 261     case InsetGradient:
 262         return getInsetGradient();
 263     case ShineGradient:
 264         return getShineGradient();
 265     case ShadeGradient:
 266         return getShadeGradient();
 267     case ConvexGradient:
 268         return getConvexGradient();
 269     case ConcaveGradient:
 270         return getConcaveGradient();
 271     case SliderTrackGradient:
 272         return getSliderTrackGradient();
 273     case ReadonlySliderTrackGradient:
 274         return getReadonlySliderTrackGradient();
 275     case SliderThumbOpaquePressedGradient:
 276         return getSliderThumbOpaquePressedGradient();
 277     }
 278     ASSERT_NOT_REACHED();
 279     return nullptr;
 280 }
 281 
 282 static void contentSizeCategoryDidChange(CFNotificationCenterRef, void*, CFStringRef name, const void*, CFDictionaryRef)
 283 {
 284     ASSERT_UNUSED(name, CFEqual(name, PAL::get_UIKit_UIContentSizeCategoryDidChangeNotification()));
 285     WebThreadRun(^{
 286         Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment();
 287     });
 288 }
 289 
 290 RenderThemeIOS::RenderThemeIOS()
 291 {
 292     CFNotificationCenterAddObserver(CFNotificationCenterGetLocalCenter(), this, contentSizeCategoryDidChange, (__bridge CFStringRef)PAL::get_UIKit_UIContentSizeCategoryDidChangeNotification(), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
 293 }
 294 
 295 RenderTheme&amp; RenderTheme::singleton()
 296 {
 297     static NeverDestroyed&lt;RenderThemeIOS&gt; theme;
 298     return theme;
 299 }
 300 
 301 static String&amp; _contentSizeCategory()
 302 {
 303     static NeverDestroyed&lt;String&gt; _contentSizeCategory;
 304     return _contentSizeCategory.get();
 305 }
 306 
 307 CFStringRef RenderThemeIOS::contentSizeCategory()
 308 {
 309     if (!_contentSizeCategory().isNull())
 310         return (__bridge CFStringRef)static_cast&lt;NSString*&gt;(_contentSizeCategory());
 311     return (CFStringRef)[[PAL::getUIApplicationClass() sharedApplication] preferredContentSizeCategory];
 312 }
 313 
 314 void RenderThemeIOS::setContentSizeCategory(const String&amp; contentSizeCategory)
 315 {
 316     _contentSizeCategory() = contentSizeCategory;
 317 }
 318 
 319 const Color&amp; RenderThemeIOS::shadowColor() const
 320 {
 321     static NeverDestroyed&lt;Color&gt; color(0.0f, 0.0f, 0.0f, 0.7f);
 322     return color;
 323 }
 324 
 325 FloatRect RenderThemeIOS::addRoundedBorderClip(const RenderObject&amp; box, GraphicsContext&amp; context, const IntRect&amp; rect)
 326 {
 327     // To fix inner border bleeding issues &lt;rdar://problem/9812507&gt;, we clip to the outer border and assert that
 328     // the border is opaque or transparent, unless we&#39;re checked because checked radio/checkboxes show no bleeding.
 329     auto&amp; style = box.style();
 330     RoundedRect border = isChecked(box) ? style.getRoundedInnerBorderFor(rect) : style.getRoundedBorderFor(rect);
 331 
 332     if (border.isRounded())
 333         context.clipRoundedRect(FloatRoundedRect(border));
 334     else
 335         context.clip(border.rect());
 336 
 337     if (isChecked(box)) {
 338         ASSERT(style.visitedDependentColor(CSSPropertyBorderTopColor).alpha() % 255 == 0);
 339         ASSERT(style.visitedDependentColor(CSSPropertyBorderRightColor).alpha() % 255 == 0);
 340         ASSERT(style.visitedDependentColor(CSSPropertyBorderBottomColor).alpha() % 255 == 0);
 341         ASSERT(style.visitedDependentColor(CSSPropertyBorderLeftColor).alpha() % 255 == 0);
 342     }
 343 
 344     return border.rect();
 345 }
 346 
 347 void RenderThemeIOS::adjustCheckboxStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 348 {
 349     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
 350         return;
 351 
 352     int size = std::max(style.computedFontPixelSize(), 10U);
 353     style.setWidth({ size, Fixed });
 354     style.setHeight({ size, Fixed });
 355 }
 356 
 357 static CGPoint shortened(CGPoint start, CGPoint end, float width)
 358 {
 359     float x = end.x - start.x;
 360     float y = end.y - start.y;
 361     float ratio = (!x &amp;&amp; !y) ? 0 : width / sqrtf(x * x + y * y);
 362     return CGPointMake(start.x + x * ratio, start.y + y * ratio);
 363 }
 364 
 365 static void drawJoinedLines(CGContextRef context, const Vector&lt;CGPoint&gt;&amp; points, CGLineCap lineCap, float lineWidth, Color strokeColor)
 366 {
 367     CGContextSetLineWidth(context, lineWidth);
 368     CGContextSetStrokeColorWithColor(context, cachedCGColor(strokeColor));
 369     CGContextSetShouldAntialias(context, true);
 370     CGContextBeginPath(context);
 371     CGContextSetLineCap(context, lineCap);
 372     CGContextMoveToPoint(context, points[0].x, points[0].y);
 373     
 374     for (unsigned i = 1; i &lt; points.size(); ++i)
 375         CGContextAddLineToPoint(context, points[i].x, points[i].y);
 376 
 377     CGContextStrokePath(context);
 378 }
 379 
 380 bool RenderThemeIOS::paintCheckboxDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 381 {
 382     bool checked = isChecked(box);
 383     bool indeterminate = isIndeterminate(box);
 384     CGContextRef cgContext = paintInfo.context().platformContext();
 385     GraphicsContextStateSaver stateSaver { paintInfo.context() };
 386 
 387     if (checked || indeterminate) {
 388         auto border = box.style().getRoundedBorderFor(rect);
 389         paintInfo.context().fillRoundedRect(border.pixelSnappedRoundedRectForPainting(box.document().deviceScaleFactor()), Color(0.0f, 0.0f, 0.0f, 0.8f));
 390 
 391         auto clip = addRoundedBorderClip(box, paintInfo.context(), rect);
 392         auto width = clip.width();
 393         auto height = clip.height();
 394         drawAxialGradient(cgContext, gradientWithName(ConcaveGradient), clip.location(), FloatPoint { clip.x(), clip.maxY() }, LinearInterpolation);
 395 
 396         constexpr float thicknessRatio = 2 / 14.0;
 397         float lineWidth = std::min(width, height) * 2.0f * thicknessRatio;
 398 
 399         Vector&lt;CGPoint, 3&gt; line;
 400         Vector&lt;CGPoint, 3&gt; shadow;
 401         if (checked) {
 402             constexpr CGSize size { 14.0f, 14.0f };
 403             constexpr CGPoint pathRatios[] = {
 404                 { 2.5f / size.width, 7.5f / size.height },
 405                 { 5.5f / size.width, 10.5f / size.height },
 406                 { 11.5f / size.width, 2.5f / size.height }
 407             };
 408 
 409             line.uncheckedAppend(CGPointMake(clip.x() + width * pathRatios[0].x, clip.y() + height * pathRatios[0].y));
 410             line.uncheckedAppend(CGPointMake(clip.x() + width * pathRatios[1].x, clip.y() + height * pathRatios[1].y));
 411             line.uncheckedAppend(CGPointMake(clip.x() + width * pathRatios[2].x, clip.y() + height * pathRatios[2].y));
 412 
 413             shadow.uncheckedAppend(shortened(line[0], line[1], lineWidth / 4.0f));
 414             shadow.uncheckedAppend(line[1]);
 415             shadow.uncheckedAppend(shortened(line[2], line[1], lineWidth / 4.0f));
 416         } else {
 417             line.uncheckedAppend(CGPointMake(clip.x() + 3.5, clip.center().y()));
 418             line.uncheckedAppend(CGPointMake(clip.maxX() - 3.5, clip.center().y()));
 419 
 420             shadow.uncheckedAppend(shortened(line[0], line[1], lineWidth / 4.0f));
 421             shadow.uncheckedAppend(shortened(line[1], line[0], lineWidth / 4.0f));
 422         }
 423 
 424         lineWidth = std::max&lt;float&gt;(lineWidth, 1);
 425         drawJoinedLines(cgContext, Vector&lt;CGPoint&gt; { WTFMove(shadow) }, kCGLineCapSquare, lineWidth, Color { 0.0f, 0.0f, 0.0f, 0.7f });
 426 
 427         lineWidth = std::max&lt;float&gt;(std::min(width, height) * thicknessRatio, 1);
 428         drawJoinedLines(cgContext, Vector&lt;CGPoint&gt; { WTFMove(line) }, kCGLineCapButt, lineWidth, Color { 1.0f, 1.0f, 1.0f, 240 / 255.0f });
 429     } else {
 430         auto clip = addRoundedBorderClip(box, paintInfo.context(), rect);
 431         auto width = clip.width();
 432         auto height = clip.height();
 433         FloatPoint bottomCenter { clip.x() + width / 2.0f, clip.maxY() };
 434 
 435         drawAxialGradient(cgContext, gradientWithName(ShadeGradient), clip.location(), FloatPoint { clip.x(), clip.maxY() }, LinearInterpolation);
 436         drawRadialGradient(cgContext, gradientWithName(ShineGradient), bottomCenter, 0, bottomCenter, sqrtf((width * width) / 4.0f + height * height), ExponentialInterpolation);
 437     }
 438     return false;
 439 }
 440 
 441 int RenderThemeIOS::baselinePosition(const RenderBox&amp; box) const
 442 {
 443     if (box.style().appearance() == CheckboxPart || box.style().appearance() == RadioPart)
 444         return box.marginTop() + box.height() - 2; // The baseline is 2px up from the bottom of the checkbox/radio in AppKit.
 445     if (box.style().appearance() == MenulistPart)
 446         return box.marginTop() + box.height() - 5; // This is to match AppKit. There might be a better way to calculate this though.
 447     return RenderTheme::baselinePosition(box);
 448 }
 449 
 450 bool RenderThemeIOS::isControlStyled(const RenderStyle&amp; style, const BorderData&amp; border, const FillLayer&amp; background, const Color&amp; backgroundColor) const
 451 {
 452     // Buttons and MenulistButtons are styled if they contain a background image.
 453     if (style.appearance() == PushButtonPart || style.appearance() == MenulistButtonPart)
 454         return !style.visitedDependentColor(CSSPropertyBackgroundColor).isVisible() || style.backgroundLayers().hasImage();
 455 
 456     if (style.appearance() == TextFieldPart || style.appearance() == TextAreaPart)
 457         return style.backgroundLayers() != background;
 458 
 459     return RenderTheme::isControlStyled(style, border, background, backgroundColor);
 460 }
 461 
 462 void RenderThemeIOS::adjustRadioStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 463 {
 464     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
 465         return;
 466 
 467     int size = std::max(style.computedFontPixelSize(), 10U);
 468     style.setWidth({ size, Fixed });
 469     style.setHeight({ size, Fixed });
 470     style.setBorderRadius({ size / 2, size / 2 });
 471 }
 472 
 473 bool RenderThemeIOS::paintRadioDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 474 {
 475     GraphicsContextStateSaver stateSaver(paintInfo.context());
 476     CGContextRef cgContext = paintInfo.context().platformContext();
 477 
 478     auto drawShadeAndShineGradients = [&amp;](auto clip) {
 479         FloatPoint bottomCenter(clip.x() + clip.width() / 2.0, clip.maxY());
 480         drawAxialGradient(cgContext, gradientWithName(ShadeGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
 481         drawRadialGradient(cgContext, gradientWithName(ShineGradient), bottomCenter, 0, bottomCenter, std::max(clip.width(), clip.height()), ExponentialInterpolation);
 482     };
 483 
 484     if (isChecked(box)) {
 485         auto border = box.style().getRoundedBorderFor(rect);
 486         paintInfo.context().fillRoundedRect(border.pixelSnappedRoundedRectForPainting(box.document().deviceScaleFactor()), Color(0.0f, 0.0f, 0.0f, 0.8f));
 487 
 488         auto clip = addRoundedBorderClip(box, paintInfo.context(), rect);
 489         drawAxialGradient(cgContext, gradientWithName(ConcaveGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
 490 
 491         // The inner circle is 6 / 14 the size of the surrounding circle, 
 492         // leaving 8 / 14 around it. (8 / 14) / 2 = 2 / 7.
 493 
 494         static const float InnerInverseRatio = 2 / 7.0;
 495 
 496         clip.inflateX(-clip.width() * InnerInverseRatio);
 497         clip.inflateY(-clip.height() * InnerInverseRatio);
 498 
 499         paintInfo.context().drawRaisedEllipse(clip, Color::white, shadowColor());
 500 
 501         FloatSize radius(clip.width() / 2.0f, clip.height() / 2.0f);
 502         paintInfo.context().clipRoundedRect(FloatRoundedRect(clip, radius, radius, radius, radius));
 503         drawShadeAndShineGradients(clip);
 504     } else {
 505         auto clip = addRoundedBorderClip(box, paintInfo.context(), rect);
 506         drawShadeAndShineGradients(clip);
 507     }
 508     return false;
 509 }
 510 
 511 bool RenderThemeIOS::paintTextFieldDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 512 {
 513     auto&amp; style = box.style();
 514     FloatPoint point(rect.x() + style.borderLeftWidth(), rect.y() + style.borderTopWidth());
 515 
 516     GraphicsContextStateSaver stateSaver(paintInfo.context());
 517 
 518     paintInfo.context().clipRoundedRect(style.getRoundedBorderFor(LayoutRect(rect)).pixelSnappedRoundedRectForPainting(box.document().deviceScaleFactor()));
 519 
 520     // This gradient gets drawn black when printing.
 521     // Do not draw the gradient if there is no visible top border.
 522     bool topBorderIsInvisible = !style.hasBorder() || !style.borderTopWidth() || style.borderTopIsTransparent();
 523     if (!box.view().printing() &amp;&amp; !topBorderIsInvisible)
 524         drawAxialGradient(paintInfo.context().platformContext(), gradientWithName(InsetGradient), point, FloatPoint(CGPointMake(point.x(), point.y() + 3.0f)), LinearInterpolation);
 525     return false;
 526 }
 527 
 528 bool RenderThemeIOS::paintTextAreaDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 529 {
 530     return paintTextFieldDecorations(box, paintInfo, rect);
 531 }
 532 
 533 const int MenuListMinHeight = 15;
 534 
 535 const float MenuListBaseHeight = 20;
 536 const float MenuListBaseFontSize = 11;
 537 
 538 const float MenuListArrowWidth = 7;
 539 const float MenuListArrowHeight = 6;
 540 const float MenuListButtonPaddingAfter = 19;
 541 
 542 LengthBox RenderThemeIOS::popupInternalPaddingBox(const RenderStyle&amp; style) const
 543 {
 544     if (style.appearance() == MenulistButtonPart) {
 545         if (style.direction() == TextDirection::RTL)
 546             return { 0, 0, 0, static_cast&lt;int&gt;(MenuListButtonPaddingAfter + style.borderTopWidth()) };
 547         return { 0, static_cast&lt;int&gt;(MenuListButtonPaddingAfter + style.borderTopWidth()), 0, 0 };
 548     }
 549     return { 0, 0, 0, 0 };
 550 }
 551 
 552 void RenderThemeIOS::adjustRoundBorderRadius(RenderStyle&amp; style, RenderBox&amp; box)
 553 {
 554     if (style.appearance() == NoControlPart || style.backgroundLayers().hasImage())
 555         return;
 556 
 557     // FIXME: We should not be relying on border radius for the appearance of our controls &lt;rdar://problem/7675493&gt;.
 558     style.setBorderRadius({ { std::min(box.width(), box.height()) / 2, Fixed }, { box.height() / 2, Fixed } });
 559 }
 560 
 561 static void applyCommonButtonPaddingToStyle(RenderStyle&amp; style, const Element&amp; element)
 562 {
 563     Document&amp; document = element.document();
 564     auto emSize = CSSPrimitiveValue::create(0.5, CSSPrimitiveValue::CSS_EMS);
 565     int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData(&amp;style, document.renderStyle(), document.renderView(), document.frame()-&gt;pageZoomFactor()));
 566     style.setPaddingBox(LengthBox(0, pixels, 0, pixels));
 567 }
 568 
 569 static void adjustSelectListButtonStyle(RenderStyle&amp; style, const Element&amp; element)
 570 {
 571     // Enforce &quot;padding: 0 0.5em&quot;.
 572     applyCommonButtonPaddingToStyle(style, element);
 573 
 574     // Enforce &quot;line-height: normal&quot;.
 575     style.setLineHeight(Length(-100.0, Percent));
 576 }
 577     
 578 class RenderThemeMeasureTextClient : public MeasureTextClient {
 579 public:
 580     RenderThemeMeasureTextClient(const FontCascade&amp; font, const RenderStyle&amp; style)
 581         : m_font(font)
 582         , m_style(style)
 583     {
 584     }
 585     float measureText(const String&amp; string) const override
 586     {
 587         TextRun run = RenderBlock::constructTextRun(string, m_style);
 588         return m_font.width(run);
 589     }
 590 private:
 591     const FontCascade&amp; m_font;
 592     const RenderStyle&amp; m_style;
 593 };
 594 
 595 static void adjustInputElementButtonStyle(RenderStyle&amp; style, const HTMLInputElement&amp; inputElement)
 596 {
 597     // Always Enforce &quot;padding: 0 0.5em&quot;.
 598     applyCommonButtonPaddingToStyle(style, inputElement);
 599 
 600     // Don&#39;t adjust the style if the width is specified.
 601     if (style.width().isFixed() &amp;&amp; style.width().value() &gt; 0)
 602         return;
 603 
 604     // Don&#39;t adjust for unsupported date input types.
 605     DateComponents::Type dateType = inputElement.dateType();
 606     if (dateType == DateComponents::Invalid || dateType == DateComponents::Week)
 607         return;
 608 
 609     // Enforce the width and set the box-sizing to content-box to not conflict with the padding.
 610     FontCascade font = style.fontCascade();
 611     
 612     float maximumWidth = localizedDateCache().maximumWidthForDateType(dateType, font, RenderThemeMeasureTextClient(font, style));
 613 
 614     ASSERT(maximumWidth &gt;= 0);
 615 
 616     if (maximumWidth &gt; 0) {
 617         int width = static_cast&lt;int&gt;(maximumWidth + MenuListButtonPaddingAfter);
 618         style.setWidth(Length(width, Fixed));
 619         style.setBoxSizing(BoxSizing::ContentBox);
 620     }
 621 }
 622 
 623 void RenderThemeIOS::adjustMenuListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const
 624 {
 625     // Set the min-height to be at least MenuListMinHeight.
 626     if (style.height().isAuto())
 627         style.setMinHeight(Length(std::max(MenuListMinHeight, static_cast&lt;int&gt;(MenuListBaseHeight / MenuListBaseFontSize * style.fontDescription().computedSize())), Fixed));
 628     else
 629         style.setMinHeight(Length(MenuListMinHeight, Fixed));
 630 
 631     if (!element)
 632         return;
 633 
 634     // Enforce some default styles in the case that this is a non-multiple &lt;select&gt; element,
 635     // or a date input. We don&#39;t force these if this is just an element with
 636     // &quot;-webkit-appearance: menulist-button&quot;.
 637     if (is&lt;HTMLSelectElement&gt;(*element) &amp;&amp; !element-&gt;hasAttributeWithoutSynchronization(HTMLNames::multipleAttr))
 638         adjustSelectListButtonStyle(style, *element);
 639     else if (is&lt;HTMLInputElement&gt;(*element))
 640         adjustInputElementButtonStyle(style, downcast&lt;HTMLInputElement&gt;(*element));
 641 }
 642 
 643 bool RenderThemeIOS::paintMenuListButtonDecorations(const RenderBox&amp; box, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 644 {
 645     auto&amp; style = box.style();
 646     bool isRTL = style.direction() == TextDirection::RTL;
 647     float borderTopWidth = style.borderTopWidth();
 648     FloatRect clip(rect.x() + style.borderLeftWidth(), rect.y() + style.borderTopWidth(), rect.width() - style.borderLeftWidth() - style.borderRightWidth(), rect.height() - style.borderTopWidth() - style.borderBottomWidth());
 649     CGContextRef cgContext = paintInfo.context().platformContext();
 650 
 651     float adjustLeft = 0.5;
 652     float adjustRight = 0.5;
 653     float adjustTop = 0.5;
 654     float adjustBottom = 0.5;
 655 
 656     // Paint title portion.
 657     {
 658         float leftInset = isRTL ? MenuListButtonPaddingAfter : 0;
 659         FloatRect titleClip(clip.x() + leftInset - adjustLeft, clip.y() - adjustTop, clip.width() - MenuListButtonPaddingAfter + adjustLeft, clip.height() + adjustTop + adjustBottom);
 660 
 661         GraphicsContextStateSaver stateSaver(paintInfo.context());
 662 
 663         FloatSize topLeftRadius;
 664         FloatSize topRightRadius;
 665         FloatSize bottomLeftRadius;
 666         FloatSize bottomRightRadius;
 667 
 668         if (isRTL) {
 669             topRightRadius = FloatSize(valueForLength(style.borderTopRightRadius().width, rect.width()) - style.borderRightWidth(), valueForLength(style.borderTopRightRadius().height, rect.height()) - style.borderTopWidth());
 670             bottomRightRadius = FloatSize(valueForLength(style.borderBottomRightRadius().width, rect.width()) - style.borderRightWidth(), valueForLength(style.borderBottomRightRadius().height, rect.height()) - style.borderBottomWidth());
 671         } else {
 672             topLeftRadius = FloatSize(valueForLength(style.borderTopLeftRadius().width, rect.width()) - style.borderLeftWidth(), valueForLength(style.borderTopLeftRadius().height, rect.height()) - style.borderTopWidth());
 673             bottomLeftRadius = FloatSize(valueForLength(style.borderBottomLeftRadius().width, rect.width()) - style.borderLeftWidth(), valueForLength(style.borderBottomLeftRadius().height, rect.height()) - style.borderBottomWidth());
 674         }
 675 
 676         paintInfo.context().clipRoundedRect(FloatRoundedRect(titleClip,
 677             topLeftRadius, topRightRadius,
 678             bottomLeftRadius, bottomRightRadius));
 679 
 680         drawAxialGradient(cgContext, gradientWithName(ShadeGradient), titleClip.location(), FloatPoint(titleClip.x(), titleClip.maxY()), LinearInterpolation);
 681         drawAxialGradient(cgContext, gradientWithName(ShineGradient), FloatPoint(titleClip.x(), titleClip.maxY()), titleClip.location(), ExponentialInterpolation);
 682     }
 683 
 684     // Draw the separator after the initial padding.
 685 
 686     float separatorPosition = isRTL ? (clip.x() + MenuListButtonPaddingAfter) : (clip.maxX() - MenuListButtonPaddingAfter);
 687 
 688     box.drawLineForBoxSide(paintInfo.context(), FloatRect(FloatPoint(separatorPosition - borderTopWidth, clip.y()), FloatPoint(separatorPosition, clip.maxY())), BSRight, style.visitedDependentColor(CSSPropertyBorderTopColor), style.borderTopStyle(), 0, 0);
 689 
 690     FloatRect buttonClip;
 691     if (isRTL)
 692         buttonClip = FloatRect(clip.x() - adjustTop, clip.y() - adjustTop, MenuListButtonPaddingAfter + adjustTop + adjustLeft, clip.height() + adjustTop + adjustBottom);
 693     else
 694         buttonClip = FloatRect(separatorPosition - adjustTop, clip.y() - adjustTop, MenuListButtonPaddingAfter + adjustTop + adjustRight, clip.height() + adjustTop + adjustBottom);
 695 
 696     // Now paint the button portion.
 697     {
 698         GraphicsContextStateSaver stateSaver(paintInfo.context());
 699 
 700         FloatSize topLeftRadius;
 701         FloatSize topRightRadius;
 702         FloatSize bottomLeftRadius;
 703         FloatSize bottomRightRadius;
 704 
 705         if (isRTL) {
 706             topLeftRadius = FloatSize(valueForLength(style.borderTopLeftRadius().width, rect.width()) - style.borderLeftWidth(), valueForLength(style.borderTopLeftRadius().height, rect.height()) - style.borderTopWidth());
 707             bottomLeftRadius = FloatSize(valueForLength(style.borderBottomLeftRadius().width, rect.width()) - style.borderLeftWidth(), valueForLength(style.borderBottomLeftRadius().height, rect.height()) - style.borderBottomWidth());
 708         } else {
 709             topRightRadius = FloatSize(valueForLength(style.borderTopRightRadius().width, rect.width()) - style.borderRightWidth(), valueForLength(style.borderTopRightRadius().height, rect.height()) - style.borderTopWidth());
 710             bottomRightRadius = FloatSize(valueForLength(style.borderBottomRightRadius().width, rect.width()) - style.borderRightWidth(), valueForLength(style.borderBottomRightRadius().height, rect.height()) - style.borderBottomWidth());
 711         }
 712 
 713         paintInfo.context().clipRoundedRect(FloatRoundedRect(buttonClip,
 714             topLeftRadius, topRightRadius,
 715             bottomLeftRadius, bottomRightRadius));
 716 
 717         paintInfo.context().fillRect(buttonClip, style.visitedDependentColor(CSSPropertyBorderTopColor));
 718 
 719         drawAxialGradient(cgContext, gradientWithName(isFocused(box) &amp;&amp; !isReadOnlyControl(box) ? ConcaveGradient : ConvexGradient), buttonClip.location(), FloatPoint(buttonClip.x(), buttonClip.maxY()), LinearInterpolation);
 720     }
 721 
 722     // Paint Indicators.
 723 
 724     if (box.isMenuList() &amp;&amp; downcast&lt;HTMLSelectElement&gt;(box.element())-&gt;multiple()) {
 725         int size = 2;
 726         int count = 3;
 727         int padding = 3;
 728 
 729         FloatRect ellipse(buttonClip.x() + (buttonClip.width() - count * (size + padding) + padding) / 2.0, buttonClip.maxY() - 10.0, size, size);
 730 
 731         for (int i = 0; i &lt; count; ++i) {
 732             paintInfo.context().drawRaisedEllipse(ellipse, Color::white, Color(0.0f, 0.0f, 0.0f, 0.5f));
 733             ellipse.move(size + padding, 0);
 734         }
 735     }  else {
 736         float centerX = floorf(buttonClip.x() + buttonClip.width() / 2.0) - 0.5;
 737         float centerY = floorf(buttonClip.y() + buttonClip.height() * 3.0 / 8.0);
 738 
 739         Vector&lt;FloatPoint&gt; arrow = {
 740             { centerX - MenuListArrowWidth / 2, centerY },
 741             { centerX + MenuListArrowWidth / 2, centerY },
 742             { centerX, centerY + MenuListArrowHeight }
 743         };
 744 
 745         Vector&lt;FloatPoint&gt; shadow = {
 746             { arrow[0].x(), arrow[0].y() + 1 },
 747             { arrow[1].x(), arrow[1].y() + 1 },
 748             { arrow[2].x(), arrow[2].y() + 1 }
 749         };
 750 
 751         float opacity = isReadOnlyControl(box) ? 0.2 : 0.5;
 752         paintInfo.context().setStrokeColor(Color(0.0f, 0.0f, 0.0f, opacity));
 753         paintInfo.context().setFillColor(Color(0.0f, 0.0f, 0.0f, opacity));
 754         paintInfo.context().drawPath(Path::polygonPathFromPoints(shadow));
 755 
 756         paintInfo.context().setStrokeColor(Color::white);
 757         paintInfo.context().setFillColor(Color::white);
 758         paintInfo.context().drawPath(Path::polygonPathFromPoints(arrow));
 759     }
 760 
 761     return false;
 762 }
 763 
 764 const CGFloat kTrackThickness = 4.0;
 765 const CGFloat kTrackRadius = kTrackThickness / 2.0;
 766 const int kDefaultSliderThumbSize = 16;
 767 
 768 void RenderThemeIOS::adjustSliderTrackStyle(StyleResolver&amp; selector, RenderStyle&amp; style, const Element* element) const
 769 {
 770     RenderTheme::adjustSliderTrackStyle(selector, style, element);
 771 
 772     // FIXME: We should not be relying on border radius for the appearance of our controls &lt;rdar://problem/7675493&gt;.
 773     int radius = static_cast&lt;int&gt;(kTrackRadius);
 774     style.setBorderRadius({ { radius, Fixed }, { radius, Fixed } });
 775 }
 776 
 777 bool RenderThemeIOS::paintSliderTrack(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 778 {
 779     IntRect trackClip = rect;
 780     auto&amp; style = box.style();
 781 
 782     bool isHorizontal = true;
 783     switch (style.appearance()) {
 784     case SliderHorizontalPart:
 785         isHorizontal = true;
 786         // Inset slightly so the thumb covers the edge.
 787         if (trackClip.width() &gt; 2) {
 788             trackClip.setWidth(trackClip.width() - 2);
 789             trackClip.setX(trackClip.x() + 1);
 790         }
 791         trackClip.setHeight(static_cast&lt;int&gt;(kTrackThickness));
 792         trackClip.setY(rect.y() + rect.height() / 2 - kTrackThickness / 2);
 793         break;
 794     case SliderVerticalPart:
 795         isHorizontal = false;
 796         // Inset slightly so the thumb covers the edge.
 797         if (trackClip.height() &gt; 2) {
 798             trackClip.setHeight(trackClip.height() - 2);
 799             trackClip.setY(trackClip.y() + 1);
 800         }
 801         trackClip.setWidth(kTrackThickness);
 802         trackClip.setX(rect.x() + rect.width() / 2 - kTrackThickness / 2);
 803         break;
 804     default:
 805         ASSERT_NOT_REACHED();
 806     }
 807 
 808     ASSERT(trackClip.width() &gt;= 0);
 809     ASSERT(trackClip.height() &gt;= 0);
 810     CGFloat cornerWidth = trackClip.width() &lt; kTrackThickness ? trackClip.width() / 2.0f : kTrackRadius;
 811     CGFloat cornerHeight = trackClip.height() &lt; kTrackThickness ? trackClip.height() / 2.0f : kTrackRadius;
 812 
 813     bool readonly = isReadOnlyControl(box);
 814 
 815 #if ENABLE(DATALIST_ELEMENT)
 816     paintSliderTicks(box, paintInfo, trackClip);
 817 #endif
 818 
 819     // Draw the track gradient.
 820     {
 821         GraphicsContextStateSaver stateSaver(paintInfo.context());
 822 
 823         IntSize cornerSize(cornerWidth, cornerHeight);
 824         FloatRoundedRect innerBorder(trackClip, cornerSize, cornerSize, cornerSize, cornerSize);
 825         paintInfo.context().clipRoundedRect(innerBorder);
 826 
 827         CGContextRef cgContext = paintInfo.context().platformContext();
 828         IOSGradientRef gradient = readonly ? gradientWithName(ReadonlySliderTrackGradient) : gradientWithName(SliderTrackGradient);
 829         if (isHorizontal)
 830             drawAxialGradient(cgContext, gradient, trackClip.location(), FloatPoint(trackClip.x(), trackClip.maxY()), LinearInterpolation);
 831         else
 832             drawAxialGradient(cgContext, gradient, trackClip.location(), FloatPoint(trackClip.maxX(), trackClip.y()), LinearInterpolation);
 833     }
 834 
 835     // Draw the track border.
 836     {
 837         GraphicsContextStateSaver stateSaver(paintInfo.context());
 838 
 839         CGContextRef cgContext = paintInfo.context().platformContext();
 840         if (readonly)
 841             paintInfo.context().setStrokeColor(Color(178, 178, 178));
 842         else
 843             paintInfo.context().setStrokeColor(Color(76, 76, 76));
 844 
 845         RetainPtr&lt;CGMutablePathRef&gt; roundedRectPath = adoptCF(CGPathCreateMutable());
 846         CGPathAddRoundedRect(roundedRectPath.get(), 0, trackClip, cornerWidth, cornerHeight);
 847         CGContextAddPath(cgContext, roundedRectPath.get());
 848         CGContextSetLineWidth(cgContext, 1);
 849         CGContextStrokePath(cgContext);
 850     }
 851 
 852     return false;
 853 }
 854 
 855 void RenderThemeIOS::adjustSliderThumbSize(RenderStyle&amp; style, const Element*) const
 856 {
 857     if (style.appearance() != SliderThumbHorizontalPart &amp;&amp; style.appearance() != SliderThumbVerticalPart)
 858         return;
 859 
 860     // Enforce &quot;border-radius: 50%&quot;.
 861     style.setBorderRadius({ { 50, Percent }, { 50, Percent } });
 862 
 863     // Enforce a 16x16 size if no size is provided.
 864     if (style.width().isIntrinsicOrAuto() || style.height().isAuto()) {
 865         style.setWidth({ kDefaultSliderThumbSize, Fixed });
 866         style.setHeight({ kDefaultSliderThumbSize, Fixed });
 867     }
 868 }
 869 
 870 bool RenderThemeIOS::paintSliderThumbDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 871 {
 872     GraphicsContextStateSaver stateSaver(paintInfo.context());
 873     FloatRect clip = addRoundedBorderClip(box, paintInfo.context(), rect);
 874 
 875     CGContextRef cgContext = paintInfo.context().platformContext();
 876     FloatPoint bottomCenter(clip.x() + clip.width() / 2.0f, clip.maxY());
 877     if (isPressed(box))
 878         drawAxialGradient(cgContext, gradientWithName(SliderThumbOpaquePressedGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
 879     else {
 880         drawAxialGradient(cgContext, gradientWithName(ShadeGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
 881         drawRadialGradient(cgContext, gradientWithName(ShineGradient), bottomCenter, 0.0f, bottomCenter, std::max(clip.width(), clip.height()), ExponentialInterpolation);
 882     }
 883 
 884     return false;
 885 }
 886 
 887 Seconds RenderThemeIOS::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
 888 {
 889     return 0_s;
 890 }
 891 
 892 Seconds RenderThemeIOS::animationDurationForProgressBar(RenderProgress&amp;) const
 893 {
 894     return 0_s;
 895 }
 896 
 897 bool RenderThemeIOS::paintProgressBar(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 898 {
 899     if (!is&lt;RenderProgress&gt;(renderer))
 900         return true;
 901 
 902     const int progressBarHeight = 9;
 903     const float verticalOffset = (rect.height() - progressBarHeight) / 2.0;
 904 
 905     GraphicsContextStateSaver stateSaver(paintInfo.context());
 906     if (rect.width() &lt; 10 || rect.height() &lt; 9) {
 907         // The rect is smaller than the standard progress bar. We clip to the element&#39;s rect to avoid
 908         // leaking pixels outside the repaint rect.
 909         paintInfo.context().clip(rect);
 910     }
 911 
 912     // 1) Draw the progress bar track.
 913     // 1.1) Draw the white background with grey gradient border.
 914     GraphicsContext&amp; context = paintInfo.context();
 915     context.setStrokeThickness(0.68);
 916     context.setStrokeStyle(SolidStroke);
 917 
 918     const float verticalRenderingPosition = rect.y() + verticalOffset;
 919     auto strokeGradient = Gradient::create(Gradient::LinearData { FloatPoint(rect.x(), verticalRenderingPosition), FloatPoint(rect.x(), verticalRenderingPosition + progressBarHeight - 1) });
 920     strokeGradient-&gt;addColorStop(0.0, Color(0x8d, 0x8d, 0x8d));
 921     strokeGradient-&gt;addColorStop(0.45, Color(0xee, 0xee, 0xee));
 922     strokeGradient-&gt;addColorStop(0.55, Color(0xee, 0xee, 0xee));
 923     strokeGradient-&gt;addColorStop(1.0, Color(0x8d, 0x8d, 0x8d));
 924     context.setStrokeGradient(WTFMove(strokeGradient));
 925 
 926     context.setFillColor(Color(255, 255, 255));
 927 
 928     Path trackPath;
 929     FloatRect trackRect(rect.x() + 0.25, verticalRenderingPosition + 0.25, rect.width() - 0.5, progressBarHeight - 0.5);
 930     FloatSize roundedCornerRadius(5, 4);
 931     trackPath.addRoundedRect(trackRect, roundedCornerRadius);
 932     context.drawPath(trackPath);
 933 
 934     // 1.2) Draw top gradient on the upper half. It is supposed to overlay the fill from the background and darker the stroked path.
 935     FloatRect border(rect.x(), rect.y() + verticalOffset, rect.width(), progressBarHeight);
 936     paintInfo.context().clipRoundedRect(FloatRoundedRect(border, roundedCornerRadius, roundedCornerRadius, roundedCornerRadius, roundedCornerRadius));
 937 
 938     float upperGradientHeight = progressBarHeight / 2.;
 939     auto upperGradient = Gradient::create(Gradient::LinearData { FloatPoint(rect.x(), verticalRenderingPosition + 0.5), FloatPoint(rect.x(), verticalRenderingPosition + upperGradientHeight - 1.5) });
 940     upperGradient-&gt;addColorStop(0.0, Color(133, 133, 133, 188));
 941     upperGradient-&gt;addColorStop(1.0, Color(18, 18, 18, 51));
 942     context.setFillGradient(WTFMove(upperGradient));
 943 
 944     context.fillRect(FloatRect(rect.x(), verticalRenderingPosition, rect.width(), upperGradientHeight));
 945 
 946     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderer);
 947     if (renderProgress.isDeterminate()) {
 948         // 2) Draw the progress bar.
 949         double position = clampTo(renderProgress.position(), 0.0, 1.0);
 950         double barWidth = position * rect.width();
 951         auto barGradient = Gradient::create(Gradient::LinearData { FloatPoint(rect.x(), verticalRenderingPosition + 0.5), FloatPoint(rect.x(), verticalRenderingPosition + progressBarHeight - 1) });
 952         barGradient-&gt;addColorStop(0.0, Color(195, 217, 247));
 953         barGradient-&gt;addColorStop(0.45, Color(118, 164, 228));
 954         barGradient-&gt;addColorStop(0.49, Color(118, 164, 228));
 955         barGradient-&gt;addColorStop(0.51, Color(36, 114, 210));
 956         barGradient-&gt;addColorStop(0.55, Color(36, 114, 210));
 957         barGradient-&gt;addColorStop(1.0, Color(57, 142, 244));
 958         context.setFillGradient(WTFMove(barGradient));
 959 
 960         auto barStrokeGradient = Gradient::create(Gradient::LinearData { FloatPoint(rect.x(), verticalRenderingPosition), FloatPoint(rect.x(), verticalRenderingPosition + progressBarHeight - 1) });
 961         barStrokeGradient-&gt;addColorStop(0.0, Color(95, 107, 183));
 962         barStrokeGradient-&gt;addColorStop(0.5, Color(66, 106, 174, 240));
 963         barStrokeGradient-&gt;addColorStop(1.0, Color(38, 104, 166));
 964         context.setStrokeGradient(WTFMove(barStrokeGradient));
 965 
 966         Path barPath;
 967         int left = rect.x();
 968         if (!renderProgress.style().isLeftToRightDirection())
 969             left = rect.maxX() - barWidth;
 970         FloatRect barRect(left + 0.25, verticalRenderingPosition + 0.25, std::max(barWidth - 0.5, 0.0), progressBarHeight - 0.5);
 971         barPath.addRoundedRect(barRect, roundedCornerRadius);
 972         context.drawPath(barPath);
 973     }
 974 
 975     return false;
 976 }
 977 
 978 #if ENABLE(DATALIST_ELEMENT)
 979 IntSize RenderThemeIOS::sliderTickSize() const
 980 {
 981     // FIXME: &lt;rdar://problem/12271791&gt; MERGEBOT: Correct values for slider tick of &lt;input type=&quot;range&quot;&gt; elements (requires ENABLE_DATALIST_ELEMENT)
 982     return IntSize(1, 3);
 983 }
 984 
 985 int RenderThemeIOS::sliderTickOffsetFromTrackCenter() const
 986 {
 987     // FIXME: &lt;rdar://problem/12271791&gt; MERGEBOT: Correct values for slider tick of &lt;input type=&quot;range&quot;&gt; elements (requires ENABLE_DATALIST_ELEMENT)
 988     return -9;
 989 }
 990 #endif
 991 
 992 void RenderThemeIOS::adjustSearchFieldStyle(StyleResolver&amp; selector, RenderStyle&amp; style, const Element* element) const
 993 {
 994     RenderTheme::adjustSearchFieldStyle(selector, style, element);
 995 
 996     if (!element)
 997         return;
 998 
 999     if (!style.hasBorder())
1000         return;
1001 
1002     RenderBox* box = element-&gt;renderBox();
1003     if (!box)
1004         return;
1005 
1006     adjustRoundBorderRadius(style, *box);
1007 }
1008 
1009 bool RenderThemeIOS::paintSearchFieldDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1010 {
1011     return paintTextFieldDecorations(box, paintInfo, rect);
1012 }
1013 
1014 void RenderThemeIOS::adjustButtonStyle(StyleResolver&amp; selector, RenderStyle&amp; style, const Element* element) const
1015 {
1016     RenderTheme::adjustButtonStyle(selector, style, element);
1017 
1018 #if ENABLE(INPUT_TYPE_COLOR)
1019     if (style.appearance() == ColorWellPart)
1020         return;
1021 #endif
1022 
1023     // Set padding: 0 1.0em; on buttons.
1024     // CSSPrimitiveValue::computeLengthInt only needs the element&#39;s style to calculate em lengths.
1025     // Since the element might not be in a document, just pass nullptr for the root element style
1026     // and the render view.
1027     auto emSize = CSSPrimitiveValue::create(1.0, CSSPrimitiveValue::CSS_EMS);
1028     int pixels = emSize-&gt;computeLength&lt;int&gt;(CSSToLengthConversionData(&amp;style, nullptr, nullptr, 1.0, false));
1029     style.setPaddingBox(LengthBox(0, pixels, 0, pixels));
1030 
1031     if (!element)
1032         return;
1033 
1034     RenderBox* box = element-&gt;renderBox();
1035     if (!box)
1036         return;
1037 
1038     adjustRoundBorderRadius(style, *box);
1039 }
1040 
1041 bool RenderThemeIOS::paintButtonDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1042 {
1043     return paintPushButtonDecorations(box, paintInfo, rect);
1044 }
1045 
1046 bool RenderThemeIOS::paintPushButtonDecorations(const RenderObject&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1047 {
1048     GraphicsContextStateSaver stateSaver(paintInfo.context());
1049     FloatRect clip = addRoundedBorderClip(box, paintInfo.context(), rect);
1050 
1051     CGContextRef cgContext = paintInfo.context().platformContext();
1052     if (box.style().visitedDependentColor(CSSPropertyBackgroundColor).isDark())
1053         drawAxialGradient(cgContext, gradientWithName(ConvexGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
1054     else {
1055         drawAxialGradient(cgContext, gradientWithName(ShadeGradient), clip.location(), FloatPoint(clip.x(), clip.maxY()), LinearInterpolation);
1056         drawAxialGradient(cgContext, gradientWithName(ShineGradient), FloatPoint(clip.x(), clip.maxY()), clip.location(), ExponentialInterpolation);
1057     }
1058     return false;
1059 }
1060 
1061 void RenderThemeIOS::setButtonSize(RenderStyle&amp; style) const
1062 {
1063     // If the width and height are both specified, then we have nothing to do.
1064     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
1065         return;
1066 
1067     // Use the font size to determine the intrinsic width of the control.
1068     style.setHeight(Length(static_cast&lt;int&gt;(ControlBaseHeight / ControlBaseFontSize * style.fontDescription().computedSize()), Fixed));
1069 }
1070 
1071 const int kThumbnailBorderStrokeWidth = 1;
1072 const int kThumbnailBorderCornerRadius = 1;
1073 const int kVisibleBackgroundImageWidth = 1;
1074 const int kMultipleThumbnailShrinkSize = 2;
1075 
1076 bool RenderThemeIOS::paintFileUploadIconDecorations(const RenderObject&amp;, const RenderObject&amp; buttonRenderer, const PaintInfo&amp; paintInfo, const IntRect&amp; rect, Icon* icon, FileUploadDecorations fileUploadDecorations)
1077 {
1078     GraphicsContextStateSaver stateSaver(paintInfo.context());
1079 
1080     IntSize cornerSize(kThumbnailBorderCornerRadius, kThumbnailBorderCornerRadius);
1081     Color pictureFrameColor = buttonRenderer.style().visitedDependentColor(CSSPropertyBorderTopColor);
1082 
1083     IntRect thumbnailPictureFrameRect = rect;
1084     IntRect thumbnailRect = rect;
1085     thumbnailRect.contract(2 * kThumbnailBorderStrokeWidth, 2 * kThumbnailBorderStrokeWidth);
1086     thumbnailRect.move(kThumbnailBorderStrokeWidth, kThumbnailBorderStrokeWidth);
1087 
1088     if (fileUploadDecorations == MultipleFiles) {
1089         // Smaller thumbnails for multiple selection appearance.
1090         thumbnailPictureFrameRect.contract(kMultipleThumbnailShrinkSize, kMultipleThumbnailShrinkSize);
1091         thumbnailRect.contract(kMultipleThumbnailShrinkSize, kMultipleThumbnailShrinkSize);
1092 
1093         // Background picture frame and simple background icon with a gradient matching the button.
1094         Color backgroundImageColor = Color(buttonRenderer.style().visitedDependentColor(CSSPropertyBackgroundColor).rgb());
1095         paintInfo.context().fillRoundedRect(FloatRoundedRect(thumbnailPictureFrameRect, cornerSize, cornerSize, cornerSize, cornerSize), pictureFrameColor);
1096         paintInfo.context().fillRect(thumbnailRect, backgroundImageColor);
1097         {
1098             GraphicsContextStateSaver stateSaver2(paintInfo.context());
1099             CGContextRef cgContext = paintInfo.context().platformContext();
1100             paintInfo.context().clip(thumbnailRect);
1101             if (backgroundImageColor.isDark())
1102                 drawAxialGradient(cgContext, gradientWithName(ConvexGradient), thumbnailRect.location(), FloatPoint(thumbnailRect.x(), thumbnailRect.maxY()), LinearInterpolation);
1103             else {
1104                 drawAxialGradient(cgContext, gradientWithName(ShadeGradient), thumbnailRect.location(), FloatPoint(thumbnailRect.x(), thumbnailRect.maxY()), LinearInterpolation);
1105                 drawAxialGradient(cgContext, gradientWithName(ShineGradient), FloatPoint(thumbnailRect.x(), thumbnailRect.maxY()), thumbnailRect.location(), ExponentialInterpolation);
1106             }
1107         }
1108 
1109         // Move the rects for the Foreground picture frame and icon.
1110         int inset = kVisibleBackgroundImageWidth + kThumbnailBorderStrokeWidth;
1111         thumbnailPictureFrameRect.move(inset, inset);
1112         thumbnailRect.move(inset, inset);
1113     }
1114 
1115     // Foreground picture frame and icon.
1116     paintInfo.context().fillRoundedRect(FloatRoundedRect(thumbnailPictureFrameRect, cornerSize, cornerSize, cornerSize, cornerSize), pictureFrameColor);
1117     icon-&gt;paint(paintInfo.context(), thumbnailRect);
1118 
1119     return false;
1120 }
1121 
1122 Color RenderThemeIOS::platformActiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
1123 {
1124     return Color::transparent;
1125 }
1126 
1127 Color RenderThemeIOS::platformInactiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
1128 {
1129     return Color::transparent;
1130 }
1131 
1132 #if ENABLE(FULL_KEYBOARD_ACCESS)
1133 Color RenderThemeIOS::platformFocusRingColor(OptionSet&lt;StyleColor::Options&gt;) const
1134 {
1135     // FIXME: Should be using -keyboardFocusIndicatorColor. For now, work around &lt;rdar://problem/50838886&gt;.
1136     return colorFromUIColor([PAL::getUIColorClass() systemBlueColor]);
1137 }
1138 #endif
1139 
1140 bool RenderThemeIOS::shouldHaveSpinButton(const HTMLInputElement&amp;) const
1141 {
1142     return false;
1143 }
1144 
1145 bool RenderThemeIOS::supportsFocusRing(const RenderStyle&amp;) const
1146 {
1147     return false;
1148 }
1149 
1150 FontCascadeDescription&amp; RenderThemeIOS::cachedSystemFontDescription(CSSValueID valueID) const
1151 {
1152     static NeverDestroyed&lt;FontCascadeDescription&gt; systemFont;
1153     static NeverDestroyed&lt;FontCascadeDescription&gt; headlineFont;
1154     static NeverDestroyed&lt;FontCascadeDescription&gt; bodyFont;
1155     static NeverDestroyed&lt;FontCascadeDescription&gt; subheadlineFont;
1156     static NeverDestroyed&lt;FontCascadeDescription&gt; footnoteFont;
1157     static NeverDestroyed&lt;FontCascadeDescription&gt; caption1Font;
1158     static NeverDestroyed&lt;FontCascadeDescription&gt; caption2Font;
1159     static NeverDestroyed&lt;FontCascadeDescription&gt; shortHeadlineFont;
1160     static NeverDestroyed&lt;FontCascadeDescription&gt; shortBodyFont;
1161     static NeverDestroyed&lt;FontCascadeDescription&gt; shortSubheadlineFont;
1162     static NeverDestroyed&lt;FontCascadeDescription&gt; shortFootnoteFont;
1163     static NeverDestroyed&lt;FontCascadeDescription&gt; shortCaption1Font;
1164     static NeverDestroyed&lt;FontCascadeDescription&gt; tallBodyFont;
1165 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1166     static NeverDestroyed&lt;FontCascadeDescription&gt; title0Font;
1167 #endif
1168     static NeverDestroyed&lt;FontCascadeDescription&gt; title1Font;
1169     static NeverDestroyed&lt;FontCascadeDescription&gt; title2Font;
1170     static NeverDestroyed&lt;FontCascadeDescription&gt; title3Font;
1171 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1172     static NeverDestroyed&lt;FontCascadeDescription&gt; title4Font;
1173 #endif
1174 
1175     static CFStringRef userTextSize = contentSizeCategory();
1176 
1177     if (userTextSize != contentSizeCategory()) {
1178         userTextSize = contentSizeCategory();
1179 
1180         headlineFont.get().setIsAbsoluteSize(false);
1181         bodyFont.get().setIsAbsoluteSize(false);
1182         subheadlineFont.get().setIsAbsoluteSize(false);
1183         footnoteFont.get().setIsAbsoluteSize(false);
1184         caption1Font.get().setIsAbsoluteSize(false);
1185         caption2Font.get().setIsAbsoluteSize(false);
1186         shortHeadlineFont.get().setIsAbsoluteSize(false);
1187         shortBodyFont.get().setIsAbsoluteSize(false);
1188         shortSubheadlineFont.get().setIsAbsoluteSize(false);
1189         shortFootnoteFont.get().setIsAbsoluteSize(false);
1190         shortCaption1Font.get().setIsAbsoluteSize(false);
1191         tallBodyFont.get().setIsAbsoluteSize(false);
1192     }
1193 
1194     switch (valueID) {
1195     case CSSValueAppleSystemHeadline:
1196         return headlineFont;
1197     case CSSValueAppleSystemBody:
1198         return bodyFont;
1199 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1200     case CSSValueAppleSystemTitle0:
1201         return title0Font;
1202 #endif
1203     case CSSValueAppleSystemTitle1:
1204         return title1Font;
1205     case CSSValueAppleSystemTitle2:
1206         return title2Font;
1207     case CSSValueAppleSystemTitle3:
1208         return title3Font;
1209 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1210     case CSSValueAppleSystemTitle4:
1211         return title4Font;
1212 #endif
1213     case CSSValueAppleSystemSubheadline:
1214         return subheadlineFont;
1215     case CSSValueAppleSystemFootnote:
1216         return footnoteFont;
1217     case CSSValueAppleSystemCaption1:
1218         return caption1Font;
1219     case CSSValueAppleSystemCaption2:
1220         return caption2Font;
1221         // Short version.
1222     case CSSValueAppleSystemShortHeadline:
1223         return shortHeadlineFont;
1224     case CSSValueAppleSystemShortBody:
1225         return shortBodyFont;
1226     case CSSValueAppleSystemShortSubheadline:
1227         return shortSubheadlineFont;
1228     case CSSValueAppleSystemShortFootnote:
1229         return shortFootnoteFont;
1230     case CSSValueAppleSystemShortCaption1:
1231         return shortCaption1Font;
1232         // Tall version.
1233     case CSSValueAppleSystemTallBody:
1234         return tallBodyFont;
1235     default:
1236         return systemFont;
1237     }
1238 }
1239 
1240 static inline FontSelectionValue cssWeightOfSystemFont(CTFontRef font)
1241 {
1242     RetainPtr&lt;CFDictionaryRef&gt; traits = adoptCF(CTFontCopyTraits(font));
1243     CFNumberRef resultRef = (CFNumberRef)CFDictionaryGetValue(traits.get(), kCTFontWeightTrait);
1244     float result = 0;
1245     CFNumberGetValue(resultRef, kCFNumberFloatType, &amp;result);
1246     // These numbers were experimentally gathered from weights of the system font.
1247     static float weightThresholds[] = { -0.6, -0.365, -0.115, 0.130, 0.235, 0.350, 0.5, 0.7 };
1248     for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(weightThresholds); ++i) {
1249         if (result &lt; weightThresholds[i])
1250             return FontSelectionValue((static_cast&lt;int&gt;(i) + 1) * 100);
1251     }
1252     return FontSelectionValue(900);
1253 }
1254 
1255 void RenderThemeIOS::updateCachedSystemFontDescription(CSSValueID valueID, FontCascadeDescription&amp; fontDescription) const
1256 {
1257     RetainPtr&lt;CTFontDescriptorRef&gt; fontDescriptor;
1258     CFStringRef textStyle;
1259     switch (valueID) {
1260     case CSSValueAppleSystemHeadline:
1261         textStyle = kCTUIFontTextStyleHeadline;
1262         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1263         break;
1264     case CSSValueAppleSystemBody:
1265         textStyle = kCTUIFontTextStyleBody;
1266         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1267         break;
1268 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1269     case CSSValueAppleSystemTitle0:
1270         textStyle = kCTUIFontTextStyleTitle0;
1271         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1272         break;
1273 #endif
1274     case CSSValueAppleSystemTitle1:
1275         textStyle = kCTUIFontTextStyleTitle1;
1276         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1277         break;
1278     case CSSValueAppleSystemTitle2:
1279         textStyle = kCTUIFontTextStyleTitle2;
1280         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1281         break;
1282     case CSSValueAppleSystemTitle3:
1283         textStyle = kCTUIFontTextStyleTitle3;
1284         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1285         break;
1286 #if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 110000
1287     case CSSValueAppleSystemTitle4:
1288         textStyle = kCTUIFontTextStyleTitle4;
1289         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1290         break;
1291 #endif
1292     case CSSValueAppleSystemSubheadline:
1293         textStyle = kCTUIFontTextStyleSubhead;
1294         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1295         break;
1296     case CSSValueAppleSystemFootnote:
1297         textStyle = kCTUIFontTextStyleFootnote;
1298         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1299         break;
1300     case CSSValueAppleSystemCaption1:
1301         textStyle = kCTUIFontTextStyleCaption1;
1302         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1303         break;
1304     case CSSValueAppleSystemCaption2:
1305         textStyle = kCTUIFontTextStyleCaption2;
1306         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1307         break;
1308 
1309     // Short version.
1310     case CSSValueAppleSystemShortHeadline:
1311         textStyle = kCTUIFontTextStyleShortHeadline;
1312         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1313         break;
1314     case CSSValueAppleSystemShortBody:
1315         textStyle = kCTUIFontTextStyleShortBody;
1316         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1317         break;
1318     case CSSValueAppleSystemShortSubheadline:
1319         textStyle = kCTUIFontTextStyleShortSubhead;
1320         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1321         break;
1322     case CSSValueAppleSystemShortFootnote:
1323         textStyle = kCTUIFontTextStyleShortFootnote;
1324         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1325         break;
1326     case CSSValueAppleSystemShortCaption1:
1327         textStyle = kCTUIFontTextStyleShortCaption1;
1328         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1329         break;
1330 
1331     // Tall version.
1332     case CSSValueAppleSystemTallBody:
1333         textStyle = kCTUIFontTextStyleTallBody;
1334         fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(textStyle, contentSizeCategory(), nullptr));
1335         break;
1336 
1337     default:
1338         textStyle = kCTFontDescriptorTextStyleEmphasized;
1339         fontDescriptor = adoptCF(CTFontDescriptorCreateForUIType(kCTFontUIFontSystem, 0, nullptr));
1340     }
1341 
1342     ASSERT(fontDescriptor);
1343     RetainPtr&lt;CTFontRef&gt; font = adoptCF(CTFontCreateWithFontDescriptor(fontDescriptor.get(), 0, nullptr));
1344     fontDescription.setIsAbsoluteSize(true);
1345     fontDescription.setOneFamily(textStyle);
1346     fontDescription.setSpecifiedSize(CTFontGetSize(font.get()));
1347     fontDescription.setWeight(cssWeightOfSystemFont(font.get()));
1348     fontDescription.setItalic(normalItalicValue());
1349 }
1350 
1351 #if ENABLE(VIDEO)
1352 String RenderThemeIOS::mediaControlsStyleSheet()
1353 {
1354 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1355     if (m_legacyMediaControlsStyleSheet.isEmpty())
1356         m_legacyMediaControlsStyleSheet = [NSString stringWithContentsOfFile:[[NSBundle bundleForClass:[WebCoreRenderThemeBundle class]] pathForResource:@&quot;mediaControlsiOS&quot; ofType:@&quot;css&quot;] encoding:NSUTF8StringEncoding error:nil];
1357     return m_legacyMediaControlsStyleSheet;
1358 #else
1359     return emptyString();
1360 #endif
1361 }
1362 
1363 String RenderThemeIOS::modernMediaControlsStyleSheet()
1364 {
1365 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1366     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled()) {
1367         if (m_mediaControlsStyleSheet.isEmpty())
1368             m_mediaControlsStyleSheet = [NSString stringWithContentsOfFile:[[NSBundle bundleForClass:[WebCoreRenderThemeBundle class]] pathForResource:@&quot;modern-media-controls&quot; ofType:@&quot;css&quot; inDirectory:@&quot;modern-media-controls&quot;] encoding:NSUTF8StringEncoding error:nil];
1369         return m_mediaControlsStyleSheet;
1370     }
1371     return emptyString();
1372 #else
1373     return emptyString();
1374 #endif
1375 }
1376 
1377 void RenderThemeIOS::purgeCaches()
1378 {
1379     m_legacyMediaControlsScript.clearImplIfNotShared();
1380     m_mediaControlsScript.clearImplIfNotShared();
1381     m_legacyMediaControlsStyleSheet.clearImplIfNotShared();
1382     m_mediaControlsStyleSheet.clearImplIfNotShared();
1383 }
1384 
1385 String RenderThemeIOS::mediaControlsScript()
1386 {
1387 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1388     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled()) {
1389         if (m_mediaControlsScript.isEmpty()) {
1390             NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
1391 
1392             StringBuilder scriptBuilder;
1393             scriptBuilder.append(&quot;window.isIOSFamily = true;&quot;);
1394             scriptBuilder.append([NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;modern-media-controls-localized-strings&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil]);
1395             scriptBuilder.append([NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;modern-media-controls&quot; ofType:@&quot;js&quot; inDirectory:@&quot;modern-media-controls&quot;] encoding:NSUTF8StringEncoding error:nil]);
1396             m_mediaControlsScript = scriptBuilder.toString();
1397         }
1398         return m_mediaControlsScript;
1399     }
1400 
1401     if (m_legacyMediaControlsScript.isEmpty()) {
1402         NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
1403 
1404         StringBuilder scriptBuilder;
1405         scriptBuilder.append([NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;mediaControlsLocalizedStrings&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil]);
1406         scriptBuilder.append([NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;mediaControlsApple&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil]);
1407         scriptBuilder.append([NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;mediaControlsiOS&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil]);
1408 
1409         m_legacyMediaControlsScript = scriptBuilder.toString();
1410     }
1411     return m_legacyMediaControlsScript;
1412 #else
1413     return emptyString();
1414 #endif
1415 }
1416 
1417 String RenderThemeIOS::mediaControlsBase64StringForIconNameAndType(const String&amp; iconName, const String&amp; iconType)
1418 {
1419 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1420     if (!RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
1421         return emptyString();
1422 
1423     String directory = &quot;modern-media-controls/images&quot;;
1424     NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
1425     return [[NSData dataWithContentsOfFile:[bundle pathForResource:iconName ofType:iconType inDirectory:directory]] base64EncodedStringWithOptions:0];
1426 #else
1427     return emptyString();
1428 #endif
1429 }
1430 
1431 #endif // ENABLE(VIDEO)
1432 
1433 Color RenderThemeIOS::systemColor(CSSValueID cssValueID, OptionSet&lt;StyleColor::Options&gt; options) const
1434 {
1435     const bool forVisitedLink = options.contains(StyleColor::Options::ForVisitedLink);
1436 
1437     // The system color cache below can&#39;t handle visited links. The only color value
1438     // that cares about visited links is CSSValueWebkitLink, so handle it here by
1439     // calling through to RenderTheme&#39;s base implementation.
1440     if (forVisitedLink &amp;&amp; cssValueID == CSSValueWebkitLink)
1441         return RenderTheme::systemColor(cssValueID, options);
1442 
1443     ASSERT(!forVisitedLink);
1444 
1445     auto&amp; cache = colorCache(options);
1446     return cache.systemStyleColors.ensure(cssValueID, [this, cssValueID, options] () -&gt; Color {
1447         const bool useDarkAppearance = options.contains(StyleColor::Options::UseDarkAppearance);
1448         const bool useElevatedUserInterfaceLevel = options.contains(StyleColor::Options::UseElevatedUserInterfaceLevel);
1449         LocalCurrentTraitCollection localTraitCollection(useDarkAppearance, useElevatedUserInterfaceLevel);
1450 
1451         auto cssColorToSelector = [cssValueID] () -&gt; SEL {
1452             switch (cssValueID) {
1453 #if HAVE(OS_DARK_MODE_SUPPORT)
1454             case CSSValueText:
1455             case CSSValueAppleSystemLabel:
1456             case CSSValueAppleSystemHeaderText:
1457                 return @selector(labelColor);
1458             case CSSValueAppleSystemSecondaryLabel:
1459                 return @selector(secondaryLabelColor);
1460             case CSSValueAppleSystemTertiaryLabel:
1461                 return @selector(tertiaryLabelColor);
1462             case CSSValueAppleSystemQuaternaryLabel:
1463                 return @selector(quaternaryLabelColor);
1464             case CSSValueAppleSystemPlaceholderText:
1465                 return @selector(placeholderTextColor);
1466             case CSSValueWebkitControlBackground:
1467             case CSSValueAppleSystemControlBackground:
1468             case CSSValueAppleSystemTextBackground:
1469             case CSSValueAppleSystemBackground:
1470                 return @selector(systemBackgroundColor);
1471             case CSSValueAppleSystemSecondaryBackground:
1472                 return @selector(secondarySystemBackgroundColor);
1473             case CSSValueAppleSystemTertiaryBackground:
1474                 return @selector(tertiarySystemBackgroundColor);
1475             case CSSValueAppleSystemGroupedBackground:
1476                 return @selector(systemGroupedBackgroundColor);
1477             case CSSValueAppleSystemSecondaryGroupedBackground:
1478                 return @selector(secondarySystemGroupedBackgroundColor);
1479             case CSSValueAppleSystemTertiaryGroupedBackground:
1480                 return @selector(tertiarySystemGroupedBackgroundColor);
1481             case CSSValueAppleSystemGrid:
1482             case CSSValueAppleSystemSeparator:
1483             case CSSValueAppleSystemContainerBorder:
1484                 return @selector(separatorColor);
1485             case CSSValueAppleSystemSelectedContentBackground:
1486             case CSSValueAppleSystemUnemphasizedSelectedContentBackground:
1487                 return @selector(tableCellDefaultSelectionTintColor);
1488             case CSSValueAppleSystemBrown:
1489                 return @selector(systemBrownColor);
1490             case CSSValueAppleSystemIndigo:
1491                 return @selector(systemIndigoColor);
1492 #endif
1493             case CSSValueAppleSystemTeal:
1494                 return @selector(systemTealColor);
1495             case CSSValueAppleWirelessPlaybackTargetActive:
1496             case CSSValueAppleSystemBlue:
1497                 return @selector(systemBlueColor);
1498             case CSSValueAppleSystemGray:
1499                 return @selector(systemGrayColor);
1500             case CSSValueAppleSystemGreen:
1501                 return @selector(systemGreenColor);
1502             case CSSValueAppleSystemOrange:
1503                 return @selector(systemOrangeColor);
1504             case CSSValueAppleSystemPink:
1505                 return @selector(systemPinkColor);
1506             case CSSValueAppleSystemPurple:
1507                 return @selector(systemPurpleColor);
1508             case CSSValueAppleSystemRed:
1509                 return @selector(systemRedColor);
1510             case CSSValueAppleSystemYellow:
1511                 return @selector(systemYellowColor);
1512             default:
1513                 return nullptr;
1514             }
1515         };
1516 
1517         if (auto selector = cssColorToSelector()) {
1518             if (auto color = wtfObjCMsgSend&lt;UIColor *&gt;(PAL::getUIColorClass(), selector))
1519                 return Color(color.CGColor, Color::Semantic);
1520         }
1521 
1522         return RenderTheme::systemColor(cssValueID, options);
1523     }).iterator-&gt;value;
1524 }
1525 
1526 #if ENABLE(ATTACHMENT_ELEMENT)
1527 
1528 const CGSize attachmentSize = { 160, 119 };
1529 
1530 const CGFloat attachmentBorderRadius = 16;
1531 static Color attachmentBorderColor() { return Color(204, 204, 204); }
1532 
1533 static Color attachmentProgressColor() { return Color(222, 222, 222); }
1534 const CGFloat attachmentProgressBorderThickness = 3;
1535 
1536 const CGFloat attachmentProgressSize = 36;
1537 const CGFloat attachmentIconSize = 48;
1538 
1539 const CGFloat attachmentItemMargin = 8;
1540 
1541 const CGFloat attachmentWrappingTextMaximumWidth = 140;
1542 const CFIndex attachmentWrappingTextMaximumLineCount = 2;
1543 
1544 static RetainPtr&lt;CTFontRef&gt; attachmentActionFont()
1545 {
1546     RetainPtr&lt;CTFontDescriptorRef&gt; fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(kCTUIFontTextStyleShortFootnote, RenderThemeIOS::contentSizeCategory(), 0));
1547     RetainPtr&lt;CTFontDescriptorRef&gt; emphasizedFontDescriptor = adoptCF(CTFontDescriptorCreateCopyWithAttributes(fontDescriptor.get(),
1548         (CFDictionaryRef)@{
1549             (id)kCTFontDescriptorTextStyleAttribute: (id)kCTFontDescriptorTextStyleEmphasized
1550     }));
1551     return adoptCF(CTFontCreateWithFontDescriptor(emphasizedFontDescriptor.get(), 0, nullptr));
1552 }
1553 
1554 static UIColor *attachmentActionColor(const RenderAttachment&amp; attachment)
1555 {
1556     return [PAL::getUIColorClass() colorWithCGColor:cachedCGColor(attachment.style().visitedDependentColor(CSSPropertyColor))];
1557 }
1558 
1559 static RetainPtr&lt;CTFontRef&gt; attachmentTitleFont()
1560 {
1561     RetainPtr&lt;CTFontDescriptorRef&gt; fontDescriptor = adoptCF(CTFontDescriptorCreateWithTextStyle(kCTUIFontTextStyleShortCaption1, RenderThemeIOS::contentSizeCategory(), 0));
1562     return adoptCF(CTFontCreateWithFontDescriptor(fontDescriptor.get(), 0, nullptr));
1563 }
1564 
1565 static UIColor *attachmentTitleColor() { return [PAL::getUIColorClass() systemGrayColor]; }
1566 
1567 static RetainPtr&lt;CTFontRef&gt; attachmentSubtitleFont() { return attachmentTitleFont(); }
1568 static UIColor *attachmentSubtitleColor() { return [PAL::getUIColorClass() systemGrayColor]; }
1569 
1570 struct RenderAttachmentInfo {
1571     explicit RenderAttachmentInfo(const RenderAttachment&amp;);
1572 
1573     FloatRect iconRect;
1574     FloatRect attachmentRect;
1575     FloatRect progressRect;
1576 
1577     BOOL hasProgress { NO };
1578     float progress;
1579 
1580     RetainPtr&lt;UIImage&gt; icon;
1581 
1582     int baseline { 0 };
1583 
1584     struct LabelLine {
1585         FloatRect rect;
1586         RetainPtr&lt;CTLineRef&gt; line;
1587     };
1588     Vector&lt;LabelLine&gt; lines;
1589 
1590     CGFloat contentYOrigin { 0 };
1591 
1592 private:
1593     void buildWrappedLines(const String&amp;, CTFontRef, UIColor *, unsigned maximumLineCount);
1594     void buildSingleLine(const String&amp;, CTFontRef, UIColor *);
1595 
1596     void addLine(CTLineRef);
1597 };
1598 
1599 void RenderAttachmentInfo::addLine(CTLineRef line)
1600 {
1601     CGRect lineBounds = CTLineGetBoundsWithOptions(line, kCTLineBoundsExcludeTypographicLeading);
1602     CGFloat trailingWhitespaceWidth = CTLineGetTrailingWhitespaceWidth(line);
1603     CGFloat lineWidthIgnoringTrailingWhitespace = lineBounds.size.width - trailingWhitespaceWidth;
1604     CGFloat lineHeight = CGCeiling(lineBounds.size.height + lineBounds.origin.y);
1605 
1606     CGFloat xOffset = (attachmentRect.width() / 2) - (lineWidthIgnoringTrailingWhitespace / 2);
1607     LabelLine labelLine;
1608     labelLine.line = line;
1609     labelLine.rect = FloatRect(xOffset, 0, lineWidthIgnoringTrailingWhitespace, lineHeight);
1610 
1611     lines.append(labelLine);
1612 }
1613 
1614 void RenderAttachmentInfo::buildWrappedLines(const String&amp; text, CTFontRef font, UIColor *color, unsigned maximumLineCount)
1615 {
1616     if (text.isEmpty())
1617         return;
1618 
1619     NSDictionary *textAttributes = @{
1620         (id)kCTFontAttributeName: (id)font,
1621         (id)kCTForegroundColorAttributeName: color
1622     };
1623     RetainPtr&lt;NSAttributedString&gt; attributedText = adoptNS([[NSAttributedString alloc] initWithString:text attributes:textAttributes]);
1624     RetainPtr&lt;CTFramesetterRef&gt; framesetter = adoptCF(CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributedText.get()));
1625 
1626     CFRange fitRange;
1627     CGSize textSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter.get(), CFRangeMake(0, 0), nullptr, CGSizeMake(attachmentWrappingTextMaximumWidth, CGFLOAT_MAX), &amp;fitRange);
1628 
1629     RetainPtr&lt;CGPathRef&gt; textPath = adoptCF(CGPathCreateWithRect(CGRectMake(0, 0, textSize.width, textSize.height), nullptr));
1630     RetainPtr&lt;CTFrameRef&gt; textFrame = adoptCF(CTFramesetterCreateFrame(framesetter.get(), fitRange, textPath.get(), nullptr));
1631 
1632     CFArrayRef ctLines = CTFrameGetLines(textFrame.get());
1633     CFIndex lineCount = CFArrayGetCount(ctLines);
1634     if (!lineCount)
1635         return;
1636 
1637     // Lay out and record the first (maximumLineCount - 1) lines.
1638     CFIndex lineIndex = 0;
1639     CFIndex nonTruncatedLineCount = std::min&lt;CFIndex&gt;(maximumLineCount - 1, lineCount);
1640     for (; lineIndex &lt; nonTruncatedLineCount; ++lineIndex)
1641         addLine((CTLineRef)CFArrayGetValueAtIndex(ctLines, lineIndex));
1642 
1643     if (lineIndex == lineCount)
1644         return;
1645 
1646     // We had text that didn&#39;t fit in the first (maximumLineCount - 1) lines.
1647     // Combine it into one last line, and center-truncate it.
1648     CTLineRef firstRemainingLine = (CTLineRef)CFArrayGetValueAtIndex(ctLines, lineIndex);
1649     CFIndex remainingRangeStart = CTLineGetStringRange(firstRemainingLine).location;
1650     CFRange remainingRange = CFRangeMake(remainingRangeStart, [attributedText length] - remainingRangeStart);
1651     RetainPtr&lt;CGPathRef&gt; remainingPath = adoptCF(CGPathCreateWithRect(CGRectMake(0, 0, CGFLOAT_MAX, CGFLOAT_MAX), nullptr));
1652     RetainPtr&lt;CTFrameRef&gt; remainingFrame = adoptCF(CTFramesetterCreateFrame(framesetter.get(), remainingRange, remainingPath.get(), nullptr));
1653     RetainPtr&lt;NSAttributedString&gt; ellipsisString = adoptNS([[NSAttributedString alloc] initWithString:@&quot;\u2026&quot; attributes:textAttributes]);
1654     RetainPtr&lt;CTLineRef&gt; ellipsisLine = adoptCF(CTLineCreateWithAttributedString((CFAttributedStringRef)ellipsisString.get()));
1655     CTLineRef remainingLine = (CTLineRef)CFArrayGetValueAtIndex(CTFrameGetLines(remainingFrame.get()), 0);
1656     RetainPtr&lt;CTLineRef&gt; truncatedLine = adoptCF(CTLineCreateTruncatedLine(remainingLine, attachmentWrappingTextMaximumWidth, kCTLineTruncationMiddle, ellipsisLine.get()));
1657 
1658     if (!truncatedLine)
1659         truncatedLine = remainingLine;
1660 
1661     addLine(truncatedLine.get());
1662 }
1663 
1664 void RenderAttachmentInfo::buildSingleLine(const String&amp; text, CTFontRef font, UIColor *color)
1665 {
1666     if (text.isEmpty())
1667         return;
1668 
1669     NSDictionary *textAttributes = @{
1670         (id)kCTFontAttributeName: (id)font,
1671         (id)kCTForegroundColorAttributeName: color
1672     };
1673     RetainPtr&lt;NSAttributedString&gt; attributedText = adoptNS([[NSAttributedString alloc] initWithString:text attributes:textAttributes]);
1674 
1675     addLine(adoptCF(CTLineCreateWithAttributedString((CFAttributedStringRef)attributedText.get())).get());
1676 }
1677 
1678 static BOOL getAttachmentProgress(const RenderAttachment&amp; attachment, float&amp; progress)
1679 {
1680     auto&amp; progressString = attachment.attachmentElement().attributeWithoutSynchronization(progressAttr);
1681     if (progressString.isEmpty())
1682         return NO;
1683     bool validProgress;
1684     progress = std::max&lt;float&gt;(std::min&lt;float&gt;(progressString.toFloat(&amp;validProgress), 1), 0);
1685     return validProgress;
1686 }
1687 
1688 static RetainPtr&lt;UIImage&gt; iconForAttachment(const RenderAttachment&amp; attachment, FloatSize&amp; size)
1689 {
1690     ALLOW_DEPRECATED_DECLARATIONS_BEGIN
1691     auto documentInteractionController = adoptNS([PAL::allocUIDocumentInteractionControllerInstance() init]);
1692     ALLOW_DEPRECATED_DECLARATIONS_END
1693 
1694     String fileName;
1695     if (File* file = attachment.attachmentElement().file())
1696         fileName = file-&gt;name();
1697 
1698     if (fileName.isEmpty())
1699         fileName = attachment.attachmentElement().attachmentTitle();
1700     [documentInteractionController setName:fileName];
1701 
1702     String attachmentType = attachment.attachmentElement().attachmentType();
1703     if (!attachmentType.isEmpty()) {
1704         String UTI;
1705         if (isDeclaredUTI(attachmentType))
1706             UTI = attachmentType;
1707         else
1708             UTI = UTIFromMIMEType(attachmentType);
1709 
1710 #if PLATFORM(IOS)
1711         [documentInteractionController setUTI:static_cast&lt;NSString *&gt;(UTI)];
1712 #endif
1713     }
1714 
1715     RetainPtr&lt;UIImage&gt; result;
1716 #if PLATFORM(IOS)
1717     NSArray *icons = [documentInteractionController icons];
1718     if (!icons.count)
1719         return nil;
1720 
1721     result = icons.lastObject;
1722 
1723     BOOL useHeightForClosestMatch = [result size].height &gt; [result size].width;
1724     CGFloat bestMatchRatio = -1;
1725 
1726     for (UIImage *icon in icons) {
1727         CGFloat iconSize = useHeightForClosestMatch ? icon.size.height : icon.size.width;
1728 
1729         CGFloat matchRatio = (attachmentIconSize / iconSize) - 1.0f;
1730         if (matchRatio &lt; 0.3f) {
1731             matchRatio = CGFAbs(matchRatio);
1732             if ((bestMatchRatio == -1) || (matchRatio &lt; bestMatchRatio)) {
1733                 result = icon;
1734                 bestMatchRatio = matchRatio;
1735             }
1736         }
1737     }
1738 #endif
1739     CGFloat iconAspect = [result size].width / [result size].height;
1740     size = largestRectWithAspectRatioInsideRect(iconAspect, FloatRect(0, 0, attachmentIconSize, attachmentIconSize)).size();
1741 
1742     return result;
1743 }
1744 
1745 RenderAttachmentInfo::RenderAttachmentInfo(const RenderAttachment&amp; attachment)
1746 {
1747     attachmentRect = FloatRect(0, 0, attachment.width().toFloat(), attachment.height().toFloat());
1748 
1749     hasProgress = getAttachmentProgress(attachment, progress);
1750 
1751     String title = attachment.attachmentElement().attachmentTitleForDisplay();
1752     String action = attachment.attachmentElement().attributeWithoutSynchronization(actionAttr);
1753     String subtitle = attachment.attachmentElement().attributeWithoutSynchronization(subtitleAttr);
1754 
1755     CGFloat yOffset = 0;
1756 
1757     if (hasProgress) {
1758         progressRect = FloatRect((attachmentRect.width() / 2) - (attachmentProgressSize / 2), 0, attachmentProgressSize, attachmentProgressSize);
1759         yOffset += attachmentProgressSize + attachmentItemMargin;
1760     }
1761 
1762     if (action.isEmpty() &amp;&amp; !hasProgress) {
1763         FloatSize iconSize;
1764         icon = iconForAttachment(attachment, iconSize);
1765         if (icon) {
1766             iconRect = FloatRect(FloatPoint((attachmentRect.width() / 2) - (iconSize.width() / 2), 0), iconSize);
1767             yOffset += iconRect.height() + attachmentItemMargin;
1768         }
1769     } else
1770         buildWrappedLines(action, attachmentActionFont().get(), attachmentActionColor(attachment), attachmentWrappingTextMaximumLineCount);
1771 
1772     bool forceSingleLineTitle = !action.isEmpty() || !subtitle.isEmpty() || hasProgress;
1773     buildWrappedLines(title, attachmentTitleFont().get(), attachmentTitleColor(), forceSingleLineTitle ? 1 : attachmentWrappingTextMaximumLineCount);
1774     buildSingleLine(subtitle, attachmentSubtitleFont().get(), attachmentSubtitleColor());
1775 
1776     if (!lines.isEmpty()) {
1777         for (auto&amp; line : lines) {
1778             line.rect.setY(yOffset);
1779             yOffset += line.rect.height() + attachmentItemMargin;
1780         }
1781     }
1782 
1783     yOffset -= attachmentItemMargin;
1784 
1785     contentYOrigin = (attachmentRect.height() / 2) - (yOffset / 2);
1786 }
1787 
1788 LayoutSize RenderThemeIOS::attachmentIntrinsicSize(const RenderAttachment&amp;) const
1789 {
1790     return LayoutSize(FloatSize(attachmentSize));
1791 }
1792 
1793 int RenderThemeIOS::attachmentBaseline(const RenderAttachment&amp; attachment) const
1794 {
1795     RenderAttachmentInfo info(attachment);
1796     return info.baseline;
1797 }
1798 
1799 static void paintAttachmentIcon(GraphicsContext&amp; context, RenderAttachmentInfo&amp; info)
1800 {
1801     if (!info.icon)
1802         return;
1803 
1804     auto iconImage = BitmapImage::create([info.icon CGImage]);
1805     context.drawImage(iconImage.get(), info.iconRect);
1806 }
1807 
1808 static void paintAttachmentText(GraphicsContext&amp; context, RenderAttachmentInfo&amp; info)
1809 {
1810     for (const auto&amp; line : info.lines) {
1811         GraphicsContextStateSaver saver(context);
1812 
1813         context.translate(toFloatSize(line.rect.minXMaxYCorner()));
1814         context.scale(FloatSize(1, -1));
1815 
1816         CGContextSetTextPosition(context.platformContext(), 0, 0);
1817         CTLineDraw(line.line.get(), context.platformContext());
1818     }
1819 }
1820 
1821 static void paintAttachmentProgress(GraphicsContext&amp; context, RenderAttachmentInfo&amp; info)
1822 {
1823     GraphicsContextStateSaver saver(context);
1824 
1825     context.setStrokeThickness(attachmentProgressBorderThickness);
1826     context.setStrokeColor(attachmentProgressColor());
1827     context.setFillColor(attachmentProgressColor());
1828     context.strokeEllipse(info.progressRect);
1829 
1830     FloatPoint center = info.progressRect.center();
1831 
1832     Path progressPath;
1833     progressPath.moveTo(center);
1834     progressPath.addLineTo(FloatPoint(center.x(), info.progressRect.y()));
1835     progressPath.addArc(center, info.progressRect.width() / 2, -M_PI_2, info.progress * 2 * M_PI - M_PI_2, 0);
1836     progressPath.closeSubpath();
1837     context.fillPath(progressPath);
1838 }
1839 
1840 static Path attachmentBorderPath(RenderAttachmentInfo&amp; info)
1841 {
1842     Path borderPath;
1843     borderPath.addRoundedRect(info.attachmentRect, FloatSize(attachmentBorderRadius, attachmentBorderRadius));
1844     return borderPath;
1845 }
1846 
1847 static void paintAttachmentBorder(GraphicsContext&amp; context, Path&amp; borderPath)
1848 {
1849     context.setStrokeColor(attachmentBorderColor());
1850     context.setStrokeThickness(1);
1851     context.strokePath(borderPath);
1852 }
1853 
1854 bool RenderThemeIOS::paintAttachment(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const IntRect&amp; paintRect)
1855 {
1856     if (!is&lt;RenderAttachment&gt;(renderer))
1857         return false;
1858 
1859     const RenderAttachment&amp; attachment = downcast&lt;RenderAttachment&gt;(renderer);
1860 
1861     RenderAttachmentInfo info(attachment);
1862 
1863     GraphicsContext&amp; context = paintInfo.context();
1864     GraphicsContextStateSaver saver(context);
1865 
1866     context.translate(toFloatSize(paintRect.location()));
1867 
1868     if (attachment.shouldDrawBorder()) {
1869         auto borderPath = attachmentBorderPath(info);
1870         paintAttachmentBorder(context, borderPath);
1871         context.clipPath(borderPath);
1872     }
1873 
1874     context.translate(FloatSize(0, info.contentYOrigin));
1875 
1876     if (info.hasProgress)
1877         paintAttachmentProgress(context, info);
1878     else if (info.icon)
1879         paintAttachmentIcon(context, info);
1880 
1881     paintAttachmentText(context, info);
1882 
1883     return true;
1884 }
1885 
1886 #endif // ENABLE(ATTACHMENT_ELEMENT)
1887 
1888 #if PLATFORM(WATCHOS)
1889 
1890 String RenderThemeIOS::extraDefaultStyleSheet()
1891 {
1892     return &quot;* { -webkit-text-size-adjust: auto; -webkit-hyphens: auto !important; }&quot;_s;
1893 }
1894 
1895 #endif
1896 
1897 #if USE(SYSTEM_PREVIEW)
1898 static NSBundle *arKitBundle()
1899 {
1900     static NSBundle *arKitBundle = []() {
1901 #if PLATFORM(IOS_FAMILY_SIMULATOR)
1902         dlopen(&quot;/System/Library/PrivateFrameworks/AssetViewer.framework/AssetViewer&quot;, RTLD_NOW);
1903         return [NSBundle bundleForClass:NSClassFromString(@&quot;ASVThumbnailView&quot;)];
1904 #else
1905         return [NSBundle bundleWithURL:[NSURL fileURLWithPath:@&quot;/System/Library/PrivateFrameworks/AssetViewer.framework&quot;]];
1906 #endif
1907     }();
1908 
1909     return arKitBundle;
1910 }
1911 
1912 static RetainPtr&lt;CGPDFPageRef&gt; loadARKitPDFPage(NSString *imageName)
1913 {
1914     NSURL *url = [arKitBundle() URLForResource:imageName withExtension:@&quot;pdf&quot;];
1915 
1916     if (!url)
1917         return nullptr;
1918 
1919     auto document = adoptCF(CGPDFDocumentCreateWithURL((CFURLRef)url));
1920     if (!document)
1921         return nullptr;
1922 
1923     if (!CGPDFDocumentGetNumberOfPages(document.get()))
1924         return nullptr;
1925 
1926     return CGPDFDocumentGetPage(document.get(), 1);
1927 }
1928 
1929 static CGPDFPageRef systemPreviewLogo()
1930 {
1931     static CGPDFPageRef logoPage = loadARKitPDFPage(@&quot;ARKitBadge&quot;).leakRef();
1932     return logoPage;
1933 }
1934 
1935 void RenderThemeIOS::paintSystemPreviewBadge(Image&amp; image, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
1936 {
1937     static const int largeBadgeDimension = 70;
1938     static const int largeBadgeOffset = 20;
1939 
1940     static const int smallBadgeDimension = 35;
1941     static const int smallBadgeOffset = 8;
1942 
1943     static const int minimumSizeForLargeBadge = 240;
1944 
1945     bool useSmallBadge = rect.width() &lt; minimumSizeForLargeBadge || rect.height() &lt; minimumSizeForLargeBadge;
1946     int badgeOffset = useSmallBadge ? smallBadgeOffset : largeBadgeOffset;
1947     int badgeDimension = useSmallBadge ? smallBadgeDimension : largeBadgeDimension;
1948 
1949     int minimumDimension = badgeDimension + 2 * badgeOffset;
1950     if (rect.width() &lt; minimumDimension || rect.height() &lt; minimumDimension)
1951         return;
1952 
1953     CGRect absoluteBadgeRect = CGRectMake(rect.x() + rect.width() - badgeDimension - badgeOffset, rect.y() + badgeOffset, badgeDimension, badgeDimension);
1954     CGRect insetBadgeRect = CGRectMake(rect.width() - badgeDimension - badgeOffset, badgeOffset, badgeDimension, badgeDimension);
1955     CGRect badgeRect = CGRectMake(0, 0, badgeDimension, badgeDimension);
1956 
1957     CIImage *inputImage = [CIImage imageWithCGImage:image.nativeImage().get()];
1958 
1959     // Create a circle to be used for the clipping path in the badge, as well as the drop shadow.
1960     RetainPtr&lt;CGPathRef&gt; circle = adoptCF(CGPathCreateWithRoundedRect(absoluteBadgeRect, badgeDimension / 2, badgeDimension / 2, nullptr));
1961 
1962     auto&amp; graphicsContext = paintInfo.context();
1963     if (graphicsContext.paintingDisabled())
1964         return;
1965 
1966     GraphicsContextStateSaver stateSaver(graphicsContext);
1967 
1968     CGContextRef ctx = graphicsContext.platformContext();
1969     if (!ctx)
1970         return;
1971 
1972     CGContextSaveGState(ctx);
1973 
1974     // Draw a drop shadow around the circle.
1975     // Use the GraphicsContext function, because it calculates the blur radius in context space,
1976     // rather than screen space.
1977     Color shadowColor = Color { 0.f, 0.f, 0.f, 0.1f };
1978     graphicsContext.setShadow(FloatSize { }, 16, shadowColor);
1979 
1980     // The circle must have an alpha channel value of 1 for the shadow color to appear.
1981     CGFloat circleColorComponents[4] = { 0, 0, 0, 1 };
1982     RetainPtr&lt;CGColorRef&gt; circleColor = adoptCF(CGColorCreate(sRGBColorSpaceRef(), circleColorComponents));
1983     CGContextSetFillColorWithColor(ctx, circleColor.get());
1984 
1985     // Clip out the circle to only show the shadow.
1986     CGContextBeginPath(ctx);
1987     CGContextAddRect(ctx, rect);
1988     CGContextAddPath(ctx, circle.get());
1989     CGContextClosePath(ctx);
1990     CGContextEOClip(ctx);
1991 
1992     // Draw a slightly smaller circle with a shadow, otherwise we&#39;ll see a fringe of the solid
1993     // black circle around the edges of the clipped path below.
1994     CGContextBeginPath(ctx);
1995     CGRect slightlySmallerAbsoluteBadgeRect = CGRectMake(absoluteBadgeRect.origin.x + 0.5, absoluteBadgeRect.origin.y + 0.5, badgeDimension - 1, badgeDimension - 1);
1996     RetainPtr&lt;CGPathRef&gt; slightlySmallerCircle = adoptCF(CGPathCreateWithRoundedRect(slightlySmallerAbsoluteBadgeRect, slightlySmallerAbsoluteBadgeRect.size.width / 2, slightlySmallerAbsoluteBadgeRect.size.height / 2, nullptr));
1997     CGContextAddPath(ctx, slightlySmallerCircle.get());
1998     CGContextClosePath(ctx);
1999     CGContextFillPath(ctx);
2000 
2001     CGContextRestoreGState(ctx);
2002 
2003     // Draw the blurred backdrop. Scale from intrinsic size to render size.
2004     CGAffineTransform transform = CGAffineTransformIdentity;
2005     transform = CGAffineTransformScale(transform, rect.width() / image.width(), rect.height() / image.height());
2006     CIImage *scaledImage = [inputImage imageByApplyingTransform:transform];
2007 
2008     // CoreImage coordinates are y-up, so we need to flip the badge rectangle within the image frame.
2009     CGRect flippedInsetBadgeRect = CGRectMake(insetBadgeRect.origin.x, rect.height() - insetBadgeRect.origin.y - insetBadgeRect.size.height, badgeDimension, badgeDimension);
2010 
2011     // Create a cropped region with pixel values extending outwards.
2012     CIImage *clampedImage = [scaledImage imageByClampingToRect:flippedInsetBadgeRect];
2013 
2014     // Blur.
2015     CIImage *blurredImage = [clampedImage imageByApplyingGaussianBlurWithSigma:10];
2016 
2017     // Saturate.
2018     CIFilter *saturationFilter = [CIFilter filterWithName:@&quot;CIColorControls&quot;];
2019     [saturationFilter setValue:blurredImage forKey:kCIInputImageKey];
2020     [saturationFilter setValue:@1.8 forKey:kCIInputSaturationKey];
2021 
2022     // Tint.
2023     CIFilter *tintFilter1 = [CIFilter filterWithName:@&quot;CIConstantColorGenerator&quot;];
2024     CIColor *tintColor1 = [CIColor colorWithRed:1 green:1 blue:1 alpha:0.18];
2025     [tintFilter1 setValue:tintColor1 forKey:kCIInputColorKey];
2026 
2027     // Blend the tint with the saturated output.
2028     CIFilter *sourceOverFilter = [CIFilter filterWithName:@&quot;CISourceOverCompositing&quot;];
2029     [sourceOverFilter setValue:tintFilter1.outputImage forKey:kCIInputImageKey];
2030     [sourceOverFilter setValue:saturationFilter.outputImage forKey:kCIInputBackgroundImageKey];
2031 
2032     if (!m_ciContext)
2033         m_ciContext = [CIContext context];
2034 
2035     RetainPtr&lt;CGImageRef&gt; cgImage;
2036 #if HAVE(IOSURFACE)
2037     // Crop the result to the badge location.
2038     CIImage *croppedImage = [sourceOverFilter.outputImage imageByCroppingToRect:flippedInsetBadgeRect];
2039     CIImage *translatedImage = [croppedImage imageByApplyingTransform:CGAffineTransformMakeTranslation(-flippedInsetBadgeRect.origin.x, -flippedInsetBadgeRect.origin.y)];
2040     IOSurfaceRef surface;
2041     if (useSmallBadge) {
2042         if (!m_smallBadgeSurface)
2043             m_smallBadgeSurface = IOSurface::create({ smallBadgeDimension, smallBadgeDimension }, sRGBColorSpaceRef());
2044         surface = m_smallBadgeSurface-&gt;surface();
2045     } else {
2046         if (!m_largeBadgeSurface)
2047             m_largeBadgeSurface = IOSurface::create({ largeBadgeDimension, largeBadgeDimension }, sRGBColorSpaceRef());
2048         surface = m_largeBadgeSurface-&gt;surface();
2049     }
2050     [m_ciContext.get() render:translatedImage toIOSurface:surface bounds:badgeRect colorSpace:sRGBColorSpaceRef()];
2051     cgImage = useSmallBadge ? m_smallBadgeSurface-&gt;createImage() : m_largeBadgeSurface-&gt;createImage();
2052 #else
2053     cgImage = adoptCF([m_ciContext.get() createCGImage:sourceOverFilter.outputImage fromRect:flippedInsetBadgeRect]);
2054 #endif
2055 
2056     // Before we render the result, we should clip to a circle around the badge rectangle.
2057     CGContextSaveGState(ctx);
2058     CGContextBeginPath(ctx);
2059     CGContextAddPath(ctx, circle.get());
2060     CGContextClosePath(ctx);
2061     CGContextClip(ctx);
2062 
2063     CGContextTranslateCTM(ctx, absoluteBadgeRect.origin.x, absoluteBadgeRect.origin.y);
2064     CGContextTranslateCTM(ctx, 0, badgeDimension);
2065     CGContextScaleCTM(ctx, 1, -1);
2066     CGContextDrawImage(ctx, badgeRect, cgImage.get());
2067 
2068     if (auto logo = systemPreviewLogo()) {
2069         CGSize pdfSize = CGPDFPageGetBoxRect(logo, kCGPDFMediaBox).size;
2070         CGFloat scaleX = badgeDimension / pdfSize.width;
2071         CGFloat scaleY = badgeDimension / pdfSize.height;
2072         CGContextScaleCTM(ctx, scaleX, scaleY);
2073         CGContextDrawPDFPage(ctx, logo);
2074     }
2075 
2076     CGContextFlush(ctx);
2077     CGContextRestoreGState(ctx);
2078 }
2079 #endif
2080 
2081 } // namespace WebCore
2082 
2083 #endif //PLATFORM(IOS_FAMILY)
    </pre>
  </body>
</html>