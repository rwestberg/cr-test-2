<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/mathml/MathOperator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Igalia S.L. All rights reserved.
  3  * Copyright (C) 2016 Apple Inc.  All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 15  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 16  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 17  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 18  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 19  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 20  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 21  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 22  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MathOperator.h&quot;
 29 
 30 #if ENABLE(MATHML)
 31 
 32 #include &quot;RenderStyle.h&quot;
 33 #include &quot;StyleInheritedData.h&quot;
 34 
 35 static const unsigned kRadicalOperator = 0x221A;
 36 static const unsigned kMaximumExtensionCount = 128;
 37 
 38 namespace WebCore {
 39 
 40 static inline FloatRect boundsForGlyph(const GlyphData&amp; data)
 41 {
 42     return data.font ? data.font-&gt;boundsForGlyph(data.glyph) : FloatRect();
 43 }
 44 
 45 static inline float heightForGlyph(const GlyphData&amp; data)
 46 {
 47     return boundsForGlyph(data).height();
 48 }
 49 
 50 static inline void getAscentAndDescentForGlyph(const GlyphData&amp; data, LayoutUnit&amp; ascent, LayoutUnit&amp; descent)
 51 {
 52     FloatRect bounds = boundsForGlyph(data);
 53     ascent = -bounds.y();
 54     descent = bounds.maxY();
 55 }
 56 
 57 static inline float advanceWidthForGlyph(const GlyphData&amp; data)
 58 {
 59     return data.font ? data.font-&gt;widthForGlyph(data.glyph) : 0;
 60 }
 61 
 62 // FIXME: This hardcoded data can be removed when OpenType MATH font are widely available (http://wkbug/156837).
 63 struct StretchyCharacter {
 64     UChar32 character;
 65     UChar topChar;
 66     UChar extensionChar;
 67     UChar bottomChar;
 68     UChar middleChar;
 69 };
 70 // The first leftRightPairsCount pairs correspond to left/right fences that can easily be mirrored in RTL.
 71 static const short leftRightPairsCount = 5;
 72 static const StretchyCharacter stretchyCharacters[14] = {
 73     { 0x28  , 0x239b, 0x239c, 0x239d, 0x0    }, // left parenthesis
 74     { 0x29  , 0x239e, 0x239f, 0x23a0, 0x0    }, // right parenthesis
 75     { 0x5b  , 0x23a1, 0x23a2, 0x23a3, 0x0    }, // left square bracket
 76     { 0x5d  , 0x23a4, 0x23a5, 0x23a6, 0x0    }, // right square bracket
 77     { 0x7b  , 0x23a7, 0x23aa, 0x23a9, 0x23a8 }, // left curly bracket
 78     { 0x7d  , 0x23ab, 0x23aa, 0x23ad, 0x23ac }, // right curly bracket
 79     { 0x2308, 0x23a1, 0x23a2, 0x23a2, 0x0    }, // left ceiling
 80     { 0x2309, 0x23a4, 0x23a5, 0x23a5, 0x0    }, // right ceiling
 81     { 0x230a, 0x23a2, 0x23a2, 0x23a3, 0x0    }, // left floor
 82     { 0x230b, 0x23a5, 0x23a5, 0x23a6, 0x0    }, // right floor
 83     { 0x7c  , 0x7c,   0x7c,   0x7c,   0x0    }, // vertical bar
 84     { 0x2016, 0x2016, 0x2016, 0x2016, 0x0    }, // double vertical line
 85     { 0x2225, 0x2225, 0x2225, 0x2225, 0x0    }, // parallel to
 86     { 0x222b, 0x2320, 0x23ae, 0x2321, 0x0    } // integral sign
 87 };
 88 
 89 MathOperator::MathOperator()
 90 {
 91     m_variantGlyph = 0;
 92 }
 93 
 94 void MathOperator::setOperator(const RenderStyle&amp; style, UChar32 baseCharacter, Type operatorType)
 95 {
 96     m_baseCharacter = baseCharacter;
 97     m_operatorType = operatorType;
 98     reset(style);
 99 }
100 
101 void MathOperator::reset(const RenderStyle&amp; style)
102 {
103     m_stretchType = StretchType::Unstretched;
104     m_maxPreferredWidth = 0;
105     m_width = 0;
106     m_ascent = 0;
107     m_descent = 0;
108     m_italicCorrection = 0;
109     m_radicalVerticalScale = 1;
110 
111     // We use the base size for the calculation of the preferred width.
112     GlyphData baseGlyph;
113     if (!getBaseGlyph(style, baseGlyph))
114         return;
115     m_maxPreferredWidth = m_width = advanceWidthForGlyph(baseGlyph);
116     getAscentAndDescentForGlyph(baseGlyph, m_ascent, m_descent);
117 
118     if (m_operatorType == Type::VerticalOperator)
119         calculateStretchyData(style, true); // We also take into account the width of larger sizes for the calculation of the preferred width.
120     else if (m_operatorType == Type::DisplayOperator)
121         calculateDisplayStyleLargeOperator(style); // We can directly select the size variant and determine the final metrics.
122 }
123 
124 LayoutUnit MathOperator::stretchSize() const
125 {
126     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
127     return m_operatorType == Type::VerticalOperator ? m_ascent + m_descent : m_width;
128 }
129 
130 bool MathOperator::getGlyph(const RenderStyle&amp; style, UChar32 character, GlyphData&amp; glyph) const
131 {
132     glyph = style.fontCascade().glyphDataForCharacter(character, !style.isLeftToRightDirection());
133     return glyph.font &amp;&amp; glyph.font == &amp;style.fontCascade().primaryFont();
134 }
135 
136 void MathOperator::setSizeVariant(const GlyphData&amp; sizeVariant)
137 {
138     ASSERT(sizeVariant.font);
139     ASSERT(sizeVariant.font-&gt;mathData());
140     m_stretchType = StretchType::SizeVariant;
141     m_variantGlyph = sizeVariant.glyph;
142     m_width = advanceWidthForGlyph(sizeVariant);
143     getAscentAndDescentForGlyph(sizeVariant, m_ascent, m_descent);
144 }
145 
146 static GlyphData glyphDataForCodePointOrFallbackGlyph(const RenderStyle&amp; style, UChar32 codePoint, Glyph fallbackGlyph)
147 {
148     if (codePoint)
149         return style.fontCascade().glyphDataForCharacter(codePoint, false);
150 
151     GlyphData fallback;
152 
153     if (fallbackGlyph) {
154         fallback.glyph = fallbackGlyph;
155         fallback.font = &amp;style.fontCascade().primaryFont();
156     }
157 
158     return fallback;
159 }
160 
161 void MathOperator::setGlyphAssembly(const RenderStyle&amp; style, const GlyphAssemblyData&amp; assemblyData)
162 {
163     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
164     m_stretchType = StretchType::GlyphAssembly;
165     m_assembly = assemblyData;
166 
167     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
168     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
169     auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
170     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
171 
172     if (m_operatorType == Type::VerticalOperator) {
173         m_width = 0;
174         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(topOrRight)));
175         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(extension)));
176         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(bottomOrLeft)));
177         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(middle)));
178     } else {
179         m_ascent = 0;
180         m_descent = 0;
181         LayoutUnit ascent, descent;
182         getAscentAndDescentForGlyph(bottomOrLeft, ascent, descent);
183         m_ascent = std::max(m_ascent, ascent);
184         m_descent = std::max(m_descent, descent);
185         getAscentAndDescentForGlyph(extension, ascent, descent);
186         m_ascent = std::max(m_ascent, ascent);
187         m_descent = std::max(m_descent, descent);
188         getAscentAndDescentForGlyph(topOrRight, ascent, descent);
189         m_ascent = std::max(m_ascent, ascent);
190         m_descent = std::max(m_descent, descent);
191         getAscentAndDescentForGlyph(middle, ascent, descent);
192         m_ascent = std::max(m_ascent, ascent);
193         m_descent = std::max(m_descent, descent);
194     }
195 }
196 
197 // The MathML specification recommends avoiding combining characters.
198 // See https://www.w3.org/TR/MathML/chapter7.html#chars.comb-chars
199 // However, many math fonts do not provide constructions for the non-combining equivalent.
200 const unsigned maxFallbackPerCharacter = 3;
201 static const UChar32 characterFallback[][maxFallbackPerCharacter] = {
202     { 0x005E, 0x0302, 0 }, // CIRCUMFLEX ACCENT
203     { 0x005F, 0x0332, 0 }, // LOW LINE
204     { 0x007E, 0x0303, 0 }, // TILDE
205     { 0x00AF, 0x0304, 0x0305 }, // MACRON
206     { 0x02C6, 0x0302, 0 }, // MODIFIER LETTER CIRCUMFLEX ACCENT
207     { 0x02C7, 0x030C, 0 } // CARON
208 };
209 const unsigned characterFallbackSize = WTF_ARRAY_LENGTH(characterFallback);
210 
211 void MathOperator::getMathVariantsWithFallback(const RenderStyle&amp; style, bool isVertical, Vector&lt;Glyph&gt;&amp; sizeVariants, Vector&lt;OpenTypeMathData::AssemblyPart&gt;&amp; assemblyParts)
212 {
213     // In general, we first try and find contruction for the base glyph.
214     GlyphData baseGlyph;
215     if (!getBaseGlyph(style, baseGlyph) || !baseGlyph.font-&gt;mathData())
216         return;
217     baseGlyph.font-&gt;mathData()-&gt;getMathVariants(baseGlyph.glyph, isVertical, sizeVariants, assemblyParts);
218     if (!sizeVariants.isEmpty() || !assemblyParts.isEmpty())
219         return;
220 
221     // Otherwise, we try and find fallback constructions using similar characters.
222     for (unsigned i = 0; i &lt; characterFallbackSize; i++) {
223         unsigned j = 0;
224         if (characterFallback[i][j] == m_baseCharacter) {
225             for (j++; j &lt; maxFallbackPerCharacter &amp;&amp; characterFallback[i][j]; j++) {
226                 GlyphData glyphData;
227                 if (!getGlyph(style, characterFallback[i][j], glyphData))
228                     continue;
229                 glyphData.font-&gt;mathData()-&gt;getMathVariants(glyphData.glyph, isVertical, sizeVariants, assemblyParts);
230                 if (!sizeVariants.isEmpty() || !assemblyParts.isEmpty())
231                     return;
232             }
233             break;
234         }
235     }
236 }
237 
238 void MathOperator::calculateDisplayStyleLargeOperator(const RenderStyle&amp; style)
239 {
240     ASSERT(m_operatorType == Type::DisplayOperator);
241 
242     GlyphData baseGlyph;
243     if (!getBaseGlyph(style, baseGlyph) || !baseGlyph.font-&gt;mathData())
244         return;
245 
246     // The value of displayOperatorMinHeight is sometimes too small, so we ensure that it is at least \sqrt{2} times the size of the base glyph.
247     float displayOperatorMinHeight = std::max(heightForGlyph(baseGlyph) * sqrtOfTwoFloat, baseGlyph.font-&gt;mathData()-&gt;getMathConstant(*baseGlyph.font, OpenTypeMathData::DisplayOperatorMinHeight));
248 
249     Vector&lt;Glyph&gt; sizeVariants;
250     Vector&lt;OpenTypeMathData::AssemblyPart&gt; assemblyParts;
251     baseGlyph.font-&gt;mathData()-&gt;getMathVariants(baseGlyph.glyph, true, sizeVariants, assemblyParts);
252 
253     // We choose the first size variant that is larger than the expected displayOperatorMinHeight and otherwise fallback to the largest variant.
254     for (auto&amp; sizeVariant : sizeVariants) {
255         GlyphData glyphData(sizeVariant, baseGlyph.font);
256         setSizeVariant(glyphData);
257         m_maxPreferredWidth = m_width;
258         m_italicCorrection = glyphData.font-&gt;mathData()-&gt;getItalicCorrection(*glyphData.font, glyphData.glyph);
259         if (heightForGlyph(glyphData) &gt;= displayOperatorMinHeight)
260             break;
261     }
262 }
263 
264 bool MathOperator::calculateGlyphAssemblyFallback(const Vector&lt;OpenTypeMathData::AssemblyPart&gt;&amp; assemblyParts, GlyphAssemblyData&amp; assemblyData) const
265 {
266     // The structure of the Open Type Math table is a bit more general than the one currently used by the MathOperator code, so we try to fallback in a reasonable way.
267     // FIXME: MathOperator should support the most general format (https://bugs.webkit.org/show_bug.cgi?id=130327).
268     // We use the approach of the copyComponents function in github.com/mathjax/MathJax-dev/blob/master/fonts/OpenTypeMath/fontUtil.py
269 
270     // We count the number of non extender pieces.
271     int nonExtenderCount = 0;
272     for (auto&amp; part : assemblyParts) {
273         if (!part.isExtender)
274             nonExtenderCount++;
275     }
276     if (nonExtenderCount &gt; 3)
277         return false; // This is not supported: there are too many pieces.
278 
279     // We now browse the list of pieces from left to right for horizontal operators and from bottom to top for vertical operators.
280     enum PartType {
281         Start,
282         ExtenderBetweenStartAndMiddle,
283         Middle,
284         ExtenderBetweenMiddleAndEnd,
285         End,
286         None
287     };
288     PartType expectedPartType = Start;
289     assemblyData.extensionCodePoint = 0;
290     assemblyData.extensionFallbackGlyph = 0;
291     assemblyData.middleCodePoint = 0;
292     assemblyData.middleFallbackGlyph = 0;
293     for (auto&amp; part : assemblyParts) {
294         if (nonExtenderCount &lt; 3) {
295             // If we only have at most two non-extenders then we skip the middle glyph.
296             if (expectedPartType == ExtenderBetweenStartAndMiddle)
297                 expectedPartType = ExtenderBetweenMiddleAndEnd;
298             else if (expectedPartType == Middle)
299                 expectedPartType = End;
300         }
301         if (part.isExtender) {
302             if (!assemblyData.extensionFallbackGlyph)
303                 assemblyData.extensionFallbackGlyph = part.glyph; // We copy the extender part.
304             else if (assemblyData.extensionFallbackGlyph != part.glyph)
305                 return false; // This is not supported: the assembly has different extenders.
306 
307             switch (expectedPartType) {
308             case Start:
309                 // We ignore the left/bottom part.
310                 expectedPartType = ExtenderBetweenStartAndMiddle;
311                 continue;
312             case Middle:
313                 // We ignore the middle part.
314                 expectedPartType = ExtenderBetweenMiddleAndEnd;
315                 continue;
316             case End:
317             case None:
318                 // This is not supported: we got an unexpected extender.
319                 return false;
320             case ExtenderBetweenStartAndMiddle:
321             case ExtenderBetweenMiddleAndEnd:
322                 // We ignore multiple consecutive extenders.
323                 continue;
324             }
325         }
326 
327         switch (expectedPartType) {
328         case Start:
329             // We copy the left/bottom part.
330             assemblyData.bottomOrLeftFallbackGlyph = part.glyph;
331             assemblyData.bottomOrLeftCodePoint = 0;
332             expectedPartType = ExtenderBetweenStartAndMiddle;
333             continue;
334         case ExtenderBetweenStartAndMiddle:
335         case Middle:
336             // We copy the middle part.
337             assemblyData.middleFallbackGlyph = part.glyph;
338             expectedPartType = ExtenderBetweenMiddleAndEnd;
339             continue;
340         case ExtenderBetweenMiddleAndEnd:
341         case End:
342             // We copy the right/top part.
343             assemblyData.topOrRightFallbackGlyph = part.glyph;
344             assemblyData.topOrRightCodePoint = 0;
345             expectedPartType = None;
346             continue;
347         case None:
348             // This is not supported: we got an unexpected non-extender part.
349             return false;
350         }
351     }
352 
353     if (!assemblyData.hasExtension())
354         return false; // This is not supported: we always assume that we have an extension glyph.
355 
356     // If we don&#39;t have top/bottom glyphs, we use the extension glyph.
357     if (!assemblyData.topOrRightCodePoint &amp;&amp; !assemblyData.topOrRightFallbackGlyph)
358         assemblyData.topOrRightFallbackGlyph = assemblyData.extensionFallbackGlyph;
359     if (!assemblyData.bottomOrLeftCodePoint &amp;&amp; !assemblyData.bottomOrLeftFallbackGlyph)
360         assemblyData.bottomOrLeftFallbackGlyph = assemblyData.extensionFallbackGlyph;
361 
362     return true;
363 }
364 
365 void MathOperator::calculateStretchyData(const RenderStyle&amp; style, bool calculateMaxPreferredWidth, LayoutUnit targetSize)
366 {
367     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
368     ASSERT(!calculateMaxPreferredWidth || m_operatorType == Type::VerticalOperator);
369     bool isVertical = m_operatorType == Type::VerticalOperator;
370 
371     GlyphData baseGlyph;
372     if (!getBaseGlyph(style, baseGlyph))
373         return;
374 
375     if (!calculateMaxPreferredWidth) {
376         // We do not stretch if the base glyph is large enough.
377         float baseSize = isVertical ? heightForGlyph(baseGlyph) : advanceWidthForGlyph(baseGlyph);
378         if (targetSize &lt;= baseSize)
379             return;
380     }
381 
382     GlyphAssemblyData assemblyData;
383     if (baseGlyph.font-&gt;mathData()) {
384         Vector&lt;Glyph&gt; sizeVariants;
385         Vector&lt;OpenTypeMathData::AssemblyPart&gt; assemblyParts;
386         getMathVariantsWithFallback(style, isVertical, sizeVariants, assemblyParts);
387         // We verify the size variants.
388         for (auto&amp; sizeVariant : sizeVariants) {
389             GlyphData glyphData(sizeVariant, baseGlyph.font);
390             if (calculateMaxPreferredWidth)
391                 m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(glyphData)));
392             else {
393                 setSizeVariant(glyphData);
394                 LayoutUnit size { isVertical ? heightForGlyph(glyphData) : advanceWidthForGlyph(glyphData) };
395                 if (size &gt;= targetSize)
396                     return;
397             }
398         }
399 
400         // We verify if there is a construction.
401         if (!calculateGlyphAssemblyFallback(assemblyParts, assemblyData))
402             return;
403     } else {
404         if (!isVertical)
405             return;
406 
407         // If the font does not have a MATH table, we fallback to the Unicode-only constructions.
408         const StretchyCharacter* stretchyCharacter = nullptr;
409         const unsigned maxIndex = WTF_ARRAY_LENGTH(stretchyCharacters);
410         for (unsigned index = 0; index &lt; maxIndex; ++index) {
411             if (stretchyCharacters[index].character == m_baseCharacter) {
412                 stretchyCharacter = &amp;stretchyCharacters[index];
413                 if (!style.isLeftToRightDirection() &amp;&amp; index &lt; leftRightPairsCount * 2) {
414                     // If we are in right-to-left direction we select the mirrored form by adding -1 or +1 according to the parity of index.
415                     index += index % 2 ? -1 : 1;
416                 }
417                 break;
418             }
419         }
420 
421         // Unicode contains U+23B7 RADICAL SYMBOL BOTTOM but it is generally not provided by fonts without a MATH table.
422         // Moreover, it&#39;s not clear what the proper vertical extender or top hook would be.
423         // Hence we fallback to scaling the base glyph vertically.
424         if (!calculateMaxPreferredWidth &amp;&amp; m_baseCharacter == kRadicalOperator) {
425             LayoutUnit height = m_ascent + m_descent;
426             if (height &gt; 0 &amp;&amp; height &lt; targetSize) {
427                 m_radicalVerticalScale = targetSize.toFloat() / height;
428                 m_ascent *= m_radicalVerticalScale;
429                 m_descent *= m_radicalVerticalScale;
430             }
431             return;
432         }
433 
434         // If we didn&#39;t find a stretchy character set for this character, we don&#39;t know how to stretch it.
435         if (!stretchyCharacter)
436             return;
437 
438         // We convert the list of Unicode characters into a list of glyph data.
439         assemblyData.topOrRightCodePoint = stretchyCharacter-&gt;topChar;
440         assemblyData.extensionCodePoint = stretchyCharacter-&gt;extensionChar;
441         assemblyData.bottomOrLeftCodePoint = stretchyCharacter-&gt;bottomChar;
442         assemblyData.middleCodePoint = stretchyCharacter-&gt;middleChar;
443     }
444 
445     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.topOrRightCodePoint, assemblyData.topOrRightFallbackGlyph);
446     auto extension = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.extensionCodePoint, assemblyData.extensionFallbackGlyph);
447     auto middle = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.middleCodePoint, assemblyData.middleFallbackGlyph);
448     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.bottomOrLeftCodePoint, assemblyData.bottomOrLeftFallbackGlyph);
449 
450     // If we are measuring the maximum width, verify each component.
451     if (calculateMaxPreferredWidth) {
452         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(topOrRight)));
453         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(extension)));
454         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(middle)));
455         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(bottomOrLeft)));
456         return;
457     }
458 
459     // We ensure that the size is large enough to avoid glyph overlaps.
460     float minSize = isVertical ?
461         heightForGlyph(topOrRight) + heightForGlyph(middle) + heightForGlyph(bottomOrLeft)
462         : advanceWidthForGlyph(bottomOrLeft) + advanceWidthForGlyph(middle) + advanceWidthForGlyph(topOrRight);
463     if (minSize &gt; targetSize)
464         return;
465 
466     setGlyphAssembly(style, assemblyData);
467 }
468 
469 void MathOperator::stretchTo(const RenderStyle&amp; style, LayoutUnit targetSize)
470 {
471     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
472     calculateStretchyData(style, false, targetSize);
473     if (m_stretchType == StretchType::GlyphAssembly) {
474         if (m_operatorType == Type::VerticalOperator) {
475             m_ascent = targetSize;
476             m_descent = 0;
477         } else
478             m_width = targetSize;
479     }
480 }
481 
482 LayoutRect MathOperator::paintGlyph(const RenderStyle&amp; style, PaintInfo&amp; info, const GlyphData&amp; data, const LayoutPoint&amp; origin, GlyphPaintTrimming trim)
483 {
484     FloatRect glyphBounds = boundsForGlyph(data);
485 
486     LayoutRect glyphPaintRect(origin, LayoutSize(glyphBounds.x() + glyphBounds.width(), glyphBounds.height()));
487     glyphPaintRect.setY(origin.y() + glyphBounds.y());
488 
489     // In order to have glyphs fit snugly with one another we snap the connecting edges to pixel boundaries
490     // and trim off one pixel. The pixel trim is to account for fonts that have edge pixels that have less
491     // than full coverage. These edge pixels can introduce small seams between connected glyphs.
492     FloatRect clipBounds = info.rect;
493     switch (trim) {
494     case TrimTop:
495         glyphPaintRect.shiftYEdgeTo(glyphPaintRect.y().ceil() + 1);
496         clipBounds.shiftYEdgeTo(glyphPaintRect.y());
497         break;
498     case TrimBottom:
499         glyphPaintRect.shiftMaxYEdgeTo(glyphPaintRect.maxY().floor() - 1);
500         clipBounds.shiftMaxYEdgeTo(glyphPaintRect.maxY());
501         break;
502     case TrimTopAndBottom:
503         glyphPaintRect.shiftYEdgeTo(glyphPaintRect.y().ceil() + 1);
504         glyphPaintRect.shiftMaxYEdgeTo(glyphPaintRect.maxY().floor() - 1);
505         clipBounds.shiftYEdgeTo(glyphPaintRect.y());
506         clipBounds.shiftMaxYEdgeTo(glyphPaintRect.maxY());
507         break;
508     case TrimLeft:
509         glyphPaintRect.shiftXEdgeTo(glyphPaintRect.x().ceil() + 1);
510         clipBounds.shiftXEdgeTo(glyphPaintRect.x());
511         break;
512     case TrimRight:
513         glyphPaintRect.shiftMaxXEdgeTo(glyphPaintRect.maxX().floor() - 1);
514         clipBounds.shiftMaxXEdgeTo(glyphPaintRect.maxX());
515         break;
516     case TrimLeftAndRight:
517         glyphPaintRect.shiftXEdgeTo(glyphPaintRect.x().ceil() + 1);
518         glyphPaintRect.shiftMaxXEdgeTo(glyphPaintRect.maxX().floor() - 1);
519         clipBounds.shiftXEdgeTo(glyphPaintRect.x());
520         clipBounds.shiftMaxXEdgeTo(glyphPaintRect.maxX());
521     }
522 
523     // Clipping the enclosing IntRect avoids any potential issues at joined edges.
524     GraphicsContextStateSaver stateSaver(info.context());
525     info.context().clip(clipBounds);
526 
527     GlyphBuffer buffer;
528     buffer.add(data.glyph, data.font, advanceWidthForGlyph(data));
529     info.context().drawGlyphs(*data.font, buffer, 0, 1, origin, style.fontCascade().fontDescription().fontSmoothing());
530 
531     return glyphPaintRect;
532 }
533 
534 void MathOperator::fillWithVerticalExtensionGlyph(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; from, const LayoutPoint&amp; to)
535 {
536     ASSERT(m_operatorType == Type::VerticalOperator);
537     ASSERT(m_stretchType == StretchType::GlyphAssembly);
538 
539     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
540 
541     ASSERT(extension.font);
542     ASSERT(from.y() &lt;= to.y());
543 
544     // If there is no space for the extension glyph, we don&#39;t need to do anything.
545     if (from.y() == to.y())
546         return;
547 
548     GraphicsContextStateSaver stateSaver(info.context());
549 
550     FloatRect glyphBounds = boundsForGlyph(extension);
551 
552     // Clipping the extender region here allows us to draw the bottom extender glyph into the
553     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
554     LayoutRect clipBounds = info.rect;
555     clipBounds.shiftYEdgeTo(from.y());
556     clipBounds.shiftMaxYEdgeTo(to.y());
557     info.context().clip(clipBounds);
558 
559     // Trimming may remove up to two pixels from the top of the extender glyph, so we move it up by two pixels.
560     float offsetToGlyphTop = glyphBounds.y() + 2;
561     LayoutPoint glyphOrigin { from.x(), LayoutUnit(from.y() - offsetToGlyphTop) };
562     FloatRect lastPaintedGlyphRect(from, FloatSize());
563 
564     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
565     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxY() &lt; to.y() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
566         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimTopAndBottom);
567         glyphOrigin.setY(glyphOrigin.y() + lastPaintedGlyphRect.height());
568 
569         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
570         // with trimming. In that case we just draw nothing.
571         if (lastPaintedGlyphRect.isEmpty())
572             break;
573     }
574 }
575 
576 void MathOperator::fillWithHorizontalExtensionGlyph(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; from, const LayoutPoint&amp; to)
577 {
578     ASSERT(m_operatorType == Type::HorizontalOperator);
579     ASSERT(m_stretchType == StretchType::GlyphAssembly);
580 
581     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
582 
583     ASSERT(extension.font);
584     ASSERT(from.x() &lt;= to.x());
585     ASSERT(from.y() == to.y());
586 
587     // If there is no space for the extension glyph, we don&#39;t need to do anything.
588     if (from.x() == to.x())
589         return;
590 
591     GraphicsContextStateSaver stateSaver(info.context());
592 
593     // Clipping the extender region here allows us to draw the bottom extender glyph into the
594     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
595     LayoutRect clipBounds = info.rect;
596     clipBounds.shiftXEdgeTo(from.x());
597     clipBounds.shiftMaxXEdgeTo(to.x());
598     info.context().clip(clipBounds);
599 
600     // Trimming may remove up to two pixels from the left of the extender glyph, so we move it left by two pixels.
601     float offsetToGlyphLeft = -2;
602     LayoutPoint glyphOrigin { LayoutUnit(from.x() + offsetToGlyphLeft), from.y() };
603     FloatRect lastPaintedGlyphRect(from, FloatSize());
604 
605     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
606     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxX() &lt; to.x() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
607         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimLeftAndRight);
608         glyphOrigin.setX(glyphOrigin.x() + lastPaintedGlyphRect.width());
609 
610         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
611         // with trimming. In that case we just draw nothing.
612         if (lastPaintedGlyphRect.isEmpty())
613             break;
614     }
615 }
616 
617 void MathOperator::paintVerticalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
618 {
619     ASSERT(m_operatorType == Type::VerticalOperator);
620     ASSERT(m_stretchType == StretchType::GlyphAssembly);
621 
622     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
623     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
624 
625     ASSERT(topOrRight.font);
626     ASSERT(bottomOrLeft.font);
627     if (!topOrRight.font || !bottomOrLeft.font) {
628         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
629         return;
630     }
631 
632     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
633     LayoutPoint operatorTopLeft = paintOffset;
634     FloatRect topGlyphBounds = boundsForGlyph(topOrRight);
635     LayoutPoint topGlyphOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() - topGlyphBounds.y()) };
636     LayoutRect topGlyphPaintRect = paintGlyph(style, info, topOrRight, topGlyphOrigin, TrimBottom);
637 
638     FloatRect bottomGlyphBounds = boundsForGlyph(bottomOrLeft);
639     LayoutPoint bottomGlyphOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() + stretchSize() - (bottomGlyphBounds.height() + bottomGlyphBounds.y())) };
640     LayoutRect bottomGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, bottomGlyphOrigin, TrimTop);
641 
642     if (m_assembly.hasMiddle()) {
643         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
644 
645         // Center the glyph origin between the start and end glyph paint extents. Then shift it half the paint height toward the bottom glyph.
646         FloatRect middleGlyphBounds = boundsForGlyph(middle);
647         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), topGlyphOrigin.y());
648         middleGlyphOrigin.moveBy(LayoutPoint(0, (bottomGlyphPaintRect.y() - topGlyphPaintRect.maxY()) / 2.0));
649         middleGlyphOrigin.moveBy(LayoutPoint(0, middleGlyphBounds.height() / 2.0));
650 
651         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimTopAndBottom);
652         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), middleGlyphPaintRect.minXMinYCorner());
653         fillWithVerticalExtensionGlyph(style, info, middleGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
654     } else
655         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
656 }
657 
658 void MathOperator::paintHorizontalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
659 {
660     ASSERT(m_operatorType == Type::HorizontalOperator);
661     ASSERT(m_stretchType == StretchType::GlyphAssembly);
662 
663     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
664     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
665 
666     ASSERT(bottomOrLeft.font);
667     ASSERT(topOrRight.font);
668     if (!topOrRight.font || !bottomOrLeft.font) {
669         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
670         return;
671     }
672 
673     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
674     LayoutPoint operatorTopLeft = paintOffset;
675     LayoutUnit baselineY = operatorTopLeft.y() + m_ascent;
676     LayoutPoint leftGlyphOrigin(operatorTopLeft.x(), baselineY);
677     LayoutRect leftGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, leftGlyphOrigin, TrimRight);
678 
679     FloatRect rightGlyphBounds = boundsForGlyph(topOrRight);
680     LayoutPoint rightGlyphOrigin { LayoutUnit(operatorTopLeft.x() + stretchSize() - rightGlyphBounds.width()), baselineY };
681     LayoutRect rightGlyphPaintRect = paintGlyph(style, info, topOrRight, rightGlyphOrigin, TrimLeft);
682 
683     if (m_assembly.hasMiddle()) {
684         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
685 
686         // Center the glyph origin between the start and end glyph paint extents.
687         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), baselineY);
688         middleGlyphOrigin.moveBy(LayoutPoint((rightGlyphPaintRect.x() - leftGlyphPaintRect.maxX()) / 2.0, 0));
689         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimLeftAndRight);
690         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(middleGlyphPaintRect.x(), baselineY));
691         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(middleGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
692     } else
693         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
694 }
695 
696 void MathOperator::paint(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
697 {
698     if (info.context().paintingDisabled() || info.phase != PaintPhase::Foreground || style.visibility() != Visibility::Visible)
699         return;
700 
701     // Make a copy of the PaintInfo because applyTransform will modify its rect.
702     PaintInfo paintInfo(info);
703     GraphicsContextStateSaver stateSaver(paintInfo.context());
704     paintInfo.context().setFillColor(style.visitedDependentColorWithColorFilter(CSSPropertyColor));
705 
706     // For a radical character, we may need some scale transform to stretch it vertically or mirror it.
707     if (m_baseCharacter == kRadicalOperator) {
708         float radicalHorizontalScale = style.isLeftToRightDirection() ? 1 : -1;
709         if (radicalHorizontalScale == -1 || m_radicalVerticalScale &gt; 1) {
710             LayoutPoint scaleOrigin = paintOffset;
711             scaleOrigin.move(m_width / 2, 0_lu);
712             paintInfo.applyTransform(AffineTransform().translate(scaleOrigin).scale(radicalHorizontalScale, m_radicalVerticalScale).translate(-scaleOrigin));
713         }
714     }
715 
716     if (m_stretchType == StretchType::GlyphAssembly) {
717         if (m_operatorType == Type::VerticalOperator)
718             paintVerticalGlyphAssembly(style, info, paintOffset);
719         else
720             paintHorizontalGlyphAssembly(style, info, paintOffset);
721         return;
722     }
723 
724     GlyphData glyphData;
725     ASSERT(m_stretchType == StretchType::Unstretched || m_stretchType == StretchType::SizeVariant);
726     if (!getBaseGlyph(style, glyphData))
727         return;
728     if (m_stretchType == StretchType::SizeVariant)
729         glyphData.glyph = m_variantGlyph;
730 
731     GlyphBuffer buffer;
732     buffer.add(glyphData.glyph, glyphData.font, advanceWidthForGlyph(glyphData));
733     LayoutPoint operatorTopLeft = paintOffset;
734     FloatRect glyphBounds = boundsForGlyph(glyphData);
735     LayoutPoint operatorOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() - glyphBounds.y()) };
736     paintInfo.context().drawGlyphs(*glyphData.font, buffer, 0, 1, operatorOrigin, style.fontCascade().fontDescription().fontSmoothing());
737 }
738 
739 }
740 
741 #endif
    </pre>
  </body>
</html>