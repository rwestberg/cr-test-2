<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/SubresourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SubresourceLoader.h&quot;
 31 
 32 #include &quot;CachedRawResource.h&quot;
 33 #include &quot;CachedResourceLoader.h&quot;
 34 #include &quot;CrossOriginAccessControl.h&quot;
 35 #include &quot;CustomHeaderFields.h&quot;
 36 #include &quot;DiagnosticLoggingClient.h&quot;
 37 #include &quot;DiagnosticLoggingKeys.h&quot;
 38 #include &quot;Document.h&quot;
 39 #include &quot;DocumentLoader.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;HTTPParsers.h&quot;
 43 #include &quot;LinkLoader.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;MemoryCache.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ResourceLoadObserver.h&quot;
 48 #include &quot;ResourceTiming.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &lt;wtf/CompletionHandler.h&gt;
 52 #include &lt;wtf/Ref.h&gt;
 53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 54 #include &lt;wtf/StdLibExtras.h&gt;
 55 #include &lt;wtf/SystemTracing.h&gt;
 56 #include &lt;wtf/text/CString.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &lt;RuntimeApplicationChecks.h&gt;
 60 #endif
 61 
 62 #if ENABLE(CONTENT_EXTENSIONS)
 63 #include &quot;ResourceLoadInfo.h&quot;
 64 #endif
 65 
 66 #if USE(QUICK_LOOK)
 67 #include &quot;PreviewConverter.h&quot;
 68 #include &quot;PreviewLoader.h&quot;
 69 #endif
 70 
 71 #undef RELEASE_LOG_IF_ALLOWED
 72 #undef RELEASE_LOG_ERROR_IF_ALLOWED
 73 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 74 #define RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ResourceLoading, &quot;%p - SubresourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 75 
 76 namespace WebCore {
 77 
 78 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, (&quot;SubresourceLoader&quot;));
 79 
 80 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader&amp; cachedResourceLoader, const CachedResource&amp; resource)
 81     : m_cachedResourceLoader(cachedResourceLoader)
 82     , m_resource(resource)
 83 {
 84     m_cachedResourceLoader.incrementRequestCount(m_resource);
 85 }
 86 
 87 SubresourceLoader::RequestCountTracker::~RequestCountTracker()
 88 {
 89     m_cachedResourceLoader.decrementRequestCount(m_resource);
 90 }
 91 
 92 SubresourceLoader::SubresourceLoader(Frame&amp; frame, CachedResource&amp; resource, const ResourceLoaderOptions&amp; options)
 93     : ResourceLoader(frame, options)
 94     , m_resource(&amp;resource)
 95     , m_state(Uninitialized)
 96     , m_requestCountTracker(std::in_place, frame.document()-&gt;cachedResourceLoader(), resource)
 97 {
 98 #ifndef NDEBUG
 99     subresourceLoaderCounter.increment();
100 #endif
101 #if ENABLE(CONTENT_EXTENSIONS)
102     m_resourceType = ContentExtensions::toResourceType(resource.type());
103 #endif
104     m_canCrossOriginRequestsAskUserForCredentials = resource.type() == CachedResource::Type::MainResource || frame.settings().allowCrossOriginSubresourcesToAskForCredentials();
105 }
106 
107 SubresourceLoader::~SubresourceLoader()
108 {
109     ASSERT(m_state != Initialized);
110     ASSERT(reachedTerminalState());
111 #ifndef NDEBUG
112     subresourceLoaderCounter.decrement();
113 #endif
114 }
115 
116 void SubresourceLoader::create(Frame&amp; frame, CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceLoaderOptions&amp; options, CompletionHandler&lt;void(RefPtr&lt;SubresourceLoader&gt;&amp;&amp;)&gt;&amp;&amp; completionHandler)
117 {
118     auto subloader(adoptRef(*new SubresourceLoader(frame, resource, options)));
119 #if PLATFORM(IOS_FAMILY)
120     if (!IOSApplication::isWebProcess()) {
121         // On iOS, do not invoke synchronous resource load delegates while resource load scheduling
122         // is disabled to avoid re-entering style selection from a different thread (see &lt;rdar://problem/9121719&gt;).
123         // FIXME: This should be fixed for all ports in &lt;https://bugs.webkit.org/show_bug.cgi?id=56647&gt;.
124         subloader-&gt;m_iOSOriginalRequest = request;
125         return completionHandler(WTFMove(subloader));
126     }
127 #endif
128     subloader-&gt;init(WTFMove(request), [subloader = subloader.copyRef(), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
129         if (!initialized)
130             return completionHandler(nullptr);
131         completionHandler(WTFMove(subloader));
132     });
133 }
134 
135 #if PLATFORM(IOS_FAMILY)
136 void SubresourceLoader::startLoading()
137 {
138     // FIXME: this should probably be removed.
139     ASSERT(!IOSApplication::isWebProcess());
140     init(ResourceRequest(m_iOSOriginalRequest), [this, protectedThis = makeRef(*this)] (bool success) {
141         if (!success)
142             return;
143         m_iOSOriginalRequest = ResourceRequest();
144         start();
145     });
146 }
147 #endif
148 
149 CachedResource* SubresourceLoader::cachedResource()
150 {
151     return m_resource;
152 }
153 
154 void SubresourceLoader::cancelIfNotFinishing()
155 {
156     if (m_state != Initialized)
157         return;
158 
159     ResourceLoader::cancel();
160 }
161 
162 void SubresourceLoader::init(ResourceRequest&amp;&amp; request, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler)
163 {
164     ResourceLoader::init(WTFMove(request), [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (bool initialized) mutable {
165         if (!initialized)
166             return completionHandler(false);
167         if (!m_documentLoader) {
168             ASSERT_NOT_REACHED();
169             RELEASE_LOG_ERROR(ResourceLoading, &quot;SubresourceLoader::init: resource load canceled because document loader is null (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
170             return completionHandler(false);
171         }
172         ASSERT(!reachedTerminalState());
173         m_state = Initialized;
174         m_documentLoader-&gt;addSubresourceLoader(this);
175         m_origin = m_resource-&gt;origin();
176         completionHandler(true);
177     });
178 }
179 
180 bool SubresourceLoader::isSubresourceLoader() const
181 {
182     return true;
183 }
184 
185 void SubresourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
186 {
187     // Store the previous URL because the call to ResourceLoader::willSendRequest will modify it.
188     URL previousURL = request().url();
189     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
190 
191     if (!newRequest.url().isValid()) {
192         cancel(cannotShowURLError());
193         return completionHandler(WTFMove(newRequest));
194     }
195 
196     if (newRequest.requester() != ResourceRequestBase::Requester::Main) {
197         tracePoint(SubresourceLoadWillStart);
198         ResourceLoadObserver::shared().logSubresourceLoading(m_frame.get(), newRequest, redirectResponse);
199     }
200 
201     auto continueWillSendRequest = [this, protectedThis = makeRef(*this), redirectResponse] (CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler, ResourceRequest&amp;&amp; newRequest) mutable {
202         if (newRequest.isNull() || reachedTerminalState())
203             return completionHandler(WTFMove(newRequest));
204 
205         ResourceLoader::willSendRequestInternal(WTFMove(newRequest), redirectResponse, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), redirectResponse] (ResourceRequest&amp;&amp; request) mutable {
206             if (reachedTerminalState())
207                 return completionHandler(WTFMove(request));
208 
209             if (request.isNull()) {
210                 cancel();
211                 return completionHandler(WTFMove(request));
212             }
213 
214             if (m_resource-&gt;type() == CachedResource::Type::MainResource &amp;&amp; !redirectResponse.isNull())
215                 m_documentLoader-&gt;willContinueMainResourceLoadAfterRedirect(request);
216             completionHandler(WTFMove(request));
217         });
218     };
219 
220     ASSERT(!newRequest.isNull());
221     if (!redirectResponse.isNull()) {
222         if (options().redirect != FetchOptions::Redirect::Follow) {
223             if (options().redirect == FetchOptions::Redirect::Error) {
224                 ResourceError error { errorDomainWebKitInternal, 0, request().url(), makeString(&quot;Not allowed to follow a redirection while loading &quot;, request().url().string()), ResourceError::Type::AccessControl };
225 
226                 if (m_frame &amp;&amp; m_frame-&gt;document())
227                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
228 
229                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because not allowed to follow a redirect (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
230 
231                 cancel(error);
232                 return completionHandler(WTFMove(newRequest));
233             }
234 
235             ResourceResponse opaqueRedirectedResponse = redirectResponse;
236             opaqueRedirectedResponse.setType(ResourceResponse::Type::Opaqueredirect);
237             opaqueRedirectedResponse.setTainting(ResourceResponse::Tainting::Opaqueredirect);
238             m_resource-&gt;responseReceived(opaqueRedirectedResponse);
239             if (reachedTerminalState()) {
240                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
241                 return;
242             }
243 
244             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load completed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
245 
246             NetworkLoadMetrics emptyMetrics;
247             didFinishLoading(emptyMetrics);
248             return completionHandler(WTFMove(newRequest));
249         } else if (m_redirectCount++ &gt;= options().maxRedirectCount) {
250             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because too many redirects (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
251             cancel(ResourceError(String(), 0, request().url(), &quot;Too many redirections&quot;_s, ResourceError::Type::General));
252             return completionHandler(WTFMove(newRequest));
253         }
254 
255         // CachedResources are keyed off their original request URL.
256         // Requesting the same original URL a second time can redirect to a unique second resource.
257         // Therefore, if a redirect to a different destination URL occurs, we should no longer consider this a revalidation of the first resource.
258         // Doing so would have us reusing the resource from the first request if the second request&#39;s revalidation succeeds.
259         if (newRequest.isConditional() &amp;&amp; m_resource-&gt;resourceToRevalidate() &amp;&amp; newRequest.url() != m_resource-&gt;resourceToRevalidate()-&gt;response().url()) {
260             newRequest.makeUnconditional();
261             MemoryCache::singleton().revalidationFailed(*m_resource);
262             if (m_frame &amp;&amp; m_frame-&gt;page())
263                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
264         }
265 
266         if (!m_documentLoader-&gt;cachedResourceLoader().updateRequestAfterRedirection(m_resource-&gt;type(), newRequest, options())) {
267             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because something about updateRequestAfterRedirection (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
268             cancel();
269             return completionHandler(WTFMove(newRequest));
270         }
271 
272         String errorDescription;
273         if (!checkRedirectionCrossOriginAccessControl(request(), redirectResponse, newRequest, errorDescription)) {
274             String errorMessage = &quot;Cross-origin redirection to &quot; + newRequest.url().string() + &quot; denied by Cross-Origin Resource Sharing policy: &quot; + errorDescription;
275             if (m_frame &amp;&amp; m_frame-&gt;document())
276                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorMessage);
277             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because crosss-origin redirection denied by CORS policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
278             cancel(ResourceError(String(), 0, request().url(), errorMessage, ResourceError::Type::AccessControl));
279             return completionHandler(WTFMove(newRequest));
280         }
281 
282         if (m_resource-&gt;isImage() &amp;&amp; m_documentLoader-&gt;cachedResourceLoader().shouldDeferImageLoad(newRequest.url())) {
283             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because it&#39;s an image that should be defered (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
284             cancel();
285             return completionHandler(WTFMove(newRequest));
286         }
287         m_loadTiming.addRedirect(redirectResponse.url(), newRequest.url());
288         m_resource-&gt;redirectReceived(WTFMove(newRequest), redirectResponse, [completionHandler = WTFMove(completionHandler), continueWillSendRequest = WTFMove(continueWillSendRequest)] (ResourceRequest&amp;&amp; request) mutable {
289             continueWillSendRequest(WTFMove(completionHandler), WTFMove(request));
290         });
291         return;
292     }
293 
294     continueWillSendRequest(WTFMove(completionHandler), WTFMove(newRequest));
295 }
296 
297 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
298 {
299     ASSERT(m_state == Initialized);
300     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
301     m_resource-&gt;didSendData(bytesSent, totalBytesToBeSent);
302 }
303 
304 #if USE(QUICK_LOOK)
305 
306 bool SubresourceLoader::shouldCreatePreviewLoaderForResponse(const ResourceResponse&amp; response) const
307 {
308     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
309         return false;
310 
311     if (m_previewLoader)
312         return false;
313 
314     return PreviewConverter::supportsMIMEType(response.mimeType());
315 }
316 
317 #endif
318 
319 void SubresourceLoader::didReceiveResponse(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
320 {
321     ASSERT(!response.isNull());
322     ASSERT(m_state == Initialized);
323 
324     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
325 
326 #if USE(QUICK_LOOK)
327     if (shouldCreatePreviewLoaderForResponse(response)) {
328         m_previewLoader = PreviewLoader::create(*this, response);
329         if (m_previewLoader-&gt;didReceiveResponse(response))
330             return;
331     }
332 #endif
333 #if ENABLE(SERVICE_WORKER)
334     // Implementing step 10 of https://fetch.spec.whatwg.org/#main-fetch for service worker responses.
335     if (response.source() == ResourceResponse::Source::ServiceWorker &amp;&amp; response.url() != request().url()) {
336         auto&amp; loader = m_documentLoader-&gt;cachedResourceLoader();
337         if (!loader.allowedByContentSecurityPolicy(m_resource-&gt;type(), response.url(), options(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
338             RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because not allowed by content policy (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
339             cancel(ResourceError({ }, 0, response.url(), { }, ResourceError::Type::General));
340             return;
341         }
342     }
343 #endif
344 
345     // We want redirect responses to be processed through willSendRequestInternal. Exceptions are
346     // redirection with no Location headers and fetch in manual redirect mode. Or in rare circumstances,
347     // cases of too many redirects from CFNetwork (&lt;rdar://problem/30610988&gt;).
348 #if !PLATFORM(COCOA)
349     ASSERT(response.httpStatusCode() &lt; 300 || response.httpStatusCode() &gt;= 400 || response.httpStatusCode() == 304 || !response.httpHeaderField(HTTPHeaderName::Location) || response.type() == ResourceResponse::Type::Opaqueredirect);
350 #endif
351 
352     // Reference the object in this method since the additional processing can do
353     // anything including removing the last reference to this object; one example of this is 3266216.
354     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
355 
356     if (shouldIncludeCertificateInfo())
357         response.includeCertificateInfo();
358 
359     if (m_resource-&gt;resourceToRevalidate()) {
360         if (response.httpStatusCode() == 304) {
361             // 304 Not modified / Use local copy
362             // Existing resource is ok, just use it updating the expiration time.
363             ResourceResponse revalidationResponse = response;
364             revalidationResponse.setSource(ResourceResponse::Source::MemoryCacheAfterValidation);
365             m_resource-&gt;setResponse(revalidationResponse);
366             MemoryCache::singleton().revalidationSucceeded(*m_resource, revalidationResponse);
367             if (m_frame &amp;&amp; m_frame-&gt;page())
368                 m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultPass, ShouldSample::Yes);
369             if (!reachedTerminalState())
370                 ResourceLoader::didReceiveResponse(revalidationResponse, [completionHandlerCaller = WTFMove(completionHandlerCaller)] { });
371             return;
372         }
373         // Did not get 304 response, continue as a regular resource load.
374         MemoryCache::singleton().revalidationFailed(*m_resource);
375         if (m_frame &amp;&amp; m_frame-&gt;page())
376             m_frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::cachedResourceRevalidationKey(), emptyString(), DiagnosticLoggingResultFail, ShouldSample::Yes);
377     }
378 
379     String errorDescription;
380     if (!checkResponseCrossOriginAccessControl(response, errorDescription)) {
381         if (m_frame &amp;&amp; m_frame-&gt;document())
382             m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
383         RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because of cross origin access control (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
384         cancel(ResourceError(String(), 0, request().url(), errorDescription, ResourceError::Type::AccessControl));
385         return;
386     }
387 
388     m_resource-&gt;responseReceived(response);
389     if (reachedTerminalState())
390         return;
391 
392     bool isResponseMultipart = response.isMultipart();
393     if (options().mode != FetchOptions::Mode::Navigate)
394         LinkLoader::loadLinksFromHeader(response.httpHeaderField(HTTPHeaderName::Link), m_documentLoader-&gt;url(), *m_frame-&gt;document(), LinkLoader::MediaAttributeCheck::SkipMediaAttributeCheck);
395     ResourceLoader::didReceiveResponse(response, [this, protectedThis = WTFMove(protectedThis), isResponseMultipart, completionHandlerCaller = WTFMove(completionHandlerCaller)]() mutable {
396         if (reachedTerminalState())
397             return;
398 
399         // FIXME: Main resources have a different set of rules for multipart than images do.
400         // Hopefully we can merge those 2 paths.
401         if (isResponseMultipart &amp;&amp; m_resource-&gt;type() != CachedResource::Type::MainResource) {
402             m_loadingMultipartContent = true;
403 
404             // We don&#39;t count multiParts in a CachedResourceLoader&#39;s request count
405             m_requestCountTracker = WTF::nullopt;
406             if (!m_resource-&gt;isImage()) {
407                 RELEASE_LOG_IF_ALLOWED(&quot;didReceiveResponse: canceling load because something about a multi-part non-image (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
408                 cancel();
409                 return;
410             }
411         }
412 
413         auto* buffer = resourceData();
414         if (m_loadingMultipartContent &amp;&amp; buffer &amp;&amp; buffer-&gt;size()) {
415             // The resource data will change as the next part is loaded, so we need to make a copy.
416             m_resource-&gt;finishLoading(buffer-&gt;copy().ptr());
417             clearResourceData();
418             // Since a subresource loader does not load multipart sections progressively, data was delivered to the loader all at once.
419             // After the first multipart section is complete, signal to delegates that this load is &quot;finished&quot;
420             NetworkLoadMetrics emptyMetrics;
421             m_documentLoader-&gt;subresourceLoaderFinishedLoadingOnePart(this);
422             didFinishLoadingOnePart(emptyMetrics);
423         }
424 
425         checkForHTTPStatusCodeError();
426 
427         if (m_inAsyncResponsePolicyCheck)
428             m_policyForResponseCompletionHandler = completionHandlerCaller.release();
429     });
430 }
431 
432 void SubresourceLoader::didReceiveResponsePolicy()
433 {
434     ASSERT(m_inAsyncResponsePolicyCheck);
435     m_inAsyncResponsePolicyCheck = false;
436     if (auto completionHandler = WTFMove(m_policyForResponseCompletionHandler))
437         completionHandler();
438 }
439 
440 void SubresourceLoader::didReceiveData(const char* data, unsigned length, long long encodedDataLength, DataPayloadType dataPayloadType)
441 {
442 #if USE(QUICK_LOOK)
443     if (auto previewLoader = m_previewLoader.get()) {
444         if (previewLoader-&gt;didReceiveData(data, length))
445             return;
446     }
447 #endif
448 
449     didReceiveDataOrBuffer(data, length, nullptr, encodedDataLength, dataPayloadType);
450 }
451 
452 void SubresourceLoader::didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
453 {
454 #if USE(QUICK_LOOK)
455     if (auto previewLoader = m_previewLoader.get()) {
456         if (previewLoader-&gt;didReceiveBuffer(buffer.get()))
457             return;
458     }
459 #endif
460 
461     didReceiveDataOrBuffer(nullptr, 0, WTFMove(buffer), encodedDataLength, dataPayloadType);
462 }
463 
464 void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
465 {
466     ASSERT(m_resource);
467 
468     if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
469         return;
470     ASSERT(!m_resource-&gt;resourceToRevalidate());
471     ASSERT(!m_resource-&gt;errorOccurred());
472     ASSERT(m_state == Initialized);
473     // Reference the object in this method since the additional processing can do
474     // anything including removing the last reference to this object; one example of this is 3266216.
475     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
476 
477     ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);
478 
479     if (!m_loadingMultipartContent) {
480         if (auto* resourceData = this-&gt;resourceData())
481             m_resource-&gt;updateBuffer(*resourceData);
482         else
483             m_resource-&gt;updateData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);
484     }
485 }
486 
487 bool SubresourceLoader::checkForHTTPStatusCodeError()
488 {
489     if (m_resource-&gt;response().httpStatusCode() &lt; 400 || m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
490         return false;
491 
492     m_state = Finishing;
493     m_resource-&gt;error(CachedResource::LoadError);
494     cancel();
495     return true;
496 }
497 
498 static void logResourceLoaded(Frame* frame, CachedResource::Type type)
499 {
500     if (!frame || !frame-&gt;page())
501         return;
502 
503     String resourceType;
504     switch (type) {
505     case CachedResource::Type::MainResource:
506         resourceType = DiagnosticLoggingKeys::mainResourceKey();
507         break;
508     case CachedResource::Type::ImageResource:
509         resourceType = DiagnosticLoggingKeys::imageKey();
510         break;
511 #if ENABLE(XSLT)
512     case CachedResource::Type::XSLStyleSheet:
513 #endif
514     case CachedResource::Type::CSSStyleSheet:
515         resourceType = DiagnosticLoggingKeys::styleSheetKey();
516         break;
517     case CachedResource::Type::Script:
518         resourceType = DiagnosticLoggingKeys::scriptKey();
519         break;
520     case CachedResource::Type::FontResource:
521 #if ENABLE(SVG_FONTS)
522     case CachedResource::Type::SVGFontResource:
523 #endif
524         resourceType = DiagnosticLoggingKeys::fontKey();
525         break;
526     case CachedResource::Type::Beacon:
527     case CachedResource::Type::Ping:
528     case CachedResource::Type::MediaResource:
529     case CachedResource::Type::Icon:
530     case CachedResource::Type::RawResource:
531         resourceType = DiagnosticLoggingKeys::rawKey();
532         break;
533     case CachedResource::Type::SVGDocumentResource:
534         resourceType = DiagnosticLoggingKeys::svgDocumentKey();
535         break;
536 #if ENABLE(APPLICATION_MANIFEST)
537     case CachedResource::Type::ApplicationManifest:
538         resourceType = DiagnosticLoggingKeys::applicationManifestKey();
539         break;
540 #endif
541     case CachedResource::Type::LinkPrefetch:
542 #if ENABLE(VIDEO_TRACK)
543     case CachedResource::Type::TextTrackResource:
544 #endif
545         resourceType = DiagnosticLoggingKeys::otherKey();
546         break;
547     }
548 
549     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::resourceLoadedKey(), resourceType, ShouldSample::Yes);
550 }
551 
552 bool SubresourceLoader::checkResponseCrossOriginAccessControl(const ResourceResponse&amp; response, String&amp; errorDescription)
553 {
554     if (!m_resource-&gt;isCrossOrigin() || options().mode != FetchOptions::Mode::Cors)
555         return true;
556 
557 #if ENABLE(SERVICE_WORKER)
558     if (response.source() == ResourceResponse::Source::ServiceWorker)
559         return response.tainting() != ResourceResponse::Tainting::Opaque;
560 #endif
561 
562     ASSERT(m_origin);
563 
564     return passesAccessControlCheck(response, options().credentials == FetchOptions::Credentials::Include ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse, *m_origin, errorDescription);
565 }
566 
567 bool SubresourceLoader::checkRedirectionCrossOriginAccessControl(const ResourceRequest&amp; previousRequest, const ResourceResponse&amp; redirectResponse, ResourceRequest&amp; newRequest, String&amp; errorMessage)
568 {
569     bool crossOriginFlag = m_resource-&gt;isCrossOrigin();
570     bool isNextRequestCrossOrigin = m_origin &amp;&amp; !m_origin-&gt;canRequest(newRequest.url());
571 
572     if (isNextRequestCrossOrigin)
573         m_resource-&gt;setCrossOrigin();
574 
575     ASSERT(options().mode != FetchOptions::Mode::SameOrigin || !m_resource-&gt;isCrossOrigin());
576 
577     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 7 &amp; 8.
578     if (options().mode == FetchOptions::Mode::Cors) {
579         if (m_resource-&gt;isCrossOrigin() &amp;&amp; !isValidCrossOriginRedirectionURL(newRequest.url())) {
580             errorMessage = &quot;URL is either a non-HTTP URL or contains credentials.&quot;_s;
581             return false;
582         }
583 
584         ASSERT(m_origin);
585         if (crossOriginFlag &amp;&amp; !passesAccessControlCheck(redirectResponse, options().storedCredentialsPolicy, *m_origin, errorMessage))
586             return false;
587     }
588 
589     bool redirectingToNewOrigin = false;
590     if (m_resource-&gt;isCrossOrigin()) {
591         if (!crossOriginFlag &amp;&amp; isNextRequestCrossOrigin)
592             redirectingToNewOrigin = true;
593         else
594             redirectingToNewOrigin = !protocolHostAndPortAreEqual(previousRequest.url(), newRequest.url());
595     }
596 
597     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 10.
598     if (crossOriginFlag &amp;&amp; redirectingToNewOrigin)
599         m_origin = SecurityOrigin::createUnique();
600 
601     // Implementing https://fetch.spec.whatwg.org/#concept-http-redirect-fetch step 14.
602     updateReferrerPolicy(redirectResponse.httpHeaderField(HTTPHeaderName::ReferrerPolicy));
603 
604     if (options().mode == FetchOptions::Mode::Cors &amp;&amp; redirectingToNewOrigin) {
605         cleanHTTPRequestHeadersForAccessControl(newRequest, options().httpHeadersToKeep);
606         updateRequestForAccessControl(newRequest, *m_origin, options().storedCredentialsPolicy);
607     }
608 
609     updateRequestReferrer(newRequest, referrerPolicy(), previousRequest.httpReferrer());
610 
611     return true;
612 }
613 
614 void SubresourceLoader::updateReferrerPolicy(const String&amp; referrerPolicyValue)
615 {
616     if (auto referrerPolicy = parseReferrerPolicy(referrerPolicyValue, ReferrerPolicySource::HTTPHeader)) {
617         ASSERT(*referrerPolicy != ReferrerPolicy::EmptyString);
618         setReferrerPolicy(*referrerPolicy);
619     }
620 }
621 
622 void SubresourceLoader::didFinishLoading(const NetworkLoadMetrics&amp; networkLoadMetrics)
623 {
624     RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
625 
626 #if USE(QUICK_LOOK)
627     if (auto previewLoader = m_previewLoader.get()) {
628         if (previewLoader-&gt;didFinishLoading())
629             return;
630     }
631 #endif
632 
633     if (m_state != Initialized)
634         return;
635     ASSERT(!reachedTerminalState());
636     ASSERT(!m_resource-&gt;resourceToRevalidate());
637     // FIXME (129394): We should cancel the load when a decode error occurs instead of continuing the load to completion.
638     ASSERT(!m_resource-&gt;errorOccurred() || m_resource-&gt;status() == CachedResource::DecodeError || !m_resource-&gt;isLoading());
639     LOG(ResourceLoading, &quot;Received &#39;%s&#39;.&quot;, m_resource-&gt;url().string().latin1().data());
640     logResourceLoaded(m_frame.get(), m_resource-&gt;type());
641 
642     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
643     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
644 
645     // FIXME: Remove this with deprecatedNetworkLoadMetrics.
646     m_loadTiming.setResponseEnd(MonotonicTime::now());
647 
648     if (networkLoadMetrics.isComplete())
649         reportResourceTiming(networkLoadMetrics);
650     else {
651         // This is the legacy path for platforms (and ResourceHandle paths) that do not provide
652         // complete load metrics in didFinishLoad. In those cases, fall back to the possibility
653         // that they populated partial load timing information on the ResourceResponse.
654         reportResourceTiming(m_resource-&gt;response().deprecatedNetworkLoadMetrics());
655     }
656 
657     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
658         tracePoint(SubresourceLoadDidEnd);
659 
660     m_state = Finishing;
661     m_resource-&gt;finishLoading(resourceData());
662 
663     if (wasCancelled()) {
664         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: was canceled (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
665         return;
666     }
667 
668     m_resource-&gt;finish();
669     ASSERT(!reachedTerminalState());
670     didFinishLoadingOnePart(networkLoadMetrics);
671     notifyDone(LoadCompletionType::Finish);
672 
673     if (reachedTerminalState()) {
674         RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: reached terminal state (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
675         return;
676     }
677     releaseResources();
678 }
679 
680 void SubresourceLoader::didFail(const ResourceError&amp; error)
681 {
682     RELEASE_LOG_IF_ALLOWED(&quot;didFail: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
683 
684 #if USE(QUICK_LOOK)
685     if (auto previewLoader = m_previewLoader.get())
686         previewLoader-&gt;didFail();
687 #endif
688 
689     if (m_state != Initialized)
690         return;
691 
692     ASSERT(!reachedTerminalState());
693     LOG(ResourceLoading, &quot;Failed to load &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
694 
695     if (m_frame-&gt;document() &amp;&amp; error.isAccessControl() &amp;&amp; m_resource-&gt;type() != CachedResource::Type::Ping)
696         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
697 
698     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
699     CachedResourceHandle&lt;CachedResource&gt; protectResource(m_resource);
700     m_state = Finishing;
701 
702     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
703         tracePoint(SubresourceLoadDidEnd);
704 
705     if (m_resource-&gt;resourceToRevalidate())
706         MemoryCache::singleton().revalidationFailed(*m_resource);
707     m_resource-&gt;setResourceError(error);
708     if (!m_resource-&gt;isPreloaded())
709         MemoryCache::singleton().remove(*m_resource);
710     m_resource-&gt;error(CachedResource::LoadError);
711     cleanupForError(error);
712     notifyDone(LoadCompletionType::Cancel);
713     if (reachedTerminalState())
714         return;
715     releaseResources();
716 }
717 
718 void SubresourceLoader::willCancel(const ResourceError&amp; error)
719 {
720     RELEASE_LOG_IF_ALLOWED(&quot;willCancel: (frame = %p, frameLoader = %p, resourceID = %lu, type = %d, code = %d)&quot;, frame(), frameLoader(), identifier(), static_cast&lt;int&gt;(error.type()), error.errorCode());
721 
722 #if PLATFORM(IOS_FAMILY)
723     // Since we defer initialization to scheduling time on iOS but
724     // CachedResourceLoader stores resources in the memory cache immediately,
725     // m_resource might be cached despite its loader not being initialized.
726     if (m_state != Initialized &amp;&amp; m_state != Uninitialized)
727 #else
728     if (m_state != Initialized)
729 #endif
730         return;
731 
732     ASSERT(!reachedTerminalState());
733     LOG(ResourceLoading, &quot;Cancelled load of &#39;%s&#39;.\n&quot;, m_resource-&gt;url().string().latin1().data());
734 
735     Ref&lt;SubresourceLoader&gt; protectedThis(*this);
736 #if PLATFORM(IOS_FAMILY)
737     m_state = m_state == Uninitialized ? CancelledWhileInitializing : Finishing;
738 #else
739     m_state = Finishing;
740 #endif
741     auto&amp; memoryCache = MemoryCache::singleton();
742     if (m_resource-&gt;resourceToRevalidate())
743         memoryCache.revalidationFailed(*m_resource);
744     m_resource-&gt;setResourceError(error);
745     memoryCache.remove(*m_resource);
746 }
747 
748 void SubresourceLoader::didCancel(const ResourceError&amp;)
749 {
750     if (m_state == Uninitialized)
751         return;
752 
753     if (m_resource-&gt;type() != CachedResource::Type::MainResource)
754         tracePoint(SubresourceLoadDidEnd);
755 
756     m_resource-&gt;cancelLoad();
757     notifyDone(LoadCompletionType::Cancel);
758 }
759 
760 void SubresourceLoader::notifyDone(LoadCompletionType type)
761 {
762     if (reachedTerminalState())
763         return;
764 
765     m_requestCountTracker = WTF::nullopt;
766     bool shouldPerformPostLoadActions = true;
767 #if PLATFORM(IOS_FAMILY)
768     if (m_state == CancelledWhileInitializing)
769         shouldPerformPostLoadActions = false;
770 #endif
771     m_documentLoader-&gt;cachedResourceLoader().loadDone(type, shouldPerformPostLoadActions);
772     if (reachedTerminalState())
773         return;
774     m_documentLoader-&gt;removeSubresourceLoader(type, this);
775 }
776 
777 void SubresourceLoader::releaseResources()
778 {
779     ASSERT(!reachedTerminalState());
780 #if PLATFORM(IOS_FAMILY)
781     if (m_state != Uninitialized &amp;&amp; m_state != CancelledWhileInitializing)
782 #else
783     if (m_state != Uninitialized)
784 #endif
785         m_resource-&gt;clearLoader();
786     m_resource = nullptr;
787     ResourceLoader::releaseResources();
788 }
789 
790 void SubresourceLoader::reportResourceTiming(const NetworkLoadMetrics&amp; networkLoadMetrics)
791 {
792     if (!RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
793         return;
794 
795     if (!ResourceTimingInformation::shouldAddResourceTiming(*m_resource))
796         return;
797 
798     Document* document = m_documentLoader-&gt;cachedResourceLoader().document();
799     if (!document)
800         return;
801 
802     SecurityOrigin&amp; origin = m_origin ? *m_origin : document-&gt;securityOrigin();
803     auto resourceTiming = ResourceTiming::fromLoad(*m_resource, m_resource-&gt;initiatorName(), m_loadTiming, networkLoadMetrics, origin);
804 
805     // Worker resources loaded here are all CachedRawResources loaded through WorkerThreadableLoader.
806     // Pass the ResourceTiming information on so that WorkerThreadableLoader may add them to the
807     // Worker&#39;s Performance object.
808     if (options().initiatorContext == InitiatorContext::Worker) {
809         ASSERT(m_origin);
810         ASSERT(is&lt;CachedRawResource&gt;(m_resource));
811         downcast&lt;CachedRawResource&gt;(*m_resource).finishedTimingForWorkerLoad(WTFMove(resourceTiming));
812         return;
813     }
814 
815     ASSERT(options().initiatorContext == InitiatorContext::Document);
816     m_documentLoader-&gt;cachedResourceLoader().resourceTimingInformation().addResourceTiming(*m_resource, *document, WTFMove(resourceTiming));
817 }
818 
819 const HTTPHeaderMap* SubresourceLoader::originalHeaders() const
820 {
821     return (m_resource  &amp;&amp; m_resource-&gt;originalRequest()) ? &amp;m_resource-&gt;originalRequest()-&gt;httpHeaderFields() : nullptr;
822 }
823 
824 }
825 
826 #undef RELEASE_LOG_IF_ALLOWED
827 #undef RELEASE_LOG_ERROR_IF_ALLOWED
    </pre>
  </body>
</html>