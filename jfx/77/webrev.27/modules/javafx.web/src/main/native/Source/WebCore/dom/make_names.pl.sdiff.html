<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/make_names.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="messageports/MessagePortChannel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/make_names.pl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  95 mkpath($outputDir);
  96 
  97 if (length($fontNamesIn)) {
  98     my $names = new IO::File;
  99     my $familyNamesFileBase = &quot;WebKitFontFamily&quot;;
 100 
 101     open($names, $fontNamesIn) or die &quot;Failed to open file: $fontNamesIn&quot;;
 102 
 103     $initDefaults = 0;
 104     my $Parser = InFilesParser-&gt;new();
 105     my $dummy;
 106     $Parser-&gt;parse($names, \&amp;parametersHandler, \&amp;dummy);
 107 
 108     my $F;
 109     my $header = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.h&quot;);
 110     open F, &quot;&gt;$header&quot; or die &quot;Unable to open $header for writing.&quot;;
 111 
 112     printLicenseHeader($F);
 113     printHeaderHead($F, &quot;CSS&quot;, $familyNamesFileBase, &lt;&lt;END, &quot;&quot;);
 114 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified"> 115 #include &lt;wtf/text/AtomicString.h&gt;</span>
 116 END
 117 
<span class="line-modified"> 118     printMacros($F, &quot;extern LazyNeverDestroyed&lt;const WTF::AtomicString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 119     print F &quot;#endif\n\n&quot;;
 120 
 121     printInit($F, 1);
 122     close F;
 123 
 124     my $source = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.cpp&quot;);
 125     open F, &quot;&gt;$source&quot; or die &quot;Unable to open $source for writing.&quot;;
 126 
 127     printLicenseHeader($F);
 128     printCppHead($F, &quot;CSS&quot;, $familyNamesFileBase, &quot;WTF&quot;);
 129 
 130     print F StaticString::GenerateStrings(\%parameters);
 131 
<span class="line-modified"> 132     printMacros($F, &quot;LazyNeverDestroyed&lt;const WTF::AtomicString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 133 
 134     printInit($F, 0);
 135 
 136     print F &quot;\n&quot;;
 137     print F StaticString::GenerateStringAsserts(\%parameters);
 138 
 139     for my $name (sort keys %parameters) {
 140         print F &quot;    ${name}.construct(&amp;${name}Data);\n&quot;;
 141     }
 142 
 143     print F &quot;}\n}\n}\n&quot;;
 144     close F;
 145     exit 0;
 146 }
 147 
 148 die &quot;You must specify at least one of --tags &lt;file&gt; or --attrs &lt;file&gt;&quot; unless (length($tagsFile) || length($attrsFile));
 149 
 150 if (length($tagsFile)) {
 151     %allTags = %{readTags($tagsFile, 0)};
 152     %enabledTags = %{readTags($tagsFile, 1)};
</pre>
<hr />
<pre>
 579 sub printInit
 580 {
 581     my ($F, $isDefinition) = @_;
 582 
 583     if ($isDefinition) {
 584         print F &quot;\nWEBCORE_EXPORT void init();\n\n&quot;;
 585         print F &quot;} }\n\n&quot;;
 586         print F &quot;#endif\n\n&quot;;
 587         return;
 588     }
 589 
 590 print F &quot;\nvoid init()
 591 {
 592     static bool initialized = false;
 593     if (initialized)
 594         return;
 595     initialized = true;
 596 
 597     // Use placement new to initialize the globals.
 598 
<span class="line-modified"> 599     AtomicString::init();</span>
 600 &quot;;
 601 }
 602 
 603 sub printLicenseHeader
 604 {
 605     my $F = shift;
 606     print F &quot;/*
 607  * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 608  *
 609  * This file was generated by the dom/make_names.pl script.
 610  *
 611  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 612  *
 613  * Redistribution and use in source and binary forms, with or without
 614  * modification, are permitted provided that the following conditions
 615  * are met:
 616  * 1. Redistributions of source code must retain the above copyright
 617  *    notice, this list of conditions and the following disclaimer.
 618  * 2. Redistributions in binary form must reproduce the above copyright
 619  *    notice, this list of conditions and the following disclaimer in the
</pre>
<hr />
<pre>
 698     print F &quot;#ifndef &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n&quot;;
 699     print F &quot;#define &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n\n&quot;;
 700     print F &quot;#include \&quot;&quot;.$parameters{namespace}.&quot;Names.h\&quot;\n\n&quot;;
 701 
 702     printTypeHelpers($F, \%allTags);
 703 
 704     print F &quot;#endif\n&quot;;
 705 
 706     close F;
 707 }
 708 
 709 sub printNamesHeaderFile
 710 {
 711     my ($headerPath) = shift;
 712     my $F;
 713     open F, &quot;&gt;$headerPath&quot;;
 714 
 715     printLicenseHeader($F);
 716     printHeaderHead($F, &quot;DOM&quot;, $parameters{namespace}, &lt;&lt;END, &quot;class $parameters{namespace}QualifiedName : public QualifiedName { };\n\n&quot;);
 717 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified"> 718 #include &lt;wtf/text/AtomicString.h&gt;</span>
 719 #include &quot;QualifiedName.h&quot;
 720 END
 721 
 722     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 723 
 724     print F &quot;// Namespace\n&quot;;
<span class="line-modified"> 725     print F &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WTF::AtomicString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 726 
 727     if (keys %allTags) {
 728         print F &quot;// Tags\n&quot;;
 729         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::$parameters{namespace}QualifiedName&gt;&quot;, &quot;Tag&quot;, \%allTags);
 730     }
 731 
 732     if (keys %allAttrs) {
 733         print F &quot;// Attributes\n&quot;;
 734         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::QualifiedName&gt;&quot;, &quot;Attr&quot;, \%allAttrs);
 735     }
 736     print F &quot;#endif\n\n&quot;;
 737 
 738     if (keys %allTags) {
 739         print F &quot;const unsigned $parameters{namespace}TagsCount = &quot;, scalar(keys %allTags), &quot;;\n&quot;;
 740         print F &quot;const WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags();\n&quot;;
 741     }
 742 
 743     if (keys %allAttrs) {
 744         print F &quot;const unsigned $parameters{namespace}AttrsCount = &quot;, scalar(keys %allAttrs), &quot;;\n&quot;;
 745         print F &quot;const WebCore::QualifiedName* const* get$parameters{namespace}Attrs();\n&quot;;
 746     }
 747 
 748     printInit($F, 1);
 749     close F;
 750 }
 751 
 752 sub printNamesCppFile
 753 {
 754     my $cppPath = shift;
 755     my $F;
 756     open F, &quot;&gt;$cppPath&quot;;
 757     
 758     printLicenseHeader($F);
 759     printCppHead($F, &quot;DOM&quot;, $parameters{namespace}, &quot;WebCore&quot;);
 760     
 761     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 762 
<span class="line-modified"> 763     print F &quot;LazyNeverDestroyed&lt;const AtomicString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 764 
 765     print F StaticString::GenerateStrings(\%allStrings);
 766 
 767     if (keys %allTags) {
 768         print F &quot;// Tags\n&quot;;
 769         for my $name (sort keys %allTags) {
 770             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const $parameters{namespace}QualifiedName&gt; ${name}Tag;\n&quot;;
 771         }
 772         
 773         print F &quot;\n\nconst WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags()\n&quot;;
 774         print F &quot;{\n    static const WebCore::$parameters{namespace}QualifiedName* const $parameters{namespace}Tags[] = {\n&quot;;
 775         for my $name (sort keys %allTags) {
 776             print F &quot;        &amp;${name}Tag.get(),\n&quot;;
 777         }
 778         print F &quot;    };\n&quot;;
 779         print F &quot;    return $parameters{namespace}Tags;\n&quot;;
 780         print F &quot;}\n&quot;;
 781     }
 782 
 783     if (keys %allAttrs) {
 784         print F &quot;\n// Attributes\n&quot;;
 785         for my $name (sort keys %allAttrs) {
 786             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const QualifiedName&gt; ${name}Attr;\n&quot;;
 787         }
 788         print F &quot;\n\nconst WebCore::QualifiedName* const* get$parameters{namespace}Attrs()\n&quot;;
 789         print F &quot;{\n    static const WebCore::QualifiedName* const $parameters{namespace}Attrs[] = {\n&quot;;
 790         for my $name (sort keys %allAttrs) {
 791             print F &quot;        &amp;${name}Attr.get(),\n&quot;;
 792         }
 793         print F &quot;    };\n&quot;;
 794         print F &quot;    return $parameters{namespace}Attrs;\n&quot;;
 795         print F &quot;}\n&quot;;
 796     }
 797 
 798     printInit($F, 0);
 799 
<span class="line-modified"> 800     print(F &quot;    AtomicString ${lowercaseNamespacePrefix}NS(\&quot;$parameters{namespaceURI}\&quot;, AtomicString::ConstructFromLiteral);\n\n&quot;);</span>
 801 
 802     print(F &quot;    // Namespace\n&quot;);
 803     print(F &quot;    ${lowercaseNamespacePrefix}NamespaceURI.construct(${lowercaseNamespacePrefix}NS);\n&quot;);
 804     print(F &quot;\n&quot;);
 805     print F StaticString::GenerateStringAsserts(\%allStrings);
 806 
 807     if (keys %allTags) {
 808         my $tagsNamespace = $parameters{tagsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 809         printDefinitions($F, \%allTags, &quot;tags&quot;, $tagsNamespace);
 810     }
 811     if (keys %allAttrs) {
 812         my $attrsNamespace = $parameters{attrsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 813         printDefinitions($F, \%allAttrs, &quot;attributes&quot;, $attrsNamespace);
 814     }
 815 
 816     print F &quot;}\n\n} }\n\n&quot;;
 817     close F;
 818 }
 819 
 820 sub printJSElementIncludes
</pre>
<hr />
<pre>
 902     
 903 print F &lt;&lt;END;
 904 
 905     struct ${capitalizedType}TableEntry {
 906         LazyNeverDestroyed&lt;const QualifiedName&gt;* targetAddress;
 907         const StaticStringImpl&amp; name;
 908     };
 909 
 910     static const ${capitalizedType}TableEntry ${type}Table[] = {
 911 END
 912 
 913     my $cast = $type eq &quot;tags&quot; ? &quot;(LazyNeverDestroyed&lt;const QualifiedName&gt;*)&quot; : &quot;&quot;;
 914     for my $name (sort keys %$namesRef) {
 915         print F &quot;        { $cast&amp;$name$shortCamelType, *(&amp;${name}Data) },\n&quot;;
 916     }
 917 
 918 print F &lt;&lt;END;
 919     };
 920 
 921     for (auto&amp; entry : ${type}Table)
<span class="line-modified"> 922         entry.targetAddress-&gt;construct(nullAtom(), AtomicString(&amp;entry.name), $namespaceURI);</span>
 923 END
 924 
 925 }
 926 
 927 ## ElementFactory routines
 928 
 929 sub printFactoryCppFile
 930 {
 931     my $cppPath = shift;
 932     my $F;
 933     open F, &quot;&gt;$cppPath&quot;;
 934 
 935     my $formElementArgumentForDeclaration = &quot;&quot;;
 936     my $formElementArgumentForDefinition = &quot;&quot;;
 937     $formElementArgumentForDeclaration = &quot;, HTMLFormElement*&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 938     $formElementArgumentForDefinition = &quot;, HTMLFormElement* formElement&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 939 
 940     printLicenseHeader($F);
 941 
 942     print F &lt;&lt;END
</pre>
<hr />
<pre>
 987 
 988     printConstructors($F, \%tagConstructorMap);
 989 
 990     print F &lt;&lt;END
 991 
 992 struct $parameters{namespace}ConstructorFunctionMapEntry {
 993     $parameters{namespace}ConstructorFunctionMapEntry($parameters{namespace}ConstructorFunction function, const QualifiedName&amp; name)
 994         : function(function)
 995         , qualifiedName(&amp;name)
 996     { }
 997 
 998     $parameters{namespace}ConstructorFunctionMapEntry()
 999         : function(nullptr)
1000         , qualifiedName(nullptr)
1001     { }
1002 
1003     $parameters{namespace}ConstructorFunction function;
1004     const QualifiedName* qualifiedName; // Use pointer instead of reference so that emptyValue() in HashMap is cheap to create.
1005 };
1006 
<span class="line-modified">1007 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; create$parameters{namespace}FactoryMap()</span>
1008 {
1009     struct TableEntry {
1010         const QualifiedName&amp; name;
1011         $parameters{namespace}ConstructorFunction function;
1012     };
1013 
1014     static const TableEntry table[] = {
1015 END
1016     ;
1017 
1018     printFunctionTable($F, \%tagConstructorMap);
1019 
1020     print F &lt;&lt;END
1021     };
1022 
<span class="line-modified">1023     HashMap&lt;AtomicStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; map;</span>
1024     for (auto&amp; entry : table)
1025         map.add(entry.name.localName().impl(), $parameters{namespace}ConstructorFunctionMapEntry(entry.function, entry.name));
1026     return map;
1027 }
1028 
<span class="line-modified">1029 static $parameters{namespace}ConstructorFunctionMapEntry find$parameters{namespace}ElementConstructorFunction(const AtomicString&amp; localName)</span>
1030 {
1031     static const auto map = makeNeverDestroyed(create$parameters{namespace}FactoryMap());
1032     return map.get().get(localName.impl());
1033 }
1034 
<span class="line-modified">1035 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const AtomicString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1036 {
1037     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1038     if (LIKELY(entry.function)) {
1039         ASSERT(entry.qualifiedName);
1040         const auto&amp; name = *entry.qualifiedName;
1041         return entry.function($argumentList);
1042     }
1043     return nullptr;
1044 }
1045 
1046 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1047 {
1048     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1049     if (LIKELY(entry.function))
1050         return entry.function($argumentList);
1051     return nullptr;
1052 }
1053 
<span class="line-modified">1054 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const AtomicString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1055 {
1056     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1057     if (LIKELY(entry.function)) {
1058         ASSERT(entry.qualifiedName);
1059         const auto&amp; name = *entry.qualifiedName;
1060         return entry.function($argumentList);
1061     }
1062     return $parameters{fallbackInterfaceName}::create(QualifiedName(nullAtom(), localName, ${lowercaseNamespacePrefix}NamespaceURI), document);
1063 }
1064 
1065 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1066 {
1067     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1068     if (LIKELY(entry.function))
1069         return entry.function($argumentList);
1070     return $parameters{fallbackInterfaceName}::create(name, document);
1071 }
1072 
1073 } // namespace WebCore
1074 
</pre>
<hr />
<pre>
1090 
1091     print F&lt;&lt;END
1092 #ifndef $parameters{namespace}ElementFactory_h
1093 #define $parameters{namespace}ElementFactory_h
1094 
1095 #include &lt;wtf/Forward.h&gt;
1096 
1097 namespace WebCore {
1098 
1099 class Document;
1100 class HTMLFormElement;
1101 class QualifiedName;
1102 
1103 class $parameters{namespace}Element;
1104 
1105 class $parameters{namespace}ElementFactory {
1106 public:
1107 END
1108 ;
1109 
<span class="line-modified">1110 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const AtomicString&amp;, Document&amp;&quot;;</span>
1111 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1112 print F &quot;, bool createdByParser = false);\n&quot;;
1113 
1114 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const QualifiedName&amp;, Document&amp;&quot;;
1115 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1116 print F &quot;, bool createdByParser = false);\n&quot;;
1117 
<span class="line-modified">1118 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const AtomicString&amp;, Document&amp;&quot;;</span>
1119 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1120 print F &quot;, bool createdByParser = false);\n&quot;;
1121 
1122 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const QualifiedName&amp;, Document&amp;&quot;;
1123 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1124 print F &quot;, bool createdByParser = false);\n&quot;;
1125 
1126 printf F&lt;&lt;END
1127 };
1128 
1129 }
1130 
1131 #endif // $parameters{namespace}ElementFactory_h
1132 
1133 END
1134 ;
1135 
1136     close F;
1137 }
1138 
</pre>
<hr />
<pre>
1243 
1244     printConditionalElementIncludes($F, 1);
1245 
1246     print F &lt;&lt;END
1247 
1248 using namespace JSC;
1249 
1250 namespace WebCore {
1251 
1252 using namespace $parameters{namespace}Names;
1253 
1254 typedef JSDOMObject* (*Create$parameters{namespace}ElementWrapperFunction)(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1255 
1256 END
1257 ;
1258 
1259     printWrapperFunctions($F);
1260 
1261 print F &lt;&lt;END
1262 
<span class="line-modified">1263 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; create$parameters{namespace}WrapperMap()</span>
1264 {
1265     struct TableEntry {
1266         const QualifiedName&amp; name;
1267         Create$parameters{namespace}ElementWrapperFunction function;
1268     };
1269 
1270     static const TableEntry table[] = {
1271 END
1272 ;
1273 
1274     for my $tag (sort keys %enabledTags) {
1275         # Do not add the name to the map if it does not have a JS wrapper constructor or uses the default wrapper.
1276         next if (usesDefaultJSWrapper($tag, \%enabledTags) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;));
1277 
1278         my $conditional = $enabledTags{$tag}{conditional};
1279         if ($conditional) {
1280             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1281             print F &quot;#if ${conditionalString}\n&quot;;
1282         }
1283 
1284         my $ucTag;
1285         if ($enabledTags{$tag}{settingsConditional}) {
1286             $ucTag = $enabledTags{$tag}{interfaceName};
1287         } else {
1288             $ucTag = $enabledTags{$tag}{JSInterfaceName};
1289         }
1290 
1291         print F &quot;        { ${tag}Tag, create${ucTag}Wrapper },\n&quot;;
1292 
1293         if ($conditional) {
1294             print F &quot;#endif\n&quot;;
1295         }
1296     }
1297 
1298     print F &lt;&lt;END
1299     };
1300 
<span class="line-modified">1301     HashMap&lt;AtomicStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; map;</span>
1302     for (auto&amp; entry : table)
1303         map.add(entry.name.localName().impl(), entry.function);
1304     return map;
1305 }
1306 
1307 JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1308 {
1309     static const auto functions = makeNeverDestroyed(create$parameters{namespace}WrapperMap());
1310     if (auto function = functions.get().get(element-&gt;localName().impl()))
1311         return function(globalObject, WTFMove(element));
1312 END
1313 ;
1314 
1315     if ($parameters{customElementInterfaceName}) {
1316         print F &lt;&lt;END
1317     if (element-&gt;isCustomElementUpgradeCandidate())
1318         return createWrapper&lt;$parameters{customElementInterfaceName}&gt;(globalObject, WTFMove(element));
1319 END
1320 ;
1321     }
</pre>
</td>
<td>
<hr />
<pre>
  95 mkpath($outputDir);
  96 
  97 if (length($fontNamesIn)) {
  98     my $names = new IO::File;
  99     my $familyNamesFileBase = &quot;WebKitFontFamily&quot;;
 100 
 101     open($names, $fontNamesIn) or die &quot;Failed to open file: $fontNamesIn&quot;;
 102 
 103     $initDefaults = 0;
 104     my $Parser = InFilesParser-&gt;new();
 105     my $dummy;
 106     $Parser-&gt;parse($names, \&amp;parametersHandler, \&amp;dummy);
 107 
 108     my $F;
 109     my $header = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.h&quot;);
 110     open F, &quot;&gt;$header&quot; or die &quot;Unable to open $header for writing.&quot;;
 111 
 112     printLicenseHeader($F);
 113     printHeaderHead($F, &quot;CSS&quot;, $familyNamesFileBase, &lt;&lt;END, &quot;&quot;);
 114 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified"> 115 #include &lt;wtf/text/AtomString.h&gt;</span>
 116 END
 117 
<span class="line-modified"> 118     printMacros($F, &quot;extern LazyNeverDestroyed&lt;const WTF::AtomString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 119     print F &quot;#endif\n\n&quot;;
 120 
 121     printInit($F, 1);
 122     close F;
 123 
 124     my $source = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.cpp&quot;);
 125     open F, &quot;&gt;$source&quot; or die &quot;Unable to open $source for writing.&quot;;
 126 
 127     printLicenseHeader($F);
 128     printCppHead($F, &quot;CSS&quot;, $familyNamesFileBase, &quot;WTF&quot;);
 129 
 130     print F StaticString::GenerateStrings(\%parameters);
 131 
<span class="line-modified"> 132     printMacros($F, &quot;LazyNeverDestroyed&lt;const WTF::AtomString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 133 
 134     printInit($F, 0);
 135 
 136     print F &quot;\n&quot;;
 137     print F StaticString::GenerateStringAsserts(\%parameters);
 138 
 139     for my $name (sort keys %parameters) {
 140         print F &quot;    ${name}.construct(&amp;${name}Data);\n&quot;;
 141     }
 142 
 143     print F &quot;}\n}\n}\n&quot;;
 144     close F;
 145     exit 0;
 146 }
 147 
 148 die &quot;You must specify at least one of --tags &lt;file&gt; or --attrs &lt;file&gt;&quot; unless (length($tagsFile) || length($attrsFile));
 149 
 150 if (length($tagsFile)) {
 151     %allTags = %{readTags($tagsFile, 0)};
 152     %enabledTags = %{readTags($tagsFile, 1)};
</pre>
<hr />
<pre>
 579 sub printInit
 580 {
 581     my ($F, $isDefinition) = @_;
 582 
 583     if ($isDefinition) {
 584         print F &quot;\nWEBCORE_EXPORT void init();\n\n&quot;;
 585         print F &quot;} }\n\n&quot;;
 586         print F &quot;#endif\n\n&quot;;
 587         return;
 588     }
 589 
 590 print F &quot;\nvoid init()
 591 {
 592     static bool initialized = false;
 593     if (initialized)
 594         return;
 595     initialized = true;
 596 
 597     // Use placement new to initialize the globals.
 598 
<span class="line-modified"> 599     AtomString::init();</span>
 600 &quot;;
 601 }
 602 
 603 sub printLicenseHeader
 604 {
 605     my $F = shift;
 606     print F &quot;/*
 607  * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 608  *
 609  * This file was generated by the dom/make_names.pl script.
 610  *
 611  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 612  *
 613  * Redistribution and use in source and binary forms, with or without
 614  * modification, are permitted provided that the following conditions
 615  * are met:
 616  * 1. Redistributions of source code must retain the above copyright
 617  *    notice, this list of conditions and the following disclaimer.
 618  * 2. Redistributions in binary form must reproduce the above copyright
 619  *    notice, this list of conditions and the following disclaimer in the
</pre>
<hr />
<pre>
 698     print F &quot;#ifndef &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n&quot;;
 699     print F &quot;#define &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n\n&quot;;
 700     print F &quot;#include \&quot;&quot;.$parameters{namespace}.&quot;Names.h\&quot;\n\n&quot;;
 701 
 702     printTypeHelpers($F, \%allTags);
 703 
 704     print F &quot;#endif\n&quot;;
 705 
 706     close F;
 707 }
 708 
 709 sub printNamesHeaderFile
 710 {
 711     my ($headerPath) = shift;
 712     my $F;
 713     open F, &quot;&gt;$headerPath&quot;;
 714 
 715     printLicenseHeader($F);
 716     printHeaderHead($F, &quot;DOM&quot;, $parameters{namespace}, &lt;&lt;END, &quot;class $parameters{namespace}QualifiedName : public QualifiedName { };\n\n&quot;);
 717 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified"> 718 #include &lt;wtf/text/AtomString.h&gt;</span>
 719 #include &quot;QualifiedName.h&quot;
 720 END
 721 
 722     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 723 
 724     print F &quot;// Namespace\n&quot;;
<span class="line-modified"> 725     print F &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WTF::AtomString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 726 
 727     if (keys %allTags) {
 728         print F &quot;// Tags\n&quot;;
 729         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::$parameters{namespace}QualifiedName&gt;&quot;, &quot;Tag&quot;, \%allTags);
 730     }
 731 
 732     if (keys %allAttrs) {
 733         print F &quot;// Attributes\n&quot;;
 734         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::QualifiedName&gt;&quot;, &quot;Attr&quot;, \%allAttrs);
 735     }
 736     print F &quot;#endif\n\n&quot;;
 737 
 738     if (keys %allTags) {
 739         print F &quot;const unsigned $parameters{namespace}TagsCount = &quot;, scalar(keys %allTags), &quot;;\n&quot;;
 740         print F &quot;const WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags();\n&quot;;
 741     }
 742 
 743     if (keys %allAttrs) {
 744         print F &quot;const unsigned $parameters{namespace}AttrsCount = &quot;, scalar(keys %allAttrs), &quot;;\n&quot;;
 745         print F &quot;const WebCore::QualifiedName* const* get$parameters{namespace}Attrs();\n&quot;;
 746     }
 747 
 748     printInit($F, 1);
 749     close F;
 750 }
 751 
 752 sub printNamesCppFile
 753 {
 754     my $cppPath = shift;
 755     my $F;
 756     open F, &quot;&gt;$cppPath&quot;;
 757     
 758     printLicenseHeader($F);
 759     printCppHead($F, &quot;DOM&quot;, $parameters{namespace}, &quot;WebCore&quot;);
 760     
 761     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 762 
<span class="line-modified"> 763     print F &quot;LazyNeverDestroyed&lt;const AtomString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 764 
 765     print F StaticString::GenerateStrings(\%allStrings);
 766 
 767     if (keys %allTags) {
 768         print F &quot;// Tags\n&quot;;
 769         for my $name (sort keys %allTags) {
 770             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const $parameters{namespace}QualifiedName&gt; ${name}Tag;\n&quot;;
 771         }
 772         
 773         print F &quot;\n\nconst WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags()\n&quot;;
 774         print F &quot;{\n    static const WebCore::$parameters{namespace}QualifiedName* const $parameters{namespace}Tags[] = {\n&quot;;
 775         for my $name (sort keys %allTags) {
 776             print F &quot;        &amp;${name}Tag.get(),\n&quot;;
 777         }
 778         print F &quot;    };\n&quot;;
 779         print F &quot;    return $parameters{namespace}Tags;\n&quot;;
 780         print F &quot;}\n&quot;;
 781     }
 782 
 783     if (keys %allAttrs) {
 784         print F &quot;\n// Attributes\n&quot;;
 785         for my $name (sort keys %allAttrs) {
 786             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const QualifiedName&gt; ${name}Attr;\n&quot;;
 787         }
 788         print F &quot;\n\nconst WebCore::QualifiedName* const* get$parameters{namespace}Attrs()\n&quot;;
 789         print F &quot;{\n    static const WebCore::QualifiedName* const $parameters{namespace}Attrs[] = {\n&quot;;
 790         for my $name (sort keys %allAttrs) {
 791             print F &quot;        &amp;${name}Attr.get(),\n&quot;;
 792         }
 793         print F &quot;    };\n&quot;;
 794         print F &quot;    return $parameters{namespace}Attrs;\n&quot;;
 795         print F &quot;}\n&quot;;
 796     }
 797 
 798     printInit($F, 0);
 799 
<span class="line-modified"> 800     print(F &quot;    AtomString ${lowercaseNamespacePrefix}NS(\&quot;$parameters{namespaceURI}\&quot;, AtomString::ConstructFromLiteral);\n\n&quot;);</span>
 801 
 802     print(F &quot;    // Namespace\n&quot;);
 803     print(F &quot;    ${lowercaseNamespacePrefix}NamespaceURI.construct(${lowercaseNamespacePrefix}NS);\n&quot;);
 804     print(F &quot;\n&quot;);
 805     print F StaticString::GenerateStringAsserts(\%allStrings);
 806 
 807     if (keys %allTags) {
 808         my $tagsNamespace = $parameters{tagsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 809         printDefinitions($F, \%allTags, &quot;tags&quot;, $tagsNamespace);
 810     }
 811     if (keys %allAttrs) {
 812         my $attrsNamespace = $parameters{attrsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 813         printDefinitions($F, \%allAttrs, &quot;attributes&quot;, $attrsNamespace);
 814     }
 815 
 816     print F &quot;}\n\n} }\n\n&quot;;
 817     close F;
 818 }
 819 
 820 sub printJSElementIncludes
</pre>
<hr />
<pre>
 902     
 903 print F &lt;&lt;END;
 904 
 905     struct ${capitalizedType}TableEntry {
 906         LazyNeverDestroyed&lt;const QualifiedName&gt;* targetAddress;
 907         const StaticStringImpl&amp; name;
 908     };
 909 
 910     static const ${capitalizedType}TableEntry ${type}Table[] = {
 911 END
 912 
 913     my $cast = $type eq &quot;tags&quot; ? &quot;(LazyNeverDestroyed&lt;const QualifiedName&gt;*)&quot; : &quot;&quot;;
 914     for my $name (sort keys %$namesRef) {
 915         print F &quot;        { $cast&amp;$name$shortCamelType, *(&amp;${name}Data) },\n&quot;;
 916     }
 917 
 918 print F &lt;&lt;END;
 919     };
 920 
 921     for (auto&amp; entry : ${type}Table)
<span class="line-modified"> 922         entry.targetAddress-&gt;construct(nullAtom(), AtomString(&amp;entry.name), $namespaceURI);</span>
 923 END
 924 
 925 }
 926 
 927 ## ElementFactory routines
 928 
 929 sub printFactoryCppFile
 930 {
 931     my $cppPath = shift;
 932     my $F;
 933     open F, &quot;&gt;$cppPath&quot;;
 934 
 935     my $formElementArgumentForDeclaration = &quot;&quot;;
 936     my $formElementArgumentForDefinition = &quot;&quot;;
 937     $formElementArgumentForDeclaration = &quot;, HTMLFormElement*&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 938     $formElementArgumentForDefinition = &quot;, HTMLFormElement* formElement&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 939 
 940     printLicenseHeader($F);
 941 
 942     print F &lt;&lt;END
</pre>
<hr />
<pre>
 987 
 988     printConstructors($F, \%tagConstructorMap);
 989 
 990     print F &lt;&lt;END
 991 
 992 struct $parameters{namespace}ConstructorFunctionMapEntry {
 993     $parameters{namespace}ConstructorFunctionMapEntry($parameters{namespace}ConstructorFunction function, const QualifiedName&amp; name)
 994         : function(function)
 995         , qualifiedName(&amp;name)
 996     { }
 997 
 998     $parameters{namespace}ConstructorFunctionMapEntry()
 999         : function(nullptr)
1000         , qualifiedName(nullptr)
1001     { }
1002 
1003     $parameters{namespace}ConstructorFunction function;
1004     const QualifiedName* qualifiedName; // Use pointer instead of reference so that emptyValue() in HashMap is cheap to create.
1005 };
1006 
<span class="line-modified">1007 static NEVER_INLINE HashMap&lt;AtomStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; create$parameters{namespace}FactoryMap()</span>
1008 {
1009     struct TableEntry {
1010         const QualifiedName&amp; name;
1011         $parameters{namespace}ConstructorFunction function;
1012     };
1013 
1014     static const TableEntry table[] = {
1015 END
1016     ;
1017 
1018     printFunctionTable($F, \%tagConstructorMap);
1019 
1020     print F &lt;&lt;END
1021     };
1022 
<span class="line-modified">1023     HashMap&lt;AtomStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; map;</span>
1024     for (auto&amp; entry : table)
1025         map.add(entry.name.localName().impl(), $parameters{namespace}ConstructorFunctionMapEntry(entry.function, entry.name));
1026     return map;
1027 }
1028 
<span class="line-modified">1029 static $parameters{namespace}ConstructorFunctionMapEntry find$parameters{namespace}ElementConstructorFunction(const AtomString&amp; localName)</span>
1030 {
1031     static const auto map = makeNeverDestroyed(create$parameters{namespace}FactoryMap());
1032     return map.get().get(localName.impl());
1033 }
1034 
<span class="line-modified">1035 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const AtomString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1036 {
1037     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1038     if (LIKELY(entry.function)) {
1039         ASSERT(entry.qualifiedName);
1040         const auto&amp; name = *entry.qualifiedName;
1041         return entry.function($argumentList);
1042     }
1043     return nullptr;
1044 }
1045 
1046 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1047 {
1048     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1049     if (LIKELY(entry.function))
1050         return entry.function($argumentList);
1051     return nullptr;
1052 }
1053 
<span class="line-modified">1054 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const AtomString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1055 {
1056     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1057     if (LIKELY(entry.function)) {
1058         ASSERT(entry.qualifiedName);
1059         const auto&amp; name = *entry.qualifiedName;
1060         return entry.function($argumentList);
1061     }
1062     return $parameters{fallbackInterfaceName}::create(QualifiedName(nullAtom(), localName, ${lowercaseNamespacePrefix}NamespaceURI), document);
1063 }
1064 
1065 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1066 {
1067     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1068     if (LIKELY(entry.function))
1069         return entry.function($argumentList);
1070     return $parameters{fallbackInterfaceName}::create(name, document);
1071 }
1072 
1073 } // namespace WebCore
1074 
</pre>
<hr />
<pre>
1090 
1091     print F&lt;&lt;END
1092 #ifndef $parameters{namespace}ElementFactory_h
1093 #define $parameters{namespace}ElementFactory_h
1094 
1095 #include &lt;wtf/Forward.h&gt;
1096 
1097 namespace WebCore {
1098 
1099 class Document;
1100 class HTMLFormElement;
1101 class QualifiedName;
1102 
1103 class $parameters{namespace}Element;
1104 
1105 class $parameters{namespace}ElementFactory {
1106 public:
1107 END
1108 ;
1109 
<span class="line-modified">1110 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const AtomString&amp;, Document&amp;&quot;;</span>
1111 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1112 print F &quot;, bool createdByParser = false);\n&quot;;
1113 
1114 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const QualifiedName&amp;, Document&amp;&quot;;
1115 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1116 print F &quot;, bool createdByParser = false);\n&quot;;
1117 
<span class="line-modified">1118 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const AtomString&amp;, Document&amp;&quot;;</span>
1119 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1120 print F &quot;, bool createdByParser = false);\n&quot;;
1121 
1122 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const QualifiedName&amp;, Document&amp;&quot;;
1123 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1124 print F &quot;, bool createdByParser = false);\n&quot;;
1125 
1126 printf F&lt;&lt;END
1127 };
1128 
1129 }
1130 
1131 #endif // $parameters{namespace}ElementFactory_h
1132 
1133 END
1134 ;
1135 
1136     close F;
1137 }
1138 
</pre>
<hr />
<pre>
1243 
1244     printConditionalElementIncludes($F, 1);
1245 
1246     print F &lt;&lt;END
1247 
1248 using namespace JSC;
1249 
1250 namespace WebCore {
1251 
1252 using namespace $parameters{namespace}Names;
1253 
1254 typedef JSDOMObject* (*Create$parameters{namespace}ElementWrapperFunction)(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1255 
1256 END
1257 ;
1258 
1259     printWrapperFunctions($F);
1260 
1261 print F &lt;&lt;END
1262 
<span class="line-modified">1263 static NEVER_INLINE HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; create$parameters{namespace}WrapperMap()</span>
1264 {
1265     struct TableEntry {
1266         const QualifiedName&amp; name;
1267         Create$parameters{namespace}ElementWrapperFunction function;
1268     };
1269 
1270     static const TableEntry table[] = {
1271 END
1272 ;
1273 
1274     for my $tag (sort keys %enabledTags) {
1275         # Do not add the name to the map if it does not have a JS wrapper constructor or uses the default wrapper.
1276         next if (usesDefaultJSWrapper($tag, \%enabledTags) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;));
1277 
1278         my $conditional = $enabledTags{$tag}{conditional};
1279         if ($conditional) {
1280             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1281             print F &quot;#if ${conditionalString}\n&quot;;
1282         }
1283 
1284         my $ucTag;
1285         if ($enabledTags{$tag}{settingsConditional}) {
1286             $ucTag = $enabledTags{$tag}{interfaceName};
1287         } else {
1288             $ucTag = $enabledTags{$tag}{JSInterfaceName};
1289         }
1290 
1291         print F &quot;        { ${tag}Tag, create${ucTag}Wrapper },\n&quot;;
1292 
1293         if ($conditional) {
1294             print F &quot;#endif\n&quot;;
1295         }
1296     }
1297 
1298     print F &lt;&lt;END
1299     };
1300 
<span class="line-modified">1301     HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; map;</span>
1302     for (auto&amp; entry : table)
1303         map.add(entry.name.localName().impl(), entry.function);
1304     return map;
1305 }
1306 
1307 JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1308 {
1309     static const auto functions = makeNeverDestroyed(create$parameters{namespace}WrapperMap());
1310     if (auto function = functions.get().get(element-&gt;localName().impl()))
1311         return function(globalObject, WTFMove(element));
1312 END
1313 ;
1314 
1315     if ($parameters{customElementInterfaceName}) {
1316         print F &lt;&lt;END
1317     if (element-&gt;isCustomElementUpgradeCandidate())
1318         return createWrapper&lt;$parameters{customElementInterfaceName}&gt;(globalObject, WTFMove(element));
1319 END
1320 ;
1321     }
</pre>
</td>
</tr>
</table>
<center><a href="XMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="messageports/MessagePortChannel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>