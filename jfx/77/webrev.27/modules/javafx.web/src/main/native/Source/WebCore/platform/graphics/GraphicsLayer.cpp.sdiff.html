<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsContextImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  62             m_values.insert(i + 1, WTFMove(value));
  63             return;
  64         }
  65         if (curValue-&gt;keyTime() &gt; value-&gt;keyTime()) {
  66             // insert before
  67             m_values.insert(i, WTFMove(value));
  68             return;
  69         }
  70     }
  71 
  72     m_values.append(WTFMove(value));
  73 }
  74 
  75 #if !USE(CA)
  76 bool GraphicsLayer::supportsLayerType(Type type)
  77 {
  78     switch (type) {
  79     case Type::Normal:
  80     case Type::PageTiledBacking:
  81     case Type::ScrollContainer:

  82         return true;
  83     case Type::Shape:
  84         return false;
  85     }
  86     ASSERT_NOT_REACHED();
  87     return false;
  88 }
  89 
  90 bool GraphicsLayer::supportsBackgroundColorContent()
  91 {
  92 #if USE(TEXTURE_MAPPER)
  93     return true;
  94 #else
  95     return false;
  96 #endif
  97 }
  98 
  99 bool GraphicsLayer::supportsSubpixelAntialiasedLayerText()
 100 {
 101     return false;
 102 }
 103 #endif
 104 
 105 #if !USE(COORDINATED_GRAPHICS)
 106 bool GraphicsLayer::supportsContentsTiling()
 107 {
 108     // FIXME: Enable the feature on different ports.
 109     return false;
 110 }
 111 #endif
 112 
 113 // Singleton client used for layers on which clearClient has been called.
<span class="line-modified"> 114 class EmptyGraphicsLayerClient : public GraphicsLayerClient {</span>
 115     WTF_MAKE_FAST_ALLOCATED;
 116 public:
 117     static EmptyGraphicsLayerClient&amp; singleton();
 118 };
 119 
 120 EmptyGraphicsLayerClient&amp; EmptyGraphicsLayerClient::singleton()
 121 {
 122     static NeverDestroyed&lt;EmptyGraphicsLayerClient&gt; client;
 123     return client;
 124 }
 125 
 126 GraphicsLayer::GraphicsLayer(Type type, GraphicsLayerClient&amp; layerClient)
 127     : m_client(&amp;layerClient)
 128     , m_type(type)
 129     , m_beingDestroyed(false)
 130     , m_contentsOpaque(false)
 131     , m_supportsSubpixelAntialiasedText(false)
 132     , m_preserves3D(false)
 133     , m_backfaceVisibility(true)
 134     , m_masksToBounds(false)
</pre>
<hr />
<pre>
 325     if (m_parent) {
 326         GraphicsLayer* parent = m_parent;
 327         setParent(nullptr);
 328         parent-&gt;m_children.removeFirstMatching([this](auto&amp; layer) {
 329             return layer.ptr() == this;
 330         });
 331         // |this| may be destroyed here.
 332     }
 333 }
 334 
 335 const TransformationMatrix&amp; GraphicsLayer::transform() const
 336 {
 337     return m_transform ? *m_transform : TransformationMatrix::identity;
 338 }
 339 
 340 void GraphicsLayer::setTransform(const TransformationMatrix&amp; matrix)
 341 {
 342     if (m_transform)
 343         *m_transform = matrix;
 344     else
<span class="line-modified"> 345         m_transform = std::make_unique&lt;TransformationMatrix&gt;(matrix);</span>
 346 }
 347 
 348 const TransformationMatrix&amp; GraphicsLayer::childrenTransform() const
 349 {
 350     return m_childrenTransform ? *m_childrenTransform : TransformationMatrix::identity;
 351 }
 352 
 353 void GraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; matrix)
 354 {
 355     if (m_childrenTransform)
 356         *m_childrenTransform = matrix;
 357     else
<span class="line-modified"> 358         m_childrenTransform = std::make_unique&lt;TransformationMatrix&gt;(matrix);</span>
 359 }
 360 
 361 void GraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 362 {
 363     if (layer == m_maskLayer)
 364         return;
 365 
 366     if (layer) {
 367         layer-&gt;removeFromParent();
 368         layer-&gt;setParent(this);
 369         layer-&gt;setIsMaskLayer(true);
 370     } else if (m_maskLayer) {
 371         m_maskLayer-&gt;setParent(nullptr);
 372         m_maskLayer-&gt;setIsMaskLayer(false);
 373     }
 374 
 375     m_maskLayer = WTFMove(layer);
 376 }
 377 
 378 Path GraphicsLayer::shapeLayerPath() const
</pre>
<hr />
<pre>
 394 }
 395 
 396 WindRule GraphicsLayer::shapeLayerWindRule() const
 397 {
 398 #if USE(CA)
 399     return m_shapeLayerWindRule;
 400 #else
 401     return WindRule::NonZero;
 402 #endif
 403 }
 404 
 405 void GraphicsLayer::setShapeLayerWindRule(WindRule windRule)
 406 {
 407 #if USE(CA)
 408     m_shapeLayerWindRule = windRule;
 409 #else
 410     UNUSED_PARAM(windRule);
 411 #endif
 412 }
 413 





 414 void GraphicsLayer::noteDeviceOrPageScaleFactorChangedIncludingDescendants()
 415 {
 416     deviceOrPageScaleFactorChanged();
 417 
 418     if (m_maskLayer)
 419         m_maskLayer-&gt;deviceOrPageScaleFactorChanged();
 420 
 421     if (m_replicaLayer)
 422         m_replicaLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 423 
 424     for (auto&amp; layer : children())
 425         layer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 426 }
 427 
 428 void GraphicsLayer::setIsInWindow(bool inWindow)
 429 {
 430     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
 431         tiledBacking-&gt;setIsInWindow(inWindow);
 432 }
 433 
</pre>
<hr />
<pre>
 468     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 469         setNeedsDisplay();
 470 }
 471 
 472 void GraphicsLayer::setSize(const FloatSize&amp; size)
 473 {
 474     if (size == m_size)
 475         return;
 476 
 477     m_size = size;
 478 
 479     if (shouldRepaintOnSizeChange())
 480         setNeedsDisplay();
 481 }
 482 
 483 void GraphicsLayer::setBackgroundColor(const Color&amp; color)
 484 {
 485     m_backgroundColor = color;
 486 }
 487 









 488 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 489 {
 490     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 491     context.translate(-offset);
 492 
 493     FloatRect clipRect(clip);
 494     clipRect.move(offset);
 495 
 496     client().paintContents(this, context, m_paintingPhase, clipRect, layerPaintBehavior);
 497 }
 498 


























































 499 String GraphicsLayer::animationNameForTransition(AnimatedPropertyID property)
 500 {
 501     // | is not a valid identifier character in CSS, so this can never conflict with a keyframe identifier.
 502     StringBuilder id;
 503     id.appendLiteral(&quot;-|transition&quot;);
 504     id.appendNumber(static_cast&lt;int&gt;(property));
 505     id.append(&#39;-&#39;);
 506     return id.toString();
 507 }
 508 
 509 void GraphicsLayer::suspendAnimations(MonotonicTime)
 510 {
 511 }
 512 
 513 void GraphicsLayer::resumeAnimations()
 514 {
 515 }
 516 
 517 void GraphicsLayer::getDebugBorderInfo(Color&amp; color, float&amp; width) const
 518 {
</pre>
<hr />
<pre>
 816         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 817 
 818     if (m_opacity != 1)
 819         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 820 
 821 #if ENABLE(CSS_COMPOSITING)
 822     if (m_blendMode != BlendMode::Normal)
 823         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;
 824 #endif
 825 
 826     if (type() == Type::Normal &amp;&amp; tiledBacking())
 827         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 828 
 829     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 830     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 831         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 832 
 833     if (m_supportsSubpixelAntialiasedText)
 834         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 835 



 836     if (m_preserves3D)
 837         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 838 
 839     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 840         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
 841 
 842     if (!m_contentsVisible)
 843         ts &lt;&lt; indent &lt;&lt; &quot;(contentsVisible &quot; &lt;&lt; m_contentsVisible &lt;&lt; &quot;)\n&quot;;
 844 
 845     if (!m_backfaceVisibility)
 846         ts &lt;&lt; indent &lt;&lt; &quot;(backfaceVisibility &quot; &lt;&lt; (m_backfaceVisibility ? &quot;visible&quot; : &quot;hidden&quot;) &lt;&lt; &quot;)\n&quot;;
 847 
<span class="line-modified"> 848     if (behavior &amp; LayerTreeAsTextDebug) {</span>
 849         ts &lt;&lt; indent &lt;&lt; &quot;(primary-layer-id &quot; &lt;&lt; primaryLayerID() &lt;&lt; &quot;)\n&quot;;
<span class="line-removed"> 850         ts &lt;&lt; indent &lt;&lt; &quot;(client &quot; &lt;&lt; static_cast&lt;void*&gt;(m_client) &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-removed"> 851     }</span>
 852 
 853     if (m_backgroundColor.isValid() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;backgroundColor&quot;, behavior))
 854         ts &lt;&lt; indent &lt;&lt; &quot;(backgroundColor &quot; &lt;&lt; m_backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;)\n&quot;;
 855 
 856     if (behavior &amp; LayerTreeAsTextIncludeAcceleratesDrawing &amp;&amp; m_acceleratesDrawing)
 857         ts &lt;&lt; indent &lt;&lt; &quot;(acceleratesDrawing &quot; &lt;&lt; m_acceleratesDrawing &lt;&lt; &quot;)\n&quot;;
 858 
 859     if (behavior &amp; LayerTreeAsTextIncludeBackingStoreAttached)
 860         ts &lt;&lt; indent &lt;&lt; &quot;(backingStoreAttached &quot; &lt;&lt; backingStoreAttachedForTesting() &lt;&lt; &quot;)\n&quot;;
 861 
 862     if (m_transform &amp;&amp; !m_transform-&gt;isIdentity()) {
 863         ts &lt;&lt; indent &lt;&lt; &quot;(transform &quot;;
 864         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m14() &lt;&lt; &quot;] &quot;;
 865         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m24() &lt;&lt; &quot;] &quot;;
 866         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m34() &lt;&lt; &quot;] &quot;;
 867         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 868     }
 869 
 870     // Avoid dumping the sublayer transform on the root layer, because it&#39;s used for geometry flipping, whose behavior
 871     // differs between platforms.
</pre>
<hr />
<pre>
 904         ts &lt;&lt; &quot;)\n&quot;;
 905     }
 906 
 907     if (behavior &amp; LayerTreeAsTextIncludeRepaintRects &amp;&amp; repaintRectMap().contains(this) &amp;&amp; !repaintRectMap().get(this).isEmpty() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;repaintRects&quot;, behavior)) {
 908         ts &lt;&lt; indent &lt;&lt; &quot;(repaint rects\n&quot;;
 909         for (size_t i = 0; i &lt; repaintRectMap().get(this).size(); ++i) {
 910             if (repaintRectMap().get(this)[i].isEmpty())
 911                 continue;
 912 
 913             TextStream::IndentScope indentScope(ts);
 914             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot;;
 915             ts &lt;&lt; repaintRectMap().get(this)[i].x() &lt;&lt; &quot; &quot;;
 916             ts &lt;&lt; repaintRectMap().get(this)[i].y() &lt;&lt; &quot; &quot;;
 917             ts &lt;&lt; repaintRectMap().get(this)[i].width() &lt;&lt; &quot; &quot;;
 918             ts &lt;&lt; repaintRectMap().get(this)[i].height();
 919             ts &lt;&lt; &quot;)\n&quot;;
 920         }
 921         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 922     }
 923 
<span class="line-modified"> 924     if (behavior &amp; LayerTreeAsTextIncludePaintingPhases &amp;&amp; paintingPhase()) {</span>
<span class="line-modified"> 925         ts &lt;&lt; indent &lt;&lt; &quot;(paintingPhases\n&quot;;</span>
<span class="line-removed"> 926         TextStream::IndentScope indentScope(ts);</span>
<span class="line-removed"> 927         if (paintingPhase() &amp; GraphicsLayerPaintBackground)</span>
<span class="line-removed"> 928             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintBackground\n&quot;;</span>
<span class="line-removed"> 929 </span>
<span class="line-removed"> 930         if (paintingPhase() &amp; GraphicsLayerPaintForeground)</span>
<span class="line-removed"> 931             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintForeground\n&quot;;</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933         if (paintingPhase() &amp; GraphicsLayerPaintMask)</span>
<span class="line-removed"> 934             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintMask\n&quot;;</span>
<span class="line-removed"> 935 </span>
<span class="line-removed"> 936         if (paintingPhase() &amp; GraphicsLayerPaintChildClippingMask)</span>
<span class="line-removed"> 937             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintChildClippingMask\n&quot;;</span>
<span class="line-removed"> 938 </span>
<span class="line-removed"> 939         if (paintingPhase() &amp; GraphicsLayerPaintOverflowContents)</span>
<span class="line-removed"> 940             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintOverflowContents\n&quot;;</span>
<span class="line-removed"> 941 </span>
<span class="line-removed"> 942         if (paintingPhase() &amp; GraphicsLayerPaintCompositedScroll)</span>
<span class="line-removed"> 943             ts &lt;&lt; indent &lt;&lt; &quot;GraphicsLayerPaintCompositedScroll\n&quot;;</span>
<span class="line-removed"> 944 </span>
 945         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 946     }
 947 



 948     dumpAdditionalProperties(ts, behavior);
 949 
 950     if (m_children.size()) {
 951         TextStream childrenStream;
 952 
 953         childrenStream.increaseIndent(ts.indent());
 954         unsigned totalChildCount = 0;
 955         dumpChildren(childrenStream, m_children, totalChildCount, behavior);
 956 
 957         if (totalChildCount) {
 958             ts &lt;&lt; indent &lt;&lt; &quot;(children &quot; &lt;&lt; totalChildCount &lt;&lt; &quot;\n&quot;;
 959             ts &lt;&lt; childrenStream.release();
 960             ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 961         }
 962     }
 963 }
 964 
 965 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp; layers)
 966 {
 967     for (size_t i = 0; i &lt; layers.size(); ++i) {
 968         if (i)
 969             ts &lt;&lt; &quot; &quot;;
 970         ts &lt;&lt; layers[i];
 971     }
 972 
 973     return ts;
 974 }
 975 
<span class="line-modified"> 976 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const WebCore::GraphicsLayer::CustomAppearance&amp; customAppearance)</span>















 977 {
 978     switch (customAppearance) {
 979     case GraphicsLayer::CustomAppearance::None: ts &lt;&lt; &quot;none&quot;; break;
 980     case GraphicsLayer::CustomAppearance::ScrollingOverhang: ts &lt;&lt; &quot;scrolling-overhang&quot;; break;
 981     case GraphicsLayer::CustomAppearance::ScrollingShadow: ts &lt;&lt; &quot;scrolling-shadow&quot;; break;
 982     case GraphicsLayer::CustomAppearance::LightBackdrop: ts &lt;&lt; &quot;light-backdrop&quot;; break;
 983     case GraphicsLayer::CustomAppearance::DarkBackdrop: ts &lt;&lt; &quot;dark-backdrop&quot;; break;
 984     }
 985     return ts;
 986 }
 987 
 988 String GraphicsLayer::layerTreeAsText(LayerTreeAsTextBehavior behavior) const
 989 {
 990     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
 991 
 992     dumpLayer(ts, behavior);
 993     return ts.release();
 994 }
 995 
 996 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  62             m_values.insert(i + 1, WTFMove(value));
  63             return;
  64         }
  65         if (curValue-&gt;keyTime() &gt; value-&gt;keyTime()) {
  66             // insert before
  67             m_values.insert(i, WTFMove(value));
  68             return;
  69         }
  70     }
  71 
  72     m_values.append(WTFMove(value));
  73 }
  74 
  75 #if !USE(CA)
  76 bool GraphicsLayer::supportsLayerType(Type type)
  77 {
  78     switch (type) {
  79     case Type::Normal:
  80     case Type::PageTiledBacking:
  81     case Type::ScrollContainer:
<span class="line-added">  82     case Type::ScrolledContents:</span>
  83         return true;
  84     case Type::Shape:
  85         return false;
  86     }
  87     ASSERT_NOT_REACHED();
  88     return false;
  89 }
  90 
  91 bool GraphicsLayer::supportsBackgroundColorContent()
  92 {
  93 #if USE(TEXTURE_MAPPER)
  94     return true;
  95 #else
  96     return false;
  97 #endif
  98 }
  99 
 100 bool GraphicsLayer::supportsSubpixelAntialiasedLayerText()
 101 {
 102     return false;
 103 }
 104 #endif
 105 
 106 #if !USE(COORDINATED_GRAPHICS)
 107 bool GraphicsLayer::supportsContentsTiling()
 108 {
 109     // FIXME: Enable the feature on different ports.
 110     return false;
 111 }
 112 #endif
 113 
 114 // Singleton client used for layers on which clearClient has been called.
<span class="line-modified"> 115 class EmptyGraphicsLayerClient final : public GraphicsLayerClient {</span>
 116     WTF_MAKE_FAST_ALLOCATED;
 117 public:
 118     static EmptyGraphicsLayerClient&amp; singleton();
 119 };
 120 
 121 EmptyGraphicsLayerClient&amp; EmptyGraphicsLayerClient::singleton()
 122 {
 123     static NeverDestroyed&lt;EmptyGraphicsLayerClient&gt; client;
 124     return client;
 125 }
 126 
 127 GraphicsLayer::GraphicsLayer(Type type, GraphicsLayerClient&amp; layerClient)
 128     : m_client(&amp;layerClient)
 129     , m_type(type)
 130     , m_beingDestroyed(false)
 131     , m_contentsOpaque(false)
 132     , m_supportsSubpixelAntialiasedText(false)
 133     , m_preserves3D(false)
 134     , m_backfaceVisibility(true)
 135     , m_masksToBounds(false)
</pre>
<hr />
<pre>
 326     if (m_parent) {
 327         GraphicsLayer* parent = m_parent;
 328         setParent(nullptr);
 329         parent-&gt;m_children.removeFirstMatching([this](auto&amp; layer) {
 330             return layer.ptr() == this;
 331         });
 332         // |this| may be destroyed here.
 333     }
 334 }
 335 
 336 const TransformationMatrix&amp; GraphicsLayer::transform() const
 337 {
 338     return m_transform ? *m_transform : TransformationMatrix::identity;
 339 }
 340 
 341 void GraphicsLayer::setTransform(const TransformationMatrix&amp; matrix)
 342 {
 343     if (m_transform)
 344         *m_transform = matrix;
 345     else
<span class="line-modified"> 346         m_transform = makeUnique&lt;TransformationMatrix&gt;(matrix);</span>
 347 }
 348 
 349 const TransformationMatrix&amp; GraphicsLayer::childrenTransform() const
 350 {
 351     return m_childrenTransform ? *m_childrenTransform : TransformationMatrix::identity;
 352 }
 353 
 354 void GraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; matrix)
 355 {
 356     if (m_childrenTransform)
 357         *m_childrenTransform = matrix;
 358     else
<span class="line-modified"> 359         m_childrenTransform = makeUnique&lt;TransformationMatrix&gt;(matrix);</span>
 360 }
 361 
 362 void GraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 363 {
 364     if (layer == m_maskLayer)
 365         return;
 366 
 367     if (layer) {
 368         layer-&gt;removeFromParent();
 369         layer-&gt;setParent(this);
 370         layer-&gt;setIsMaskLayer(true);
 371     } else if (m_maskLayer) {
 372         m_maskLayer-&gt;setParent(nullptr);
 373         m_maskLayer-&gt;setIsMaskLayer(false);
 374     }
 375 
 376     m_maskLayer = WTFMove(layer);
 377 }
 378 
 379 Path GraphicsLayer::shapeLayerPath() const
</pre>
<hr />
<pre>
 395 }
 396 
 397 WindRule GraphicsLayer::shapeLayerWindRule() const
 398 {
 399 #if USE(CA)
 400     return m_shapeLayerWindRule;
 401 #else
 402     return WindRule::NonZero;
 403 #endif
 404 }
 405 
 406 void GraphicsLayer::setShapeLayerWindRule(WindRule windRule)
 407 {
 408 #if USE(CA)
 409     m_shapeLayerWindRule = windRule;
 410 #else
 411     UNUSED_PARAM(windRule);
 412 #endif
 413 }
 414 
<span class="line-added"> 415 void GraphicsLayer::setEventRegion(EventRegion&amp;&amp; eventRegion)</span>
<span class="line-added"> 416 {</span>
<span class="line-added"> 417     m_eventRegion = WTFMove(eventRegion);</span>
<span class="line-added"> 418 }</span>
<span class="line-added"> 419 </span>
 420 void GraphicsLayer::noteDeviceOrPageScaleFactorChangedIncludingDescendants()
 421 {
 422     deviceOrPageScaleFactorChanged();
 423 
 424     if (m_maskLayer)
 425         m_maskLayer-&gt;deviceOrPageScaleFactorChanged();
 426 
 427     if (m_replicaLayer)
 428         m_replicaLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 429 
 430     for (auto&amp; layer : children())
 431         layer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 432 }
 433 
 434 void GraphicsLayer::setIsInWindow(bool inWindow)
 435 {
 436     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
 437         tiledBacking-&gt;setIsInWindow(inWindow);
 438 }
 439 
</pre>
<hr />
<pre>
 474     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 475         setNeedsDisplay();
 476 }
 477 
 478 void GraphicsLayer::setSize(const FloatSize&amp; size)
 479 {
 480     if (size == m_size)
 481         return;
 482 
 483     m_size = size;
 484 
 485     if (shouldRepaintOnSizeChange())
 486         setNeedsDisplay();
 487 }
 488 
 489 void GraphicsLayer::setBackgroundColor(const Color&amp; color)
 490 {
 491     m_backgroundColor = color;
 492 }
 493 
<span class="line-added"> 494 void GraphicsLayer::setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt; phase)</span>
<span class="line-added"> 495 {</span>
<span class="line-added"> 496     if (phase == m_paintingPhase)</span>
<span class="line-added"> 497         return;</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     setNeedsDisplay();</span>
<span class="line-added"> 500     m_paintingPhase = phase;</span>
<span class="line-added"> 501 }</span>
<span class="line-added"> 502 </span>
 503 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 504 {
 505     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 506     context.translate(-offset);
 507 
 508     FloatRect clipRect(clip);
 509     clipRect.move(offset);
 510 
 511     client().paintContents(this, context, m_paintingPhase, clipRect, layerPaintBehavior);
 512 }
 513 
<span class="line-added"> 514 FloatRect GraphicsLayer::adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect)</span>
<span class="line-added"> 515 {</span>
<span class="line-added"> 516     // If the old visible rect is empty, we have no information about how the visible area is changing</span>
<span class="line-added"> 517     // (maybe the layer was just created), so don&#39;t attempt to expand. Also don&#39;t attempt to expand if the rects don&#39;t overlap.</span>
<span class="line-added"> 518     if (previousVisibleRect.isEmpty() || !currentVisibleRect.intersects(previousVisibleRect))</span>
<span class="line-added"> 519         return unionRect(coverageRect, currentVisibleRect);</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     const float paddingMultiplier = 2;</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523     float leftEdgeDelta = paddingMultiplier * (currentVisibleRect.x() - previousVisibleRect.x());</span>
<span class="line-added"> 524     float rightEdgeDelta = paddingMultiplier * (currentVisibleRect.maxX() - previousVisibleRect.maxX());</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526     float topEdgeDelta = paddingMultiplier * (currentVisibleRect.y() - previousVisibleRect.y());</span>
<span class="line-added"> 527     float bottomEdgeDelta = paddingMultiplier * (currentVisibleRect.maxY() - previousVisibleRect.maxY());</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529     FloatRect expandedRect = currentVisibleRect;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531     // More exposed on left side.</span>
<span class="line-added"> 532     if (leftEdgeDelta &lt; 0) {</span>
<span class="line-added"> 533         float newLeft = expandedRect.x() + leftEdgeDelta;</span>
<span class="line-added"> 534         // Pad to the left, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the left).</span>
<span class="line-added"> 535         if (newLeft &lt; previousVisibleRect.x())</span>
<span class="line-added"> 536             expandedRect.shiftXEdgeTo(newLeft);</span>
<span class="line-added"> 537         else</span>
<span class="line-added"> 538             expandedRect.shiftXEdgeTo(previousVisibleRect.x());</span>
<span class="line-added"> 539     }</span>
<span class="line-added"> 540 </span>
<span class="line-added"> 541     // More exposed on right.</span>
<span class="line-added"> 542     if (rightEdgeDelta &gt; 0) {</span>
<span class="line-added"> 543         float newRight = expandedRect.maxX() + rightEdgeDelta;</span>
<span class="line-added"> 544         // Pad to the right, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the right).</span>
<span class="line-added"> 545         if (newRight &gt; previousVisibleRect.maxX())</span>
<span class="line-added"> 546             expandedRect.setWidth(newRight - expandedRect.x());</span>
<span class="line-added"> 547         else</span>
<span class="line-added"> 548             expandedRect.setWidth(previousVisibleRect.maxX() - expandedRect.x());</span>
<span class="line-added"> 549     }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551     // More exposed at top.</span>
<span class="line-added"> 552     if (topEdgeDelta &lt; 0) {</span>
<span class="line-added"> 553         float newTop = expandedRect.y() + topEdgeDelta;</span>
<span class="line-added"> 554         if (newTop &lt; previousVisibleRect.y())</span>
<span class="line-added"> 555             expandedRect.shiftYEdgeTo(newTop);</span>
<span class="line-added"> 556         else</span>
<span class="line-added"> 557             expandedRect.shiftYEdgeTo(previousVisibleRect.y());</span>
<span class="line-added"> 558     }</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560     // More exposed on bottom.</span>
<span class="line-added"> 561     if (bottomEdgeDelta &gt; 0) {</span>
<span class="line-added"> 562         float newBottom = expandedRect.maxY() + bottomEdgeDelta;</span>
<span class="line-added"> 563         if (newBottom &gt; previousVisibleRect.maxY())</span>
<span class="line-added"> 564             expandedRect.setHeight(newBottom - expandedRect.y());</span>
<span class="line-added"> 565         else</span>
<span class="line-added"> 566             expandedRect.setHeight(previousVisibleRect.maxY() - expandedRect.y());</span>
<span class="line-added"> 567     }</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569     return unionRect(coverageRect, expandedRect);</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
 572 String GraphicsLayer::animationNameForTransition(AnimatedPropertyID property)
 573 {
 574     // | is not a valid identifier character in CSS, so this can never conflict with a keyframe identifier.
 575     StringBuilder id;
 576     id.appendLiteral(&quot;-|transition&quot;);
 577     id.appendNumber(static_cast&lt;int&gt;(property));
 578     id.append(&#39;-&#39;);
 579     return id.toString();
 580 }
 581 
 582 void GraphicsLayer::suspendAnimations(MonotonicTime)
 583 {
 584 }
 585 
 586 void GraphicsLayer::resumeAnimations()
 587 {
 588 }
 589 
 590 void GraphicsLayer::getDebugBorderInfo(Color&amp; color, float&amp; width) const
 591 {
</pre>
<hr />
<pre>
 889         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 890 
 891     if (m_opacity != 1)
 892         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 893 
 894 #if ENABLE(CSS_COMPOSITING)
 895     if (m_blendMode != BlendMode::Normal)
 896         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;
 897 #endif
 898 
 899     if (type() == Type::Normal &amp;&amp; tiledBacking())
 900         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 901 
 902     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 903     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 904         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 905 
 906     if (m_supportsSubpixelAntialiasedText)
 907         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 908 
<span class="line-added"> 909     if (m_masksToBounds &amp;&amp; behavior &amp; LayerTreeAsTextIncludeClipping)</span>
<span class="line-added"> 910         ts &lt;&lt; indent &lt;&lt; &quot;(clips &quot; &lt;&lt; m_masksToBounds &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added"> 911 </span>
 912     if (m_preserves3D)
 913         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 914 
 915     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 916         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
 917 
 918     if (!m_contentsVisible)
 919         ts &lt;&lt; indent &lt;&lt; &quot;(contentsVisible &quot; &lt;&lt; m_contentsVisible &lt;&lt; &quot;)\n&quot;;
 920 
 921     if (!m_backfaceVisibility)
 922         ts &lt;&lt; indent &lt;&lt; &quot;(backfaceVisibility &quot; &lt;&lt; (m_backfaceVisibility ? &quot;visible&quot; : &quot;hidden&quot;) &lt;&lt; &quot;)\n&quot;;
 923 
<span class="line-modified"> 924     if (behavior &amp; LayerTreeAsTextDebug)</span>
 925         ts &lt;&lt; indent &lt;&lt; &quot;(primary-layer-id &quot; &lt;&lt; primaryLayerID() &lt;&lt; &quot;)\n&quot;;


 926 
 927     if (m_backgroundColor.isValid() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;backgroundColor&quot;, behavior))
 928         ts &lt;&lt; indent &lt;&lt; &quot;(backgroundColor &quot; &lt;&lt; m_backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;)\n&quot;;
 929 
 930     if (behavior &amp; LayerTreeAsTextIncludeAcceleratesDrawing &amp;&amp; m_acceleratesDrawing)
 931         ts &lt;&lt; indent &lt;&lt; &quot;(acceleratesDrawing &quot; &lt;&lt; m_acceleratesDrawing &lt;&lt; &quot;)\n&quot;;
 932 
 933     if (behavior &amp; LayerTreeAsTextIncludeBackingStoreAttached)
 934         ts &lt;&lt; indent &lt;&lt; &quot;(backingStoreAttached &quot; &lt;&lt; backingStoreAttachedForTesting() &lt;&lt; &quot;)\n&quot;;
 935 
 936     if (m_transform &amp;&amp; !m_transform-&gt;isIdentity()) {
 937         ts &lt;&lt; indent &lt;&lt; &quot;(transform &quot;;
 938         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m14() &lt;&lt; &quot;] &quot;;
 939         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m24() &lt;&lt; &quot;] &quot;;
 940         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m34() &lt;&lt; &quot;] &quot;;
 941         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 942     }
 943 
 944     // Avoid dumping the sublayer transform on the root layer, because it&#39;s used for geometry flipping, whose behavior
 945     // differs between platforms.
</pre>
<hr />
<pre>
 978         ts &lt;&lt; &quot;)\n&quot;;
 979     }
 980 
 981     if (behavior &amp; LayerTreeAsTextIncludeRepaintRects &amp;&amp; repaintRectMap().contains(this) &amp;&amp; !repaintRectMap().get(this).isEmpty() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;repaintRects&quot;, behavior)) {
 982         ts &lt;&lt; indent &lt;&lt; &quot;(repaint rects\n&quot;;
 983         for (size_t i = 0; i &lt; repaintRectMap().get(this).size(); ++i) {
 984             if (repaintRectMap().get(this)[i].isEmpty())
 985                 continue;
 986 
 987             TextStream::IndentScope indentScope(ts);
 988             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot;;
 989             ts &lt;&lt; repaintRectMap().get(this)[i].x() &lt;&lt; &quot; &quot;;
 990             ts &lt;&lt; repaintRectMap().get(this)[i].y() &lt;&lt; &quot; &quot;;
 991             ts &lt;&lt; repaintRectMap().get(this)[i].width() &lt;&lt; &quot; &quot;;
 992             ts &lt;&lt; repaintRectMap().get(this)[i].height();
 993             ts &lt;&lt; &quot;)\n&quot;;
 994         }
 995         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 996     }
 997 
<span class="line-modified"> 998     if (behavior &amp; LayerTreeAsTextIncludeEventRegion &amp;&amp; !m_eventRegion.isEmpty()) {</span>
<span class="line-modified"> 999         ts &lt;&lt; indent &lt;&lt; &quot;(event region&quot; &lt;&lt; m_eventRegion;</span>



















1000         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1001     }
1002 
<span class="line-added">1003     if (behavior &amp; LayerTreeAsTextIncludePaintingPhases &amp;&amp; paintingPhase())</span>
<span class="line-added">1004         ts &lt;&lt; indent &lt;&lt; &quot;(paintingPhases &quot; &lt;&lt; paintingPhase() &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added">1005 </span>
1006     dumpAdditionalProperties(ts, behavior);
1007 
1008     if (m_children.size()) {
1009         TextStream childrenStream;
1010 
1011         childrenStream.increaseIndent(ts.indent());
1012         unsigned totalChildCount = 0;
1013         dumpChildren(childrenStream, m_children, totalChildCount, behavior);
1014 
1015         if (totalChildCount) {
1016             ts &lt;&lt; indent &lt;&lt; &quot;(children &quot; &lt;&lt; totalChildCount &lt;&lt; &quot;\n&quot;;
1017             ts &lt;&lt; childrenStream.release();
1018             ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1019         }
1020     }
1021 }
1022 
1023 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp; layers)
1024 {
1025     for (size_t i = 0; i &lt; layers.size(); ++i) {
1026         if (i)
1027             ts &lt;&lt; &quot; &quot;;
1028         ts &lt;&lt; layers[i];
1029     }
1030 
1031     return ts;
1032 }
1033 
<span class="line-modified">1034 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, GraphicsLayerPaintingPhase phase)</span>
<span class="line-added">1035 {</span>
<span class="line-added">1036     switch (phase) {</span>
<span class="line-added">1037     case GraphicsLayerPaintingPhase::Background: ts &lt;&lt; &quot;background&quot;; break;</span>
<span class="line-added">1038     case GraphicsLayerPaintingPhase::Foreground: ts &lt;&lt; &quot;foreground&quot;; break;</span>
<span class="line-added">1039     case GraphicsLayerPaintingPhase::Mask: ts &lt;&lt; &quot;mask&quot;; break;</span>
<span class="line-added">1040     case GraphicsLayerPaintingPhase::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;</span>
<span class="line-added">1041     case GraphicsLayerPaintingPhase::OverflowContents: ts &lt;&lt; &quot;overflow-contents&quot;; break;</span>
<span class="line-added">1042     case GraphicsLayerPaintingPhase::CompositedScroll: ts &lt;&lt; &quot;composited-scroll&quot;; break;</span>
<span class="line-added">1043     case GraphicsLayerPaintingPhase::ChildClippingMask: ts &lt;&lt; &quot;child-clipping-mask&quot;; break;</span>
<span class="line-added">1044     }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046     return ts;</span>
<span class="line-added">1047 }</span>
<span class="line-added">1048 </span>
<span class="line-added">1049 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsLayer::CustomAppearance&amp; customAppearance)</span>
1050 {
1051     switch (customAppearance) {
1052     case GraphicsLayer::CustomAppearance::None: ts &lt;&lt; &quot;none&quot;; break;
1053     case GraphicsLayer::CustomAppearance::ScrollingOverhang: ts &lt;&lt; &quot;scrolling-overhang&quot;; break;
1054     case GraphicsLayer::CustomAppearance::ScrollingShadow: ts &lt;&lt; &quot;scrolling-shadow&quot;; break;
1055     case GraphicsLayer::CustomAppearance::LightBackdrop: ts &lt;&lt; &quot;light-backdrop&quot;; break;
1056     case GraphicsLayer::CustomAppearance::DarkBackdrop: ts &lt;&lt; &quot;dark-backdrop&quot;; break;
1057     }
1058     return ts;
1059 }
1060 
1061 String GraphicsLayer::layerTreeAsText(LayerTreeAsTextBehavior behavior) const
1062 {
1063     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1064 
1065     dumpLayer(ts, behavior);
1066     return ts.release();
1067 }
1068 
1069 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsContextImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>