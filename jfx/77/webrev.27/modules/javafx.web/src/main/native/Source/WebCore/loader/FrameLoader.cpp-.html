<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
   7  * Copyright (C) 2011 Kris Jordan &lt;krisjordan@gmail.com&gt;
   8  * Copyright (C) 2011 Google Inc. All rights reserved.
   9  *
  10  * Redistribution and use in source and binary forms, with or without
  11  * modification, are permitted provided that the following conditions
  12  * are met:
  13  *
  14  * 1.  Redistributions of source code must retain the above copyright
  15  *     notice, this list of conditions and the following disclaimer.
  16  * 2.  Redistributions in binary form must reproduce the above copyright
  17  *     notice, this list of conditions and the following disclaimer in the
  18  *     documentation and/or other materials provided with the distribution.
  19  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardController.h&quot;
  41 #include &quot;BeforeUnloadEvent.h&quot;
  42 #include &quot;CachedPage.h&quot;
  43 #include &quot;CachedResourceLoader.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ContentFilter.h&quot;
  48 #include &quot;ContentSecurityPolicy.h&quot;
  49 #include &quot;DOMWindow.h&quot;
  50 #include &quot;DatabaseManager.h&quot;
  51 #include &quot;DiagnosticLoggingClient.h&quot;
  52 #include &quot;DiagnosticLoggingKeys.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentLoader.h&quot;
  55 #include &quot;Editor.h&quot;
  56 #include &quot;EditorClient.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;Event.h&quot;
  59 #include &quot;EventHandler.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FormState.h&quot;
  63 #include &quot;FormSubmission.h&quot;
  64 #include &quot;Frame.h&quot;
  65 #include &quot;FrameLoadRequest.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameNetworkingContext.h&quot;
  68 #include &quot;FrameTree.h&quot;
  69 #include &quot;FrameView.h&quot;
  70 #include &quot;GCController.h&quot;
  71 #include &quot;HTMLFormElement.h&quot;
  72 #include &quot;HTMLInputElement.h&quot;
  73 #include &quot;HTMLNames.h&quot;
  74 #include &quot;HTMLObjectElement.h&quot;
  75 #include &quot;HTMLParserIdioms.h&quot;
  76 #include &quot;HTTPHeaderNames.h&quot;
  77 #include &quot;HTTPParsers.h&quot;
  78 #include &quot;HistoryController.h&quot;
  79 #include &quot;HistoryItem.h&quot;
  80 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  81 #include &quot;InspectorController.h&quot;
  82 #include &quot;InspectorInstrumentation.h&quot;
  83 #include &quot;LinkLoader.h&quot;
  84 #include &quot;LoadTiming.h&quot;
  85 #include &quot;LoaderStrategy.h&quot;
  86 #include &quot;Logging.h&quot;
  87 #include &quot;MemoryCache.h&quot;
  88 #include &quot;MemoryRelease.h&quot;
  89 #include &quot;NavigationDisabler.h&quot;
  90 #include &quot;NavigationScheduler.h&quot;
  91 #include &quot;Node.h&quot;
  92 #include &quot;Page.h&quot;
  93 #include &quot;PageCache.h&quot;
  94 #include &quot;PageTransitionEvent.h&quot;
  95 #include &quot;PerformanceLogging.h&quot;
  96 #include &quot;PlatformStrategies.h&quot;
  97 #include &quot;PluginData.h&quot;
  98 #include &quot;PluginDocument.h&quot;
  99 #include &quot;PolicyChecker.h&quot;
 100 #include &quot;ProgressTracker.h&quot;
 101 #include &quot;ResourceHandle.h&quot;
 102 #include &quot;ResourceLoadInfo.h&quot;
 103 #include &quot;ResourceLoadObserver.h&quot;
 104 #include &quot;ResourceRequest.h&quot;
 105 #include &quot;SVGDocument.h&quot;
 106 #include &quot;SVGLocatable.h&quot;
 107 #include &quot;SVGNames.h&quot;
 108 #include &quot;SVGViewElement.h&quot;
 109 #include &quot;SVGViewSpec.h&quot;
 110 #include &quot;ScriptController.h&quot;
 111 #include &quot;ScriptSourceCode.h&quot;
 112 #include &quot;ScrollAnimator.h&quot;
 113 #include &quot;SecurityOrigin.h&quot;
 114 #include &quot;SecurityPolicy.h&quot;
 115 #include &quot;SegmentedString.h&quot;
 116 #include &quot;SerializedScriptValue.h&quot;
 117 #include &quot;Settings.h&quot;
 118 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 119 #include &quot;SubframeLoader.h&quot;
 120 #include &quot;SubresourceLoader.h&quot;
 121 #include &quot;TextResourceDecoder.h&quot;
 122 #include &quot;UserContentController.h&quot;
 123 #include &quot;UserGestureIndicator.h&quot;
 124 #include &quot;WindowFeatures.h&quot;
 125 #include &quot;XMLDocumentParser.h&quot;
 126 #include &lt;dom/ScriptDisallowedScope.h&gt;
 127 #include &lt;wtf/CompletionHandler.h&gt;
 128 #include &lt;wtf/URL.h&gt;
 129 #include &lt;wtf/Ref.h&gt;
 130 #include &lt;wtf/SetForScope.h&gt;
 131 #include &lt;wtf/StdLibExtras.h&gt;
 132 #include &lt;wtf/SystemTracing.h&gt;
 133 #include &lt;wtf/text/CString.h&gt;
 134 #include &lt;wtf/text/WTFString.h&gt;
 135 
 136 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 137 #include &quot;Archive.h&quot;
 138 #endif
 139 
 140 #if ENABLE(DATA_DETECTION)
 141 #include &quot;DataDetection.h&quot;
 142 #endif
 143 
 144 #if PLATFORM(IOS_FAMILY)
 145 #include &quot;DocumentType.h&quot;
 146 #include &quot;ResourceLoader.h&quot;
 147 #include &quot;RuntimeApplicationChecks.h&quot;
 148 #include &quot;WKContentObservation.h&quot;
 149 #endif
 150 
 151 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - FrameLoader::&quot; fmt, this, ##__VA_ARGS__)
 152 
 153 namespace WebCore {
 154 
 155 using namespace HTMLNames;
 156 using namespace SVGNames;
 157 
 158 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 159 
 160 bool isBackForwardLoadType(FrameLoadType type)
 161 {
 162     switch (type) {
 163     case FrameLoadType::Standard:
 164     case FrameLoadType::Reload:
 165     case FrameLoadType::ReloadFromOrigin:
 166     case FrameLoadType::ReloadExpiredOnly:
 167     case FrameLoadType::Same:
 168     case FrameLoadType::RedirectWithLockedBackForwardList:
 169     case FrameLoadType::Replace:
 170         return false;
 171     case FrameLoadType::Back:
 172     case FrameLoadType::Forward:
 173     case FrameLoadType::IndexedBackForward:
 174         return true;
 175     }
 176     ASSERT_NOT_REACHED();
 177     return false;
 178 }
 179 
 180 bool isReload(FrameLoadType type)
 181 {
 182     switch (type) {
 183     case FrameLoadType::Reload:
 184     case FrameLoadType::ReloadFromOrigin:
 185     case FrameLoadType::ReloadExpiredOnly:
 186         return true;
 187     case FrameLoadType::Standard:
 188     case FrameLoadType::Same:
 189     case FrameLoadType::RedirectWithLockedBackForwardList:
 190     case FrameLoadType::Replace:
 191     case FrameLoadType::Back:
 192     case FrameLoadType::Forward:
 193     case FrameLoadType::IndexedBackForward:
 194         return false;
 195     }
 196     ASSERT_NOT_REACHED();
 197     return false;
 198 }
 199 
 200 // This is not in the FrameLoader class to emphasize that it does not depend on
 201 // private FrameLoader data, and to avoid increasing the number of public functions
 202 // with access to private data.  Since only this .cpp file needs it, making it
 203 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 204 // API simpler.
 205 //
 206 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 207 {
 208     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 209 }
 210 
 211 struct ForbidPromptsScope {
 212     ForbidPromptsScope(Page* page) : m_page(page)
 213     {
 214         if (!m_page)
 215             return;
 216         m_page-&gt;forbidPrompts();
 217     }
 218 
 219     ~ForbidPromptsScope()
 220     {
 221         if (!m_page)
 222             return;
 223         m_page-&gt;allowPrompts();
 224     }
 225 
 226     Page* m_page;
 227 };
 228 
 229 class FrameLoader::FrameProgressTracker {
 230     WTF_MAKE_FAST_ALLOCATED;
 231 public:
 232     explicit FrameProgressTracker(Frame&amp; frame)
 233         : m_frame(frame)
 234         , m_inProgress(false)
 235     {
 236     }
 237 
 238     ~FrameProgressTracker()
 239     {
 240         if (m_inProgress &amp;&amp; m_frame.page())
 241             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 242     }
 243 
 244     void progressStarted()
 245     {
 246         ASSERT(m_frame.page());
 247         if (!m_inProgress)
 248             m_frame.page()-&gt;progress().progressStarted(m_frame);
 249         m_inProgress = true;
 250     }
 251 
 252     void progressCompleted()
 253     {
 254         ASSERT(m_inProgress);
 255         ASSERT(m_frame.page());
 256         m_inProgress = false;
 257         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 258 
 259         if (auto pageID = m_frame.loader().client().pageID())
 260             platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(pageID.value());
 261     }
 262 
 263 private:
 264     Frame&amp; m_frame;
 265     bool m_inProgress;
 266 };
 267 
 268 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 269     : m_frame(frame)
 270     , m_client(client)
 271     , m_policyChecker(std::make_unique&lt;PolicyChecker&gt;(frame))
 272     , m_history(std::make_unique&lt;HistoryController&gt;(frame))
 273     , m_notifier(frame)
 274     , m_subframeLoader(std::make_unique&lt;SubframeLoader&gt;(frame))
 275     , m_mixedContentChecker(frame)
 276     , m_state(FrameStateProvisional)
 277     , m_loadType(FrameLoadType::Standard)
 278     , m_quickRedirectComing(false)
 279     , m_sentRedirectNotification(false)
 280     , m_inStopAllLoaders(false)
 281     , m_isExecutingJavaScriptFormAction(false)
 282     , m_didCallImplicitClose(true)
 283     , m_wasUnloadEventEmitted(false)
 284     , m_isComplete(false)
 285     , m_needsClear(false)
 286     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 287     , m_shouldCallCheckCompleted(false)
 288     , m_shouldCallCheckLoadComplete(false)
 289     , m_opener(nullptr)
 290     , m_loadingFromCachedPage(false)
 291     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 292     , m_loadsSynchronously(false)
 293     , m_forcedSandboxFlags(SandboxNone)
 294 {
 295 }
 296 
 297 FrameLoader::~FrameLoader()
 298 {
 299     setOpener(nullptr);
 300 
 301     for (auto&amp; frame : m_openedFrames)
 302         frame-&gt;loader().m_opener = nullptr;
 303 
 304     m_client.frameLoaderDestroyed();
 305 
 306     if (m_networkingContext)
 307         m_networkingContext-&gt;invalidate();
 308 }
 309 
 310 void FrameLoader::init()
 311 {
 312     // This somewhat odd set of steps gives the frame an initial empty document.
 313     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 314     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 315     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 316 
 317     Ref&lt;Frame&gt; protect(m_frame);
 318     m_frame.document()-&gt;cancelParsing();
 319     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 320 
 321     m_networkingContext = m_client.createNetworkingContext();
 322     m_progressTracker = std::make_unique&lt;FrameProgressTracker&gt;(m_frame);
 323 }
 324 
 325 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 326 {
 327     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 328     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 329 
 330     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 331     loader-&gt;attachToFrame(m_frame);
 332     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 333     loader-&gt;setCommitted(true);
 334     setDocumentLoader(loader.ptr());
 335 
 336     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 337     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 338     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 339     m_client.transitionToCommittedForNewPage();
 340 
 341     m_didCallImplicitClose = true;
 342     m_isComplete = true;
 343     m_state = FrameStateComplete;
 344     m_needsClear = true;
 345 
 346     m_networkingContext = m_client.createNetworkingContext();
 347     m_progressTracker = std::make_unique&lt;FrameProgressTracker&gt;(m_frame);
 348 }
 349 
 350 void FrameLoader::setDefersLoading(bool defers)
 351 {
 352     if (m_documentLoader)
 353         m_documentLoader-&gt;setDefersLoading(defers);
 354     if (m_provisionalDocumentLoader)
 355         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 356     if (m_policyDocumentLoader)
 357         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 358     history().setDefersLoading(defers);
 359 
 360     if (!defers) {
 361         m_frame.navigationScheduler().startTimer();
 362         startCheckCompleteTimer();
 363     }
 364 }
 365 
 366 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 367 {
 368     if (!activeDocumentLoader()) {
 369         // Load was cancelled
 370         function(PolicyAction::Ignore, identifier);
 371         return;
 372     }
 373 
 374     // FIXME: Validate the policy check identifier.
 375     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, WTFMove(function));
 376 }
 377 
 378 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 379 {
 380     urlSelected(WTFMove(request), nullptr);
 381 }
 382 
 383 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomicString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 384 {
 385     auto* frame = lexicalFrameFromCommonVM();
 386     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 387 
 388     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 389     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 390 }
 391 
 392 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 393 {
 394     RELEASE_LOG_IF_ALLOWED(&quot;urlSelected: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 395 
 396     Ref&lt;Frame&gt; protect(m_frame);
 397 
 398     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), frameRequest.shouldReplaceDocumentIfJavaScriptURL()))
 399         return;
 400 
 401     if (frameRequest.frameName().isEmpty())
 402         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 403 
 404     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 405     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 406 
 407     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 408 }
 409 
 410 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 411 {
 412     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 413 
 414     // FIXME: Find a good spot for these.
 415     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 416 
 417     if (!m_frame.page())
 418         return;
 419 
 420     if (submission-&gt;action().isEmpty())
 421         return;
 422 
 423     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 424         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 425         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 426         return;
 427     }
 428 
 429     if (WTF::protocolIsJavaScript(submission-&gt;action())) {
 430         if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(URL(submission-&gt;action())))
 431             return;
 432         m_isExecutingJavaScriptFormAction = true;
 433         Ref&lt;Frame&gt; protect(m_frame);
 434         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), DoNotReplaceDocumentIfJavaScriptURL);
 435         m_isExecutingJavaScriptFormAction = false;
 436         return;
 437     }
 438 
 439     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 440     if (!targetFrame) {
 441         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 442             return;
 443 
 444         // FIXME: targetFrame can be null for two distinct reasons:
 445         // 1. The frame was not found by name, so we should try opening a new window.
 446         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 447         // Continuing form submission makes no sense in the latter case.
 448         // There is a repeat check after timer fires, so this is not a correctness issue.
 449 
 450         targetFrame = &amp;m_frame;
 451     } else
 452         submission-&gt;clearTarget();
 453 
 454     if (!targetFrame-&gt;page())
 455         return;
 456 
 457     // FIXME: We&#39;d like to remove this altogether and fix the multiple form submission issue another way.
 458 
 459     // We do not want to submit more than one form from the same page, nor do we want to submit a single
 460     // form more than once. This flag prevents these from happening; not sure how other browsers prevent this.
 461     // The flag is reset in each time we start dispatching a new mouse or key down event, and
 462     // also in setView since this part may get reused for a page from the back/forward cache.
 463     // The form multi-submit logic here is only needed when we are submitting a form that affects this frame.
 464 
 465     // FIXME: Frame targeting is only one of the ways the submission could end up doing something other
 466     // than replacing this frame&#39;s content, so this check is flawed. On the other hand, the check is hardly
 467     // needed any more now that we reset m_submittedFormURL on each mouse or key down event.
 468 
 469     if (m_frame.tree().isDescendantOf(targetFrame)) {
 470         if (m_submittedFormURL == submission-&gt;requestURL())
 471             return;
 472         m_submittedFormURL = submission-&gt;requestURL();
 473     }
 474 
 475     submission-&gt;data().generateFiles(m_frame.document());
 476     submission-&gt;setReferrer(outgoingReferrer());
 477     submission-&gt;setOrigin(outgoingOrigin());
 478 
 479     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 480 }
 481 
 482 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 483 {
 484     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 485         m_frame.document()-&gt;parser()-&gt;stopParsing();
 486 
 487     if (unloadEventPolicy != UnloadEventPolicyNone)
 488         dispatchUnloadEvents(unloadEventPolicy);
 489 
 490     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 491     m_didCallImplicitClose = true; // don&#39;t want that one either
 492 
 493     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 494         finishedParsing();
 495         m_frame.document()-&gt;setParsing(false);
 496     }
 497 
 498     if (auto* document = m_frame.document()) {
 499         // FIXME: HTML5 doesn&#39;t tell us to set the state to complete when aborting, but we do anyway to match legacy behavior.
 500         // http://www.w3.org/Bugs/Public/show_bug.cgi?id=10537
 501         document-&gt;setReadyState(Document::Complete);
 502 
 503         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 504         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 505     }
 506 
 507     policyChecker().stopCheck();
 508 
 509     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 510     m_frame.navigationScheduler().cancel();
 511 }
 512 
 513 void FrameLoader::stop()
 514 {
 515     // http://bugs.webkit.org/show_bug.cgi?id=10854
 516     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 517     Ref&lt;Frame&gt; protect(m_frame);
 518 
 519     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 520         parser-&gt;stopParsing();
 521         parser-&gt;finish();
 522     }
 523 }
 524 
 525 void FrameLoader::willTransitionToCommitted()
 526 {
 527     // This function is called when a frame is still fully in place (not cached, not detached), but will be replaced.
 528 
 529     if (m_frame.editor().hasComposition()) {
 530         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 531         m_frame.editor().confirmComposition();
 532         if (EditorClient* editorClient = m_frame.editor().client()) {
 533             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 534             editorClient-&gt;discardedComposition(&amp;m_frame);
 535         }
 536     }
 537 }
 538 
 539 bool FrameLoader::closeURL()
 540 {
 541     history().saveDocumentState();
 542 
 543     Document* currentDocument = m_frame.document();
 544     UnloadEventPolicy unloadEventPolicy;
 545     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 546         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 547         unloadEventPolicy = UnloadEventPolicyNone;
 548     } else {
 549         // Should only send the pagehide event here if the current document exists and has not been placed in the page cache.
 550         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;pageCacheState() == Document::NotInPageCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;
 551     }
 552 
 553     stopLoading(unloadEventPolicy);
 554 
 555     m_frame.editor().clearUndoRedoOperations();
 556     return true;
 557 }
 558 
 559 bool FrameLoader::didOpenURL()
 560 {
 561     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 562         // A redirect was scheduled before the document was created.
 563         // This can happen when one frame changes another frame&#39;s location.
 564         return false;
 565     }
 566 
 567     m_frame.navigationScheduler().cancel();
 568     m_frame.editor().clearLastEditCommand();
 569 
 570     m_isComplete = false;
 571     m_didCallImplicitClose = false;
 572 
 573     // If we are still in the process of initializing an empty document then
 574     // its frame is not in a consistent state for rendering, so avoid setJSStatusBarText
 575     // since it may cause clients to attempt to render the frame.
 576     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 577         DOMWindow* window = m_frame.document()-&gt;domWindow();
 578         window-&gt;setStatus(String());
 579         window-&gt;setDefaultStatus(String());
 580     }
 581 
 582     started();
 583 
 584     return true;
 585 }
 586 
 587 void FrameLoader::didExplicitOpen()
 588 {
 589     m_isComplete = false;
 590     m_didCallImplicitClose = false;
 591 
 592     // Calling document.open counts as committing the first real document load.
 593     if (!m_stateMachine.committedFirstRealDocumentLoad())
 594         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 595 
 596     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 597     // from a subsequent window.document.open / window.document.write call.
 598     // Canceling redirection here works for all cases because document.open
 599     // implicitly precedes document.write.
 600     m_frame.navigationScheduler().cancel();
 601 }
 602 
 603 
 604 void FrameLoader::cancelAndClear()
 605 {
 606     m_frame.navigationScheduler().cancel();
 607 
 608     if (!m_isComplete)
 609         closeURL();
 610 
 611     clear(m_frame.document(), false);
 612     m_frame.script().updatePlatformScriptObjects();
 613 }
 614 
 615 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 616 {
 617     if (!frame.isMainFrame())
 618         return false;
 619 
 620     if (frame.loader().opener())
 621         return false;
 622 
 623     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 624 }
 625 
 626 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView)
 627 {
 628     m_frame.editor().clear();
 629 
 630     if (!m_needsClear)
 631         return;
 632     m_needsClear = false;
 633 
 634     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
 635         m_frame.document()-&gt;cancelParsing();
 636         m_frame.document()-&gt;stopActiveDOMObjects();
 637         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 638         m_frame.document()-&gt;prepareForDestruction();
 639         if (hadLivingRenderTree)
 640             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 641     }
 642 
 643     // Do this after detaching the document so that the unload event works.
 644     if (clearWindowProperties) {
 645         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 646         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 647         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);
 648 
 649         if (shouldClearWindowName(m_frame, *newDocument))
 650             m_frame.tree().setName(nullAtom());
 651     }
 652 
 653     m_frame.selection().prepareForDestruction();
 654     m_frame.eventHandler().clear();
 655 
 656     if (clearFrameView &amp;&amp; m_frame.view())
 657         m_frame.view()-&gt;clear();
 658 
 659     // Do not drop the document before the ScriptController and view are cleared
 660     // as some destructors might still try to access the document.
 661     m_frame.setDocument(nullptr);
 662 
 663     subframeLoader().clear();
 664 
 665     if (clearWindowProperties)
 666         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 667 
 668     if (clearScriptObjects)
 669         m_frame.script().clearScriptObjects();
 670 
 671     m_frame.script().enableEval();
 672 
 673     m_frame.navigationScheduler().clear();
 674 
 675     m_checkTimer.stop();
 676     m_shouldCallCheckCompleted = false;
 677     m_shouldCallCheckLoadComplete = false;
 678 
 679     if (m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad())
 680         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 681 }
 682 
 683 void FrameLoader::receivedFirstData()
 684 {
 685     dispatchDidCommitLoad(WTF::nullopt);
 686     dispatchDidClearWindowObjectsInAllWorlds();
 687     dispatchGlobalObjectAvailableInAllWorlds();
 688 
 689     if (!m_documentLoader)
 690         return;
 691 
 692     auto&amp; documentLoader = *m_documentLoader;
 693     auto&amp; title = documentLoader.title();
 694     if (!title.string.isNull())
 695         m_client.dispatchDidReceiveTitle(title);
 696 
 697     ASSERT(m_frame.document());
 698     auto&amp; document = *m_frame.document();
 699 
 700     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 701 
 702     double delay;
 703     String urlString;
 704     if (!parseHTTPRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))
 705         return;
 706     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 707     if (!WTF::protocolIsJavaScript(completedURL))
 708         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 709     else {
 710         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 711         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 712     }
 713 }
 714 
 715 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 716 {
 717     m_outgoingReferrer = url.strippedForUseAsReferrer();
 718 }
 719 
 720 void FrameLoader::didBeginDocument(bool dispatch, ContentSecurityPolicy* previousPolicy)
 721 {
 722     m_needsClear = true;
 723     m_isComplete = false;
 724     m_didCallImplicitClose = false;
 725     m_frame.document()-&gt;setReadyState(Document::Loading);
 726 
 727     if (m_pendingStateObject) {
 728         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 729         m_pendingStateObject = nullptr;
 730     }
 731 
 732     if (dispatch)
 733         dispatchDidClearWindowObjectsInAllWorlds();
 734 
 735     updateFirstPartyForCookies();
 736     m_frame.document()-&gt;initContentSecurityPolicy(previousPolicy);
 737 
 738     const Settings&amp; settings = m_frame.settings();
 739     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 740     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 741 
 742     if (m_documentLoader) {
 743         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 744         if (!dnsPrefetchControl.isEmpty())
 745             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 746 
 747         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 748 
 749         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 750         if (!referrerPolicy.isNull())
 751             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 752 
 753         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 754         if (!headerContentLanguage.isEmpty()) {
 755             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 756             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
 757             headerContentLanguage = stripLeadingAndTrailingHTMLSpaces(headerContentLanguage);
 758             if (!headerContentLanguage.isEmpty())
 759                 m_frame.document()-&gt;setContentLanguage(headerContentLanguage);
 760         }
 761     }
 762 
 763     history().restoreDocumentState();
 764 }
 765 
 766 void FrameLoader::finishedParsing()
 767 {
 768     LOG(Loading, &quot;WebCoreLoading %s: Finished parsing&quot;, m_frame.tree().uniqueName().string().utf8().data());
 769 
 770     m_frame.injectUserScripts(InjectAtDocumentEnd);
 771 
 772     if (m_stateMachine.creatingInitialEmptyDocument())
 773         return;
 774 
 775     // This can be called from the Frame&#39;s destructor, in which case we shouldn&#39;t protect ourselves
 776     // because doing so will cause us to re-enter the destructor when protector goes out of scope.
 777     // Null-checking the FrameView indicates whether or not we&#39;re in the destructor.
 778     RefPtr&lt;Frame&gt; protector = m_frame.view() ? &amp;m_frame : 0;
 779 
 780     m_client.dispatchDidFinishDocumentLoad();
 781 
 782     scrollToFragmentWithParentBoundary(m_frame.document()-&gt;url());
 783 
 784     checkCompleted();
 785 
 786     if (!m_frame.view())
 787         return; // We are being destroyed by something checkCompleted called.
 788 
 789     // Check if the scrollbars are really needed for the content.
 790     // If not, remove them, relayout, and repaint.
 791     m_frame.view()-&gt;restoreScrollbar();
 792 }
 793 
 794 void FrameLoader::loadDone(LoadCompletionType type)
 795 {
 796     if (type == LoadCompletionType::Finish)
 797         checkCompleted();
 798     else
 799         scheduleCheckCompleted();
 800 }
 801 
 802 void FrameLoader::subresourceLoadDone(LoadCompletionType type)
 803 {
 804     if (type == LoadCompletionType::Finish)
 805         checkLoadComplete();
 806     else
 807         scheduleCheckLoadComplete();
 808 }
 809 
 810 bool FrameLoader::allChildrenAreComplete() const
 811 {
 812     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
 813         if (!child-&gt;loader().m_isComplete)
 814             return false;
 815     }
 816     return true;
 817 }
 818 
 819 bool FrameLoader::allAncestorsAreComplete() const
 820 {
 821     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 822         if (!ancestor-&gt;loader().m_isComplete)
 823             return false;
 824     }
 825     return true;
 826 }
 827 
 828 void FrameLoader::checkCompleted()
 829 {
 830     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 831     m_shouldCallCheckCompleted = false;
 832 
 833     // Have we completed before?
 834     if (m_isComplete)
 835         return;
 836 
 837 #if ENABLE(VIDEO)
 838     // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.
 839     if (HTMLMediaElement::isRunningDestructor()) {
 840         ASSERT_NOT_REACHED();
 841         scheduleCheckCompleted();
 842         return;
 843     }
 844 #endif
 845 
 846     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 847     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 848     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 849         scheduleCheckCompleted();
 850         return;
 851     }
 852 
 853     // Are we still parsing?
 854     if (m_frame.document()-&gt;parsing())
 855         return;
 856 
 857     // Still waiting for images/scripts?
 858     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 859         return;
 860 
 861     // Still waiting for elements that don&#39;t go through a FrameLoader?
 862     if (m_frame.document()-&gt;isDelayingLoadEvent())
 863         return;
 864 
 865     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 866     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 867         return;
 868 
 869     // Any frame that hasn&#39;t completed yet?
 870     if (!allChildrenAreComplete())
 871         return;
 872 
 873     // Important not to protect earlier in this function, because earlier parts
 874     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 875     // to ref an object while it&#39;s being destroyed.
 876     Ref&lt;Frame&gt; protect(m_frame);
 877 
 878     // OK, completed.
 879     m_isComplete = true;
 880     m_requestedHistoryItem = nullptr;
 881     m_frame.document()-&gt;setReadyState(Document::Complete);
 882 
 883 #if PLATFORM(IOS_FAMILY)
 884     if (m_frame.document()-&gt;url().isEmpty()) {
 885         // We need to update the document URL of a PDF document to be non-empty so that both back/forward history navigation
 886         // between PDF pages and fragment navigation works. See &lt;rdar://problem/9544769&gt; for more details.
 887         // FIXME: Is there a better place for this code, say DocumentLoader? Also, we should explicitly only update the URL
 888         // of the document when it&#39;s a PDFDocument object instead of assuming that a Document object with an empty URL is a PDFDocument.
 889         // FIXME: This code is incorrect for a synthesized document (which also has an empty URL). The URL for a synthesized
 890         // document should be the URL specified to FrameLoader::initForSynthesizedDocument().
 891         m_frame.document()-&gt;setURL(activeDocumentLoader()-&gt;documentURL());
 892     }
 893 #endif
 894 
 895     checkCallImplicitClose(); // if we didn&#39;t do it before
 896 
 897     m_frame.navigationScheduler().startTimer();
 898 
 899     completed();
 900     if (m_frame.page())
 901         checkLoadComplete();
 902 }
 903 
 904 void FrameLoader::checkTimerFired()
 905 {
 906     checkCompletenessNow();
 907 }
 908 
 909 void FrameLoader::checkCompletenessNow()
 910 {
 911     Ref&lt;Frame&gt; protect(m_frame);
 912 
 913     if (Page* page = m_frame.page()) {
 914         if (page-&gt;defersLoading())
 915             return;
 916     }
 917     if (m_shouldCallCheckCompleted)
 918         checkCompleted();
 919     if (m_shouldCallCheckLoadComplete)
 920         checkLoadComplete();
 921 }
 922 
 923 void FrameLoader::startCheckCompleteTimer()
 924 {
 925     if (!(m_shouldCallCheckCompleted || m_shouldCallCheckLoadComplete))
 926         return;
 927     if (m_checkTimer.isActive())
 928         return;
 929     m_checkTimer.startOneShot(0_s);
 930 }
 931 
 932 void FrameLoader::scheduleCheckCompleted()
 933 {
 934     m_shouldCallCheckCompleted = true;
 935     startCheckCompleteTimer();
 936 }
 937 
 938 void FrameLoader::scheduleCheckLoadComplete()
 939 {
 940     m_shouldCallCheckLoadComplete = true;
 941     startCheckCompleteTimer();
 942 }
 943 
 944 void FrameLoader::checkCallImplicitClose()
 945 {
 946     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 947         return;
 948 
 949     if (!allChildrenAreComplete())
 950         return; // still got a frame running -&gt; too early
 951 
 952     m_didCallImplicitClose = true;
 953     m_wasUnloadEventEmitted = false;
 954     m_frame.document()-&gt;implicitClose();
 955 }
 956 
 957 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 958 {
 959     RELEASE_LOG_IF_ALLOWED(&quot;loadURLIntoChildFrame: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 960 
 961     ASSERT(childFrame);
 962 
 963 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 964     if (auto activeLoader = activeDocumentLoader()) {
 965         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 966             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 967             return;
 968         }
 969     }
 970 #endif
 971 
 972     // If we&#39;re moving in the back/forward list, we might want to replace the content
 973     // of this child frame with whatever was there at that point.
 974     auto* parentItem = history().currentItem();
 975     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 976         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 977             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
 978             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
 979             return;
 980         }
 981     }
 982 
 983     auto* lexicalFrame = lexicalFrameFromCommonVM();
 984     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 985 
 986     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 987     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 988 }
 989 
 990 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 991 
 992 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 993 {
 994     RELEASE_LOG_IF_ALLOWED(&quot;loadArchive: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 995 
 996     ArchiveResource* mainResource = archive-&gt;mainResource();
 997     ASSERT(mainResource);
 998     if (!mainResource)
 999         return;
1000 
1001     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1002     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1003 
1004     ResourceRequest request(mainResource-&gt;url());
1005 
1006     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1007     documentLoader-&gt;setArchive(WTFMove(archive));
1008     load(documentLoader.get());
1009 }
1010 
1011 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1012 
1013 String FrameLoader::outgoingReferrer() const
1014 {
1015     // See http://www.whatwg.org/specs/web-apps/current-work/#fetching-resources
1016     // for why we walk the parent chain for srcdoc documents.
1017     Frame* frame = &amp;m_frame;
1018     while (frame &amp;&amp; frame-&gt;document()-&gt;isSrcdocDocument()) {
1019         frame = frame-&gt;tree().parent();
1020         // Srcdoc documents cannot be top-level documents, by definition,
1021         // because they need to be contained in iframes with the srcdoc.
1022         ASSERT(frame);
1023     }
1024     if (!frame)
1025         return emptyString();
1026     return frame-&gt;loader().m_outgoingReferrer;
1027 }
1028 
1029 String FrameLoader::outgoingOrigin() const
1030 {
1031     return m_frame.document()-&gt;securityOrigin().toString();
1032 }
1033 
1034 bool FrameLoader::checkIfFormActionAllowedByCSP(const URL&amp; url, bool didReceiveRedirectResponse) const
1035 {
1036     if (m_submittedFormURL.isEmpty())
1037         return true;
1038 
1039     auto redirectResponseReceived = didReceiveRedirectResponse ? ContentSecurityPolicy::RedirectResponseReceived::Yes : ContentSecurityPolicy::RedirectResponseReceived::No;
1040     return m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(url, redirectResponseReceived);
1041 }
1042 
1043 Frame* FrameLoader::opener()
1044 {
1045     return m_opener;
1046 }
1047 
1048 void FrameLoader::setOpener(Frame* opener)
1049 {
1050     if (m_opener &amp;&amp; !opener)
1051         m_client.didDisownOpener();
1052 
1053     if (m_opener) {
1054         // When setOpener is called in ~FrameLoader, opener&#39;s m_frameLoader is already cleared.
1055         auto&amp; openerFrameLoader = m_opener == &amp;m_frame ? *this : m_opener-&gt;loader();
1056         openerFrameLoader.m_openedFrames.remove(&amp;m_frame);
1057     }
1058     if (opener) {
1059         opener-&gt;loader().m_openedFrames.add(&amp;m_frame);
1060         if (auto* page = m_frame.page())
1061             page-&gt;setOpenedByDOMWithOpener();
1062     }
1063     m_opener = opener;
1064 
1065     if (m_frame.document())
1066         m_frame.document()-&gt;initSecurityContext();
1067 }
1068 
1069 // FIXME: This does not belong in FrameLoader!
1070 void FrameLoader::handleFallbackContent()
1071 {
1072     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
1073     if (!is&lt;HTMLObjectElement&gt;(owner))
1074         return;
1075     downcast&lt;HTMLObjectElement&gt;(*owner).renderFallbackContent();
1076 }
1077 
1078 void FrameLoader::provisionalLoadStarted()
1079 {
1080     if (m_stateMachine.firstLayoutDone())
1081         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
1082     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1083     m_client.provisionalLoadStarted();
1084 
1085     if (m_frame.isMainFrame()) {
1086         tracePoint(MainResourceLoadDidStartProvisional);
1087 
1088         if (auto* page = m_frame.page())
1089             page-&gt;didStartProvisionalLoad();
1090     }
1091 }
1092 
1093 void FrameLoader::resetMultipleFormSubmissionProtection()
1094 {
1095     m_submittedFormURL = URL();
1096 }
1097 
1098 void FrameLoader::updateFirstPartyForCookies()
1099 {
1100     if (m_frame.tree().parent())
1101         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1102     else
1103         setFirstPartyForCookies(m_frame.document()-&gt;url());
1104 }
1105 
1106 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1107 {
1108     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1109         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1110 
1111     String registrableDomain = ResourceRequest::partitionName(url.host().toString());
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
1113         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomainsAreEqual(frame-&gt;document()-&gt;url(), registrableDomain))
1114             frame-&gt;document()-&gt;setSiteForCookies(url);
1115     }
1116 }
1117 
1118 // This does the same kind of work that didOpenURL does, except it relies on the fact
1119 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1120 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1121 {
1122     RELEASE_LOG_IF_ALLOWED(&quot;loadInSameDocument: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1123 
1124     // If we have a state object, we cannot also be a new navigation.
1125     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1126 
1127     // Update the data source&#39;s request with the new URL to fake the URL change
1128     URL oldURL = m_frame.document()-&gt;url();
1129     m_frame.document()-&gt;setURL(url);
1130     setOutgoingReferrer(url);
1131     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1132     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1133         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1134         // based on the current request. Must also happen before we openURL and displace the
1135         // scroll position, since adding the BF item will save away scroll state.
1136 
1137         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1138         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1139         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1140         // though its load is not yet done.  I think this all works out OK, for one because
1141         // we have already saved away the scroll and doc state for the long slow load,
1142         // but it&#39;s not an obvious case.
1143 
1144         history().updateBackForwardListForFragmentScroll();
1145     }
1146 
1147     bool hashChange = equalIgnoringFragmentIdentifier(url, oldURL) &amp;&amp; url.fragmentIdentifier() != oldURL.fragmentIdentifier();
1148 
1149     history().updateForSameDocumentNavigation();
1150 
1151     // If we were in the autoscroll/panScroll mode we want to stop it before following the link to the anchor
1152     if (hashChange)
1153         m_frame.eventHandler().stopAutoscrollTimer();
1154 
1155     // It&#39;s important to model this as a load that starts and immediately finishes.
1156     // Otherwise, the parent frame may think we never finished loading.
1157     started();
1158 
1159     if (auto* ownerElement = m_frame.ownerElement()) {
1160         auto* ownerRenderer = ownerElement-&gt;renderer();
1161         auto* view = m_frame.view();
1162         if (is&lt;RenderWidget&gt;(ownerRenderer) &amp;&amp; view)
1163             downcast&lt;RenderWidget&gt;(*ownerRenderer).setWidget(view);
1164     }
1165 
1166     // We need to scroll to the fragment whether or not a hash change occurred, since
1167     // the user might have scrolled since the previous navigation.
1168     scrollToFragmentWithParentBoundary(url, isNewNavigation);
1169 
1170     m_isComplete = false;
1171     checkCompleted();
1172 
1173     if (isNewNavigation) {
1174         // This will clear previousItem from the rest of the frame tree that didn&#39;t
1175         // doing any loading. We need to make a pass on this now, since for fragment
1176         // navigation we&#39;ll not go through a real load and reach Completed state.
1177         checkLoadComplete();
1178     }
1179 
1180     m_client.dispatchDidNavigateWithinPage();
1181 
1182     m_frame.document()-&gt;statePopped(stateObject ? Ref&lt;SerializedScriptValue&gt; { *stateObject } : SerializedScriptValue::nullValue());
1183     m_client.dispatchDidPopStateWithinPage();
1184 
1185     if (hashChange) {
1186         m_frame.document()-&gt;enqueueHashchangeEvent(oldURL, url);
1187         m_client.dispatchDidChangeLocationWithinPage();
1188     }
1189 
1190     // FrameLoaderClient::didFinishLoad() tells the internal load delegate the load finished with no error
1191     m_client.didFinishLoad();
1192 }
1193 
1194 bool FrameLoader::isComplete() const
1195 {
1196     return m_isComplete;
1197 }
1198 
1199 void FrameLoader::completed()
1200 {
1201     Ref&lt;Frame&gt; protect(m_frame);
1202 
1203     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1204         descendant-&gt;navigationScheduler().startTimer();
1205 
1206     if (Frame* parent = m_frame.tree().parent())
1207         parent-&gt;loader().checkCompleted();
1208 
1209     if (m_frame.view())
1210         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1211 }
1212 
1213 void FrameLoader::started()
1214 {
1215     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1216         frame-&gt;loader().m_isComplete = false;
1217 }
1218 
1219 void FrameLoader::prepareForLoadStart()
1220 {
1221     RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart: Starting frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1222 
1223     m_progressTracker-&gt;progressStarted();
1224     m_client.dispatchDidStartProvisionalLoad();
1225 
1226     if (AXObjectCache::accessibilityEnabled()) {
1227         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1228             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1229             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1230         }
1231     }
1232 }
1233 
1234 void FrameLoader::setupForReplace()
1235 {
1236     m_client.revertToProvisionalState(m_documentLoader.get());
1237     setState(FrameStateProvisional);
1238     m_provisionalDocumentLoader = m_documentLoader;
1239     m_documentLoader = nullptr;
1240     detachChildren();
1241 }
1242 
1243 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1244 {
1245     RELEASE_LOG_IF_ALLOWED(&quot;loadFrameRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1246 
1247     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1248     auto protectFrame = makeRef(m_frame);
1249 
1250     URL url = request.resourceRequest().url();
1251 
1252     ASSERT(m_frame.document());
1253     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1254         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1255         return;
1256     }
1257 
1258     String argsReferrer = request.resourceRequest().httpReferrer();
1259     if (argsReferrer.isEmpty())
1260         argsReferrer = outgoingReferrer();
1261 
1262     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1263     if (request.shouldSendReferrer() == NeverSendReferrer)
1264         referrer = String();
1265 
1266     FrameLoadType loadType;
1267     if (request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1268         loadType = FrameLoadType::Reload;
1269     else if (request.lockBackForwardList() == LockBackForwardList::Yes)
1270         loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1271     else
1272         loadType = FrameLoadType::Standard;
1273 
1274     auto completionHandler = [this, protectedFrame = makeRef(m_frame), formState = makeWeakPtr(formState.get()), frameName = request.frameName()] {
1275         // FIXME: It&#39;s possible this targetFrame will not be the same frame that was targeted by the actual
1276         // load if frame names have changed.
1277         Frame* sourceFrame = formState ? formState-&gt;sourceDocument().frame() : &amp;m_frame;
1278         if (!sourceFrame)
1279             sourceFrame = &amp;m_frame;
1280         Frame* targetFrame = sourceFrame-&gt;loader().findFrameForNavigation(frameName);
1281         if (targetFrame &amp;&amp; targetFrame != sourceFrame) {
1282             if (Page* page = targetFrame-&gt;page())
1283                 page-&gt;chrome().focus();
1284         }
1285     };
1286 
1287     if (request.resourceRequest().httpMethod() == &quot;POST&quot;)
1288         loadPostRequest(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(completionHandler));
1289     else
1290         loadURL(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(adClickAttribution), WTFMove(completionHandler));
1291 }
1292 
1293 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1294 {
1295     if (UserGestureIndicator::processingUserGesture())
1296         return ShouldOpenExternalURLsPolicy::ShouldAllow;
1297 
1298     if (initiatedByMainFrame == InitiatedByMainFrame::Yes)
1299         return propagatedPolicy;
1300 
1301     if (!currentFrame.isMainFrame())
1302         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
1303 
1304     return propagatedPolicy;
1305 }
1306 
1307 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1308 {
1309     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1310 }
1311 
1312 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1313 {
1314     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1315 }
1316 
1317 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1318 {
1319     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1320 }
1321 
1322 bool FrameLoader::isNavigationAllowed() const
1323 {
1324     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);
1325 }
1326 
1327 bool FrameLoader::isStopLoadingAllowed() const
1328 {
1329     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1330 }
1331 
1332 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1333 {
1334     RELEASE_LOG_IF_ALLOWED(&quot;loadURL: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1335 
1336     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1337     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1338         return;
1339 
1340     Ref&lt;Frame&gt; protect(m_frame);
1341 
1342     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1343     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1344     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1345     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1346     LockHistory lockHistory = frameLoadRequest.lockHistory();
1347     bool isFormSubmission = formState;
1348 
1349     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1350     ResourceRequest request(newURL);
1351     if (!referrer.isEmpty()) {
1352         request.setHTTPReferrer(referrer);
1353         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1354         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
1355     }
1356     if (&amp;m_frame.tree().top() != &amp;m_frame)
1357         request.setDomainForCachePartition(m_frame.tree().top().document()-&gt;domainForCachePartition());
1358 
1359     addExtraFieldsToRequest(request, newLoadType, true);
1360     if (isReload(newLoadType))
1361         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1362 
1363     ASSERT(newLoadType != FrameLoadType::Same);
1364 
1365     // The search for a target frame is done earlier in the case of form submission.
1366     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1367     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1368         frameLoadRequest.setFrameName(&quot;_self&quot;);
1369         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1370         return;
1371     }
1372 
1373     if (!isNavigationAllowed())
1374         return;
1375 
1376     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1377     action.setLockHistory(lockHistory);
1378     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1379     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1380         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1381 
1382     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1383         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
1384         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
1385             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1386             completionHandler();
1387         });
1388         return;
1389     }
1390 
1391     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1392 
1393     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1394     const String&amp; httpMethod = request.httpMethod();
1395 
1396     // Make sure to do scroll to fragment processing even if the URL is
1397     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1398     // work properly.
1399     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1400         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1401         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1402         policyChecker().stopCheck();
1403         policyChecker().setLoadType(newLoadType);
1404         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1405         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1406             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1407         }, PolicyDecisionMode::Synchronous);
1408         return;
1409     }
1410 
1411     // Must grab this now, since this load may stop the previous load and clear this flag.
1412     bool isRedirect = m_quickRedirectComing;
1413 #if USE(SYSTEM_PREVIEW)
1414     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1415     request.setSystemPreview(isSystemPreview);
1416     if (isSystemPreview)
1417         request.setSystemPreviewRect(frameLoadRequest.systemPreviewRect());
1418 #endif
1419     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {
1420         if (isRedirect) {
1421             m_quickRedirectComing = false;
1422             if (m_provisionalDocumentLoader)
1423                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1424             else if (m_policyDocumentLoader)
1425                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1426         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1427             // Example of this case are sites that reload the same URL with a different cookie
1428             // driving the generated content, or a master frame with links that drive a target
1429             // frame, where the user has clicked on the same link repeatedly.
1430             m_loadType = FrameLoadType::Same;
1431         }
1432         completionHandler();
1433     });
1434 }
1435 
1436 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1437 {
1438     if (!shouldTreatURLAsSrcdocDocument(url))
1439         return SubstituteData();
1440     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1441     ASSERT(!srcdoc.isNull());
1442     CString encodedSrcdoc = srcdoc.string().utf8();
1443 
1444     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1445     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1446 }
1447 
1448 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1449 {
1450     RELEASE_LOG_IF_ALLOWED(&quot;load (FrameLoadRequest): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1451 
1452     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1453         return;
1454 
1455     if (!request.frameName().isEmpty()) {
1456         Frame* frame = findFrameForNavigation(request.frameName());
1457         if (frame) {
1458             request.setShouldCheckNewWindowPolicy(false);
1459             if (&amp;frame-&gt;loader() != this) {
1460                 frame-&gt;loader().load(WTFMove(request));
1461                 return;
1462             }
1463         }
1464     }
1465 
1466     if (request.shouldCheckNewWindowPolicy()) {
1467         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
1468         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) {
1469             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1470         });
1471 
1472         return;
1473     }
1474 
1475     if (!request.hasSubstituteData())
1476         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1477 
1478     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1479     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1480     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1481     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1482 
1483     if (request.shouldTreatAsContinuingLoad()) {
1484         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1485         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1486             loader-&gt;setIsClientRedirect(true);
1487             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1488         }
1489     }
1490 
1491     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1492     load(loader.get());
1493 }
1494 
1495 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1496 {
1497     RELEASE_LOG_IF_ALLOWED(&quot;loadWithNavigationAction: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1498 
1499     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1500     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1501 
1502     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1503         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1504 
1505     loader-&gt;setTriggeringAction(WTFMove(action));
1506     if (m_documentLoader)
1507         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1508 
1509     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1510 }
1511 
1512 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1513 {
1514     RELEASE_LOG_IF_ALLOWED(&quot;load (DocumentLoader): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1515 
1516     ResourceRequest&amp; r = newDocumentLoader.request();
1517     addExtraFieldsToMainResourceRequest(r);
1518     FrameLoadType type;
1519 
1520     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1521         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1522         type = FrameLoadType::Same;
1523     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1524         type = m_loadType;
1525     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1526         type = FrameLoadType::RedirectWithLockedBackForwardList;
1527     else
1528         type = FrameLoadType::Standard;
1529 
1530     if (m_documentLoader)
1531         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1532 
1533     // When we loading alternate content for an unreachable URL that we&#39;re
1534     // visiting in the history list, we treat it as a reload so the history list
1535     // is appropriately maintained.
1536     //
1537     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1538     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1539     // &quot;load without affecting history&quot; ?
1540     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1541         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1542         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1543         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1544         history().saveDocumentAndScrollState();
1545 
1546         ASSERT(type == FrameLoadType::Standard);
1547         type = FrameLoadType::Reload;
1548     }
1549 
1550     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1551 }
1552 
1553 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1554 {
1555     RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1556 
1557     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1558     Ref&lt;Frame&gt; protect(m_frame);
1559 
1560     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1561 
1562     ASSERT(m_client.hasWebView());
1563 
1564     // Unfortunately the view must be non-nil, this is ultimately due
1565     // to parser requiring a FrameView.  We should fix this dependency.
1566 
1567     ASSERT(m_frame.view());
1568 
1569     if (!isNavigationAllowed())
1570         return;
1571 
1572     if (m_frame.document())
1573         m_previousURL = m_frame.document()-&gt;url();
1574 
1575     const URL&amp; newURL = loader-&gt;request().url();
1576 
1577     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1578     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1579     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1580         m_shouldReportResourceTimingToParentFrame = false;
1581 
1582     // Log main frame navigation types.
1583     if (m_frame.isMainFrame()) {
1584         if (auto* page = m_frame.page()) {
1585             RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: main frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1586             page-&gt;mainFrameLoadStarted(newURL, type);
1587             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1588         }
1589     }
1590 
1591     policyChecker().setLoadType(type);
1592     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1593     bool isFormSubmission = formState;
1594 
1595     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1596 
1597     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1598         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1599         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1600 
1601         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1602         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1603         policyChecker().stopCheck();
1604         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1605         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1606             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1607         }, PolicyDecisionMode::Synchronous);
1608         return;
1609     }
1610 
1611     if (Frame* parent = m_frame.tree().parent())
1612         loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());
1613 
1614     policyChecker().stopCheck();
1615     setPolicyDocumentLoader(loader);
1616     if (loader-&gt;triggeringAction().isEmpty())
1617         loader-&gt;setTriggeringAction({ *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission });
1618 
1619     if (Element* ownerElement = m_frame.ownerElement()) {
1620         // We skip dispatching the beforeload event if we&#39;ve already
1621         // committed a real document load because the event would leak
1622         // subsequent activity by the frame which the parent frame isn&#39;t
1623         // supposed to learn. For example, if the child frame navigated to
1624         // a new URL, the parent frame shouldn&#39;t learn the URL.
1625         if (!m_stateMachine.committedFirstRealDocumentLoad()
1626             &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) {
1627             continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::IgnoreLoad, allowNavigationToInvalidURL);
1628             return;
1629         }
1630     }
1631 
1632     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1633 
1634     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1635         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1636         return;
1637     }
1638 
1639     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1640     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1641         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1642         completionHandler();
1643     }, PolicyDecisionMode::Asynchronous);
1644 }
1645 
1646 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1647 {
1648     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1649         return;
1650 
1651     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1652     m_provisionalDocumentLoader-&gt;stopLoading();
1653     setProvisionalDocumentLoader(nullptr);
1654 }
1655 
1656 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1657 {
1658     ASSERT(!url.isEmpty());
1659     if (!frame)
1660         return;
1661 
1662     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1663 }
1664 
1665 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1666 {
1667     ASSERT(!url.isEmpty());
1668     if (!frame)
1669         return;
1670 
1671     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1672 }
1673 
1674 void FrameLoader::reportAuthenticationChallengeBlocked(Frame* frame, const URL&amp; url, const String&amp; reason)
1675 {
1676     if (!frame)
1677         return;
1678 
1679     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Blocked &quot;, url.stringCenterEllipsizedToLength(), &quot; from asking for credentials because &quot;, reason, &#39;.&#39;));
1680 }
1681 
1682 const ResourceRequest&amp; FrameLoader::initialRequest() const
1683 {
1684     return activeDocumentLoader()-&gt;originalRequest();
1685 }
1686 
1687 bool FrameLoader::willLoadMediaElementURL(URL&amp; url, Node&amp; initiatorNode)
1688 {
1689 #if PLATFORM(IOS_FAMILY)
1690     // MobileStore depends on the iOS 4.0 era client delegate method because webView:resource:willSendRequest:redirectResponse:fromDataSource
1691     // doesn&#39;t let them tell when a load request is coming from a media element. See &lt;rdar://problem/8266916&gt; for more details.
1692     if (IOSApplication::isMobileStore())
1693         return m_client.shouldLoadMediaElementURL(url);
1694 #endif
1695 
1696     ResourceRequest request(url);
1697     request.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(initiatorNode));
1698 
1699     unsigned long identifier;
1700     ResourceError error;
1701     requestFromDelegate(request, identifier, error);
1702     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, ResourceResponse(url, String(), -1, String()), 0, -1, -1, error);
1703 
1704     url = request.url();
1705 
1706     return error.isNull();
1707 }
1708 
1709 bool FrameLoader::shouldReloadToHandleUnreachableURL(DocumentLoader&amp; docLoader)
1710 {
1711     URL unreachableURL = docLoader.unreachableURL();
1712 
1713     if (unreachableURL.isEmpty())
1714         return false;
1715 
1716     if (!isBackForwardLoadType(policyChecker().loadType()))
1717         return false;
1718 
1719     // We only treat unreachableURLs specially during the delegate callbacks
1720     // for provisional load errors and navigation policy decisions. The former
1721     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1722     // case handles malformed URLs and unknown schemes. Loading alternate content
1723     // at other times behaves like a standard load.
1724     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1725         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1726 
1727     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1728 }
1729 
1730 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1731 {
1732     if (!m_documentLoader)
1733         return;
1734 
1735     RELEASE_LOG_IF_ALLOWED(&quot;reloadWithOverrideEncoding: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1736 
1737     ResourceRequest request = m_documentLoader-&gt;request();
1738     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1739     if (!unreachableURL.isEmpty())
1740         request.setURL(unreachableURL);
1741 
1742     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1743     // We should ask the user for confirmation in this case.
1744     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1745 
1746     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1747     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1748 
1749     setPolicyDocumentLoader(loader.ptr());
1750 
1751     loader-&gt;setOverrideEncoding(encoding);
1752 
1753     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1754 }
1755 
1756 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1757 {
1758     if (!m_documentLoader)
1759         return;
1760 
1761     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1762     // Reloading in this case will lose the current contents (see 4151001).
1763     if (m_documentLoader-&gt;request().url().isEmpty())
1764         return;
1765 
1766     RELEASE_LOG_IF_ALLOWED(&quot;reload: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1767 
1768     // Replace error-page URL with the URL we were trying to reach.
1769     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1770     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1771     if (!unreachableURL.isEmpty())
1772         initialRequest.setURL(unreachableURL);
1773 
1774     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1775     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1776     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1777     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());
1778     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1779 
1780     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1781 
1782     ResourceRequest&amp; request = loader-&gt;request();
1783 
1784     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1785     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1786 
1787     addSameSiteInfoToRequestIfNeeded(request);
1788 
1789     // If we&#39;re about to re-post, set up action so the application can warn the user.
1790     if (request.httpMethod() == &quot;POST&quot;)
1791         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1792 
1793     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1794 
1795     auto frameLoadTypeForReloadOptions = [] (auto options) {
1796         if (options &amp; ReloadOption::FromOrigin)
1797             return FrameLoadType::ReloadFromOrigin;
1798         if (options &amp; ReloadOption::ExpiredOnly)
1799             return FrameLoadType::ReloadExpiredOnly;
1800         return FrameLoadType::Reload;
1801     };
1802 
1803     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1804 }
1805 
1806 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy)
1807 {
1808     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;pageCacheState() == Document::InPageCache)
1809         return;
1810 
1811     if (!isStopLoadingAllowed())
1812         return;
1813 
1814     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1815     if (m_inStopAllLoaders)
1816         return;
1817 
1818     // This method might dispatch events.
1819     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1820 
1821     // Calling stopLoading() on the provisional document loader can blow away
1822     // the frame from underneath.
1823     Ref&lt;Frame&gt; protect(m_frame);
1824 
1825     m_inStopAllLoaders = true;
1826 
1827     policyChecker().stopCheck();
1828 
1829     // If no new load is in progress, we should clear the provisional item from history
1830     // before we call stopLoading.
1831     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1832         history().setProvisionalItem(nullptr);
1833 
1834     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1835         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1836     if (m_provisionalDocumentLoader)
1837         m_provisionalDocumentLoader-&gt;stopLoading();
1838     if (m_documentLoader)
1839         m_documentLoader-&gt;stopLoading();
1840 
1841     setProvisionalDocumentLoader(nullptr);
1842 
1843     m_inStopAllLoaders = false;
1844 }
1845 
1846 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1847 {
1848     stopAllLoaders();
1849 
1850     if (!m_checkTimer.isActive())
1851         return;
1852 
1853     m_checkTimer.stop();
1854     m_checkingLoadCompleteForDetachment = true;
1855     checkCompletenessNow();
1856     m_checkingLoadCompleteForDetachment = false;
1857 }
1858 
1859 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1860 {
1861     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1862     Ref&lt;Frame&gt; protectedFrame(m_frame);
1863 
1864     stopAllLoaders();
1865 
1866 #if PLATFORM(IOS_FAMILY)
1867     // Lay out immediately when stopping to immediately clear the old page if we just committed this one
1868     // but haven&#39;t laid out/painted yet.
1869     // FIXME: Is this behavior specific to iOS? Or should we expose a setting to toggle this behavior?
1870     if (m_frame.view() &amp;&amp; !m_frame.view()-&gt;didFirstLayout())
1871         m_frame.view()-&gt;layoutContext().layout();
1872 #endif
1873 
1874     if (deferCheckLoadComplete)
1875         scheduleCheckLoadComplete();
1876     else if (m_frame.page())
1877         checkLoadComplete();
1878 }
1879 
1880 DocumentLoader* FrameLoader::activeDocumentLoader() const
1881 {
1882     if (m_state == FrameStateProvisional)
1883         return m_provisionalDocumentLoader.get();
1884     return m_documentLoader.get();
1885 }
1886 
1887 bool FrameLoader::isLoading() const
1888 {
1889     DocumentLoader* docLoader = activeDocumentLoader();
1890     if (!docLoader)
1891         return false;
1892     return docLoader-&gt;isLoading();
1893 }
1894 
1895 bool FrameLoader::frameHasLoaded() const
1896 {
1897     return m_stateMachine.committedFirstRealDocumentLoad() || (m_provisionalDocumentLoader &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument());
1898 }
1899 
1900 void FrameLoader::setDocumentLoader(DocumentLoader* loader)
1901 {
1902     if (!loader &amp;&amp; !m_documentLoader)
1903         return;
1904 
1905     if (loader == m_documentLoader)
1906         return;
1907 
1908     ASSERT(loader != m_documentLoader);
1909     ASSERT(!loader || loader-&gt;frameLoader() == this);
1910 
1911     m_client.prepareForDataSourceReplacement();
1912     detachChildren();
1913 
1914     // detachChildren() can trigger this frame&#39;s unload event, and therefore
1915     // script can run and do just about anything. For example, an unload event that calls
1916     // document.write(&quot;&quot;) on its parent frame can lead to a recursive detachChildren()
1917     // invocation for this frame. In that case, we can end up at this point with a
1918     // loader that hasn&#39;t been deleted but has been detached from its frame. Such a
1919     // DocumentLoader has been sufficiently detached that we&#39;ll end up in an inconsistent
1920     // state if we try to use it.
1921     if (loader &amp;&amp; !loader-&gt;frame())
1922         return;
1923 
1924     if (m_documentLoader)
1925         m_documentLoader-&gt;detachFromFrame();
1926 
1927     m_documentLoader = loader;
1928 }
1929 
1930 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1931 {
1932     if (m_policyDocumentLoader == loader)
1933         return;
1934 
1935     if (loader)
1936         loader-&gt;attachToFrame(m_frame);
1937     if (m_policyDocumentLoader
1938             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1939             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1940         m_policyDocumentLoader-&gt;detachFromFrame();
1941 
1942     m_policyDocumentLoader = loader;
1943 }
1944 
1945 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1946 {
1947     ASSERT(!loader || !m_provisionalDocumentLoader);
1948     ASSERT(!loader || loader-&gt;frameLoader() == this);
1949 
1950     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1951         m_provisionalDocumentLoader-&gt;detachFromFrame();
1952 
1953     m_provisionalDocumentLoader = loader;
1954 }
1955 
1956 void FrameLoader::setState(FrameState newState)
1957 {
1958     FrameState oldState = m_state;
1959     m_state = newState;
1960 
1961     if (newState == FrameStateProvisional)
1962         provisionalLoadStarted();
1963     else if (newState == FrameStateComplete) {
1964         frameLoadCompleted();
1965         if (m_documentLoader)
1966             m_documentLoader-&gt;stopRecordingResponses();
1967         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
1968             RELEASE_LOG_IF_ALLOWED(&quot;setState: main frame load completed (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1969             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
1970         }
1971     }
1972 }
1973 
1974 void FrameLoader::clearProvisionalLoad()
1975 {
1976     setProvisionalDocumentLoader(nullptr);
1977     m_progressTracker-&gt;progressCompleted();
1978     setState(FrameStateComplete);
1979 }
1980 
1981 void FrameLoader::commitProvisionalLoad()
1982 {
1983     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
1984     Ref&lt;Frame&gt; protect(m_frame);
1985 
1986     std::unique_ptr&lt;CachedPage&gt; cachedPage;
1987     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
1988         cachedPage = PageCache::singleton().take(*history().provisionalItem(), m_frame.page());
1989 
1990     LOG(PageCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),
1991         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
1992         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
1993 
1994     willTransitionToCommitted();
1995 
1996     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
1997         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
1998         // We are doing this here because we know for sure that a new page is about to be loaded.
1999         PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());
2000 
2001         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2002     }
2003 
2004     if (m_loadType != FrameLoadType::Replace)
2005         closeOldDataSources();
2006 
2007     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2008         m_client.makeRepresentation(pdl.get());
2009 
2010     transitionToCommitted(cachedPage.get());
2011 
2012     if (pdl &amp;&amp; m_documentLoader) {
2013         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2014         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2015         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2016     }
2017 
2018     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2019     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
2020     // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:.  Since we are
2021     // just about to commit a new page, there cannot possibly be a pending redirect at this point.
2022     if (m_sentRedirectNotification)
2023         clientRedirectCancelledOrFinished(NewLoadInProgress::No);
2024 
2025     if (cachedPage &amp;&amp; cachedPage-&gt;document()) {
2026 #if PLATFORM(IOS_FAMILY)
2027         // FIXME: CachedPage::restore() would dispatch viewport change notification. However UIKit expects load
2028         // commit to happen before any changes to viewport arguments and dealing with this there is difficult.
2029         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(true);
2030 #endif
2031         willRestoreFromCachedPage();
2032 
2033         // Start request for the main resource and dispatch didReceiveResponse before the load is committed for
2034         // consistency with all other loads. See https://bugs.webkit.org/show_bug.cgi?id=150927.
2035         ResourceError mainResouceError;
2036         unsigned long mainResourceIdentifier;
2037         ResourceRequest mainResourceRequest(cachedPage-&gt;documentLoader()-&gt;request());
2038         requestFromDelegate(mainResourceRequest, mainResourceIdentifier, mainResouceError);
2039         notifier().dispatchDidReceiveResponse(cachedPage-&gt;documentLoader(), mainResourceIdentifier, cachedPage-&gt;documentLoader()-&gt;response());
2040 
2041         Optional&lt;HasInsecureContent&gt; hasInsecureContent = cachedPage-&gt;cachedMainFrame()-&gt;hasInsecureContent();
2042 
2043         dispatchDidCommitLoad(hasInsecureContent);
2044 
2045         // FIXME: This API should be turned around so that we ground CachedPage into the Page.
2046         cachedPage-&gt;restore(*m_frame.page());
2047 
2048 #if PLATFORM(IOS_FAMILY)
2049         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(false);
2050         m_frame.page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_frame.page()-&gt;viewportArguments());
2051 #endif
2052         m_frame.page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_frame.page()-&gt;disabledAdaptations());
2053 
2054         auto&amp; title = m_documentLoader-&gt;title();
2055         if (!title.string.isNull())
2056             m_client.dispatchDidReceiveTitle(title);
2057 
2058         // Send remaining notifications for the main resource.
2059         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2060             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2061 
2062         checkCompleted();
2063     } else
2064         didOpenURL();
2065 
2066     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2067         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2068 
2069     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2070         history().updateForClientRedirect();
2071 
2072     if (m_loadingFromCachedPage) {
2073         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2074         if (auto* page = m_frame.page())
2075             page-&gt;chrome().didReceiveDocType(m_frame);
2076         m_frame.document()-&gt;resume(ReasonForSuspension::PageCache);
2077 
2078         // Force a layout to update view size and thereby update scrollbars.
2079 #if PLATFORM(IOS_FAMILY)
2080         if (!m_client.forceLayoutOnRestoreFromPageCache())
2081             m_frame.view()-&gt;forceLayout();
2082 #else
2083         m_frame.view()-&gt;forceLayout();
2084 #endif
2085 
2086         // Main resource delegates were already sent, so we skip the first response here.
2087         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2088             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2089             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2090             ResourceError error;
2091             unsigned long identifier;
2092             ResourceRequest request(response.url());
2093             requestFromDelegate(request, identifier, error);
2094             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2095             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2096             // Could be an issue with a giant local file.
2097             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2098         }
2099 
2100         // FIXME: Why only this frame and not parent frames?
2101         checkLoadCompleteForThisFrame();
2102     }
2103 }
2104 
2105 void FrameLoader::transitionToCommitted(CachedPage* cachedPage)
2106 {
2107     ASSERT(m_client.hasWebView());
2108     ASSERT(m_state == FrameStateProvisional);
2109 
2110     if (m_state != FrameStateProvisional)
2111         return;
2112 
2113     if (FrameView* view = m_frame.view()) {
2114         if (ScrollAnimator* scrollAnimator = view-&gt;existingScrollAnimator())
2115             scrollAnimator-&gt;cancelAnimations();
2116     }
2117 
2118     m_client.setCopiesOnScroll();
2119     history().updateForCommit();
2120 
2121     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2122     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2123     // or the two will stomp each other.
2124     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2125     if (m_documentLoader)
2126         closeURL();
2127     if (pdl != m_provisionalDocumentLoader)
2128         return;
2129 
2130     if (m_documentLoader)
2131         m_documentLoader-&gt;stopLoadingSubresources();
2132     if (m_documentLoader)
2133         m_documentLoader-&gt;stopLoadingPlugIns();
2134 
2135     // Setting our document loader invokes the unload event handler of our child frames.
2136     // Script can do anything. If the script initiates a new load, we need to abandon the
2137     // current load or the two will stomp each other.
2138     setDocumentLoader(m_provisionalDocumentLoader.get());
2139     if (pdl != m_provisionalDocumentLoader)
2140         return;
2141     setProvisionalDocumentLoader(nullptr);
2142 
2143     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2144     setState(FrameStateCommittedPage);
2145 
2146     // Handle adding the URL to the back/forward list.
2147     DocumentLoader* dl = m_documentLoader.get();
2148 
2149     switch (m_loadType) {
2150     case FrameLoadType::Forward:
2151     case FrameLoadType::Back:
2152     case FrameLoadType::IndexedBackForward:
2153         if (m_frame.page()) {
2154             // If the first load within a frame is a navigation within a back/forward list that was attached
2155             // without any of the items being loaded then we need to update the history in a similar manner as
2156             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2157             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2158                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2159 
2160             history().updateForBackForwardNavigation();
2161 
2162             // For cached pages, CachedFrame::restore will take care of firing the popstate event with the history item&#39;s state object
2163             if (history().currentItem() &amp;&amp; !cachedPage)
2164                 m_pendingStateObject = history().currentItem()-&gt;stateObject();
2165 
2166             // Create a document view for this document, or used the cached view.
2167             if (cachedPage) {
2168                 DocumentLoader* cachedDocumentLoader = cachedPage-&gt;documentLoader();
2169                 ASSERT(cachedDocumentLoader);
2170                 cachedDocumentLoader-&gt;attachToFrame(m_frame);
2171                 m_client.transitionToCommittedFromCachedFrame(cachedPage-&gt;cachedMainFrame());
2172             } else
2173                 m_client.transitionToCommittedForNewPage();
2174         }
2175         break;
2176 
2177     case FrameLoadType::Reload:
2178     case FrameLoadType::ReloadFromOrigin:
2179     case FrameLoadType::ReloadExpiredOnly:
2180     case FrameLoadType::Same:
2181     case FrameLoadType::Replace:
2182         history().updateForReload();
2183         m_client.transitionToCommittedForNewPage();
2184         break;
2185 
2186     case FrameLoadType::Standard:
2187         history().updateForStandardLoad();
2188         if (m_frame.view())
2189             m_frame.view()-&gt;setScrollbarsSuppressed(true);
2190         m_client.transitionToCommittedForNewPage();
2191         break;
2192 
2193     case FrameLoadType::RedirectWithLockedBackForwardList:
2194         history().updateForRedirectWithLockedBackForwardList();
2195         m_client.transitionToCommittedForNewPage();
2196         break;
2197     }
2198 
2199     m_documentLoader-&gt;writer().setMIMEType(dl-&gt;responseMIMEType());
2200 
2201     // Tell the client we&#39;ve committed this URL.
2202     ASSERT(m_frame.view());
2203 
2204     if (m_stateMachine.creatingInitialEmptyDocument())
2205         return;
2206 
2207     if (!m_stateMachine.committedFirstRealDocumentLoad())
2208         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
2209 }
2210 
2211 void FrameLoader::clientRedirectCancelledOrFinished(NewLoadInProgress newLoadInProgress)
2212 {
2213     // Note that -webView:didCancelClientRedirectForFrame: is called on the frame load delegate even if
2214     // the redirect succeeded.  We should either rename this API, or add a new method, like
2215     // -webView:didFinishClientRedirectForFrame:
2216     m_client.dispatchDidCancelClientRedirect();
2217 
2218     if (newLoadInProgress == NewLoadInProgress::No)
2219         m_quickRedirectComing = false;
2220 
2221     m_sentRedirectNotification = false;
2222 }
2223 
2224 void FrameLoader::clientRedirected(const URL&amp; url, double seconds, WallTime fireDate, LockBackForwardList lockBackForwardList)
2225 {
2226     m_client.dispatchWillPerformClientRedirect(url, seconds, fireDate, lockBackForwardList);
2227 
2228     // Remember that we sent a redirect notification to the frame load delegate so that when we commit
2229     // the next provisional load, we can send a corresponding -webView:didCancelClientRedirectForFrame:
2230     m_sentRedirectNotification = true;
2231 
2232     // If a &quot;quick&quot; redirect comes in, we set a special mode so we treat the next
2233     // load as part of the original navigation. If we don&#39;t have a document loader, we have
2234     // no &quot;original&quot; load on which to base a redirect, so we treat the redirect as a normal load.
2235     // Loads triggered by JavaScript form submissions never count as quick redirects.
2236     m_quickRedirectComing = (lockBackForwardList == LockBackForwardList::Yes || history().currentItemShouldBeReplaced()) &amp;&amp; m_documentLoader &amp;&amp; !m_isExecutingJavaScriptFormAction;
2237 }
2238 
2239 bool FrameLoader::shouldReload(const URL&amp; currentURL, const URL&amp; destinationURL)
2240 {
2241     // This function implements the rule: &quot;Don&#39;t reload if navigating by fragment within
2242     // the same URL, but do reload if going to a new URL or to the same URL with no
2243     // fragment identifier at all.&quot;
2244     if (!destinationURL.hasFragmentIdentifier())
2245         return true;
2246     return !equalIgnoringFragmentIdentifier(currentURL, destinationURL);
2247 }
2248 
2249 void FrameLoader::closeOldDataSources()
2250 {
2251     // FIXME: Is it important for this traversal to be postorder instead of preorder?
2252     // If so, add helpers for postorder traversal, and use them. If not, then lets not
2253     // use a recursive algorithm here.
2254     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
2255         child-&gt;loader().closeOldDataSources();
2256 
2257     if (m_documentLoader)
2258         m_client.dispatchWillClose();
2259 
2260     m_client.setMainFrameDocumentReady(false); // stop giving out the actual DOMDocument to observers
2261 }
2262 
2263 void FrameLoader::willRestoreFromCachedPage()
2264 {
2265     ASSERT(!m_frame.tree().parent());
2266     ASSERT(m_frame.page());
2267     ASSERT(m_frame.isMainFrame());
2268 
2269     m_frame.navigationScheduler().cancel();
2270 
2271     // We still have to close the previous part page.
2272     closeURL();
2273 
2274     // Delete old status bar messages (if it _was_ activated on last URL).
2275     if (m_frame.script().canExecuteScripts(NotAboutToExecuteScript)) {
2276         DOMWindow* window = m_frame.document()-&gt;domWindow();
2277         window-&gt;setStatus(String());
2278         window-&gt;setDefaultStatus(String());
2279     }
2280 }
2281 
2282 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2283 {
2284     m_isComplete = false;
2285 
2286     // Don&#39;t re-emit the load event.
2287     m_didCallImplicitClose = true;
2288 
2289     URL url = cachedFrame.url();
2290 
2291     // FIXME: I suspect this block of code doesn&#39;t do anything.
2292     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2293         url.setPath(&quot;/&quot;);
2294 
2295     started();
2296     Document* document = cachedFrame.document();
2297     ASSERT(document);
2298     ASSERT(document-&gt;domWindow());
2299 
2300     clear(document, true, true, cachedFrame.isMainFrame());
2301 
2302     document-&gt;setPageCacheState(Document::NotInPageCache);
2303 
2304     m_needsClear = true;
2305     m_isComplete = false;
2306     m_didCallImplicitClose = false;
2307     m_outgoingReferrer = url.string();
2308 
2309     FrameView* view = cachedFrame.view();
2310 
2311     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2312     ASSERT(view);
2313     view-&gt;setWasScrolledByUser(false);
2314 
2315     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2316     m_frame.setView(view);
2317 
2318     // Use the previous ScrollView&#39;s frame rect.
2319     if (previousViewFrameRect)
2320         view-&gt;setFrameRect(previousViewFrameRect.value());
2321 
2322     {
2323         // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,
2324         // including loading a child frame before its been re-attached to the frame tree as part of this restore.
2325         // For example, the HTML object element may load its content into a frame in a post style resolution callback.
2326         NavigationDisabler disableNavigation { &amp;m_frame };
2327         m_frame.setDocument(document);
2328     }
2329 
2330     document-&gt;domWindow()-&gt;resumeFromPageCache();
2331 
2332     updateFirstPartyForCookies();
2333 
2334     cachedFrame.restore();
2335 }
2336 
2337 bool FrameLoader::isHostedByObjectElement() const
2338 {
2339     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2340     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2341 }
2342 
2343 bool FrameLoader::isReplacing() const
2344 {
2345     return m_loadType == FrameLoadType::Replace;
2346 }
2347 
2348 void FrameLoader::setReplacing()
2349 {
2350     m_loadType = FrameLoadType::Replace;
2351 }
2352 
2353 bool FrameLoader::subframeIsLoading() const
2354 {
2355     // It&#39;s most likely that the last added frame is the last to load so we walk backwards.
2356     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling()) {
2357         FrameLoader&amp; childLoader = child-&gt;loader();
2358         DocumentLoader* documentLoader = childLoader.documentLoader();
2359         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2360             return true;
2361         documentLoader = childLoader.provisionalDocumentLoader();
2362         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2363             return true;
2364         documentLoader = childLoader.policyDocumentLoader();
2365         if (documentLoader)
2366             return true;
2367     }
2368     return false;
2369 }
2370 
2371 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2372 {
2373     m_client.willChangeTitle(loader);
2374 }
2375 
2376 FrameLoadType FrameLoader::loadType() const
2377 {
2378     return m_loadType;
2379 }
2380 
2381 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2382 {
2383     if (Page* page = m_frame.page()) {
2384         if (page-&gt;isResourceCachingDisabled())
2385             return CachePolicyReload;
2386     }
2387 
2388     if (m_isComplete)
2389         return CachePolicyVerify;
2390 
2391     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2392         return CachePolicyReload;
2393 
2394     if (Frame* parentFrame = m_frame.tree().parent()) {
2395         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2396         if (parentCachePolicy != CachePolicyVerify)
2397             return parentCachePolicy;
2398     }
2399 
2400     switch (m_loadType) {
2401     case FrameLoadType::Reload:
2402         return CachePolicyRevalidate;
2403     case FrameLoadType::Back:
2404     case FrameLoadType::Forward:
2405     case FrameLoadType::IndexedBackForward:
2406         return CachePolicyHistoryBuffer;
2407     case FrameLoadType::ReloadFromOrigin:
2408         ASSERT_NOT_REACHED(); // Already handled above.
2409         return CachePolicyReload;
2410     case FrameLoadType::RedirectWithLockedBackForwardList:
2411     case FrameLoadType::Replace:
2412     case FrameLoadType::Same:
2413     case FrameLoadType::Standard:
2414         return CachePolicyVerify;
2415     case FrameLoadType::ReloadExpiredOnly:
2416         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2417         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2418             return CachePolicyReload;
2419         return CachePolicyVerify;
2420     }
2421 
2422     RELEASE_ASSERT_NOT_REACHED();
2423     return CachePolicyVerify;
2424 }
2425 
2426 void FrameLoader::checkLoadCompleteForThisFrame()
2427 {
2428     ASSERT(m_client.hasWebView());
2429 
2430     // FIXME: Should this check be done in checkLoadComplete instead of here?
2431     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2432     if (m_frame.document()-&gt;isDelayingLoadEvent())
2433         return;
2434 
2435     switch (m_state) {
2436         case FrameStateProvisional: {
2437             // FIXME: Prohibiting any provisional load failures from being sent to clients
2438             // while handling provisional load failures is too heavy. For example, the current
2439             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2440             // load state being handled properly.
2441             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2442                 return;
2443 
2444             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2445             if (!pdl)
2446                 return;
2447 
2448             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2449             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2450             if (error.isNull())
2451                 return;
2452 
2453             // Check all children first.
2454             RefPtr&lt;HistoryItem&gt; item;
2455             if (Page* page = m_frame.page())
2456                 if (isBackForwardLoadType(loadType()))
2457                     // Reset the back forward list to the last committed history item at the top level.
2458                     item = page-&gt;mainFrame().loader().history().currentItem();
2459 
2460             // Only reset if we aren&#39;t already going to a new provisional item.
2461             bool shouldReset = !history().provisionalItem();
2462             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2463                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Failed provisional load (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());
2464                 m_provisionalLoadErrorBeingHandledURL = m_provisionalDocumentLoader-&gt;url();
2465                 m_client.dispatchDidFailProvisionalLoad(error);
2466 #if ENABLE(CONTENT_FILTERING)
2467                 if (auto contentFilter = pdl-&gt;contentFilter())
2468                     contentFilter-&gt;handleProvisionalLoadFailure(error);
2469 #endif
2470                 m_provisionalLoadErrorBeingHandledURL = { };
2471 
2472                 ASSERT(!pdl-&gt;isLoading());
2473 
2474                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2475                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2476                     setDocumentLoader(m_provisionalDocumentLoader.get());
2477 
2478                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2479                 // delegate callback.
2480                 if (pdl == m_provisionalDocumentLoader)
2481                     clearProvisionalLoad();
2482                 else if (activeDocumentLoader()) {
2483                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2484                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2485                         shouldReset = false;
2486                 }
2487             }
2488             if (shouldReset &amp;&amp; item)
2489                 if (Page* page = m_frame.page()) {
2490                     page-&gt;backForward().setCurrentItem(*item);
2491                 }
2492             return;
2493         }
2494 
2495         case FrameStateCommittedPage: {
2496             if (!m_documentLoader)
2497                 return;
2498             if (m_documentLoader-&gt;isLoadingInAPISense() &amp;&amp; !m_documentLoader-&gt;isStopping() &amp;&amp; !m_checkingLoadCompleteForDetachment)
2499                 return;
2500 
2501             setState(FrameStateComplete);
2502 
2503             // FIXME: Is this subsequent work important if we already navigated away?
2504             // Maybe there are bugs because of that, or extra work we can skip because
2505             // the new page is ready.
2506 
2507             m_client.forceLayoutForNonHTML();
2508 
2509             // If the user had a scroll point, scroll to it, overriding the anchor point if any.
2510             if (m_frame.page()) {
2511                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2512                     history().restoreScrollPositionAndViewState();
2513             }
2514 
2515             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2516                 return;
2517 
2518             m_progressTracker-&gt;progressCompleted();
2519             Page* page = m_frame.page();
2520             if (page) {
2521                 if (m_frame.isMainFrame()) {
2522                     tracePoint(MainResourceLoadDidEnd);
2523                     page-&gt;didFinishLoad();
2524                 }
2525             }
2526 
2527             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2528 
2529             AXObjectCache::AXLoadingEvent loadingEvent;
2530             if (!error.isNull()) {
2531                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load with error (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());
2532                 m_client.dispatchDidFailLoad(error);
2533                 loadingEvent = AXObjectCache::AXLoadingFailed;
2534             } else {
2535                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
2536 #if ENABLE(DATA_DETECTION)
2537                 auto* document = m_frame.document();
2538                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2539                     if (auto* documentElement = document-&gt;documentElement()) {
2540                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2541                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2542                         if (m_frame.isMainFrame())
2543                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2544                     }
2545                 }
2546 #endif
2547                 m_client.dispatchDidFinishLoad();
2548                 loadingEvent = AXObjectCache::AXLoadingFinished;
2549             }
2550 
2551             // Notify accessibility.
2552             if (auto* document = m_frame.document()) {
2553                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2554                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2555             }
2556 
2557             // The above calls to dispatchDidFinishLoad() might have detached the Frame
2558             // from its Page and also might have caused Page to be deleted.
2559             // Don&#39;t assume &#39;page&#39; is still available to use.
2560             if (m_frame.isMainFrame() &amp;&amp; m_frame.page()) {
2561                 ASSERT(&amp;m_frame.page()-&gt;mainFrame() == &amp;m_frame);
2562                 m_frame.page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageLoadedKey(), emptyString(), error.isNull() ? DiagnosticLoggingResultPass : DiagnosticLoggingResultFail, ShouldSample::Yes);
2563             }
2564 
2565             return;
2566         }
2567 
2568         case FrameStateComplete:
2569             m_loadType = FrameLoadType::Standard;
2570             frameLoadCompleted();
2571             return;
2572     }
2573 
2574     ASSERT_NOT_REACHED();
2575 }
2576 
2577 void FrameLoader::setOriginalURLForDownloadRequest(ResourceRequest&amp; request)
2578 {
2579     // FIXME: Rename firstPartyForCookies back to mainDocumentURL. It was a mistake to think that it was only used for cookies.
2580     // The originalURL is defined as the URL of the page where the download was initiated.
2581     URL originalURL;
2582     auto* initiator = m_frame.document();
2583     if (initiator) {
2584         originalURL = initiator-&gt;firstPartyForCookies();
2585         // If there is no main document URL, it means that this document is newly opened and just for download purpose.
2586         // In this case, we need to set the originalURL to this document&#39;s opener&#39;s main document URL.
2587         if (originalURL.isEmpty() &amp;&amp; opener() &amp;&amp; opener()-&gt;document()) {
2588             originalURL = opener()-&gt;document()-&gt;firstPartyForCookies();
2589             initiator = opener()-&gt;document();
2590         }
2591     }
2592     // If the originalURL is the same as the requested URL, we are processing a download
2593     // initiated directly without a page and do not need to specify the originalURL.
2594     if (originalURL == request.url())
2595         request.setFirstPartyForCookies(URL());
2596     else
2597         request.setFirstPartyForCookies(originalURL);
2598     addSameSiteInfoToRequestIfNeeded(request, initiator);
2599 }
2600 
2601 void FrameLoader::didReachLayoutMilestone(OptionSet&lt;LayoutMilestone&gt; milestones)
2602 {
2603     ASSERT(m_frame.isMainFrame());
2604 
2605     m_client.dispatchDidReachLayoutMilestone(milestones);
2606 }
2607 
2608 void FrameLoader::didFirstLayout()
2609 {
2610 #if PLATFORM(IOS_FAMILY)
2611     // Only send layout-related delegate callbacks synchronously for the main frame to
2612     // avoid reentering layout for the main frame while delivering a layout-related delegate
2613     // callback for a subframe.
2614     if (&amp;m_frame != &amp;m_frame.page()-&gt;mainFrame())
2615         return;
2616 #endif
2617     if (m_frame.page() &amp;&amp; isBackForwardLoadType(m_loadType))
2618         history().restoreScrollPositionAndViewState();
2619 
2620     if (m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2621         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2622 }
2623 
2624 void FrameLoader::frameLoadCompleted()
2625 {
2626     // Note: Can be called multiple times.
2627 
2628     m_client.frameLoadCompleted();
2629 
2630     history().updateForFrameLoadCompleted();
2631 
2632     // After a canceled provisional load, firstLayoutDone is false.
2633     // Reset it to true if we&#39;re displaying a page.
2634     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2635         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2636 }
2637 
2638 void FrameLoader::detachChildren()
2639 {
2640     // detachChildren() will fire the unload event in each subframe and the
2641     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2642     // this event is being fired in its subframes:
2643     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2644     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2645 
2646     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2647     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2648     // allow loading of subframes at this point.
2649     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2650 
2651     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2652     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2653     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2654         childrenToDetach.uncheckedAppend(*child);
2655     for (auto&amp; child : childrenToDetach)
2656         child-&gt;loader().detachFromParent();
2657 }
2658 
2659 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2660 {
2661     child.tree().detachFromParent();
2662 
2663     child.setView(nullptr);
2664     if (child.ownerElement() &amp;&amp; child.page())
2665         child.page()-&gt;decrementSubframeCount();
2666     child.willDetachPage();
2667     child.detachFromPage();
2668 
2669     m_frame.tree().removeChild(child);
2670 }
2671 
2672 // Called every time a resource is completely loaded or an error is received.
2673 void FrameLoader::checkLoadComplete()
2674 {
2675     m_shouldCallCheckLoadComplete = false;
2676 
2677     if (!m_frame.page())
2678         return;
2679 
2680     ASSERT(m_client.hasWebView());
2681 
2682     // FIXME: Always traversing the entire frame tree is a bit inefficient, but
2683     // is currently needed in order to null out the previous history item for all frames.
2684     Vector&lt;Ref&lt;Frame&gt;, 16&gt; frames;
2685     for (Frame* frame = &amp;m_frame.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2686         frames.append(*frame);
2687 
2688     // To process children before their parents, iterate the vector backwards.
2689     for (auto frame = frames.rbegin(); frame != frames.rend(); ++frame) {
2690         if ((*frame)-&gt;page())
2691             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2692     }
2693 }
2694 
2695 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2696 {
2697     if (!recurse)
2698         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2699 
2700     int count = 0;
2701     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2702         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2703     return count;
2704 }
2705 
2706 String FrameLoader::userAgent(const URL&amp; url) const
2707 {
2708     String userAgent;
2709 
2710     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader())
2711         userAgent = documentLoader-&gt;customUserAgent();
2712 
2713     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2714 
2715     if (!userAgent.isEmpty())
2716         return userAgent;
2717 
2718     return m_client.userAgent(url);
2719 }
2720 
2721 String FrameLoader::userAgentForJavaScript(const URL&amp; url) const
2722 {
2723     String userAgent;
2724 
2725     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2726         if (m_frame.settings().needsSiteSpecificQuirks())
2727             userAgent = documentLoader-&gt;customJavaScriptUserAgentAsSiteSpecificQuirks();
2728         if (userAgent.isEmpty())
2729             userAgent = documentLoader-&gt;customUserAgent();
2730     }
2731 
2732     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2733 
2734     if (!userAgent.isEmpty())
2735         return userAgent;
2736 
2737     return m_client.userAgent(url);
2738 }
2739 
2740 String FrameLoader::navigatorPlatform() const
2741 {
2742     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2743         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2744         if (!customNavigatorPlatform.isEmpty())
2745             return customNavigatorPlatform;
2746     }
2747     return String();
2748 }
2749 
2750 void FrameLoader::dispatchOnloadEvents()
2751 {
2752     m_client.dispatchDidDispatchOnloadEvents();
2753 
2754     if (documentLoader())
2755         documentLoader()-&gt;dispatchOnloadEvents();
2756 }
2757 
2758 void FrameLoader::frameDetached()
2759 {
2760     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2761     Ref&lt;Frame&gt; protectedFrame(m_frame);
2762 
2763     if (m_checkTimer.isActive()) {
2764         m_checkTimer.stop();
2765         checkCompletenessNow();
2766     }
2767 
2768     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2769         stopAllLoadersAndCheckCompleteness();
2770         m_frame.document()-&gt;stopActiveDOMObjects();
2771     }
2772 
2773     detachFromParent();
2774 }
2775 
2776 void FrameLoader::detachFromParent()
2777 {
2778     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2779     Ref&lt;Frame&gt; protect(m_frame);
2780 
2781     closeURL();
2782     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2783     detachChildren();
2784     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2785         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the page cache,
2786         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2787         // handlers might start a new subresource load in this frame.
2788         stopAllLoaders();
2789     }
2790 
2791     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2792 
2793     detachViewsAndDocumentLoader();
2794 
2795     m_progressTracker = nullptr;
2796 
2797     if (Frame* parent = m_frame.tree().parent()) {
2798         parent-&gt;loader().closeAndRemoveChild(m_frame);
2799         parent-&gt;loader().scheduleCheckCompleted();
2800         parent-&gt;loader().scheduleCheckLoadComplete();
2801     } else {
2802         m_frame.setView(nullptr);
2803         m_frame.willDetachPage();
2804         m_frame.detachFromPage();
2805     }
2806 }
2807 
2808 void FrameLoader::detachViewsAndDocumentLoader()
2809 {
2810     m_client.detachedFromParent2();
2811     setDocumentLoader(nullptr);
2812     m_client.detachedFromParent3();
2813 }
2814 
2815 void FrameLoader::addExtraFieldsToSubresourceRequest(ResourceRequest&amp; request)
2816 {
2817     addExtraFieldsToRequest(request, m_loadType, false);
2818 }
2819 
2820 void FrameLoader::addExtraFieldsToMainResourceRequest(ResourceRequest&amp; request)
2821 {
2822     // FIXME: Using m_loadType seems wrong for some callers.
2823     // If we are only preparing to load the main resource, that is previous load&#39;s load type!
2824     addExtraFieldsToRequest(request, m_loadType, true);
2825 
2826     // Upgrade-Insecure-Requests should only be added to main resource requests
2827     addHTTPUpgradeInsecureRequestsIfNeeded(request);
2828 }
2829 
2830 ResourceRequestCachePolicy FrameLoader::defaultRequestCachingPolicy(const ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2831 {
2832     if (m_overrideCachePolicyForTesting)
2833         return m_overrideCachePolicyForTesting.value();
2834 
2835     if (isMainResource) {
2836         if (isReload(loadType) || request.isConditional())
2837             return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2838 
2839         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2840     }
2841 
2842     if (request.isConditional())
2843         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2844 
2845     if (documentLoader()-&gt;isLoadingInAPISense()) {
2846         // If we inherit cache policy from a main resource, we use the DocumentLoader&#39;s
2847         // original request cache policy for two reasons:
2848         // 1. For POST requests, we mutate the cache policy for the main resource,
2849         //    but we do not want this to apply to subresources
2850         // 2. Delegates that modify the cache policy using willSendRequest: should
2851         //    not affect any other resources. Such changes need to be done
2852         //    per request.
2853         ResourceRequestCachePolicy mainDocumentOriginalCachePolicy = documentLoader()-&gt;originalRequest().cachePolicy();
2854         // Back-forward navigations try to load main resource from cache only to avoid re-submitting form data, and start over (with a warning dialog) if that fails.
2855         // This policy is set on initial request too, but should not be inherited.
2856         return (mainDocumentOriginalCachePolicy == ResourceRequestCachePolicy::ReturnCacheDataDontLoad) ? ResourceRequestCachePolicy::ReturnCacheDataElseLoad : mainDocumentOriginalCachePolicy;
2857     }
2858 
2859     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2860 }
2861 
2862 void FrameLoader::addExtraFieldsToRequest(ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2863 {
2864     // If the request came from a previous process due to process-swap-on-navigation then we should not modify the request.
2865     if (m_currentLoadContinuingState == LoadContinuingState::ContinuingWithRequest)
2866         return;
2867 
2868     // Don&#39;t set the cookie policy URL if it&#39;s already been set.
2869     // But make sure to set it on all requests regardless of protocol, as it has significance beyond the cookie policy (&lt;rdar://problem/6616664&gt;).
2870     bool isMainFrameMainResource = isMainResource &amp;&amp; m_frame.isMainFrame();
2871     if (request.firstPartyForCookies().isEmpty()) {
2872         if (isMainFrameMainResource)
2873             request.setFirstPartyForCookies(request.url());
2874         else if (Document* document = m_frame.document())
2875             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2876     }
2877 
2878     if (request.isSameSiteUnspecified()) {
2879         auto* initiator = m_frame.document();
2880         if (isMainResource) {
2881             auto* ownerFrame = m_frame.tree().parent();
2882             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2883                 ownerFrame = m_opener;
2884             if (ownerFrame)
2885                 initiator = ownerFrame-&gt;document();
2886             ASSERT(ownerFrame || m_frame.isMainFrame());
2887         }
2888         addSameSiteInfoToRequestIfNeeded(request, initiator);
2889     }
2890     request.setIsTopSite(isMainFrameMainResource);
2891 
2892     Page* page = frame().page();
2893     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2894 
2895     if (page &amp;&amp; page-&gt;isResourceCachingDisabled()) {
2896         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2897         loadType = FrameLoadType::ReloadFromOrigin;
2898     } else if (!hasSpecificCachePolicy)
2899         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2900 
2901     // The remaining modifications are only necessary for HTTP and HTTPS.
2902     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2903         return;
2904 
2905     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2906         if (loadType == FrameLoadType::Reload)
2907             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;max-age=0&quot;);
2908         else if (loadType == FrameLoadType::ReloadFromOrigin) {
2909             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-cache&quot;);
2910             request.setHTTPHeaderField(HTTPHeaderName::Pragma, &quot;no-cache&quot;);
2911         }
2912     }
2913 
2914     if (m_overrideResourceLoadPriorityForTesting)
2915         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2916 
2917     applyUserAgentIfNeeded(request);
2918 
2919     if (isMainResource)
2920         request.setHTTPAccept(defaultAcceptHeader);
2921 
2922     // Make sure we send the Origin header.
2923     addHTTPOriginIfNeeded(request, String());
2924 
2925     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2926     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2927         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2928         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2929     }
2930 }
2931 
2932 void FrameLoader::addHTTPOriginIfNeeded(ResourceRequest&amp; request, const String&amp; origin)
2933 {
2934     if (!request.httpOrigin().isEmpty())
2935         return;  // Request already has an Origin header.
2936 
2937     // Don&#39;t send an Origin header for GET or HEAD to avoid privacy issues.
2938     // For example, if an intranet page has a hyperlink to an external web
2939     // site, we don&#39;t want to include the Origin of the request because it
2940     // will leak the internal host name. Similar privacy concerns have lead
2941     // to the widespread suppression of the Referer header at the network
2942     // layer.
2943     if (request.httpMethod() == &quot;GET&quot; || request.httpMethod() == &quot;HEAD&quot;)
2944         return;
2945 
2946     // For non-GET and non-HEAD methods, always send an Origin header so the
2947     // server knows we support this feature.
2948 
2949     if (origin.isEmpty()) {
2950         // If we don&#39;t know what origin header to attach, we attach the value
2951         // for an empty origin.
2952         request.setHTTPOrigin(SecurityOrigin::createUnique()-&gt;toString());
2953         return;
2954     }
2955 
2956     request.setHTTPOrigin(origin);
2957 }
2958 
2959 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
2960 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
2961 // as same-site. This matches the behavior of Chrome and Firefox.
2962 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
2963 {
2964     if (!request.isSameSiteUnspecified())
2965         return;
2966     if (!initiator) {
2967         request.setIsSameSite(true);
2968         return;
2969     }
2970     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
2971         request.setIsSameSite(true);
2972         return;
2973     }
2974     request.setIsSameSite(registrableDomainsAreEqual(initiator-&gt;siteForCookies(), request.url()));
2975 }
2976 
2977 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
2978 {
2979     if (request.url().protocolIs(&quot;https&quot;)) {
2980         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
2981         return;
2982     }
2983 
2984     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
2985 }
2986 
2987 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
2988 {
2989     RELEASE_LOG_IF_ALLOWED(&quot;loadPostRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
2990 
2991     String frameName = request.frameName();
2992     LockHistory lockHistory = request.lockHistory();
2993     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
2994     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
2995 
2996     const ResourceRequest&amp; inRequest = request.resourceRequest();
2997     const URL&amp; url = inRequest.url();
2998     const String&amp; contentType = inRequest.httpContentType();
2999     String origin = inRequest.httpOrigin();
3000 
3001     ResourceRequest workingResourceRequest(url);
3002 
3003     if (!referrer.isEmpty())
3004         workingResourceRequest.setHTTPReferrer(referrer);
3005     workingResourceRequest.setHTTPOrigin(origin);
3006     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3007     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3008     workingResourceRequest.setHTTPContentType(contentType);
3009     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3010 
3011     if (Document* document = m_frame.document())
3012         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3013 
3014     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3015 
3016     if (!frameName.isEmpty()) {
3017         // The search for a target frame is done earlier in the case of form submission.
3018         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
3019             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, WTFMove(completionHandler));
3020             return;
3021         }
3022 
3023         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
3024             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3025             completionHandler();
3026         });
3027         return;
3028     }
3029 
3030     // must grab this now, since this load may stop the previous load and clear this flag
3031     bool isRedirect = m_quickRedirectComing;
3032     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {
3033         if (isRedirect) {
3034             m_quickRedirectComing = false;
3035             if (m_provisionalDocumentLoader)
3036                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3037             else if (m_policyDocumentLoader)
3038                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3039         }
3040         completionHandler();
3041     });
3042 }
3043 
3044 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3045 {
3046     ASSERT(m_frame.document());
3047     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3048 
3049     ResourceRequest initialRequest = request;
3050     initialRequest.setTimeoutInterval(10);
3051 
3052     if (!referrer.isEmpty())
3053         initialRequest.setHTTPReferrer(referrer);
3054     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3055 
3056     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3057 
3058     addExtraFieldsToSubresourceRequest(initialRequest);
3059 
3060     unsigned long identifier = 0;
3061     ResourceRequest newRequest(initialRequest);
3062     requestFromDelegate(newRequest, identifier, error);
3063 
3064 #if ENABLE(CONTENT_EXTENSIONS)
3065     if (error.isNull()) {
3066         if (auto* page = m_frame.page()) {
3067             if (m_documentLoader) {
3068                 auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(newRequest.url(), ResourceType::Raw, *m_documentLoader);
3069                 applyBlockedStatusToRequest(blockedStatus, page, newRequest);
3070                 if (blockedStatus.blockedLoad) {
3071                     newRequest = { };
3072                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3073                     response = { };
3074                     data = nullptr;
3075                 }
3076             }
3077         }
3078     }
3079 #endif
3080 
3081     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3082 
3083     if (error.isNull()) {
3084         ASSERT(!newRequest.isNull());
3085 
3086         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3087             Vector&lt;char&gt; buffer;
3088             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3089             data = SharedBuffer::create(WTFMove(buffer));
3090             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
3091             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response);
3092         }
3093     }
3094     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3095     return identifier;
3096 }
3097 
3098 const ResourceRequest&amp; FrameLoader::originalRequest() const
3099 {
3100     return activeDocumentLoader()-&gt;originalRequestCopy();
3101 }
3102 
3103 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3104 {
3105     // Retain because the stop may release the last reference to it.
3106     Ref&lt;Frame&gt; protect(m_frame);
3107 
3108     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3109     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3110     // that both data sources on the frame are either this or nil.
3111     stop();
3112     if (m_client.shouldFallBack(error))
3113         handleFallbackContent();
3114 
3115     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3116         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3117             m_submittedFormURL = URL();
3118 
3119         // We might have made a page cache item, but now we&#39;re bailing out due to an error before we ever
3120         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3121         // so that the existing view (that wenever got far enough to replace) can continue being used.
3122         history().invalidateCurrentItemCachedPage();
3123 
3124         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3125         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3126         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3127         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3128         // has ended.
3129         if (m_sentRedirectNotification)
3130             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3131     }
3132 
3133     checkCompleted();
3134     if (m_frame.page())
3135         checkLoadComplete();
3136 }
3137 
3138 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3139 {
3140     m_quickRedirectComing = false;
3141 
3142     if (!shouldContinue)
3143         return;
3144 
3145     // Calling stopLoading() on the provisional document loader can cause the underlying
3146     // frame to be deallocated.
3147     Ref&lt;Frame&gt; protectedFrame(m_frame);
3148 
3149     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3150     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3151         m_provisionalDocumentLoader-&gt;stopLoading();
3152         setProvisionalDocumentLoader(nullptr);
3153     }
3154 
3155     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3156     loadInSameDocument(request.url(), 0, !isRedirect);
3157 }
3158 
3159 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3160 {
3161     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3162     // currently displaying a frameset, or if the URL does not have a fragment.
3163     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3164 
3165     // FIXME: What about load types other than Standard and Reload?
3166 
3167     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3168         &amp;&amp; !isReload(loadType)
3169         &amp;&amp; loadType != FrameLoadType::Same
3170         &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache
3171         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3172         // We don&#39;t want to just scroll if a link from within a
3173         // frameset is trying to reload the frameset into _top.
3174         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3175 }
3176 
3177 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3178 {
3179     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3180 }
3181 
3182 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3183 {
3184     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3185 }
3186 
3187 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3188 {
3189     FrameView* view = m_frame.view();
3190     if (!view)
3191         return;
3192 
3193     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem()))
3194         view-&gt;scrollToFragment(url);
3195 }
3196 
3197 bool FrameLoader::shouldClose()
3198 {
3199     Page* page = m_frame.page();
3200     if (!page)
3201         return true;
3202     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3203         return true;
3204 
3205     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3206     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3207     targetFrames.append(m_frame);
3208     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3209         targetFrames.append(*child);
3210 
3211     bool shouldClose = false;
3212     {
3213         NavigationDisabler navigationDisabler(&amp;m_frame);
3214         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3215         size_t i;
3216 
3217         for (i = 0; i &lt; targetFrames.size(); i++) {
3218             if (!targetFrames[i]-&gt;tree().isDescendantOf(&amp;m_frame))
3219                 continue;
3220             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3221                 break;
3222         }
3223 
3224         if (i == targetFrames.size())
3225             shouldClose = true;
3226     }
3227 
3228     if (!shouldClose)
3229         m_submittedFormURL = URL();
3230 
3231     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3232     return shouldClose;
3233 }
3234 
3235 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3236 {
3237     if (!m_frame.document())
3238         return;
3239 
3240     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3241     ForbidPromptsScope forbidPrompts(m_frame.page());
3242     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3243 
3244     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3245         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3246         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3247             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3248         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3249             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3250                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3251                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache), m_frame.document());
3252             }
3253 
3254             // FIXME: update Page Visibility state here.
3255             // https://bugs.webkit.org/show_bug.cgi?id=116770
3256 
3257             if (m_frame.document()-&gt;pageCacheState() == Document::NotInPageCache) {
3258                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3259                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3260                 // while dispatching the event, so protect it to prevent writing the end
3261                 // time into freed memory.
3262                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3263                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3264                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3265                     auto&amp; timing = documentLoader-&gt;timing();
3266                     timing.markUnloadEventStart();
3267                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3268                     timing.markUnloadEventEnd();
3269                 } else
3270                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3271             }
3272         }
3273         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3274         m_wasUnloadEventEmitted = true;
3275     }
3276 
3277     // Dispatching the unload event could have made m_frame.document() null.
3278     if (!m_frame.document())
3279         return;
3280 
3281     if (m_frame.document()-&gt;pageCacheState() != Document::NotInPageCache)
3282         return;
3283 
3284     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3285     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3286         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3287 
3288     if (!keepEventListeners)
3289         m_frame.document()-&gt;removeAllEventListeners();
3290 }
3291 
3292 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3293 {
3294     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3295     if (document.isSandboxed(SandboxModals))
3296         return false;
3297 
3298     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3299     // Web pages can request we ask for confirmation before navigating by:
3300     // - Cancelling the BeforeUnloadEvent (modern way)
3301     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3302     // - Returning a non-empty string from the event handler, which is then set as returnValue
3303     //   attribute on the BeforeUnloadEvent.
3304     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3305 }
3306 
3307 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3308 {
3309     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3310     if (!domWindow)
3311         return true;
3312 
3313     RefPtr&lt;Document&gt; document = m_frame.document();
3314     if (!document-&gt;bodyOrFrameset())
3315         return true;
3316 
3317     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
3318     m_pageDismissalEventBeingDispatched = PageDismissalType::BeforeUnload;
3319 
3320     {
3321         ForbidPromptsScope forbidPrompts(m_frame.page());
3322         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3323     }
3324 
3325     m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3326 
3327     if (!beforeUnloadEvent-&gt;defaultPrevented())
3328         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3329 
3330     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3331         return true;
3332 
3333     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3334     // this frame is not allowed to cause another one to be shown.
3335     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3336         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3337         return true;
3338     }
3339 
3340     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3341     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3342     if (frameLoaderBeingNavigated != this) {
3343         Frame* parentFrame = m_frame.tree().parent();
3344         while (parentFrame) {
3345             Document* parentDocument = parentFrame-&gt;document();
3346             if (!parentDocument)
3347                 return true;
3348             if (!m_frame.document() || !m_frame.document()-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin())) {
3349                 document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show beforeunload confirmation dialog on behalf of a frame with different security origin. Protocols, domains, and ports must match.&quot;_s);
3350                 return true;
3351             }
3352 
3353             if (&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated)
3354                 break;
3355 
3356             parentFrame = parentFrame-&gt;tree().parent();
3357         }
3358 
3359         // The navigatingFrameLoader should always be in our ancestory.
3360         ASSERT(parentFrame);
3361         ASSERT(&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated);
3362     }
3363 
3364     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3365 
3366     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3367     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3368 }
3369 
3370 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3371 {
3372     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3373     // nil policyDataSource because loading the alternate page will have passed
3374     // through this method already, nested; otherwise, policyDataSource should still be set.
3375     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3376 
3377     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3378 
3379     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3380     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3381 
3382     if (!canContinue) {
3383         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;
3384             &quot;frame = %p, &quot;
3385             &quot;main = %d, &quot;
3386             &quot;allowNavigationToInvalidURL = %d, &quot;
3387             &quot;requestURLIsValid = %d, &quot;
3388             &quot;navigationPolicyDecision = %d)&quot;,
3389             &amp;m_frame,
3390             m_frame.isMainFrame(),
3391             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3392             request.url().isValid(),
3393             static_cast&lt;int&gt;(navigationPolicyDecision));
3394 
3395         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3396         // need to report that the client redirect was cancelled.
3397         // FIXME: The client should be told about ignored non-quick redirects, too.
3398         if (m_quickRedirectComing)
3399             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3400 
3401         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3402             stopAllLoaders();
3403             m_checkTimer.stop();
3404         }
3405 
3406         setPolicyDocumentLoader(nullptr);
3407         checkCompleted();
3408 
3409         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3410             checkLoadComplete();
3411 
3412         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3413         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3414         // we only do this when punting a navigation for the target frame or top-level frame.
3415         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3416             if (Page* page = m_frame.page()) {
3417                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3418                     page-&gt;backForward().setCurrentItem(*resetItem);
3419             }
3420         }
3421         return;
3422     }
3423 
3424     FrameLoadType type = policyChecker().loadType();
3425     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3426     stopAllLoaders(ShouldNotClearProvisionalItem);
3427 
3428     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3429     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3430     if (!m_frame.page()) {
3431         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3432         return;
3433     }
3434 
3435     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3436     m_loadType = type;
3437     setState(FrameStateProvisional);
3438 
3439     setPolicyDocumentLoader(nullptr);
3440 
3441     if (isBackForwardLoadType(type)) {
3442         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
3443         if (history().provisionalItem()-&gt;isInPageCache()) {
3444             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3445             loadProvisionalItemFromCachedPage();
3446             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3447             return;
3448         }
3449         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3450     }
3451 
3452     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3453         if (!m_provisionalDocumentLoader) {
3454             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy completionHandler: Frame load canceled #1 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3455             return;
3456         }
3457 
3458         prepareForLoadStart();
3459 
3460         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3461         // so we need to null check it again.
3462         if (!m_provisionalDocumentLoader) {
3463             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Frame load canceled #2 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3464             return;
3465         }
3466 
3467         DocumentLoader* activeDocLoader = activeDocumentLoader();
3468         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
3469             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Main frame already being loaded (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3470             return;
3471         }
3472 
3473         m_loadingFromCachedPage = false;
3474 
3475         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3476     };
3477 
3478     if (!formState) {
3479         completionHandler();
3480         return;
3481     }
3482 
3483     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3484 }
3485 
3486 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
3487     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)
3488 {
3489     if (shouldContinue != ShouldContinue::Yes)
3490         return;
3491 
3492     Ref&lt;Frame&gt; frame(m_frame);
3493     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3494     if (!mainFrame)
3495         return;
3496 
3497     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3498     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3499         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3500 
3501     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3502         mainFrame-&gt;tree().setName(frameName);
3503 
3504     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3505     mainFrame-&gt;loader().m_client.dispatchShow();
3506     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3507         mainFrame-&gt;loader().setOpener(frame.ptr());
3508         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3509     }
3510 
3511     NavigationAction newAction { *frame-&gt;document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, action.shouldOpenExternalURLsPolicy(), nullptr, action.downloadAttribute() };
3512     mainFrame-&gt;loader().loadWithNavigationAction(request, WTFMove(newAction), LockHistory::No, FrameLoadType::Standard, formState, allowNavigationToInvalidURL);
3513 }
3514 
3515 void FrameLoader::requestFromDelegate(ResourceRequest&amp; request, unsigned long&amp; identifier, ResourceError&amp; error)
3516 {
3517     ASSERT(!request.isNull());
3518 
3519     identifier = 0;
3520     if (Page* page = m_frame.page()) {
3521         identifier = page-&gt;progress().createUniqueIdentifier();
3522         notifier().assignIdentifierToInitialRequest(identifier, m_documentLoader.get(), request);
3523     }
3524 
3525     ResourceRequest newRequest(request);
3526     notifier().dispatchWillSendRequest(m_documentLoader.get(), identifier, newRequest, ResourceResponse());
3527 
3528     if (newRequest.isNull())
3529         error = cancelledError(request);
3530     else
3531         error = ResourceError();
3532 
3533     request = newRequest;
3534 }
3535 
3536 void FrameLoader::loadedResourceFromMemoryCache(CachedResource&amp; resource, ResourceRequest&amp; newRequest, ResourceError&amp; error)
3537 {
3538     Page* page = m_frame.page();
3539     if (!page)
3540         return;
3541 
3542     if (!resource.shouldSendResourceLoadCallbacks() || m_documentLoader-&gt;haveToldClientAboutLoad(resource.url()))
3543         return;
3544 
3545     // Main resource delegate messages are synthesized in MainResourceLoader, so we must not send them here.
3546     if (resource.type() == CachedResource::Type::MainResource)
3547         return;
3548 
3549     if (!page-&gt;areMemoryCacheClientCallsEnabled()) {
3550         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3551         m_documentLoader-&gt;recordMemoryCacheLoadForFutureClientNotification(resource.resourceRequest());
3552         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3553         return;
3554     }
3555 
3556     if (m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), newRequest, resource.response(), resource.encodedSize())) {
3557         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3558         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3559         return;
3560     }
3561 
3562     unsigned long identifier;
3563     requestFromDelegate(newRequest, identifier, error);
3564 
3565     ResourceResponse response = resource.response();
3566     response.setSource(ResourceResponse::Source::MemoryCache);
3567     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, newRequest, response, 0, resource.encodedSize(), 0, error);
3568 }
3569 
3570 void FrameLoader::applyUserAgentIfNeeded(ResourceRequest&amp; request)
3571 {
3572     if (!request.hasHTTPHeaderField(HTTPHeaderName::UserAgent)) {
3573         String userAgent = this-&gt;userAgent(request.url());
3574         ASSERT(!userAgent.isNull());
3575         request.setHTTPUserAgent(userAgent);
3576     }
3577 }
3578 
3579 bool FrameLoader::shouldInterruptLoadForXFrameOptions(const String&amp; content, const URL&amp; url, unsigned long requestIdentifier)
3580 {
3581     Frame&amp; topFrame = m_frame.tree().top();
3582     if (&amp;m_frame == &amp;topFrame)
3583         return false;
3584 
3585     XFrameOptionsDisposition disposition = parseXFrameOptionsHeader(content);
3586 
3587     switch (disposition) {
3588     case XFrameOptionsSameOrigin: {
3589         auto origin = SecurityOrigin::create(url);
3590         if (!origin-&gt;isSameSchemeHostPort(topFrame.document()-&gt;securityOrigin()))
3591             return true;
3592         for (Frame* frame = m_frame.tree().parent(); frame; frame = frame-&gt;tree().parent()) {
3593             if (!origin-&gt;isSameSchemeHostPort(frame-&gt;document()-&gt;securityOrigin()))
3594                 return true;
3595         }
3596         return false;
3597     }
3598     case XFrameOptionsDeny:
3599         return true;
3600     case XFrameOptionsAllowAll:
3601         return false;
3602     case XFrameOptionsConflict:
3603         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3604         return true;
3605     case XFrameOptionsInvalid:
3606         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3607         return false;
3608     case XFrameOptionsNone:
3609         return false;
3610     }
3611     ASSERT_NOT_REACHED();
3612     return false;
3613 }
3614 
3615 void FrameLoader::loadProvisionalItemFromCachedPage()
3616 {
3617     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
3618     LOG(PageCache, &quot;WebCorePageCache: Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());
3619 
3620     prepareForLoadStart();
3621 
3622     m_loadingFromCachedPage = true;
3623 
3624     // Should have timing data from previous time(s) the page was shown.
3625     ASSERT(provisionalLoader-&gt;timing().startTime());
3626     provisionalLoader-&gt;resetTiming();
3627     provisionalLoader-&gt;timing().markStartTime();
3628 
3629     provisionalLoader-&gt;setCommitted(true);
3630     commitProvisionalLoad();
3631 }
3632 
3633 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3634 {
3635     if (!history().currentItem())
3636         return false;
3637     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3638 }
3639 
3640 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3641 {
3642     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3643         return false;
3644     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3645     if (!ownerElement)
3646         return false;
3647     if (!ownerElement-&gt;hasTagName(iframeTag))
3648         return false;
3649     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3650 }
3651 
3652 Frame* FrameLoader::findFrameForNavigation(const AtomicString&amp; name, Document* activeDocument)
3653 {
3654     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3655     if (!activeDocument)
3656         activeDocument = m_frame.document();
3657 
3658     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3659 
3660     if (!activeDocument-&gt;canNavigate(frame))
3661         return nullptr;
3662 
3663     return frame;
3664 }
3665 
3666 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3667 {
3668     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3669 
3670     Ref&lt;Frame&gt; protect(m_frame);
3671 
3672     // Save user view state to the current history item here since we don&#39;t do a normal load.
3673     // FIXME: Does form state need to be saved here too?
3674     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3675     if (FrameView* view = m_frame.view())
3676         view-&gt;setWasScrolledByUser(false);
3677 
3678     history().setCurrentItem(item);
3679 
3680     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3681     loadInSameDocument(item.url(), item.stateObject(), false);
3682 
3683     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3684     history().restoreScrollPositionAndViewState();
3685 }
3686 
3687 // FIXME: This function should really be split into a couple pieces, some of
3688 // which should be methods of HistoryController and some of which should be
3689 // methods of FrameLoader.
3690 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3691 {
3692     RELEASE_LOG_IF_ALLOWED(&quot;loadDifferentDocumentItem: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3693 
3694     Ref&lt;Frame&gt; protectedFrame(m_frame);
3695 
3696     // History items should not be reported to the parent.
3697     m_shouldReportResourceTimingToParentFrame = false;
3698 
3699     // Remember this item so we can traverse any child items as child frames load
3700     history().setProvisionalItem(&amp;item);
3701 
3702     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3703 
3704     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3705 
3706     if (CachedPage* cachedPage = PageCache::singleton().get(item, m_frame.page())) {
3707         auto documentLoader = cachedPage-&gt;documentLoader();
3708         m_client.updateCachedDocumentLoader(*documentLoader);
3709 
3710         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3711         action.setTargetBackForwardItem(item);
3712         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3713 
3714         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3715         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3716         return;
3717     }
3718 
3719     URL itemURL = item.url();
3720     URL itemOriginalURL = item.originalURL();
3721     URL currentURL;
3722     if (documentLoader())
3723         currentURL = documentLoader()-&gt;url();
3724     RefPtr&lt;FormData&gt; formData = item.formData();
3725 
3726     ResourceRequest request(itemURL);
3727 
3728     if (!item.referrer().isNull())
3729         request.setHTTPReferrer(item.referrer());
3730 
3731     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3732     bool isFormSubmission = false;
3733     Event* event = nullptr;
3734 
3735     // If this was a repost that failed the page cache, we might try to repost the form.
3736     NavigationAction action;
3737     if (formData) {
3738         formData-&gt;generateFiles(m_frame.document());
3739 
3740         request.setHTTPMethod(&quot;POST&quot;);
3741         request.setHTTPBody(WTFMove(formData));
3742         request.setHTTPContentType(item.formContentType());
3743         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3744         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3745         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3746 
3747         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3748         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3749         addExtraFieldsToRequest(request, loadType, true);
3750 
3751         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3752         // We want to know this before talking to the policy delegate, since it affects whether
3753         // we show the DoYouReallyWantToRepost nag.
3754         //
3755         // This trick has a small bug (3123893) where we might find a cache hit, but then
3756         // have the item vanish when we try to use it in the ensuing nav.  This should be
3757         // extremely rare, but in that case the user will get an error on the navigation.
3758 
3759         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
3760             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataDontLoad);
3761             action = { *m_frame.document(), request, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3762         } else {
3763             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3764             action = { *m_frame.document(), request, initiatedByMainFrame, NavigationType::FormResubmitted, shouldOpenExternalURLsPolicy, event };
3765         }
3766     } else {
3767         switch (loadType) {
3768         case FrameLoadType::Reload:
3769         case FrameLoadType::ReloadFromOrigin:
3770         case FrameLoadType::ReloadExpiredOnly:
3771             request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
3772             break;
3773         case FrameLoadType::Back:
3774         case FrameLoadType::Forward:
3775         case FrameLoadType::IndexedBackForward: {
3776 #if PLATFORM(COCOA)
3777             bool allowStaleData = true;
3778 #else
3779             bool allowStaleData = !item.wasRestoredFromSession();
3780 #endif
3781             if (allowStaleData)
3782                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3783             item.setWasRestoredFromSession(false);
3784             break;
3785         }
3786         case FrameLoadType::Standard:
3787         case FrameLoadType::RedirectWithLockedBackForwardList:
3788             break;
3789         case FrameLoadType::Same:
3790         case FrameLoadType::Replace:
3791             ASSERT_NOT_REACHED();
3792         }
3793 
3794         addExtraFieldsToRequest(request, loadType, true);
3795 
3796         ResourceRequest requestForOriginalURL(request);
3797         requestForOriginalURL.setURL(itemOriginalURL);
3798         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3799     }
3800 
3801     action.setTargetBackForwardItem(item);
3802 
3803     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3804 }
3805 
3806 // Loads content into this frame, as specified by history item
3807 void FrameLoader::loadItem(HistoryItem&amp; item, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3808 {
3809     m_requestedHistoryItem = &amp;item;
3810     HistoryItem* currentItem = history().currentItem();
3811     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3812 
3813     if (sameDocumentNavigation)
3814         loadSameDocumentItem(item);
3815     else
3816         loadDifferentDocumentItem(item, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);
3817 }
3818 
3819 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3820 {
3821     ASSERT(m_state == FrameStateProvisional);
3822     ASSERT(!m_loadingFromCachedPage);
3823     ASSERT(history().provisionalItem());
3824     ASSERT(history().provisionalItem()-&gt;formData());
3825     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3826 
3827     FrameLoadType loadType = m_loadType;
3828     HistoryItem&amp; item = *history().provisionalItem();
3829 
3830     stopAllLoaders(ShouldNotClearProvisionalItem);
3831     loadDifferentDocumentItem(item, loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
3832 }
3833 
3834 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3835 {
3836     ResourceError error = m_client.cancelledError(request);
3837     error.setType(ResourceError::Type::Cancellation);
3838     return error;
3839 }
3840 
3841 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3842 {
3843     return m_client.blockedByContentBlockerError(request);
3844 }
3845 
3846 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3847 {
3848     ResourceError error = m_client.blockedError(request);
3849     error.setType(ResourceError::Type::Cancellation);
3850     return error;
3851 }
3852 
3853 #if ENABLE(CONTENT_FILTERING)
3854 ResourceError FrameLoader::blockedByContentFilterError(const ResourceRequest&amp; request) const
3855 {
3856     ResourceError error = m_client.blockedByContentFilterError(request);
3857     error.setType(ResourceError::Type::General);
3858     return error;
3859 }
3860 #endif
3861 
3862 #if PLATFORM(IOS_FAMILY)
3863 RetainPtr&lt;CFDictionaryRef&gt; FrameLoader::connectionProperties(ResourceLoader* loader)
3864 {
3865     return m_client.connectionProperties(loader-&gt;documentLoader(), loader-&gt;identifier());
3866 }
3867 #endif
3868 
3869 ReferrerPolicy FrameLoader::effectiveReferrerPolicy() const
3870 {
3871     if (auto* parentFrame = m_frame.tree().parent())
3872         return parentFrame-&gt;document()-&gt;referrerPolicy();
3873     if (m_opener)
3874         return m_opener-&gt;document()-&gt;referrerPolicy();
3875     return ReferrerPolicy::NoReferrerWhenDowngrade;
3876 }
3877 
3878 String FrameLoader::referrer() const
3879 {
3880     return m_documentLoader ? m_documentLoader-&gt;request().httpReferrer() : emptyString();
3881 }
3882 
3883 void FrameLoader::dispatchDidClearWindowObjectsInAllWorlds()
3884 {
3885     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript))
3886         return;
3887 
3888     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3889     ScriptController::getAllWorlds(worlds);
3890     for (auto&amp; world : worlds)
3891         dispatchDidClearWindowObjectInWorld(world);
3892 }
3893 
3894 void FrameLoader::dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp; world)
3895 {
3896     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript) || !m_frame.windowProxy().existingJSWindowProxy(world))
3897         return;
3898 
3899     m_client.dispatchDidClearWindowObjectInWorld(world);
3900 
3901     if (Page* page = m_frame.page())
3902         page-&gt;inspectorController().didClearWindowObjectInWorld(m_frame, world);
3903 
3904     InspectorInstrumentation::didClearWindowObjectInWorld(m_frame, world);
3905 }
3906 
3907 void FrameLoader::dispatchGlobalObjectAvailableInAllWorlds()
3908 {
3909     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3910     ScriptController::getAllWorlds(worlds);
3911     for (auto&amp; world : worlds)
3912         m_client.dispatchGlobalObjectAvailable(world);
3913 }
3914 
3915 SandboxFlags FrameLoader::effectiveSandboxFlags() const
3916 {
3917     SandboxFlags flags = m_forcedSandboxFlags;
3918     if (Frame* parentFrame = m_frame.tree().parent())
3919         flags |= parentFrame-&gt;document()-&gt;sandboxFlags();
3920     if (HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement())
3921         flags |= ownerElement-&gt;sandboxFlags();
3922     return flags;
3923 }
3924 
3925 void FrameLoader::didChangeTitle(DocumentLoader* loader)
3926 {
3927     m_client.didChangeTitle(loader);
3928 
3929     if (loader == m_documentLoader) {
3930         // Must update the entries in the back-forward list too.
3931         history().setCurrentItemTitle(loader-&gt;title());
3932         // This must go through the WebFrame because it has the right notion of the current b/f item.
3933         m_client.setTitle(loader-&gt;title(), loader-&gt;urlForHistory());
3934         m_client.setMainFrameDocumentReady(true); // update observers with new DOMDocument
3935         m_client.dispatchDidReceiveTitle(loader-&gt;title());
3936     }
3937 
3938 #if ENABLE(REMOTE_INSPECTOR)
3939     if (m_frame.isMainFrame())
3940         m_frame.page()-&gt;remoteInspectorInformationDidChange();
3941 #endif
3942 }
3943 
3944 void FrameLoader::dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent)
3945 {
3946     if (m_stateMachine.creatingInitialEmptyDocument())
3947         return;
3948 
3949     m_client.dispatchDidCommitLoad(initialHasInsecureContent);
3950 
3951     if (m_frame.isMainFrame()) {
3952         m_frame.page()-&gt;resetSeenPlugins();
3953         m_frame.page()-&gt;resetSeenMediaEngines();
3954     }
3955 
3956     InspectorInstrumentation::didCommitLoad(m_frame, m_documentLoader.get());
3957 
3958 #if ENABLE(REMOTE_INSPECTOR)
3959     if (m_frame.isMainFrame())
3960         m_frame.page()-&gt;remoteInspectorInformationDidChange();
3961 #endif
3962 }
3963 
3964 void FrameLoader::tellClientAboutPastMemoryCacheLoads()
3965 {
3966     ASSERT(m_frame.page());
3967     ASSERT(m_frame.page()-&gt;areMemoryCacheClientCallsEnabled());
3968 
3969     if (!m_documentLoader)
3970         return;
3971 
3972     Vector&lt;ResourceRequest&gt; pastLoads;
3973     m_documentLoader-&gt;takeMemoryCacheLoadsForClientNotification(pastLoads);
3974 
3975     for (auto&amp; pastLoad : pastLoads) {
3976         CachedResource* resource = MemoryCache::singleton().resourceForRequest(pastLoad, m_frame.page()-&gt;sessionID());
3977 
3978         // FIXME: These loads, loaded from cache, but now gone from the cache by the time
3979         // Page::setMemoryCacheClientCallsEnabled(true) is called, will not be seen by the client.
3980         // Consider if there&#39;s some efficient way of remembering enough to deliver this client call.
3981         // We have the URL, but not the rest of the response or the length.
3982         if (!resource)
3983             continue;
3984 
3985         ResourceRequest request(resource-&gt;url());
3986         m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), request, resource-&gt;response(), resource-&gt;encodedSize());
3987     }
3988 }
3989 
3990 NetworkingContext* FrameLoader::networkingContext() const
3991 {
3992     return m_networkingContext.get();
3993 }
3994 
3995 void FrameLoader::loadProgressingStatusChanged()
3996 {
3997     if (auto* view = m_frame.mainFrame().view())
3998         view-&gt;loadProgressingStatusChanged();
3999 }
4000 
4001 void FrameLoader::forcePageTransitionIfNeeded()
4002 {
4003     m_client.forcePageTransitionIfNeeded();
4004 }
4005 
4006 void FrameLoader::clearTestingOverrides()
4007 {
4008     m_overrideCachePolicyForTesting = WTF::nullopt;
4009     m_overrideResourceLoadPriorityForTesting = WTF::nullopt;
4010     m_isStrictRawResourceValidationPolicyDisabledForTesting = false;
4011 }
4012 
4013 bool FrameLoader::isAlwaysOnLoggingAllowed() const
4014 {
4015     return frame().isAlwaysOnLoggingAllowed();
4016 }
4017 
4018 bool FrameLoaderClient::hasHTMLView() const
4019 {
4020     return true;
4021 }
4022 
4023 RefPtr&lt;Frame&gt; createWindow(Frame&amp; openerFrame, Frame&amp; lookupFrame, FrameLoadRequest&amp;&amp; request, const WindowFeatures&amp; features, bool&amp; created)
4024 {
4025     ASSERT(!features.dialog || request.frameName().isEmpty());
4026 
4027     created = false;
4028 
4029     // FIXME: Provide line number information with respect to the opener&#39;s document.
4030     if (WTF::protocolIsJavaScript(request.resourceRequest().url()) &amp;&amp; !openerFrame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(openerFrame.document()-&gt;url(), { }))
4031         return nullptr;
4032 
4033     if (!request.frameName().isEmpty() &amp;&amp; !equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;)) {
4034         if (RefPtr&lt;Frame&gt; frame = lookupFrame.loader().findFrameForNavigation(request.frameName(), openerFrame.document())) {
4035             if (!equalIgnoringASCIICase(request.frameName(), &quot;_self&quot;)) {
4036                 if (Page* page = frame-&gt;page())
4037                     page-&gt;chrome().focus();
4038             }
4039             return frame;
4040         }
4041     }
4042 
4043     // Sandboxed frames cannot open new auxiliary browsing contexts.
4044     if (isDocumentSandboxed(openerFrame, SandboxPopups)) {
4045         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
4046         openerFrame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked opening &#39;&quot; + request.resourceRequest().url().stringCenterEllipsizedToLength() + &quot;&#39; in a new window because the request was made in a sandboxed frame whose &#39;allow-popups&#39; permission is not set.&quot;);
4047         return nullptr;
4048     }
4049 
4050     // FIXME: Setting the referrer should be the caller&#39;s responsibility.
4051     String referrer = SecurityPolicy::generateReferrerHeader(openerFrame.document()-&gt;referrerPolicy(), request.resourceRequest().url(), openerFrame.loader().outgoingReferrer());
4052     if (!referrer.isEmpty())
4053         request.resourceRequest().setHTTPReferrer(referrer);
4054     FrameLoader::addHTTPOriginIfNeeded(request.resourceRequest(), openerFrame.loader().outgoingOrigin());
4055     FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(request.resourceRequest());
4056     FrameLoader::addSameSiteInfoToRequestIfNeeded(request.resourceRequest(), openerFrame.document());
4057 
4058     Page* oldPage = openerFrame.page();
4059     if (!oldPage)
4060         return nullptr;
4061 
4062     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(openerFrame, request);
4063     NavigationAction action { request.requester(), request.resourceRequest(), request.initiatedByMainFrame(), NavigationType::Other, shouldOpenExternalURLsPolicy };
4064     Page* page = oldPage-&gt;chrome().createWindow(openerFrame, request, features, action);
4065     if (!page)
4066         return nullptr;
4067 
4068     RefPtr&lt;Frame&gt; frame = &amp;page-&gt;mainFrame();
4069 
4070     if (isDocumentSandboxed(openerFrame, SandboxPropagatesToAuxiliaryBrowsingContexts))
4071         frame-&gt;loader().forceSandboxFlags(openerFrame.document()-&gt;sandboxFlags());
4072 
4073     if (!equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;))
4074         frame-&gt;tree().setName(request.frameName());
4075 
4076     page-&gt;chrome().setToolbarsVisible(features.toolBarVisible || features.locationBarVisible);
4077 
4078     if (!frame-&gt;page())
4079         return nullptr;
4080     page-&gt;chrome().setStatusbarVisible(features.statusBarVisible);
4081 
4082     if (!frame-&gt;page())
4083         return nullptr;
4084     page-&gt;chrome().setScrollbarsVisible(features.scrollbarsVisible);
4085 
4086     if (!frame-&gt;page())
4087         return nullptr;
4088     page-&gt;chrome().setMenubarVisible(features.menuBarVisible);
4089 
4090     if (!frame-&gt;page())
4091         return nullptr;
4092     page-&gt;chrome().setResizable(features.resizable);
4093 
4094     // &#39;x&#39; and &#39;y&#39; specify the location of the window, while &#39;width&#39; and &#39;height&#39;
4095     // specify the size of the viewport. We can only resize the window, so adjust
4096     // for the difference between the window size and the viewport size.
4097 
4098     // FIXME: We should reconcile the initialization of viewport arguments between iOS and non-IOS.
4099 #if !PLATFORM(IOS_FAMILY)
4100     FloatSize viewportSize = page-&gt;chrome().pageRect().size();
4101     FloatRect windowRect = page-&gt;chrome().windowRect();
4102     if (features.x)
4103         windowRect.setX(*features.x);
4104     if (features.y)
4105         windowRect.setY(*features.y);
4106     // Zero width and height mean using default size, not minumum one.
4107     if (features.width &amp;&amp; *features.width)
4108         windowRect.setWidth(*features.width + (windowRect.width() - viewportSize.width()));
4109     if (features.height &amp;&amp; *features.height)
4110         windowRect.setHeight(*features.height + (windowRect.height() - viewportSize.height()));
4111 
4112     // Ensure non-NaN values, minimum size as well as being within valid screen area.
4113     FloatRect newWindowRect = DOMWindow::adjustWindowRect(*page, windowRect);
4114 
4115     if (!frame-&gt;page())
4116         return nullptr;
4117     page-&gt;chrome().setWindowRect(newWindowRect);
4118 #else
4119     // On iOS, width and height refer to the viewport dimensions.
4120     ViewportArguments arguments;
4121     // Zero width and height mean using default size, not minimum one.
4122     if (features.width &amp;&amp; *features.width)
4123         arguments.width = *features.width;
4124     if (features.height &amp;&amp; *features.height)
4125         arguments.height = *features.height;
4126     frame-&gt;setViewportArguments(arguments);
4127 #endif
4128 
4129     if (!frame-&gt;page())
4130         return nullptr;
4131     page-&gt;chrome().show();
4132 
4133     created = true;
4134     return frame;
4135 }
4136 
4137 bool FrameLoader::shouldSuppressTextInputFromEditing() const
4138 {
4139     return m_frame.settings().shouldSuppressTextInputFromEditingDuringProvisionalNavigation() &amp;&amp; m_state == FrameStateProvisional;
4140 }
4141 
4142 } // namespace WebCore
    </pre>
  </body>
</html>