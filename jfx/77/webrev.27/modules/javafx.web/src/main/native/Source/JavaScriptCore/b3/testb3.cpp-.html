<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*
    2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 
   28 #include &quot;AirCode.h&quot;
   29 #include &quot;AirInstInlines.h&quot;
   30 #include &quot;AirValidate.h&quot;
   31 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   32 #include &quot;B3ArgumentRegValue.h&quot;
   33 #include &quot;B3AtomicValue.h&quot;
   34 #include &quot;B3BasicBlockInlines.h&quot;
   35 #include &quot;B3BreakCriticalEdges.h&quot;
   36 #include &quot;B3CCallValue.h&quot;
   37 #include &quot;B3Compilation.h&quot;
   38 #include &quot;B3Compile.h&quot;
   39 #include &quot;B3ComputeDivisionMagic.h&quot;
   40 #include &quot;B3Const32Value.h&quot;
   41 #include &quot;B3ConstPtrValue.h&quot;
   42 #include &quot;B3Effects.h&quot;
   43 #include &quot;B3FenceValue.h&quot;
   44 #include &quot;B3FixSSA.h&quot;
   45 #include &quot;B3Generate.h&quot;
   46 #include &quot;B3LowerToAir.h&quot;
   47 #include &quot;B3MathExtras.h&quot;
   48 #include &quot;B3MemoryValue.h&quot;
   49 #include &quot;B3MoveConstants.h&quot;
   50 #include &quot;B3NativeTraits.h&quot;
   51 #include &quot;B3Procedure.h&quot;
   52 #include &quot;B3ReduceStrength.h&quot;
   53 #include &quot;B3SlotBaseValue.h&quot;
   54 #include &quot;B3StackSlot.h&quot;
   55 #include &quot;B3StackmapGenerationParams.h&quot;
   56 #include &quot;B3SwitchValue.h&quot;
   57 #include &quot;B3UpsilonValue.h&quot;
   58 #include &quot;B3UseCounts.h&quot;
   59 #include &quot;B3Validate.h&quot;
   60 #include &quot;B3ValueInlines.h&quot;
   61 #include &quot;B3VariableValue.h&quot;
   62 #include &quot;B3WasmAddressValue.h&quot;
   63 #include &quot;B3WasmBoundsCheckValue.h&quot;
   64 #include &quot;CCallHelpers.h&quot;
   65 #include &quot;FPRInfo.h&quot;
   66 #include &quot;GPRInfo.h&quot;
   67 #include &quot;InitializeThreading.h&quot;
   68 #include &quot;JSCInlines.h&quot;
   69 #include &quot;LinkBuffer.h&quot;
   70 #include &quot;PureNaN.h&quot;
   71 #include &lt;cmath&gt;
   72 #include &lt;string&gt;
   73 #include &lt;wtf/FastTLS.h&gt;
   74 #include &lt;wtf/IndexSet.h&gt;
   75 #include &lt;wtf/ListDump.h&gt;
   76 #include &lt;wtf/Lock.h&gt;
   77 #include &lt;wtf/NumberOfCores.h&gt;
   78 #include &lt;wtf/StdList.h&gt;
   79 #include &lt;wtf/Threading.h&gt;
   80 
   81 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
   82 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
   83 
   84 static void usage()
   85 {
   86     dataLog(&quot;Usage: testb3 [&lt;filter&gt;]\n&quot;);
   87     if (hiddenTruthBecauseNoReturnIsStupid())
   88         exit(1);
   89 }
   90 
   91 #if ENABLE(B3_JIT)
   92 
   93 using namespace JSC;
   94 using namespace JSC::B3;
   95 
   96 namespace {
   97 
   98 bool shouldBeVerbose()
   99 {
  100     return shouldDumpIR(B3Mode);
  101 }
  102 
  103 Lock crashLock;
  104 
  105 // Nothing fancy for now; we just use the existing WTF assertion machinery.
  106 #define CHECK(x) do {                                                   \
  107         if (!!(x))                                                      \
  108             break;                                                      \
  109         crashLock.lock();                                               \
  110         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #x); \
  111         CRASH();                                                        \
  112     } while (false)
  113 
  114 #define CHECK_EQ(x, y) do { \
  115         auto __x = (x); \
  116         auto __y = (y); \
  117         if (__x == __y) \
  118             break; \
  119         crashLock.lock(); \
  120         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, toCString(#x &quot; == &quot; #y, &quot; (&quot; #x &quot; == &quot;, __x, &quot;, &quot; #y &quot; == &quot;, __y, &quot;)&quot;).data()); \
  121         CRASH(); \
  122     } while (false)
  123 
  124 std::unique_ptr&lt;Compilation&gt; compileProc(Procedure&amp; procedure, unsigned optLevel = defaultOptLevel())
  125 {
  126     procedure.setOptLevel(optLevel);
  127     return std::make_unique&lt;Compilation&gt;(B3::compile(procedure));
  128 }
  129 
  130 template&lt;typename T, typename... Arguments&gt;
  131 T invoke(MacroAssemblerCodePtr&lt;B3CompilationPtrTag&gt; ptr, Arguments... arguments)
  132 {
  133     void* executableAddress = untagCFunctionPtr&lt;B3CompilationPtrTag&gt;(ptr.executableAddress());
  134     T (*function)(Arguments...) = bitwise_cast&lt;T(*)(Arguments...)&gt;(executableAddress);
  135     return function(arguments...);
  136 }
  137 
  138 template&lt;typename T, typename... Arguments&gt;
  139 T invoke(const Compilation&amp; code, Arguments... arguments)
  140 {
  141     return invoke&lt;T&gt;(code.code(), arguments...);
  142 }
  143 
  144 template&lt;typename T, typename... Arguments&gt;
  145 T compileAndRun(Procedure&amp; procedure, Arguments... arguments)
  146 {
  147     return invoke&lt;T&gt;(*compileProc(procedure), arguments...);
  148 }
  149 
  150 void lowerToAirForTesting(Procedure&amp; proc)
  151 {
  152     proc.resetReachability();
  153 
  154     if (shouldBeVerbose())
  155         dataLog(&quot;B3 before lowering:\n&quot;, proc);
  156 
  157     validate(proc);
  158     lowerToAir(proc);
  159 
  160     if (shouldBeVerbose())
  161         dataLog(&quot;Air after lowering:\n&quot;, proc.code());
  162 
  163     Air::validate(proc.code());
  164 }
  165 
  166 template&lt;typename Func&gt;
  167 void checkDisassembly(Compilation&amp; compilation, const Func&amp; func, const CString&amp; failText)
  168 {
  169     CString disassembly = compilation.disassembly();
  170     if (func(disassembly.data()))
  171         return;
  172 
  173     crashLock.lock();
  174     dataLog(&quot;Bad lowering!  &quot;, failText, &quot;\n&quot;);
  175     dataLog(disassembly);
  176     CRASH();
  177 }
  178 
  179 void checkUsesInstruction(Compilation&amp; compilation, const char* text)
  180 {
  181     checkDisassembly(
  182         compilation,
  183         [&amp;] (const char* disassembly) -&gt; bool {
  184             return strstr(disassembly, text);
  185         },
  186         toCString(&quot;Expected to find &quot;, text, &quot; but didnt!&quot;));
  187 }
  188 
  189 void checkDoesNotUseInstruction(Compilation&amp; compilation, const char* text)
  190 {
  191     checkDisassembly(
  192         compilation,
  193         [&amp;] (const char* disassembly) -&gt; bool {
  194             return !strstr(disassembly, text);
  195         },
  196         toCString(&quot;Did not expected to find &quot;, text, &quot; but it&#39;s there!&quot;));
  197 }
  198 
  199 template&lt;typename Type&gt;
  200 struct Operand {
  201     const char* name;
  202     Type value;
  203 };
  204 
  205 typedef Operand&lt;int64_t&gt; Int64Operand;
  206 typedef Operand&lt;int32_t&gt; Int32Operand;
  207 
  208 template&lt;typename FloatType&gt;
  209 void populateWithInterestingValues(Vector&lt;Operand&lt;FloatType&gt;&gt;&amp; operands)
  210 {
  211     operands.append({ &quot;0.&quot;, static_cast&lt;FloatType&gt;(0.) });
  212     operands.append({ &quot;-0.&quot;, static_cast&lt;FloatType&gt;(-0.) });
  213     operands.append({ &quot;0.4&quot;, static_cast&lt;FloatType&gt;(0.5) });
  214     operands.append({ &quot;-0.4&quot;, static_cast&lt;FloatType&gt;(-0.5) });
  215     operands.append({ &quot;0.5&quot;, static_cast&lt;FloatType&gt;(0.5) });
  216     operands.append({ &quot;-0.5&quot;, static_cast&lt;FloatType&gt;(-0.5) });
  217     operands.append({ &quot;0.6&quot;, static_cast&lt;FloatType&gt;(0.5) });
  218     operands.append({ &quot;-0.6&quot;, static_cast&lt;FloatType&gt;(-0.5) });
  219     operands.append({ &quot;1.&quot;, static_cast&lt;FloatType&gt;(1.) });
  220     operands.append({ &quot;-1.&quot;, static_cast&lt;FloatType&gt;(-1.) });
  221     operands.append({ &quot;2.&quot;, static_cast&lt;FloatType&gt;(2.) });
  222     operands.append({ &quot;-2.&quot;, static_cast&lt;FloatType&gt;(-2.) });
  223     operands.append({ &quot;M_PI&quot;, static_cast&lt;FloatType&gt;(M_PI) });
  224     operands.append({ &quot;-M_PI&quot;, static_cast&lt;FloatType&gt;(-M_PI) });
  225     operands.append({ &quot;min&quot;, std::numeric_limits&lt;FloatType&gt;::min() });
  226     operands.append({ &quot;max&quot;, std::numeric_limits&lt;FloatType&gt;::max() });
  227     operands.append({ &quot;lowest&quot;, std::numeric_limits&lt;FloatType&gt;::lowest() });
  228     operands.append({ &quot;epsilon&quot;, std::numeric_limits&lt;FloatType&gt;::epsilon() });
  229     operands.append({ &quot;infiniti&quot;, std::numeric_limits&lt;FloatType&gt;::infinity() });
  230     operands.append({ &quot;-infiniti&quot;, - std::numeric_limits&lt;FloatType&gt;::infinity() });
  231     operands.append({ &quot;PNaN&quot;, static_cast&lt;FloatType&gt;(PNaN) });
  232 }
  233 
  234 template&lt;typename FloatType&gt;
  235 Vector&lt;Operand&lt;FloatType&gt;&gt; floatingPointOperands()
  236 {
  237     Vector&lt;Operand&lt;FloatType&gt;&gt; operands;
  238     populateWithInterestingValues(operands);
  239     return operands;
  240 };
  241 
  242 static Vector&lt;Int64Operand&gt; int64Operands()
  243 {
  244     Vector&lt;Int64Operand&gt; operands;
  245     operands.append({ &quot;0&quot;, 0 });
  246     operands.append({ &quot;1&quot;, 1 });
  247     operands.append({ &quot;-1&quot;, -1 });
  248     operands.append({ &quot;42&quot;, 42 });
  249     operands.append({ &quot;-42&quot;, -42 });
  250     operands.append({ &quot;int64-max&quot;, std::numeric_limits&lt;int64_t&gt;::max() });
  251     operands.append({ &quot;int64-min&quot;, std::numeric_limits&lt;int64_t&gt;::min() });
  252     operands.append({ &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() });
  253     operands.append({ &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() });
  254     operands.append({ &quot;uint64-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::max()) });
  255     operands.append({ &quot;uint64-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::min()) });
  256     operands.append({ &quot;uint32-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) });
  257     operands.append({ &quot;uint32-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) });
  258 
  259     return operands;
  260 }
  261 
  262 static Vector&lt;Int32Operand&gt; int32Operands()
  263 {
  264     Vector&lt;Int32Operand&gt; operands({
  265         { &quot;0&quot;, 0 },
  266         { &quot;1&quot;, 1 },
  267         { &quot;-1&quot;, -1 },
  268         { &quot;42&quot;, 42 },
  269         { &quot;-42&quot;, -42 },
  270         { &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() },
  271         { &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() },
  272         { &quot;uint32-max&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) },
  273         { &quot;uint32-min&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) }
  274     });
  275     return operands;
  276 }
  277 
  278 void add32(CCallHelpers&amp; jit, GPRReg src1, GPRReg src2, GPRReg dest)
  279 {
  280     if (src2 == dest)
  281         jit.add32(src1, dest);
  282     else {
  283         jit.move(src1, dest);
  284         jit.add32(src2, dest);
  285     }
  286 }
  287 
  288 void test42()
  289 {
  290     Procedure proc;
  291     BasicBlock* root = proc.addBlock();
  292     Value* const42 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
  293     root-&gt;appendNewControlValue(proc, Return, Origin(), const42);
  294 
  295     CHECK(compileAndRun&lt;int&gt;(proc) == 42);
  296 }
  297 
  298 void testLoad42()
  299 {
  300     Procedure proc;
  301     BasicBlock* root = proc.addBlock();
  302     int x = 42;
  303     root-&gt;appendNewControlValue(
  304         proc, Return, Origin(),
  305         root-&gt;appendNew&lt;MemoryValue&gt;(
  306             proc, Load, Int32, Origin(),
  307             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x)));
  308 
  309     CHECK(compileAndRun&lt;int&gt;(proc) == 42);
  310 }
  311 
  312 void testLoadAcq42()
  313 {
  314     Procedure proc;
  315     BasicBlock* root = proc.addBlock();
  316     int x = 42;
  317     root-&gt;appendNewControlValue(
  318         proc, Return, Origin(),
  319         root-&gt;appendNew&lt;MemoryValue&gt;(
  320             proc, Load, Int32, Origin(),
  321             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x),
  322             0, HeapRange(42), HeapRange(42)));
  323 
  324     auto code = compileProc(proc);
  325     if (isARM64())
  326         checkUsesInstruction(*code, &quot;lda&quot;);
  327     CHECK(invoke&lt;int&gt;(*code) == 42);
  328 }
  329 
  330 void testLoadWithOffsetImpl(int32_t offset64, int32_t offset32)
  331 {
  332     {
  333         Procedure proc;
  334         BasicBlock* root = proc.addBlock();
  335         int64_t x = -42;
  336         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  337         root-&gt;appendNewControlValue(
  338             proc, Return, Origin(),
  339             root-&gt;appendNew&lt;MemoryValue&gt;(
  340                 proc, Load, Int64, Origin(),
  341                 base,
  342                 offset64));
  343 
  344         char* address = reinterpret_cast&lt;char*&gt;(&amp;x) - offset64;
  345         CHECK(compileAndRun&lt;int64_t&gt;(proc, address) == -42);
  346     }
  347     {
  348         Procedure proc;
  349         BasicBlock* root = proc.addBlock();
  350         int32_t x = -42;
  351         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  352         root-&gt;appendNewControlValue(
  353             proc, Return, Origin(),
  354             root-&gt;appendNew&lt;MemoryValue&gt;(
  355                 proc, Load, Int32, Origin(),
  356                 base,
  357                 offset32));
  358 
  359         char* address = reinterpret_cast&lt;char*&gt;(&amp;x) - offset32;
  360         CHECK(compileAndRun&lt;int32_t&gt;(proc, address) == -42);
  361     }
  362 }
  363 
  364 void testLoadOffsetImm9Max()
  365 {
  366     testLoadWithOffsetImpl(255, 255);
  367 }
  368 
  369 void testLoadOffsetImm9MaxPlusOne()
  370 {
  371     testLoadWithOffsetImpl(256, 256);
  372 }
  373 
  374 void testLoadOffsetImm9MaxPlusTwo()
  375 {
  376     testLoadWithOffsetImpl(257, 257);
  377 }
  378 
  379 void testLoadOffsetImm9Min()
  380 {
  381     testLoadWithOffsetImpl(-256, -256);
  382 }
  383 
  384 void testLoadOffsetImm9MinMinusOne()
  385 {
  386     testLoadWithOffsetImpl(-257, -257);
  387 }
  388 
  389 void testLoadOffsetScaledUnsignedImm12Max()
  390 {
  391     testLoadWithOffsetImpl(32760, 16380);
  392 }
  393 
  394 void testLoadOffsetScaledUnsignedOverImm12Max()
  395 {
  396     testLoadWithOffsetImpl(32760, 32760);
  397     testLoadWithOffsetImpl(32761, 16381);
  398     testLoadWithOffsetImpl(32768, 16384);
  399 }
  400 
  401 void testArg(int argument)
  402 {
  403     Procedure proc;
  404     BasicBlock* root = proc.addBlock();
  405     root-&gt;appendNewControlValue(
  406         proc, Return, Origin(),
  407         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  408 
  409     CHECK(compileAndRun&lt;int&gt;(proc, argument) == argument);
  410 }
  411 
  412 void testReturnConst64(int64_t value)
  413 {
  414     Procedure proc;
  415     BasicBlock* root = proc.addBlock();
  416     root-&gt;appendNewControlValue(
  417         proc, Return, Origin(),
  418         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value));
  419 
  420     CHECK(compileAndRun&lt;int64_t&gt;(proc) == value);
  421 }
  422 
  423 void testReturnVoid()
  424 {
  425     Procedure proc;
  426     BasicBlock* root = proc.addBlock();
  427     root-&gt;appendNewControlValue(proc, Return, Origin());
  428     compileAndRun&lt;void&gt;(proc);
  429 }
  430 
  431 void testAddArg(int a)
  432 {
  433     Procedure proc;
  434     BasicBlock* root = proc.addBlock();
  435     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  436     root-&gt;appendNewControlValue(
  437         proc, Return, Origin(),
  438         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), value, value));
  439 
  440     CHECK(compileAndRun&lt;int&gt;(proc, a) == a + a);
  441 }
  442 
  443 void testAddArgs(int a, int b)
  444 {
  445     Procedure proc;
  446     BasicBlock* root = proc.addBlock();
  447     root-&gt;appendNewControlValue(
  448         proc, Return, Origin(),
  449         root-&gt;appendNew&lt;Value&gt;(
  450             proc, Add, Origin(),
  451             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  452             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
  453 
  454     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a + b);
  455 }
  456 
  457 void testAddArgImm(int a, int b)
  458 {
  459     Procedure proc;
  460     BasicBlock* root = proc.addBlock();
  461     root-&gt;appendNewControlValue(
  462         proc, Return, Origin(),
  463         root-&gt;appendNew&lt;Value&gt;(
  464             proc, Add, Origin(),
  465             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  466             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
  467 
  468     CHECK(compileAndRun&lt;int&gt;(proc, a) == a + b);
  469 }
  470 
  471 void testAddImmArg(int a, int b)
  472 {
  473     Procedure proc;
  474     BasicBlock* root = proc.addBlock();
  475     root-&gt;appendNewControlValue(
  476         proc, Return, Origin(),
  477         root-&gt;appendNew&lt;Value&gt;(
  478             proc, Add, Origin(),
  479             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
  480             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
  481 
  482     CHECK(compileAndRun&lt;int&gt;(proc, b) == a + b);
  483 }
  484 
  485 void testAddArgMem(int64_t a, int64_t b)
  486 {
  487     Procedure proc;
  488     BasicBlock* root = proc.addBlock();
  489     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
  490     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
  491     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
  492         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  493         load);
  494     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
  495     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
  496 
  497     int64_t inputOutput = b;
  498     CHECK(!compileAndRun&lt;int64_t&gt;(proc, a, &amp;inputOutput));
  499     CHECK(inputOutput == a + b);
  500 }
  501 
  502 void testAddMemArg(int64_t a, int64_t b)
  503 {
  504     Procedure proc;
  505     BasicBlock* root = proc.addBlock();
  506     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  507     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
  508     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
  509         load,
  510         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
  511     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
  512 
  513     CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;a, b) == a + b);
  514 }
  515 
  516 void testAddImmMem(int64_t a, int64_t b)
  517 {
  518     Procedure proc;
  519     BasicBlock* root = proc.addBlock();
  520     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  521     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
  522     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
  523         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
  524         load);
  525     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
  526     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
  527 
  528     int64_t inputOutput = b;
  529     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
  530     CHECK(inputOutput == a + b);
  531 }
  532 
  533 void testAddArg32(int a)
  534 {
  535     Procedure proc;
  536     BasicBlock* root = proc.addBlock();
  537     Value* value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  538         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  539     root-&gt;appendNewControlValue(
  540         proc, Return, Origin(),
  541         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), value, value));
  542 
  543     CHECK(compileAndRun&lt;int&gt;(proc, a) == a + a);
  544 }
  545 
  546 void testAddArgs32(int a, int b)
  547 {
  548     Procedure proc;
  549     BasicBlock* root = proc.addBlock();
  550     root-&gt;appendNewControlValue(
  551         proc, Return, Origin(),
  552         root-&gt;appendNew&lt;Value&gt;(
  553             proc, Add, Origin(),
  554             root-&gt;appendNew&lt;Value&gt;(
  555                 proc, Trunc, Origin(),
  556                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
  557             root-&gt;appendNew&lt;Value&gt;(
  558                 proc, Trunc, Origin(),
  559                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
  560 
  561     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a + b);
  562 }
  563 
  564 void testAddArgMem32(int32_t a, int32_t b)
  565 {
  566     Procedure proc;
  567     BasicBlock* root = proc.addBlock();
  568     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
  569     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
  570     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  571         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  572     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), argument, load);
  573     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
  574     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
  575 
  576     int32_t inputOutput = b;
  577     CHECK(!compileAndRun&lt;int32_t&gt;(proc, a, &amp;inputOutput));
  578     CHECK(inputOutput == a + b);
  579 }
  580 
  581 void testAddMemArg32(int32_t a, int32_t b)
  582 {
  583     Procedure proc;
  584     BasicBlock* root = proc.addBlock();
  585     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  586     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
  587     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  588         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
  589     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), load, argument);
  590     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
  591 
  592     CHECK(compileAndRun&lt;int32_t&gt;(proc, &amp;a, b) == a + b);
  593 }
  594 
  595 void testAddImmMem32(int32_t a, int32_t b)
  596 {
  597     Procedure proc;
  598     BasicBlock* root = proc.addBlock();
  599     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  600     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
  601     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
  602         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
  603         load);
  604     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
  605     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
  606 
  607     int32_t inputOutput = b;
  608     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
  609     CHECK(inputOutput == a + b);
  610 }
  611 
  612 void testAddNeg1(int a, int b)
  613 {
  614     Procedure proc;
  615     BasicBlock* root = proc.addBlock();
  616     root-&gt;appendNewControlValue(
  617         proc, Return, Origin(),
  618         root-&gt;appendNew&lt;Value&gt;(
  619             proc, Add, Origin(),
  620             root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(),
  621                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
  622             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
  623 
  624     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == (- a) + b);
  625 }
  626 
  627 void testAddNeg2(int a, int b)
  628 {
  629     Procedure proc;
  630     BasicBlock* root = proc.addBlock();
  631     root-&gt;appendNewControlValue(
  632         proc, Return, Origin(),
  633         root-&gt;appendNew&lt;Value&gt;(
  634             proc, Add, Origin(),
  635             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  636             root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(),
  637                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
  638 
  639     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a + (- b));
  640 }
  641 
  642 void testAddArgZeroImmZDef()
  643 {
  644     Procedure proc;
  645     BasicBlock* root = proc.addBlock();
  646     Value* arg = root-&gt;appendNew&lt;Value&gt;(
  647         proc, Trunc, Origin(),
  648         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  649     Value* constZero = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0);
  650     root-&gt;appendNewControlValue(
  651         proc, Return, Origin(),
  652         root-&gt;appendNew&lt;Value&gt;(
  653             proc, Add, Origin(),
  654             arg,
  655             constZero));
  656 
  657     auto code = compileProc(proc, 0);
  658     CHECK(invoke&lt;int64_t&gt;(*code, 0x0123456789abcdef) == 0x89abcdef);
  659 }
  660 
  661 void testAddLoadTwice()
  662 {
  663     auto test = [&amp;] (unsigned optLevel) {
  664         Procedure proc;
  665         BasicBlock* root = proc.addBlock();
  666         int32_t value = 42;
  667         Value* load = root-&gt;appendNew&lt;MemoryValue&gt;(
  668             proc, Load, Int32, Origin(),
  669             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;value));
  670         root-&gt;appendNewControlValue(
  671             proc, Return, Origin(),
  672             root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), load, load));
  673 
  674         auto code = compileProc(proc, optLevel);
  675         CHECK(invoke&lt;int32_t&gt;(*code) == 42 * 2);
  676     };
  677 
  678     test(0);
  679     test(1);
  680 }
  681 
  682 void testAddArgDouble(double a)
  683 {
  684     Procedure proc;
  685     BasicBlock* root = proc.addBlock();
  686     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
  687     root-&gt;appendNewControlValue(
  688         proc, Return, Origin(),
  689         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), value, value));
  690 
  691     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a + a));
  692 }
  693 
  694 void testAddArgsDouble(double a, double b)
  695 {
  696     Procedure proc;
  697     BasicBlock* root = proc.addBlock();
  698     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
  699     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
  700     root-&gt;appendNewControlValue(
  701         proc, Return, Origin(),
  702         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), valueA, valueB));
  703 
  704     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), a + b));
  705 }
  706 
  707 void testAddArgImmDouble(double a, double b)
  708 {
  709     Procedure proc;
  710     BasicBlock* root = proc.addBlock();
  711     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
  712     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
  713     root-&gt;appendNewControlValue(
  714         proc, Return, Origin(),
  715         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), valueA, valueB));
  716 
  717     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a + b));
  718 }
  719 
  720 void testAddImmArgDouble(double a, double b)
  721 {
  722     Procedure proc;
  723     BasicBlock* root = proc.addBlock();
  724     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
  725     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
  726     root-&gt;appendNewControlValue(
  727         proc, Return, Origin(),
  728         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), valueA, valueB));
  729 
  730     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, b), a + b));
  731 }
  732 
  733 void testAddImmsDouble(double a, double b)
  734 {
  735     Procedure proc;
  736     BasicBlock* root = proc.addBlock();
  737     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
  738     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
  739     root-&gt;appendNewControlValue(
  740         proc, Return, Origin(),
  741         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), valueA, valueB));
  742 
  743     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), a + b));
  744 }
  745 
  746 void testAddArgFloat(float a)
  747 {
  748     Procedure proc;
  749     BasicBlock* root = proc.addBlock();
  750     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  751         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  752     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
  753     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), floatValue, floatValue);
  754     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
  755     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  756 
  757 
  758     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a + a)));
  759 }
  760 
  761 void testAddArgsFloat(float a, float b)
  762 {
  763     Procedure proc;
  764     BasicBlock* root = proc.addBlock();
  765     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  766         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  767     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  768         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
  769     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
  770     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
  771     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), floatValue1, floatValue2);
  772     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
  773     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  774 
  775     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a + b)));
  776 }
  777 
  778 void testAddFPRArgsFloat(float a, float b)
  779 {
  780     Procedure proc;
  781     BasicBlock* root = proc.addBlock();
  782     Value* argument1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  783         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
  784     Value* argument2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  785         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1));
  786     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), argument1, argument2);
  787     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
  788 
  789     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, a, b), a + b));
  790 }
  791 
  792 void testAddArgImmFloat(float a, float b)
  793 {
  794     Procedure proc;
  795     BasicBlock* root = proc.addBlock();
  796     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  797         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  798     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
  799     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
  800     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), floatValue, constValue);
  801     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
  802     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  803 
  804     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a + b)));
  805 }
  806 
  807 void testAddImmArgFloat(float a, float b)
  808 {
  809     Procedure proc;
  810     BasicBlock* root = proc.addBlock();
  811     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  812         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  813     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
  814     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
  815     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), constValue, floatValue);
  816     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
  817     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  818 
  819     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a + b)));
  820 }
  821 
  822 void testAddImmsFloat(float a, float b)
  823 {
  824     Procedure proc;
  825     BasicBlock* root = proc.addBlock();
  826     Value* constValue1 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
  827     Value* constValue2 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
  828     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), constValue1, constValue2);
  829     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
  830     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  831 
  832     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(a + b)));
  833 }
  834 
  835 void testAddArgFloatWithUselessDoubleConversion(float a)
  836 {
  837     Procedure proc;
  838     BasicBlock* root = proc.addBlock();
  839     Value* argumentInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  840         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  841     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentInt32);
  842     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
  843     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), asDouble, asDouble);
  844     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
  845     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
  846     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  847 
  848     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a + a)));
  849 }
  850 
  851 void testAddArgsFloatWithUselessDoubleConversion(float a, float b)
  852 {
  853     Procedure proc;
  854     BasicBlock* root = proc.addBlock();
  855     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  856         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  857     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  858         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
  859     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
  860     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
  861     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
  862     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
  863     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), asDouble1, asDouble2);
  864     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
  865     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
  866     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  867 
  868     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a + b)));
  869 }
  870 
  871 void testAddArgsFloatWithEffectfulDoubleConversion(float a, float b)
  872 {
  873     Procedure proc;
  874     BasicBlock* root = proc.addBlock();
  875     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  876         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  877     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
  878         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
  879     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
  880     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
  881     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
  882     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
  883     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), asDouble1, asDouble2);
  884     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
  885     Value* doubleAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
  886     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleAddress);
  887     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
  888     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
  889 
  890     double effect = 0;
  891     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), &amp;effect), bitwise_cast&lt;int32_t&gt;(a + b)));
  892     CHECK(isIdentical(effect, static_cast&lt;double&gt;(a) + static_cast&lt;double&gt;(b)));
  893 }
  894 
  895 void testMulArg(int a)
  896 {
  897     Procedure proc;
  898     BasicBlock* root = proc.addBlock();
  899     Value* value = root-&gt;appendNew&lt;Value&gt;(
  900         proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  901     root-&gt;appendNewControlValue(
  902         proc, Return, Origin(),
  903         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), value, value));
  904 
  905     CHECK(compileAndRun&lt;int&gt;(proc, a) == a * a);
  906 }
  907 
  908 void testMulArgStore(int a)
  909 {
  910     Procedure proc;
  911     BasicBlock* root = proc.addBlock();
  912 
  913     int mulSlot;
  914     int valueSlot;
  915 
  916     Value* value = root-&gt;appendNew&lt;Value&gt;(
  917         proc, Trunc, Origin(),
  918         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  919     Value* mul = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), value, value);
  920 
  921     root-&gt;appendNew&lt;MemoryValue&gt;(
  922         proc, Store, Origin(), value,
  923         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;valueSlot), 0);
  924     root-&gt;appendNew&lt;MemoryValue&gt;(
  925         proc, Store, Origin(), mul,
  926         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;mulSlot), 0);
  927 
  928     root-&gt;appendNewControlValue(
  929         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
  930 
  931     CHECK(!compileAndRun&lt;int&gt;(proc, a));
  932     CHECK(mulSlot == a * a);
  933     CHECK(valueSlot == a);
  934 }
  935 
  936 void testMulAddArg(int a)
  937 {
  938     Procedure proc;
  939     BasicBlock* root = proc.addBlock();
  940     Value* value = root-&gt;appendNew&lt;Value&gt;(
  941         proc, Trunc, Origin(),
  942         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
  943     root-&gt;appendNewControlValue(
  944         proc, Return, Origin(),
  945         root-&gt;appendNew&lt;Value&gt;(
  946             proc, Add, Origin(),
  947             root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), value, value),
  948             value));
  949 
  950     CHECK(compileAndRun&lt;int&gt;(proc, a) == a * a + a);
  951 }
  952 
  953 void testMulArgs(int a, int b)
  954 {
  955     Procedure proc;
  956     BasicBlock* root = proc.addBlock();
  957     root-&gt;appendNewControlValue(
  958         proc, Return, Origin(),
  959         root-&gt;appendNew&lt;Value&gt;(
  960             proc, Mul, Origin(),
  961             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  962             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
  963 
  964     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a * b);
  965 }
  966 
  967 void testMulArgImm(int64_t a, int64_t b)
  968 {
  969     Procedure proc;
  970     BasicBlock* root = proc.addBlock();
  971     root-&gt;appendNewControlValue(
  972         proc, Return, Origin(),
  973         root-&gt;appendNew&lt;Value&gt;(
  974             proc, Mul, Origin(),
  975             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
  976             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
  977 
  978     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == a * b);
  979 }
  980 
  981 void testMulImmArg(int a, int b)
  982 {
  983     Procedure proc;
  984     BasicBlock* root = proc.addBlock();
  985     root-&gt;appendNewControlValue(
  986         proc, Return, Origin(),
  987         root-&gt;appendNew&lt;Value&gt;(
  988             proc, Mul, Origin(),
  989             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
  990             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
  991 
  992     CHECK(compileAndRun&lt;int&gt;(proc, b) == a * b);
  993 }
  994 
  995 void testMulArgs32(int a, int b)
  996 {
  997     Procedure proc;
  998     BasicBlock* root = proc.addBlock();
  999     root-&gt;appendNewControlValue(
 1000         proc, Return, Origin(),
 1001         root-&gt;appendNew&lt;Value&gt;(
 1002             proc, Mul, Origin(),
 1003             root-&gt;appendNew&lt;Value&gt;(
 1004                 proc, Trunc, Origin(),
 1005                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 1006             root-&gt;appendNew&lt;Value&gt;(
 1007                 proc, Trunc, Origin(),
 1008                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 1009 
 1010     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a * b);
 1011 }
 1012 
 1013 void testMulLoadTwice()
 1014 {
 1015     auto test = [&amp;] (unsigned optLevel) {
 1016         Procedure proc;
 1017         BasicBlock* root = proc.addBlock();
 1018         int32_t value = 42;
 1019         Value* load = root-&gt;appendNew&lt;MemoryValue&gt;(
 1020             proc, Load, Int32, Origin(),
 1021             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;value));
 1022         root-&gt;appendNewControlValue(
 1023             proc, Return, Origin(),
 1024             root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), load, load));
 1025 
 1026         auto code = compileProc(proc, optLevel);
 1027         CHECK(invoke&lt;int32_t&gt;(*code) == 42 * 42);
 1028     };
 1029 
 1030     test(0);
 1031     test(1);
 1032     test(2);
 1033 }
 1034 
 1035 void testMulAddArgsLeft()
 1036 {
 1037     Procedure proc;
 1038     BasicBlock* root = proc.addBlock();
 1039 
 1040     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1041     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1042     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1043     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1044     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), multiplied, arg2);
 1045     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1046 
 1047     auto code = compileProc(proc);
 1048 
 1049     auto testValues = int64Operands();
 1050     for (auto a : testValues) {
 1051         for (auto b : testValues) {
 1052             for (auto c : testValues) {
 1053                 CHECK(invoke&lt;int64_t&gt;(*code, a.value, b.value, c.value) == a.value * b.value + c.value);
 1054             }
 1055         }
 1056     }
 1057 }
 1058 
 1059 void testMulAddArgsRight()
 1060 {
 1061     Procedure proc;
 1062     BasicBlock* root = proc.addBlock();
 1063 
 1064     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1065     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1066     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1067     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg1, arg2);
 1068     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg0, multiplied);
 1069     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1070 
 1071     auto code = compileProc(proc);
 1072 
 1073     auto testValues = int64Operands();
 1074     for (auto a : testValues) {
 1075         for (auto b : testValues) {
 1076             for (auto c : testValues) {
 1077                 CHECK(invoke&lt;int64_t&gt;(*code, a.value, b.value, c.value) == a.value + b.value * c.value);
 1078             }
 1079         }
 1080     }
 1081 }
 1082 
 1083 void testMulAddArgsLeft32()
 1084 {
 1085     Procedure proc;
 1086     BasicBlock* root = proc.addBlock();
 1087 
 1088     Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1089         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1090     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1091         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1092     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1093         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 1094     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1095     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), multiplied, arg2);
 1096     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1097 
 1098     auto code = compileProc(proc);
 1099 
 1100     auto testValues = int32Operands();
 1101     for (auto a : testValues) {
 1102         for (auto b : testValues) {
 1103             for (auto c : testValues) {
 1104                 CHECK(invoke&lt;int32_t&gt;(*code, a.value, b.value, c.value) == a.value * b.value + c.value);
 1105             }
 1106         }
 1107     }
 1108 }
 1109 
 1110 void testMulAddArgsRight32()
 1111 {
 1112     Procedure proc;
 1113     BasicBlock* root = proc.addBlock();
 1114 
 1115     Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1116         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1117     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1118         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1119     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1120         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 1121     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg1, arg2);
 1122     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg0, multiplied);
 1123     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1124 
 1125     auto code = compileProc(proc);
 1126 
 1127     auto testValues = int32Operands();
 1128     for (auto a : testValues) {
 1129         for (auto b : testValues) {
 1130             for (auto c : testValues) {
 1131                 CHECK(invoke&lt;int32_t&gt;(*code, a.value, b.value, c.value) == a.value + b.value * c.value);
 1132             }
 1133         }
 1134     }
 1135 }
 1136 
 1137 void testMulSubArgsLeft()
 1138 {
 1139     Procedure proc;
 1140     BasicBlock* root = proc.addBlock();
 1141 
 1142     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1143     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1144     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1145     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1146     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), multiplied, arg2);
 1147     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1148 
 1149     auto code = compileProc(proc);
 1150 
 1151     auto testValues = int64Operands();
 1152     for (auto a : testValues) {
 1153         for (auto b : testValues) {
 1154             for (auto c : testValues) {
 1155                 CHECK(invoke&lt;int64_t&gt;(*code, a.value, b.value, c.value) == a.value * b.value - c.value);
 1156             }
 1157         }
 1158     }
 1159 }
 1160 
 1161 void testMulSubArgsRight()
 1162 {
 1163     Procedure proc;
 1164     BasicBlock* root = proc.addBlock();
 1165 
 1166     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1167     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1168     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1169     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg1, arg2);
 1170     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), arg0, multiplied);
 1171     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1172 
 1173     auto code = compileProc(proc);
 1174 
 1175     auto testValues = int64Operands();
 1176     for (auto a : testValues) {
 1177         for (auto b : testValues) {
 1178             for (auto c : testValues) {
 1179                 CHECK(invoke&lt;int64_t&gt;(*code, a.value, b.value, c.value) == a.value - b.value * c.value);
 1180             }
 1181         }
 1182     }
 1183 }
 1184 
 1185 void testMulSubArgsLeft32()
 1186 {
 1187     Procedure proc;
 1188     BasicBlock* root = proc.addBlock();
 1189 
 1190     Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1191         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1192     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1193         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1194     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1195         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 1196     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1197     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), multiplied, arg2);
 1198     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1199 
 1200     auto code = compileProc(proc);
 1201 
 1202     auto testValues = int32Operands();
 1203     for (auto a : testValues) {
 1204         for (auto b : testValues) {
 1205             for (auto c : testValues) {
 1206                 CHECK(invoke&lt;int32_t&gt;(*code, a.value, b.value, c.value) == a.value * b.value - c.value);
 1207             }
 1208         }
 1209     }
 1210 }
 1211 
 1212 void testMulSubArgsRight32()
 1213 {
 1214     Procedure proc;
 1215     BasicBlock* root = proc.addBlock();
 1216 
 1217     Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1218         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1219     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1220         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1221     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1222         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 1223     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg1, arg2);
 1224     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), arg0, multiplied);
 1225     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1226 
 1227     auto code = compileProc(proc);
 1228 
 1229     auto testValues = int32Operands();
 1230     for (auto a : testValues) {
 1231         for (auto b : testValues) {
 1232             for (auto c : testValues) {
 1233                 CHECK(invoke&lt;int32_t&gt;(*code, a.value, b.value, c.value) == a.value - b.value * c.value);
 1234             }
 1235         }
 1236     }
 1237 }
 1238 
 1239 void testMulNegArgs()
 1240 {
 1241     Procedure proc;
 1242     BasicBlock* root = proc.addBlock();
 1243 
 1244     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1245     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1246     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1247     Value* zero = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0);
 1248     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), zero, multiplied);
 1249     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1250 
 1251     auto code = compileProc(proc);
 1252 
 1253     auto testValues = int64Operands();
 1254     for (auto a : testValues) {
 1255         for (auto b : testValues) {
 1256             CHECK(invoke&lt;int64_t&gt;(*code, a.value, b.value) == -(a.value * b.value));
 1257         }
 1258     }
 1259 }
 1260 
 1261 void testMulNegArgs32()
 1262 {
 1263     Procedure proc;
 1264     BasicBlock* root = proc.addBlock();
 1265 
 1266     Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1267         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1268     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1269         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1270     Value* multiplied = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), arg0, arg1);
 1271     Value* zero = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0);
 1272     Value* added = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), zero, multiplied);
 1273     root-&gt;appendNewControlValue(proc, Return, Origin(), added);
 1274 
 1275     auto code = compileProc(proc);
 1276 
 1277     auto testValues = int32Operands();
 1278     for (auto a : testValues) {
 1279         for (auto b : testValues) {
 1280             CHECK(invoke&lt;int32_t&gt;(*code, a.value, b.value) == -(a.value * b.value));
 1281         }
 1282     }
 1283 }
 1284 
 1285 void testMulArgDouble(double a)
 1286 {
 1287     Procedure proc;
 1288     BasicBlock* root = proc.addBlock();
 1289     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1290     root-&gt;appendNewControlValue(
 1291         proc, Return, Origin(),
 1292         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), value, value));
 1293 
 1294     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a * a));
 1295 }
 1296 
 1297 void testMulArgsDouble(double a, double b)
 1298 {
 1299     Procedure proc;
 1300     BasicBlock* root = proc.addBlock();
 1301     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1302     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 1303     root-&gt;appendNewControlValue(
 1304         proc, Return, Origin(),
 1305         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), valueA, valueB));
 1306 
 1307     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), a * b));
 1308 }
 1309 
 1310 void testMulArgImmDouble(double a, double b)
 1311 {
 1312     Procedure proc;
 1313     BasicBlock* root = proc.addBlock();
 1314     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1315     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1316     root-&gt;appendNewControlValue(
 1317         proc, Return, Origin(),
 1318         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), valueA, valueB));
 1319 
 1320     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a * b));
 1321 }
 1322 
 1323 void testMulImmArgDouble(double a, double b)
 1324 {
 1325     Procedure proc;
 1326     BasicBlock* root = proc.addBlock();
 1327     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1328     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1329     root-&gt;appendNewControlValue(
 1330         proc, Return, Origin(),
 1331         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), valueA, valueB));
 1332 
 1333     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, b), a * b));
 1334 }
 1335 
 1336 void testMulImmsDouble(double a, double b)
 1337 {
 1338     Procedure proc;
 1339     BasicBlock* root = proc.addBlock();
 1340     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1341     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1342     root-&gt;appendNewControlValue(
 1343         proc, Return, Origin(),
 1344         root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), valueA, valueB));
 1345 
 1346     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), a * b));
 1347 }
 1348 
 1349 void testMulArgFloat(float a)
 1350 {
 1351     Procedure proc;
 1352     BasicBlock* root = proc.addBlock();
 1353     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1354         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1355     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1356     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), floatValue, floatValue);
 1357     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1358     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1359 
 1360 
 1361     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a * a)));
 1362 }
 1363 
 1364 void testMulArgsFloat(float a, float b)
 1365 {
 1366     Procedure proc;
 1367     BasicBlock* root = proc.addBlock();
 1368     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1369         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1370     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1371         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1372     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1373     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1374     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), floatValue1, floatValue2);
 1375     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1376     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1377 
 1378     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a * b)));
 1379 }
 1380 
 1381 void testMulArgImmFloat(float a, float b)
 1382 {
 1383     Procedure proc;
 1384     BasicBlock* root = proc.addBlock();
 1385     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1386         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1387     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1388     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1389     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), floatValue, constValue);
 1390     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1391     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1392 
 1393     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a * b)));
 1394 }
 1395 
 1396 void testMulImmArgFloat(float a, float b)
 1397 {
 1398     Procedure proc;
 1399     BasicBlock* root = proc.addBlock();
 1400     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1401         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1402     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1403     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1404     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), constValue, floatValue);
 1405     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1406     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1407 
 1408     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a * b)));
 1409 }
 1410 
 1411 void testMulImmsFloat(float a, float b)
 1412 {
 1413     Procedure proc;
 1414     BasicBlock* root = proc.addBlock();
 1415     Value* constValue1 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1416     Value* constValue2 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1417     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), constValue1, constValue2);
 1418     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1419     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1420 
 1421     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(a * b)));
 1422 }
 1423 
 1424 void testMulArgFloatWithUselessDoubleConversion(float a)
 1425 {
 1426     Procedure proc;
 1427     BasicBlock* root = proc.addBlock();
 1428     Value* argumentInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1429         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1430     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentInt32);
 1431     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 1432     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), asDouble, asDouble);
 1433     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1434     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1435     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1436 
 1437     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a * a)));
 1438 }
 1439 
 1440 void testMulArgsFloatWithUselessDoubleConversion(float a, float b)
 1441 {
 1442     Procedure proc;
 1443     BasicBlock* root = proc.addBlock();
 1444     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1445         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1446     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1447         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1448     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1449     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1450     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 1451     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 1452     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), asDouble1, asDouble2);
 1453     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1454     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1455     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1456 
 1457     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a * b)));
 1458 }
 1459 
 1460 void testMulArgsFloatWithEffectfulDoubleConversion(float a, float b)
 1461 {
 1462     Procedure proc;
 1463     BasicBlock* root = proc.addBlock();
 1464     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1465         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1466     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1467         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1468     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1469     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1470     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 1471     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 1472     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), asDouble1, asDouble2);
 1473     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1474     Value* doubleMulress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1475     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleMulress);
 1476     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1477     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1478 
 1479     double effect = 0;
 1480     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), &amp;effect), bitwise_cast&lt;int32_t&gt;(a * b)));
 1481     CHECK(isIdentical(effect, static_cast&lt;double&gt;(a) * static_cast&lt;double&gt;(b)));
 1482 }
 1483 
 1484 void testDivArgDouble(double a)
 1485 {
 1486     Procedure proc;
 1487     BasicBlock* root = proc.addBlock();
 1488     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1489     root-&gt;appendNewControlValue(
 1490         proc, Return, Origin(),
 1491         root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), value, value));
 1492 
 1493     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a / a));
 1494 }
 1495 
 1496 void testDivArgsDouble(double a, double b)
 1497 {
 1498     Procedure proc;
 1499     BasicBlock* root = proc.addBlock();
 1500     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1501     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 1502     root-&gt;appendNewControlValue(
 1503         proc, Return, Origin(),
 1504         root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), valueA, valueB));
 1505 
 1506     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), a / b));
 1507 }
 1508 
 1509 void testDivArgImmDouble(double a, double b)
 1510 {
 1511     Procedure proc;
 1512     BasicBlock* root = proc.addBlock();
 1513     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1514     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1515     root-&gt;appendNewControlValue(
 1516         proc, Return, Origin(),
 1517         root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), valueA, valueB));
 1518 
 1519     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a / b));
 1520 }
 1521 
 1522 void testDivImmArgDouble(double a, double b)
 1523 {
 1524     Procedure proc;
 1525     BasicBlock* root = proc.addBlock();
 1526     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1527     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1528     root-&gt;appendNewControlValue(
 1529         proc, Return, Origin(),
 1530         root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), valueA, valueB));
 1531 
 1532     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, b), a / b));
 1533 }
 1534 
 1535 void testDivImmsDouble(double a, double b)
 1536 {
 1537     Procedure proc;
 1538     BasicBlock* root = proc.addBlock();
 1539     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1540     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1541     root-&gt;appendNewControlValue(
 1542         proc, Return, Origin(),
 1543         root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), valueA, valueB));
 1544 
 1545     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), a / b));
 1546 }
 1547 
 1548 void testDivArgFloat(float a)
 1549 {
 1550     Procedure proc;
 1551     BasicBlock* root = proc.addBlock();
 1552     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1553         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1554     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1555     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), floatValue, floatValue);
 1556     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1557     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1558 
 1559 
 1560     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a / a)));
 1561 }
 1562 
 1563 void testDivArgsFloat(float a, float b)
 1564 {
 1565     Procedure proc;
 1566     BasicBlock* root = proc.addBlock();
 1567     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1568         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1569     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1570         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1571     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1572     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1573     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), floatValue1, floatValue2);
 1574     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1575     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1576 
 1577     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a / b)));
 1578 }
 1579 
 1580 void testDivArgImmFloat(float a, float b)
 1581 {
 1582     Procedure proc;
 1583     BasicBlock* root = proc.addBlock();
 1584     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1585         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1586     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1587     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1588     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), floatValue, constValue);
 1589     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1590     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1591 
 1592     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a / b)));
 1593 }
 1594 
 1595 void testDivImmArgFloat(float a, float b)
 1596 {
 1597     Procedure proc;
 1598     BasicBlock* root = proc.addBlock();
 1599     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1600         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1601     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1602     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1603     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), constValue, floatValue);
 1604     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1605     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1606 
 1607     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a / b)));
 1608 }
 1609 
 1610 void testDivImmsFloat(float a, float b)
 1611 {
 1612     Procedure proc;
 1613     BasicBlock* root = proc.addBlock();
 1614     Value* constValue1 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1615     Value* constValue2 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1616     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), constValue1, constValue2);
 1617     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1618     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1619 
 1620     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(a / b)));
 1621 }
 1622 
 1623 void testModArgDouble(double a)
 1624 {
 1625     Procedure proc;
 1626     BasicBlock* root = proc.addBlock();
 1627     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1628     root-&gt;appendNewControlValue(
 1629         proc, Return, Origin(),
 1630         root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), value, value));
 1631 
 1632     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), fmod(a, a)));
 1633 }
 1634 
 1635 void testModArgsDouble(double a, double b)
 1636 {
 1637     Procedure proc;
 1638     BasicBlock* root = proc.addBlock();
 1639     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1640     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 1641     root-&gt;appendNewControlValue(
 1642         proc, Return, Origin(),
 1643         root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), valueA, valueB));
 1644 
 1645     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), fmod(a, b)));
 1646 }
 1647 
 1648 void testModArgImmDouble(double a, double b)
 1649 {
 1650     Procedure proc;
 1651     BasicBlock* root = proc.addBlock();
 1652     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1653     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1654     root-&gt;appendNewControlValue(
 1655         proc, Return, Origin(),
 1656         root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), valueA, valueB));
 1657 
 1658     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), fmod(a, b)));
 1659 }
 1660 
 1661 void testModImmArgDouble(double a, double b)
 1662 {
 1663     Procedure proc;
 1664     BasicBlock* root = proc.addBlock();
 1665     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1666     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 1667     root-&gt;appendNewControlValue(
 1668         proc, Return, Origin(),
 1669         root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), valueA, valueB));
 1670 
 1671     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, b), fmod(a, b)));
 1672 }
 1673 
 1674 void testModImmsDouble(double a, double b)
 1675 {
 1676     Procedure proc;
 1677     BasicBlock* root = proc.addBlock();
 1678     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 1679     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 1680     root-&gt;appendNewControlValue(
 1681         proc, Return, Origin(),
 1682         root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), valueA, valueB));
 1683 
 1684     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), fmod(a, b)));
 1685 }
 1686 
 1687 void testModArgFloat(float a)
 1688 {
 1689     Procedure proc;
 1690     BasicBlock* root = proc.addBlock();
 1691     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1692         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1693     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1694     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), floatValue, floatValue);
 1695     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1696     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1697 
 1698 
 1699     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fmod(a, a)))));
 1700 }
 1701 
 1702 void testModArgsFloat(float a, float b)
 1703 {
 1704     Procedure proc;
 1705     BasicBlock* root = proc.addBlock();
 1706     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1707         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1708     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1709         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1710     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1711     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1712     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), floatValue1, floatValue2);
 1713     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1714     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1715 
 1716     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fmod(a, b)))));
 1717 }
 1718 
 1719 void testModArgImmFloat(float a, float b)
 1720 {
 1721     Procedure proc;
 1722     BasicBlock* root = proc.addBlock();
 1723     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1724         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1725     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1726     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1727     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), floatValue, constValue);
 1728     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1729     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1730 
 1731     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fmod(a, b)))));
 1732 }
 1733 
 1734 void testModImmArgFloat(float a, float b)
 1735 {
 1736     Procedure proc;
 1737     BasicBlock* root = proc.addBlock();
 1738     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1739         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1740     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 1741     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1742     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), constValue, floatValue);
 1743     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1744     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1745 
 1746     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fmod(a, b)))));
 1747 }
 1748 
 1749 void testModImmsFloat(float a, float b)
 1750 {
 1751     Procedure proc;
 1752     BasicBlock* root = proc.addBlock();
 1753     Value* constValue1 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 1754     Value* constValue2 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 1755     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), constValue1, constValue2);
 1756     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 1757     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1758 
 1759     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fmod(a, b)))));
 1760 }
 1761 
 1762 void testDivArgFloatWithUselessDoubleConversion(float a)
 1763 {
 1764     Procedure proc;
 1765     BasicBlock* root = proc.addBlock();
 1766     Value* argumentInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1767         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1768     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentInt32);
 1769     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 1770     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), asDouble, asDouble);
 1771     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1772     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1773     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1774 
 1775     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a / a)));
 1776 }
 1777 
 1778 void testDivArgsFloatWithUselessDoubleConversion(float a, float b)
 1779 {
 1780     Procedure proc;
 1781     BasicBlock* root = proc.addBlock();
 1782     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1783         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1784     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1785         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1786     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1787     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1788     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 1789     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 1790     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), asDouble1, asDouble2);
 1791     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1792     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1793     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1794 
 1795     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a / b)));
 1796 }
 1797 
 1798 void testDivArgsFloatWithEffectfulDoubleConversion(float a, float b)
 1799 {
 1800     Procedure proc;
 1801     BasicBlock* root = proc.addBlock();
 1802     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1803         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1804     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1805         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1806     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 1807     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 1808     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 1809     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 1810     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Div, Origin(), asDouble1, asDouble2);
 1811     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 1812     Value* doubleDivress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 1813     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleDivress);
 1814     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 1815     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 1816 
 1817     double effect = 0;
 1818     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), &amp;effect), bitwise_cast&lt;int32_t&gt;(a / b)));
 1819     CHECK(isIdentical(effect, static_cast&lt;double&gt;(a) / static_cast&lt;double&gt;(b)));
 1820 }
 1821 
 1822 void testUDivArgsInt32(uint32_t a, uint32_t b)
 1823 {
 1824     // UDiv with denominator == 0 is invalid.
 1825     if (!b)
 1826         return;
 1827 
 1828     Procedure proc;
 1829     BasicBlock* root = proc.addBlock();
 1830     Value* argument1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1831         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1832     Value* argument2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1833         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1834     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, UDiv, Origin(), argument1, argument2);
 1835     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 1836 
 1837     CHECK_EQ(compileAndRun&lt;uint32_t&gt;(proc, a, b), a / b);
 1838 }
 1839 
 1840 void testUDivArgsInt64(uint64_t a, uint64_t b)
 1841 {
 1842     // UDiv with denominator == 0 is invalid.
 1843     if (!b)
 1844         return;
 1845 
 1846     Procedure proc;
 1847     BasicBlock* root = proc.addBlock();
 1848     Value* argument1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1849     Value* argument2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1850     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, UDiv, Origin(), argument1, argument2);
 1851     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 1852 
 1853     CHECK_EQ(compileAndRun&lt;uint64_t&gt;(proc, a, b), a / b);
 1854 }
 1855 
 1856 void testUModArgsInt32(uint32_t a, uint32_t b)
 1857 {
 1858     // UMod with denominator == 0 is invalid.
 1859     if (!b)
 1860         return;
 1861 
 1862     Procedure proc;
 1863     BasicBlock* root = proc.addBlock();
 1864     Value* argument1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1865         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 1866     Value* argument2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 1867         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 1868     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, UMod, Origin(), argument1, argument2);
 1869     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 1870 
 1871     CHECK_EQ(compileAndRun&lt;uint32_t&gt;(proc, a, b), a % b);
 1872 }
 1873 
 1874 void testUModArgsInt64(uint64_t a, uint64_t b)
 1875 {
 1876     // UMod with denominator == 0 is invalid.
 1877     if (!b)
 1878         return;
 1879 
 1880     Procedure proc;
 1881     BasicBlock* root = proc.addBlock();
 1882     Value* argument1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1883     Value* argument2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1884     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, UMod, Origin(), argument1, argument2);
 1885     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
 1886 
 1887     CHECK_EQ(compileAndRun&lt;uint64_t&gt;(proc, a, b), a % b);
 1888 }
 1889 
 1890 void testSubArg(int a)
 1891 {
 1892     Procedure proc;
 1893     BasicBlock* root = proc.addBlock();
 1894     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1895     root-&gt;appendNewControlValue(
 1896         proc, Return, Origin(),
 1897         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), value, value));
 1898 
 1899     CHECK(!compileAndRun&lt;int&gt;(proc, a));
 1900 }
 1901 
 1902 void testSubArgs(int a, int b)
 1903 {
 1904     Procedure proc;
 1905     BasicBlock* root = proc.addBlock();
 1906     root-&gt;appendNewControlValue(
 1907         proc, Return, Origin(),
 1908         root-&gt;appendNew&lt;Value&gt;(
 1909             proc, Sub, Origin(),
 1910             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 1911             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 1912 
 1913     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a - b);
 1914 }
 1915 
 1916 void testSubArgImm(int64_t a, int64_t b)
 1917 {
 1918     Procedure proc;
 1919     BasicBlock* root = proc.addBlock();
 1920     root-&gt;appendNewControlValue(
 1921         proc, Return, Origin(),
 1922         root-&gt;appendNew&lt;Value&gt;(
 1923             proc, Sub, Origin(),
 1924             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 1925             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 1926 
 1927     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == a - b);
 1928 }
 1929 
 1930 void testSubNeg(int a, int b)
 1931 {
 1932     Procedure proc;
 1933     BasicBlock* root = proc.addBlock();
 1934     root-&gt;appendNewControlValue(
 1935         proc, Return, Origin(),
 1936         root-&gt;appendNew&lt;Value&gt;(
 1937             proc, Sub, Origin(),
 1938             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 1939             root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(),
 1940                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 1941 
 1942     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a - (- b));
 1943 }
 1944 
 1945 void testNegSub(int a, int b)
 1946 {
 1947     Procedure proc;
 1948     BasicBlock* root = proc.addBlock();
 1949     root-&gt;appendNewControlValue(
 1950         proc, Return, Origin(),
 1951         root-&gt;appendNew&lt;Value&gt;(
 1952             proc, Neg, Origin(),
 1953             root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 1954                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 1955                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 1956 
 1957     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == -(a - b));
 1958 }
 1959 
 1960 void testNegValueSubOne(int a)
 1961 {
 1962     Procedure proc;
 1963     BasicBlock* root = proc.addBlock();
 1964     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 1965     Value* negArgument = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 1966         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0),
 1967         argument);
 1968     Value* negArgumentMinusOne = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 1969         negArgument,
 1970         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 1));
 1971     root-&gt;appendNewControlValue(proc, Return, Origin(), negArgumentMinusOne);
 1972     CHECK(compileAndRun&lt;int&gt;(proc, a) == -a - 1);
 1973 }
 1974 
 1975 void testSubImmArg(int a, int b)
 1976 {
 1977     Procedure proc;
 1978     BasicBlock* root = proc.addBlock();
 1979     root-&gt;appendNewControlValue(
 1980         proc, Return, Origin(),
 1981         root-&gt;appendNew&lt;Value&gt;(
 1982             proc, Sub, Origin(),
 1983             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 1984             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 1985 
 1986     CHECK(compileAndRun&lt;int&gt;(proc, b) == a - b);
 1987 }
 1988 
 1989 void testSubArgMem(int64_t a, int64_t b)
 1990 {
 1991     Procedure proc;
 1992     BasicBlock* root = proc.addBlock();
 1993     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 1994     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 1995     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 1996         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 1997         load);
 1998     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 1999 
 2000     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, &amp;b) == a - b);
 2001 }
 2002 
 2003 void testSubMemArg(int64_t a, int64_t b)
 2004 {
 2005     Procedure proc;
 2006     BasicBlock* root = proc.addBlock();
 2007     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2008     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 2009     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2010         load,
 2011         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 2012     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2013     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2014 
 2015     int64_t inputOutput = a;
 2016     CHECK(!compileAndRun&lt;int64_t&gt;(proc, &amp;inputOutput, b));
 2017     CHECK(inputOutput == a - b);
 2018 }
 2019 
 2020 void testSubImmMem(int64_t a, int64_t b)
 2021 {
 2022     Procedure proc;
 2023     BasicBlock* root = proc.addBlock();
 2024     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2025     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 2026     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2027         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 2028         load);
 2029     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2030     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2031 
 2032     int64_t inputOutput = b;
 2033     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
 2034     CHECK(inputOutput == a - b);
 2035 }
 2036 
 2037 void testSubMemImm(int64_t a, int64_t b)
 2038 {
 2039     Procedure proc;
 2040     BasicBlock* root = proc.addBlock();
 2041     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2042     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 2043     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2044         load,
 2045         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b));
 2046     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2047     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2048 
 2049     int64_t inputOutput = a;
 2050     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
 2051     CHECK(inputOutput == a - b);
 2052 }
 2053 
 2054 
 2055 void testSubArgs32(int a, int b)
 2056 {
 2057     Procedure proc;
 2058     BasicBlock* root = proc.addBlock();
 2059     root-&gt;appendNewControlValue(
 2060         proc, Return, Origin(),
 2061         root-&gt;appendNew&lt;Value&gt;(
 2062             proc, Sub, Origin(),
 2063             root-&gt;appendNew&lt;Value&gt;(
 2064                 proc, Trunc, Origin(),
 2065                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2066             root-&gt;appendNew&lt;Value&gt;(
 2067                 proc, Trunc, Origin(),
 2068                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 2069 
 2070     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a - b);
 2071 }
 2072 
 2073 void testSubArgImm32(int a, int b)
 2074 {
 2075     Procedure proc;
 2076     BasicBlock* root = proc.addBlock();
 2077     root-&gt;appendNewControlValue(
 2078         proc, Return, Origin(),
 2079         root-&gt;appendNew&lt;Value&gt;(
 2080             proc, Sub, Origin(),
 2081             root-&gt;appendNew&lt;Value&gt;(
 2082                 proc, Trunc, Origin(),
 2083                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2084             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 2085 
 2086     CHECK(compileAndRun&lt;int&gt;(proc, a) == a - b);
 2087 }
 2088 
 2089 void testSubImmArg32(int a, int b)
 2090 {
 2091     Procedure proc;
 2092     BasicBlock* root = proc.addBlock();
 2093     root-&gt;appendNewControlValue(
 2094         proc, Return, Origin(),
 2095         root-&gt;appendNew&lt;Value&gt;(
 2096             proc, Sub, Origin(),
 2097             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 2098             root-&gt;appendNew&lt;Value&gt;(
 2099                 proc, Trunc, Origin(),
 2100                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 2101 
 2102     CHECK(compileAndRun&lt;int&gt;(proc, b) == a - b);
 2103 }
 2104 
 2105 void testSubMemArg32(int32_t a, int32_t b)
 2106 {
 2107     Procedure proc;
 2108     BasicBlock* root = proc.addBlock();
 2109     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2110     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 2111     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2112         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 2113     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), load, argument);
 2114     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2115     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2116 
 2117     int32_t inputOutput = a;
 2118     CHECK(!compileAndRun&lt;int32_t&gt;(proc, &amp;inputOutput, b));
 2119     CHECK(inputOutput == a - b);
 2120 }
 2121 
 2122 void testSubArgMem32(int32_t a, int32_t b)
 2123 {
 2124     Procedure proc;
 2125     BasicBlock* root = proc.addBlock();
 2126     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2127     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 2128     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2129         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2130     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), argument, load);
 2131     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2132 
 2133     CHECK(compileAndRun&lt;int32_t&gt;(proc, a, &amp;b) == a - b);
 2134 }
 2135 
 2136 void testSubImmMem32(int32_t a, int32_t b)
 2137 {
 2138     Procedure proc;
 2139     BasicBlock* root = proc.addBlock();
 2140     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2141     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 2142     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2143         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 2144         load);
 2145     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2146     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2147 
 2148     int32_t inputOutput = b;
 2149     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
 2150     CHECK(inputOutput == a - b);
 2151 }
 2152 
 2153 void testSubMemImm32(int32_t a, int32_t b)
 2154 {
 2155     Procedure proc;
 2156     BasicBlock* root = proc.addBlock();
 2157     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2158     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 2159     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2160         load,
 2161         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b));
 2162     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, address);
 2163     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 2164 
 2165     int32_t inputOutput = a;
 2166     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;inputOutput));
 2167     CHECK(inputOutput == a - b);
 2168 }
 2169 
 2170 void testNegValueSubOne32(int a)
 2171 {
 2172     Procedure proc;
 2173     BasicBlock* root = proc.addBlock();
 2174     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2175         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2176     Value* negArgument = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2177         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 2178         argument);
 2179     Value* negArgumentMinusOne = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(),
 2180         negArgument,
 2181         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 2182     root-&gt;appendNewControlValue(proc, Return, Origin(), negArgumentMinusOne);
 2183     CHECK(compileAndRun&lt;int&gt;(proc, a) == -a - 1);
 2184 }
 2185 
 2186 void testSubArgDouble(double a)
 2187 {
 2188     Procedure proc;
 2189     BasicBlock* root = proc.addBlock();
 2190     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2191     root-&gt;appendNewControlValue(
 2192         proc, Return, Origin(),
 2193         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), value, value));
 2194 
 2195     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a - a));
 2196 }
 2197 
 2198 void testSubArgsDouble(double a, double b)
 2199 {
 2200     Procedure proc;
 2201     BasicBlock* root = proc.addBlock();
 2202     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2203     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 2204     root-&gt;appendNewControlValue(
 2205         proc, Return, Origin(),
 2206         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), valueA, valueB));
 2207 
 2208     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), a - b));
 2209 }
 2210 
 2211 void testSubArgImmDouble(double a, double b)
 2212 {
 2213     Procedure proc;
 2214     BasicBlock* root = proc.addBlock();
 2215     Value* valueA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2216     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 2217     root-&gt;appendNewControlValue(
 2218         proc, Return, Origin(),
 2219         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), valueA, valueB));
 2220 
 2221     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), a - b));
 2222 }
 2223 
 2224 void testSubImmArgDouble(double a, double b)
 2225 {
 2226     Procedure proc;
 2227     BasicBlock* root = proc.addBlock();
 2228     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 2229     Value* valueB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2230     root-&gt;appendNewControlValue(
 2231         proc, Return, Origin(),
 2232         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), valueA, valueB));
 2233 
 2234     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, b), a - b));
 2235 }
 2236 
 2237 void testSubImmsDouble(double a, double b)
 2238 {
 2239     Procedure proc;
 2240     BasicBlock* root = proc.addBlock();
 2241     Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 2242     Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 2243     root-&gt;appendNewControlValue(
 2244         proc, Return, Origin(),
 2245         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), valueA, valueB));
 2246 
 2247     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), a - b));
 2248 }
 2249 
 2250 void testSubArgFloat(float a)
 2251 {
 2252     Procedure proc;
 2253     BasicBlock* root = proc.addBlock();
 2254     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2255         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2256     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 2257     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), floatValue, floatValue);
 2258     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 2259     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2260 
 2261 
 2262     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a - a)));
 2263 }
 2264 
 2265 void testSubArgsFloat(float a, float b)
 2266 {
 2267     Procedure proc;
 2268     BasicBlock* root = proc.addBlock();
 2269     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2270         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2271     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2272         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 2273     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 2274     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 2275     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), floatValue1, floatValue2);
 2276     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 2277     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2278 
 2279     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a - b)));
 2280 }
 2281 
 2282 void testSubArgImmFloat(float a, float b)
 2283 {
 2284     Procedure proc;
 2285     BasicBlock* root = proc.addBlock();
 2286     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2287         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2288     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 2289     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 2290     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), floatValue, constValue);
 2291     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 2292     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2293 
 2294     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a - b)));
 2295 }
 2296 
 2297 void testSubImmArgFloat(float a, float b)
 2298 {
 2299     Procedure proc;
 2300     BasicBlock* root = proc.addBlock();
 2301     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2302         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2303     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 2304     Value* constValue = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 2305     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), constValue, floatValue);
 2306     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 2307     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2308 
 2309     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a - b)));
 2310 }
 2311 
 2312 void testSubImmsFloat(float a, float b)
 2313 {
 2314     Procedure proc;
 2315     BasicBlock* root = proc.addBlock();
 2316     Value* constValue1 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 2317     Value* constValue2 = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 2318     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), constValue1, constValue2);
 2319     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 2320     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2321 
 2322     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(a - b)));
 2323 }
 2324 
 2325 void testSubArgFloatWithUselessDoubleConversion(float a)
 2326 {
 2327     Procedure proc;
 2328     BasicBlock* root = proc.addBlock();
 2329     Value* argumentInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2330         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2331     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentInt32);
 2332     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 2333     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), asDouble, asDouble);
 2334     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 2335     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 2336     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2337 
 2338     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(a - a)));
 2339 }
 2340 
 2341 void testSubArgsFloatWithUselessDoubleConversion(float a, float b)
 2342 {
 2343     Procedure proc;
 2344     BasicBlock* root = proc.addBlock();
 2345     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2346         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2347     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2348         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 2349     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 2350     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 2351     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 2352     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 2353     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), asDouble1, asDouble2);
 2354     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 2355     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 2356     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2357 
 2358     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitwise_cast&lt;int32_t&gt;(a - b)));
 2359 }
 2360 
 2361 void testSubArgsFloatWithEffectfulDoubleConversion(float a, float b)
 2362 {
 2363     Procedure proc;
 2364     BasicBlock* root = proc.addBlock();
 2365     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2366         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2367     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2368         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 2369     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
 2370     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
 2371     Value* asDouble1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
 2372     Value* asDouble2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
 2373     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), asDouble1, asDouble2);
 2374     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 2375     Value* doubleSubress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 2376     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleSubress);
 2377     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 2378     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 2379 
 2380     double effect = 0;
 2381     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), &amp;effect), bitwise_cast&lt;int32_t&gt;(a - b)));
 2382     CHECK(isIdentical(effect, static_cast&lt;double&gt;(a) - static_cast&lt;double&gt;(b)));
 2383 }
 2384 
 2385 void testTernarySubInstructionSelection(B3::Opcode valueModifier, Type valueType, Air::Opcode expectedOpcode)
 2386 {
 2387     Procedure proc;
 2388     BasicBlock* root = proc.addBlock();
 2389 
 2390     Value* left = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2391     Value* right = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2392 
 2393     if (valueModifier == Trunc) {
 2394         left = root-&gt;appendNew&lt;Value&gt;(proc, valueModifier, valueType, Origin(), left);
 2395         right = root-&gt;appendNew&lt;Value&gt;(proc, valueModifier, valueType, Origin(), right);
 2396     }
 2397 
 2398     root-&gt;appendNewControlValue(
 2399         proc, Return, Origin(),
 2400         root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), left, right));
 2401 
 2402     lowerToAirForTesting(proc);
 2403 
 2404     auto block = proc.code()[0];
 2405     unsigned numberOfSubInstructions = 0;
 2406     for (auto instruction : *block) {
 2407         if (instruction.kind.opcode == expectedOpcode) {
 2408             CHECK_EQ(instruction.args.size(), 3ul);
 2409             CHECK_EQ(instruction.args[0].kind(), Air::Arg::Tmp);
 2410             CHECK_EQ(instruction.args[1].kind(), Air::Arg::Tmp);
 2411             CHECK_EQ(instruction.args[2].kind(), Air::Arg::Tmp);
 2412             numberOfSubInstructions++;
 2413         }
 2414     }
 2415     CHECK_EQ(numberOfSubInstructions, 1ul);
 2416 }
 2417 
 2418 void testNegDouble(double a)
 2419 {
 2420     Procedure proc;
 2421     BasicBlock* root = proc.addBlock();
 2422     root-&gt;appendNewControlValue(
 2423         proc, Return, Origin(),
 2424         root-&gt;appendNew&lt;Value&gt;(
 2425             proc, Neg, Origin(),
 2426             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0)));
 2427 
 2428     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), -a));
 2429 }
 2430 
 2431 void testNegFloat(float a)
 2432 {
 2433     Procedure proc;
 2434     BasicBlock* root = proc.addBlock();
 2435     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2436         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2437     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 2438     root-&gt;appendNewControlValue(
 2439         proc, Return, Origin(),
 2440         root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(), floatValue));
 2441 
 2442     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), -a));
 2443 }
 2444 
 2445 void testNegFloatWithUselessDoubleConversion(float a)
 2446 {
 2447     Procedure proc;
 2448     BasicBlock* root = proc.addBlock();
 2449     Value* argumentInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2450         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2451     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentInt32);
 2452     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 2453     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(), asDouble);
 2454     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 2455     root-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 2456 
 2457     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), -a));
 2458 }
 2459 
 2460 void testBitAndArgs(int64_t a, int64_t b)
 2461 {
 2462     Procedure proc;
 2463     BasicBlock* root = proc.addBlock();
 2464     root-&gt;appendNewControlValue(
 2465         proc, Return, Origin(),
 2466         root-&gt;appendNew&lt;Value&gt;(
 2467             proc, BitAnd, Origin(),
 2468             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 2469             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 2470 
 2471     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == (a &amp; b));
 2472 }
 2473 
 2474 void testBitAndSameArg(int64_t a)
 2475 {
 2476     Procedure proc;
 2477     BasicBlock* root = proc.addBlock();
 2478     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2479     root-&gt;appendNewControlValue(
 2480         proc, Return, Origin(),
 2481         root-&gt;appendNew&lt;Value&gt;(
 2482             proc, BitAnd, Origin(),
 2483             argument,
 2484             argument));
 2485 
 2486     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == a);
 2487 }
 2488 
 2489 void testBitAndNotNot(int64_t a, int64_t b)
 2490 {
 2491     Procedure proc;
 2492     BasicBlock* root = proc.addBlock();
 2493     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2494     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2495     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2496     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2497     root-&gt;appendNewControlValue(
 2498         proc, Return, Origin(),
 2499         root-&gt;appendNew&lt;Value&gt;(
 2500             proc, BitAnd, Origin(),
 2501             notA,
 2502             notB));
 2503 
 2504     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a &amp; ~b));
 2505 }
 2506 
 2507 void testBitAndNotImm(int64_t a, int64_t b)
 2508 {
 2509     Procedure proc;
 2510     BasicBlock* root = proc.addBlock();
 2511     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2512     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2513     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
 2514     root-&gt;appendNewControlValue(
 2515         proc, Return, Origin(),
 2516         root-&gt;appendNew&lt;Value&gt;(
 2517             proc, BitAnd, Origin(),
 2518             notA,
 2519             cstB));
 2520 
 2521     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a &amp; b));
 2522 }
 2523 
 2524 void testBitAndImms(int64_t a, int64_t b)
 2525 {
 2526     Procedure proc;
 2527     BasicBlock* root = proc.addBlock();
 2528     root-&gt;appendNewControlValue(
 2529         proc, Return, Origin(),
 2530         root-&gt;appendNew&lt;Value&gt;(
 2531             proc, BitAnd, Origin(),
 2532             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 2533             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 2534 
 2535     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a &amp; b));
 2536 }
 2537 
 2538 void testBitAndArgImm(int64_t a, int64_t b)
 2539 {
 2540     Procedure proc;
 2541     BasicBlock* root = proc.addBlock();
 2542     root-&gt;appendNewControlValue(
 2543         proc, Return, Origin(),
 2544         root-&gt;appendNew&lt;Value&gt;(
 2545             proc, BitAnd, Origin(),
 2546             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 2547             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 2548 
 2549     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == (a &amp; b));
 2550 }
 2551 
 2552 void testBitAndImmArg(int64_t a, int64_t b)
 2553 {
 2554     Procedure proc;
 2555     BasicBlock* root = proc.addBlock();
 2556     root-&gt;appendNewControlValue(
 2557         proc, Return, Origin(),
 2558         root-&gt;appendNew&lt;Value&gt;(
 2559             proc, BitAnd, Origin(),
 2560             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 2561             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 2562 
 2563     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a &amp; b));
 2564 }
 2565 
 2566 void testBitAndBitAndArgImmImm(int64_t a, int64_t b, int64_t c)
 2567 {
 2568     Procedure proc;
 2569     BasicBlock* root = proc.addBlock();
 2570     Value* innerBitAnd = root-&gt;appendNew&lt;Value&gt;(
 2571         proc, BitAnd, Origin(),
 2572         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 2573         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b));
 2574     root-&gt;appendNewControlValue(
 2575         proc, Return, Origin(),
 2576         root-&gt;appendNew&lt;Value&gt;(
 2577             proc, BitAnd, Origin(),
 2578             innerBitAnd,
 2579             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c)));
 2580 
 2581     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == ((a &amp; b) &amp; c));
 2582 }
 2583 
 2584 void testBitAndImmBitAndArgImm(int64_t a, int64_t b, int64_t c)
 2585 {
 2586     Procedure proc;
 2587     BasicBlock* root = proc.addBlock();
 2588     Value* innerBitAnd = root-&gt;appendNew&lt;Value&gt;(
 2589         proc, BitAnd, Origin(),
 2590         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 2591         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c));
 2592     root-&gt;appendNewControlValue(
 2593         proc, Return, Origin(),
 2594         root-&gt;appendNew&lt;Value&gt;(
 2595             proc, BitAnd, Origin(),
 2596             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 2597             innerBitAnd));
 2598 
 2599     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a &amp; (b &amp; c)));
 2600 }
 2601 
 2602 void testBitAndArgs32(int a, int b)
 2603 {
 2604     Procedure proc;
 2605     BasicBlock* root = proc.addBlock();
 2606     root-&gt;appendNewControlValue(
 2607         proc, Return, Origin(),
 2608         root-&gt;appendNew&lt;Value&gt;(
 2609             proc, BitAnd, Origin(),
 2610             root-&gt;appendNew&lt;Value&gt;(
 2611                 proc, Trunc, Origin(),
 2612                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2613             root-&gt;appendNew&lt;Value&gt;(
 2614                 proc, Trunc, Origin(),
 2615                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 2616 
 2617     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == (a &amp; b));
 2618 }
 2619 
 2620 void testBitAndSameArg32(int a)
 2621 {
 2622     Procedure proc;
 2623     BasicBlock* root = proc.addBlock();
 2624     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2625         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 2626     root-&gt;appendNewControlValue(
 2627         proc, Return, Origin(),
 2628         root-&gt;appendNew&lt;Value&gt;(
 2629             proc, BitAnd, Origin(),
 2630             argument,
 2631             argument));
 2632 
 2633     CHECK(compileAndRun&lt;int&gt;(proc, a) == a);
 2634 }
 2635 
 2636 void testBitAndImms32(int a, int b)
 2637 {
 2638     Procedure proc;
 2639     BasicBlock* root = proc.addBlock();
 2640     root-&gt;appendNewControlValue(
 2641         proc, Return, Origin(),
 2642         root-&gt;appendNew&lt;Value&gt;(
 2643             proc, BitAnd, Origin(),
 2644             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 2645             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 2646 
 2647     CHECK(compileAndRun&lt;int&gt;(proc) == (a &amp; b));
 2648 }
 2649 
 2650 void testBitAndArgImm32(int a, int b)
 2651 {
 2652     Procedure proc;
 2653     BasicBlock* root = proc.addBlock();
 2654     root-&gt;appendNewControlValue(
 2655         proc, Return, Origin(),
 2656         root-&gt;appendNew&lt;Value&gt;(
 2657             proc, BitAnd, Origin(),
 2658             root-&gt;appendNew&lt;Value&gt;(
 2659                 proc, Trunc, Origin(),
 2660                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2661             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 2662 
 2663     CHECK(compileAndRun&lt;int&gt;(proc, a) == (a &amp; b));
 2664 }
 2665 
 2666 void testBitAndImmArg32(int a, int b)
 2667 {
 2668     Procedure proc;
 2669     BasicBlock* root = proc.addBlock();
 2670     root-&gt;appendNewControlValue(
 2671         proc, Return, Origin(),
 2672         root-&gt;appendNew&lt;Value&gt;(
 2673             proc, BitAnd, Origin(),
 2674             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 2675             root-&gt;appendNew&lt;Value&gt;(
 2676                 proc, Trunc, Origin(),
 2677                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 2678 
 2679     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a &amp; b));
 2680 }
 2681 
 2682 void testBitAndBitAndArgImmImm32(int a, int b, int c)
 2683 {
 2684     Procedure proc;
 2685     BasicBlock* root = proc.addBlock();
 2686     Value* innerBitAnd = root-&gt;appendNew&lt;Value&gt;(
 2687         proc, BitAnd, Origin(),
 2688         root-&gt;appendNew&lt;Value&gt;(
 2689             proc, Trunc, Origin(),
 2690             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2691         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b));
 2692     root-&gt;appendNewControlValue(
 2693         proc, Return, Origin(),
 2694         root-&gt;appendNew&lt;Value&gt;(
 2695             proc, BitAnd, Origin(),
 2696             innerBitAnd,
 2697             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c)));
 2698 
 2699     CHECK(compileAndRun&lt;int&gt;(proc, a) == ((a &amp; b) &amp; c));
 2700 }
 2701 
 2702 void testBitAndImmBitAndArgImm32(int a, int b, int c)
 2703 {
 2704     Procedure proc;
 2705     BasicBlock* root = proc.addBlock();
 2706     Value* innerBitAnd = root-&gt;appendNew&lt;Value&gt;(
 2707         proc, BitAnd, Origin(),
 2708         root-&gt;appendNew&lt;Value&gt;(
 2709             proc, Trunc, Origin(),
 2710             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 2711         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c));
 2712     root-&gt;appendNewControlValue(
 2713         proc, Return, Origin(),
 2714         root-&gt;appendNew&lt;Value&gt;(
 2715             proc, BitAnd, Origin(),
 2716             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 2717             innerBitAnd));
 2718 
 2719     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a &amp; (b &amp; c)));
 2720 }
 2721 
 2722 void testBitAndWithMaskReturnsBooleans(int64_t a, int64_t b)
 2723 {
 2724     Procedure proc;
 2725     BasicBlock* root = proc.addBlock();
 2726     Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2727     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2728     Value* equal = root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg0, arg1);
 2729     Value* maskedEqual = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(),
 2730         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x5),
 2731         equal);
 2732     Value* inverted = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 2733         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x1),
 2734         maskedEqual);
 2735     Value* select = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(), inverted,
 2736         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 42),
 2737         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -5));
 2738 
 2739     root-&gt;appendNewControlValue(proc, Return, Origin(), select);
 2740 
 2741     int64_t expected = (a == b) ? -5 : 42;
 2742     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == expected);
 2743 }
 2744 
 2745 double bitAndDouble(double a, double b)
 2746 {
 2747     return bitwise_cast&lt;double&gt;(bitwise_cast&lt;uint64_t&gt;(a) &amp; bitwise_cast&lt;uint64_t&gt;(b));
 2748 }
 2749 
 2750 void testBitAndArgDouble(double a)
 2751 {
 2752     Procedure proc;
 2753     BasicBlock* root = proc.addBlock();
 2754     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2755     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argument, argument);
 2756     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2757 
 2758     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), bitAndDouble(a, a)));
 2759 }
 2760 
 2761 void testBitAndArgsDouble(double a, double b)
 2762 {
 2763     Procedure proc;
 2764     BasicBlock* root = proc.addBlock();
 2765     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2766     Value* argumentB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 2767     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2768     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2769 
 2770     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), bitAndDouble(a, b)));
 2771 }
 2772 
 2773 void testBitAndArgImmDouble(double a, double b)
 2774 {
 2775     Procedure proc;
 2776     BasicBlock* root = proc.addBlock();
 2777     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 2778     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 2779     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2780     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2781 
 2782     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), bitAndDouble(a, b)));
 2783 }
 2784 
 2785 void testBitAndImmsDouble(double a, double b)
 2786 {
 2787     Procedure proc;
 2788     BasicBlock* root = proc.addBlock();
 2789     Value* argumentA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 2790     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 2791     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2792     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2793 
 2794     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), bitAndDouble(a, b)));
 2795 }
 2796 
 2797 float bitAndFloat(float a, float b)
 2798 {
 2799     return bitwise_cast&lt;float&gt;(bitwise_cast&lt;uint32_t&gt;(a) &amp; bitwise_cast&lt;uint32_t&gt;(b));
 2800 }
 2801 
 2802 void testBitAndArgFloat(float a)
 2803 {
 2804     Procedure proc;
 2805     BasicBlock* root = proc.addBlock();
 2806     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2807         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2808             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 2809     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argument, argument);
 2810     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2811 
 2812     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitAndFloat(a, a)));
 2813 }
 2814 
 2815 void testBitAndArgsFloat(float a, float b)
 2816 {
 2817     Procedure proc;
 2818     BasicBlock* root = proc.addBlock();
 2819     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2820         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2821             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 2822     Value* argumentB = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2823         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2824             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 2825     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2826     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2827 
 2828     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitAndFloat(a, b)));
 2829 }
 2830 
 2831 void testBitAndArgImmFloat(float a, float b)
 2832 {
 2833     Procedure proc;
 2834     BasicBlock* root = proc.addBlock();
 2835     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2836         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2837             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 2838     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 2839     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2840     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2841 
 2842     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitAndFloat(a, b)));
 2843 }
 2844 
 2845 void testBitAndImmsFloat(float a, float b)
 2846 {
 2847     Procedure proc;
 2848     BasicBlock* root = proc.addBlock();
 2849     Value* argumentA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 2850     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 2851     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentA, argumentB);
 2852     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2853 
 2854     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), bitAndFloat(a, b)));
 2855 }
 2856 
 2857 void testBitAndArgsFloatWithUselessDoubleConversion(float a, float b)
 2858 {
 2859     Procedure proc;
 2860     BasicBlock* root = proc.addBlock();
 2861     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2862         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2863             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 2864     Value* argumentB = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 2865         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 2866             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 2867     Value* argumentAasDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argumentA);
 2868     Value* argumentBasDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argumentB);
 2869     Value* doubleResult = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argumentAasDouble, argumentBasDouble);
 2870     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), doubleResult);
 2871     root-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 2872 
 2873     double doubleA = a;
 2874     double doubleB = b;
 2875     float expected = static_cast&lt;float&gt;(bitAndDouble(doubleA, doubleB));
 2876     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), expected));
 2877 }
 2878 
 2879 void testBitOrArgs(int64_t a, int64_t b)
 2880 {
 2881     Procedure proc;
 2882     BasicBlock* root = proc.addBlock();
 2883     root-&gt;appendNewControlValue(
 2884         proc, Return, Origin(),
 2885         root-&gt;appendNew&lt;Value&gt;(
 2886             proc, BitOr, Origin(),
 2887             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 2888             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 2889 
 2890     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == (a | b));
 2891 }
 2892 
 2893 void testBitOrSameArg(int64_t a)
 2894 {
 2895     Procedure proc;
 2896     BasicBlock* root = proc.addBlock();
 2897     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2898     root-&gt;appendNewControlValue(
 2899         proc, Return, Origin(),
 2900         root-&gt;appendNew&lt;Value&gt;(
 2901             proc, BitOr, Origin(),
 2902             argument,
 2903             argument));
 2904 
 2905     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == a);
 2906 }
 2907 
 2908 void testBitOrAndAndArgs(int64_t a, int64_t b, int64_t c)
 2909 {
 2910     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 2911     // ((a &amp; b) | (a &amp; c))
 2912     // ((a &amp; b) | (c &amp; a))
 2913     // ((b &amp; a) | (a &amp; c))
 2914     // ((b &amp; a) | (c &amp; a))
 2915     for (int i = 0; i &lt; 4; ++i) {
 2916         Procedure proc;
 2917         BasicBlock* root = proc.addBlock();
 2918         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2919         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2920         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 2921         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 2922             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 2923         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
 2924             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
 2925         root-&gt;appendNewControlValue(
 2926             proc, Return, Origin(),
 2927             root-&gt;appendNew&lt;Value&gt;(
 2928                 proc, BitOr, Origin(),
 2929                 andAB,
 2930                 andAC));
 2931 
 2932         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) | (a &amp; c)));
 2933     }
 2934 }
 2935 
 2936 void testBitOrAndSameArgs(int64_t a, int64_t b)
 2937 {
 2938     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 2939     // ((a &amp; b) | a)
 2940     // ((b &amp; a) | a)
 2941     // (a | (a &amp; b))
 2942     // (a | (b &amp; a))
 2943     for (int i = 0; i &lt; 4; ++i) {
 2944         Procedure proc;
 2945         BasicBlock* root = proc.addBlock();
 2946         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2947         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2948         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 2949             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 2950         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), andAB, argA)
 2951             : root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argA, andAB);
 2952         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 2953 
 2954         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) | a));
 2955     }
 2956 }
 2957 
 2958 void testBitOrNotNot(int64_t a, int64_t b)
 2959 {
 2960     Procedure proc;
 2961     BasicBlock* root = proc.addBlock();
 2962     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2963     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 2964     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2965     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2966     root-&gt;appendNewControlValue(
 2967         proc, Return, Origin(),
 2968         root-&gt;appendNew&lt;Value&gt;(
 2969             proc, BitOr, Origin(),
 2970             notA,
 2971             notB));
 2972 
 2973     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | ~b));
 2974 }
 2975 
 2976 void testBitOrNotImm(int64_t a, int64_t b)
 2977 {
 2978     Procedure proc;
 2979     BasicBlock* root = proc.addBlock();
 2980     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 2981     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
 2982     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
 2983     root-&gt;appendNewControlValue(
 2984         proc, Return, Origin(),
 2985         root-&gt;appendNew&lt;Value&gt;(
 2986             proc, BitOr, Origin(),
 2987             notA,
 2988             cstB));
 2989 
 2990     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | b));
 2991 }
 2992 
 2993 void testBitOrImms(int64_t a, int64_t b)
 2994 {
 2995     Procedure proc;
 2996     BasicBlock* root = proc.addBlock();
 2997     root-&gt;appendNewControlValue(
 2998         proc, Return, Origin(),
 2999         root-&gt;appendNew&lt;Value&gt;(
 3000             proc, BitOr, Origin(),
 3001             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3002             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 3003 
 3004     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a | b));
 3005 }
 3006 
 3007 void testBitOrArgImm(int64_t a, int64_t b)
 3008 {
 3009     Procedure proc;
 3010     BasicBlock* root = proc.addBlock();
 3011     root-&gt;appendNewControlValue(
 3012         proc, Return, Origin(),
 3013         root-&gt;appendNew&lt;Value&gt;(
 3014             proc, BitOr, Origin(),
 3015             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3016             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 3017 
 3018     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == (a | b));
 3019 }
 3020 
 3021 void testBitOrImmArg(int64_t a, int64_t b)
 3022 {
 3023     Procedure proc;
 3024     BasicBlock* root = proc.addBlock();
 3025     root-&gt;appendNewControlValue(
 3026         proc, Return, Origin(),
 3027         root-&gt;appendNew&lt;Value&gt;(
 3028             proc, BitOr, Origin(),
 3029             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3030             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3031 
 3032     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a | b));
 3033 }
 3034 
 3035 void testBitOrBitOrArgImmImm(int64_t a, int64_t b, int64_t c)
 3036 {
 3037     Procedure proc;
 3038     BasicBlock* root = proc.addBlock();
 3039     Value* innerBitOr = root-&gt;appendNew&lt;Value&gt;(
 3040         proc, BitOr, Origin(),
 3041         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3042         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b));
 3043     root-&gt;appendNewControlValue(
 3044         proc, Return, Origin(),
 3045         root-&gt;appendNew&lt;Value&gt;(
 3046             proc, BitOr, Origin(),
 3047             innerBitOr,
 3048             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c)));
 3049 
 3050     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == ((a | b) | c));
 3051 }
 3052 
 3053 void testBitOrImmBitOrArgImm(int64_t a, int64_t b, int64_t c)
 3054 {
 3055     Procedure proc;
 3056     BasicBlock* root = proc.addBlock();
 3057     Value* innerBitOr = root-&gt;appendNew&lt;Value&gt;(
 3058         proc, BitOr, Origin(),
 3059         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3060         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c));
 3061     root-&gt;appendNewControlValue(
 3062         proc, Return, Origin(),
 3063         root-&gt;appendNew&lt;Value&gt;(
 3064             proc, BitOr, Origin(),
 3065             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3066             innerBitOr));
 3067 
 3068     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a | (b | c)));
 3069 }
 3070 
 3071 void testBitOrArgs32(int a, int b)
 3072 {
 3073     Procedure proc;
 3074     BasicBlock* root = proc.addBlock();
 3075     root-&gt;appendNewControlValue(
 3076         proc, Return, Origin(),
 3077         root-&gt;appendNew&lt;Value&gt;(
 3078             proc, BitOr, Origin(),
 3079             root-&gt;appendNew&lt;Value&gt;(
 3080                 proc, Trunc, Origin(),
 3081                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3082             root-&gt;appendNew&lt;Value&gt;(
 3083                 proc, Trunc, Origin(),
 3084                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3085 
 3086     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == (a | b));
 3087 }
 3088 
 3089 void testBitOrSameArg32(int a)
 3090 {
 3091     Procedure proc;
 3092     BasicBlock* root = proc.addBlock();
 3093     Value* argument = root-&gt;appendNew&lt;Value&gt;(
 3094         proc, Trunc, Origin(),
 3095             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3096     root-&gt;appendNewControlValue(
 3097         proc, Return, Origin(),
 3098         root-&gt;appendNew&lt;Value&gt;(
 3099             proc, BitOr, Origin(),
 3100             argument,
 3101             argument));
 3102 
 3103     CHECK(compileAndRun&lt;int&gt;(proc, a) == a);
 3104 }
 3105 
 3106 void testBitOrImms32(int a, int b)
 3107 {
 3108     Procedure proc;
 3109     BasicBlock* root = proc.addBlock();
 3110     root-&gt;appendNewControlValue(
 3111         proc, Return, Origin(),
 3112         root-&gt;appendNew&lt;Value&gt;(
 3113             proc, BitOr, Origin(),
 3114             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3115             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3116 
 3117     CHECK(compileAndRun&lt;int&gt;(proc) == (a | b));
 3118 }
 3119 
 3120 void testBitOrArgImm32(int a, int b)
 3121 {
 3122     Procedure proc;
 3123     BasicBlock* root = proc.addBlock();
 3124     root-&gt;appendNewControlValue(
 3125         proc, Return, Origin(),
 3126         root-&gt;appendNew&lt;Value&gt;(
 3127             proc, BitOr, Origin(),
 3128             root-&gt;appendNew&lt;Value&gt;(
 3129                 proc, Trunc, Origin(),
 3130                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3131             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3132 
 3133     CHECK(compileAndRun&lt;int&gt;(proc, a) == (a | b));
 3134 }
 3135 
 3136 void testBitOrImmArg32(int a, int b)
 3137 {
 3138     Procedure proc;
 3139     BasicBlock* root = proc.addBlock();
 3140     root-&gt;appendNewControlValue(
 3141         proc, Return, Origin(),
 3142         root-&gt;appendNew&lt;Value&gt;(
 3143             proc, BitOr, Origin(),
 3144             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3145             root-&gt;appendNew&lt;Value&gt;(
 3146                 proc, Trunc, Origin(),
 3147                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 3148 
 3149     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a | b));
 3150 }
 3151 
 3152 void testBitOrBitOrArgImmImm32(int a, int b, int c)
 3153 {
 3154     Procedure proc;
 3155     BasicBlock* root = proc.addBlock();
 3156     Value* innerBitOr = root-&gt;appendNew&lt;Value&gt;(
 3157         proc, BitOr, Origin(),
 3158         root-&gt;appendNew&lt;Value&gt;(
 3159             proc, Trunc, Origin(),
 3160             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3161         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b));
 3162     root-&gt;appendNewControlValue(
 3163         proc, Return, Origin(),
 3164         root-&gt;appendNew&lt;Value&gt;(
 3165             proc, BitOr, Origin(),
 3166             innerBitOr,
 3167             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c)));
 3168 
 3169     CHECK(compileAndRun&lt;int&gt;(proc, a) == ((a | b) | c));
 3170 }
 3171 
 3172 void testBitOrImmBitOrArgImm32(int a, int b, int c)
 3173 {
 3174     Procedure proc;
 3175     BasicBlock* root = proc.addBlock();
 3176     Value* innerBitOr = root-&gt;appendNew&lt;Value&gt;(
 3177         proc, BitOr, Origin(),
 3178         root-&gt;appendNew&lt;Value&gt;(
 3179             proc, Trunc, Origin(),
 3180             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3181         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c));
 3182     root-&gt;appendNewControlValue(
 3183         proc, Return, Origin(),
 3184         root-&gt;appendNew&lt;Value&gt;(
 3185             proc, BitOr, Origin(),
 3186             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3187             innerBitOr));
 3188 
 3189     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a | (b | c)));
 3190 }
 3191 
 3192 double bitOrDouble(double a, double b)
 3193 {
 3194     return bitwise_cast&lt;double&gt;(bitwise_cast&lt;uint64_t&gt;(a) | bitwise_cast&lt;uint64_t&gt;(b));
 3195 }
 3196 
 3197 void testBitOrArgDouble(double a)
 3198 {
 3199     Procedure proc;
 3200     BasicBlock* root = proc.addBlock();
 3201     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 3202     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argument, argument);
 3203     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3204 
 3205     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), bitOrDouble(a, a)));
 3206 }
 3207 
 3208 void testBitOrArgsDouble(double a, double b)
 3209 {
 3210     Procedure proc;
 3211     BasicBlock* root = proc.addBlock();
 3212     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 3213     Value* argumentB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 3214     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3215     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3216 
 3217     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), bitOrDouble(a, b)));
 3218 }
 3219 
 3220 void testBitOrArgImmDouble(double a, double b)
 3221 {
 3222     Procedure proc;
 3223     BasicBlock* root = proc.addBlock();
 3224     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 3225     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 3226     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3227     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3228 
 3229     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a, b), bitOrDouble(a, b)));
 3230 }
 3231 
 3232 void testBitOrImmsDouble(double a, double b)
 3233 {
 3234     Procedure proc;
 3235     BasicBlock* root = proc.addBlock();
 3236     Value* argumentA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 3237     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 3238     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3239     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3240 
 3241     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), bitOrDouble(a, b)));
 3242 }
 3243 
 3244 float bitOrFloat(float a, float b)
 3245 {
 3246     return bitwise_cast&lt;float&gt;(bitwise_cast&lt;uint32_t&gt;(a) | bitwise_cast&lt;uint32_t&gt;(b));
 3247 }
 3248 
 3249 void testBitOrArgFloat(float a)
 3250 {
 3251     Procedure proc;
 3252     BasicBlock* root = proc.addBlock();
 3253     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3254         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3255             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3256     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argument, argument);
 3257     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3258 
 3259     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitOrFloat(a, a)));
 3260 }
 3261 
 3262 void testBitOrArgsFloat(float a, float b)
 3263 {
 3264     Procedure proc;
 3265     BasicBlock* root = proc.addBlock();
 3266     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3267         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3268             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3269     Value* argumentB = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3270         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3271             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 3272     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3273     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3274 
 3275     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitOrFloat(a, b)));
 3276 }
 3277 
 3278 void testBitOrArgImmFloat(float a, float b)
 3279 {
 3280     Procedure proc;
 3281     BasicBlock* root = proc.addBlock();
 3282     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3283         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3284             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3285     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 3286     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3287     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3288 
 3289     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), bitOrFloat(a, b)));
 3290 }
 3291 
 3292 void testBitOrImmsFloat(float a, float b)
 3293 {
 3294     Procedure proc;
 3295     BasicBlock* root = proc.addBlock();
 3296     Value* argumentA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 3297     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 3298     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentA, argumentB);
 3299     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3300 
 3301     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), bitOrFloat(a, b)));
 3302 }
 3303 
 3304 void testBitOrArgsFloatWithUselessDoubleConversion(float a, float b)
 3305 {
 3306     Procedure proc;
 3307     BasicBlock* root = proc.addBlock();
 3308     Value* argumentA = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3309         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3310             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3311     Value* argumentB = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
 3312         root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3313             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 3314     Value* argumentAasDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argumentA);
 3315     Value* argumentBasDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argumentB);
 3316     Value* doubleResult = root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argumentAasDouble, argumentBasDouble);
 3317     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), doubleResult);
 3318     root-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 3319 
 3320     double doubleA = a;
 3321     double doubleB = b;
 3322     float expected = static_cast&lt;float&gt;(bitOrDouble(doubleA, doubleB));
 3323     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), expected));
 3324 }
 3325 
 3326 void testBitXorArgs(int64_t a, int64_t b)
 3327 {
 3328     Procedure proc;
 3329     BasicBlock* root = proc.addBlock();
 3330     root-&gt;appendNewControlValue(
 3331         proc, Return, Origin(),
 3332         root-&gt;appendNew&lt;Value&gt;(
 3333             proc, BitXor, Origin(),
 3334             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3335             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 3336 
 3337     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == (a ^ b));
 3338 }
 3339 
 3340 void testBitXorSameArg(int64_t a)
 3341 {
 3342     Procedure proc;
 3343     BasicBlock* root = proc.addBlock();
 3344     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 3345     root-&gt;appendNewControlValue(
 3346         proc, Return, Origin(),
 3347         root-&gt;appendNew&lt;Value&gt;(
 3348             proc, BitXor, Origin(),
 3349             argument,
 3350             argument));
 3351 
 3352     CHECK(!compileAndRun&lt;int64_t&gt;(proc, a));
 3353 }
 3354 
 3355 void testBitXorAndAndArgs(int64_t a, int64_t b, int64_t c)
 3356 {
 3357     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 3358     // ((a &amp; b) ^ (a &amp; c))
 3359     // ((a &amp; b) ^ (c &amp; a))
 3360     // ((b &amp; a) ^ (a &amp; c))
 3361     // ((b &amp; a) ^ (c &amp; a))
 3362     for (int i = 0; i &lt; 4; ++i) {
 3363         Procedure proc;
 3364         BasicBlock* root = proc.addBlock();
 3365         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 3366         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 3367         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 3368         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 3369             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 3370         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
 3371             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
 3372         root-&gt;appendNewControlValue(
 3373             proc, Return, Origin(),
 3374             root-&gt;appendNew&lt;Value&gt;(
 3375                 proc, BitXor, Origin(),
 3376                 andAB,
 3377                 andAC));
 3378 
 3379         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) ^ (a &amp; c)));
 3380     }
 3381 }
 3382 
 3383 void testBitXorAndSameArgs(int64_t a, int64_t b)
 3384 {
 3385     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 3386     // ((a &amp; b) ^ a)
 3387     // ((b &amp; a) ^ a)
 3388     // (a ^ (a &amp; b))
 3389     // (a ^ (b &amp; a))
 3390     for (int i = 0; i &lt; 4; ++i) {
 3391         Procedure proc;
 3392         BasicBlock* root = proc.addBlock();
 3393         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 3394         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 3395         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 3396             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 3397         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), andAB, argA)
 3398             : root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, andAB);
 3399         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 3400 
 3401         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) ^ a));
 3402     }
 3403 }
 3404 
 3405 void testBitXorImms(int64_t a, int64_t b)
 3406 {
 3407     Procedure proc;
 3408     BasicBlock* root = proc.addBlock();
 3409     root-&gt;appendNewControlValue(
 3410         proc, Return, Origin(),
 3411         root-&gt;appendNew&lt;Value&gt;(
 3412             proc, BitXor, Origin(),
 3413             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3414             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 3415 
 3416     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a ^ b));
 3417 }
 3418 
 3419 void testBitXorArgImm(int64_t a, int64_t b)
 3420 {
 3421     Procedure proc;
 3422     BasicBlock* root = proc.addBlock();
 3423     root-&gt;appendNewControlValue(
 3424         proc, Return, Origin(),
 3425         root-&gt;appendNew&lt;Value&gt;(
 3426             proc, BitXor, Origin(),
 3427             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3428             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 3429 
 3430     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == (a ^ b));
 3431 }
 3432 
 3433 void testBitXorImmArg(int64_t a, int64_t b)
 3434 {
 3435     Procedure proc;
 3436     BasicBlock* root = proc.addBlock();
 3437     root-&gt;appendNewControlValue(
 3438         proc, Return, Origin(),
 3439         root-&gt;appendNew&lt;Value&gt;(
 3440             proc, BitXor, Origin(),
 3441             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3442             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3443 
 3444     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a ^ b));
 3445 }
 3446 
 3447 void testBitXorBitXorArgImmImm(int64_t a, int64_t b, int64_t c)
 3448 {
 3449     Procedure proc;
 3450     BasicBlock* root = proc.addBlock();
 3451     Value* innerBitXor = root-&gt;appendNew&lt;Value&gt;(
 3452         proc, BitXor, Origin(),
 3453         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3454         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b));
 3455     root-&gt;appendNewControlValue(
 3456         proc, Return, Origin(),
 3457         root-&gt;appendNew&lt;Value&gt;(
 3458             proc, BitXor, Origin(),
 3459             innerBitXor,
 3460             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c)));
 3461 
 3462     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == ((a ^ b) ^ c));
 3463 }
 3464 
 3465 void testBitXorImmBitXorArgImm(int64_t a, int64_t b, int64_t c)
 3466 {
 3467     Procedure proc;
 3468     BasicBlock* root = proc.addBlock();
 3469     Value* innerBitXor = root-&gt;appendNew&lt;Value&gt;(
 3470         proc, BitXor, Origin(),
 3471         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3472         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), c));
 3473     root-&gt;appendNewControlValue(
 3474         proc, Return, Origin(),
 3475         root-&gt;appendNew&lt;Value&gt;(
 3476             proc, BitXor, Origin(),
 3477             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3478             innerBitXor));
 3479 
 3480     CHECK(compileAndRun&lt;int64_t&gt;(proc, b) == (a ^ (b ^ c)));
 3481 }
 3482 
 3483 void testBitXorArgs32(int a, int b)
 3484 {
 3485     Procedure proc;
 3486     BasicBlock* root = proc.addBlock();
 3487     root-&gt;appendNewControlValue(
 3488         proc, Return, Origin(),
 3489         root-&gt;appendNew&lt;Value&gt;(
 3490             proc, BitXor, Origin(),
 3491             root-&gt;appendNew&lt;Value&gt;(
 3492                 proc, Trunc, Origin(),
 3493                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3494             root-&gt;appendNew&lt;Value&gt;(
 3495                 proc, Trunc, Origin(),
 3496                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3497 
 3498     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == (a ^ b));
 3499 }
 3500 
 3501 void testBitXorSameArg32(int a)
 3502 {
 3503     Procedure proc;
 3504     BasicBlock* root = proc.addBlock();
 3505     Value* argument = root-&gt;appendNew&lt;Value&gt;(
 3506         proc, Trunc, Origin(),
 3507             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3508     root-&gt;appendNewControlValue(
 3509         proc, Return, Origin(),
 3510         root-&gt;appendNew&lt;Value&gt;(
 3511             proc, BitXor, Origin(),
 3512             argument,
 3513             argument));
 3514 
 3515     CHECK(!compileAndRun&lt;int&gt;(proc, a));
 3516 }
 3517 
 3518 void testBitXorImms32(int a, int b)
 3519 {
 3520     Procedure proc;
 3521     BasicBlock* root = proc.addBlock();
 3522     root-&gt;appendNewControlValue(
 3523         proc, Return, Origin(),
 3524         root-&gt;appendNew&lt;Value&gt;(
 3525             proc, BitXor, Origin(),
 3526             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3527             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3528 
 3529     CHECK(compileAndRun&lt;int&gt;(proc) == (a ^ b));
 3530 }
 3531 
 3532 void testBitXorArgImm32(int a, int b)
 3533 {
 3534     Procedure proc;
 3535     BasicBlock* root = proc.addBlock();
 3536     root-&gt;appendNewControlValue(
 3537         proc, Return, Origin(),
 3538         root-&gt;appendNew&lt;Value&gt;(
 3539             proc, BitXor, Origin(),
 3540             root-&gt;appendNew&lt;Value&gt;(
 3541                 proc, Trunc, Origin(),
 3542                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3543             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3544 
 3545     CHECK(compileAndRun&lt;int&gt;(proc, a) == (a ^ b));
 3546 }
 3547 
 3548 void testBitXorImmArg32(int a, int b)
 3549 {
 3550     Procedure proc;
 3551     BasicBlock* root = proc.addBlock();
 3552     root-&gt;appendNewControlValue(
 3553         proc, Return, Origin(),
 3554         root-&gt;appendNew&lt;Value&gt;(
 3555             proc, BitXor, Origin(),
 3556             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3557             root-&gt;appendNew&lt;Value&gt;(
 3558                 proc, Trunc, Origin(),
 3559                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 3560 
 3561     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a ^ b));
 3562 }
 3563 
 3564 void testBitXorBitXorArgImmImm32(int a, int b, int c)
 3565 {
 3566     Procedure proc;
 3567     BasicBlock* root = proc.addBlock();
 3568     Value* innerBitXor = root-&gt;appendNew&lt;Value&gt;(
 3569         proc, BitXor, Origin(),
 3570         root-&gt;appendNew&lt;Value&gt;(
 3571             proc, Trunc, Origin(),
 3572             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3573         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b));
 3574     root-&gt;appendNewControlValue(
 3575         proc, Return, Origin(),
 3576         root-&gt;appendNew&lt;Value&gt;(
 3577             proc, BitXor, Origin(),
 3578             innerBitXor,
 3579             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c)));
 3580 
 3581     CHECK(compileAndRun&lt;int&gt;(proc, a) == ((a ^ b) ^ c));
 3582 }
 3583 
 3584 void testBitXorImmBitXorArgImm32(int a, int b, int c)
 3585 {
 3586     Procedure proc;
 3587     BasicBlock* root = proc.addBlock();
 3588     Value* innerBitXor = root-&gt;appendNew&lt;Value&gt;(
 3589         proc, BitXor, Origin(),
 3590         root-&gt;appendNew&lt;Value&gt;(
 3591             proc, Trunc, Origin(),
 3592             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3593         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), c));
 3594     root-&gt;appendNewControlValue(
 3595         proc, Return, Origin(),
 3596         root-&gt;appendNew&lt;Value&gt;(
 3597             proc, BitXor, Origin(),
 3598             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3599             innerBitXor));
 3600 
 3601     CHECK(compileAndRun&lt;int&gt;(proc, b) == (a ^ (b ^ c)));
 3602 }
 3603 
 3604 void testBitNotArg(int64_t a)
 3605 {
 3606     Procedure proc;
 3607     BasicBlock* root = proc.addBlock();
 3608     root-&gt;appendNewControlValue(
 3609         proc, Return, Origin(),
 3610         root-&gt;appendNew&lt;Value&gt;(
 3611             proc, BitXor, Origin(),
 3612             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1),
 3613             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 3614 
 3615     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, a), static_cast&lt;int64_t&gt;((static_cast&lt;uint64_t&gt;(a) ^ 0xffffffffffffffff))));
 3616 }
 3617 
 3618 void testBitNotImm(int64_t a)
 3619 {
 3620     Procedure proc;
 3621     BasicBlock* root = proc.addBlock();
 3622     root-&gt;appendNewControlValue(
 3623         proc, Return, Origin(),
 3624         root-&gt;appendNew&lt;Value&gt;(
 3625             proc, BitXor, Origin(),
 3626             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1),
 3627             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a)));
 3628 
 3629     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, a), static_cast&lt;int64_t&gt;((static_cast&lt;uint64_t&gt;(a) ^ 0xffffffffffffffff))));
 3630 }
 3631 
 3632 void testBitNotMem(int64_t a)
 3633 {
 3634     Procedure proc;
 3635     BasicBlock* root = proc.addBlock();
 3636     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 3637     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 3638     Value* notLoad = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 3639         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1),
 3640         load);
 3641     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), notLoad, address);
 3642     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 3643 
 3644     int64_t input = a;
 3645     compileAndRun&lt;int32_t&gt;(proc, &amp;input);
 3646     CHECK(isIdentical(input, static_cast&lt;int64_t&gt;((static_cast&lt;uint64_t&gt;(a) ^ 0xffffffffffffffff))));
 3647 }
 3648 
 3649 void testBitNotArg32(int32_t a)
 3650 {
 3651     Procedure proc;
 3652     BasicBlock* root = proc.addBlock();
 3653     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3654         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3655     root-&gt;appendNewControlValue(
 3656         proc, Return, Origin(),
 3657         root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 3658             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1),
 3659             argument));
 3660     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, a), static_cast&lt;int32_t&gt;((static_cast&lt;uint32_t&gt;(a) ^ 0xffffffff))));
 3661 }
 3662 
 3663 void testBitNotImm32(int32_t a)
 3664 {
 3665     Procedure proc;
 3666     BasicBlock* root = proc.addBlock();
 3667     root-&gt;appendNewControlValue(
 3668         proc, Return, Origin(),
 3669         root-&gt;appendNew&lt;Value&gt;(
 3670             proc, BitXor, Origin(),
 3671             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1),
 3672             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a)));
 3673 
 3674     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, a), static_cast&lt;int32_t&gt;((static_cast&lt;uint32_t&gt;(a) ^ 0xffffffff))));
 3675 }
 3676 
 3677 void testBitNotMem32(int32_t a)
 3678 {
 3679     Procedure proc;
 3680     BasicBlock* root = proc.addBlock();
 3681     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 3682     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 3683     Value* notLoad = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 3684         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1),
 3685         load);
 3686     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), notLoad, address);
 3687     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 3688 
 3689     int32_t input = a;
 3690     compileAndRun&lt;int32_t&gt;(proc, &amp;input);
 3691     CHECK(isIdentical(input, static_cast&lt;int32_t&gt;((static_cast&lt;uint32_t&gt;(a) ^ 0xffffffff))));
 3692 }
 3693 
 3694 void testNotOnBooleanAndBranch32(int64_t a, int64_t b)
 3695 {
 3696     Procedure proc;
 3697     BasicBlock* root = proc.addBlock();
 3698     BasicBlock* thenCase = proc.addBlock();
 3699     BasicBlock* elseCase = proc.addBlock();
 3700 
 3701     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3702         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3703     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3704         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 3705     Value* argsAreEqual = root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2);
 3706     Value* argsAreNotEqual = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 3707         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1),
 3708         argsAreEqual);
 3709 
 3710     root-&gt;appendNewControlValue(
 3711         proc, Branch, Origin(),
 3712         argsAreNotEqual,
 3713         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 3714 
 3715     thenCase-&gt;appendNewControlValue(
 3716         proc, Return, Origin(),
 3717         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 3718 
 3719     elseCase-&gt;appendNewControlValue(
 3720         proc, Return, Origin(),
 3721         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -42));
 3722 
 3723     int32_t expectedValue = (a != b) ? 42 : -42;
 3724     CHECK(compileAndRun&lt;int32_t&gt;(proc, a, b) == expectedValue);
 3725 }
 3726 
 3727 void testBitNotOnBooleanAndBranch32(int64_t a, int64_t b)
 3728 {
 3729     Procedure proc;
 3730     BasicBlock* root = proc.addBlock();
 3731     BasicBlock* thenCase = proc.addBlock();
 3732     BasicBlock* elseCase = proc.addBlock();
 3733 
 3734     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3735         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3736     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 3737         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 3738     Value* argsAreEqual = root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2);
 3739     Value* bitNotArgsAreEqual = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(),
 3740         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1),
 3741         argsAreEqual);
 3742 
 3743     root-&gt;appendNewControlValue(proc, Branch, Origin(),
 3744         bitNotArgsAreEqual, FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 3745 
 3746     thenCase-&gt;appendNewControlValue(proc, Return, Origin(),
 3747         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 3748 
 3749     elseCase-&gt;appendNewControlValue(proc, Return, Origin(),
 3750         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -42));
 3751 
 3752     int32_t expectedValue = ~(a == b) ? 42 : -42; // always 42
 3753     CHECK(compileAndRun&lt;int32_t&gt;(proc, a, b) == expectedValue);
 3754 }
 3755 
 3756 void testShlArgs(int64_t a, int64_t b)
 3757 {
 3758     Procedure proc;
 3759     BasicBlock* root = proc.addBlock();
 3760     root-&gt;appendNewControlValue(
 3761         proc, Return, Origin(),
 3762         root-&gt;appendNew&lt;Value&gt;(
 3763             proc, Shl, Origin(),
 3764             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3765             root-&gt;appendNew&lt;Value&gt;(
 3766                 proc, Trunc, Origin(),
 3767                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3768 
 3769     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == (a &lt;&lt; b));
 3770 }
 3771 
 3772 void testShlImms(int64_t a, int64_t b)
 3773 {
 3774     Procedure proc;
 3775     BasicBlock* root = proc.addBlock();
 3776     root-&gt;appendNewControlValue(
 3777         proc, Return, Origin(),
 3778         root-&gt;appendNew&lt;Value&gt;(
 3779             proc, Shl, Origin(),
 3780             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3781             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3782 
 3783     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a &lt;&lt; b));
 3784 }
 3785 
 3786 void testShlArgImm(int64_t a, int64_t b)
 3787 {
 3788     Procedure proc;
 3789     BasicBlock* root = proc.addBlock();
 3790     root-&gt;appendNewControlValue(
 3791         proc, Return, Origin(),
 3792         root-&gt;appendNew&lt;Value&gt;(
 3793             proc, Shl, Origin(),
 3794             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3795             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3796 
 3797     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == (a &lt;&lt; b));
 3798 }
 3799 
 3800 void testShlArg32(int32_t a)
 3801 {
 3802     Procedure proc;
 3803     BasicBlock* root = proc.addBlock();
 3804     Value* value = root-&gt;appendNew&lt;Value&gt;(
 3805         proc, Trunc, Origin(),
 3806         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3807     root-&gt;appendNewControlValue(
 3808         proc, Return, Origin(),
 3809         root-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), value, value));
 3810 
 3811     CHECK(compileAndRun&lt;int32_t&gt;(proc, a) == (a &lt;&lt; a));
 3812 }
 3813 
 3814 void testShlArgs32(int32_t a, int32_t b)
 3815 {
 3816     Procedure proc;
 3817     BasicBlock* root = proc.addBlock();
 3818     root-&gt;appendNewControlValue(
 3819         proc, Return, Origin(),
 3820         root-&gt;appendNew&lt;Value&gt;(
 3821             proc, Shl, Origin(),
 3822             root-&gt;appendNew&lt;Value&gt;(
 3823                 proc, Trunc, Origin(),
 3824                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3825             root-&gt;appendNew&lt;Value&gt;(
 3826                 proc, Trunc, Origin(),
 3827                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3828 
 3829     CHECK(compileAndRun&lt;int32_t&gt;(proc, a, b) == (a &lt;&lt; b));
 3830 }
 3831 
 3832 void testShlImms32(int32_t a, int32_t b)
 3833 {
 3834     Procedure proc;
 3835     BasicBlock* root = proc.addBlock();
 3836     root-&gt;appendNewControlValue(
 3837         proc, Return, Origin(),
 3838         root-&gt;appendNew&lt;Value&gt;(
 3839             proc, Shl, Origin(),
 3840             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3841             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3842 
 3843     CHECK(compileAndRun&lt;int32_t&gt;(proc) == (a &lt;&lt; b));
 3844 }
 3845 
 3846 void testShlArgImm32(int32_t a, int32_t b)
 3847 {
 3848     Procedure proc;
 3849     BasicBlock* root = proc.addBlock();
 3850     root-&gt;appendNewControlValue(
 3851         proc, Return, Origin(),
 3852         root-&gt;appendNew&lt;Value&gt;(
 3853             proc, Shl, Origin(),
 3854             root-&gt;appendNew&lt;Value&gt;(
 3855                 proc, Trunc, Origin(),
 3856                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3857             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3858 
 3859     CHECK(compileAndRun&lt;int32_t&gt;(proc, a) == (a &lt;&lt; b));
 3860 }
 3861 
 3862 void testSShrArgs(int64_t a, int64_t b)
 3863 {
 3864     Procedure proc;
 3865     BasicBlock* root = proc.addBlock();
 3866     root-&gt;appendNewControlValue(
 3867         proc, Return, Origin(),
 3868         root-&gt;appendNew&lt;Value&gt;(
 3869             proc, SShr, Origin(),
 3870             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3871             root-&gt;appendNew&lt;Value&gt;(
 3872                 proc, Trunc, Origin(),
 3873                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3874 
 3875     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == (a &gt;&gt; b));
 3876 }
 3877 
 3878 void testSShrImms(int64_t a, int64_t b)
 3879 {
 3880     Procedure proc;
 3881     BasicBlock* root = proc.addBlock();
 3882     root-&gt;appendNewControlValue(
 3883         proc, Return, Origin(),
 3884         root-&gt;appendNew&lt;Value&gt;(
 3885             proc, SShr, Origin(),
 3886             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3887             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3888 
 3889     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a &gt;&gt; b));
 3890 }
 3891 
 3892 void testSShrArgImm(int64_t a, int64_t b)
 3893 {
 3894     Procedure proc;
 3895     BasicBlock* root = proc.addBlock();
 3896     root-&gt;appendNewControlValue(
 3897         proc, Return, Origin(),
 3898         root-&gt;appendNew&lt;Value&gt;(
 3899             proc, SShr, Origin(),
 3900             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3901             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3902 
 3903     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == (a &gt;&gt; b));
 3904 }
 3905 
 3906 void testSShrArg32(int32_t a)
 3907 {
 3908     Procedure proc;
 3909     BasicBlock* root = proc.addBlock();
 3910     Value* value = root-&gt;appendNew&lt;Value&gt;(
 3911         proc, Trunc, Origin(),
 3912         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 3913     root-&gt;appendNewControlValue(
 3914         proc, Return, Origin(),
 3915         root-&gt;appendNew&lt;Value&gt;(proc, SShr, Origin(), value, value));
 3916 
 3917     CHECK(compileAndRun&lt;int32_t&gt;(proc, a) == (a &gt;&gt; (a &amp; 31)));
 3918 }
 3919 
 3920 void testSShrArgs32(int32_t a, int32_t b)
 3921 {
 3922     Procedure proc;
 3923     BasicBlock* root = proc.addBlock();
 3924     root-&gt;appendNewControlValue(
 3925         proc, Return, Origin(),
 3926         root-&gt;appendNew&lt;Value&gt;(
 3927             proc, SShr, Origin(),
 3928             root-&gt;appendNew&lt;Value&gt;(
 3929                 proc, Trunc, Origin(),
 3930                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3931             root-&gt;appendNew&lt;Value&gt;(
 3932                 proc, Trunc, Origin(),
 3933                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3934 
 3935     CHECK(compileAndRun&lt;int32_t&gt;(proc, a, b) == (a &gt;&gt; b));
 3936 }
 3937 
 3938 void testSShrImms32(int32_t a, int32_t b)
 3939 {
 3940     Procedure proc;
 3941     BasicBlock* root = proc.addBlock();
 3942     root-&gt;appendNewControlValue(
 3943         proc, Return, Origin(),
 3944         root-&gt;appendNew&lt;Value&gt;(
 3945             proc, SShr, Origin(),
 3946             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 3947             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3948 
 3949     CHECK(compileAndRun&lt;int32_t&gt;(proc) == (a &gt;&gt; b));
 3950 }
 3951 
 3952 void testSShrArgImm32(int32_t a, int32_t b)
 3953 {
 3954     Procedure proc;
 3955     BasicBlock* root = proc.addBlock();
 3956     root-&gt;appendNewControlValue(
 3957         proc, Return, Origin(),
 3958         root-&gt;appendNew&lt;Value&gt;(
 3959             proc, SShr, Origin(),
 3960             root-&gt;appendNew&lt;Value&gt;(
 3961                 proc, Trunc, Origin(),
 3962                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 3963             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3964 
 3965     CHECK(compileAndRun&lt;int32_t&gt;(proc, a) == (a &gt;&gt; b));
 3966 }
 3967 
 3968 void testZShrArgs(uint64_t a, uint64_t b)
 3969 {
 3970     Procedure proc;
 3971     BasicBlock* root = proc.addBlock();
 3972     root-&gt;appendNewControlValue(
 3973         proc, Return, Origin(),
 3974         root-&gt;appendNew&lt;Value&gt;(
 3975             proc, ZShr, Origin(),
 3976             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 3977             root-&gt;appendNew&lt;Value&gt;(
 3978                 proc, Trunc, Origin(),
 3979                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 3980 
 3981     CHECK(compileAndRun&lt;uint64_t&gt;(proc, a, b) == (a &gt;&gt; b));
 3982 }
 3983 
 3984 void testZShrImms(uint64_t a, uint64_t b)
 3985 {
 3986     Procedure proc;
 3987     BasicBlock* root = proc.addBlock();
 3988     root-&gt;appendNewControlValue(
 3989         proc, Return, Origin(),
 3990         root-&gt;appendNew&lt;Value&gt;(
 3991             proc, ZShr, Origin(),
 3992             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 3993             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 3994 
 3995     CHECK(compileAndRun&lt;uint64_t&gt;(proc) == (a &gt;&gt; b));
 3996 }
 3997 
 3998 void testZShrArgImm(uint64_t a, uint64_t b)
 3999 {
 4000     Procedure proc;
 4001     BasicBlock* root = proc.addBlock();
 4002     root-&gt;appendNewControlValue(
 4003         proc, Return, Origin(),
 4004         root-&gt;appendNew&lt;Value&gt;(
 4005             proc, ZShr, Origin(),
 4006             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 4007             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 4008 
 4009     CHECK(compileAndRun&lt;uint64_t&gt;(proc, a) == (a &gt;&gt; b));
 4010 }
 4011 
 4012 void testZShrArg32(uint32_t a)
 4013 {
 4014     Procedure proc;
 4015     BasicBlock* root = proc.addBlock();
 4016     Value* value = root-&gt;appendNew&lt;Value&gt;(
 4017         proc, Trunc, Origin(),
 4018         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4019     root-&gt;appendNewControlValue(
 4020         proc, Return, Origin(),
 4021         root-&gt;appendNew&lt;Value&gt;(proc, ZShr, Origin(), value, value));
 4022 
 4023     CHECK(compileAndRun&lt;uint32_t&gt;(proc, a) == (a &gt;&gt; (a &amp; 31)));
 4024 }
 4025 
 4026 void testZShrArgs32(uint32_t a, uint32_t b)
 4027 {
 4028     Procedure proc;
 4029     BasicBlock* root = proc.addBlock();
 4030     root-&gt;appendNewControlValue(
 4031         proc, Return, Origin(),
 4032         root-&gt;appendNew&lt;Value&gt;(
 4033             proc, ZShr, Origin(),
 4034             root-&gt;appendNew&lt;Value&gt;(
 4035                 proc, Trunc, Origin(),
 4036                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 4037             root-&gt;appendNew&lt;Value&gt;(
 4038                 proc, Trunc, Origin(),
 4039                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
 4040 
 4041     CHECK(compileAndRun&lt;uint32_t&gt;(proc, a, b) == (a &gt;&gt; b));
 4042 }
 4043 
 4044 void testZShrImms32(uint32_t a, uint32_t b)
 4045 {
 4046     Procedure proc;
 4047     BasicBlock* root = proc.addBlock();
 4048     root-&gt;appendNewControlValue(
 4049         proc, Return, Origin(),
 4050         root-&gt;appendNew&lt;Value&gt;(
 4051             proc, ZShr, Origin(),
 4052             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a),
 4053             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 4054 
 4055     CHECK(compileAndRun&lt;uint32_t&gt;(proc) == (a &gt;&gt; b));
 4056 }
 4057 
 4058 void testZShrArgImm32(uint32_t a, uint32_t b)
 4059 {
 4060     Procedure proc;
 4061     BasicBlock* root = proc.addBlock();
 4062     root-&gt;appendNewControlValue(
 4063         proc, Return, Origin(),
 4064         root-&gt;appendNew&lt;Value&gt;(
 4065             proc, ZShr, Origin(),
 4066             root-&gt;appendNew&lt;Value&gt;(
 4067                 proc, Trunc, Origin(),
 4068                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 4069             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b)));
 4070 
 4071     CHECK(compileAndRun&lt;uint32_t&gt;(proc, a) == (a &gt;&gt; b));
 4072 }
 4073 
 4074 template&lt;typename IntegerType&gt;
 4075 static unsigned countLeadingZero(IntegerType value)
 4076 {
 4077     unsigned bitCount = sizeof(IntegerType) * 8;
 4078     if (!value)
 4079         return bitCount;
 4080 
 4081     unsigned counter = 0;
 4082     while (!(static_cast&lt;uint64_t&gt;(value) &amp; (1l &lt;&lt; (bitCount - 1)))) {
 4083         value &lt;&lt;= 1;
 4084         ++counter;
 4085     }
 4086     return counter;
 4087 }
 4088 
 4089 void testClzArg64(int64_t a)
 4090 {
 4091     Procedure proc;
 4092     BasicBlock* root = proc.addBlock();
 4093     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4094     Value* clzValue = root-&gt;appendNew&lt;Value&gt;(proc, Clz, Origin(), argument);
 4095     root-&gt;appendNewControlValue(proc, Return, Origin(), clzValue);
 4096     CHECK(compileAndRun&lt;unsigned&gt;(proc, a) == countLeadingZero(a));
 4097 }
 4098 
 4099 void testClzMem64(int64_t a)
 4100 {
 4101     Procedure proc;
 4102     BasicBlock* root = proc.addBlock();
 4103     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4104     MemoryValue* value = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 4105     Value* clzValue = root-&gt;appendNew&lt;Value&gt;(proc, Clz, Origin(), value);
 4106     root-&gt;appendNewControlValue(proc, Return, Origin(), clzValue);
 4107     CHECK(compileAndRun&lt;unsigned&gt;(proc, &amp;a) == countLeadingZero(a));
 4108 }
 4109 
 4110 void testClzArg32(int32_t a)
 4111 {
 4112     Procedure proc;
 4113     BasicBlock* root = proc.addBlock();
 4114     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4115         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4116     Value* clzValue = root-&gt;appendNew&lt;Value&gt;(proc, Clz, Origin(), argument);
 4117     root-&gt;appendNewControlValue(proc, Return, Origin(), clzValue);
 4118     CHECK(compileAndRun&lt;unsigned&gt;(proc, a) == countLeadingZero(a));
 4119 }
 4120 
 4121 void testClzMem32(int32_t a)
 4122 {
 4123     Procedure proc;
 4124     BasicBlock* root = proc.addBlock();
 4125     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4126     MemoryValue* value = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 4127     Value* clzValue = root-&gt;appendNew&lt;Value&gt;(proc, Clz, Origin(), value);
 4128     root-&gt;appendNewControlValue(proc, Return, Origin(), clzValue);
 4129     CHECK(compileAndRun&lt;unsigned&gt;(proc, &amp;a) == countLeadingZero(a));
 4130 }
 4131 
 4132 void testAbsArg(double a)
 4133 {
 4134     Procedure proc;
 4135     BasicBlock* root = proc.addBlock();
 4136     root-&gt;appendNewControlValue(
 4137         proc, Return, Origin(),
 4138         root-&gt;appendNew&lt;Value&gt;(
 4139             proc, Abs, Origin(),
 4140                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0)));
 4141 
 4142     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), fabs(a)));
 4143 }
 4144 
 4145 void testAbsImm(double a)
 4146 {
 4147     Procedure proc;
 4148     BasicBlock* root = proc.addBlock();
 4149     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 4150     root-&gt;appendNewControlValue(
 4151         proc, Return, Origin(),
 4152         root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argument));
 4153 
 4154     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), fabs(a)));
 4155 }
 4156 
 4157 void testAbsMem(double a)
 4158 {
 4159     Procedure proc;
 4160     BasicBlock* root = proc.addBlock();
 4161     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4162     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 4163     root-&gt;appendNewControlValue(
 4164         proc, Return, Origin(),
 4165         root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), loadDouble));
 4166 
 4167     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;a), fabs(a)));
 4168 }
 4169 
 4170 void testAbsAbsArg(double a)
 4171 {
 4172     Procedure proc;
 4173     BasicBlock* root = proc.addBlock();
 4174     Value* firstAbs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(),
 4175         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4176     Value* secondAbs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), firstAbs);
 4177     root-&gt;appendNewControlValue(proc, Return, Origin(), secondAbs);
 4178 
 4179     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), fabs(fabs(a))));
 4180 }
 4181 
 4182 void testAbsNegArg(double a)
 4183 {
 4184     Procedure proc;
 4185     BasicBlock* root = proc.addBlock();
 4186     Value* neg = root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(),
 4187         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4188     Value* abs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), neg);
 4189     root-&gt;appendNewControlValue(proc, Return, Origin(), abs);
 4190 
 4191     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), fabs(- a)));
 4192 }
 4193 
 4194 void testAbsBitwiseCastArg(double a)
 4195 {
 4196     Procedure proc;
 4197     BasicBlock* root = proc.addBlock();
 4198     Value* argumentAsInt64 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4199     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentAsInt64);
 4200     Value* absValue = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argumentAsDouble);
 4201     root-&gt;appendNewControlValue(proc, Return, Origin(), absValue);
 4202 
 4203     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, bitwise_cast&lt;int64_t&gt;(a)), fabs(a)));
 4204 }
 4205 
 4206 void testBitwiseCastAbsBitwiseCastArg(double a)
 4207 {
 4208     Procedure proc;
 4209     BasicBlock* root = proc.addBlock();
 4210     Value* argumentAsInt64 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4211     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentAsInt64);
 4212     Value* absValue = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argumentAsDouble);
 4213     Value* resultAsInt64 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), absValue);
 4214 
 4215     root-&gt;appendNewControlValue(proc, Return, Origin(), resultAsInt64);
 4216 
 4217     int64_t expectedResult = bitwise_cast&lt;int64_t&gt;(fabs(a));
 4218     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, bitwise_cast&lt;int64_t&gt;(a)), expectedResult));
 4219 }
 4220 
 4221 void testAbsArg(float a)
 4222 {
 4223     Procedure proc;
 4224     BasicBlock* root = proc.addBlock();
 4225     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4226         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4227     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4228     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argument);
 4229     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4230     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4231 
 4232     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)))));
 4233 }
 4234 
 4235 void testAbsImm(float a)
 4236 {
 4237     Procedure proc;
 4238     BasicBlock* root = proc.addBlock();
 4239     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 4240     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argument);
 4241     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4242     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4243 
 4244     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)))));
 4245 }
 4246 
 4247 void testAbsMem(float a)
 4248 {
 4249     Procedure proc;
 4250     BasicBlock* root = proc.addBlock();
 4251     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4252     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 4253     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), loadFloat);
 4254     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4255     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4256 
 4257     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, &amp;a), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)))));
 4258 }
 4259 
 4260 void testAbsAbsArg(float a)
 4261 {
 4262     Procedure proc;
 4263     BasicBlock* root = proc.addBlock();
 4264     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4265         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4266     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4267     Value* firstAbs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argument);
 4268     Value* secondAbs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), firstAbs);
 4269     root-&gt;appendNewControlValue(proc, Return, Origin(), secondAbs);
 4270 
 4271     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), static_cast&lt;float&gt;(fabs(fabs(a)))));
 4272 }
 4273 
 4274 void testAbsNegArg(float a)
 4275 {
 4276     Procedure proc;
 4277     BasicBlock* root = proc.addBlock();
 4278     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4279         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4280     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4281     Value* neg = root-&gt;appendNew&lt;Value&gt;(proc, Neg, Origin(), argument);
 4282     Value* abs = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), neg);
 4283     root-&gt;appendNewControlValue(proc, Return, Origin(), abs);
 4284 
 4285     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), static_cast&lt;float&gt;(fabs(- a))));
 4286 }
 4287 
 4288 void testAbsBitwiseCastArg(float a)
 4289 {
 4290     Procedure proc;
 4291     BasicBlock* root = proc.addBlock();
 4292     Value* argumentAsInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4293         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4294     Value* argumentAsfloat = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentAsInt32);
 4295     Value* absValue = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argumentAsfloat);
 4296     root-&gt;appendNewControlValue(proc, Return, Origin(), absValue);
 4297 
 4298     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), static_cast&lt;float&gt;(fabs(a))));
 4299 }
 4300 
 4301 void testBitwiseCastAbsBitwiseCastArg(float a)
 4302 {
 4303     Procedure proc;
 4304     BasicBlock* root = proc.addBlock();
 4305     Value* argumentAsInt32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4306         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4307     Value* argumentAsfloat = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argumentAsInt32);
 4308     Value* absValue = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), argumentAsfloat);
 4309     Value* resultAsInt64 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), absValue);
 4310 
 4311     root-&gt;appendNewControlValue(proc, Return, Origin(), resultAsInt64);
 4312 
 4313     int32_t expectedResult = bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)));
 4314     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), expectedResult));
 4315 }
 4316 
 4317 void testAbsArgWithUselessDoubleConversion(float a)
 4318 {
 4319     Procedure proc;
 4320     BasicBlock* root = proc.addBlock();
 4321     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4322         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4323     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4324     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4325     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), asDouble);
 4326     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4327     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4328     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4329 
 4330     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)))));
 4331 }
 4332 
 4333 void testAbsArgWithEffectfulDoubleConversion(float a)
 4334 {
 4335     Procedure proc;
 4336     BasicBlock* root = proc.addBlock();
 4337     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4338         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4339     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4340     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4341     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Abs, Origin(), asDouble);
 4342     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4343     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4344     Value* doubleAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 4345     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleAddress);
 4346     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4347 
 4348     double effect = 0;
 4349     int32_t resultValue = compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), &amp;effect);
 4350     CHECK(isIdentical(resultValue, bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(fabs(a)))));
 4351     CHECK(isIdentical(effect, static_cast&lt;double&gt;(fabs(a))));
 4352 }
 4353 
 4354 void testCeilArg(double a)
 4355 {
 4356     Procedure proc;
 4357     BasicBlock* root = proc.addBlock();
 4358     root-&gt;appendNewControlValue(
 4359         proc, Return, Origin(),
 4360         root-&gt;appendNew&lt;Value&gt;(
 4361             proc, Ceil, Origin(),
 4362                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0)));
 4363 
 4364     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), ceil(a)));
 4365 }
 4366 
 4367 void testCeilImm(double a)
 4368 {
 4369     Procedure proc;
 4370     BasicBlock* root = proc.addBlock();
 4371     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 4372     root-&gt;appendNewControlValue(
 4373         proc, Return, Origin(),
 4374         root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argument));
 4375 
 4376     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), ceil(a)));
 4377 }
 4378 
 4379 void testCeilMem(double a)
 4380 {
 4381     Procedure proc;
 4382     BasicBlock* root = proc.addBlock();
 4383     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4384     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 4385     root-&gt;appendNewControlValue(
 4386         proc, Return, Origin(),
 4387         root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), loadDouble));
 4388 
 4389     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;a), ceil(a)));
 4390 }
 4391 
 4392 void testCeilCeilArg(double a)
 4393 {
 4394     Procedure proc;
 4395     BasicBlock* root = proc.addBlock();
 4396     Value* firstCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(),
 4397         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4398     Value* secondCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), firstCeil);
 4399     root-&gt;appendNewControlValue(proc, Return, Origin(), secondCeil);
 4400 
 4401     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), ceil(a)));
 4402 }
 4403 
 4404 void testFloorCeilArg(double a)
 4405 {
 4406     Procedure proc;
 4407     BasicBlock* root = proc.addBlock();
 4408     Value* firstCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(),
 4409         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4410     Value* wrappingFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), firstCeil);
 4411     root-&gt;appendNewControlValue(proc, Return, Origin(), wrappingFloor);
 4412 
 4413     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), ceil(a)));
 4414 }
 4415 
 4416 void testCeilIToD64(int64_t a)
 4417 {
 4418     Procedure proc;
 4419     BasicBlock* root = proc.addBlock();
 4420     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4421     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), argument);
 4422 
 4423     root-&gt;appendNewControlValue(
 4424         proc, Return, Origin(),
 4425         root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argumentAsDouble));
 4426 
 4427     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), ceil(static_cast&lt;double&gt;(a))));
 4428 }
 4429 
 4430 void testCeilIToD32(int64_t a)
 4431 {
 4432     Procedure proc;
 4433     BasicBlock* root = proc.addBlock();
 4434     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4435         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4436     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), argument);
 4437 
 4438     root-&gt;appendNewControlValue(
 4439         proc, Return, Origin(),
 4440         root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argumentAsDouble));
 4441 
 4442     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), ceil(static_cast&lt;double&gt;(a))));
 4443 }
 4444 
 4445 void testCeilArg(float a)
 4446 {
 4447     Procedure proc;
 4448     BasicBlock* root = proc.addBlock();
 4449     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4450         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4451     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4452     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argument);
 4453     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4454     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4455 
 4456     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(ceilf(a))));
 4457 }
 4458 
 4459 void testCeilImm(float a)
 4460 {
 4461     Procedure proc;
 4462     BasicBlock* root = proc.addBlock();
 4463     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 4464     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argument);
 4465     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4466     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4467 
 4468     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(ceilf(a))));
 4469 }
 4470 
 4471 void testCeilMem(float a)
 4472 {
 4473     Procedure proc;
 4474     BasicBlock* root = proc.addBlock();
 4475     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4476     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 4477     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), loadFloat);
 4478     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4479     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4480 
 4481     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, &amp;a), bitwise_cast&lt;int32_t&gt;(ceilf(a))));
 4482 }
 4483 
 4484 void testCeilCeilArg(float a)
 4485 {
 4486     Procedure proc;
 4487     BasicBlock* root = proc.addBlock();
 4488     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4489         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4490     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4491     Value* firstCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argument);
 4492     Value* secondCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), firstCeil);
 4493     root-&gt;appendNewControlValue(proc, Return, Origin(), secondCeil);
 4494 
 4495     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), ceilf(a)));
 4496 }
 4497 
 4498 void testFloorCeilArg(float a)
 4499 {
 4500     Procedure proc;
 4501     BasicBlock* root = proc.addBlock();
 4502     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4503         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4504     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4505     Value* firstCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), argument);
 4506     Value* wrappingFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), firstCeil);
 4507     root-&gt;appendNewControlValue(proc, Return, Origin(), wrappingFloor);
 4508 
 4509     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), ceilf(a)));
 4510 }
 4511 
 4512 void testCeilArgWithUselessDoubleConversion(float a)
 4513 {
 4514     Procedure proc;
 4515     BasicBlock* root = proc.addBlock();
 4516     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4517         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4518     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4519     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4520     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), asDouble);
 4521     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4522     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4523     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4524 
 4525     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(ceilf(a))));
 4526 }
 4527 
 4528 void testCeilArgWithEffectfulDoubleConversion(float a)
 4529 {
 4530     Procedure proc;
 4531     BasicBlock* root = proc.addBlock();
 4532     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4533         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4534     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4535     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4536     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), asDouble);
 4537     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4538     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4539     Value* doubleAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 4540     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleAddress);
 4541     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4542 
 4543     double effect = 0;
 4544     int32_t resultValue = compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), &amp;effect);
 4545     CHECK(isIdentical(resultValue, bitwise_cast&lt;int32_t&gt;(ceilf(a))));
 4546     CHECK(isIdentical(effect, static_cast&lt;double&gt;(ceilf(a))));
 4547 }
 4548 
 4549 void testFloorArg(double a)
 4550 {
 4551     Procedure proc;
 4552     BasicBlock* root = proc.addBlock();
 4553     root-&gt;appendNewControlValue(
 4554         proc, Return, Origin(),
 4555         root-&gt;appendNew&lt;Value&gt;(
 4556             proc, Floor, Origin(),
 4557                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0)));
 4558 
 4559     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), floor(a)));
 4560 }
 4561 
 4562 void testFloorImm(double a)
 4563 {
 4564     Procedure proc;
 4565     BasicBlock* root = proc.addBlock();
 4566     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 4567     root-&gt;appendNewControlValue(
 4568         proc, Return, Origin(),
 4569         root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argument));
 4570 
 4571     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), floor(a)));
 4572 }
 4573 
 4574 void testFloorMem(double a)
 4575 {
 4576     Procedure proc;
 4577     BasicBlock* root = proc.addBlock();
 4578     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4579     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 4580     root-&gt;appendNewControlValue(
 4581         proc, Return, Origin(),
 4582         root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), loadDouble));
 4583 
 4584     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;a), floor(a)));
 4585 }
 4586 
 4587 void testFloorFloorArg(double a)
 4588 {
 4589     Procedure proc;
 4590     BasicBlock* root = proc.addBlock();
 4591     Value* firstFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(),
 4592         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4593     Value* secondFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), firstFloor);
 4594     root-&gt;appendNewControlValue(proc, Return, Origin(), secondFloor);
 4595 
 4596     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), floor(a)));
 4597 }
 4598 
 4599 void testCeilFloorArg(double a)
 4600 {
 4601     Procedure proc;
 4602     BasicBlock* root = proc.addBlock();
 4603     Value* firstFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(),
 4604         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 4605     Value* wrappingCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), firstFloor);
 4606     root-&gt;appendNewControlValue(proc, Return, Origin(), wrappingCeil);
 4607 
 4608     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), floor(a)));
 4609 }
 4610 
 4611 void testFloorIToD64(int64_t a)
 4612 {
 4613     Procedure proc;
 4614     BasicBlock* root = proc.addBlock();
 4615     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4616     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), argument);
 4617 
 4618     root-&gt;appendNewControlValue(
 4619         proc, Return, Origin(),
 4620         root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argumentAsDouble));
 4621 
 4622     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), floor(static_cast&lt;double&gt;(a))));
 4623 }
 4624 
 4625 void testFloorIToD32(int64_t a)
 4626 {
 4627     Procedure proc;
 4628     BasicBlock* root = proc.addBlock();
 4629     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4630         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4631     Value* argumentAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), argument);
 4632 
 4633     root-&gt;appendNewControlValue(
 4634         proc, Return, Origin(),
 4635         root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argumentAsDouble));
 4636 
 4637     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), floor(static_cast&lt;double&gt;(a))));
 4638 }
 4639 
 4640 void testFloorArg(float a)
 4641 {
 4642     Procedure proc;
 4643     BasicBlock* root = proc.addBlock();
 4644     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4645         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4646     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4647     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argument);
 4648     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4649     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4650 
 4651     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(floorf(a))));
 4652 }
 4653 
 4654 void testFloorImm(float a)
 4655 {
 4656     Procedure proc;
 4657     BasicBlock* root = proc.addBlock();
 4658     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 4659     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argument);
 4660     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4661     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4662 
 4663     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(floorf(a))));
 4664 }
 4665 
 4666 void testFloorMem(float a)
 4667 {
 4668     Procedure proc;
 4669     BasicBlock* root = proc.addBlock();
 4670     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4671     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 4672     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), loadFloat);
 4673     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4674     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4675 
 4676     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, &amp;a), bitwise_cast&lt;int32_t&gt;(floorf(a))));
 4677 }
 4678 
 4679 void testFloorFloorArg(float a)
 4680 {
 4681     Procedure proc;
 4682     BasicBlock* root = proc.addBlock();
 4683     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4684         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4685     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4686     Value* firstFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argument);
 4687     Value* secondFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), firstFloor);
 4688     root-&gt;appendNewControlValue(proc, Return, Origin(), secondFloor);
 4689 
 4690     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), floorf(a)));
 4691 }
 4692 
 4693 void testCeilFloorArg(float a)
 4694 {
 4695     Procedure proc;
 4696     BasicBlock* root = proc.addBlock();
 4697     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4698         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4699     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4700     Value* firstFloor = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), argument);
 4701     Value* wrappingCeil = root-&gt;appendNew&lt;Value&gt;(proc, Ceil, Origin(), firstFloor);
 4702     root-&gt;appendNewControlValue(proc, Return, Origin(), wrappingCeil);
 4703 
 4704     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), floorf(a)));
 4705 }
 4706 
 4707 void testFloorArgWithUselessDoubleConversion(float a)
 4708 {
 4709     Procedure proc;
 4710     BasicBlock* root = proc.addBlock();
 4711     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4712         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4713     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4714     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4715     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), asDouble);
 4716     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4717     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4718     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4719 
 4720     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(floorf(a))));
 4721 }
 4722 
 4723 void testFloorArgWithEffectfulDoubleConversion(float a)
 4724 {
 4725     Procedure proc;
 4726     BasicBlock* root = proc.addBlock();
 4727     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4728         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4729     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4730     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4731     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Floor, Origin(), asDouble);
 4732     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4733     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4734     Value* doubleAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 4735     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleAddress);
 4736     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4737 
 4738     double effect = 0;
 4739     int32_t resultValue = compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), &amp;effect);
 4740     CHECK(isIdentical(resultValue, bitwise_cast&lt;int32_t&gt;(floorf(a))));
 4741     CHECK(isIdentical(effect, static_cast&lt;double&gt;(floorf(a))));
 4742 }
 4743 
 4744 double correctSqrt(double value)
 4745 {
 4746 #if CPU(X86) || CPU(X86_64)
 4747     double result;
 4748     asm (&quot;sqrtsd %1, %0&quot; : &quot;=x&quot;(result) : &quot;x&quot;(value));
 4749     return result;
 4750 #else
 4751     return sqrt(value);
 4752 #endif
 4753 }
 4754 
 4755 void testSqrtArg(double a)
 4756 {
 4757     Procedure proc;
 4758     BasicBlock* root = proc.addBlock();
 4759     root-&gt;appendNewControlValue(
 4760         proc, Return, Origin(),
 4761         root-&gt;appendNew&lt;Value&gt;(
 4762             proc, Sqrt, Origin(),
 4763                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0)));
 4764 
 4765     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, a), correctSqrt(a)));
 4766 }
 4767 
 4768 void testSqrtImm(double a)
 4769 {
 4770     Procedure proc;
 4771     BasicBlock* root = proc.addBlock();
 4772     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 4773     root-&gt;appendNewControlValue(
 4774         proc, Return, Origin(),
 4775         root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), argument));
 4776 
 4777     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), correctSqrt(a)));
 4778 }
 4779 
 4780 void testSqrtMem(double a)
 4781 {
 4782     Procedure proc;
 4783     BasicBlock* root = proc.addBlock();
 4784     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4785     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 4786     root-&gt;appendNewControlValue(
 4787         proc, Return, Origin(),
 4788         root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), loadDouble));
 4789 
 4790     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;a), correctSqrt(a)));
 4791 }
 4792 
 4793 void testSqrtArg(float a)
 4794 {
 4795     Procedure proc;
 4796     BasicBlock* root = proc.addBlock();
 4797     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4798         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4799     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4800     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), argument);
 4801     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4802     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4803 
 4804     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(correctSqrt(a)))));
 4805 }
 4806 
 4807 void testSqrtImm(float a)
 4808 {
 4809     Procedure proc;
 4810     BasicBlock* root = proc.addBlock();
 4811     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 4812     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), argument);
 4813     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4814     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4815 
 4816     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(correctSqrt(a)))));
 4817 }
 4818 
 4819 void testSqrtMem(float a)
 4820 {
 4821     Procedure proc;
 4822     BasicBlock* root = proc.addBlock();
 4823     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4824     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 4825     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), loadFloat);
 4826     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), result);
 4827     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4828 
 4829     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, &amp;a), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(correctSqrt(a)))));
 4830 }
 4831 
 4832 void testSqrtArgWithUselessDoubleConversion(float a)
 4833 {
 4834     Procedure proc;
 4835     BasicBlock* root = proc.addBlock();
 4836     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4837         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4838     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4839     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4840     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), asDouble);
 4841     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4842     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4843     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4844 
 4845     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a)), bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(correctSqrt(a)))));
 4846 }
 4847 
 4848 void testSqrtArgWithEffectfulDoubleConversion(float a)
 4849 {
 4850     Procedure proc;
 4851     BasicBlock* root = proc.addBlock();
 4852     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4853         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4854     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4855     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4856     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sqrt, Origin(), asDouble);
 4857     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), result);
 4858     Value* result32 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), floatResult);
 4859     Value* doubleAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 4860     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), result, doubleAddress);
 4861     root-&gt;appendNewControlValue(proc, Return, Origin(), result32);
 4862 
 4863     double effect = 0;
 4864     int32_t resultValue = compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), &amp;effect);
 4865     CHECK(isIdentical(resultValue, bitwise_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(correctSqrt(a)))));
 4866     double expected = static_cast&lt;double&gt;(correctSqrt(a));
 4867     CHECK(isIdentical(effect, expected));
 4868 }
 4869 
 4870 void testCompareTwoFloatToDouble(float a, float b)
 4871 {
 4872     Procedure proc;
 4873     BasicBlock* root = proc.addBlock();
 4874 
 4875     Value* arg1As32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4876         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4877     Value* arg1Float = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), arg1As32);
 4878     Value* arg1AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), arg1Float);
 4879 
 4880     Value* arg2As32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4881         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 4882     Value* arg2Float = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), arg2As32);
 4883     Value* arg2AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), arg2Float);
 4884     Value* equal = root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1AsDouble, arg2AsDouble);
 4885 
 4886     root-&gt;appendNewControlValue(proc, Return, Origin(), equal);
 4887 
 4888     CHECK(compileAndRun&lt;int64_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)) == (a == b));
 4889 }
 4890 
 4891 void testCompareOneFloatToDouble(float a, double b)
 4892 {
 4893     Procedure proc;
 4894     BasicBlock* root = proc.addBlock();
 4895 
 4896     Value* arg1As32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4897         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 4898     Value* arg1Float = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), arg1As32);
 4899     Value* arg1AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), arg1Float);
 4900 
 4901     Value* arg2AsDouble = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 4902     Value* equal = root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1AsDouble, arg2AsDouble);
 4903 
 4904     root-&gt;appendNewControlValue(proc, Return, Origin(), equal);
 4905 
 4906     CHECK(compileAndRun&lt;int64_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), b) == (a == b));
 4907 }
 4908 
 4909 void testCompareFloatToDoubleThroughPhi(float a, float b)
 4910 {
 4911     Procedure proc;
 4912     BasicBlock* root = proc.addBlock();
 4913     BasicBlock* thenCase = proc.addBlock();
 4914     BasicBlock* elseCase = proc.addBlock();
 4915     BasicBlock* tail = proc.addBlock();
 4916 
 4917     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4918 
 4919     Value* arg1As32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4920         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 4921     Value* arg1Float = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), arg1As32);
 4922     Value* arg1AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), arg1Float);
 4923 
 4924     Value* arg2AsDouble = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 4925     Value* arg2AsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), arg2AsDouble);
 4926     Value* arg2AsFRoundedDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), arg2AsFloat);
 4927 
 4928     root-&gt;appendNewControlValue(
 4929         proc, Branch, Origin(),
 4930         condition,
 4931         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 4932 
 4933     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), arg1AsDouble);
 4934     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 4935 
 4936     Value* elseConst = elseCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.);
 4937     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), elseConst);
 4938     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 4939 
 4940     Value* doubleInput = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 4941     thenValue-&gt;setPhi(doubleInput);
 4942     elseValue-&gt;setPhi(doubleInput);
 4943     Value* equal = tail-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), doubleInput, arg2AsFRoundedDouble);
 4944     tail-&gt;appendNewControlValue(proc, Return, Origin(), equal);
 4945 
 4946     auto code = compileProc(proc);
 4947     int32_t integerA = bitwise_cast&lt;int32_t&gt;(a);
 4948     double doubleB = b;
 4949     CHECK(invoke&lt;int64_t&gt;(*code, 1, integerA, doubleB) == (a == b));
 4950     CHECK(invoke&lt;int64_t&gt;(*code, 0, integerA, doubleB) == (b == 0));
 4951 }
 4952 
 4953 void testDoubleToFloatThroughPhi(float value)
 4954 {
 4955     // Simple case of:
 4956     //     if (a) {
 4957     //         x = DoubleAdd(a, b)
 4958     //     else
 4959     //         x = DoubleAdd(a, c)
 4960     //     DoubleToFloat(x)
 4961     //
 4962     // Both Adds can be converted to float add.
 4963     Procedure proc;
 4964     BasicBlock* root = proc.addBlock();
 4965     BasicBlock* thenCase = proc.addBlock();
 4966     BasicBlock* elseCase = proc.addBlock();
 4967     BasicBlock* tail = proc.addBlock();
 4968 
 4969     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 4970     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 4971         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 4972     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 4973     Value* argAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 4974 
 4975     root-&gt;appendNewControlValue(
 4976         proc, Branch, Origin(),
 4977         condition,
 4978         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 4979 
 4980     Value* postitiveConst = thenCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5f);
 4981     Value* thenAdd = thenCase-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), argAsDouble, postitiveConst);
 4982     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), thenAdd);
 4983     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 4984 
 4985     Value* elseConst = elseCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), M_PI);
 4986     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), elseConst);
 4987     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 4988 
 4989     Value* doubleInput = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 4990     thenValue-&gt;setPhi(doubleInput);
 4991     elseValue-&gt;setPhi(doubleInput);
 4992     Value* floatResult = tail-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), doubleInput);
 4993     tail-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 4994 
 4995     auto code = compileProc(proc);
 4996     CHECK(isIdentical(invoke&lt;float&gt;(*code, 1, bitwise_cast&lt;int32_t&gt;(value)), value + 42.5f));
 4997     CHECK(isIdentical(invoke&lt;float&gt;(*code, 0, bitwise_cast&lt;int32_t&gt;(value)), static_cast&lt;float&gt;(M_PI)));
 4998 }
 4999 
 5000 void testReduceFloatToDoubleValidates()
 5001 {
 5002     // Simple case of:
 5003     //     f = DoubleToFloat(Bitcast(argGPR0))
 5004     //     if (a) {
 5005     //         x = FloatConst()
 5006     //     else
 5007     //         x = FloatConst()
 5008     //     p = Phi(x)
 5009     //     a = Mul(p, p)
 5010     //     b = Add(a, f)
 5011     //     c = Add(p, b)
 5012     //     Return(c)
 5013     //
 5014     // This should not crash in the validator after ReduceFloatToDouble.
 5015     Procedure proc;
 5016     BasicBlock* root = proc.addBlock();
 5017     BasicBlock* thenCase = proc.addBlock();
 5018     BasicBlock* elseCase = proc.addBlock();
 5019     BasicBlock* tail = proc.addBlock();
 5020 
 5021     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5022     Value* thingy = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), condition);
 5023     thingy = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), thingy); // Make the phase think it has work to do.
 5024     root-&gt;appendNewControlValue(
 5025         proc, Branch, Origin(),
 5026         condition,
 5027         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 5028 
 5029     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(),
 5030         thenCase-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), 11.5));
 5031     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5032 
 5033     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(),
 5034         elseCase-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), 10.5));
 5035     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5036 
 5037     Value* phi =  tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Float, Origin());
 5038     thenValue-&gt;setPhi(phi);
 5039     elseValue-&gt;setPhi(phi);
 5040     Value* result = tail-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(),
 5041             phi, phi);
 5042     result = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
 5043             result,
 5044             thingy);
 5045     result = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(),
 5046             phi,
 5047             result);
 5048     tail-&gt;appendNewControlValue(proc, Return, Origin(), result);
 5049 
 5050     auto code = compileProc(proc);
 5051     CHECK(isIdentical(invoke&lt;float&gt;(*code, 1), 11.5f * 11.5f + static_cast&lt;float&gt;(bitwise_cast&lt;double&gt;(static_cast&lt;uint64_t&gt;(1))) + 11.5f));
 5052     CHECK(isIdentical(invoke&lt;float&gt;(*code, 0), 10.5f * 10.5f + static_cast&lt;float&gt;(bitwise_cast&lt;double&gt;(static_cast&lt;uint64_t&gt;(0))) + 10.5f));
 5053 }
 5054 
 5055 void testDoubleProducerPhiToFloatConversion(float value)
 5056 {
 5057     Procedure proc;
 5058     BasicBlock* root = proc.addBlock();
 5059     BasicBlock* thenCase = proc.addBlock();
 5060     BasicBlock* elseCase = proc.addBlock();
 5061     BasicBlock* tail = proc.addBlock();
 5062 
 5063     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5064     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5065         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 5066     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 5067 
 5068     root-&gt;appendNewControlValue(
 5069         proc, Branch, Origin(),
 5070         condition,
 5071         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 5072 
 5073     Value* asDouble = thenCase-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5074     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), asDouble);
 5075     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5076 
 5077     Value* constDouble = elseCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5);
 5078     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), constDouble);
 5079     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5080 
 5081     Value* doubleInput = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 5082     thenValue-&gt;setPhi(doubleInput);
 5083     elseValue-&gt;setPhi(doubleInput);
 5084 
 5085     Value* argAsDoubleAgain = tail-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5086     Value* finalAdd = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleInput, argAsDoubleAgain);
 5087     Value* floatResult = tail-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), finalAdd);
 5088     tail-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 5089 
 5090     auto code = compileProc(proc);
 5091     CHECK(isIdentical(invoke&lt;float&gt;(*code, 1, bitwise_cast&lt;int32_t&gt;(value)), value + value));
 5092     CHECK(isIdentical(invoke&lt;float&gt;(*code, 0, bitwise_cast&lt;int32_t&gt;(value)), 42.5f + value));
 5093 }
 5094 
 5095 void testDoubleProducerPhiToFloatConversionWithDoubleConsumer(float value)
 5096 {
 5097     // In this case, the Upsilon-Phi effectively contains a Float value, but it is used
 5098     // as a Float and as a Double.
 5099     Procedure proc;
 5100     BasicBlock* root = proc.addBlock();
 5101     BasicBlock* thenCase = proc.addBlock();
 5102     BasicBlock* elseCase = proc.addBlock();
 5103     BasicBlock* tail = proc.addBlock();
 5104 
 5105     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5106     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5107         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 5108     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 5109 
 5110     root-&gt;appendNewControlValue(
 5111         proc, Branch, Origin(),
 5112         condition,
 5113         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 5114 
 5115     Value* asDouble = thenCase-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5116     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), asDouble);
 5117     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5118 
 5119     Value* constDouble = elseCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5);
 5120     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), constDouble);
 5121     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5122 
 5123     Value* doubleInput = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 5124     thenValue-&gt;setPhi(doubleInput);
 5125     elseValue-&gt;setPhi(doubleInput);
 5126 
 5127     Value* argAsDoubleAgain = tail-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5128     Value* floatAdd = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleInput, argAsDoubleAgain);
 5129 
 5130     // FRound.
 5131     Value* floatResult = tail-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), floatAdd);
 5132     Value* doubleResult = tail-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatResult);
 5133 
 5134     // This one *cannot* be eliminated
 5135     Value* doubleAdd = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleInput, doubleResult);
 5136 
 5137     tail-&gt;appendNewControlValue(proc, Return, Origin(), doubleAdd);
 5138 
 5139     auto code = compileProc(proc);
 5140     CHECK(isIdentical(invoke&lt;double&gt;(*code, 1, bitwise_cast&lt;int32_t&gt;(value)), (value + value) + static_cast&lt;double&gt;(value)));
 5141     CHECK(isIdentical(invoke&lt;double&gt;(*code, 0, bitwise_cast&lt;int32_t&gt;(value)), static_cast&lt;double&gt;((42.5f + value) + 42.5f)));
 5142 }
 5143 
 5144 void testDoubleProducerPhiWithNonFloatConst(float value, double constValue)
 5145 {
 5146     Procedure proc;
 5147     BasicBlock* root = proc.addBlock();
 5148     BasicBlock* thenCase = proc.addBlock();
 5149     BasicBlock* elseCase = proc.addBlock();
 5150     BasicBlock* tail = proc.addBlock();
 5151 
 5152     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5153     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5154         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 5155     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 5156 
 5157     root-&gt;appendNewControlValue(
 5158         proc, Branch, Origin(),
 5159         condition,
 5160         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 5161 
 5162     Value* asDouble = thenCase-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5163     UpsilonValue* thenValue = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), asDouble);
 5164     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5165 
 5166     Value* constDouble = elseCase-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), constValue);
 5167     UpsilonValue* elseValue = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), constDouble);
 5168     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
 5169 
 5170     Value* doubleInput = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 5171     thenValue-&gt;setPhi(doubleInput);
 5172     elseValue-&gt;setPhi(doubleInput);
 5173 
 5174     Value* argAsDoubleAgain = tail-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5175     Value* finalAdd = tail-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleInput, argAsDoubleAgain);
 5176     Value* floatResult = tail-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), finalAdd);
 5177     tail-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 5178 
 5179     auto code = compileProc(proc);
 5180     CHECK(isIdentical(invoke&lt;float&gt;(*code, 1, bitwise_cast&lt;int32_t&gt;(value)), value + value));
 5181     CHECK(isIdentical(invoke&lt;float&gt;(*code, 0, bitwise_cast&lt;int32_t&gt;(value)), static_cast&lt;float&gt;(constValue + value)));
 5182 }
 5183 
 5184 void testDoubleArgToInt64BitwiseCast(double value)
 5185 {
 5186     Procedure proc;
 5187     BasicBlock* root = proc.addBlock();
 5188     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 5189 
 5190     root-&gt;appendNewControlValue(
 5191         proc, Return, Origin(),
 5192         root-&gt;appendNew&lt;Value&gt;(
 5193             proc, BitwiseCast, Origin(), argument));
 5194 
 5195     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, value), bitwise_cast&lt;int64_t&gt;(value)));
 5196 }
 5197 
 5198 void testDoubleImmToInt64BitwiseCast(double value)
 5199 {
 5200     Procedure proc;
 5201     BasicBlock* root = proc.addBlock();
 5202     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), value);
 5203 
 5204     root-&gt;appendNewControlValue(
 5205         proc, Return, Origin(),
 5206         root-&gt;appendNew&lt;Value&gt;(
 5207             proc, BitwiseCast, Origin(), argument));
 5208 
 5209     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc), bitwise_cast&lt;int64_t&gt;(value)));
 5210 }
 5211 
 5212 void testTwoBitwiseCastOnDouble(double value)
 5213 {
 5214     Procedure proc;
 5215     BasicBlock* root = proc.addBlock();
 5216     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 5217     Value* first = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument);
 5218     Value* second = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), first);
 5219     root-&gt;appendNewControlValue(proc, Return, Origin(), second);
 5220 
 5221     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, value), value));
 5222 }
 5223 
 5224 void testBitwiseCastOnDoubleInMemory(double value)
 5225 {
 5226     Procedure proc;
 5227     BasicBlock* root = proc.addBlock();
 5228     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5229     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 5230     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadDouble);
 5231     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5232 
 5233     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, &amp;value), bitwise_cast&lt;int64_t&gt;(value)));
 5234 }
 5235 
 5236 void testBitwiseCastOnDoubleInMemoryIndexed(double value)
 5237 {
 5238     Procedure proc;
 5239     BasicBlock* root = proc.addBlock();
 5240     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5241     Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5242     Value* scaledOffset = root-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(),
 5243         offset,
 5244         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 3));
 5245     Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), base, scaledOffset);
 5246     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 5247     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadDouble);
 5248     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5249 
 5250     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, &amp;value, 0), bitwise_cast&lt;int64_t&gt;(value)));
 5251 }
 5252 
 5253 void testInt64BArgToDoubleBitwiseCast(int64_t value)
 5254 {
 5255     Procedure proc;
 5256     BasicBlock* root = proc.addBlock();
 5257     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5258 
 5259     root-&gt;appendNewControlValue(
 5260         proc, Return, Origin(),
 5261         root-&gt;appendNew&lt;Value&gt;(
 5262             proc, BitwiseCast, Origin(), argument));
 5263 
 5264     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, value), bitwise_cast&lt;double&gt;(value)));
 5265 }
 5266 
 5267 void testInt64BImmToDoubleBitwiseCast(int64_t value)
 5268 {
 5269     Procedure proc;
 5270     BasicBlock* root = proc.addBlock();
 5271     Value* argument = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value);
 5272 
 5273     root-&gt;appendNewControlValue(
 5274         proc, Return, Origin(),
 5275         root-&gt;appendNew&lt;Value&gt;(
 5276             proc, BitwiseCast, Origin(), argument));
 5277 
 5278     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), bitwise_cast&lt;double&gt;(value)));
 5279 }
 5280 
 5281 void testTwoBitwiseCastOnInt64(int64_t value)
 5282 {
 5283     Procedure proc;
 5284     BasicBlock* root = proc.addBlock();
 5285     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5286     Value* first = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument);
 5287     Value* second = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), first);
 5288     root-&gt;appendNewControlValue(proc, Return, Origin(), second);
 5289 
 5290     CHECK(isIdentical(compileAndRun&lt;int64_t&gt;(proc, value), value));
 5291 }
 5292 
 5293 void testBitwiseCastOnInt64InMemory(int64_t value)
 5294 {
 5295     Procedure proc;
 5296     BasicBlock* root = proc.addBlock();
 5297     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5298     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 5299     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadDouble);
 5300     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5301 
 5302     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;value), bitwise_cast&lt;double&gt;(value)));
 5303 }
 5304 
 5305 void testBitwiseCastOnInt64InMemoryIndexed(int64_t value)
 5306 {
 5307     Procedure proc;
 5308     BasicBlock* root = proc.addBlock();
 5309     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5310     Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5311     Value* scaledOffset = root-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(),
 5312         offset,
 5313         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 3));
 5314     Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), base, scaledOffset);
 5315     MemoryValue* loadDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 5316     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadDouble);
 5317     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5318 
 5319     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;value, 0), bitwise_cast&lt;double&gt;(value)));
 5320 }
 5321 
 5322 void testFloatImmToInt32BitwiseCast(float value)
 5323 {
 5324     Procedure proc;
 5325     BasicBlock* root = proc.addBlock();
 5326     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), value);
 5327 
 5328     root-&gt;appendNewControlValue(
 5329         proc, Return, Origin(),
 5330         root-&gt;appendNew&lt;Value&gt;(
 5331             proc, BitwiseCast, Origin(), argument));
 5332 
 5333     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc), bitwise_cast&lt;int32_t&gt;(value)));
 5334 }
 5335 
 5336 void testBitwiseCastOnFloatInMemory(float value)
 5337 {
 5338     Procedure proc;
 5339     BasicBlock* root = proc.addBlock();
 5340     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5341     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 5342     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadFloat);
 5343     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5344 
 5345     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, &amp;value), bitwise_cast&lt;int32_t&gt;(value)));
 5346 }
 5347 
 5348 void testInt32BArgToFloatBitwiseCast(int32_t value)
 5349 {
 5350     Procedure proc;
 5351     BasicBlock* root = proc.addBlock();
 5352     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5353 
 5354     root-&gt;appendNewControlValue(
 5355         proc, Return, Origin(),
 5356         root-&gt;appendNew&lt;Value&gt;(
 5357             proc, BitwiseCast, Origin(), argument));
 5358 
 5359     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, value), bitwise_cast&lt;float&gt;(value)));
 5360 }
 5361 
 5362 void testInt32BImmToFloatBitwiseCast(int32_t value)
 5363 {
 5364     Procedure proc;
 5365     BasicBlock* root = proc.addBlock();
 5366     Value* argument = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value);
 5367 
 5368     root-&gt;appendNewControlValue(
 5369         proc, Return, Origin(),
 5370         root-&gt;appendNew&lt;Value&gt;(
 5371             proc, BitwiseCast, Origin(), argument));
 5372 
 5373     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), bitwise_cast&lt;float&gt;(value)));
 5374 }
 5375 
 5376 void testTwoBitwiseCastOnInt32(int32_t value)
 5377 {
 5378     Procedure proc;
 5379     BasicBlock* root = proc.addBlock();
 5380     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5381     Value* first = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument);
 5382     Value* second = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), first);
 5383     root-&gt;appendNewControlValue(proc, Return, Origin(), second);
 5384 
 5385     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, value), value));
 5386 }
 5387 
 5388 void testBitwiseCastOnInt32InMemory(int32_t value)
 5389 {
 5390     Procedure proc;
 5391     BasicBlock* root = proc.addBlock();
 5392     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5393     MemoryValue* loadFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 5394     Value* cast = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), loadFloat);
 5395     root-&gt;appendNewControlValue(proc, Return, Origin(), cast);
 5396 
 5397     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, &amp;value), bitwise_cast&lt;float&gt;(value)));
 5398 }
 5399 
 5400 void testConvertDoubleToFloatArg(double value)
 5401 {
 5402     Procedure proc;
 5403     BasicBlock* root = proc.addBlock();
 5404     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 5405     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 5406     root-&gt;appendNewControlValue(proc, Return, Origin(), asFloat);
 5407 
 5408     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, value), static_cast&lt;float&gt;(value)));
 5409 }
 5410 
 5411 void testConvertDoubleToFloatImm(double value)
 5412 {
 5413     Procedure proc;
 5414     BasicBlock* root = proc.addBlock();
 5415     Value* argument = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), value);
 5416     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 5417     root-&gt;appendNewControlValue(proc, Return, Origin(), asFloat);
 5418 
 5419     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), static_cast&lt;float&gt;(value)));
 5420 }
 5421 
 5422 void testConvertDoubleToFloatMem(double value)
 5423 {
 5424     Procedure proc;
 5425     BasicBlock* root = proc.addBlock();
 5426     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5427     MemoryValue* loadedDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 5428     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), loadedDouble);
 5429     root-&gt;appendNewControlValue(proc, Return, Origin(), asFloat);
 5430 
 5431     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, &amp;value), static_cast&lt;float&gt;(value)));
 5432 }
 5433 
 5434 void testConvertFloatToDoubleArg(float value)
 5435 {
 5436     Procedure proc;
 5437     BasicBlock* root = proc.addBlock();
 5438     Value* argument32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5439         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5440     Value* floatValue = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument32);
 5441     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue);
 5442     root-&gt;appendNewControlValue(proc, Return, Origin(), asDouble);
 5443 
 5444     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, bitwise_cast&lt;int32_t&gt;(value)), static_cast&lt;double&gt;(value)));
 5445 }
 5446 
 5447 void testConvertFloatToDoubleImm(float value)
 5448 {
 5449     Procedure proc;
 5450     BasicBlock* root = proc.addBlock();
 5451     Value* argument = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), value);
 5452     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argument);
 5453     root-&gt;appendNewControlValue(proc, Return, Origin(), asDouble);
 5454 
 5455     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), static_cast&lt;double&gt;(value)));
 5456 }
 5457 
 5458 void testConvertFloatToDoubleMem(float value)
 5459 {
 5460     Procedure proc;
 5461     BasicBlock* root = proc.addBlock();
 5462     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5463     MemoryValue* loadedFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), address);
 5464     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), loadedFloat);
 5465     root-&gt;appendNewControlValue(proc, Return, Origin(), asDouble);
 5466 
 5467     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;value), static_cast&lt;double&gt;(value)));
 5468 }
 5469 
 5470 void testConvertDoubleToFloatToDoubleToFloat(double value)
 5471 {
 5472     Procedure proc;
 5473     BasicBlock* root = proc.addBlock();
 5474     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 5475     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 5476     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), asFloat);
 5477     Value* asFloatAgain = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), asDouble);
 5478     root-&gt;appendNewControlValue(proc, Return, Origin(), asFloatAgain);
 5479 
 5480     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, value), static_cast&lt;float&gt;(value)));
 5481 }
 5482 
 5483 void testLoadFloatConvertDoubleConvertFloatStoreFloat(float value)
 5484 {
 5485     Procedure proc;
 5486     BasicBlock* root = proc.addBlock();
 5487     Value* src = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5488     Value* dst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5489     MemoryValue* loadedFloat = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(), src);
 5490     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), loadedFloat);
 5491     Value* asFloatAgain = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), asDouble);
 5492     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), asFloatAgain, dst);
 5493 
 5494     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 5495 
 5496     float input = value;
 5497     float output = 0.;
 5498     CHECK(!compileAndRun&lt;int64_t&gt;(proc, &amp;input, &amp;output));
 5499     CHECK(isIdentical(input, output));
 5500 }
 5501 
 5502 void testFroundArg(double value)
 5503 {
 5504     Procedure proc;
 5505     BasicBlock* root = proc.addBlock();
 5506     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 5507     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 5508     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), asFloat);
 5509     root-&gt;appendNewControlValue(proc, Return, Origin(), asDouble);
 5510 
 5511     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, value), static_cast&lt;double&gt;(static_cast&lt;float&gt;(value))));
 5512 }
 5513 
 5514 void testFroundMem(double value)
 5515 {
 5516     Procedure proc;
 5517     BasicBlock* root = proc.addBlock();
 5518     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5519     MemoryValue* loadedDouble = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Double, Origin(), address);
 5520     Value* asFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), loadedDouble);
 5521     Value* asDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), asFloat);
 5522     root-&gt;appendNewControlValue(proc, Return, Origin(), asDouble);
 5523 
 5524     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, &amp;value), static_cast&lt;double&gt;(static_cast&lt;float&gt;(value))));
 5525 }
 5526 
 5527 void testIToD64Arg()
 5528 {
 5529     Procedure proc;
 5530     BasicBlock* root = proc.addBlock();
 5531     Value* src = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5532     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5533     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsDouble);
 5534 
 5535     auto code = compileProc(proc);
 5536     for (auto testValue : int64Operands())
 5537         CHECK(isIdentical(invoke&lt;double&gt;(*code, testValue.value), static_cast&lt;double&gt;(testValue.value)));
 5538 }
 5539 
 5540 void testIToF64Arg()
 5541 {
 5542     Procedure proc;
 5543     BasicBlock* root = proc.addBlock();
 5544     Value* src = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5545     Value* srcAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), src);
 5546     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloat);
 5547 
 5548     auto code = compileProc(proc);
 5549     for (auto testValue : int64Operands())
 5550         CHECK(isIdentical(invoke&lt;float&gt;(*code, testValue.value), static_cast&lt;float&gt;(testValue.value)));
 5551 }
 5552 
 5553 void testIToD32Arg()
 5554 {
 5555     Procedure proc;
 5556     BasicBlock* root = proc.addBlock();
 5557     Value* src = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5558         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5559     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5560     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsDouble);
 5561 
 5562     auto code = compileProc(proc);
 5563     for (auto testValue : int32Operands())
 5564         CHECK(isIdentical(invoke&lt;double&gt;(*code, testValue.value), static_cast&lt;double&gt;(testValue.value)));
 5565 }
 5566 
 5567 void testIToF32Arg()
 5568 {
 5569     Procedure proc;
 5570     BasicBlock* root = proc.addBlock();
 5571     Value* src = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5572         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5573     Value* srcAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), src);
 5574     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloat);
 5575 
 5576     auto code = compileProc(proc);
 5577     for (auto testValue : int32Operands())
 5578         CHECK(isIdentical(invoke&lt;float&gt;(*code, testValue.value), static_cast&lt;float&gt;(testValue.value)));
 5579 }
 5580 
 5581 void testIToD64Mem()
 5582 {
 5583     Procedure proc;
 5584     BasicBlock* root = proc.addBlock();
 5585     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5586     MemoryValue* loadedSrc = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 5587     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), loadedSrc);
 5588     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsDouble);
 5589 
 5590     auto code = compileProc(proc);
 5591     int64_t inMemoryValue;
 5592     for (auto testValue : int64Operands()) {
 5593         inMemoryValue = testValue.value;
 5594         CHECK(isIdentical(invoke&lt;double&gt;(*code, &amp;inMemoryValue), static_cast&lt;double&gt;(testValue.value)));
 5595         CHECK(inMemoryValue == testValue.value);
 5596     }
 5597 }
 5598 
 5599 void testIToF64Mem()
 5600 {
 5601     Procedure proc;
 5602     BasicBlock* root = proc.addBlock();
 5603     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5604     MemoryValue* loadedSrc = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), address);
 5605     Value* srcAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), loadedSrc);
 5606     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloat);
 5607 
 5608     auto code = compileProc(proc);
 5609     int64_t inMemoryValue;
 5610     for (auto testValue : int64Operands()) {
 5611         inMemoryValue = testValue.value;
 5612         CHECK(isIdentical(invoke&lt;float&gt;(*code, &amp;inMemoryValue), static_cast&lt;float&gt;(testValue.value)));
 5613         CHECK(inMemoryValue == testValue.value);
 5614     }
 5615 }
 5616 
 5617 void testIToD32Mem()
 5618 {
 5619     Procedure proc;
 5620     BasicBlock* root = proc.addBlock();
 5621     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5622     MemoryValue* loadedSrc = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 5623     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), loadedSrc);
 5624     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsDouble);
 5625 
 5626     auto code = compileProc(proc);
 5627     int32_t inMemoryValue;
 5628     for (auto testValue : int32Operands()) {
 5629         inMemoryValue = testValue.value;
 5630         CHECK(isIdentical(invoke&lt;double&gt;(*code, &amp;inMemoryValue), static_cast&lt;double&gt;(testValue.value)));
 5631         CHECK(inMemoryValue == testValue.value);
 5632     }
 5633 }
 5634 
 5635 void testIToF32Mem()
 5636 {
 5637     Procedure proc;
 5638     BasicBlock* root = proc.addBlock();
 5639     Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5640     MemoryValue* loadedSrc = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), address);
 5641     Value* srcAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), loadedSrc);
 5642     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloat);
 5643 
 5644     auto code = compileProc(proc);
 5645     int32_t inMemoryValue;
 5646     for (auto testValue : int32Operands()) {
 5647         inMemoryValue = testValue.value;
 5648         CHECK(isIdentical(invoke&lt;float&gt;(*code, &amp;inMemoryValue), static_cast&lt;float&gt;(testValue.value)));
 5649         CHECK(inMemoryValue == testValue.value);
 5650     }
 5651 }
 5652 
 5653 void testIToD64Imm(int64_t value)
 5654 {
 5655     Procedure proc;
 5656     BasicBlock* root = proc.addBlock();
 5657     Value* src = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value);
 5658     Value* srcAsFloatingPoint = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5659     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloatingPoint);
 5660     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), static_cast&lt;double&gt;(value)));
 5661 }
 5662 
 5663 void testIToF64Imm(int64_t value)
 5664 {
 5665     Procedure proc;
 5666     BasicBlock* root = proc.addBlock();
 5667     Value* src = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value);
 5668     Value* srcAsFloatingPoint = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), src);
 5669     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloatingPoint);
 5670     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), static_cast&lt;float&gt;(value)));
 5671 }
 5672 
 5673 void testIToD32Imm(int32_t value)
 5674 {
 5675     Procedure proc;
 5676     BasicBlock* root = proc.addBlock();
 5677     Value* src = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value);
 5678     Value* srcAsFloatingPoint = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5679     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloatingPoint);
 5680     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), static_cast&lt;double&gt;(value)));
 5681 }
 5682 
 5683 void testIToF32Imm(int32_t value)
 5684 {
 5685     Procedure proc;
 5686     BasicBlock* root = proc.addBlock();
 5687     Value* src = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value);
 5688     Value* srcAsFloatingPoint = root-&gt;appendNew&lt;Value&gt;(proc, IToF, Origin(), src);
 5689     root-&gt;appendNewControlValue(proc, Return, Origin(), srcAsFloatingPoint);
 5690     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), static_cast&lt;float&gt;(value)));
 5691 }
 5692 
 5693 void testIToDReducedToIToF64Arg()
 5694 {
 5695     Procedure proc;
 5696     BasicBlock* root = proc.addBlock();
 5697     Value* src = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5698     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5699     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), srcAsDouble);
 5700     root-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 5701 
 5702     auto code = compileProc(proc);
 5703     for (auto testValue : int64Operands())
 5704         CHECK(isIdentical(invoke&lt;float&gt;(*code, testValue.value), static_cast&lt;float&gt;(testValue.value)));
 5705 }
 5706 
 5707 void testIToDReducedToIToF32Arg()
 5708 {
 5709     Procedure proc;
 5710     BasicBlock* root = proc.addBlock();
 5711     Value* src = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5712         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5713     Value* srcAsDouble = root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), src);
 5714     Value* floatResult = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), srcAsDouble);
 5715     root-&gt;appendNewControlValue(proc, Return, Origin(), floatResult);
 5716 
 5717     auto code = compileProc(proc);
 5718     for (auto testValue : int32Operands())
 5719         CHECK(isIdentical(invoke&lt;float&gt;(*code, testValue.value), static_cast&lt;float&gt;(testValue.value)));
 5720 }
 5721 
 5722 void testStore32(int value)
 5723 {
 5724     Procedure proc;
 5725     BasicBlock* root = proc.addBlock();
 5726     int slot = 0xbaadbeef;
 5727     root-&gt;appendNew&lt;MemoryValue&gt;(
 5728         proc, Store, Origin(),
 5729         root-&gt;appendNew&lt;Value&gt;(
 5730             proc, Trunc, Origin(),
 5731             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 5732         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot), 0);
 5733     root-&gt;appendNewControlValue(
 5734         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 5735 
 5736     CHECK(!compileAndRun&lt;int&gt;(proc, value));
 5737     CHECK(slot == value);
 5738 }
 5739 
 5740 void testStoreConstant(int value)
 5741 {
 5742     Procedure proc;
 5743     BasicBlock* root = proc.addBlock();
 5744     int slot = 0xbaadbeef;
 5745     root-&gt;appendNew&lt;MemoryValue&gt;(
 5746         proc, Store, Origin(),
 5747         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value),
 5748         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot), 0);
 5749     root-&gt;appendNewControlValue(
 5750         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 5751 
 5752     CHECK(!compileAndRun&lt;int&gt;(proc));
 5753     CHECK(slot == value);
 5754 }
 5755 
 5756 void testStoreConstantPtr(intptr_t value)
 5757 {
 5758     Procedure proc;
 5759     BasicBlock* root = proc.addBlock();
 5760     intptr_t slot;
 5761 #if CPU(ADDRESS64)
 5762     slot = (static_cast&lt;intptr_t&gt;(0xbaadbeef) &lt;&lt; 32) + static_cast&lt;intptr_t&gt;(0xbaadbeef);
 5763 #else
 5764     slot = 0xbaadbeef;
 5765 #endif
 5766     root-&gt;appendNew&lt;MemoryValue&gt;(
 5767         proc, Store, Origin(),
 5768         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), value),
 5769         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot), 0);
 5770     root-&gt;appendNewControlValue(
 5771         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 5772 
 5773     CHECK(!compileAndRun&lt;int&gt;(proc));
 5774     CHECK(slot == value);
 5775 }
 5776 
 5777 void testStore8Arg()
 5778 {
 5779     { // Direct addressing.
 5780         Procedure proc;
 5781         BasicBlock* root = proc.addBlock();
 5782 
 5783         Value* value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5784             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5785         Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5786 
 5787         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store8, Origin(), value, address);
 5788         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5789 
 5790         int8_t storage = 0;
 5791         CHECK(compileAndRun&lt;int64_t&gt;(proc, 42, &amp;storage) == 42);
 5792         CHECK(storage == 42);
 5793     }
 5794 
 5795     { // Indexed addressing.
 5796         Procedure proc;
 5797         BasicBlock* root = proc.addBlock();
 5798 
 5799         Value* value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5800             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5801         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5802         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 5803         Value* displacement = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1);
 5804 
 5805         Value* baseDisplacement = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), displacement, base);
 5806         Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), baseDisplacement, offset);
 5807 
 5808         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store8, Origin(), value, address);
 5809         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5810 
 5811         int8_t storage = 0;
 5812         CHECK(compileAndRun&lt;int64_t&gt;(proc, 42, &amp;storage, 1) == 42);
 5813         CHECK(storage == 42);
 5814     }
 5815 }
 5816 
 5817 void testStore8Imm()
 5818 {
 5819     { // Direct addressing.
 5820         Procedure proc;
 5821         BasicBlock* root = proc.addBlock();
 5822 
 5823         Value* value = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 5824         Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5825 
 5826         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store8, Origin(), value, address);
 5827         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5828 
 5829         int8_t storage = 0;
 5830         CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;storage) == 42);
 5831         CHECK(storage == 42);
 5832     }
 5833 
 5834     { // Indexed addressing.
 5835         Procedure proc;
 5836         BasicBlock* root = proc.addBlock();
 5837 
 5838         Value* value = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 5839         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5840         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5841         Value* displacement = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1);
 5842 
 5843         Value* baseDisplacement = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), displacement, base);
 5844         Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), baseDisplacement, offset);
 5845 
 5846         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store8, Origin(), value, address);
 5847         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5848 
 5849         int8_t storage = 0;
 5850         CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;storage, 1) == 42);
 5851         CHECK(storage == 42);
 5852     }
 5853 }
 5854 
 5855 void testStorePartial8BitRegisterOnX86()
 5856 {
 5857     Procedure proc;
 5858     BasicBlock* root = proc.addBlock();
 5859 
 5860     // We want to have this in ECX.
 5861     Value* returnValue = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5862 
 5863     // We want this suck in EDX.
 5864     Value* whereToStore = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5865 
 5866     // The patch point is there to help us force the hand of the compiler.
 5867     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 5868 
 5869     // For the value above to be materialized and give the allocator
 5870     // a stronger insentive to name those register the way we need.
 5871     patchpoint-&gt;append(ConstrainedValue(returnValue, ValueRep(GPRInfo::regT3)));
 5872     patchpoint-&gt;append(ConstrainedValue(whereToStore, ValueRep(GPRInfo::regT2)));
 5873 
 5874     // We&#39;ll produce EDI.
 5875     patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::regT6);
 5876 
 5877     // Give the allocator a good reason not to use any other register.
 5878     RegisterSet clobberSet = RegisterSet::allGPRs();
 5879     clobberSet.exclude(RegisterSet::stackRegisters());
 5880     clobberSet.exclude(RegisterSet::reservedHardwareRegisters());
 5881     clobberSet.clear(GPRInfo::regT3);
 5882     clobberSet.clear(GPRInfo::regT2);
 5883     clobberSet.clear(GPRInfo::regT6);
 5884     patchpoint-&gt;clobberLate(clobberSet);
 5885 
 5886     // Set EDI.
 5887     patchpoint-&gt;setGenerator(
 5888         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 5889             AllowMacroScratchRegisterUsage allowScratch(jit);
 5890             jit.xor64(params[0].gpr(), params[0].gpr());
 5891         });
 5892 
 5893     // If everything went well, we should have the big number in eax,
 5894     // patchpoint == EDI and whereToStore = EDX.
 5895     // Since EDI == 5, and AH = 5 on 8 bit store, this would go wrong
 5896     // if we use X86 partial registers.
 5897     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store8, Origin(), patchpoint, whereToStore);
 5898 
 5899     root-&gt;appendNewControlValue(proc, Return, Origin(), returnValue);
 5900 
 5901     int8_t storage = 0xff;
 5902     CHECK(compileAndRun&lt;int64_t&gt;(proc, 0x12345678abcdef12, &amp;storage) == 0x12345678abcdef12);
 5903     CHECK(!storage);
 5904 }
 5905 
 5906 void testStore16Arg()
 5907 {
 5908     { // Direct addressing.
 5909         Procedure proc;
 5910         BasicBlock* root = proc.addBlock();
 5911 
 5912         Value* value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5913             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5914         Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5915 
 5916         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store16, Origin(), value, address);
 5917         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5918 
 5919         int16_t storage = -1;
 5920         CHECK(compileAndRun&lt;int64_t&gt;(proc, 42, &amp;storage) == 42);
 5921         CHECK(storage == 42);
 5922     }
 5923 
 5924     { // Indexed addressing.
 5925         Procedure proc;
 5926         BasicBlock* root = proc.addBlock();
 5927 
 5928         Value* value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
 5929             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 5930         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5931         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 5932         Value* displacement = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1);
 5933 
 5934         Value* baseDisplacement = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), displacement, base);
 5935         Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), baseDisplacement, offset);
 5936 
 5937         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store16, Origin(), value, address);
 5938         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5939 
 5940         int16_t storage = -1;
 5941         CHECK(compileAndRun&lt;int64_t&gt;(proc, 42, &amp;storage, 1) == 42);
 5942         CHECK(storage == 42);
 5943     }
 5944 }
 5945 
 5946 void testStore16Imm()
 5947 {
 5948     { // Direct addressing.
 5949         Procedure proc;
 5950         BasicBlock* root = proc.addBlock();
 5951 
 5952         Value* value = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 5953         Value* address = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5954 
 5955         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store16, Origin(), value, address);
 5956         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5957 
 5958         int16_t storage = -1;
 5959         CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;storage) == 42);
 5960         CHECK(storage == 42);
 5961     }
 5962 
 5963     { // Indexed addressing.
 5964         Procedure proc;
 5965         BasicBlock* root = proc.addBlock();
 5966 
 5967         Value* value = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 5968         Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 5969         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 5970         Value* displacement = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1);
 5971 
 5972         Value* baseDisplacement = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), displacement, base);
 5973         Value* address = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), baseDisplacement, offset);
 5974 
 5975         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store16, Origin(), value, address);
 5976         root-&gt;appendNewControlValue(proc, Return, Origin(), value);
 5977 
 5978         int16_t storage = -1;
 5979         CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;storage, 1) == 42);
 5980         CHECK(storage == 42);
 5981     }
 5982 }
 5983 
 5984 void testTrunc(int64_t value)
 5985 {
 5986     Procedure proc;
 5987     BasicBlock* root = proc.addBlock();
 5988     root-&gt;appendNewControlValue(
 5989         proc, Return, Origin(),
 5990         root-&gt;appendNew&lt;Value&gt;(
 5991             proc, Trunc, Origin(),
 5992             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 5993 
 5994     CHECK(compileAndRun&lt;int&gt;(proc, value) == static_cast&lt;int&gt;(value));
 5995 }
 5996 
 5997 void testAdd1(int value)
 5998 {
 5999     Procedure proc;
 6000     BasicBlock* root = proc.addBlock();
 6001     root-&gt;appendNewControlValue(
 6002         proc, Return, Origin(),
 6003         root-&gt;appendNew&lt;Value&gt;(
 6004             proc, Add, Origin(),
 6005             root-&gt;appendNew&lt;Value&gt;(
 6006                 proc, Trunc, Origin(),
 6007                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 6008             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 6009 
 6010     CHECK(compileAndRun&lt;int&gt;(proc, value) == value + 1);
 6011 }
 6012 
 6013 void testAdd1Ptr(intptr_t value)
 6014 {
 6015     Procedure proc;
 6016     BasicBlock* root = proc.addBlock();
 6017     root-&gt;appendNewControlValue(
 6018         proc, Return, Origin(),
 6019         root-&gt;appendNew&lt;Value&gt;(
 6020             proc, Add, Origin(),
 6021             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 6022             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 1)));
 6023 
 6024     CHECK(compileAndRun&lt;intptr_t&gt;(proc, value) == value + 1);
 6025 }
 6026 
 6027 void testNeg32(int32_t value)
 6028 {
 6029     Procedure proc;
 6030     BasicBlock* root = proc.addBlock();
 6031     root-&gt;appendNewControlValue(
 6032         proc, Return, Origin(),
 6033         root-&gt;appendNew&lt;Value&gt;(
 6034             proc, Sub, Origin(),
 6035             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 6036             root-&gt;appendNew&lt;Value&gt;(
 6037                 proc, Trunc, Origin(),
 6038                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 6039 
 6040     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == -value);
 6041 }
 6042 
 6043 void testNegPtr(intptr_t value)
 6044 {
 6045     Procedure proc;
 6046     BasicBlock* root = proc.addBlock();
 6047     root-&gt;appendNewControlValue(
 6048         proc, Return, Origin(),
 6049         root-&gt;appendNew&lt;Value&gt;(
 6050             proc, Sub, Origin(),
 6051             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0),
 6052             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 6053 
 6054     CHECK(compileAndRun&lt;intptr_t&gt;(proc, value) == -value);
 6055 }
 6056 
 6057 void testStoreAddLoad32(int amount)
 6058 {
 6059     Procedure proc;
 6060     BasicBlock* root = proc.addBlock();
 6061     int slot = 37;
 6062     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6063     root-&gt;appendNew&lt;MemoryValue&gt;(
 6064         proc, Store, Origin(),
 6065         root-&gt;appendNew&lt;Value&gt;(
 6066             proc, Add, Origin(),
 6067             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6068             root-&gt;appendNew&lt;Value&gt;(
 6069                 proc, Trunc, Origin(),
 6070                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6071         slotPtr, 0);
 6072     root-&gt;appendNewControlValue(
 6073         proc, Return, Origin(),
 6074         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6075 
 6076     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6077     CHECK(slot == 37 + amount);
 6078 }
 6079 
 6080 void testStoreRelAddLoadAcq32(int amount)
 6081 {
 6082     Procedure proc;
 6083     BasicBlock* root = proc.addBlock();
 6084     int slot = 37;
 6085     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6086     root-&gt;appendNew&lt;MemoryValue&gt;(
 6087         proc, Store, Origin(),
 6088         root-&gt;appendNew&lt;Value&gt;(
 6089             proc, Add, Origin(),
 6090             root-&gt;appendNew&lt;MemoryValue&gt;(
 6091                 proc, Load, Int32, Origin(), slotPtr, 0, HeapRange(42), HeapRange(42)),
 6092             root-&gt;appendNew&lt;Value&gt;(
 6093                 proc, Trunc, Origin(),
 6094                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6095         slotPtr, 0, HeapRange(42), HeapRange(42));
 6096     root-&gt;appendNewControlValue(
 6097         proc, Return, Origin(),
 6098         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6099 
 6100     auto code = compileProc(proc);
 6101     if (isARM64()) {
 6102         checkUsesInstruction(*code, &quot;lda&quot;);
 6103         checkUsesInstruction(*code, &quot;stl&quot;);
 6104     }
 6105     if (isX86())
 6106         checkUsesInstruction(*code, &quot;xchg&quot;);
 6107     CHECK(!invoke&lt;int&gt;(*code, amount));
 6108     CHECK(slot == 37 + amount);
 6109 }
 6110 
 6111 void testStoreAddLoadImm32(int amount)
 6112 {
 6113     Procedure proc;
 6114     BasicBlock* root = proc.addBlock();
 6115     int slot = 37;
 6116     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6117     root-&gt;appendNew&lt;MemoryValue&gt;(
 6118         proc, Store, Origin(),
 6119         root-&gt;appendNew&lt;Value&gt;(
 6120             proc, Add, Origin(),
 6121             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6122             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6123         slotPtr, 0);
 6124     root-&gt;appendNewControlValue(
 6125         proc, Return, Origin(),
 6126         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6127 
 6128     CHECK(!compileAndRun&lt;int&gt;(proc));
 6129     CHECK(slot == 37 + amount);
 6130 }
 6131 
 6132 void testStoreAddLoad8(int amount, B3::Opcode loadOpcode)
 6133 {
 6134     Procedure proc;
 6135     BasicBlock* root = proc.addBlock();
 6136     int8_t slot = 37;
 6137     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6138     root-&gt;appendNew&lt;MemoryValue&gt;(
 6139         proc, Store8, Origin(),
 6140         root-&gt;appendNew&lt;Value&gt;(
 6141             proc, Add, Origin(),
 6142             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6143             root-&gt;appendNew&lt;Value&gt;(
 6144                 proc, Trunc, Origin(),
 6145                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6146         slotPtr, 0);
 6147     root-&gt;appendNewControlValue(
 6148         proc, Return, Origin(),
 6149         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6150 
 6151     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6152     CHECK(slot == 37 + amount);
 6153 }
 6154 
 6155 void testStoreRelAddLoadAcq8(int amount, B3::Opcode loadOpcode)
 6156 {
 6157     Procedure proc;
 6158     BasicBlock* root = proc.addBlock();
 6159     int8_t slot = 37;
 6160     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6161     root-&gt;appendNew&lt;MemoryValue&gt;(
 6162         proc, Store8, Origin(),
 6163         root-&gt;appendNew&lt;Value&gt;(
 6164             proc, Add, Origin(),
 6165             root-&gt;appendNew&lt;MemoryValue&gt;(
 6166                 proc, loadOpcode, Origin(), slotPtr, 0, HeapRange(42), HeapRange(42)),
 6167             root-&gt;appendNew&lt;Value&gt;(
 6168                 proc, Trunc, Origin(),
 6169                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6170         slotPtr, 0, HeapRange(42), HeapRange(42));
 6171     root-&gt;appendNewControlValue(
 6172         proc, Return, Origin(),
 6173         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6174 
 6175     auto code = compileProc(proc);
 6176     if (isARM64()) {
 6177         checkUsesInstruction(*code, &quot;lda&quot;);
 6178         checkUsesInstruction(*code, &quot;stl&quot;);
 6179     }
 6180     if (isX86())
 6181         checkUsesInstruction(*code, &quot;xchg&quot;);
 6182     CHECK(!invoke&lt;int&gt;(*code, amount));
 6183     CHECK(slot == 37 + amount);
 6184 }
 6185 
 6186 void testStoreRelAddFenceLoadAcq8(int amount, B3::Opcode loadOpcode)
 6187 {
 6188     Procedure proc;
 6189     BasicBlock* root = proc.addBlock();
 6190     int8_t slot = 37;
 6191     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6192     Value* loadedValue = root-&gt;appendNew&lt;MemoryValue&gt;(
 6193         proc, loadOpcode, Origin(), slotPtr, 0, HeapRange(42), HeapRange(42));
 6194     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 6195     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 6196     patchpoint-&gt;setGenerator(
 6197         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
 6198             AllowMacroScratchRegisterUsage allowScratch(jit);
 6199             jit.store8(CCallHelpers::TrustedImm32(0xbeef), &amp;slot);
 6200         });
 6201     patchpoint-&gt;effects = Effects::none();
 6202     patchpoint-&gt;effects.fence = true;
 6203     root-&gt;appendNew&lt;MemoryValue&gt;(
 6204         proc, Store8, Origin(),
 6205         root-&gt;appendNew&lt;Value&gt;(
 6206             proc, Add, Origin(),
 6207             loadedValue,
 6208             root-&gt;appendNew&lt;Value&gt;(
 6209                 proc, Trunc, Origin(),
 6210                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6211         slotPtr, 0, HeapRange(42), HeapRange(42));
 6212     root-&gt;appendNewControlValue(
 6213         proc, Return, Origin(),
 6214         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6215 
 6216     auto code = compileProc(proc);
 6217     if (isARM64()) {
 6218         checkUsesInstruction(*code, &quot;lda&quot;);
 6219         checkUsesInstruction(*code, &quot;stl&quot;);
 6220     }
 6221     if (isX86())
 6222         checkUsesInstruction(*code, &quot;xchg&quot;);
 6223     CHECK(!invoke&lt;int&gt;(*code, amount));
 6224     CHECK(slot == 37 + amount);
 6225 }
 6226 
 6227 void testStoreAddLoadImm8(int amount, B3::Opcode loadOpcode)
 6228 {
 6229     Procedure proc;
 6230     BasicBlock* root = proc.addBlock();
 6231     int8_t slot = 37;
 6232     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6233     root-&gt;appendNew&lt;MemoryValue&gt;(
 6234         proc, Store8, Origin(),
 6235         root-&gt;appendNew&lt;Value&gt;(
 6236             proc, Add, Origin(),
 6237             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6238             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6239         slotPtr, 0);
 6240     root-&gt;appendNewControlValue(
 6241         proc, Return, Origin(),
 6242         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6243 
 6244     CHECK(!compileAndRun&lt;int&gt;(proc));
 6245     CHECK(slot == 37 + amount);
 6246 }
 6247 
 6248 void testStoreAddLoad16(int amount, B3::Opcode loadOpcode)
 6249 {
 6250     Procedure proc;
 6251     BasicBlock* root = proc.addBlock();
 6252     int16_t slot = 37;
 6253     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6254     root-&gt;appendNew&lt;MemoryValue&gt;(
 6255         proc, Store16, Origin(),
 6256         root-&gt;appendNew&lt;Value&gt;(
 6257             proc, Add, Origin(),
 6258             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6259             root-&gt;appendNew&lt;Value&gt;(
 6260                 proc, Trunc, Origin(),
 6261                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6262         slotPtr, 0);
 6263     root-&gt;appendNewControlValue(
 6264         proc, Return, Origin(),
 6265         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6266 
 6267     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6268     CHECK(slot == 37 + amount);
 6269 }
 6270 
 6271 void testStoreRelAddLoadAcq16(int amount, B3::Opcode loadOpcode)
 6272 {
 6273     Procedure proc;
 6274     BasicBlock* root = proc.addBlock();
 6275     int16_t slot = 37;
 6276     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6277     root-&gt;appendNew&lt;MemoryValue&gt;(
 6278         proc, Store16, Origin(),
 6279         root-&gt;appendNew&lt;Value&gt;(
 6280             proc, Add, Origin(),
 6281             root-&gt;appendNew&lt;MemoryValue&gt;(
 6282                 proc, loadOpcode, Origin(), slotPtr, 0, HeapRange(42), HeapRange(42)),
 6283             root-&gt;appendNew&lt;Value&gt;(
 6284                 proc, Trunc, Origin(),
 6285                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6286         slotPtr, 0, HeapRange(42), HeapRange(42));
 6287     root-&gt;appendNewControlValue(
 6288         proc, Return, Origin(),
 6289         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6290 
 6291     auto code = compileProc(proc);
 6292     if (isARM64()) {
 6293         checkUsesInstruction(*code, &quot;lda&quot;);
 6294         checkUsesInstruction(*code, &quot;stl&quot;);
 6295     }
 6296     if (isX86())
 6297         checkUsesInstruction(*code, &quot;xchg&quot;);
 6298     CHECK(!invoke&lt;int&gt;(*code, amount));
 6299     CHECK(slot == 37 + amount);
 6300 }
 6301 
 6302 void testStoreAddLoadImm16(int amount, B3::Opcode loadOpcode)
 6303 {
 6304     Procedure proc;
 6305     BasicBlock* root = proc.addBlock();
 6306     int16_t slot = 37;
 6307     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6308     root-&gt;appendNew&lt;MemoryValue&gt;(
 6309         proc, Store16, Origin(),
 6310         root-&gt;appendNew&lt;Value&gt;(
 6311             proc, Add, Origin(),
 6312             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6313             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6314         slotPtr, 0);
 6315     root-&gt;appendNewControlValue(
 6316         proc, Return, Origin(),
 6317         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6318 
 6319     CHECK(!compileAndRun&lt;int&gt;(proc));
 6320     CHECK(slot == 37 + amount);
 6321 }
 6322 
 6323 void testStoreAddLoad64(int amount)
 6324 {
 6325     Procedure proc;
 6326     BasicBlock* root = proc.addBlock();
 6327     int64_t slot = 37000000000ll;
 6328     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6329     root-&gt;appendNew&lt;MemoryValue&gt;(
 6330         proc, Store, Origin(),
 6331         root-&gt;appendNew&lt;Value&gt;(
 6332             proc, Add, Origin(),
 6333             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), slotPtr),
 6334             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 6335         slotPtr, 0);
 6336     root-&gt;appendNewControlValue(
 6337         proc, Return, Origin(),
 6338         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6339 
 6340     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6341     CHECK(slot == 37000000000ll + amount);
 6342 }
 6343 
 6344 void testStoreRelAddLoadAcq64(int amount)
 6345 {
 6346     Procedure proc;
 6347     BasicBlock* root = proc.addBlock();
 6348     int64_t slot = 37000000000ll;
 6349     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6350     root-&gt;appendNew&lt;MemoryValue&gt;(
 6351         proc, Store, Origin(),
 6352         root-&gt;appendNew&lt;Value&gt;(
 6353             proc, Add, Origin(),
 6354             root-&gt;appendNew&lt;MemoryValue&gt;(
 6355                 proc, Load, Int64, Origin(), slotPtr, 0, HeapRange(42), HeapRange(42)),
 6356             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 6357         slotPtr, 0, HeapRange(42), HeapRange(42));
 6358     root-&gt;appendNewControlValue(
 6359         proc, Return, Origin(),
 6360         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6361 
 6362     auto code = compileProc(proc);
 6363     if (isARM64()) {
 6364         checkUsesInstruction(*code, &quot;lda&quot;);
 6365         checkUsesInstruction(*code, &quot;stl&quot;);
 6366     }
 6367     if (isX86())
 6368         checkUsesInstruction(*code, &quot;xchg&quot;);
 6369     CHECK(!invoke&lt;int&gt;(*code, amount));
 6370     CHECK(slot == 37000000000ll + amount);
 6371 }
 6372 
 6373 void testStoreAddLoadImm64(int64_t amount)
 6374 {
 6375     Procedure proc;
 6376     BasicBlock* root = proc.addBlock();
 6377     int64_t slot = 370000000000ll;
 6378     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6379     root-&gt;appendNew&lt;MemoryValue&gt;(
 6380         proc, Store, Origin(),
 6381         root-&gt;appendNew&lt;Value&gt;(
 6382             proc, Add, Origin(),
 6383             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), slotPtr),
 6384             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), amount)),
 6385         slotPtr, 0);
 6386     root-&gt;appendNewControlValue(
 6387         proc, Return, Origin(),
 6388         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6389 
 6390     CHECK(!compileAndRun&lt;int&gt;(proc));
 6391     CHECK(slot == 370000000000ll + amount);
 6392 }
 6393 
 6394 void testStoreAddLoad32Index(int amount)
 6395 {
 6396     Procedure proc;
 6397     BasicBlock* root = proc.addBlock();
 6398     int slot = 37;
 6399     int* ptr = &amp;slot;
 6400     intptr_t zero = 0;
 6401     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6402         proc, Add, Origin(),
 6403         root-&gt;appendNew&lt;MemoryValue&gt;(
 6404             proc, Load, pointerType(), Origin(),
 6405             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6406         root-&gt;appendNew&lt;MemoryValue&gt;(
 6407             proc, Load, pointerType(), Origin(),
 6408             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6409     root-&gt;appendNew&lt;MemoryValue&gt;(
 6410         proc, Store, Origin(),
 6411         root-&gt;appendNew&lt;Value&gt;(
 6412             proc, Add, Origin(),
 6413             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6414             root-&gt;appendNew&lt;Value&gt;(
 6415                 proc, Trunc, Origin(),
 6416                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6417         slotPtr, 0);
 6418     root-&gt;appendNewControlValue(
 6419         proc, Return, Origin(),
 6420         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6421 
 6422     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6423     CHECK(slot == 37 + amount);
 6424 }
 6425 
 6426 void testStoreAddLoadImm32Index(int amount)
 6427 {
 6428     Procedure proc;
 6429     BasicBlock* root = proc.addBlock();
 6430     int slot = 37;
 6431     int* ptr = &amp;slot;
 6432     intptr_t zero = 0;
 6433     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6434         proc, Add, Origin(),
 6435         root-&gt;appendNew&lt;MemoryValue&gt;(
 6436             proc, Load, pointerType(), Origin(),
 6437             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6438         root-&gt;appendNew&lt;MemoryValue&gt;(
 6439             proc, Load, pointerType(), Origin(),
 6440             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6441     root-&gt;appendNew&lt;MemoryValue&gt;(
 6442         proc, Store, Origin(),
 6443         root-&gt;appendNew&lt;Value&gt;(
 6444             proc, Add, Origin(),
 6445             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6446             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6447         slotPtr, 0);
 6448     root-&gt;appendNewControlValue(
 6449         proc, Return, Origin(),
 6450         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6451 
 6452     CHECK(!compileAndRun&lt;int&gt;(proc));
 6453     CHECK(slot == 37 + amount);
 6454 }
 6455 
 6456 void testStoreAddLoad8Index(int amount, B3::Opcode loadOpcode)
 6457 {
 6458     Procedure proc;
 6459     BasicBlock* root = proc.addBlock();
 6460     int8_t slot = 37;
 6461     int8_t* ptr = &amp;slot;
 6462     intptr_t zero = 0;
 6463     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6464         proc, Add, Origin(),
 6465         root-&gt;appendNew&lt;MemoryValue&gt;(
 6466             proc, Load, pointerType(), Origin(),
 6467             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6468         root-&gt;appendNew&lt;MemoryValue&gt;(
 6469             proc, Load, pointerType(), Origin(),
 6470             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6471     root-&gt;appendNew&lt;MemoryValue&gt;(
 6472         proc, Store8, Origin(),
 6473         root-&gt;appendNew&lt;Value&gt;(
 6474             proc, Add, Origin(),
 6475             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6476             root-&gt;appendNew&lt;Value&gt;(
 6477                 proc, Trunc, Origin(),
 6478                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6479         slotPtr);
 6480     root-&gt;appendNewControlValue(
 6481         proc, Return, Origin(),
 6482         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6483 
 6484     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6485     CHECK(slot == 37 + amount);
 6486 }
 6487 
 6488 void testStoreAddLoadImm8Index(int amount, B3::Opcode loadOpcode)
 6489 {
 6490     Procedure proc;
 6491     BasicBlock* root = proc.addBlock();
 6492     int8_t slot = 37;
 6493     int8_t* ptr = &amp;slot;
 6494     intptr_t zero = 0;
 6495     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6496         proc, Add, Origin(),
 6497         root-&gt;appendNew&lt;MemoryValue&gt;(
 6498             proc, Load, pointerType(), Origin(),
 6499             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6500         root-&gt;appendNew&lt;MemoryValue&gt;(
 6501             proc, Load, pointerType(), Origin(),
 6502             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6503     root-&gt;appendNew&lt;MemoryValue&gt;(
 6504         proc, Store8, Origin(),
 6505         root-&gt;appendNew&lt;Value&gt;(
 6506             proc, Add, Origin(),
 6507             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6508             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6509         slotPtr);
 6510     root-&gt;appendNewControlValue(
 6511         proc, Return, Origin(),
 6512         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6513 
 6514     CHECK(!compileAndRun&lt;int&gt;(proc));
 6515     CHECK(slot == 37 + amount);
 6516 }
 6517 
 6518 void testStoreAddLoad16Index(int amount, B3::Opcode loadOpcode)
 6519 {
 6520     Procedure proc;
 6521     BasicBlock* root = proc.addBlock();
 6522     int16_t slot = 37;
 6523     int16_t* ptr = &amp;slot;
 6524     intptr_t zero = 0;
 6525     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6526         proc, Add, Origin(),
 6527         root-&gt;appendNew&lt;MemoryValue&gt;(
 6528             proc, Load, pointerType(), Origin(),
 6529             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6530         root-&gt;appendNew&lt;MemoryValue&gt;(
 6531             proc, Load, pointerType(), Origin(),
 6532             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6533     root-&gt;appendNew&lt;MemoryValue&gt;(
 6534         proc, Store16, Origin(),
 6535         root-&gt;appendNew&lt;Value&gt;(
 6536             proc, Add, Origin(),
 6537             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6538             root-&gt;appendNew&lt;Value&gt;(
 6539                 proc, Trunc, Origin(),
 6540                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6541         slotPtr);
 6542     root-&gt;appendNewControlValue(
 6543         proc, Return, Origin(),
 6544         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6545 
 6546     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6547     CHECK(slot == 37 + amount);
 6548 }
 6549 
 6550 void testStoreAddLoadImm16Index(int amount, B3::Opcode loadOpcode)
 6551 {
 6552     Procedure proc;
 6553     BasicBlock* root = proc.addBlock();
 6554     int16_t slot = 37;
 6555     int16_t* ptr = &amp;slot;
 6556     intptr_t zero = 0;
 6557     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6558         proc, Add, Origin(),
 6559         root-&gt;appendNew&lt;MemoryValue&gt;(
 6560             proc, Load, pointerType(), Origin(),
 6561             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6562         root-&gt;appendNew&lt;MemoryValue&gt;(
 6563             proc, Load, pointerType(), Origin(),
 6564             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6565     root-&gt;appendNew&lt;MemoryValue&gt;(
 6566         proc, Store16, Origin(),
 6567         root-&gt;appendNew&lt;Value&gt;(
 6568             proc, Add, Origin(),
 6569             root-&gt;appendNew&lt;MemoryValue&gt;(proc, loadOpcode, Origin(), slotPtr),
 6570             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6571         slotPtr);
 6572     root-&gt;appendNewControlValue(
 6573         proc, Return, Origin(),
 6574         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6575 
 6576     CHECK(!compileAndRun&lt;int&gt;(proc));
 6577     CHECK(slot == 37 + amount);
 6578 }
 6579 
 6580 void testStoreAddLoad64Index(int amount)
 6581 {
 6582     Procedure proc;
 6583     BasicBlock* root = proc.addBlock();
 6584     int64_t slot = 37000000000ll;
 6585     int64_t* ptr = &amp;slot;
 6586     intptr_t zero = 0;
 6587     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6588         proc, Add, Origin(),
 6589         root-&gt;appendNew&lt;MemoryValue&gt;(
 6590             proc, Load, pointerType(), Origin(),
 6591             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6592         root-&gt;appendNew&lt;MemoryValue&gt;(
 6593             proc, Load, pointerType(), Origin(),
 6594             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6595     root-&gt;appendNew&lt;MemoryValue&gt;(
 6596         proc, Store, Origin(),
 6597         root-&gt;appendNew&lt;Value&gt;(
 6598             proc, Add, Origin(),
 6599             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), slotPtr),
 6600             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 6601         slotPtr, 0);
 6602     root-&gt;appendNewControlValue(
 6603         proc, Return, Origin(),
 6604         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6605 
 6606     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6607     CHECK(slot == 37000000000ll + amount);
 6608 }
 6609 
 6610 void testStoreAddLoadImm64Index(int64_t amount)
 6611 {
 6612     Procedure proc;
 6613     BasicBlock* root = proc.addBlock();
 6614     int64_t slot = 370000000000ll;
 6615     int64_t* ptr = &amp;slot;
 6616     intptr_t zero = 0;
 6617     Value* slotPtr = root-&gt;appendNew&lt;Value&gt;(
 6618         proc, Add, Origin(),
 6619         root-&gt;appendNew&lt;MemoryValue&gt;(
 6620             proc, Load, pointerType(), Origin(),
 6621             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;ptr)),
 6622         root-&gt;appendNew&lt;MemoryValue&gt;(
 6623             proc, Load, pointerType(), Origin(),
 6624             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;zero)));
 6625     root-&gt;appendNew&lt;MemoryValue&gt;(
 6626         proc, Store, Origin(),
 6627         root-&gt;appendNew&lt;Value&gt;(
 6628             proc, Add, Origin(),
 6629             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), slotPtr),
 6630             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), amount)),
 6631         slotPtr, 0);
 6632     root-&gt;appendNewControlValue(
 6633         proc, Return, Origin(),
 6634         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6635 
 6636     CHECK(!compileAndRun&lt;int&gt;(proc));
 6637     CHECK(slot == 370000000000ll + amount);
 6638 }
 6639 
 6640 void testStoreSubLoad(int amount)
 6641 {
 6642     Procedure proc;
 6643     BasicBlock* root = proc.addBlock();
 6644     int32_t startValue = std::numeric_limits&lt;int32_t&gt;::min();
 6645     int32_t slot = startValue;
 6646     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6647     root-&gt;appendNew&lt;MemoryValue&gt;(
 6648         proc, Store, Origin(),
 6649         root-&gt;appendNew&lt;Value&gt;(
 6650             proc, Sub, Origin(),
 6651             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6652             root-&gt;appendNew&lt;Value&gt;(
 6653                 proc, Trunc, Origin(),
 6654                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 6655         slotPtr, 0);
 6656     root-&gt;appendNewControlValue(
 6657         proc, Return, Origin(),
 6658         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6659 
 6660     CHECK(!compileAndRun&lt;int&gt;(proc, amount));
 6661     CHECK(slot == startValue - amount);
 6662 }
 6663 
 6664 void testStoreAddLoadInterference(int amount)
 6665 {
 6666     Procedure proc;
 6667     BasicBlock* root = proc.addBlock();
 6668     int slot = 37;
 6669     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6670     ArgumentRegValue* otherSlotPtr =
 6671         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6672     MemoryValue* load = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr);
 6673     root-&gt;appendNew&lt;MemoryValue&gt;(
 6674         proc, Store, Origin(),
 6675         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 666),
 6676         otherSlotPtr, 0);
 6677     root-&gt;appendNew&lt;MemoryValue&gt;(
 6678         proc, Store, Origin(),
 6679         root-&gt;appendNew&lt;Value&gt;(
 6680             proc, Add, Origin(),
 6681             load, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6682         slotPtr, 0);
 6683     root-&gt;appendNewControlValue(
 6684         proc, Return, Origin(),
 6685         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6686 
 6687     CHECK(!compileAndRun&lt;int&gt;(proc, &amp;slot));
 6688     CHECK(slot == 37 + amount);
 6689 }
 6690 
 6691 void testStoreAddAndLoad(int amount, int mask)
 6692 {
 6693     Procedure proc;
 6694     BasicBlock* root = proc.addBlock();
 6695     int slot = 37;
 6696     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6697     root-&gt;appendNew&lt;MemoryValue&gt;(
 6698         proc, Store, Origin(),
 6699         root-&gt;appendNew&lt;Value&gt;(
 6700             proc, BitAnd, Origin(),
 6701             root-&gt;appendNew&lt;Value&gt;(
 6702                 proc, Add, Origin(),
 6703                 root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr),
 6704                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), amount)),
 6705             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask)),
 6706         slotPtr, 0);
 6707     root-&gt;appendNewControlValue(
 6708         proc, Return, Origin(),
 6709         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6710 
 6711     CHECK(!compileAndRun&lt;int&gt;(proc));
 6712     CHECK(slot == ((37 + amount) &amp; mask));
 6713 }
 6714 
 6715 void testStoreNegLoad32(int32_t value)
 6716 {
 6717     Procedure proc;
 6718     BasicBlock* root = proc.addBlock();
 6719 
 6720     int32_t slot = value;
 6721 
 6722     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6723 
 6724     root-&gt;appendNew&lt;MemoryValue&gt;(
 6725         proc, Store, Origin(),
 6726         root-&gt;appendNew&lt;Value&gt;(
 6727             proc, Sub, Origin(),
 6728             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 6729             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), slotPtr)),
 6730         slotPtr, 0);
 6731 
 6732     root-&gt;appendNewControlValue(
 6733         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6734 
 6735     CHECK(!compileAndRun&lt;int32_t&gt;(proc));
 6736     CHECK(slot == -value);
 6737 }
 6738 
 6739 void testStoreNegLoadPtr(intptr_t value)
 6740 {
 6741     Procedure proc;
 6742     BasicBlock* root = proc.addBlock();
 6743 
 6744     intptr_t slot = value;
 6745 
 6746     ConstPtrValue* slotPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot);
 6747 
 6748     root-&gt;appendNew&lt;MemoryValue&gt;(
 6749         proc, Store, Origin(),
 6750         root-&gt;appendNew&lt;Value&gt;(
 6751             proc, Sub, Origin(),
 6752             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0),
 6753             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, pointerType(), Origin(), slotPtr)),
 6754         slotPtr, 0);
 6755 
 6756     root-&gt;appendNewControlValue(
 6757         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 6758 
 6759     CHECK(!compileAndRun&lt;int32_t&gt;(proc));
 6760     CHECK(slot == -value);
 6761 }
 6762 
 6763 void testAdd1Uncommuted(int value)
 6764 {
 6765     Procedure proc;
 6766     BasicBlock* root = proc.addBlock();
 6767     root-&gt;appendNewControlValue(
 6768         proc, Return, Origin(),
 6769         root-&gt;appendNew&lt;Value&gt;(
 6770             proc, Add, Origin(),
 6771             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1),
 6772             root-&gt;appendNew&lt;Value&gt;(
 6773                 proc, Trunc, Origin(),
 6774                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 6775 
 6776     CHECK(compileAndRun&lt;int&gt;(proc, value) == value + 1);
 6777 }
 6778 
 6779 void testLoadOffset()
 6780 {
 6781     Procedure proc;
 6782     BasicBlock* root = proc.addBlock();
 6783     int array[] = { 1, 2 };
 6784     ConstPtrValue* arrayPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), array);
 6785     root-&gt;appendNewControlValue(
 6786         proc, Return, Origin(),
 6787         root-&gt;appendNew&lt;Value&gt;(
 6788             proc, Add, Origin(),
 6789             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), arrayPtr, 0),
 6790             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), arrayPtr, static_cast&lt;int32_t&gt;(sizeof(int)))));
 6791 
 6792     CHECK(compileAndRun&lt;int&gt;(proc) == array[0] + array[1]);
 6793 }
 6794 
 6795 void testLoadOffsetNotConstant()
 6796 {
 6797     Procedure proc;
 6798     BasicBlock* root = proc.addBlock();
 6799     int array[] = { 1, 2 };
 6800     Value* arrayPtr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6801     root-&gt;appendNewControlValue(
 6802         proc, Return, Origin(),
 6803         root-&gt;appendNew&lt;Value&gt;(
 6804             proc, Add, Origin(),
 6805             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), arrayPtr, 0),
 6806             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), arrayPtr, static_cast&lt;int32_t&gt;(sizeof(int)))));
 6807 
 6808     CHECK(compileAndRun&lt;int&gt;(proc, &amp;array[0]) == array[0] + array[1]);
 6809 }
 6810 
 6811 void testLoadOffsetUsingAdd()
 6812 {
 6813     Procedure proc;
 6814     BasicBlock* root = proc.addBlock();
 6815     int array[] = { 1, 2 };
 6816     ConstPtrValue* arrayPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), array);
 6817     root-&gt;appendNewControlValue(
 6818         proc, Return, Origin(),
 6819         root-&gt;appendNew&lt;Value&gt;(
 6820             proc, Add, Origin(),
 6821             root-&gt;appendNew&lt;MemoryValue&gt;(
 6822                 proc, Load, Int32, Origin(),
 6823                 root-&gt;appendNew&lt;Value&gt;(
 6824                     proc, Add, Origin(), arrayPtr,
 6825                     root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0))),
 6826             root-&gt;appendNew&lt;MemoryValue&gt;(
 6827                 proc, Load, Int32, Origin(),
 6828                 root-&gt;appendNew&lt;Value&gt;(
 6829                     proc, Add, Origin(), arrayPtr,
 6830                     root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;int32_t&gt;(sizeof(int)))))));
 6831 
 6832     CHECK(compileAndRun&lt;int&gt;(proc) == array[0] + array[1]);
 6833 }
 6834 
 6835 void testLoadOffsetUsingAddInterference()
 6836 {
 6837     Procedure proc;
 6838     BasicBlock* root = proc.addBlock();
 6839     int array[] = { 1, 2 };
 6840     ConstPtrValue* arrayPtr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), array);
 6841     ArgumentRegValue* otherArrayPtr =
 6842         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6843     Const32Value* theNumberOfTheBeast = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 666);
 6844     MemoryValue* left = root-&gt;appendNew&lt;MemoryValue&gt;(
 6845         proc, Load, Int32, Origin(),
 6846         root-&gt;appendNew&lt;Value&gt;(
 6847             proc, Add, Origin(), arrayPtr,
 6848             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)));
 6849     MemoryValue* right = root-&gt;appendNew&lt;MemoryValue&gt;(
 6850         proc, Load, Int32, Origin(),
 6851         root-&gt;appendNew&lt;Value&gt;(
 6852             proc, Add, Origin(), arrayPtr,
 6853             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;int32_t&gt;(sizeof(int)))));
 6854     root-&gt;appendNew&lt;MemoryValue&gt;(
 6855         proc, Store, Origin(), theNumberOfTheBeast, otherArrayPtr, 0);
 6856     root-&gt;appendNew&lt;MemoryValue&gt;(
 6857         proc, Store, Origin(), theNumberOfTheBeast, otherArrayPtr, static_cast&lt;int32_t&gt;(sizeof(int)));
 6858     root-&gt;appendNewControlValue(
 6859         proc, Return, Origin(),
 6860         root-&gt;appendNew&lt;Value&gt;(
 6861             proc, Add, Origin(), left, right));
 6862 
 6863     CHECK(compileAndRun&lt;int&gt;(proc, &amp;array[0]) == 1 + 2);
 6864     CHECK(array[0] == 666);
 6865     CHECK(array[1] == 666);
 6866 }
 6867 
 6868 void testLoadOffsetUsingAddNotConstant()
 6869 {
 6870     Procedure proc;
 6871     BasicBlock* root = proc.addBlock();
 6872     int array[] = { 1, 2 };
 6873     Value* arrayPtr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6874     root-&gt;appendNewControlValue(
 6875         proc, Return, Origin(),
 6876         root-&gt;appendNew&lt;Value&gt;(
 6877             proc, Add, Origin(),
 6878             root-&gt;appendNew&lt;MemoryValue&gt;(
 6879                 proc, Load, Int32, Origin(),
 6880                 root-&gt;appendNew&lt;Value&gt;(
 6881                     proc, Add, Origin(), arrayPtr,
 6882                     root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0))),
 6883             root-&gt;appendNew&lt;MemoryValue&gt;(
 6884                 proc, Load, Int32, Origin(),
 6885                 root-&gt;appendNew&lt;Value&gt;(
 6886                     proc, Add, Origin(), arrayPtr,
 6887                     root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;int32_t&gt;(sizeof(int)))))));
 6888 
 6889     CHECK(compileAndRun&lt;int&gt;(proc, &amp;array[0]) == array[0] + array[1]);
 6890 }
 6891 
 6892 void testLoadAddrShift(unsigned shift)
 6893 {
 6894     Procedure proc;
 6895     BasicBlock* root = proc.addBlock();
 6896     int slots[2];
 6897 
 6898     // Figure out which slot to use while having proper alignment for the shift.
 6899     int* slot;
 6900     uintptr_t arg;
 6901     for (unsigned i = sizeof(slots)/sizeof(slots[0]); i--;) {
 6902         slot = slots + i;
 6903         arg = bitwise_cast&lt;uintptr_t&gt;(slot) &gt;&gt; shift;
 6904         if (bitwise_cast&lt;int*&gt;(arg &lt;&lt; shift) == slot)
 6905             break;
 6906     }
 6907 
 6908     *slot = 8675309;
 6909 
 6910     root-&gt;appendNewControlValue(
 6911         proc, Return, Origin(),
 6912         root-&gt;appendNew&lt;MemoryValue&gt;(
 6913             proc, Load, Int32, Origin(),
 6914             root-&gt;appendNew&lt;Value&gt;(
 6915                 proc, Shl, Origin(),
 6916                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 6917                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), shift))));
 6918 
 6919     CHECK(compileAndRun&lt;int&gt;(proc, arg) == 8675309);
 6920 }
 6921 
 6922 void testFramePointer()
 6923 {
 6924     Procedure proc;
 6925     BasicBlock* root = proc.addBlock();
 6926     root-&gt;appendNewControlValue(
 6927         proc, Return, Origin(),
 6928         root-&gt;appendNew&lt;Value&gt;(proc, FramePointer, Origin()));
 6929 
 6930     void* fp = compileAndRun&lt;void*&gt;(proc);
 6931     CHECK(fp &lt; &amp;proc);
 6932     CHECK(fp &gt;= bitwise_cast&lt;char*&gt;(&amp;proc) - 10000);
 6933 }
 6934 
 6935 void testOverrideFramePointer()
 6936 {
 6937     {
 6938         Procedure proc;
 6939         BasicBlock* root = proc.addBlock();
 6940 
 6941         // Add a stack slot to make the frame non trivial.
 6942         root-&gt;appendNew&lt;SlotBaseValue&gt;(proc, Origin(), proc.addStackSlot(8));
 6943 
 6944         // Sub on x86 UseDef the source. If FP is not protected correctly, it will be overridden since it is the last visible use.
 6945         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6946         Value* fp = root-&gt;appendNew&lt;Value&gt;(proc, FramePointer, Origin());
 6947         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), fp, offset);
 6948 
 6949         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 6950         CHECK(compileAndRun&lt;int64_t&gt;(proc, 1));
 6951     }
 6952     {
 6953         Procedure proc;
 6954         BasicBlock* root = proc.addBlock();
 6955 
 6956         root-&gt;appendNew&lt;SlotBaseValue&gt;(proc, Origin(), proc.addStackSlot(8));
 6957 
 6958         Value* offset = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 6959         Value* fp = root-&gt;appendNew&lt;Value&gt;(proc, FramePointer, Origin());
 6960         Value* offsetFP = root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), offset, fp);
 6961         Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 6962         Value* offsetArg = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), offset, arg);
 6963         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), offsetArg, offsetFP);
 6964 
 6965         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 6966         CHECK(compileAndRun&lt;int64_t&gt;(proc, 1, 2));
 6967     }
 6968 }
 6969 
 6970 void testStackSlot()
 6971 {
 6972     Procedure proc;
 6973     BasicBlock* root = proc.addBlock();
 6974     root-&gt;appendNewControlValue(
 6975         proc, Return, Origin(),
 6976         root-&gt;appendNew&lt;SlotBaseValue&gt;(proc, Origin(), proc.addStackSlot(1)));
 6977 
 6978     void* stackSlot = compileAndRun&lt;void*&gt;(proc);
 6979     CHECK(stackSlot &lt; &amp;proc);
 6980     CHECK(stackSlot &gt;= bitwise_cast&lt;char*&gt;(&amp;proc) - 10000);
 6981 }
 6982 
 6983 void testLoadFromFramePointer()
 6984 {
 6985     Procedure proc;
 6986     BasicBlock* root = proc.addBlock();
 6987     root-&gt;appendNewControlValue(
 6988         proc, Return, Origin(),
 6989         root-&gt;appendNew&lt;MemoryValue&gt;(
 6990             proc, Load, pointerType(), Origin(),
 6991             root-&gt;appendNew&lt;Value&gt;(proc, FramePointer, Origin())));
 6992 
 6993     void* fp = compileAndRun&lt;void*&gt;(proc);
 6994     void* myFP = __builtin_frame_address(0);
 6995     CHECK(fp &lt;= myFP);
 6996     CHECK(fp &gt;= bitwise_cast&lt;char*&gt;(myFP) - 10000);
 6997 }
 6998 
 6999 void testStoreLoadStackSlot(int value)
 7000 {
 7001     Procedure proc;
 7002     BasicBlock* root = proc.addBlock();
 7003 
 7004     SlotBaseValue* stack =
 7005         root-&gt;appendNew&lt;SlotBaseValue&gt;(proc, Origin(), proc.addStackSlot(sizeof(int)));
 7006 
 7007     root-&gt;appendNew&lt;MemoryValue&gt;(
 7008         proc, Store, Origin(),
 7009         root-&gt;appendNew&lt;Value&gt;(
 7010             proc, Trunc, Origin(),
 7011             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7012         stack, 0);
 7013 
 7014     root-&gt;appendNewControlValue(
 7015         proc, Return, Origin(),
 7016         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), stack));
 7017 
 7018     CHECK(compileAndRun&lt;int&gt;(proc, value) == value);
 7019 }
 7020 
 7021 template&lt;typename LoadedType, typename EffectiveType&gt;
 7022 EffectiveType modelLoad(EffectiveType value)
 7023 {
 7024     union {
 7025         EffectiveType original;
 7026         LoadedType loaded;
 7027     } u;
 7028 
 7029     u.original = value;
 7030     if (std::is_signed&lt;LoadedType&gt;::value)
 7031         return static_cast&lt;EffectiveType&gt;(u.loaded);
 7032     return static_cast&lt;EffectiveType&gt;(static_cast&lt;typename std::make_unsigned&lt;EffectiveType&gt;::type&gt;(u.loaded));
 7033 }
 7034 
 7035 template&lt;&gt;
 7036 float modelLoad&lt;float, float&gt;(float value) { return value; }
 7037 
 7038 template&lt;&gt;
 7039 double modelLoad&lt;double, double&gt;(double value) { return value; }
 7040 
 7041 template&lt;B3::Type type, typename CType, typename InputType&gt;
 7042 void testLoad(B3::Opcode opcode, InputType value)
 7043 {
 7044     // Simple load from an absolute address.
 7045     {
 7046         Procedure proc;
 7047         BasicBlock* root = proc.addBlock();
 7048 
 7049         root-&gt;appendNewControlValue(
 7050             proc, Return, Origin(),
 7051             root-&gt;appendNew&lt;MemoryValue&gt;(
 7052                 proc, opcode, type, Origin(),
 7053                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;value)));
 7054 
 7055         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc), modelLoad&lt;CType&gt;(value)));
 7056     }
 7057 
 7058     // Simple load from an address in a register.
 7059     {
 7060         Procedure proc;
 7061         BasicBlock* root = proc.addBlock();
 7062 
 7063         root-&gt;appendNewControlValue(
 7064             proc, Return, Origin(),
 7065             root-&gt;appendNew&lt;MemoryValue&gt;(
 7066                 proc, opcode, type, Origin(),
 7067                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 7068 
 7069         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value), modelLoad&lt;CType&gt;(value)));
 7070     }
 7071 
 7072     // Simple load from an address in a register, at an offset.
 7073     {
 7074         Procedure proc;
 7075         BasicBlock* root = proc.addBlock();
 7076 
 7077         root-&gt;appendNewControlValue(
 7078             proc, Return, Origin(),
 7079             root-&gt;appendNew&lt;MemoryValue&gt;(
 7080                 proc, opcode, type, Origin(),
 7081                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 7082                 static_cast&lt;int32_t&gt;(sizeof(InputType))));
 7083 
 7084         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 1), modelLoad&lt;CType&gt;(value)));
 7085     }
 7086 
 7087     // Load from a simple base-index with various scales.
 7088     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 7089         Procedure proc;
 7090         BasicBlock* root = proc.addBlock();
 7091 
 7092         root-&gt;appendNewControlValue(
 7093             proc, Return, Origin(),
 7094             root-&gt;appendNew&lt;MemoryValue&gt;(
 7095                 proc, opcode, type, Origin(),
 7096                 root-&gt;appendNew&lt;Value&gt;(
 7097                     proc, Add, Origin(),
 7098                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 7099                     root-&gt;appendNew&lt;Value&gt;(
 7100                         proc, Shl, Origin(),
 7101                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 7102                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)))));
 7103 
 7104         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 7105     }
 7106 
 7107     // Load from a simple base-index with various scales, but commuted.
 7108     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 7109         Procedure proc;
 7110         BasicBlock* root = proc.addBlock();
 7111 
 7112         root-&gt;appendNewControlValue(
 7113             proc, Return, Origin(),
 7114             root-&gt;appendNew&lt;MemoryValue&gt;(
 7115                 proc, opcode, type, Origin(),
 7116                 root-&gt;appendNew&lt;Value&gt;(
 7117                     proc, Add, Origin(),
 7118                     root-&gt;appendNew&lt;Value&gt;(
 7119                         proc, Shl, Origin(),
 7120                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 7121                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)),
 7122                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 7123 
 7124         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 7125     }
 7126 }
 7127 
 7128 template&lt;typename T&gt;
 7129 void testLoad(B3::Opcode opcode, int32_t value)
 7130 {
 7131     return testLoad&lt;Int32, T&gt;(opcode, value);
 7132 }
 7133 
 7134 template&lt;B3::Type type, typename T&gt;
 7135 void testLoad(T value)
 7136 {
 7137     return testLoad&lt;type, T&gt;(Load, value);
 7138 }
 7139 
 7140 void testStoreFloat(double input)
 7141 {
 7142     // Simple store from an address in a register.
 7143     {
 7144         Procedure proc;
 7145         BasicBlock* root = proc.addBlock();
 7146         Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 7147         Value* argumentAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 7148 
 7149         Value* destinationAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 7150         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), argumentAsFloat, destinationAddress);
 7151 
 7152         root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7153 
 7154         float output = 0.;
 7155         CHECK(!compileAndRun&lt;int64_t&gt;(proc, input, &amp;output));
 7156         CHECK(isIdentical(static_cast&lt;float&gt;(input), output));
 7157     }
 7158 
 7159     // Simple indexed store.
 7160     {
 7161         Procedure proc;
 7162         BasicBlock* root = proc.addBlock();
 7163         Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 7164         Value* argumentAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), argument);
 7165 
 7166         Value* destinationBaseAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 7167         Value* index = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 7168         Value* scaledIndex = root-&gt;appendNew&lt;Value&gt;(
 7169             proc, Shl, Origin(),
 7170             index,
 7171             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2));
 7172         Value* destinationAddress = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), scaledIndex, destinationBaseAddress);
 7173 
 7174         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), argumentAsFloat, destinationAddress);
 7175 
 7176         root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7177 
 7178         float output = 0.;
 7179         CHECK(!compileAndRun&lt;int64_t&gt;(proc, input, &amp;output - 1, 1));
 7180         CHECK(isIdentical(static_cast&lt;float&gt;(input), output));
 7181     }
 7182 }
 7183 
 7184 void testStoreDoubleConstantAsFloat(double input)
 7185 {
 7186     // Simple store from an address in a register.
 7187     Procedure proc;
 7188     BasicBlock* root = proc.addBlock();
 7189     Value* value = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), input);
 7190     Value* valueAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), value);
 7191 
 7192     Value* destinationAddress = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 7193 
 7194     root-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), valueAsFloat, destinationAddress);
 7195 
 7196     root-&gt;appendNewControlValue(proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7197 
 7198     float output = 0.;
 7199     CHECK(!compileAndRun&lt;int64_t&gt;(proc, input, &amp;output));
 7200     CHECK(isIdentical(static_cast&lt;float&gt;(input), output));
 7201 }
 7202 
 7203 void testSpillGP()
 7204 {
 7205     Procedure proc;
 7206     BasicBlock* root = proc.addBlock();
 7207 
 7208     Vector&lt;Value*&gt; sources;
 7209     sources.append(root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 7210     sources.append(root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 7211 
 7212     for (unsigned i = 0; i &lt; 30; ++i) {
 7213         sources.append(
 7214             root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), sources[sources.size() - 1], sources[sources.size() - 2])
 7215         );
 7216     }
 7217 
 7218     Value* total = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0);
 7219     for (Value* value : sources)
 7220         total = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), total, value);
 7221 
 7222     root-&gt;appendNewControlValue(proc, Return, Origin(), total);
 7223     compileAndRun&lt;int&gt;(proc, 1, 2);
 7224 }
 7225 
 7226 void testSpillFP()
 7227 {
 7228     Procedure proc;
 7229     BasicBlock* root = proc.addBlock();
 7230 
 7231     Vector&lt;Value*&gt; sources;
 7232     sources.append(root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
 7233     sources.append(root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1));
 7234 
 7235     for (unsigned i = 0; i &lt; 30; ++i) {
 7236         sources.append(
 7237             root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), sources[sources.size() - 1], sources[sources.size() - 2])
 7238         );
 7239     }
 7240 
 7241     Value* total = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.);
 7242     for (Value* value : sources)
 7243         total = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), total, value);
 7244 
 7245     root-&gt;appendNewControlValue(proc, Return, Origin(), total);
 7246     compileAndRun&lt;double&gt;(proc, 1.1, 2.5);
 7247 }
 7248 
 7249 void testInt32ToDoublePartialRegisterStall()
 7250 {
 7251     Procedure proc;
 7252     BasicBlock* root = proc.addBlock();
 7253     BasicBlock* loop = proc.addBlock();
 7254     BasicBlock* done = proc.addBlock();
 7255 
 7256     // Head.
 7257     Value* total = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.);
 7258     Value* counter = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 7259     UpsilonValue* originalTotal = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), total);
 7260     UpsilonValue* originalCounter = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), counter);
 7261     root-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loop));
 7262 
 7263     // Loop.
 7264     Value* loopCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Int64, Origin());
 7265     Value* loopTotal = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 7266     originalCounter-&gt;setPhi(loopCounter);
 7267     originalTotal-&gt;setPhi(loopTotal);
 7268 
 7269     Value* truncatedCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), loopCounter);
 7270     Value* doubleCounter = loop-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), truncatedCounter);
 7271     Value* updatedTotal = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleCounter, loopTotal);
 7272     UpsilonValue* updatedTotalUpsilon = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), updatedTotal);
 7273     updatedTotalUpsilon-&gt;setPhi(loopTotal);
 7274 
 7275     Value* decCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), loopCounter, loop-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 1));
 7276     UpsilonValue* decCounterUpsilon = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), decCounter);
 7277     decCounterUpsilon-&gt;setPhi(loopCounter);
 7278     loop-&gt;appendNewControlValue(
 7279         proc, Branch, Origin(),
 7280         decCounter,
 7281         FrequentedBlock(loop), FrequentedBlock(done));
 7282 
 7283     // Tail.
 7284     done-&gt;appendNewControlValue(proc, Return, Origin(), updatedTotal);
 7285     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, 100000), 5000050000.));
 7286 }
 7287 
 7288 void testInt32ToDoublePartialRegisterWithoutStall()
 7289 {
 7290     Procedure proc;
 7291     BasicBlock* root = proc.addBlock();
 7292     BasicBlock* loop = proc.addBlock();
 7293     BasicBlock* done = proc.addBlock();
 7294 
 7295     // Head.
 7296     Value* total = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.);
 7297     Value* counter = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 7298     UpsilonValue* originalTotal = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), total);
 7299     UpsilonValue* originalCounter = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), counter);
 7300     uint64_t forPaddingInput;
 7301     Value* forPaddingInputAddress = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;forPaddingInput);
 7302     uint64_t forPaddingOutput;
 7303     Value* forPaddingOutputAddress = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;forPaddingOutput);
 7304     root-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loop));
 7305 
 7306     // Loop.
 7307     Value* loopCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Int64, Origin());
 7308     Value* loopTotal = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Double, Origin());
 7309     originalCounter-&gt;setPhi(loopCounter);
 7310     originalTotal-&gt;setPhi(loopTotal);
 7311 
 7312     Value* truncatedCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), loopCounter);
 7313     Value* doubleCounter = loop-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), truncatedCounter);
 7314     Value* updatedTotal = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), doubleCounter, loopTotal);
 7315 
 7316     // Add enough padding instructions to avoid a stall.
 7317     Value* loadPadding = loop-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), forPaddingInputAddress);
 7318     Value* padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), loadPadding, loopCounter);
 7319     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), padding, loopCounter);
 7320     padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), padding, loopCounter);
 7321     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), padding, loopCounter);
 7322     padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), padding, loopCounter);
 7323     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), padding, loopCounter);
 7324     padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), padding, loopCounter);
 7325     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), padding, loopCounter);
 7326     padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), padding, loopCounter);
 7327     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), padding, loopCounter);
 7328     padding = loop-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), padding, loopCounter);
 7329     padding = loop-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), padding, loopCounter);
 7330     loop-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), padding, forPaddingOutputAddress);
 7331 
 7332     UpsilonValue* updatedTotalUpsilon = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), updatedTotal);
 7333     updatedTotalUpsilon-&gt;setPhi(loopTotal);
 7334 
 7335     Value* decCounter = loop-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), loopCounter, loop-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 1));
 7336     UpsilonValue* decCounterUpsilon = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), decCounter);
 7337     decCounterUpsilon-&gt;setPhi(loopCounter);
 7338     loop-&gt;appendNewControlValue(
 7339         proc, Branch, Origin(),
 7340         decCounter,
 7341         FrequentedBlock(loop), FrequentedBlock(done));
 7342 
 7343     // Tail.
 7344     done-&gt;appendNewControlValue(proc, Return, Origin(), updatedTotal);
 7345     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, 100000), 5000050000.));
 7346 }
 7347 
 7348 void testBranch()
 7349 {
 7350     Procedure proc;
 7351     BasicBlock* root = proc.addBlock();
 7352     BasicBlock* thenCase = proc.addBlock();
 7353     BasicBlock* elseCase = proc.addBlock();
 7354 
 7355     root-&gt;appendNewControlValue(
 7356         proc, Branch, Origin(),
 7357         root-&gt;appendNew&lt;Value&gt;(
 7358             proc, Trunc, Origin(),
 7359             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7360         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7361 
 7362     thenCase-&gt;appendNewControlValue(
 7363         proc, Return, Origin(),
 7364         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7365 
 7366     elseCase-&gt;appendNewControlValue(
 7367         proc, Return, Origin(),
 7368         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7369 
 7370     auto code = compileProc(proc);
 7371     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7372     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7373 }
 7374 
 7375 void testBranchPtr()
 7376 {
 7377     Procedure proc;
 7378     BasicBlock* root = proc.addBlock();
 7379     BasicBlock* thenCase = proc.addBlock();
 7380     BasicBlock* elseCase = proc.addBlock();
 7381 
 7382     root-&gt;appendNewControlValue(
 7383         proc, Branch, Origin(),
 7384         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 7385         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7386 
 7387     thenCase-&gt;appendNewControlValue(
 7388         proc, Return, Origin(),
 7389         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7390 
 7391     elseCase-&gt;appendNewControlValue(
 7392         proc, Return, Origin(),
 7393         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7394 
 7395     auto code = compileProc(proc);
 7396     CHECK(invoke&lt;int&gt;(*code, static_cast&lt;intptr_t&gt;(42)) == 1);
 7397     CHECK(invoke&lt;int&gt;(*code, static_cast&lt;intptr_t&gt;(0)) == 0);
 7398 }
 7399 
 7400 void testDiamond()
 7401 {
 7402     Procedure proc;
 7403     BasicBlock* root = proc.addBlock();
 7404     BasicBlock* thenCase = proc.addBlock();
 7405     BasicBlock* elseCase = proc.addBlock();
 7406     BasicBlock* done = proc.addBlock();
 7407 
 7408     root-&gt;appendNewControlValue(
 7409         proc, Branch, Origin(),
 7410         root-&gt;appendNew&lt;Value&gt;(
 7411             proc, Trunc, Origin(),
 7412             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7413         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7414 
 7415     UpsilonValue* thenResult = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(
 7416         proc, Origin(), thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7417     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(done));
 7418 
 7419     UpsilonValue* elseResult = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(
 7420         proc, Origin(), elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7421     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(done));
 7422 
 7423     Value* phi = done-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 7424     thenResult-&gt;setPhi(phi);
 7425     elseResult-&gt;setPhi(phi);
 7426     done-&gt;appendNewControlValue(proc, Return, Origin(), phi);
 7427 
 7428     auto code = compileProc(proc);
 7429     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7430     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7431 }
 7432 
 7433 void testBranchNotEqual()
 7434 {
 7435     Procedure proc;
 7436     BasicBlock* root = proc.addBlock();
 7437     BasicBlock* thenCase = proc.addBlock();
 7438     BasicBlock* elseCase = proc.addBlock();
 7439 
 7440     root-&gt;appendNewControlValue(
 7441         proc, Branch, Origin(),
 7442         root-&gt;appendNew&lt;Value&gt;(
 7443             proc, NotEqual, Origin(),
 7444             root-&gt;appendNew&lt;Value&gt;(
 7445                 proc, Trunc, Origin(),
 7446                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7447             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7448         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7449 
 7450     thenCase-&gt;appendNewControlValue(
 7451         proc, Return, Origin(),
 7452         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7453 
 7454     elseCase-&gt;appendNewControlValue(
 7455         proc, Return, Origin(),
 7456         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7457 
 7458     auto code = compileProc(proc);
 7459     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7460     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7461 }
 7462 
 7463 void testBranchNotEqualCommute()
 7464 {
 7465     Procedure proc;
 7466     BasicBlock* root = proc.addBlock();
 7467     BasicBlock* thenCase = proc.addBlock();
 7468     BasicBlock* elseCase = proc.addBlock();
 7469 
 7470     root-&gt;appendNewControlValue(
 7471         proc, Branch, Origin(),
 7472         root-&gt;appendNew&lt;Value&gt;(
 7473             proc, NotEqual, Origin(),
 7474             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 7475             root-&gt;appendNew&lt;Value&gt;(
 7476                 proc, Trunc, Origin(),
 7477                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 7478         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7479 
 7480     thenCase-&gt;appendNewControlValue(
 7481         proc, Return, Origin(),
 7482         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7483 
 7484     elseCase-&gt;appendNewControlValue(
 7485         proc, Return, Origin(),
 7486         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7487 
 7488     auto code = compileProc(proc);
 7489     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7490     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7491 }
 7492 
 7493 void testBranchNotEqualNotEqual()
 7494 {
 7495     Procedure proc;
 7496     BasicBlock* root = proc.addBlock();
 7497     BasicBlock* thenCase = proc.addBlock();
 7498     BasicBlock* elseCase = proc.addBlock();
 7499 
 7500     root-&gt;appendNewControlValue(
 7501         proc, Branch, Origin(),
 7502         root-&gt;appendNew&lt;Value&gt;(
 7503             proc, NotEqual, Origin(),
 7504             root-&gt;appendNew&lt;Value&gt;(
 7505                 proc, NotEqual, Origin(),
 7506                 root-&gt;appendNew&lt;Value&gt;(
 7507                     proc, Trunc, Origin(),
 7508                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7509                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7510             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7511         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7512 
 7513     thenCase-&gt;appendNewControlValue(
 7514         proc, Return, Origin(),
 7515         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7516 
 7517     elseCase-&gt;appendNewControlValue(
 7518         proc, Return, Origin(),
 7519         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7520 
 7521     auto code = compileProc(proc);
 7522     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7523     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7524 }
 7525 
 7526 void testBranchEqual()
 7527 {
 7528     Procedure proc;
 7529     BasicBlock* root = proc.addBlock();
 7530     BasicBlock* thenCase = proc.addBlock();
 7531     BasicBlock* elseCase = proc.addBlock();
 7532 
 7533     root-&gt;appendNewControlValue(
 7534         proc, Branch, Origin(),
 7535         root-&gt;appendNew&lt;Value&gt;(
 7536             proc, Equal, Origin(),
 7537             root-&gt;appendNew&lt;Value&gt;(
 7538                 proc, Trunc, Origin(),
 7539                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7540             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7541         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7542 
 7543     thenCase-&gt;appendNewControlValue(
 7544         proc, Return, Origin(),
 7545         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7546 
 7547     elseCase-&gt;appendNewControlValue(
 7548         proc, Return, Origin(),
 7549         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7550 
 7551     auto code = compileProc(proc);
 7552     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7553     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7554 }
 7555 
 7556 void testBranchEqualEqual()
 7557 {
 7558     Procedure proc;
 7559     BasicBlock* root = proc.addBlock();
 7560     BasicBlock* thenCase = proc.addBlock();
 7561     BasicBlock* elseCase = proc.addBlock();
 7562 
 7563     root-&gt;appendNewControlValue(
 7564         proc, Branch, Origin(),
 7565         root-&gt;appendNew&lt;Value&gt;(
 7566             proc, Equal, Origin(),
 7567             root-&gt;appendNew&lt;Value&gt;(
 7568                 proc, Equal, Origin(),
 7569                 root-&gt;appendNew&lt;Value&gt;(
 7570                     proc, Trunc, Origin(),
 7571                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7572                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7573             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7574         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7575 
 7576     thenCase-&gt;appendNewControlValue(
 7577         proc, Return, Origin(),
 7578         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7579 
 7580     elseCase-&gt;appendNewControlValue(
 7581         proc, Return, Origin(),
 7582         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7583 
 7584     auto code = compileProc(proc);
 7585     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7586     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7587 }
 7588 
 7589 void testBranchEqualCommute()
 7590 {
 7591     Procedure proc;
 7592     BasicBlock* root = proc.addBlock();
 7593     BasicBlock* thenCase = proc.addBlock();
 7594     BasicBlock* elseCase = proc.addBlock();
 7595 
 7596     root-&gt;appendNewControlValue(
 7597         proc, Branch, Origin(),
 7598         root-&gt;appendNew&lt;Value&gt;(
 7599             proc, Equal, Origin(),
 7600             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 7601             root-&gt;appendNew&lt;Value&gt;(
 7602                 proc, Trunc, Origin(),
 7603                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
 7604         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7605 
 7606     thenCase-&gt;appendNewControlValue(
 7607         proc, Return, Origin(),
 7608         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7609 
 7610     elseCase-&gt;appendNewControlValue(
 7611         proc, Return, Origin(),
 7612         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7613 
 7614     auto code = compileProc(proc);
 7615     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7616     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7617 }
 7618 
 7619 void testBranchEqualEqual1()
 7620 {
 7621     Procedure proc;
 7622     BasicBlock* root = proc.addBlock();
 7623     BasicBlock* thenCase = proc.addBlock();
 7624     BasicBlock* elseCase = proc.addBlock();
 7625 
 7626     root-&gt;appendNewControlValue(
 7627         proc, Branch, Origin(),
 7628         root-&gt;appendNew&lt;Value&gt;(
 7629             proc, Equal, Origin(),
 7630             root-&gt;appendNew&lt;Value&gt;(
 7631                 proc, Equal, Origin(),
 7632                 root-&gt;appendNew&lt;Value&gt;(
 7633                     proc, Trunc, Origin(),
 7634                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 7635                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
 7636             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)),
 7637         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7638 
 7639     thenCase-&gt;appendNewControlValue(
 7640         proc, Return, Origin(),
 7641         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7642 
 7643     elseCase-&gt;appendNewControlValue(
 7644         proc, Return, Origin(),
 7645         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7646 
 7647     auto code = compileProc(proc);
 7648     CHECK(invoke&lt;int&gt;(*code, 42) == 1);
 7649     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 7650 }
 7651 
 7652 void testBranchEqualOrUnorderedArgs(double a, double b)
 7653 {
 7654     Procedure proc;
 7655     BasicBlock* root = proc.addBlock();
 7656     BasicBlock* thenCase = proc.addBlock();
 7657     BasicBlock* elseCase = proc.addBlock();
 7658 
 7659     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 7660     Value* argumentB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 7661     root-&gt;appendNewControlValue(
 7662         proc, Branch, Origin(),
 7663         root-&gt;appendNew&lt;Value&gt;(
 7664             proc, EqualOrUnordered, Origin(),
 7665             argumentA,
 7666             argumentB),
 7667         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7668 
 7669     thenCase-&gt;appendNewControlValue(
 7670         proc, Return, Origin(),
 7671         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7672 
 7673     elseCase-&gt;appendNewControlValue(
 7674         proc, Return, Origin(),
 7675         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7676 
 7677     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7678     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == expected);
 7679 }
 7680 
 7681 void testBranchEqualOrUnorderedArgs(float a, float b)
 7682 {
 7683     Procedure proc;
 7684     BasicBlock* root = proc.addBlock();
 7685     BasicBlock* thenCase = proc.addBlock();
 7686     BasicBlock* elseCase = proc.addBlock();
 7687 
 7688     Value* argumentA = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7689         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 7690     Value* argumentB = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7691         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 7692 
 7693     root-&gt;appendNewControlValue(
 7694         proc, Branch, Origin(),
 7695         root-&gt;appendNew&lt;Value&gt;(
 7696             proc, EqualOrUnordered, Origin(),
 7697             argumentA,
 7698             argumentB),
 7699         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7700 
 7701     thenCase-&gt;appendNewControlValue(
 7702         proc, Return, Origin(),
 7703         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7704 
 7705     elseCase-&gt;appendNewControlValue(
 7706         proc, Return, Origin(),
 7707         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7708 
 7709     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7710     CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;a, &amp;b) == expected);
 7711 }
 7712 
 7713 void testBranchNotEqualAndOrderedArgs(double a, double b)
 7714 {
 7715     Procedure proc;
 7716     BasicBlock* root = proc.addBlock();
 7717     BasicBlock* thenCase = proc.addBlock();
 7718     BasicBlock* elseCase = proc.addBlock();
 7719 
 7720     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 7721     Value* argumentB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 7722     Value* equalOrUnordered = root-&gt;appendNew&lt;Value&gt;(
 7723         proc, EqualOrUnordered, Origin(),
 7724         argumentA,
 7725         argumentB);
 7726     Value* notEqualAndOrdered = root-&gt;appendNew&lt;Value&gt;(
 7727         proc, Equal, Origin(),
 7728         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 7729         equalOrUnordered);
 7730     root-&gt;appendNewControlValue(
 7731         proc, Branch, Origin(),
 7732         notEqualAndOrdered,
 7733         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7734 
 7735     thenCase-&gt;appendNewControlValue(
 7736         proc, Return, Origin(),
 7737         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7738 
 7739     elseCase-&gt;appendNewControlValue(
 7740         proc, Return, Origin(),
 7741         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7742 
 7743     int64_t expected = (!std::isunordered(a, b) &amp;&amp; a != b) ? 42 : -13;
 7744     CHECK(compileAndRun&lt;int64_t&gt;(proc, a, b) == expected);
 7745 }
 7746 
 7747 void testBranchNotEqualAndOrderedArgs(float a, float b)
 7748 {
 7749     Procedure proc;
 7750     BasicBlock* root = proc.addBlock();
 7751     BasicBlock* thenCase = proc.addBlock();
 7752     BasicBlock* elseCase = proc.addBlock();
 7753 
 7754     Value* argumentA = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7755         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 7756     Value* argumentB = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7757         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 7758     Value* equalOrUnordered = root-&gt;appendNew&lt;Value&gt;(
 7759         proc, EqualOrUnordered, Origin(),
 7760         argumentA,
 7761         argumentB);
 7762     Value* notEqualAndOrdered = root-&gt;appendNew&lt;Value&gt;(
 7763         proc, Equal, Origin(),
 7764         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0),
 7765         equalOrUnordered);
 7766     root-&gt;appendNewControlValue(
 7767         proc, Branch, Origin(),
 7768         notEqualAndOrdered,
 7769         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7770 
 7771     thenCase-&gt;appendNewControlValue(
 7772         proc, Return, Origin(),
 7773         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7774 
 7775     elseCase-&gt;appendNewControlValue(
 7776         proc, Return, Origin(),
 7777         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7778 
 7779     int64_t expected = (!std::isunordered(a, b) &amp;&amp; a != b) ? 42 : -13;
 7780     CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;a, &amp;b) == expected);
 7781 }
 7782 
 7783 void testBranchEqualOrUnorderedDoubleArgImm(double a, double b)
 7784 {
 7785     Procedure proc;
 7786     BasicBlock* root = proc.addBlock();
 7787     BasicBlock* thenCase = proc.addBlock();
 7788     BasicBlock* elseCase = proc.addBlock();
 7789 
 7790     Value* argumentA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 7791     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 7792     root-&gt;appendNewControlValue(
 7793         proc, Branch, Origin(),
 7794         root-&gt;appendNew&lt;Value&gt;(
 7795             proc, EqualOrUnordered, Origin(),
 7796             argumentA,
 7797             argumentB),
 7798         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7799 
 7800     thenCase-&gt;appendNewControlValue(
 7801         proc, Return, Origin(),
 7802         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7803 
 7804     elseCase-&gt;appendNewControlValue(
 7805         proc, Return, Origin(),
 7806         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7807 
 7808     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7809     CHECK(compileAndRun&lt;int64_t&gt;(proc, a) == expected);
 7810 }
 7811 
 7812 void testBranchEqualOrUnorderedFloatArgImm(float a, float b)
 7813 {
 7814     Procedure proc;
 7815     BasicBlock* root = proc.addBlock();
 7816     BasicBlock* thenCase = proc.addBlock();
 7817     BasicBlock* elseCase = proc.addBlock();
 7818 
 7819     Value* argumentA = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7820         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 7821     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 7822 
 7823     root-&gt;appendNewControlValue(
 7824         proc, Branch, Origin(),
 7825         root-&gt;appendNew&lt;Value&gt;(
 7826             proc, EqualOrUnordered, Origin(),
 7827             argumentA,
 7828             argumentB),
 7829         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7830 
 7831     thenCase-&gt;appendNewControlValue(
 7832         proc, Return, Origin(),
 7833         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7834 
 7835     elseCase-&gt;appendNewControlValue(
 7836         proc, Return, Origin(),
 7837         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7838 
 7839     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7840     CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;a) == expected);
 7841 }
 7842 
 7843 void testBranchEqualOrUnorderedDoubleImms(double a, double b)
 7844 {
 7845     Procedure proc;
 7846     BasicBlock* root = proc.addBlock();
 7847     BasicBlock* thenCase = proc.addBlock();
 7848     BasicBlock* elseCase = proc.addBlock();
 7849 
 7850     Value* argumentA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
 7851     Value* argumentB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
 7852     root-&gt;appendNewControlValue(
 7853         proc, Branch, Origin(),
 7854         root-&gt;appendNew&lt;Value&gt;(
 7855             proc, EqualOrUnordered, Origin(),
 7856             argumentA,
 7857             argumentB),
 7858         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7859 
 7860     thenCase-&gt;appendNewControlValue(
 7861         proc, Return, Origin(),
 7862         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7863 
 7864     elseCase-&gt;appendNewControlValue(
 7865         proc, Return, Origin(),
 7866         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7867 
 7868     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7869     CHECK(compileAndRun&lt;int64_t&gt;(proc) == expected);
 7870 }
 7871 
 7872 void testBranchEqualOrUnorderedFloatImms(float a, float b)
 7873 {
 7874     Procedure proc;
 7875     BasicBlock* root = proc.addBlock();
 7876     BasicBlock* thenCase = proc.addBlock();
 7877     BasicBlock* elseCase = proc.addBlock();
 7878 
 7879     Value* argumentA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
 7880     Value* argumentB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
 7881 
 7882     root-&gt;appendNewControlValue(
 7883         proc, Branch, Origin(),
 7884         root-&gt;appendNew&lt;Value&gt;(
 7885             proc, EqualOrUnordered, Origin(),
 7886             argumentA,
 7887             argumentB),
 7888         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7889 
 7890     thenCase-&gt;appendNewControlValue(
 7891         proc, Return, Origin(),
 7892         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7893 
 7894     elseCase-&gt;appendNewControlValue(
 7895         proc, Return, Origin(),
 7896         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7897 
 7898     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7899     CHECK(compileAndRun&lt;int64_t&gt;(proc) == expected);
 7900 }
 7901 
 7902 void testBranchEqualOrUnorderedFloatWithUselessDoubleConversion(float a, float b)
 7903 {
 7904     Procedure proc;
 7905     BasicBlock* root = proc.addBlock();
 7906     BasicBlock* thenCase = proc.addBlock();
 7907     BasicBlock* elseCase = proc.addBlock();
 7908 
 7909     Value* argument1 = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7910         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 7911     Value* argument2 = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Float, Origin(),
 7912         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 7913     Value* argument1AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argument1);
 7914     Value* argument2AsDouble = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), argument2);
 7915 
 7916     root-&gt;appendNewControlValue(
 7917         proc, Branch, Origin(),
 7918         root-&gt;appendNew&lt;Value&gt;(
 7919             proc, EqualOrUnordered, Origin(),
 7920             argument1AsDouble,
 7921             argument2AsDouble),
 7922         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7923 
 7924     thenCase-&gt;appendNewControlValue(
 7925         proc, Return, Origin(),
 7926         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 7927 
 7928     elseCase-&gt;appendNewControlValue(
 7929         proc, Return, Origin(),
 7930         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -13));
 7931 
 7932     int64_t expected = (std::isunordered(a, b) || a == b) ? 42 : -13;
 7933     CHECK(compileAndRun&lt;int64_t&gt;(proc, &amp;a, &amp;b) == expected);
 7934 }
 7935 
 7936 void testBranchFold(int value)
 7937 {
 7938     Procedure proc;
 7939     BasicBlock* root = proc.addBlock();
 7940     BasicBlock* thenCase = proc.addBlock();
 7941     BasicBlock* elseCase = proc.addBlock();
 7942 
 7943     root-&gt;appendNewControlValue(
 7944         proc, Branch, Origin(),
 7945         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value),
 7946         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7947 
 7948     thenCase-&gt;appendNewControlValue(
 7949         proc, Return, Origin(),
 7950         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7951 
 7952     elseCase-&gt;appendNewControlValue(
 7953         proc, Return, Origin(),
 7954         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7955 
 7956     CHECK(compileAndRun&lt;int&gt;(proc) == !!value);
 7957 }
 7958 
 7959 void testDiamondFold(int value)
 7960 {
 7961     Procedure proc;
 7962     BasicBlock* root = proc.addBlock();
 7963     BasicBlock* thenCase = proc.addBlock();
 7964     BasicBlock* elseCase = proc.addBlock();
 7965     BasicBlock* done = proc.addBlock();
 7966 
 7967     root-&gt;appendNewControlValue(
 7968         proc, Branch, Origin(),
 7969         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value),
 7970         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 7971 
 7972     UpsilonValue* thenResult = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(
 7973         proc, Origin(), thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 7974     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(done));
 7975 
 7976     UpsilonValue* elseResult = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(
 7977         proc, Origin(), elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 7978     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(done));
 7979 
 7980     Value* phi = done-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 7981     thenResult-&gt;setPhi(phi);
 7982     elseResult-&gt;setPhi(phi);
 7983     done-&gt;appendNewControlValue(proc, Return, Origin(), phi);
 7984 
 7985     CHECK(compileAndRun&lt;int&gt;(proc) == !!value);
 7986 }
 7987 
 7988 void testBranchNotEqualFoldPtr(intptr_t value)
 7989 {
 7990     Procedure proc;
 7991     BasicBlock* root = proc.addBlock();
 7992     BasicBlock* thenCase = proc.addBlock();
 7993     BasicBlock* elseCase = proc.addBlock();
 7994 
 7995     root-&gt;appendNewControlValue(
 7996         proc, Branch, Origin(),
 7997         root-&gt;appendNew&lt;Value&gt;(
 7998             proc, NotEqual, Origin(),
 7999             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), value),
 8000             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)),
 8001         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8002 
 8003     thenCase-&gt;appendNewControlValue(
 8004         proc, Return, Origin(),
 8005         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8006 
 8007     elseCase-&gt;appendNewControlValue(
 8008         proc, Return, Origin(),
 8009         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8010 
 8011     CHECK(compileAndRun&lt;int&gt;(proc) == !!value);
 8012 }
 8013 
 8014 void testBranchEqualFoldPtr(intptr_t value)
 8015 {
 8016     Procedure proc;
 8017     BasicBlock* root = proc.addBlock();
 8018     BasicBlock* thenCase = proc.addBlock();
 8019     BasicBlock* elseCase = proc.addBlock();
 8020 
 8021     root-&gt;appendNewControlValue(
 8022         proc, Branch, Origin(),
 8023         root-&gt;appendNew&lt;Value&gt;(
 8024             proc, Equal, Origin(),
 8025             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), value),
 8026             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)),
 8027         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8028 
 8029     thenCase-&gt;appendNewControlValue(
 8030         proc, Return, Origin(),
 8031         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8032 
 8033     elseCase-&gt;appendNewControlValue(
 8034         proc, Return, Origin(),
 8035         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8036 
 8037     CHECK(compileAndRun&lt;int&gt;(proc) == !value);
 8038 }
 8039 
 8040 void testBranchLoadPtr()
 8041 {
 8042     Procedure proc;
 8043     BasicBlock* root = proc.addBlock();
 8044     BasicBlock* thenCase = proc.addBlock();
 8045     BasicBlock* elseCase = proc.addBlock();
 8046 
 8047     root-&gt;appendNewControlValue(
 8048         proc, Branch, Origin(),
 8049         root-&gt;appendNew&lt;MemoryValue&gt;(
 8050             proc, Load, pointerType(), Origin(),
 8051             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8052         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8053 
 8054     thenCase-&gt;appendNewControlValue(
 8055         proc, Return, Origin(),
 8056         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8057 
 8058     elseCase-&gt;appendNewControlValue(
 8059         proc, Return, Origin(),
 8060         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8061 
 8062     auto code = compileProc(proc);
 8063     intptr_t cond;
 8064     cond = 42;
 8065     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8066     cond = 0;
 8067     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8068 }
 8069 
 8070 void testBranchLoad32()
 8071 {
 8072     Procedure proc;
 8073     BasicBlock* root = proc.addBlock();
 8074     BasicBlock* thenCase = proc.addBlock();
 8075     BasicBlock* elseCase = proc.addBlock();
 8076 
 8077     root-&gt;appendNewControlValue(
 8078         proc, Branch, Origin(),
 8079         root-&gt;appendNew&lt;MemoryValue&gt;(
 8080             proc, Load, Int32, Origin(),
 8081             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8082         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8083 
 8084     thenCase-&gt;appendNewControlValue(
 8085         proc, Return, Origin(),
 8086         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8087 
 8088     elseCase-&gt;appendNewControlValue(
 8089         proc, Return, Origin(),
 8090         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8091 
 8092     auto code = compileProc(proc);
 8093     int32_t cond;
 8094     cond = 42;
 8095     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8096     cond = 0;
 8097     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8098 }
 8099 
 8100 void testBranchLoad8S()
 8101 {
 8102     Procedure proc;
 8103     BasicBlock* root = proc.addBlock();
 8104     BasicBlock* thenCase = proc.addBlock();
 8105     BasicBlock* elseCase = proc.addBlock();
 8106 
 8107     root-&gt;appendNewControlValue(
 8108         proc, Branch, Origin(),
 8109         root-&gt;appendNew&lt;MemoryValue&gt;(
 8110             proc, Load8S, Origin(),
 8111             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8112         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8113 
 8114     thenCase-&gt;appendNewControlValue(
 8115         proc, Return, Origin(),
 8116         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8117 
 8118     elseCase-&gt;appendNewControlValue(
 8119         proc, Return, Origin(),
 8120         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8121 
 8122     auto code = compileProc(proc);
 8123     int8_t cond;
 8124     cond = -1;
 8125     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8126     cond = 0;
 8127     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8128 }
 8129 
 8130 void testBranchLoad8Z()
 8131 {
 8132     Procedure proc;
 8133     BasicBlock* root = proc.addBlock();
 8134     BasicBlock* thenCase = proc.addBlock();
 8135     BasicBlock* elseCase = proc.addBlock();
 8136 
 8137     root-&gt;appendNewControlValue(
 8138         proc, Branch, Origin(),
 8139         root-&gt;appendNew&lt;MemoryValue&gt;(
 8140             proc, Load8Z, Origin(),
 8141             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8142         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8143 
 8144     thenCase-&gt;appendNewControlValue(
 8145         proc, Return, Origin(),
 8146         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8147 
 8148     elseCase-&gt;appendNewControlValue(
 8149         proc, Return, Origin(),
 8150         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8151 
 8152     auto code = compileProc(proc);
 8153     uint8_t cond;
 8154     cond = 1;
 8155     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8156     cond = 0;
 8157     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8158 }
 8159 
 8160 void testBranchLoad16S()
 8161 {
 8162     Procedure proc;
 8163     BasicBlock* root = proc.addBlock();
 8164     BasicBlock* thenCase = proc.addBlock();
 8165     BasicBlock* elseCase = proc.addBlock();
 8166 
 8167     root-&gt;appendNewControlValue(
 8168         proc, Branch, Origin(),
 8169         root-&gt;appendNew&lt;MemoryValue&gt;(
 8170             proc, Load16S, Origin(),
 8171             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8172         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8173 
 8174     thenCase-&gt;appendNewControlValue(
 8175         proc, Return, Origin(),
 8176         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8177 
 8178     elseCase-&gt;appendNewControlValue(
 8179         proc, Return, Origin(),
 8180         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8181 
 8182     auto code = compileProc(proc);
 8183     int16_t cond;
 8184     cond = -1;
 8185     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8186     cond = 0;
 8187     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8188 }
 8189 
 8190 void testBranchLoad16Z()
 8191 {
 8192     Procedure proc;
 8193     BasicBlock* root = proc.addBlock();
 8194     BasicBlock* thenCase = proc.addBlock();
 8195     BasicBlock* elseCase = proc.addBlock();
 8196 
 8197     root-&gt;appendNewControlValue(
 8198         proc, Branch, Origin(),
 8199         root-&gt;appendNew&lt;MemoryValue&gt;(
 8200             proc, Load16Z, Origin(),
 8201             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 8202         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8203 
 8204     thenCase-&gt;appendNewControlValue(
 8205         proc, Return, Origin(),
 8206         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8207 
 8208     elseCase-&gt;appendNewControlValue(
 8209         proc, Return, Origin(),
 8210         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8211 
 8212     auto code = compileProc(proc);
 8213     uint16_t cond;
 8214     cond = 1;
 8215     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 1);
 8216     cond = 0;
 8217     CHECK(invoke&lt;int&gt;(*code, &amp;cond) == 0);
 8218 }
 8219 
 8220 void testBranch8WithLoad8ZIndex()
 8221 {
 8222     Procedure proc;
 8223     BasicBlock* root = proc.addBlock();
 8224     BasicBlock* thenCase = proc.addBlock();
 8225     BasicBlock* elseCase = proc.addBlock();
 8226 
 8227     int logScale = 1;
 8228     root-&gt;appendNewControlValue(
 8229         proc, Branch, Origin(),
 8230         root-&gt;appendNew&lt;Value&gt;(
 8231             proc, Above, Origin(),
 8232             root-&gt;appendNew&lt;MemoryValue&gt;(
 8233                 proc, Load8Z, Origin(),
 8234                 root-&gt;appendNew&lt;Value&gt;(
 8235                     proc, Add, Origin(),
 8236                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 8237                     root-&gt;appendNew&lt;Value&gt;(
 8238                         proc, Shl, Origin(),
 8239                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 8240                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)))),
 8241             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 250)),
 8242         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 8243 
 8244     thenCase-&gt;appendNewControlValue(
 8245         proc, Return, Origin(),
 8246         thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8247 
 8248     elseCase-&gt;appendNewControlValue(
 8249         proc, Return, Origin(),
 8250         elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8251 
 8252     auto code = compileProc(proc);
 8253     uint32_t cond;
 8254     cond = 0xffffffffU; // All bytes are 0xff.
 8255     CHECK(invoke&lt;int&gt;(*code, &amp;cond - 2, (sizeof(uint32_t) * 2) &gt;&gt; logScale) == 1);
 8256     cond = 0x00000000U; // All bytes are 0.
 8257     CHECK(invoke&lt;int&gt;(*code, &amp;cond - 2, (sizeof(uint32_t) * 2) &gt;&gt; logScale) == 0);
 8258 }
 8259 
 8260 void testComplex(unsigned numVars, unsigned numConstructs)
 8261 {
 8262     MonotonicTime before = MonotonicTime::now();
 8263 
 8264     Procedure proc;
 8265     BasicBlock* current = proc.addBlock();
 8266 
 8267     Const32Value* one = current-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 8268 
 8269     Vector&lt;int32_t&gt; varSlots;
 8270     for (unsigned i = numVars; i--;)
 8271         varSlots.append(i);
 8272 
 8273     Vector&lt;Value*&gt; vars;
 8274     for (int32_t&amp; varSlot : varSlots) {
 8275         Value* varSlotPtr = current-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;varSlot);
 8276         vars.append(current-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), varSlotPtr));
 8277     }
 8278 
 8279     for (unsigned i = 0; i &lt; numConstructs; ++i) {
 8280         if (i &amp; 1) {
 8281             // Control flow diamond.
 8282             unsigned predicateVarIndex = ((i &gt;&gt; 1) + 2) % numVars;
 8283             unsigned thenIncVarIndex = ((i &gt;&gt; 1) + 0) % numVars;
 8284             unsigned elseIncVarIndex = ((i &gt;&gt; 1) + 1) % numVars;
 8285 
 8286             BasicBlock* thenBlock = proc.addBlock();
 8287             BasicBlock* elseBlock = proc.addBlock();
 8288             BasicBlock* continuation = proc.addBlock();
 8289 
 8290             current-&gt;appendNewControlValue(
 8291                 proc, Branch, Origin(), vars[predicateVarIndex],
 8292                 FrequentedBlock(thenBlock), FrequentedBlock(elseBlock));
 8293 
 8294             UpsilonValue* thenThenResult = thenBlock-&gt;appendNew&lt;UpsilonValue&gt;(
 8295                 proc, Origin(),
 8296                 thenBlock-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), vars[thenIncVarIndex], one));
 8297             UpsilonValue* thenElseResult = thenBlock-&gt;appendNew&lt;UpsilonValue&gt;(
 8298                 proc, Origin(), vars[elseIncVarIndex]);
 8299             thenBlock-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(continuation));
 8300 
 8301             UpsilonValue* elseElseResult = elseBlock-&gt;appendNew&lt;UpsilonValue&gt;(
 8302                 proc, Origin(),
 8303                 elseBlock-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), vars[elseIncVarIndex], one));
 8304             UpsilonValue* elseThenResult = elseBlock-&gt;appendNew&lt;UpsilonValue&gt;(
 8305                 proc, Origin(), vars[thenIncVarIndex]);
 8306             elseBlock-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(continuation));
 8307 
 8308             Value* thenPhi = continuation-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 8309             thenThenResult-&gt;setPhi(thenPhi);
 8310             elseThenResult-&gt;setPhi(thenPhi);
 8311             vars[thenIncVarIndex] = thenPhi;
 8312 
 8313             Value* elsePhi = continuation-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 8314             thenElseResult-&gt;setPhi(elsePhi);
 8315             elseElseResult-&gt;setPhi(elsePhi);
 8316             vars[elseIncVarIndex] = thenPhi;
 8317 
 8318             current = continuation;
 8319         } else {
 8320             // Loop.
 8321 
 8322             BasicBlock* loopEntry = proc.addBlock();
 8323             BasicBlock* loopReentry = proc.addBlock();
 8324             BasicBlock* loopBody = proc.addBlock();
 8325             BasicBlock* loopExit = proc.addBlock();
 8326             BasicBlock* loopSkip = proc.addBlock();
 8327             BasicBlock* continuation = proc.addBlock();
 8328 
 8329             Value* startIndex = vars[((i &gt;&gt; 1) + 1) % numVars];
 8330             Value* startSum = current-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0);
 8331             current-&gt;appendNewControlValue(
 8332                 proc, Branch, Origin(), startIndex,
 8333                 FrequentedBlock(loopEntry), FrequentedBlock(loopSkip));
 8334 
 8335             UpsilonValue* startIndexForBody = loopEntry-&gt;appendNew&lt;UpsilonValue&gt;(
 8336                 proc, Origin(), startIndex);
 8337             UpsilonValue* startSumForBody = loopEntry-&gt;appendNew&lt;UpsilonValue&gt;(
 8338                 proc, Origin(), startSum);
 8339             loopEntry-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loopBody));
 8340 
 8341             Value* bodyIndex = loopBody-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 8342             startIndexForBody-&gt;setPhi(bodyIndex);
 8343             Value* bodySum = loopBody-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 8344             startSumForBody-&gt;setPhi(bodySum);
 8345             Value* newBodyIndex = loopBody-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), bodyIndex, one);
 8346             Value* newBodySum = loopBody-&gt;appendNew&lt;Value&gt;(
 8347                 proc, Add, Origin(),
 8348                 bodySum,
 8349                 loopBody-&gt;appendNew&lt;MemoryValue&gt;(
 8350                     proc, Load, Int32, Origin(),
 8351                     loopBody-&gt;appendNew&lt;Value&gt;(
 8352                         proc, Add, Origin(),
 8353                         loopBody-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), varSlots.data()),
 8354                         loopBody-&gt;appendNew&lt;Value&gt;(
 8355                             proc, Shl, Origin(),
 8356                             loopBody-&gt;appendNew&lt;Value&gt;(
 8357                                 proc, ZExt32, Origin(),
 8358                                 loopBody-&gt;appendNew&lt;Value&gt;(
 8359                                     proc, BitAnd, Origin(),
 8360                                     newBodyIndex,
 8361                                     loopBody-&gt;appendNew&lt;Const32Value&gt;(
 8362                                         proc, Origin(), numVars - 1))),
 8363                             loopBody-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)))));
 8364             loopBody-&gt;appendNewControlValue(
 8365                 proc, Branch, Origin(), newBodyIndex,
 8366                 FrequentedBlock(loopReentry), FrequentedBlock(loopExit));
 8367 
 8368             loopReentry-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newBodyIndex, bodyIndex);
 8369             loopReentry-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newBodySum, bodySum);
 8370             loopReentry-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loopBody));
 8371 
 8372             UpsilonValue* exitSum = loopExit-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newBodySum);
 8373             loopExit-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(continuation));
 8374 
 8375             UpsilonValue* skipSum = loopSkip-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), startSum);
 8376             loopSkip-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(continuation));
 8377 
 8378             Value* finalSum = continuation-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 8379             exitSum-&gt;setPhi(finalSum);
 8380             skipSum-&gt;setPhi(finalSum);
 8381 
 8382             current = continuation;
 8383             vars[((i &gt;&gt; 1) + 0) % numVars] = finalSum;
 8384         }
 8385     }
 8386 
 8387     current-&gt;appendNewControlValue(proc, Return, Origin(), vars[0]);
 8388 
 8389     compileProc(proc);
 8390 
 8391     MonotonicTime after = MonotonicTime::now();
 8392     dataLog(toCString(&quot;    That took &quot;, (after - before).milliseconds(), &quot; ms.\n&quot;));
 8393 }
 8394 
 8395 void testSimplePatchpoint()
 8396 {
 8397     Procedure proc;
 8398     BasicBlock* root = proc.addBlock();
 8399     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8400     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8401     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8402     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 8403     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 8404     patchpoint-&gt;setGenerator(
 8405         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8406             AllowMacroScratchRegisterUsage allowScratch(jit);
 8407             CHECK(params.size() == 3);
 8408             CHECK(params[0].isGPR());
 8409             CHECK(params[1].isGPR());
 8410             CHECK(params[2].isGPR());
 8411             add32(jit, params[1].gpr(), params[2].gpr(), params[0].gpr());
 8412         });
 8413     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8414 
 8415     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8416 }
 8417 
 8418 void testSimplePatchpointWithoutOuputClobbersGPArgs()
 8419 {
 8420     Procedure proc;
 8421     BasicBlock* root = proc.addBlock();
 8422     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8423     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8424     Value* const1 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 42);
 8425     Value* const2 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 13);
 8426 
 8427     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 8428     patchpoint-&gt;clobberLate(RegisterSet(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1));
 8429     patchpoint-&gt;append(ConstrainedValue(const1, ValueRep::SomeRegister));
 8430     patchpoint-&gt;append(ConstrainedValue(const2, ValueRep::SomeRegister));
 8431     patchpoint-&gt;setGenerator(
 8432         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8433             AllowMacroScratchRegisterUsage allowScratch(jit);
 8434             CHECK(params.size() == 2);
 8435             CHECK(params[0].isGPR());
 8436             CHECK(params[1].isGPR());
 8437             jit.move(CCallHelpers::TrustedImm32(0x00ff00ff), params[0].gpr());
 8438             jit.move(CCallHelpers::TrustedImm32(0x00ff00ff), params[1].gpr());
 8439             jit.move(CCallHelpers::TrustedImm32(0x00ff00ff), GPRInfo::argumentGPR0);
 8440             jit.move(CCallHelpers::TrustedImm32(0x00ff00ff), GPRInfo::argumentGPR1);
 8441         });
 8442 
 8443     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg1, arg2);
 8444     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 8445 
 8446     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8447 }
 8448 
 8449 void testSimplePatchpointWithOuputClobbersGPArgs()
 8450 {
 8451     // We can&#39;t predict where the output will be but we want to be sure it is not
 8452     // one of the clobbered registers which is a bit hard to test.
 8453     //
 8454     // What we do is force the hand of our register allocator by clobbering absolutely
 8455     // everything but 1. The only valid allocation is to give it to the result and
 8456     // spill everything else.
 8457 
 8458     Procedure proc;
 8459     BasicBlock* root = proc.addBlock();
 8460     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8461     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8462     Value* const1 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 42);
 8463     Value* const2 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 13);
 8464 
 8465     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
 8466 
 8467     RegisterSet clobberAll = RegisterSet::allGPRs();
 8468     clobberAll.exclude(RegisterSet::stackRegisters());
 8469     clobberAll.exclude(RegisterSet::reservedHardwareRegisters());
 8470     clobberAll.clear(GPRInfo::argumentGPR2);
 8471     patchpoint-&gt;clobberLate(clobberAll);
 8472 
 8473     patchpoint-&gt;append(ConstrainedValue(const1, ValueRep::SomeRegister));
 8474     patchpoint-&gt;append(ConstrainedValue(const2, ValueRep::SomeRegister));
 8475 
 8476     patchpoint-&gt;setGenerator(
 8477         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8478             AllowMacroScratchRegisterUsage allowScratch(jit);
 8479             CHECK(params.size() == 3);
 8480             CHECK(params[0].isGPR());
 8481             CHECK(params[1].isGPR());
 8482             CHECK(params[2].isGPR());
 8483             jit.move(params[1].gpr(), params[0].gpr());
 8484             jit.add64(params[2].gpr(), params[0].gpr());
 8485 
 8486             clobberAll.forEach([&amp;] (Reg reg) {
 8487                 jit.move(CCallHelpers::TrustedImm32(0x00ff00ff), reg.gpr());
 8488             });
 8489         });
 8490 
 8491     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), patchpoint,
 8492         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg1, arg2));
 8493     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 8494 
 8495     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 58);
 8496 }
 8497 
 8498 void testSimplePatchpointWithoutOuputClobbersFPArgs()
 8499 {
 8500     Procedure proc;
 8501     BasicBlock* root = proc.addBlock();
 8502     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 8503     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 8504     Value* const1 = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5);
 8505     Value* const2 = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 13.1);
 8506 
 8507     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 8508     patchpoint-&gt;clobberLate(RegisterSet(FPRInfo::argumentFPR0, FPRInfo::argumentFPR1));
 8509     patchpoint-&gt;append(ConstrainedValue(const1, ValueRep::SomeRegister));
 8510     patchpoint-&gt;append(ConstrainedValue(const2, ValueRep::SomeRegister));
 8511     patchpoint-&gt;setGenerator(
 8512         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8513             AllowMacroScratchRegisterUsage allowScratch(jit);
 8514             CHECK(params.size() == 2);
 8515             CHECK(params[0].isFPR());
 8516             CHECK(params[1].isFPR());
 8517             jit.moveZeroToDouble(params[0].fpr());
 8518             jit.moveZeroToDouble(params[1].fpr());
 8519             jit.moveZeroToDouble(FPRInfo::argumentFPR0);
 8520             jit.moveZeroToDouble(FPRInfo::argumentFPR1);
 8521         });
 8522 
 8523     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg1, arg2);
 8524     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 8525 
 8526     CHECK(compileAndRun&lt;double&gt;(proc, 1.5, 2.5) == 4);
 8527 }
 8528 
 8529 void testSimplePatchpointWithOuputClobbersFPArgs()
 8530 {
 8531     Procedure proc;
 8532     BasicBlock* root = proc.addBlock();
 8533     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
 8534     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
 8535     Value* const1 = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5);
 8536     Value* const2 = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 13.1);
 8537 
 8538     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Double, Origin());
 8539 
 8540     RegisterSet clobberAll = RegisterSet::allFPRs();
 8541     clobberAll.exclude(RegisterSet::stackRegisters());
 8542     clobberAll.exclude(RegisterSet::reservedHardwareRegisters());
 8543     clobberAll.clear(FPRInfo::argumentFPR2);
 8544     patchpoint-&gt;clobberLate(clobberAll);
 8545 
 8546     patchpoint-&gt;append(ConstrainedValue(const1, ValueRep::SomeRegister));
 8547     patchpoint-&gt;append(ConstrainedValue(const2, ValueRep::SomeRegister));
 8548 
 8549     patchpoint-&gt;setGenerator(
 8550         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8551             AllowMacroScratchRegisterUsage allowScratch(jit);
 8552             CHECK(params.size() == 3);
 8553             CHECK(params[0].isFPR());
 8554             CHECK(params[1].isFPR());
 8555             CHECK(params[2].isFPR());
 8556             jit.addDouble(params[1].fpr(), params[2].fpr(), params[0].fpr());
 8557 
 8558             clobberAll.forEach([&amp;] (Reg reg) {
 8559                 jit.moveZeroToDouble(reg.fpr());
 8560             });
 8561         });
 8562 
 8563     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), patchpoint,
 8564         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg1, arg2));
 8565     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 8566 
 8567     CHECK(compileAndRun&lt;double&gt;(proc, 1.5, 2.5) == 59.6);
 8568 }
 8569 
 8570 void testPatchpointWithEarlyClobber()
 8571 {
 8572     auto test = [] (GPRReg registerToClobber, bool arg1InArgGPR, bool arg2InArgGPR) {
 8573         Procedure proc;
 8574         BasicBlock* root = proc.addBlock();
 8575         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8576         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8577 
 8578         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8579         patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 8580         patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 8581         patchpoint-&gt;clobberEarly(RegisterSet(registerToClobber));
 8582         patchpoint-&gt;setGenerator(
 8583             [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8584                 CHECK((params[1].gpr() == GPRInfo::argumentGPR0) == arg1InArgGPR);
 8585                 CHECK((params[2].gpr() == GPRInfo::argumentGPR1) == arg2InArgGPR);
 8586 
 8587                 add32(jit, params[1].gpr(), params[2].gpr(), params[0].gpr());
 8588             });
 8589 
 8590         root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8591 
 8592         CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8593     };
 8594 
 8595     test(GPRInfo::nonArgGPR0, true, true);
 8596     test(GPRInfo::argumentGPR0, false, true);
 8597     test(GPRInfo::argumentGPR1, true, false);
 8598 }
 8599 
 8600 void testPatchpointCallArg()
 8601 {
 8602     Procedure proc;
 8603     BasicBlock* root = proc.addBlock();
 8604     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8605     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8606     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8607     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::stackArgument(0)));
 8608     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::stackArgument(8)));
 8609     patchpoint-&gt;setGenerator(
 8610         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8611             AllowMacroScratchRegisterUsage allowScratch(jit);
 8612             CHECK(params.size() == 3);
 8613             CHECK(params[0].isGPR());
 8614             CHECK(params[1].isStack());
 8615             CHECK(params[2].isStack());
 8616             jit.load32(
 8617                 CCallHelpers::Address(GPRInfo::callFrameRegister, params[1].offsetFromFP()),
 8618                 params[0].gpr());
 8619             jit.add32(
 8620                 CCallHelpers::Address(GPRInfo::callFrameRegister, params[2].offsetFromFP()),
 8621                 params[0].gpr());
 8622         });
 8623     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8624 
 8625     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8626 }
 8627 
 8628 void testPatchpointFixedRegister()
 8629 {
 8630     Procedure proc;
 8631     BasicBlock* root = proc.addBlock();
 8632     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8633     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8634     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8635     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep(GPRInfo::regT0)));
 8636     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep(GPRInfo::regT1)));
 8637     patchpoint-&gt;setGenerator(
 8638         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8639             AllowMacroScratchRegisterUsage allowScratch(jit);
 8640             CHECK(params.size() == 3);
 8641             CHECK(params[0].isGPR());
 8642             CHECK(params[1] == ValueRep(GPRInfo::regT0));
 8643             CHECK(params[2] == ValueRep(GPRInfo::regT1));
 8644             add32(jit, GPRInfo::regT0, GPRInfo::regT1, params[0].gpr());
 8645         });
 8646     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8647 
 8648     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8649 }
 8650 
 8651 void testPatchpointAny(ValueRep rep)
 8652 {
 8653     Procedure proc;
 8654     BasicBlock* root = proc.addBlock();
 8655     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8656     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8657     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8658     patchpoint-&gt;append(ConstrainedValue(arg1, rep));
 8659     patchpoint-&gt;append(ConstrainedValue(arg2, rep));
 8660     patchpoint-&gt;setGenerator(
 8661         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8662             AllowMacroScratchRegisterUsage allowScratch(jit);
 8663             // We shouldn&#39;t have spilled the inputs, so we assert that they&#39;re in registers.
 8664             CHECK(params.size() == 3);
 8665             CHECK(params[0].isGPR());
 8666             CHECK(params[1].isGPR());
 8667             CHECK(params[2].isGPR());
 8668             add32(jit, params[1].gpr(), params[2].gpr(), params[0].gpr());
 8669         });
 8670     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8671 
 8672     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8673 }
 8674 
 8675 void testPatchpointGPScratch()
 8676 {
 8677     Procedure proc;
 8678     BasicBlock* root = proc.addBlock();
 8679     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8680     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8681     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8682     patchpoint-&gt;append(arg1, ValueRep::SomeRegister);
 8683     patchpoint-&gt;append(arg2, ValueRep::SomeRegister);
 8684     patchpoint-&gt;numGPScratchRegisters = 2;
 8685     patchpoint-&gt;setGenerator(
 8686         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8687             AllowMacroScratchRegisterUsage allowScratch(jit);
 8688             // We shouldn&#39;t have spilled the inputs, so we assert that they&#39;re in registers.
 8689             CHECK(params.size() == 3);
 8690             CHECK(params[0].isGPR());
 8691             CHECK(params[1].isGPR());
 8692             CHECK(params[2].isGPR());
 8693             CHECK(params.gpScratch(0) != InvalidGPRReg);
 8694             CHECK(params.gpScratch(0) != params[0].gpr());
 8695             CHECK(params.gpScratch(0) != params[1].gpr());
 8696             CHECK(params.gpScratch(0) != params[2].gpr());
 8697             CHECK(params.gpScratch(1) != InvalidGPRReg);
 8698             CHECK(params.gpScratch(1) != params.gpScratch(0));
 8699             CHECK(params.gpScratch(1) != params[0].gpr());
 8700             CHECK(params.gpScratch(1) != params[1].gpr());
 8701             CHECK(params.gpScratch(1) != params[2].gpr());
 8702             CHECK(!params.unavailableRegisters().get(params.gpScratch(0)));
 8703             CHECK(!params.unavailableRegisters().get(params.gpScratch(1)));
 8704             add32(jit, params[1].gpr(), params[2].gpr(), params[0].gpr());
 8705         });
 8706     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8707 
 8708     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8709 }
 8710 
 8711 void testPatchpointFPScratch()
 8712 {
 8713     Procedure proc;
 8714     BasicBlock* root = proc.addBlock();
 8715     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8716     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8717     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8718     patchpoint-&gt;append(arg1, ValueRep::SomeRegister);
 8719     patchpoint-&gt;append(arg2, ValueRep::SomeRegister);
 8720     patchpoint-&gt;numFPScratchRegisters = 2;
 8721     patchpoint-&gt;setGenerator(
 8722         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8723             AllowMacroScratchRegisterUsage allowScratch(jit);
 8724             // We shouldn&#39;t have spilled the inputs, so we assert that they&#39;re in registers.
 8725             CHECK(params.size() == 3);
 8726             CHECK(params[0].isGPR());
 8727             CHECK(params[1].isGPR());
 8728             CHECK(params[2].isGPR());
 8729             CHECK(params.fpScratch(0) != InvalidFPRReg);
 8730             CHECK(params.fpScratch(1) != InvalidFPRReg);
 8731             CHECK(params.fpScratch(1) != params.fpScratch(0));
 8732             CHECK(!params.unavailableRegisters().get(params.fpScratch(0)));
 8733             CHECK(!params.unavailableRegisters().get(params.fpScratch(1)));
 8734             add32(jit, params[1].gpr(), params[2].gpr(), params[0].gpr());
 8735         });
 8736     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8737 
 8738     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8739 }
 8740 
 8741 void testPatchpointLotsOfLateAnys()
 8742 {
 8743     Procedure proc;
 8744     BasicBlock* root = proc.addBlock();
 8745     Vector&lt;int&gt; things;
 8746     for (unsigned i = 200; i--;)
 8747         things.append(i);
 8748 
 8749     Vector&lt;Value*&gt; values;
 8750     for (int&amp; thing : things) {
 8751         Value* value = root-&gt;appendNew&lt;MemoryValue&gt;(
 8752             proc, Load, Int32, Origin(),
 8753             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;thing));
 8754         values.append(value);
 8755     }
 8756 
 8757     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8758     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8759     for (Value* value : values)
 8760         patchpoint-&gt;append(ConstrainedValue(value, ValueRep::LateColdAny));
 8761     patchpoint-&gt;setGenerator(
 8762         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8763             AllowMacroScratchRegisterUsage allowScratch(jit);
 8764             // We shouldn&#39;t have spilled the inputs, so we assert that they&#39;re in registers.
 8765             CHECK(params.size() == things.size() + 1);
 8766             CHECK(params[0].isGPR());
 8767             jit.move(CCallHelpers::TrustedImm32(0), params[0].gpr());
 8768             for (unsigned i = 1; i &lt; params.size(); ++i) {
 8769                 if (params[i].isGPR()) {
 8770                     CHECK(params[i] != params[0]);
 8771                     jit.add32(params[i].gpr(), params[0].gpr());
 8772                 } else {
 8773                     CHECK(params[i].isStack());
 8774                     jit.add32(CCallHelpers::Address(GPRInfo::callFrameRegister, params[i].offsetFromFP()), params[0].gpr());
 8775                 }
 8776             }
 8777         });
 8778     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8779 
 8780     CHECK(static_cast&lt;size_t&gt;(compileAndRun&lt;int&gt;(proc)) == (things.size() * (things.size() - 1)) / 2);
 8781 }
 8782 
 8783 void testPatchpointAnyImm(ValueRep rep)
 8784 {
 8785     Procedure proc;
 8786     BasicBlock* root = proc.addBlock();
 8787     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 8788         proc, Trunc, Origin(),
 8789         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 8790     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 8791     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8792     patchpoint-&gt;append(ConstrainedValue(arg1, rep));
 8793     patchpoint-&gt;append(ConstrainedValue(arg2, rep));
 8794     patchpoint-&gt;setGenerator(
 8795         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8796             AllowMacroScratchRegisterUsage allowScratch(jit);
 8797             CHECK(params.size() == 3);
 8798             CHECK(params[0].isGPR());
 8799             CHECK(params[1].isGPR());
 8800             CHECK(params[2].isConstant());
 8801             CHECK(params[2].value() == 42);
 8802             jit.add32(
 8803                 CCallHelpers::TrustedImm32(static_cast&lt;int32_t&gt;(params[2].value())),
 8804                 params[1].gpr(), params[0].gpr());
 8805         });
 8806     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8807 
 8808     CHECK(compileAndRun&lt;int&gt;(proc, 1) == 43);
 8809 }
 8810 
 8811 void testPatchpointManyImms()
 8812 {
 8813     Procedure proc;
 8814     BasicBlock* root = proc.addBlock();
 8815     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 8816     Value* arg2 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 43);
 8817     Value* arg3 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 43000000000000ll);
 8818     Value* arg4 = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 42.5);
 8819     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 8820     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::WarmAny));
 8821     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::WarmAny));
 8822     patchpoint-&gt;append(ConstrainedValue(arg3, ValueRep::WarmAny));
 8823     patchpoint-&gt;append(ConstrainedValue(arg4, ValueRep::WarmAny));
 8824     patchpoint-&gt;setGenerator(
 8825         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
 8826             CHECK(params.size() == 4);
 8827             CHECK(params[0] == ValueRep::constant(42));
 8828             CHECK(params[1] == ValueRep::constant(43));
 8829             CHECK(params[2] == ValueRep::constant(43000000000000ll));
 8830             CHECK(params[3] == ValueRep::constant(bitwise_cast&lt;int64_t&gt;(42.5)));
 8831         });
 8832     root-&gt;appendNewControlValue(
 8833         proc, Return, Origin(),
 8834         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8835 
 8836     CHECK(!compileAndRun&lt;int&gt;(proc));
 8837 }
 8838 
 8839 void testPatchpointWithRegisterResult()
 8840 {
 8841     Procedure proc;
 8842     BasicBlock* root = proc.addBlock();
 8843     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8844     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8845     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8846     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 8847     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 8848     patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::nonArgGPR0);
 8849     patchpoint-&gt;setGenerator(
 8850         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8851             AllowMacroScratchRegisterUsage allowScratch(jit);
 8852             CHECK(params.size() == 3);
 8853             CHECK(params[0] == ValueRep::reg(GPRInfo::nonArgGPR0));
 8854             CHECK(params[1].isGPR());
 8855             CHECK(params[2].isGPR());
 8856             add32(jit, params[1].gpr(), params[2].gpr(), GPRInfo::nonArgGPR0);
 8857         });
 8858     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8859 
 8860     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8861 }
 8862 
 8863 void testPatchpointWithStackArgumentResult()
 8864 {
 8865     Procedure proc;
 8866     BasicBlock* root = proc.addBlock();
 8867     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8868     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8869     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
 8870     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 8871     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 8872     patchpoint-&gt;resultConstraint = ValueRep::stackArgument(0);
 8873     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8874     patchpoint-&gt;setGenerator(
 8875         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8876             AllowMacroScratchRegisterUsage allowScratch(jit);
 8877             CHECK(params.size() == 3);
 8878             CHECK(params[0] == ValueRep::stack(-static_cast&lt;intptr_t&gt;(proc.frameSize())));
 8879             CHECK(params[1].isGPR());
 8880             CHECK(params[2].isGPR());
 8881             jit.add32(params[1].gpr(), params[2].gpr(), jit.scratchRegister());
 8882             jit.store32(jit.scratchRegister(), CCallHelpers::Address(CCallHelpers::stackPointerRegister, 0));
 8883         });
 8884     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8885 
 8886     CHECK(compileAndRun&lt;int&gt;(proc, 1, 2) == 3);
 8887 }
 8888 
 8889 void testPatchpointWithAnyResult()
 8890 {
 8891     Procedure proc;
 8892     BasicBlock* root = proc.addBlock();
 8893     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8894     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 8895     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Double, Origin());
 8896     patchpoint-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 8897     patchpoint-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 8898     patchpoint-&gt;resultConstraint = ValueRep::WarmAny;
 8899     patchpoint-&gt;clobberLate(RegisterSet::allFPRs());
 8900     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8901     patchpoint-&gt;clobber(RegisterSet(GPRInfo::regT0));
 8902     patchpoint-&gt;setGenerator(
 8903         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8904             AllowMacroScratchRegisterUsage allowScratch(jit);
 8905             CHECK(params.size() == 3);
 8906             CHECK(params[0].isStack());
 8907             CHECK(params[1].isGPR());
 8908             CHECK(params[2].isGPR());
 8909             add32(jit, params[1].gpr(), params[2].gpr(), GPRInfo::regT0);
 8910             jit.convertInt32ToDouble(GPRInfo::regT0, FPRInfo::fpRegT0);
 8911             jit.storeDouble(FPRInfo::fpRegT0, CCallHelpers::Address(GPRInfo::callFrameRegister, params[0].offsetFromFP()));
 8912         });
 8913     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
 8914 
 8915     CHECK(compileAndRun&lt;double&gt;(proc, 1, 2) == 3);
 8916 }
 8917 
 8918 void testSimpleCheck()
 8919 {
 8920     Procedure proc;
 8921     BasicBlock* root = proc.addBlock();
 8922     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 8923     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), arg);
 8924     check-&gt;setGenerator(
 8925         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8926             AllowMacroScratchRegisterUsage allowScratch(jit);
 8927             CHECK(!params.size());
 8928 
 8929             // This should always work because a function this simple should never have callee
 8930             // saves.
 8931             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 8932             jit.emitFunctionEpilogue();
 8933             jit.ret();
 8934         });
 8935     root-&gt;appendNewControlValue(
 8936         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8937 
 8938     auto code = compileProc(proc);
 8939 
 8940     CHECK(invoke&lt;int&gt;(*code, 0) == 0);
 8941     CHECK(invoke&lt;int&gt;(*code, 1) == 42);
 8942 }
 8943 
 8944 void testCheckFalse()
 8945 {
 8946     Procedure proc;
 8947     BasicBlock* root = proc.addBlock();
 8948     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
 8949         proc, Check, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8950     check-&gt;setGenerator(
 8951         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
 8952             CHECK(!&quot;This should not have executed&quot;);
 8953         });
 8954     root-&gt;appendNewControlValue(
 8955         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8956 
 8957     auto code = compileProc(proc);
 8958 
 8959     CHECK(invoke&lt;int&gt;(*code) == 0);
 8960 }
 8961 
 8962 void testCheckTrue()
 8963 {
 8964     Procedure proc;
 8965     BasicBlock* root = proc.addBlock();
 8966     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
 8967         proc, Check, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
 8968     check-&gt;setGenerator(
 8969         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8970             AllowMacroScratchRegisterUsage allowScratch(jit);
 8971             CHECK(params.value()-&gt;opcode() == Patchpoint);
 8972             CHECK(!params.size());
 8973 
 8974             // This should always work because a function this simple should never have callee
 8975             // saves.
 8976             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 8977             jit.emitFunctionEpilogue();
 8978             jit.ret();
 8979         });
 8980     root-&gt;appendNewControlValue(
 8981         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 8982 
 8983     auto code = compileProc(proc);
 8984 
 8985     CHECK(invoke&lt;int&gt;(*code) == 42);
 8986 }
 8987 
 8988 void testCheckLessThan()
 8989 {
 8990     Procedure proc;
 8991     BasicBlock* root = proc.addBlock();
 8992     Value* arg = root-&gt;appendNew&lt;Value&gt;(
 8993         proc, Trunc, Origin(),
 8994         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 8995     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
 8996         proc, Check, Origin(),
 8997         root-&gt;appendNew&lt;Value&gt;(
 8998             proc, LessThan, Origin(), arg,
 8999             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42)));
 9000     check-&gt;setGenerator(
 9001         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9002             AllowMacroScratchRegisterUsage allowScratch(jit);
 9003             CHECK(!params.size());
 9004 
 9005             // This should always work because a function this simple should never have callee
 9006             // saves.
 9007             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9008             jit.emitFunctionEpilogue();
 9009             jit.ret();
 9010         });
 9011     root-&gt;appendNewControlValue(
 9012         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 9013 
 9014     auto code = compileProc(proc);
 9015 
 9016     CHECK(invoke&lt;int&gt;(*code, 42) == 0);
 9017     CHECK(invoke&lt;int&gt;(*code, 1000) == 0);
 9018     CHECK(invoke&lt;int&gt;(*code, 41) == 42);
 9019     CHECK(invoke&lt;int&gt;(*code, 0) == 42);
 9020     CHECK(invoke&lt;int&gt;(*code, -1) == 42);
 9021 }
 9022 
 9023 void testCheckMegaCombo()
 9024 {
 9025     Procedure proc;
 9026     BasicBlock* root = proc.addBlock();
 9027     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9028     Value* index = root-&gt;appendNew&lt;Value&gt;(
 9029         proc, ZExt32, Origin(),
 9030         root-&gt;appendNew&lt;Value&gt;(
 9031             proc, Trunc, Origin(),
 9032             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 9033 
 9034     Value* ptr = root-&gt;appendNew&lt;Value&gt;(
 9035         proc, Add, Origin(), base,
 9036         root-&gt;appendNew&lt;Value&gt;(
 9037             proc, Shl, Origin(), index,
 9038             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 9039 
 9040     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
 9041         proc, Check, Origin(),
 9042         root-&gt;appendNew&lt;Value&gt;(
 9043             proc, LessThan, Origin(),
 9044             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load8S, Origin(), ptr),
 9045             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42)));
 9046     check-&gt;setGenerator(
 9047         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9048             AllowMacroScratchRegisterUsage allowScratch(jit);
 9049             CHECK(!params.size());
 9050 
 9051             // This should always work because a function this simple should never have callee
 9052             // saves.
 9053             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9054             jit.emitFunctionEpilogue();
 9055             jit.ret();
 9056         });
 9057     root-&gt;appendNewControlValue(
 9058         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 9059 
 9060     auto code = compileProc(proc);
 9061 
 9062     int8_t value;
 9063     value = 42;
 9064     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 0);
 9065     value = 127;
 9066     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 0);
 9067     value = 41;
 9068     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9069     value = 0;
 9070     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9071     value = -1;
 9072     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9073 }
 9074 
 9075 void testCheckTrickyMegaCombo()
 9076 {
 9077     Procedure proc;
 9078     BasicBlock* root = proc.addBlock();
 9079     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9080     Value* index = root-&gt;appendNew&lt;Value&gt;(
 9081         proc, ZExt32, Origin(),
 9082         root-&gt;appendNew&lt;Value&gt;(
 9083             proc, Add, Origin(),
 9084             root-&gt;appendNew&lt;Value&gt;(
 9085                 proc, Trunc, Origin(),
 9086                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)),
 9087             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 9088 
 9089     Value* ptr = root-&gt;appendNew&lt;Value&gt;(
 9090         proc, Add, Origin(), base,
 9091         root-&gt;appendNew&lt;Value&gt;(
 9092             proc, Shl, Origin(), index,
 9093             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 9094 
 9095     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
 9096         proc, Check, Origin(),
 9097         root-&gt;appendNew&lt;Value&gt;(
 9098             proc, LessThan, Origin(),
 9099             root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load8S, Origin(), ptr),
 9100             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42)));
 9101     check-&gt;setGenerator(
 9102         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9103             AllowMacroScratchRegisterUsage allowScratch(jit);
 9104             CHECK(!params.size());
 9105 
 9106             // This should always work because a function this simple should never have callee
 9107             // saves.
 9108             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9109             jit.emitFunctionEpilogue();
 9110             jit.ret();
 9111         });
 9112     root-&gt;appendNewControlValue(
 9113         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 9114 
 9115     auto code = compileProc(proc);
 9116 
 9117     int8_t value;
 9118     value = 42;
 9119     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 0) == 0);
 9120     value = 127;
 9121     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 0) == 0);
 9122     value = 41;
 9123     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 0) == 42);
 9124     value = 0;
 9125     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 0) == 42);
 9126     value = -1;
 9127     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 0) == 42);
 9128 }
 9129 
 9130 void testCheckTwoMegaCombos()
 9131 {
 9132     Procedure proc;
 9133     BasicBlock* root = proc.addBlock();
 9134     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9135     Value* index = root-&gt;appendNew&lt;Value&gt;(
 9136         proc, ZExt32, Origin(),
 9137         root-&gt;appendNew&lt;Value&gt;(
 9138             proc, Trunc, Origin(),
 9139             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 9140 
 9141     Value* ptr = root-&gt;appendNew&lt;Value&gt;(
 9142         proc, Add, Origin(), base,
 9143         root-&gt;appendNew&lt;Value&gt;(
 9144             proc, Shl, Origin(), index,
 9145             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 9146 
 9147     Value* predicate = root-&gt;appendNew&lt;Value&gt;(
 9148         proc, LessThan, Origin(),
 9149         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load8S, Origin(), ptr),
 9150         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 9151 
 9152     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), predicate);
 9153     check-&gt;setGenerator(
 9154         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9155             AllowMacroScratchRegisterUsage allowScratch(jit);
 9156             CHECK(!params.size());
 9157 
 9158             // This should always work because a function this simple should never have callee
 9159             // saves.
 9160             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9161             jit.emitFunctionEpilogue();
 9162             jit.ret();
 9163         });
 9164     CheckValue* check2 = root-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), predicate);
 9165     check2-&gt;setGenerator(
 9166         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9167             AllowMacroScratchRegisterUsage allowScratch(jit);
 9168             CHECK(!params.size());
 9169 
 9170             // This should always work because a function this simple should never have callee
 9171             // saves.
 9172             jit.move(CCallHelpers::TrustedImm32(43), GPRInfo::returnValueGPR);
 9173             jit.emitFunctionEpilogue();
 9174             jit.ret();
 9175         });
 9176     root-&gt;appendNewControlValue(
 9177         proc, Return, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 9178 
 9179     auto code = compileProc(proc);
 9180 
 9181     int8_t value;
 9182     value = 42;
 9183     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 0);
 9184     value = 127;
 9185     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 0);
 9186     value = 41;
 9187     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9188     value = 0;
 9189     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9190     value = -1;
 9191     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1) == 42);
 9192 }
 9193 
 9194 void testCheckTwoNonRedundantMegaCombos()
 9195 {
 9196     Procedure proc;
 9197 
 9198     BasicBlock* root = proc.addBlock();
 9199     BasicBlock* thenCase = proc.addBlock();
 9200     BasicBlock* elseCase = proc.addBlock();
 9201 
 9202     Value* base = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9203     Value* index = root-&gt;appendNew&lt;Value&gt;(
 9204         proc, ZExt32, Origin(),
 9205         root-&gt;appendNew&lt;Value&gt;(
 9206             proc, Trunc, Origin(),
 9207             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
 9208     Value* branchPredicate = root-&gt;appendNew&lt;Value&gt;(
 9209         proc, BitAnd, Origin(),
 9210         root-&gt;appendNew&lt;Value&gt;(
 9211             proc, Trunc, Origin(),
 9212             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)),
 9213         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0xff));
 9214 
 9215     Value* ptr = root-&gt;appendNew&lt;Value&gt;(
 9216         proc, Add, Origin(), base,
 9217         root-&gt;appendNew&lt;Value&gt;(
 9218             proc, Shl, Origin(), index,
 9219             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
 9220 
 9221     Value* checkPredicate = root-&gt;appendNew&lt;Value&gt;(
 9222         proc, LessThan, Origin(),
 9223         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load8S, Origin(), ptr),
 9224         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
 9225 
 9226     root-&gt;appendNewControlValue(
 9227         proc, Branch, Origin(), branchPredicate,
 9228         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
 9229 
 9230     CheckValue* check = thenCase-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), checkPredicate);
 9231     check-&gt;setGenerator(
 9232         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9233             AllowMacroScratchRegisterUsage allowScratch(jit);
 9234             CHECK(!params.size());
 9235 
 9236             // This should always work because a function this simple should never have callee
 9237             // saves.
 9238             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9239             jit.emitFunctionEpilogue();
 9240             jit.ret();
 9241         });
 9242     thenCase-&gt;appendNewControlValue(
 9243         proc, Return, Origin(), thenCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 43));
 9244 
 9245     CheckValue* check2 = elseCase-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), checkPredicate);
 9246     check2-&gt;setGenerator(
 9247         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9248             AllowMacroScratchRegisterUsage allowScratch(jit);
 9249             CHECK(!params.size());
 9250 
 9251             // This should always work because a function this simple should never have callee
 9252             // saves.
 9253             jit.move(CCallHelpers::TrustedImm32(44), GPRInfo::returnValueGPR);
 9254             jit.emitFunctionEpilogue();
 9255             jit.ret();
 9256         });
 9257     elseCase-&gt;appendNewControlValue(
 9258         proc, Return, Origin(), elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 45));
 9259 
 9260     auto code = compileProc(proc);
 9261 
 9262     int8_t value;
 9263 
 9264     value = 42;
 9265     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, true) == 43);
 9266     value = 127;
 9267     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, true) == 43);
 9268     value = 41;
 9269     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, true) == 42);
 9270     value = 0;
 9271     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, true) == 42);
 9272     value = -1;
 9273     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, true) == 42);
 9274 
 9275     value = 42;
 9276     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, false) == 45);
 9277     value = 127;
 9278     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, false) == 45);
 9279     value = 41;
 9280     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, false) == 44);
 9281     value = 0;
 9282     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, false) == 44);
 9283     value = -1;
 9284     CHECK(invoke&lt;int&gt;(*code, &amp;value - 2, 1, false) == 44);
 9285 }
 9286 
 9287 void testCheckAddImm()
 9288 {
 9289     Procedure proc;
 9290     BasicBlock* root = proc.addBlock();
 9291     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9292         proc, Trunc, Origin(),
 9293         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9294     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 9295     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9296     checkAdd-&gt;append(arg1);
 9297     checkAdd-&gt;append(arg2);
 9298     checkAdd-&gt;setGenerator(
 9299         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9300             AllowMacroScratchRegisterUsage allowScratch(jit);
 9301             CHECK(params.size() == 2);
 9302             CHECK(params[0].isGPR());
 9303             CHECK(params[1].isConstant());
 9304             CHECK(params[1].value() == 42);
 9305             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9306             jit.convertInt32ToDouble(CCallHelpers::TrustedImm32(42), FPRInfo::fpRegT1);
 9307             jit.addDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9308             jit.emitFunctionEpilogue();
 9309             jit.ret();
 9310         });
 9311     root-&gt;appendNewControlValue(
 9312         proc, Return, Origin(),
 9313         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkAdd));
 9314 
 9315     auto code = compileProc(proc);
 9316 
 9317     CHECK(invoke&lt;double&gt;(*code, 0) == 42.0);
 9318     CHECK(invoke&lt;double&gt;(*code, 1) == 43.0);
 9319     CHECK(invoke&lt;double&gt;(*code, 42) == 84.0);
 9320     CHECK(invoke&lt;double&gt;(*code, 2147483647) == 2147483689.0);
 9321 }
 9322 
 9323 void testCheckAddImmCommute()
 9324 {
 9325     Procedure proc;
 9326     BasicBlock* root = proc.addBlock();
 9327     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9328         proc, Trunc, Origin(),
 9329         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9330     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 9331     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg2, arg1);
 9332     checkAdd-&gt;append(arg1);
 9333     checkAdd-&gt;append(arg2);
 9334     checkAdd-&gt;setGenerator(
 9335         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9336             AllowMacroScratchRegisterUsage allowScratch(jit);
 9337             CHECK(params.size() == 2);
 9338             CHECK(params[0].isGPR());
 9339             CHECK(params[1].isConstant());
 9340             CHECK(params[1].value() == 42);
 9341             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9342             jit.convertInt32ToDouble(CCallHelpers::TrustedImm32(42), FPRInfo::fpRegT1);
 9343             jit.addDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9344             jit.emitFunctionEpilogue();
 9345             jit.ret();
 9346         });
 9347     root-&gt;appendNewControlValue(
 9348         proc, Return, Origin(),
 9349         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkAdd));
 9350 
 9351     auto code = compileProc(proc);
 9352 
 9353     CHECK(invoke&lt;double&gt;(*code, 0) == 42.0);
 9354     CHECK(invoke&lt;double&gt;(*code, 1) == 43.0);
 9355     CHECK(invoke&lt;double&gt;(*code, 42) == 84.0);
 9356     CHECK(invoke&lt;double&gt;(*code, 2147483647) == 2147483689.0);
 9357 }
 9358 
 9359 void testCheckAddImmSomeRegister()
 9360 {
 9361     Procedure proc;
 9362     BasicBlock* root = proc.addBlock();
 9363     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9364         proc, Trunc, Origin(),
 9365         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9366     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 9367     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9368     checkAdd-&gt;appendSomeRegister(arg1);
 9369     checkAdd-&gt;appendSomeRegister(arg2);
 9370     checkAdd-&gt;setGenerator(
 9371         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9372             AllowMacroScratchRegisterUsage allowScratch(jit);
 9373             CHECK(params.size() == 2);
 9374             CHECK(params[0].isGPR());
 9375             CHECK(params[1].isGPR());
 9376             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9377             jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9378             jit.addDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9379             jit.emitFunctionEpilogue();
 9380             jit.ret();
 9381         });
 9382     root-&gt;appendNewControlValue(
 9383         proc, Return, Origin(),
 9384         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkAdd));
 9385 
 9386     auto code = compileProc(proc);
 9387 
 9388     CHECK(invoke&lt;double&gt;(*code, 0) == 42.0);
 9389     CHECK(invoke&lt;double&gt;(*code, 1) == 43.0);
 9390     CHECK(invoke&lt;double&gt;(*code, 42) == 84.0);
 9391     CHECK(invoke&lt;double&gt;(*code, 2147483647) == 2147483689.0);
 9392 }
 9393 
 9394 void testCheckAdd()
 9395 {
 9396     Procedure proc;
 9397     BasicBlock* root = proc.addBlock();
 9398     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9399         proc, Trunc, Origin(),
 9400         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9401     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
 9402         proc, Trunc, Origin(),
 9403         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 9404     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9405     checkAdd-&gt;appendSomeRegister(arg1);
 9406     checkAdd-&gt;appendSomeRegister(arg2);
 9407     checkAdd-&gt;setGenerator(
 9408         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9409             AllowMacroScratchRegisterUsage allowScratch(jit);
 9410             CHECK(params.size() == 2);
 9411             CHECK(params[0].isGPR());
 9412             CHECK(params[1].isGPR());
 9413             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9414             jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9415             jit.addDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9416             jit.emitFunctionEpilogue();
 9417             jit.ret();
 9418         });
 9419     root-&gt;appendNewControlValue(
 9420         proc, Return, Origin(),
 9421         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkAdd));
 9422 
 9423     auto code = compileProc(proc);
 9424 
 9425     CHECK(invoke&lt;double&gt;(*code, 0, 42) == 42.0);
 9426     CHECK(invoke&lt;double&gt;(*code, 1, 42) == 43.0);
 9427     CHECK(invoke&lt;double&gt;(*code, 42, 42) == 84.0);
 9428     CHECK(invoke&lt;double&gt;(*code, 2147483647, 42) == 2147483689.0);
 9429 }
 9430 
 9431 void testCheckAdd64()
 9432 {
 9433     Procedure proc;
 9434     BasicBlock* root = proc.addBlock();
 9435     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9436     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 9437     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9438     checkAdd-&gt;appendSomeRegister(arg1);
 9439     checkAdd-&gt;appendSomeRegister(arg2);
 9440     checkAdd-&gt;setGenerator(
 9441         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9442             AllowMacroScratchRegisterUsage allowScratch(jit);
 9443             CHECK(params.size() == 2);
 9444             CHECK(params[0].isGPR());
 9445             CHECK(params[1].isGPR());
 9446             jit.convertInt64ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9447             jit.convertInt64ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9448             jit.addDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9449             jit.emitFunctionEpilogue();
 9450             jit.ret();
 9451         });
 9452     root-&gt;appendNewControlValue(
 9453         proc, Return, Origin(),
 9454         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkAdd));
 9455 
 9456     auto code = compileProc(proc);
 9457 
 9458     CHECK(invoke&lt;double&gt;(*code, 0ll, 42ll) == 42.0);
 9459     CHECK(invoke&lt;double&gt;(*code, 1ll, 42ll) == 43.0);
 9460     CHECK(invoke&lt;double&gt;(*code, 42ll, 42ll) == 84.0);
 9461     CHECK(invoke&lt;double&gt;(*code, 9223372036854775807ll, 42ll) == static_cast&lt;double&gt;(9223372036854775807ll) + 42.0);
 9462 }
 9463 
 9464 void testCheckAddFold(int a, int b)
 9465 {
 9466     Procedure proc;
 9467     BasicBlock* root = proc.addBlock();
 9468     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
 9469     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
 9470     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9471     checkAdd-&gt;setGenerator(
 9472         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
 9473             CHECK(!&quot;Should have been folded&quot;);
 9474         });
 9475     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd);
 9476 
 9477     auto code = compileProc(proc);
 9478 
 9479     CHECK(invoke&lt;int&gt;(*code) == a + b);
 9480 }
 9481 
 9482 void testCheckAddFoldFail(int a, int b)
 9483 {
 9484     Procedure proc;
 9485     BasicBlock* root = proc.addBlock();
 9486     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
 9487     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
 9488     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9489     checkAdd-&gt;setGenerator(
 9490         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
 9491             AllowMacroScratchRegisterUsage allowScratch(jit);
 9492             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9493             jit.emitFunctionEpilogue();
 9494             jit.ret();
 9495         });
 9496     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd);
 9497 
 9498     auto code = compileProc(proc);
 9499 
 9500     CHECK(invoke&lt;int&gt;(*code) == 42);
 9501 }
 9502 
 9503 void testCheckAddArgumentAliasing64()
 9504 {
 9505     Procedure proc;
 9506     BasicBlock* root = proc.addBlock();
 9507     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9508     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 9509     Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 9510 
 9511     // Pretend to use all the args.
 9512     PatchpointValue* useArgs = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9513     useArgs-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 9514     useArgs-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 9515     useArgs-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
 9516     useArgs-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9517 
 9518     // Last use of first arg (here, arg1).
 9519     CheckValue* checkAdd1 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9520     checkAdd1-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9521 
 9522     // Last use of second arg (here, arg2).
 9523     CheckValue* checkAdd2 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg3, arg2);
 9524     checkAdd2-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9525 
 9526     // Keep arg3 live.
 9527     PatchpointValue* keepArg2Live = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9528     keepArg2Live-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 9529     keepArg2Live-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9530 
 9531     // Only use of checkAdd1 and checkAdd2.
 9532     CheckValue* checkAdd3 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), checkAdd1, checkAdd2);
 9533     checkAdd3-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9534 
 9535     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd3);
 9536 
 9537     CHECK(compileAndRun&lt;int64_t&gt;(proc, 1, 2, 3) == 8);
 9538 }
 9539 
 9540 void testCheckAddArgumentAliasing32()
 9541 {
 9542     Procedure proc;
 9543     BasicBlock* root = proc.addBlock();
 9544     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9545         proc, Trunc, Origin(),
 9546         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9547     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
 9548         proc, Trunc, Origin(),
 9549         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 9550     Value* arg3 = root-&gt;appendNew&lt;Value&gt;(
 9551         proc, Trunc, Origin(),
 9552         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 9553 
 9554     // Pretend to use all the args.
 9555     PatchpointValue* useArgs = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9556     useArgs-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
 9557     useArgs-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 9558     useArgs-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
 9559     useArgs-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9560 
 9561     // Last use of first arg (here, arg1).
 9562     CheckValue* checkAdd1 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg1, arg2);
 9563     checkAdd1-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9564 
 9565     // Last use of second arg (here, arg3).
 9566     CheckValue* checkAdd2 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg2, arg3);
 9567     checkAdd2-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9568 
 9569     // Keep arg3 live.
 9570     PatchpointValue* keepArg2Live = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9571     keepArg2Live-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
 9572     keepArg2Live-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9573 
 9574     // Only use of checkAdd1 and checkAdd2.
 9575     CheckValue* checkAdd3 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), checkAdd1, checkAdd2);
 9576     checkAdd3-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
 9577 
 9578     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd3);
 9579 
 9580     CHECK(compileAndRun&lt;int32_t&gt;(proc, 1, 2, 3) == 8);
 9581 }
 9582 
 9583 void testCheckAddSelfOverflow64()
 9584 {
 9585     Procedure proc;
 9586     BasicBlock* root = proc.addBlock();
 9587     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9588     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg, arg);
 9589     checkAdd-&gt;append(arg);
 9590     checkAdd-&gt;setGenerator(
 9591         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9592             AllowMacroScratchRegisterUsage allowScratch(jit);
 9593             jit.move(params[0].gpr(), GPRInfo::returnValueGPR);
 9594             jit.emitFunctionEpilogue();
 9595             jit.ret();
 9596         });
 9597 
 9598     // Make sure the arg is not the destination of the operation.
 9599     PatchpointValue* opaqueUse = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9600     opaqueUse-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
 9601     opaqueUse-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9602 
 9603     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd);
 9604 
 9605     auto code = compileProc(proc);
 9606 
 9607     CHECK(invoke&lt;int64_t&gt;(*code, 0ll) == 0);
 9608     CHECK(invoke&lt;int64_t&gt;(*code, 1ll) == 2);
 9609     CHECK(invoke&lt;int64_t&gt;(*code, std::numeric_limits&lt;int64_t&gt;::max()) == std::numeric_limits&lt;int64_t&gt;::max());
 9610 }
 9611 
 9612 void testCheckAddSelfOverflow32()
 9613 {
 9614     Procedure proc;
 9615     BasicBlock* root = proc.addBlock();
 9616     Value* arg = root-&gt;appendNew&lt;Value&gt;(
 9617         proc, Trunc, Origin(),
 9618         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9619     CheckValue* checkAdd = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckAdd, Origin(), arg, arg);
 9620     checkAdd-&gt;append(arg);
 9621     checkAdd-&gt;setGenerator(
 9622         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9623             AllowMacroScratchRegisterUsage allowScratch(jit);
 9624             jit.move(params[0].gpr(), GPRInfo::returnValueGPR);
 9625             jit.emitFunctionEpilogue();
 9626             jit.ret();
 9627         });
 9628 
 9629     // Make sure the arg is not the destination of the operation.
 9630     PatchpointValue* opaqueUse = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
 9631     opaqueUse-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
 9632     opaqueUse-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
 9633 
 9634     root-&gt;appendNewControlValue(proc, Return, Origin(), checkAdd);
 9635 
 9636     auto code = compileProc(proc);
 9637 
 9638     CHECK(invoke&lt;int32_t&gt;(*code, 0ll) == 0);
 9639     CHECK(invoke&lt;int32_t&gt;(*code, 1ll) == 2);
 9640     CHECK(invoke&lt;int32_t&gt;(*code, std::numeric_limits&lt;int32_t&gt;::max()) == std::numeric_limits&lt;int32_t&gt;::max());
 9641 }
 9642 
 9643 void testCheckSubImm()
 9644 {
 9645     Procedure proc;
 9646     BasicBlock* root = proc.addBlock();
 9647     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9648         proc, Trunc, Origin(),
 9649         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9650     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
 9651     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9652     checkSub-&gt;append(arg1);
 9653     checkSub-&gt;append(arg2);
 9654     checkSub-&gt;setGenerator(
 9655         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9656             AllowMacroScratchRegisterUsage allowScratch(jit);
 9657             CHECK(params.size() == 2);
 9658             CHECK(params[0].isGPR());
 9659             CHECK(params[1].isConstant());
 9660             CHECK(params[1].value() == 42);
 9661             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9662             jit.convertInt32ToDouble(CCallHelpers::TrustedImm32(42), FPRInfo::fpRegT1);
 9663             jit.subDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9664             jit.emitFunctionEpilogue();
 9665             jit.ret();
 9666         });
 9667     root-&gt;appendNewControlValue(
 9668         proc, Return, Origin(),
 9669         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkSub));
 9670 
 9671     auto code = compileProc(proc);
 9672 
 9673     CHECK(invoke&lt;double&gt;(*code, 0) == -42.0);
 9674     CHECK(invoke&lt;double&gt;(*code, 1) == -41.0);
 9675     CHECK(invoke&lt;double&gt;(*code, 42) == 0.0);
 9676     CHECK(invoke&lt;double&gt;(*code, -2147483647) == -2147483689.0);
 9677 }
 9678 
 9679 void testCheckSubBadImm()
 9680 {
 9681     Procedure proc;
 9682     BasicBlock* root = proc.addBlock();
 9683     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9684         proc, Trunc, Origin(),
 9685         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9686     int32_t badImm = std::numeric_limits&lt;int&gt;::min();
 9687     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), badImm);
 9688     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9689     checkSub-&gt;append(arg1);
 9690     checkSub-&gt;append(arg2);
 9691     checkSub-&gt;setGenerator(
 9692         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9693             AllowMacroScratchRegisterUsage allowScratch(jit);
 9694             CHECK(params.size() == 2);
 9695             CHECK(params[0].isGPR());
 9696             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9697 
 9698             if (params[1].isConstant()) {
 9699                 CHECK(params[1].value() == badImm);
 9700                 jit.convertInt32ToDouble(CCallHelpers::TrustedImm32(badImm), FPRInfo::fpRegT1);
 9701             } else {
 9702                 CHECK(params[1].isGPR());
 9703                 jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9704             }
 9705             jit.subDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9706             jit.emitFunctionEpilogue();
 9707             jit.ret();
 9708         });
 9709     root-&gt;appendNewControlValue(
 9710         proc, Return, Origin(),
 9711         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkSub));
 9712 
 9713     auto code = compileProc(proc);
 9714 
 9715     CHECK(invoke&lt;double&gt;(*code, 0) == -static_cast&lt;double&gt;(badImm));
 9716     CHECK(invoke&lt;double&gt;(*code, -1) == -static_cast&lt;double&gt;(badImm) - 1);
 9717     CHECK(invoke&lt;double&gt;(*code, 1) == -static_cast&lt;double&gt;(badImm) + 1);
 9718     CHECK(invoke&lt;double&gt;(*code, 42) == -static_cast&lt;double&gt;(badImm) + 42);
 9719 }
 9720 
 9721 void testCheckSub()
 9722 {
 9723     Procedure proc;
 9724     BasicBlock* root = proc.addBlock();
 9725     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9726         proc, Trunc, Origin(),
 9727         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9728     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
 9729         proc, Trunc, Origin(),
 9730         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 9731     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9732     checkSub-&gt;append(arg1);
 9733     checkSub-&gt;append(arg2);
 9734     checkSub-&gt;setGenerator(
 9735         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9736             AllowMacroScratchRegisterUsage allowScratch(jit);
 9737             CHECK(params.size() == 2);
 9738             CHECK(params[0].isGPR());
 9739             CHECK(params[1].isGPR());
 9740             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9741             jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9742             jit.subDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9743             jit.emitFunctionEpilogue();
 9744             jit.ret();
 9745         });
 9746     root-&gt;appendNewControlValue(
 9747         proc, Return, Origin(),
 9748         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkSub));
 9749 
 9750     auto code = compileProc(proc);
 9751 
 9752     CHECK(invoke&lt;double&gt;(*code, 0, 42) == -42.0);
 9753     CHECK(invoke&lt;double&gt;(*code, 1, 42) == -41.0);
 9754     CHECK(invoke&lt;double&gt;(*code, 42, 42) == 0.0);
 9755     CHECK(invoke&lt;double&gt;(*code, -2147483647, 42) == -2147483689.0);
 9756 }
 9757 
 9758 NEVER_INLINE double doubleSub(double a, double b)
 9759 {
 9760     return a - b;
 9761 }
 9762 
 9763 void testCheckSub64()
 9764 {
 9765     Procedure proc;
 9766     BasicBlock* root = proc.addBlock();
 9767     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9768     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 9769     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9770     checkSub-&gt;append(arg1);
 9771     checkSub-&gt;append(arg2);
 9772     checkSub-&gt;setGenerator(
 9773         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9774             AllowMacroScratchRegisterUsage allowScratch(jit);
 9775             CHECK(params.size() == 2);
 9776             CHECK(params[0].isGPR());
 9777             CHECK(params[1].isGPR());
 9778             jit.convertInt64ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9779             jit.convertInt64ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9780             jit.subDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9781             jit.emitFunctionEpilogue();
 9782             jit.ret();
 9783         });
 9784     root-&gt;appendNewControlValue(
 9785         proc, Return, Origin(),
 9786         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkSub));
 9787 
 9788     auto code = compileProc(proc);
 9789 
 9790     CHECK(invoke&lt;double&gt;(*code, 0ll, 42ll) == -42.0);
 9791     CHECK(invoke&lt;double&gt;(*code, 1ll, 42ll) == -41.0);
 9792     CHECK(invoke&lt;double&gt;(*code, 42ll, 42ll) == 0.0);
 9793     CHECK(invoke&lt;double&gt;(*code, -9223372036854775807ll, 42ll) == doubleSub(static_cast&lt;double&gt;(-9223372036854775807ll), 42.0));
 9794 }
 9795 
 9796 void testCheckSubFold(int a, int b)
 9797 {
 9798     Procedure proc;
 9799     BasicBlock* root = proc.addBlock();
 9800     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
 9801     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
 9802     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9803     checkSub-&gt;setGenerator(
 9804         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
 9805             CHECK(!&quot;Should have been folded&quot;);
 9806         });
 9807     root-&gt;appendNewControlValue(proc, Return, Origin(), checkSub);
 9808 
 9809     auto code = compileProc(proc);
 9810 
 9811     CHECK(invoke&lt;int&gt;(*code) == a - b);
 9812 }
 9813 
 9814 void testCheckSubFoldFail(int a, int b)
 9815 {
 9816     Procedure proc;
 9817     BasicBlock* root = proc.addBlock();
 9818     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
 9819     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
 9820     CheckValue* checkSub = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9821     checkSub-&gt;setGenerator(
 9822         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
 9823             AllowMacroScratchRegisterUsage allowScratch(jit);
 9824             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 9825             jit.emitFunctionEpilogue();
 9826             jit.ret();
 9827         });
 9828     root-&gt;appendNewControlValue(proc, Return, Origin(), checkSub);
 9829 
 9830     auto code = compileProc(proc);
 9831 
 9832     CHECK(invoke&lt;int&gt;(*code) == 42);
 9833 }
 9834 
 9835 void testCheckNeg()
 9836 {
 9837     Procedure proc;
 9838     BasicBlock* root = proc.addBlock();
 9839     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0);
 9840     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
 9841         proc, Trunc, Origin(),
 9842         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9843     CheckValue* checkNeg = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9844     checkNeg-&gt;append(arg2);
 9845     checkNeg-&gt;setGenerator(
 9846         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9847             AllowMacroScratchRegisterUsage allowScratch(jit);
 9848             CHECK(params.size() == 1);
 9849             CHECK(params[0].isGPR());
 9850             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT1);
 9851             jit.negateDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9852             jit.emitFunctionEpilogue();
 9853             jit.ret();
 9854         });
 9855     root-&gt;appendNewControlValue(
 9856         proc, Return, Origin(),
 9857         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkNeg));
 9858 
 9859     auto code = compileProc(proc);
 9860 
 9861     CHECK(invoke&lt;double&gt;(*code, 0) == 0.0);
 9862     CHECK(invoke&lt;double&gt;(*code, 1) == -1.0);
 9863     CHECK(invoke&lt;double&gt;(*code, 42) == -42.0);
 9864     CHECK(invoke&lt;double&gt;(*code, -2147483647 - 1) == 2147483648.0);
 9865 }
 9866 
 9867 void testCheckNeg64()
 9868 {
 9869     Procedure proc;
 9870     BasicBlock* root = proc.addBlock();
 9871     Value* arg1 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0);
 9872     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 9873     CheckValue* checkNeg = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckSub, Origin(), arg1, arg2);
 9874     checkNeg-&gt;append(arg2);
 9875     checkNeg-&gt;setGenerator(
 9876         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9877             AllowMacroScratchRegisterUsage allowScratch(jit);
 9878             CHECK(params.size() == 1);
 9879             CHECK(params[0].isGPR());
 9880             jit.convertInt64ToDouble(params[0].gpr(), FPRInfo::fpRegT1);
 9881             jit.negateDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9882             jit.emitFunctionEpilogue();
 9883             jit.ret();
 9884         });
 9885     root-&gt;appendNewControlValue(
 9886         proc, Return, Origin(),
 9887         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkNeg));
 9888 
 9889     auto code = compileProc(proc);
 9890 
 9891     CHECK(invoke&lt;double&gt;(*code, 0ll) == 0.0);
 9892     CHECK(invoke&lt;double&gt;(*code, 1ll) == -1.0);
 9893     CHECK(invoke&lt;double&gt;(*code, 42ll) == -42.0);
 9894     CHECK(invoke&lt;double&gt;(*code, -9223372036854775807ll - 1) == 9223372036854775808.0);
 9895 }
 9896 
 9897 void testCheckMul()
 9898 {
 9899     Procedure proc;
 9900     BasicBlock* root = proc.addBlock();
 9901     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9902         proc, Trunc, Origin(),
 9903         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9904     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
 9905         proc, Trunc, Origin(),
 9906         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
 9907     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
 9908     checkMul-&gt;append(arg1);
 9909     checkMul-&gt;append(arg2);
 9910     checkMul-&gt;setGenerator(
 9911         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9912             AllowMacroScratchRegisterUsage allowScratch(jit);
 9913             CHECK(params.size() == 2);
 9914             CHECK(params[0].isGPR());
 9915             CHECK(params[1].isGPR());
 9916             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9917             jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9918             jit.mulDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9919             jit.emitFunctionEpilogue();
 9920             jit.ret();
 9921         });
 9922     root-&gt;appendNewControlValue(
 9923         proc, Return, Origin(),
 9924         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkMul));
 9925 
 9926     auto code = compileProc(proc);
 9927 
 9928     CHECK(invoke&lt;double&gt;(*code, 0, 42) == 0.0);
 9929     CHECK(invoke&lt;double&gt;(*code, 1, 42) == 42.0);
 9930     CHECK(invoke&lt;double&gt;(*code, 42, 42) == 42.0 * 42.0);
 9931     CHECK(invoke&lt;double&gt;(*code, 2147483647, 42) == 2147483647.0 * 42.0);
 9932 }
 9933 
 9934 void testCheckMulMemory()
 9935 {
 9936     Procedure proc;
 9937     BasicBlock* root = proc.addBlock();
 9938 
 9939     int left;
 9940     int right;
 9941 
 9942     Value* arg1 = root-&gt;appendNew&lt;MemoryValue&gt;(
 9943         proc, Load, Int32, Origin(),
 9944         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;left));
 9945     Value* arg2 = root-&gt;appendNew&lt;MemoryValue&gt;(
 9946         proc, Load, Int32, Origin(),
 9947         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;right));
 9948     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
 9949     checkMul-&gt;append(arg1);
 9950     checkMul-&gt;append(arg2);
 9951     checkMul-&gt;setGenerator(
 9952         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9953             AllowMacroScratchRegisterUsage allowScratch(jit);
 9954             CHECK(params.size() == 2);
 9955             CHECK(params[0].isGPR());
 9956             CHECK(params[1].isGPR());
 9957             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
 9958             jit.convertInt32ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
 9959             jit.mulDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
 9960             jit.emitFunctionEpilogue();
 9961             jit.ret();
 9962         });
 9963     root-&gt;appendNewControlValue(
 9964         proc, Return, Origin(),
 9965         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkMul));
 9966 
 9967     auto code = compileProc(proc);
 9968 
 9969     left = 0;
 9970     right = 42;
 9971     CHECK(invoke&lt;double&gt;(*code) == 0.0);
 9972 
 9973     left = 1;
 9974     right = 42;
 9975     CHECK(invoke&lt;double&gt;(*code) == 42.0);
 9976 
 9977     left = 42;
 9978     right = 42;
 9979     CHECK(invoke&lt;double&gt;(*code) == 42.0 * 42.0);
 9980 
 9981     left = 2147483647;
 9982     right = 42;
 9983     CHECK(invoke&lt;double&gt;(*code) == 2147483647.0 * 42.0);
 9984 }
 9985 
 9986 void testCheckMul2()
 9987 {
 9988     Procedure proc;
 9989     BasicBlock* root = proc.addBlock();
 9990     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
 9991         proc, Trunc, Origin(),
 9992         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 9993     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 9994     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
 9995     checkMul-&gt;append(arg1);
 9996     checkMul-&gt;append(arg2);
 9997     checkMul-&gt;setGenerator(
 9998         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9999             AllowMacroScratchRegisterUsage allowScratch(jit);
10000             CHECK(params.size() == 2);
10001             CHECK(params[0].isGPR());
10002             CHECK(params[1].isConstant());
10003             CHECK(params[1].value() == 2);
10004             jit.convertInt32ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
10005             jit.convertInt32ToDouble(CCallHelpers::TrustedImm32(2), FPRInfo::fpRegT1);
10006             jit.mulDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
10007             jit.emitFunctionEpilogue();
10008             jit.ret();
10009         });
10010     root-&gt;appendNewControlValue(
10011         proc, Return, Origin(),
10012         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkMul));
10013 
10014     auto code = compileProc(proc);
10015 
10016     CHECK(invoke&lt;double&gt;(*code, 0) == 0.0);
10017     CHECK(invoke&lt;double&gt;(*code, 1) == 2.0);
10018     CHECK(invoke&lt;double&gt;(*code, 42) == 42.0 * 2.0);
10019     CHECK(invoke&lt;double&gt;(*code, 2147483647) == 2147483647.0 * 2.0);
10020 }
10021 
10022 void testCheckMul64()
10023 {
10024     Procedure proc;
10025     BasicBlock* root = proc.addBlock();
10026     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10027     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
10028     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10029     checkMul-&gt;append(arg1);
10030     checkMul-&gt;append(arg2);
10031     checkMul-&gt;setGenerator(
10032         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10033             AllowMacroScratchRegisterUsage allowScratch(jit);
10034             CHECK(params.size() == 2);
10035             CHECK(params[0].isGPR());
10036             CHECK(params[1].isGPR());
10037             jit.convertInt64ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
10038             jit.convertInt64ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
10039             jit.mulDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
10040             jit.emitFunctionEpilogue();
10041             jit.ret();
10042         });
10043     root-&gt;appendNewControlValue(
10044         proc, Return, Origin(),
10045         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkMul));
10046 
10047     auto code = compileProc(proc);
10048 
10049     CHECK(invoke&lt;double&gt;(*code, 0, 42) == 0.0);
10050     CHECK(invoke&lt;double&gt;(*code, 1, 42) == 42.0);
10051     CHECK(invoke&lt;double&gt;(*code, 42, 42) == 42.0 * 42.0);
10052     CHECK(invoke&lt;double&gt;(*code, 9223372036854775807ll, 42) == static_cast&lt;double&gt;(9223372036854775807ll) * 42.0);
10053 }
10054 
10055 void testCheckMulFold(int a, int b)
10056 {
10057     Procedure proc;
10058     BasicBlock* root = proc.addBlock();
10059     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
10060     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
10061     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10062     checkMul-&gt;setGenerator(
10063         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
10064             CHECK(!&quot;Should have been folded&quot;);
10065         });
10066     root-&gt;appendNewControlValue(proc, Return, Origin(), checkMul);
10067 
10068     auto code = compileProc(proc);
10069 
10070     CHECK(invoke&lt;int&gt;(*code) == a * b);
10071 }
10072 
10073 void testCheckMulFoldFail(int a, int b)
10074 {
10075     Procedure proc;
10076     BasicBlock* root = proc.addBlock();
10077     Value* arg1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), a);
10078     Value* arg2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);
10079     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10080     checkMul-&gt;setGenerator(
10081         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
10082             AllowMacroScratchRegisterUsage allowScratch(jit);
10083             jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
10084             jit.emitFunctionEpilogue();
10085             jit.ret();
10086         });
10087     root-&gt;appendNewControlValue(proc, Return, Origin(), checkMul);
10088 
10089     auto code = compileProc(proc);
10090 
10091     CHECK(invoke&lt;int&gt;(*code) == 42);
10092 }
10093 
10094 void testCheckMulArgumentAliasing64()
10095 {
10096     Procedure proc;
10097     BasicBlock* root = proc.addBlock();
10098     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10099     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
10100     Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
10101 
10102     // Pretend to use all the args.
10103     PatchpointValue* useArgs = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
10104     useArgs-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
10105     useArgs-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
10106     useArgs-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
10107     useArgs-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
10108 
10109     // Last use of first arg (here, arg1).
10110     CheckValue* checkMul1 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10111     checkMul1-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10112 
10113     // Last use of second arg (here, arg2).
10114     CheckValue* checkMul2 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg3, arg2);
10115     checkMul2-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10116 
10117     // Keep arg3 live.
10118     PatchpointValue* keepArg2Live = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
10119     keepArg2Live-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
10120     keepArg2Live-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
10121 
10122     // Only use of checkMul1 and checkMul2.
10123     CheckValue* checkMul3 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), checkMul1, checkMul2);
10124     checkMul3-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10125 
10126     root-&gt;appendNewControlValue(proc, Return, Origin(), checkMul3);
10127 
10128     CHECK(compileAndRun&lt;int64_t&gt;(proc, 2, 3, 4) == 72);
10129 }
10130 
10131 void testCheckMulArgumentAliasing32()
10132 {
10133     Procedure proc;
10134     BasicBlock* root = proc.addBlock();
10135     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
10136         proc, Trunc, Origin(),
10137         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10138     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
10139         proc, Trunc, Origin(),
10140         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
10141     Value* arg3 = root-&gt;appendNew&lt;Value&gt;(
10142         proc, Trunc, Origin(),
10143         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
10144 
10145     // Pretend to use all the args.
10146     PatchpointValue* useArgs = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
10147     useArgs-&gt;append(ConstrainedValue(arg1, ValueRep::SomeRegister));
10148     useArgs-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
10149     useArgs-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
10150     useArgs-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
10151 
10152     // Last use of first arg (here, arg1).
10153     CheckValue* checkMul1 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10154     checkMul1-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10155 
10156     // Last use of second arg (here, arg3).
10157     CheckValue* checkMul2 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg2, arg3);
10158     checkMul2-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10159 
10160     // Keep arg3 live.
10161     PatchpointValue* keepArg2Live = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
10162     keepArg2Live-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
10163     keepArg2Live-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
10164 
10165     // Only use of checkMul1 and checkMul2.
10166     CheckValue* checkMul3 = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), checkMul1, checkMul2);
10167     checkMul3-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) { jit.oops(); });
10168 
10169     root-&gt;appendNewControlValue(proc, Return, Origin(), checkMul3);
10170 
10171     CHECK(compileAndRun&lt;int32_t&gt;(proc, 2, 3, 4) == 72);
10172 }
10173 
10174 void testCheckMul64SShr()
10175 {
10176     Procedure proc;
10177     BasicBlock* root = proc.addBlock();
10178     Value* arg1 = root-&gt;appendNew&lt;Value&gt;(
10179         proc, SShr, Origin(),
10180         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10181         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
10182     Value* arg2 = root-&gt;appendNew&lt;Value&gt;(
10183         proc, SShr, Origin(),
10184         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
10185         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
10186     CheckValue* checkMul = root-&gt;appendNew&lt;CheckValue&gt;(proc, CheckMul, Origin(), arg1, arg2);
10187     checkMul-&gt;append(arg1);
10188     checkMul-&gt;append(arg2);
10189     checkMul-&gt;setGenerator(
10190         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10191             AllowMacroScratchRegisterUsage allowScratch(jit);
10192             CHECK(params.size() == 2);
10193             CHECK(params[0].isGPR());
10194             CHECK(params[1].isGPR());
10195             jit.convertInt64ToDouble(params[0].gpr(), FPRInfo::fpRegT0);
10196             jit.convertInt64ToDouble(params[1].gpr(), FPRInfo::fpRegT1);
10197             jit.mulDouble(FPRInfo::fpRegT1, FPRInfo::fpRegT0);
10198             jit.emitFunctionEpilogue();
10199             jit.ret();
10200         });
10201     root-&gt;appendNewControlValue(
10202         proc, Return, Origin(),
10203         root-&gt;appendNew&lt;Value&gt;(proc, IToD, Origin(), checkMul));
10204 
10205     auto code = compileProc(proc);
10206 
10207     CHECK(invoke&lt;double&gt;(*code, 0ll, 42ll) == 0.0);
10208     CHECK(invoke&lt;double&gt;(*code, 1ll, 42ll) == 0.0);
10209     CHECK(invoke&lt;double&gt;(*code, 42ll, 42ll) == (42.0 / 2.0) * (42.0 / 2.0));
10210     CHECK(invoke&lt;double&gt;(*code, 10000000000ll, 10000000000ll) == 25000000000000000000.0);
10211 }
10212 
10213 template&lt;typename LeftFunctor, typename RightFunctor, typename InputType&gt;
10214 void genericTestCompare(
10215     B3::Opcode opcode, const LeftFunctor&amp; leftFunctor, const RightFunctor&amp; rightFunctor,
10216     InputType left, InputType right, int result)
10217 {
10218     // Using a compare.
10219     {
10220         Procedure proc;
10221         BasicBlock* root = proc.addBlock();
10222 
10223         Value* leftValue = leftFunctor(root, proc);
10224         Value* rightValue = rightFunctor(root, proc);
10225         Value* comparisonResult = root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), leftValue, rightValue);
10226 
10227         root-&gt;appendNewControlValue(
10228             proc, Return, Origin(),
10229             root-&gt;appendNew&lt;Value&gt;(
10230                 proc, NotEqual, Origin(),
10231                 comparisonResult,
10232                 root-&gt;appendIntConstant(proc, Origin(), comparisonResult-&gt;type(), 0)));
10233 
10234         CHECK(compileAndRun&lt;int&gt;(proc, left, right) == result);
10235     }
10236 
10237     // Using a branch.
10238     {
10239         Procedure proc;
10240         BasicBlock* root = proc.addBlock();
10241         BasicBlock* thenCase = proc.addBlock();
10242         BasicBlock* elseCase = proc.addBlock();
10243 
10244         Value* leftValue = leftFunctor(root, proc);
10245         Value* rightValue = rightFunctor(root, proc);
10246 
10247         root-&gt;appendNewControlValue(
10248             proc, Branch, Origin(),
10249             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), leftValue, rightValue),
10250             FrequentedBlock(thenCase), FrequentedBlock(elseCase));
10251 
10252         // We use a patchpoint on the then case to ensure that this doesn&#39;t get if-converted.
10253         PatchpointValue* patchpoint = thenCase-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
10254         patchpoint-&gt;setGenerator(
10255             [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10256                 AllowMacroScratchRegisterUsage allowScratch(jit);
10257                 CHECK(params.size() == 1);
10258                 CHECK(params[0].isGPR());
10259                 jit.move(CCallHelpers::TrustedImm32(1), params[0].gpr());
10260             });
10261         thenCase-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
10262 
10263         elseCase-&gt;appendNewControlValue(
10264             proc, Return, Origin(),
10265             elseCase-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
10266 
10267         CHECK(compileAndRun&lt;int&gt;(proc, left, right) == result);
10268     }
10269 }
10270 
10271 template&lt;typename InputType&gt;
10272 InputType modelCompare(B3::Opcode opcode, InputType left, InputType right)
10273 {
10274     switch (opcode) {
10275     case Equal:
10276         return left == right;
10277     case NotEqual:
10278         return left != right;
10279     case LessThan:
10280         return left &lt; right;
10281     case GreaterThan:
10282         return left &gt; right;
10283     case LessEqual:
10284         return left &lt;= right;
10285     case GreaterEqual:
10286         return left &gt;= right;
10287     case Above:
10288         return static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(left) &gt;
10289             static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(right);
10290     case Below:
10291         return static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(left) &lt;
10292             static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(right);
10293     case AboveEqual:
10294         return static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(left) &gt;=
10295             static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(right);
10296     case BelowEqual:
10297         return static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(left) &lt;=
10298             static_cast&lt;typename std::make_unsigned&lt;InputType&gt;::type&gt;(right);
10299     case BitAnd:
10300         return !!(left &amp; right);
10301     default:
10302         RELEASE_ASSERT_NOT_REACHED();
10303         return 0;
10304     }
10305 }
10306 
10307 template&lt;typename T&gt;
10308 void testCompareLoad(B3::Opcode opcode, B3::Opcode loadOpcode, int left, int right)
10309 {
10310     int result = modelCompare(opcode, modelLoad&lt;T&gt;(left), right);
10311 
10312     // Test addr-to-tmp
10313     int slot = left;
10314     genericTestCompare(
10315         opcode,
10316         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10317             return block-&gt;appendNew&lt;MemoryValue&gt;(
10318                 proc, loadOpcode, Int32, Origin(),
10319                 block-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot));
10320         },
10321         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10322             return block-&gt;appendNew&lt;Value&gt;(
10323                 proc, Trunc, Origin(),
10324                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
10325         },
10326         left, right, result);
10327 
10328     // Test addr-to-imm
10329     slot = left;
10330     genericTestCompare(
10331         opcode,
10332         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10333             return block-&gt;appendNew&lt;MemoryValue&gt;(
10334                 proc, loadOpcode, Int32, Origin(),
10335                 block-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot));
10336         },
10337         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10338             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), right);
10339         },
10340         left, right, result);
10341 
10342     result = modelCompare(opcode, left, modelLoad&lt;T&gt;(right));
10343 
10344     // Test tmp-to-addr
10345     slot = right;
10346     genericTestCompare(
10347         opcode,
10348         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10349             return block-&gt;appendNew&lt;Value&gt;(
10350                 proc, Trunc, Origin(),
10351                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10352         },
10353         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10354             return block-&gt;appendNew&lt;MemoryValue&gt;(
10355                 proc, loadOpcode, Int32, Origin(),
10356                 block-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot));
10357         },
10358         left, right, result);
10359 
10360     // Test imm-to-addr
10361     slot = right;
10362     genericTestCompare(
10363         opcode,
10364         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10365             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), left);
10366         },
10367         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10368             return block-&gt;appendNew&lt;MemoryValue&gt;(
10369                 proc, loadOpcode, Int32, Origin(),
10370                 block-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot));
10371         },
10372         left, right, result);
10373 
10374     // Test addr-to-addr, with the same addr.
10375     slot = left;
10376     Value* value;
10377     genericTestCompare(
10378         opcode,
10379         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10380             value = block-&gt;appendNew&lt;MemoryValue&gt;(
10381                 proc, loadOpcode, Int32, Origin(),
10382                 block-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;slot));
10383             return value;
10384         },
10385         [&amp;] (BasicBlock*, Procedure&amp;) {
10386             return value;
10387         },
10388         left, left, modelCompare(opcode, modelLoad&lt;T&gt;(left), modelLoad&lt;T&gt;(left)));
10389 }
10390 
10391 void testCompareImpl(B3::Opcode opcode, int64_t left, int64_t right)
10392 {
10393     int64_t result = modelCompare(opcode, left, right);
10394     int32_t int32Result = modelCompare(opcode, static_cast&lt;int32_t&gt;(left), static_cast&lt;int32_t&gt;(right));
10395 
10396     // Test tmp-to-tmp.
10397     genericTestCompare(
10398         opcode,
10399         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10400             return block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10401         },
10402         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10403             return block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
10404         },
10405         left, right, result);
10406     genericTestCompare(
10407         opcode,
10408         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10409             return block-&gt;appendNew&lt;Value&gt;(
10410                 proc, Trunc, Origin(),
10411                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10412         },
10413         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10414             return block-&gt;appendNew&lt;Value&gt;(
10415                 proc, Trunc, Origin(),
10416                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
10417         },
10418         left, right, int32Result);
10419 
10420     // Test imm-to-tmp.
10421     genericTestCompare(
10422         opcode,
10423         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10424             return block-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), left);
10425         },
10426         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10427             return block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
10428         },
10429         left, right, result);
10430     genericTestCompare(
10431         opcode,
10432         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10433             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), left);
10434         },
10435         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10436             return block-&gt;appendNew&lt;Value&gt;(
10437                 proc, Trunc, Origin(),
10438                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
10439         },
10440         left, right, int32Result);
10441 
10442     // Test tmp-to-imm.
10443     genericTestCompare(
10444         opcode,
10445         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10446             return block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10447         },
10448         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10449             return block-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), right);
10450         },
10451         left, right, result);
10452     genericTestCompare(
10453         opcode,
10454         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10455             return block-&gt;appendNew&lt;Value&gt;(
10456                 proc, Trunc, Origin(),
10457                 block-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10458         },
10459         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10460             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), right);
10461         },
10462         left, right, int32Result);
10463 
10464     // Test imm-to-imm.
10465     genericTestCompare(
10466         opcode,
10467         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10468             return block-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), left);
10469         },
10470         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10471             return block-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), right);
10472         },
10473         left, right, result);
10474     genericTestCompare(
10475         opcode,
10476         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10477             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), left);
10478         },
10479         [&amp;] (BasicBlock* block, Procedure&amp; proc) {
10480             return block-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), right);
10481         },
10482         left, right, int32Result);
10483 
10484     testCompareLoad&lt;int32_t&gt;(opcode, Load, left, right);
10485     testCompareLoad&lt;int8_t&gt;(opcode, Load8S, left, right);
10486     testCompareLoad&lt;uint8_t&gt;(opcode, Load8Z, left, right);
10487     testCompareLoad&lt;int16_t&gt;(opcode, Load16S, left, right);
10488     testCompareLoad&lt;uint16_t&gt;(opcode, Load16Z, left, right);
10489 }
10490 
10491 void testCompare(B3::Opcode opcode, int64_t left, int64_t right)
10492 {
10493     testCompareImpl(opcode, left, right);
10494     testCompareImpl(opcode, left, right + 1);
10495     testCompareImpl(opcode, left, right - 1);
10496 }
10497 
10498 void testEqualDouble(double left, double right, bool result)
10499 {
10500     Procedure proc;
10501     BasicBlock* root = proc.addBlock();
10502     root-&gt;appendNewControlValue(
10503         proc, Return, Origin(),
10504         root-&gt;appendNew&lt;Value&gt;(
10505             proc, Equal, Origin(),
10506             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
10507             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)));
10508 
10509     CHECK(compileAndRun&lt;bool&gt;(proc, left, right) == result);
10510 }
10511 
10512 int simpleFunction(int a, int b)
10513 {
10514     return a + b;
10515 }
10516 
10517 void testCallSimple(int a, int b)
10518 {
10519     Procedure proc;
10520     BasicBlock* root = proc.addBlock();
10521     root-&gt;appendNewControlValue(
10522         proc, Return, Origin(),
10523         root-&gt;appendNew&lt;CCallValue&gt;(
10524             proc, Int32, Origin(),
10525             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunction, B3CCallPtrTag)),
10526             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10527             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
10528 
10529     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a + b);
10530 }
10531 
10532 void testCallRare(int a, int b)
10533 {
10534     Procedure proc;
10535     BasicBlock* root = proc.addBlock();
10536     BasicBlock* common = proc.addBlock();
10537     BasicBlock* rare = proc.addBlock();
10538 
10539     root-&gt;appendNewControlValue(
10540         proc, Branch, Origin(),
10541         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10542         FrequentedBlock(rare, FrequencyClass::Rare),
10543         FrequentedBlock(common));
10544 
10545     common-&gt;appendNewControlValue(
10546         proc, Return, Origin(), common-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
10547 
10548     rare-&gt;appendNewControlValue(
10549         proc, Return, Origin(),
10550         rare-&gt;appendNew&lt;CCallValue&gt;(
10551             proc, Int32, Origin(),
10552             rare-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunction, B3CCallPtrTag)),
10553             rare-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
10554             rare-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
10555 
10556     CHECK(compileAndRun&lt;int&gt;(proc, true, a, b) == a + b);
10557 }
10558 
10559 void testCallRareLive(int a, int b, int c)
10560 {
10561     Procedure proc;
10562     BasicBlock* root = proc.addBlock();
10563     BasicBlock* common = proc.addBlock();
10564     BasicBlock* rare = proc.addBlock();
10565 
10566     root-&gt;appendNewControlValue(
10567         proc, Branch, Origin(),
10568         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10569         FrequentedBlock(rare, FrequencyClass::Rare),
10570         FrequentedBlock(common));
10571 
10572     common-&gt;appendNewControlValue(
10573         proc, Return, Origin(), common-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
10574 
10575     rare-&gt;appendNewControlValue(
10576         proc, Return, Origin(),
10577         rare-&gt;appendNew&lt;Value&gt;(
10578             proc, Add, Origin(),
10579             rare-&gt;appendNew&lt;CCallValue&gt;(
10580                 proc, Int32, Origin(),
10581                 rare-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunction, B3CCallPtrTag)),
10582                 rare-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
10583                 rare-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)),
10584             rare-&gt;appendNew&lt;Value&gt;(
10585                 proc, Trunc, Origin(),
10586                 rare-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3))));
10587 
10588     CHECK(compileAndRun&lt;int&gt;(proc, true, a, b, c) == a + b + c);
10589 }
10590 
10591 void testCallSimplePure(int a, int b)
10592 {
10593     Procedure proc;
10594     BasicBlock* root = proc.addBlock();
10595     root-&gt;appendNewControlValue(
10596         proc, Return, Origin(),
10597         root-&gt;appendNew&lt;CCallValue&gt;(
10598             proc, Int32, Origin(), Effects::none(),
10599             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunction, B3CCallPtrTag)),
10600             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10601             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
10602 
10603     CHECK(compileAndRun&lt;int&gt;(proc, a, b) == a + b);
10604 }
10605 
10606 int functionWithHellaArguments(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v, int w, int x, int y, int z)
10607 {
10608     return (a &lt;&lt; 0) + (b &lt;&lt; 1) + (c &lt;&lt; 2) + (d &lt;&lt; 3) + (e &lt;&lt; 4) + (f &lt;&lt; 5) + (g &lt;&lt; 6) + (h &lt;&lt; 7) + (i &lt;&lt; 8) + (j &lt;&lt; 9) + (k &lt;&lt; 10) + (l &lt;&lt; 11) + (m &lt;&lt; 12) + (n &lt;&lt; 13) + (o &lt;&lt; 14) + (p &lt;&lt; 15) + (q &lt;&lt; 16) + (r &lt;&lt; 17) + (s &lt;&lt; 18) + (t &lt;&lt; 19) + (u &lt;&lt; 20) + (v &lt;&lt; 21) + (w &lt;&lt; 22) + (x &lt;&lt; 23) + (y &lt;&lt; 24) + (z &lt;&lt; 25);
10609 }
10610 
10611 void testCallFunctionWithHellaArguments()
10612 {
10613     Procedure proc;
10614     BasicBlock* root = proc.addBlock();
10615 
10616     Vector&lt;Value*&gt; args;
10617     for (unsigned i = 0; i &lt; 26; ++i)
10618         args.append(root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), i + 1));
10619 
10620     CCallValue* call = root-&gt;appendNew&lt;CCallValue&gt;(
10621         proc, Int32, Origin(),
10622         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionWithHellaArguments, B3CCallPtrTag)));
10623     call-&gt;children().appendVector(args);
10624 
10625     root-&gt;appendNewControlValue(proc, Return, Origin(), call);
10626 
10627     CHECK(compileAndRun&lt;int&gt;(proc) == functionWithHellaArguments(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26));
10628 }
10629 
10630 uint64_t functionWithHellaArguments2(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f, uint64_t g, uint64_t h, uint64_t i, uint64_t j, uint64_t k, uint64_t l, uint64_t m, uint64_t n, uint64_t o, uint64_t p, uint64_t q, uint64_t r, uint64_t s, uint64_t t, uint64_t u, uint64_t v, uint64_t w, uint64_t x, uint64_t y, uint64_t z)
10631 {
10632     return (a &lt;&lt; 0) + (b &lt;&lt; 1) + (c &lt;&lt; 2) + (d &lt;&lt; 3) + (e &lt;&lt; 4) + (f &lt;&lt; 5) + (g &lt;&lt; 6) + (h &lt;&lt; 7) + (i &lt;&lt; 8) + (j &lt;&lt; 9) + (k &lt;&lt; 10) + (l &lt;&lt; 11) + (m &lt;&lt; 12) + (n &lt;&lt; 13) + (o &lt;&lt; 14) + (p &lt;&lt; 15) + (q &lt;&lt; 16) + (r &lt;&lt; 17) + (s &lt;&lt; 18) + (t &lt;&lt; 19) + (u &lt;&lt; 20) + (v &lt;&lt; 21) + (w &lt;&lt; 22) + (x &lt;&lt; 23) + (y &lt;&lt; 24) + (z &lt;&lt; 25);
10633 }
10634 
10635 void testCallFunctionWithHellaArguments2()
10636 {
10637     Procedure proc;
10638     BasicBlock* root = proc.addBlock();
10639 
10640     uint64_t limit = static_cast&lt;uint64_t&gt;((1 &lt;&lt; 12) - 1); // UINT12_MAX, for arm64 testing.
10641 
10642     Vector&lt;Value*&gt; args;
10643     for (unsigned i = 0; i &lt; 26; ++i)
10644         args.append(root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), limit - i));
10645 
10646     CCallValue* call = root-&gt;appendNew&lt;CCallValue&gt;(
10647         proc, Int64, Origin(),
10648         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionWithHellaArguments2, B3CCallPtrTag)));
10649     call-&gt;children().appendVector(args);
10650 
10651     root-&gt;appendNewControlValue(proc, Return, Origin(), call);
10652 
10653     auto a = compileAndRun&lt;uint64_t&gt;(proc);
10654     auto b = functionWithHellaArguments2(limit, limit-1, limit-2, limit-3, limit-4, limit-5, limit-6, limit-7, limit-8, limit-9, limit-10, limit-11, limit-12, limit-13, limit-14, limit-15, limit-16, limit-17, limit-18, limit-19, limit-20, limit-21, limit-22, limit-23, limit-24, limit-25);
10655     CHECK(a == b);
10656 }
10657 
10658 int functionWithHellaArguments3(int arg0,int arg1,int arg2,int arg3,int arg4,int arg5,int arg6,int arg7,int arg8,int arg9,int arg10,int arg11,int arg12,int arg13,int arg14,int arg15,int arg16,int arg17,int arg18,int arg19,int arg20,int arg21,int arg22,int arg23,int arg24,int arg25,int arg26,int arg27,int arg28,int arg29,int arg30,int arg31,int arg32,int arg33,int arg34,int arg35,int arg36,int arg37,int arg38,int arg39,int arg40,int arg41,int arg42,int arg43,int arg44,int arg45,int arg46,int arg47,int arg48,int arg49,int arg50,int arg51,int arg52,int arg53,int arg54,int arg55,int arg56,int arg57,int arg58,int arg59,int arg60,int arg61,int arg62,int arg63,int arg64,int arg65,int arg66,int arg67,int arg68,int arg69,int arg70,int arg71,int arg72,int arg73,int arg74,int arg75,int arg76,int arg77,int arg78,int arg79,int arg80,int arg81,int arg82,int arg83,int arg84,int arg85,int arg86,int arg87,int arg88,int arg89,int arg90,int arg91,int arg92,int arg93,int arg94,int arg95,int arg96,int arg97,int arg98,int arg99,int arg100,int arg101,int arg102,int arg103,int arg104,int arg105,int arg106,int arg107,int arg108,int arg109,int arg110,int arg111,int arg112,int arg113,int arg114,int arg115,int arg116,int arg117,int arg118,int arg119,int arg120,int arg121,int arg122,int arg123,int arg124,int arg125,int arg126,int arg127,int arg128,int arg129,int arg130,int arg131,int arg132,int arg133,int arg134,int arg135,int arg136,int arg137,int arg138,int arg139,int arg140,int arg141,int arg142,int arg143,int arg144,int arg145,int arg146,int arg147,int arg148,int arg149,int arg150,int arg151,int arg152,int arg153,int arg154,int arg155,int arg156,int arg157,int arg158,int arg159,int arg160,int arg161,int arg162,int arg163,int arg164,int arg165,int arg166,int arg167,int arg168,int arg169,int arg170,int arg171,int arg172,int arg173,int arg174,int arg175,int arg176,int arg177,int arg178,int arg179,int arg180,int arg181,int arg182,int arg183,int arg184,int arg185,int arg186,int arg187,int arg188,int arg189,int arg190,int arg191,int arg192,int arg193,int arg194,int arg195,int arg196,int arg197,int arg198,int arg199,int arg200,int arg201,int arg202,int arg203,int arg204,int arg205,int arg206,int arg207,int arg208,int arg209,int arg210,int arg211,int arg212,int arg213,int arg214,int arg215,int arg216,int arg217,int arg218,int arg219,int arg220,int arg221,int arg222,int arg223,int arg224,int arg225,int arg226,int arg227,int arg228,int arg229,int arg230,int arg231,int arg232,int arg233,int arg234,int arg235,int arg236,int arg237,int arg238,int arg239,int arg240,int arg241,int arg242,int arg243,int arg244,int arg245,int arg246,int arg247,int arg248,int arg249,int arg250,int arg251,int arg252,int arg253,int arg254,int arg255,int arg256,int arg257,int arg258,int arg259,int arg260,int arg261,int arg262,int arg263,int arg264,int arg265,int arg266,int arg267,int arg268,int arg269,int arg270,int arg271,int arg272,int arg273,int arg274,int arg275,int arg276,int arg277,int arg278,int arg279,int arg280,int arg281,int arg282,int arg283,int arg284,int arg285,int arg286,int arg287,int arg288,int arg289,int arg290,int arg291,int arg292,int arg293,int arg294,int arg295,int arg296,int arg297,int arg298,int arg299,int arg300,int arg301,int arg302,int arg303,int arg304,int arg305,int arg306,int arg307,int arg308,int arg309,int arg310,int arg311,int arg312,int arg313,int arg314,int arg315,int arg316,int arg317,int arg318,int arg319,int arg320,int arg321,int arg322,int arg323,int arg324,int arg325,int arg326,int arg327,int arg328,int arg329,int arg330,int arg331,int arg332,int arg333,int arg334,int arg335,int arg336,int arg337,int arg338,int arg339,int arg340,int arg341,int arg342,int arg343,int arg344,int arg345,int arg346,int arg347,int arg348,int arg349,int arg350,int arg351,int arg352,int arg353,int arg354,int arg355,int arg356,int arg357,int arg358,int arg359,int arg360,int arg361,int arg362,int arg363,int arg364,int arg365,int arg366,int arg367,int arg368,int arg369,int arg370,int arg371,int arg372,int arg373,int arg374,int arg375,int arg376,int arg377,int arg378,int arg379,int arg380,int arg381,int arg382,int arg383,int arg384,int arg385,int arg386,int arg387,int arg388,int arg389,int arg390,int arg391,int arg392,int arg393,int arg394,int arg395,int arg396,int arg397,int arg398,int arg399,int arg400,int arg401,int arg402,int arg403,int arg404,int arg405,int arg406,int arg407,int arg408,int arg409,int arg410,int arg411,int arg412,int arg413,int arg414,int arg415,int arg416,int arg417,int arg418,int arg419,int arg420,int arg421,int arg422,int arg423,int arg424,int arg425,int arg426,int arg427,int arg428,int arg429,int arg430,int arg431,int arg432,int arg433,int arg434,int arg435,int arg436,int arg437,int arg438,int arg439,int arg440,int arg441,int arg442,int arg443,int arg444,int arg445,int arg446,int arg447,int arg448,int arg449,int arg450,int arg451,int arg452,int arg453,int arg454,int arg455,int arg456,int arg457,int arg458,int arg459,int arg460,int arg461,int arg462,int arg463,int arg464,int arg465,int arg466,int arg467,int arg468,int arg469,int arg470,int arg471,int arg472,int arg473,int arg474,int arg475,int arg476,int arg477,int arg478,int arg479,int arg480,int arg481,int arg482,int arg483,int arg484,int arg485,int arg486,int arg487,int arg488,int arg489,int arg490,int arg491,int arg492,int arg493,int arg494,int arg495,int arg496,int arg497,int arg498,int arg499,int arg500,int arg501,int arg502,int arg503,int arg504,int arg505,int arg506,int arg507,int arg508,int arg509,int arg510,int arg511,int arg512,int arg513,int arg514,int arg515,int arg516,int arg517,int arg518,int arg519,int arg520,int arg521,int arg522,int arg523,int arg524,int arg525,int arg526,int arg527,int arg528,int arg529,int arg530,int arg531,int arg532,int arg533,int arg534,int arg535,int arg536,int arg537,int arg538,int arg539,int arg540,int arg541,int arg542,int arg543,int arg544,int arg545,int arg546,int arg547,int arg548,int arg549,int arg550,int arg551,int arg552,int arg553,int arg554,int arg555,int arg556,int arg557,int arg558,int arg559,int arg560,int arg561,int arg562,int arg563,int arg564,int arg565,int arg566,int arg567,int arg568,int arg569,int arg570,int arg571,int arg572,int arg573,int arg574,int arg575,int arg576,int arg577,int arg578,int arg579,int arg580,int arg581,int arg582,int arg583,int arg584,int arg585,int arg586,int arg587,int arg588,int arg589,int arg590,int arg591,int arg592,int arg593,int arg594,int arg595,int arg596,int arg597,int arg598,int arg599,int arg600,int arg601,int arg602,int arg603,int arg604,int arg605,int arg606,int arg607,int arg608,int arg609,int arg610,int arg611,int arg612,int arg613,int arg614,int arg615,int arg616,int arg617,int arg618,int arg619,int arg620,int arg621,int arg622,int arg623,int arg624,int arg625,int arg626,int arg627,int arg628,int arg629,int arg630,int arg631,int arg632,int arg633,int arg634,int arg635,int arg636,int arg637,int arg638,int arg639,int arg640,int arg641,int arg642,int arg643,int arg644,int arg645,int arg646,int arg647,int arg648,int arg649,int arg650,int arg651,int arg652,int arg653,int arg654,int arg655,int arg656,int arg657,int arg658,int arg659,int arg660,int arg661,int arg662,int arg663,int arg664,int arg665,int arg666,int arg667,int arg668,int arg669,int arg670,int arg671,int arg672,int arg673,int arg674,int arg675,int arg676,int arg677,int arg678,int arg679,int arg680,int arg681,int arg682,int arg683,int arg684,int arg685,int arg686,int arg687,int arg688,int arg689,int arg690,int arg691,int arg692,int arg693,int arg694,int arg695,int arg696,int arg697,int arg698,int arg699,int arg700,int arg701,int arg702,int arg703,int arg704,int arg705,int arg706,int arg707,int arg708,int arg709,int arg710,int arg711,int arg712,int arg713,int arg714,int arg715,int arg716,int arg717,int arg718,int arg719,int arg720,int arg721,int arg722,int arg723,int arg724,int arg725,int arg726,int arg727,int arg728,int arg729,int arg730,int arg731,int arg732,int arg733,int arg734,int arg735,int arg736,int arg737,int arg738,int arg739,int arg740,int arg741,int arg742,int arg743,int arg744,int arg745,int arg746,int arg747,int arg748,int arg749,int arg750,int arg751,int arg752,int arg753,int arg754,int arg755,int arg756,int arg757,int arg758,int arg759,int arg760,int arg761,int arg762,int arg763,int arg764,int arg765,int arg766,int arg767,int arg768,int arg769,int arg770,int arg771,int arg772,int arg773,int arg774,int arg775,int arg776,int arg777,int arg778,int arg779,int arg780,int arg781,int arg782,int arg783,int arg784,int arg785,int arg786,int arg787,int arg788,int arg789,int arg790,int arg791,int arg792,int arg793,int arg794,int arg795,int arg796,int arg797,int arg798,int arg799,int arg800,int arg801,int arg802,int arg803,int arg804,int arg805,int arg806,int arg807,int arg808,int arg809,int arg810,int arg811,int arg812,int arg813,int arg814,int arg815,int arg816,int arg817,int arg818,int arg819,int arg820,int arg821,int arg822,int arg823,int arg824,int arg825,int arg826,int arg827,int arg828,int arg829,int arg830,int arg831,int arg832,int arg833,int arg834,int arg835,int arg836,int arg837,int arg838,int arg839,int arg840,int arg841,int arg842,int arg843,int arg844,int arg845,int arg846,int arg847,int arg848,int arg849,int arg850,int arg851,int arg852,int arg853,int arg854,int arg855,int arg856,int arg857,int arg858,int arg859,int arg860,int arg861,int arg862,int arg863,int arg864,int arg865,int arg866,int arg867,int arg868,int arg869,int arg870,int arg871,int arg872,int arg873,int arg874,int arg875,int arg876,int arg877,int arg878,int arg879,int arg880,int arg881,int arg882,int arg883,int arg884,int arg885,int arg886,int arg887,int arg888,int arg889,int arg890,int arg891,int arg892,int arg893,int arg894,int arg895,int arg896,int arg897,int arg898,int arg899,int arg900,int arg901,int arg902,int arg903,int arg904,int arg905,int arg906,int arg907,int arg908,int arg909,int arg910,int arg911,int arg912,int arg913,int arg914,int arg915,int arg916,int arg917,int arg918,int arg919,int arg920,int arg921,int arg922,int arg923,int arg924,int arg925,int arg926,int arg927,int arg928,int arg929,int arg930,int arg931,int arg932,int arg933,int arg934,int arg935,int arg936,int arg937,int arg938,int arg939,int arg940,int arg941,int arg942,int arg943,int arg944,int arg945,int arg946,int arg947,int arg948,int arg949,int arg950,int arg951,int arg952,int arg953,int arg954,int arg955,int arg956,int arg957,int arg958,int arg959,int arg960,int arg961,int arg962,int arg963,int arg964,int arg965,int arg966,int arg967,int arg968,int arg969,int arg970,int arg971,int arg972,int arg973,int arg974,int arg975,int arg976,int arg977,int arg978,int arg979,int arg980,int arg981,int arg982,int arg983,int arg984,int arg985,int arg986,int arg987,int arg988,int arg989,int arg990,int arg991,int arg992,int arg993,int arg994,int arg995,int arg996,int arg997,int arg998,int arg999,int arg1000,int arg1001,int arg1002,int arg1003,int arg1004,int arg1005,int arg1006,int arg1007,int arg1008,int arg1009,int arg1010,int arg1011,int arg1012,int arg1013,int arg1014,int arg1015,int arg1016,int arg1017,int arg1018,int arg1019,int arg1020,int arg1021,int arg1022,int arg1023,int arg1024,int arg1025,int arg1026,int arg1027,int arg1028,int arg1029,int arg1030,int arg1031,int arg1032,int arg1033,int arg1034,int arg1035,int arg1036,int arg1037,int arg1038,int arg1039,int arg1040,int arg1041,int arg1042,int arg1043,int arg1044,int arg1045,int arg1046,int arg1047,int arg1048,int arg1049,int arg1050,int arg1051,int arg1052,int arg1053,int arg1054,int arg1055,int arg1056,int arg1057,int arg1058,int arg1059,int arg1060,int arg1061,int arg1062,int arg1063,int arg1064,int arg1065,int arg1066,int arg1067,int arg1068,int arg1069,int arg1070,int arg1071,int arg1072,int arg1073,int arg1074,int arg1075,int arg1076,int arg1077,int arg1078,int arg1079,int arg1080,int arg1081,int arg1082,int arg1083,int arg1084,int arg1085,int arg1086,int arg1087,int arg1088,int arg1089,int arg1090,int arg1091,int arg1092,int arg1093,int arg1094,int arg1095,int arg1096,int arg1097,int arg1098,int arg1099,int arg1100,int arg1101,int arg1102,int arg1103,int arg1104,int arg1105,int arg1106,int arg1107,int arg1108,int arg1109,int arg1110,int arg1111,int arg1112,int arg1113,int arg1114,int arg1115,int arg1116,int arg1117,int arg1118,int arg1119,int arg1120,int arg1121,int arg1122,int arg1123,int arg1124,int arg1125,int arg1126,int arg1127,int arg1128,int arg1129,int arg1130,int arg1131,int arg1132,int arg1133,int arg1134,int arg1135,int arg1136,int arg1137,int arg1138,int arg1139,int arg1140,int arg1141,int arg1142,int arg1143,int arg1144,int arg1145,int arg1146,int arg1147,int arg1148,int arg1149,int arg1150,int arg1151,int arg1152,int arg1153,int arg1154,int arg1155,int arg1156,int arg1157,int arg1158,int arg1159,int arg1160,int arg1161,int arg1162,int arg1163,int arg1164,int arg1165,int arg1166,int arg1167,int arg1168,int arg1169,int arg1170,int arg1171,int arg1172,int arg1173,int arg1174,int arg1175,int arg1176,int arg1177,int arg1178,int arg1179,int arg1180,int arg1181,int arg1182,int arg1183,int arg1184,int arg1185,int arg1186,int arg1187,int arg1188,int arg1189,int arg1190,int arg1191,int arg1192,int arg1193,int arg1194,int arg1195,int arg1196,int arg1197,int arg1198,int arg1199,int arg1200,int arg1201,int arg1202,int arg1203,int arg1204,int arg1205,int arg1206,int arg1207,int arg1208,int arg1209,int arg1210,int arg1211,int arg1212,int arg1213,int arg1214,int arg1215,int arg1216,int arg1217,int arg1218,int arg1219,int arg1220,int arg1221,int arg1222,int arg1223,int arg1224,int arg1225,int arg1226,int arg1227,int arg1228,int arg1229,int arg1230,int arg1231,int arg1232,int arg1233,int arg1234,int arg1235,int arg1236,int arg1237,int arg1238,int arg1239,int arg1240,int arg1241,int arg1242,int arg1243,int arg1244,int arg1245,int arg1246,int arg1247,int arg1248,int arg1249,int arg1250,int arg1251,int arg1252,int arg1253,int arg1254,int arg1255,int arg1256,int arg1257,int arg1258,int arg1259,int arg1260,int arg1261,int arg1262,int arg1263,int arg1264,int arg1265,int arg1266,int arg1267,int arg1268,int arg1269,int arg1270,int arg1271,int arg1272,int arg1273,int arg1274,int arg1275,int arg1276,int arg1277,int arg1278,int arg1279,int arg1280,int arg1281,int arg1282,int arg1283,int arg1284,int arg1285,int arg1286,int arg1287,int arg1288,int arg1289,int arg1290,int arg1291,int arg1292,int arg1293,int arg1294,int arg1295,int arg1296,int arg1297,int arg1298,int arg1299,int arg1300,int arg1301,int arg1302,int arg1303,int arg1304,int arg1305,int arg1306,int arg1307,int arg1308,int arg1309,int arg1310,int arg1311,int arg1312,int arg1313,int arg1314,int arg1315,int arg1316,int arg1317,int arg1318,int arg1319,int arg1320,int arg1321,int arg1322,int arg1323,int arg1324,int arg1325,int arg1326,int arg1327,int arg1328,int arg1329,int arg1330,int arg1331,int arg1332,int arg1333,int arg1334,int arg1335,int arg1336,int arg1337,int arg1338,int arg1339,int arg1340,int arg1341,int arg1342,int arg1343,int arg1344,int arg1345,int arg1346,int arg1347,int arg1348,int arg1349,int arg1350,int arg1351,int arg1352,int arg1353,int arg1354,int arg1355,int arg1356,int arg1357,int arg1358,int arg1359,int arg1360,int arg1361,int arg1362,int arg1363,int arg1364,int arg1365,int arg1366,int arg1367,int arg1368,int arg1369,int arg1370,int arg1371,int arg1372,int arg1373,int arg1374,int arg1375,int arg1376,int arg1377,int arg1378,int arg1379,int arg1380,int arg1381,int arg1382,int arg1383,int arg1384,int arg1385,int arg1386,int arg1387,int arg1388,int arg1389,int arg1390,int arg1391,int arg1392,int arg1393,int arg1394,int arg1395,int arg1396,int arg1397,int arg1398,int arg1399,int arg1400,int arg1401,int arg1402,int arg1403,int arg1404,int arg1405,int arg1406,int arg1407,int arg1408,int arg1409,int arg1410,int arg1411,int arg1412,int arg1413,int arg1414,int arg1415,int arg1416,int arg1417,int arg1418,int arg1419,int arg1420,int arg1421,int arg1422,int arg1423,int arg1424,int arg1425,int arg1426,int arg1427,int arg1428,int arg1429,int arg1430,int arg1431,int arg1432,int arg1433,int arg1434,int arg1435,int arg1436,int arg1437,int arg1438,int arg1439,int arg1440,int arg1441,int arg1442,int arg1443,int arg1444,int arg1445,int arg1446,int arg1447,int arg1448,int arg1449,int arg1450,int arg1451,int arg1452,int arg1453,int arg1454,int arg1455,int arg1456,int arg1457,int arg1458,int arg1459,int arg1460,int arg1461,int arg1462,int arg1463,int arg1464,int arg1465,int arg1466,int arg1467,int arg1468,int arg1469,int arg1470,int arg1471,int arg1472,int arg1473,int arg1474,int arg1475,int arg1476,int arg1477,int arg1478,int arg1479,int arg1480,int arg1481,int arg1482,int arg1483,int arg1484,int arg1485,int arg1486,int arg1487,int arg1488,int arg1489,int arg1490,int arg1491,int arg1492,int arg1493,int arg1494,int arg1495,int arg1496,int arg1497,int arg1498,int arg1499,int arg1500,int arg1501,int arg1502,int arg1503,int arg1504,int arg1505,int arg1506,int arg1507,int arg1508,int arg1509,int arg1510,int arg1511,int arg1512,int arg1513,int arg1514,int arg1515,int arg1516,int arg1517,int arg1518,int arg1519,int arg1520,int arg1521,int arg1522,int arg1523,int arg1524,int arg1525,int arg1526,int arg1527,int arg1528,int arg1529,int arg1530,int arg1531,int arg1532,int arg1533,int arg1534,int arg1535,int arg1536,int arg1537,int arg1538,int arg1539,int arg1540,int arg1541,int arg1542,int arg1543,int arg1544,int arg1545,int arg1546,int arg1547,int arg1548,int arg1549,int arg1550,int arg1551,int arg1552,int arg1553,int arg1554,int arg1555,int arg1556,int arg1557,int arg1558,int arg1559,int arg1560,int arg1561,int arg1562,int arg1563,int arg1564,int arg1565,int arg1566,int arg1567,int arg1568,int arg1569,int arg1570,int arg1571,int arg1572,int arg1573,int arg1574,int arg1575,int arg1576,int arg1577,int arg1578,int arg1579,int arg1580,int arg1581,int arg1582,int arg1583,int arg1584,int arg1585,int arg1586,int arg1587,int arg1588,int arg1589,int arg1590,int arg1591,int arg1592,int arg1593,int arg1594,int arg1595,int arg1596,int arg1597,int arg1598,int arg1599,int arg1600,int arg1601,int arg1602,int arg1603,int arg1604,int arg1605,int arg1606,int arg1607,int arg1608,int arg1609,int arg1610,int arg1611,int arg1612,int arg1613,int arg1614,int arg1615,int arg1616,int arg1617,int arg1618,int arg1619,int arg1620,int arg1621,int arg1622,int arg1623,int arg1624,int arg1625,int arg1626,int arg1627,int arg1628,int arg1629,int arg1630,int arg1631,int arg1632,int arg1633,int arg1634,int arg1635,int arg1636,int arg1637,int arg1638,int arg1639,int arg1640,int arg1641,int arg1642,int arg1643,int arg1644,int arg1645,int arg1646,int arg1647,int arg1648,int arg1649,int arg1650,int arg1651,int arg1652,int arg1653,int arg1654,int arg1655,int arg1656,int arg1657,int arg1658,int arg1659,int arg1660,int arg1661,int arg1662,int arg1663,int arg1664,int arg1665,int arg1666,int arg1667,int arg1668,int arg1669,int arg1670,int arg1671,int arg1672,int arg1673,int arg1674,int arg1675,int arg1676,int arg1677,int arg1678,int arg1679,int arg1680,int arg1681,int arg1682,int arg1683,int arg1684,int arg1685,int arg1686,int arg1687,int arg1688,int arg1689,int arg1690,int arg1691,int arg1692,int arg1693,int arg1694,int arg1695,int arg1696,int arg1697,int arg1698,int arg1699,int arg1700,int arg1701,int arg1702,int arg1703,int arg1704,int arg1705,int arg1706,int arg1707,int arg1708,int arg1709,int arg1710,int arg1711,int arg1712,int arg1713,int arg1714,int arg1715,int arg1716,int arg1717,int arg1718,int arg1719,int arg1720,int arg1721,int arg1722,int arg1723,int arg1724,int arg1725,int arg1726,int arg1727,int arg1728,int arg1729,int arg1730,int arg1731,int arg1732,int arg1733,int arg1734,int arg1735,int arg1736,int arg1737,int arg1738,int arg1739,int arg1740,int arg1741,int arg1742,int arg1743,int arg1744,int arg1745,int arg1746,int arg1747,int arg1748,int arg1749,int arg1750,int arg1751,int arg1752,int arg1753,int arg1754,int arg1755,int arg1756,int arg1757,int arg1758,int arg1759,int arg1760,int arg1761,int arg1762,int arg1763,int arg1764,int arg1765,int arg1766,int arg1767,int arg1768,int arg1769,int arg1770,int arg1771,int arg1772,int arg1773,int arg1774,int arg1775,int arg1776,int arg1777,int arg1778,int arg1779,int arg1780,int arg1781,int arg1782,int arg1783,int arg1784,int arg1785,int arg1786,int arg1787,int arg1788,int arg1789,int arg1790,int arg1791,int arg1792,int arg1793,int arg1794,int arg1795,int arg1796,int arg1797,int arg1798,int arg1799,int arg1800,int arg1801,int arg1802,int arg1803,int arg1804,int arg1805,int arg1806,int arg1807,int arg1808,int arg1809,int arg1810,int arg1811,int arg1812,int arg1813,int arg1814,int arg1815,int arg1816,int arg1817,int arg1818,int arg1819,int arg1820,int arg1821,int arg1822,int arg1823,int arg1824,int arg1825,int arg1826,int arg1827,int arg1828,int arg1829,int arg1830,int arg1831,int arg1832,int arg1833,int arg1834,int arg1835,int arg1836,int arg1837,int arg1838,int arg1839,int arg1840,int arg1841,int arg1842,int arg1843,int arg1844,int arg1845,int arg1846,int arg1847,int arg1848,int arg1849,int arg1850,int arg1851,int arg1852,int arg1853,int arg1854,int arg1855,int arg1856,int arg1857,int arg1858,int arg1859,int arg1860,int arg1861,int arg1862,int arg1863,int arg1864,int arg1865,int arg1866,int arg1867,int arg1868,int arg1869,int arg1870,int arg1871,int arg1872,int arg1873,int arg1874,int arg1875,int arg1876,int arg1877,int arg1878,int arg1879,int arg1880,int arg1881,int arg1882,int arg1883,int arg1884,int arg1885,int arg1886,int arg1887,int arg1888,int arg1889,int arg1890,int arg1891,int arg1892,int arg1893,int arg1894,int arg1895,int arg1896,int arg1897,int arg1898,int arg1899,int arg1900,int arg1901,int arg1902,int arg1903,int arg1904,int arg1905,int arg1906,int arg1907,int arg1908,int arg1909,int arg1910,int arg1911,int arg1912,int arg1913,int arg1914,int arg1915,int arg1916,int arg1917,int arg1918,int arg1919,int arg1920,int arg1921,int arg1922,int arg1923,int arg1924,int arg1925,int arg1926,int arg1927,int arg1928,int arg1929,int arg1930,int arg1931,int arg1932,int arg1933,int arg1934,int arg1935,int arg1936,int arg1937,int arg1938,int arg1939,int arg1940,int arg1941,int arg1942,int arg1943,int arg1944,int arg1945,int arg1946,int arg1947,int arg1948,int arg1949,int arg1950,int arg1951,int arg1952,int arg1953,int arg1954,int arg1955,int arg1956,int arg1957,int arg1958,int arg1959,int arg1960,int arg1961,int arg1962,int arg1963,int arg1964,int arg1965,int arg1966,int arg1967,int arg1968,int arg1969,int arg1970,int arg1971,int arg1972,int arg1973,int arg1974,int arg1975,int arg1976,int arg1977,int arg1978,int arg1979,int arg1980,int arg1981,int arg1982,int arg1983,int arg1984,int arg1985,int arg1986,int arg1987,int arg1988,int arg1989,int arg1990,int arg1991,int arg1992,int arg1993,int arg1994,int arg1995,int arg1996,int arg1997,int arg1998,int arg1999,int arg2000,int arg2001,int arg2002,int arg2003,int arg2004,int arg2005,int arg2006,int arg2007,int arg2008,int arg2009,int arg2010,int arg2011,int arg2012,int arg2013,int arg2014,int arg2015,int arg2016,int arg2017,int arg2018,int arg2019,int arg2020,int arg2021,int arg2022,int arg2023,int arg2024,int arg2025,int arg2026,int arg2027,int arg2028,int arg2029,int arg2030,int arg2031,int arg2032,int arg2033,int arg2034,int arg2035,int arg2036,int arg2037,int arg2038,int arg2039,int arg2040,int arg2041,int arg2042,int arg2043,int arg2044,int arg2045,int arg2046,int arg2047,int arg2048,int arg2049,int arg2050,int arg2051,int arg2052,int arg2053,int arg2054,int arg2055,int arg2056,int arg2057,int arg2058,int arg2059,int arg2060,int arg2061,int arg2062,int arg2063,int arg2064,int arg2065,int arg2066,int arg2067,int arg2068,int arg2069,int arg2070,int arg2071,int arg2072,int arg2073,int arg2074,int arg2075,int arg2076,int arg2077,int arg2078,int arg2079,int arg2080,int arg2081,int arg2082,int arg2083,int arg2084,int arg2085,int arg2086,int arg2087,int arg2088,int arg2089,int arg2090,int arg2091,int arg2092,int arg2093,int arg2094,int arg2095,int arg2096,int arg2097,int arg2098,int arg2099,int arg2100,int arg2101,int arg2102,int arg2103,int arg2104,int arg2105,int arg2106,int arg2107,int arg2108,int arg2109,int arg2110,int arg2111,int arg2112,int arg2113,int arg2114,int arg2115,int arg2116,int arg2117,int arg2118,int arg2119,int arg2120,int arg2121,int arg2122,int arg2123,int arg2124,int arg2125,int arg2126,int arg2127,int arg2128,int arg2129,int arg2130,int arg2131,int arg2132,int arg2133,int arg2134,int arg2135,int arg2136,int arg2137,int arg2138,int arg2139,int arg2140,int arg2141,int arg2142,int arg2143,int arg2144,int arg2145,int arg2146,int arg2147,int arg2148,int arg2149,int arg2150,int arg2151,int arg2152,int arg2153,int arg2154,int arg2155,int arg2156,int arg2157,int arg2158,int arg2159,int arg2160,int arg2161,int arg2162,int arg2163,int arg2164,int arg2165,int arg2166,int arg2167,int arg2168,int arg2169,int arg2170,int arg2171,int arg2172,int arg2173,int arg2174,int arg2175,int arg2176,int arg2177,int arg2178,int arg2179,int arg2180,int arg2181,int arg2182,int arg2183,int arg2184,int arg2185,int arg2186,int arg2187,int arg2188,int arg2189,int arg2190,int arg2191,int arg2192,int arg2193,int arg2194,int arg2195,int arg2196,int arg2197,int arg2198,int arg2199,int arg2200,int arg2201,int arg2202,int arg2203,int arg2204,int arg2205,int arg2206,int arg2207,int arg2208,int arg2209,int arg2210,int arg2211,int arg2212,int arg2213,int arg2214,int arg2215,int arg2216,int arg2217,int arg2218,int arg2219,int arg2220,int arg2221,int arg2222,int arg2223,int arg2224,int arg2225,int arg2226,int arg2227,int arg2228,int arg2229,int arg2230,int arg2231,int arg2232,int arg2233,int arg2234,int arg2235,int arg2236,int arg2237,int arg2238,int arg2239,int arg2240,int arg2241,int arg2242,int arg2243,int arg2244,int arg2245,int arg2246,int arg2247,int arg2248,int arg2249,int arg2250,int arg2251,int arg2252,int arg2253,int arg2254,int arg2255,int arg2256,int arg2257,int arg2258,int arg2259,int arg2260,int arg2261,int arg2262,int arg2263,int arg2264,int arg2265,int arg2266,int arg2267,int arg2268,int arg2269,int arg2270,int arg2271,int arg2272,int arg2273,int arg2274,int arg2275,int arg2276,int arg2277,int arg2278,int arg2279,int arg2280,int arg2281,int arg2282,int arg2283,int arg2284,int arg2285,int arg2286,int arg2287,int arg2288,int arg2289,int arg2290,int arg2291,int arg2292,int arg2293,int arg2294,int arg2295,int arg2296,int arg2297,int arg2298,int arg2299,int arg2300,int arg2301,int arg2302,int arg2303,int arg2304,int arg2305,int arg2306,int arg2307,int arg2308,int arg2309,int arg2310,int arg2311,int arg2312,int arg2313,int arg2314,int arg2315,int arg2316,int arg2317,int arg2318,int arg2319,int arg2320,int arg2321,int arg2322,int arg2323,int arg2324,int arg2325,int arg2326,int arg2327,int arg2328,int arg2329,int arg2330,int arg2331,int arg2332,int arg2333,int arg2334,int arg2335,int arg2336,int arg2337,int arg2338,int arg2339,int arg2340,int arg2341,int arg2342,int arg2343,int arg2344,int arg2345,int arg2346,int arg2347,int arg2348,int arg2349,int arg2350,int arg2351,int arg2352,int arg2353,int arg2354,int arg2355,int arg2356,int arg2357,int arg2358,int arg2359,int arg2360,int arg2361,int arg2362,int arg2363,int arg2364,int arg2365,int arg2366,int arg2367,int arg2368,int arg2369,int arg2370,int arg2371,int arg2372,int arg2373,int arg2374,int arg2375,int arg2376,int arg2377,int arg2378,int arg2379,int arg2380,int arg2381,int arg2382,int arg2383,int arg2384,int arg2385,int arg2386,int arg2387,int arg2388,int arg2389,int arg2390,int arg2391,int arg2392,int arg2393,int arg2394,int arg2395,int arg2396,int arg2397,int arg2398,int arg2399,int arg2400,int arg2401,int arg2402,int arg2403,int arg2404,int arg2405,int arg2406,int arg2407,int arg2408,int arg2409,int arg2410,int arg2411,int arg2412,int arg2413,int arg2414,int arg2415,int arg2416,int arg2417,int arg2418,int arg2419,int arg2420,int arg2421,int arg2422,int arg2423,int arg2424,int arg2425,int arg2426,int arg2427,int arg2428,int arg2429,int arg2430,int arg2431,int arg2432,int arg2433,int arg2434,int arg2435,int arg2436,int arg2437,int arg2438,int arg2439,int arg2440,int arg2441,int arg2442,int arg2443,int arg2444,int arg2445,int arg2446,int arg2447,int arg2448,int arg2449,int arg2450,int arg2451,int arg2452,int arg2453,int arg2454,int arg2455,int arg2456,int arg2457,int arg2458,int arg2459,int arg2460,int arg2461,int arg2462,int arg2463,int arg2464,int arg2465,int arg2466,int arg2467,int arg2468,int arg2469,int arg2470,int arg2471,int arg2472,int arg2473,int arg2474,int arg2475,int arg2476,int arg2477,int arg2478,int arg2479,int arg2480,int arg2481,int arg2482,int arg2483,int arg2484,int arg2485,int arg2486,int arg2487,int arg2488,int arg2489,int arg2490,int arg2491,int arg2492,int arg2493,int arg2494,int arg2495,int arg2496,int arg2497,int arg2498,int arg2499,int arg2500,int arg2501,int arg2502,int arg2503,int arg2504,int arg2505,int arg2506,int arg2507,int arg2508,int arg2509,int arg2510,int arg2511,int arg2512,int arg2513,int arg2514,int arg2515,int arg2516,int arg2517,int arg2518,int arg2519,int arg2520,int arg2521,int arg2522,int arg2523,int arg2524,int arg2525,int arg2526,int arg2527,int arg2528,int arg2529,int arg2530,int arg2531,int arg2532,int arg2533,int arg2534,int arg2535,int arg2536,int arg2537,int arg2538,int arg2539,int arg2540,int arg2541,int arg2542,int arg2543,int arg2544,int arg2545,int arg2546,int arg2547,int arg2548,int arg2549,int arg2550,int arg2551,int arg2552,int arg2553,int arg2554,int arg2555,int arg2556,int arg2557,int arg2558,int arg2559,int arg2560,int arg2561,int arg2562,int arg2563,int arg2564,int arg2565,int arg2566,int arg2567,int arg2568,int arg2569,int arg2570,int arg2571,int arg2572,int arg2573,int arg2574,int arg2575,int arg2576,int arg2577,int arg2578,int arg2579,int arg2580,int arg2581,int arg2582,int arg2583,int arg2584,int arg2585,int arg2586,int arg2587,int arg2588,int arg2589,int arg2590,int arg2591,int arg2592,int arg2593,int arg2594,int arg2595,int arg2596,int arg2597,int arg2598,int arg2599,int arg2600,int arg2601,int arg2602,int arg2603,int arg2604,int arg2605,int arg2606,int arg2607,int arg2608,int arg2609,int arg2610,int arg2611,int arg2612,int arg2613,int arg2614,int arg2615,int arg2616,int arg2617,int arg2618,int arg2619,int arg2620,int arg2621,int arg2622,int arg2623,int arg2624,int arg2625,int arg2626,int arg2627,int arg2628,int arg2629,int arg2630,int arg2631,int arg2632,int arg2633,int arg2634,int arg2635,int arg2636,int arg2637,int arg2638,int arg2639,int arg2640,int arg2641,int arg2642,int arg2643,int arg2644,int arg2645,int arg2646,int arg2647,int arg2648,int arg2649,int arg2650,int arg2651,int arg2652,int arg2653,int arg2654,int arg2655,int arg2656,int arg2657,int arg2658,int arg2659,int arg2660,int arg2661,int arg2662,int arg2663,int arg2664,int arg2665,int arg2666,int arg2667,int arg2668,int arg2669,int arg2670,int arg2671,int arg2672,int arg2673,int arg2674,int arg2675,int arg2676,int arg2677,int arg2678,int arg2679,int arg2680,int arg2681,int arg2682,int arg2683,int arg2684,int arg2685,int arg2686,int arg2687,int arg2688,int arg2689,int arg2690,int arg2691,int arg2692,int arg2693,int arg2694,int arg2695,int arg2696,int arg2697,int arg2698,int arg2699,int arg2700,int arg2701,int arg2702,int arg2703,int arg2704,int arg2705,int arg2706,int arg2707,int arg2708,int arg2709,int arg2710,int arg2711,int arg2712,int arg2713,int arg2714,int arg2715,int arg2716,int arg2717,int arg2718,int arg2719,int arg2720,int arg2721,int arg2722,int arg2723,int arg2724,int arg2725,int arg2726,int arg2727,int arg2728,int arg2729,int arg2730,int arg2731,int arg2732,int arg2733,int arg2734,int arg2735,int arg2736,int arg2737,int arg2738,int arg2739,int arg2740,int arg2741,int arg2742,int arg2743,int arg2744,int arg2745,int arg2746,int arg2747,int arg2748,int arg2749,int arg2750,int arg2751,int arg2752,int arg2753,int arg2754,int arg2755,int arg2756,int arg2757,int arg2758,int arg2759,int arg2760,int arg2761,int arg2762,int arg2763,int arg2764,int arg2765,int arg2766,int arg2767,int arg2768,int arg2769,int arg2770,int arg2771,int arg2772,int arg2773,int arg2774,int arg2775,int arg2776,int arg2777,int arg2778,int arg2779,int arg2780,int arg2781,int arg2782,int arg2783,int arg2784,int arg2785,int arg2786,int arg2787,int arg2788,int arg2789,int arg2790,int arg2791,int arg2792,int arg2793,int arg2794,int arg2795,int arg2796,int arg2797,int arg2798,int arg2799,int arg2800,int arg2801,int arg2802,int arg2803,int arg2804,int arg2805,int arg2806,int arg2807,int arg2808,int arg2809,int arg2810,int arg2811,int arg2812,int arg2813,int arg2814,int arg2815,int arg2816,int arg2817,int arg2818,int arg2819,int arg2820,int arg2821,int arg2822,int arg2823,int arg2824,int arg2825,int arg2826,int arg2827,int arg2828,int arg2829,int arg2830,int arg2831,int arg2832,int arg2833,int arg2834,int arg2835,int arg2836,int arg2837,int arg2838,int arg2839,int arg2840,int arg2841,int arg2842,int arg2843,int arg2844,int arg2845,int arg2846,int arg2847,int arg2848,int arg2849,int arg2850,int arg2851,int arg2852,int arg2853,int arg2854,int arg2855,int arg2856,int arg2857,int arg2858,int arg2859,int arg2860,int arg2861,int arg2862,int arg2863,int arg2864,int arg2865,int arg2866,int arg2867,int arg2868,int arg2869,int arg2870,int arg2871,int arg2872,int arg2873,int arg2874,int arg2875,int arg2876,int arg2877,int arg2878,int arg2879,int arg2880,int arg2881,int arg2882,int arg2883,int arg2884,int arg2885,int arg2886,int arg2887,int arg2888,int arg2889,int arg2890,int arg2891,int arg2892,int arg2893,int arg2894,int arg2895,int arg2896,int arg2897,int arg2898,int arg2899,int arg2900,int arg2901,int arg2902,int arg2903,int arg2904,int arg2905,int arg2906,int arg2907,int arg2908,int arg2909,int arg2910,int arg2911,int arg2912,int arg2913,int arg2914,int arg2915,int arg2916,int arg2917,int arg2918,int arg2919,int arg2920,int arg2921,int arg2922,int arg2923,int arg2924,int arg2925,int arg2926,int arg2927,int arg2928,int arg2929,int arg2930,int arg2931,int arg2932,int arg2933,int arg2934,int arg2935,int arg2936,int arg2937,int arg2938,int arg2939,int arg2940,int arg2941,int arg2942,int arg2943,int arg2944,int arg2945,int arg2946,int arg2947,int arg2948,int arg2949,int arg2950,int arg2951,int arg2952,int arg2953,int arg2954,int arg2955,int arg2956,int arg2957,int arg2958,int arg2959,int arg2960,int arg2961,int arg2962,int arg2963,int arg2964,int arg2965,int arg2966,int arg2967,int arg2968,int arg2969,int arg2970,int arg2971,int arg2972,int arg2973,int arg2974,int arg2975,int arg2976,int arg2977,int arg2978,int arg2979,int arg2980,int arg2981,int arg2982,int arg2983,int arg2984,int arg2985,int arg2986,int arg2987,int arg2988,int arg2989,int arg2990,int arg2991,int arg2992,int arg2993,int arg2994,int arg2995,int arg2996,int arg2997,int arg2998,int arg2999,int arg3000,int arg3001,int arg3002,int arg3003,int arg3004,int arg3005,int arg3006,int arg3007,int arg3008,int arg3009,int arg3010,int arg3011,int arg3012,int arg3013,int arg3014,int arg3015,int arg3016,int arg3017,int arg3018,int arg3019,int arg3020,int arg3021,int arg3022,int arg3023,int arg3024,int arg3025,int arg3026,int arg3027,int arg3028,int arg3029,int arg3030,int arg3031,int arg3032,int arg3033,int arg3034,int arg3035,int arg3036,int arg3037,int arg3038,int arg3039,int arg3040,int arg3041,int arg3042,int arg3043,int arg3044,int arg3045,int arg3046,int arg3047,int arg3048,int arg3049,int arg3050,int arg3051,int arg3052,int arg3053,int arg3054,int arg3055,int arg3056,int arg3057,int arg3058,int arg3059,int arg3060,int arg3061,int arg3062,int arg3063,int arg3064,int arg3065,int arg3066,int arg3067,int arg3068,int arg3069,int arg3070,int arg3071,int arg3072,int arg3073,int arg3074,int arg3075,int arg3076,int arg3077,int arg3078,int arg3079,int arg3080,int arg3081,int arg3082,int arg3083,int arg3084,int arg3085,int arg3086,int arg3087,int arg3088,int arg3089,int arg3090,int arg3091,int arg3092,int arg3093,int arg3094,int arg3095,int arg3096,int arg3097,int arg3098,int arg3099,int arg3100,int arg3101,int arg3102,int arg3103,int arg3104,int arg3105,int arg3106,int arg3107,int arg3108,int arg3109,int arg3110,int arg3111,int arg3112,int arg3113,int arg3114,int arg3115,int arg3116,int arg3117,int arg3118,int arg3119,int arg3120,int arg3121,int arg3122,int arg3123,int arg3124,int arg3125,int arg3126,int arg3127,int arg3128,int arg3129,int arg3130,int arg3131,int arg3132,int arg3133,int arg3134,int arg3135,int arg3136,int arg3137,int arg3138,int arg3139,int arg3140,int arg3141,int arg3142,int arg3143,int arg3144,int arg3145,int arg3146,int arg3147,int arg3148,int arg3149,int arg3150,int arg3151,int arg3152,int arg3153,int arg3154,int arg3155,int arg3156,int arg3157,int arg3158,int arg3159,int arg3160,int arg3161,int arg3162,int arg3163,int arg3164,int arg3165,int arg3166,int arg3167,int arg3168,int arg3169,int arg3170,int arg3171,int arg3172,int arg3173,int arg3174,int arg3175,int arg3176,int arg3177,int arg3178,int arg3179,int arg3180,int arg3181,int arg3182,int arg3183,int arg3184,int arg3185,int arg3186,int arg3187,int arg3188,int arg3189,int arg3190,int arg3191,int arg3192,int arg3193,int arg3194,int arg3195,int arg3196,int arg3197,int arg3198,int arg3199,int arg3200,int arg3201,int arg3202,int arg3203,int arg3204,int arg3205,int arg3206,int arg3207,int arg3208,int arg3209,int arg3210,int arg3211,int arg3212,int arg3213,int arg3214,int arg3215,int arg3216,int arg3217,int arg3218,int arg3219,int arg3220,int arg3221,int arg3222,int arg3223,int arg3224,int arg3225,int arg3226,int arg3227,int arg3228,int arg3229,int arg3230,int arg3231,int arg3232,int arg3233,int arg3234,int arg3235,int arg3236,int arg3237,int arg3238,int arg3239,int arg3240,int arg3241,int arg3242,int arg3243,int arg3244,int arg3245,int arg3246,int arg3247,int arg3248,int arg3249,int arg3250,int arg3251,int arg3252,int arg3253,int arg3254,int arg3255,int arg3256,int arg3257,int arg3258,int arg3259,int arg3260,int arg3261,int arg3262,int arg3263,int arg3264,int arg3265,int arg3266,int arg3267,int arg3268,int arg3269,int arg3270,int arg3271,int arg3272,int arg3273,int arg3274,int arg3275,int arg3276,int arg3277,int arg3278,int arg3279,int arg3280,int arg3281,int arg3282,int arg3283,int arg3284,int arg3285,int arg3286,int arg3287,int arg3288,int arg3289,int arg3290,int arg3291,int arg3292,int arg3293,int arg3294,int arg3295,int arg3296,int arg3297,int arg3298,int arg3299,int arg3300,int arg3301,int arg3302,int arg3303,int arg3304,int arg3305,int arg3306,int arg3307,int arg3308,int arg3309,int arg3310,int arg3311,int arg3312,int arg3313,int arg3314,int arg3315,int arg3316,int arg3317,int arg3318,int arg3319,int arg3320,int arg3321,int arg3322,int arg3323,int arg3324,int arg3325,int arg3326,int arg3327,int arg3328,int arg3329,int arg3330,int arg3331,int arg3332,int arg3333,int arg3334,int arg3335,int arg3336,int arg3337,int arg3338,int arg3339,int arg3340,int arg3341,int arg3342,int arg3343,int arg3344,int arg3345,int arg3346,int arg3347,int arg3348,int arg3349,int arg3350,int arg3351,int arg3352,int arg3353,int arg3354,int arg3355,int arg3356,int arg3357,int arg3358,int arg3359,int arg3360,int arg3361,int arg3362,int arg3363,int arg3364,int arg3365,int arg3366,int arg3367,int arg3368,int arg3369,int arg3370,int arg3371,int arg3372,int arg3373,int arg3374,int arg3375,int arg3376,int arg3377,int arg3378,int arg3379,int arg3380,int arg3381,int arg3382,int arg3383,int arg3384,int arg3385,int arg3386,int arg3387,int arg3388,int arg3389,int arg3390,int arg3391,int arg3392,int arg3393,int arg3394,int arg3395,int arg3396,int arg3397,int arg3398,int arg3399,int arg3400,int arg3401,int arg3402,int arg3403,int arg3404,int arg3405,int arg3406,int arg3407,int arg3408,int arg3409,int arg3410,int arg3411,int arg3412,int arg3413,int arg3414,int arg3415,int arg3416,int arg3417,int arg3418,int arg3419,int arg3420,int arg3421,int arg3422,int arg3423,int arg3424,int arg3425,int arg3426,int arg3427,int arg3428,int arg3429,int arg3430,int arg3431,int arg3432,int arg3433,int arg3434,int arg3435,int arg3436,int arg3437,int arg3438,int arg3439,int arg3440,int arg3441,int arg3442,int arg3443,int arg3444,int arg3445,int arg3446,int arg3447,int arg3448,int arg3449,int arg3450,int arg3451,int arg3452,int arg3453,int arg3454,int arg3455,int arg3456,int arg3457,int arg3458,int arg3459,int arg3460,int arg3461,int arg3462,int arg3463,int arg3464,int arg3465,int arg3466,int arg3467,int arg3468,int arg3469,int arg3470,int arg3471,int arg3472,int arg3473,int arg3474,int arg3475,int arg3476,int arg3477,int arg3478,int arg3479,int arg3480,int arg3481,int arg3482,int arg3483,int arg3484,int arg3485,int arg3486,int arg3487,int arg3488,int arg3489,int arg3490,int arg3491,int arg3492,int arg3493,int arg3494,int arg3495,int arg3496,int arg3497,int arg3498,int arg3499,int arg3500,int arg3501,int arg3502,int arg3503,int arg3504,int arg3505,int arg3506,int arg3507,int arg3508,int arg3509,int arg3510,int arg3511,int arg3512,int arg3513,int arg3514,int arg3515,int arg3516,int arg3517,int arg3518,int arg3519,int arg3520,int arg3521,int arg3522,int arg3523,int arg3524,int arg3525,int arg3526,int arg3527,int arg3528,int arg3529,int arg3530,int arg3531,int arg3532,int arg3533,int arg3534,int arg3535,int arg3536,int arg3537,int arg3538,int arg3539,int arg3540,int arg3541,int arg3542,int arg3543,int arg3544,int arg3545,int arg3546,int arg3547,int arg3548,int arg3549,int arg3550,int arg3551,int arg3552,int arg3553,int arg3554,int arg3555,int arg3556,int arg3557,int arg3558,int arg3559,int arg3560,int arg3561,int arg3562,int arg3563,int arg3564,int arg3565,int arg3566,int arg3567,int arg3568,int arg3569,int arg3570,int arg3571,int arg3572,int arg3573,int arg3574,int arg3575,int arg3576,int arg3577,int arg3578,int arg3579,int arg3580,int arg3581,int arg3582,int arg3583,int arg3584,int arg3585,int arg3586,int arg3587,int arg3588,int arg3589,int arg3590,int arg3591,int arg3592,int arg3593,int arg3594,int arg3595,int arg3596,int arg3597,int arg3598,int arg3599,int arg3600,int arg3601,int arg3602,int arg3603,int arg3604,int arg3605,int arg3606,int arg3607,int arg3608,int arg3609,int arg3610,int arg3611,int arg3612,int arg3613,int arg3614,int arg3615,int arg3616,int arg3617,int arg3618,int arg3619,int arg3620,int arg3621,int arg3622,int arg3623,int arg3624,int arg3625,int arg3626,int arg3627,int arg3628,int arg3629,int arg3630,int arg3631,int arg3632,int arg3633,int arg3634,int arg3635,int arg3636,int arg3637,int arg3638,int arg3639,int arg3640,int arg3641,int arg3642,int arg3643,int arg3644,int arg3645,int arg3646,int arg3647,int arg3648,int arg3649,int arg3650,int arg3651,int arg3652,int arg3653,int arg3654,int arg3655,int arg3656,int arg3657,int arg3658,int arg3659,int arg3660,int arg3661,int arg3662,int arg3663,int arg3664,int arg3665,int arg3666,int arg3667,int arg3668,int arg3669,int arg3670,int arg3671,int arg3672,int arg3673,int arg3674,int arg3675,int arg3676,int arg3677,int arg3678,int arg3679,int arg3680,int arg3681,int arg3682,int arg3683,int arg3684,int arg3685,int arg3686,int arg3687,int arg3688,int arg3689,int arg3690,int arg3691,int arg3692,int arg3693,int arg3694,int arg3695,int arg3696,int arg3697,int arg3698,int arg3699,int arg3700,int arg3701,int arg3702,int arg3703,int arg3704,int arg3705,int arg3706,int arg3707,int arg3708,int arg3709,int arg3710,int arg3711,int arg3712,int arg3713,int arg3714,int arg3715,int arg3716,int arg3717,int arg3718,int arg3719,int arg3720,int arg3721,int arg3722,int arg3723,int arg3724,int arg3725,int arg3726,int arg3727,int arg3728,int arg3729,int arg3730,int arg3731,int arg3732,int arg3733,int arg3734,int arg3735,int arg3736,int arg3737,int arg3738,int arg3739,int arg3740,int arg3741,int arg3742,int arg3743,int arg3744,int arg3745,int arg3746,int arg3747,int arg3748,int arg3749,int arg3750,int arg3751,int arg3752,int arg3753,int arg3754,int arg3755,int arg3756,int arg3757,int arg3758,int arg3759,int arg3760,int arg3761,int arg3762,int arg3763,int arg3764,int arg3765,int arg3766,int arg3767,int arg3768,int arg3769,int arg3770,int arg3771,int arg3772,int arg3773,int arg3774,int arg3775,int arg3776,int arg3777,int arg3778,int arg3779,int arg3780,int arg3781,int arg3782,int arg3783,int arg3784,int arg3785,int arg3786,int arg3787,int arg3788,int arg3789,int arg3790,int arg3791,int arg3792,int arg3793,int arg3794,int arg3795,int arg3796,int arg3797,int arg3798,int arg3799,int arg3800,int arg3801,int arg3802,int arg3803,int arg3804,int arg3805,int arg3806,int arg3807,int arg3808,int arg3809,int arg3810,int arg3811,int arg3812,int arg3813,int arg3814,int arg3815,int arg3816,int arg3817,int arg3818,int arg3819,int arg3820,int arg3821,int arg3822,int arg3823,int arg3824,int arg3825,int arg3826,int arg3827,int arg3828,int arg3829,int arg3830,int arg3831,int arg3832,int arg3833,int arg3834,int arg3835,int arg3836,int arg3837,int arg3838,int arg3839,int arg3840,int arg3841,int arg3842,int arg3843,int arg3844,int arg3845,int arg3846,int arg3847,int arg3848,int arg3849,int arg3850,int arg3851,int arg3852,int arg3853,int arg3854,int arg3855,int arg3856,int arg3857,int arg3858,int arg3859,int arg3860,int arg3861,int arg3862,int arg3863,int arg3864,int arg3865,int arg3866,int arg3867,int arg3868,int arg3869,int arg3870,int arg3871,int arg3872,int arg3873,int arg3874,int arg3875,int arg3876,int arg3877,int arg3878,int arg3879,int arg3880,int arg3881,int arg3882,int arg3883,int arg3884,int arg3885,int arg3886,int arg3887,int arg3888,int arg3889,int arg3890,int arg3891,int arg3892,int arg3893,int arg3894,int arg3895,int arg3896,int arg3897,int arg3898,int arg3899,int arg3900,int arg3901,int arg3902,int arg3903,int arg3904,int arg3905,int arg3906,int arg3907,int arg3908,int arg3909,int arg3910,int arg3911,int arg3912,int arg3913,int arg3914,int arg3915,int arg3916,int arg3917,int arg3918,int arg3919,int arg3920,int arg3921,int arg3922,int arg3923,int arg3924,int arg3925,int arg3926,int arg3927,int arg3928,int arg3929,int arg3930,int arg3931,int arg3932,int arg3933,int arg3934,int arg3935,int arg3936,int arg3937,int arg3938,int arg3939,int arg3940,int arg3941,int arg3942,int arg3943,int arg3944,int arg3945,int arg3946,int arg3947,int arg3948,int arg3949,int arg3950,int arg3951,int arg3952,int arg3953,int arg3954,int arg3955,int arg3956,int arg3957,int arg3958,int arg3959,int arg3960,int arg3961,int arg3962,int arg3963,int arg3964,int arg3965,int arg3966,int arg3967,int arg3968,int arg3969,int arg3970,int arg3971,int arg3972,int arg3973,int arg3974,int arg3975,int arg3976,int arg3977,int arg3978,int arg3979,int arg3980,int arg3981,int arg3982,int arg3983,int arg3984,int arg3985,int arg3986,int arg3987,int arg3988,int arg3989,int arg3990,int arg3991,int arg3992,int arg3993,int arg3994,int arg3995,int arg3996,int arg3997,int arg3998,int arg3999,int arg4000,int arg4001,int arg4002,int arg4003,int arg4004,int arg4005,int arg4006,int arg4007,int arg4008,int arg4009,int arg4010,int arg4011,int arg4012,int arg4013,int arg4014,int arg4015,int arg4016,int arg4017,int arg4018,int arg4019,int arg4020,int arg4021,int arg4022,int arg4023,int arg4024,int arg4025,int arg4026,int arg4027,int arg4028,int arg4029,int arg4030,int arg4031,int arg4032,int arg4033,int arg4034,int arg4035,int arg4036,int arg4037,int arg4038,int arg4039,int arg4040,int arg4041,int arg4042,int arg4043,int arg4044,int arg4045,int arg4046,int arg4047,int arg4048,int arg4049,int arg4050,int arg4051,int arg4052,int arg4053,int arg4054,int arg4055,int arg4056,int arg4057,int arg4058,int arg4059,int arg4060,int arg4061,int arg4062,int arg4063,int arg4064,int arg4065,int arg4066,int arg4067,int arg4068,int arg4069,int arg4070,int arg4071,int arg4072,int arg4073,int arg4074,int arg4075,int arg4076,int arg4077,int arg4078,int arg4079,int arg4080,int arg4081,int arg4082,int arg4083,int arg4084,int arg4085,int arg4086,int arg4087,int arg4088,int arg4089,int arg4090,int arg4091,int arg4092,int arg4093,int arg4094,int arg4095,int arg4096,int arg4097,int arg4098,int arg4099,int arg4100,int arg4101,int arg4102,int arg4103,int arg4104,int arg4105,int arg4106,int arg4107,int arg4108,int arg4109,int arg4110,int arg4111,int arg4112,int arg4113,int arg4114,int arg4115,int arg4116,int arg4117,int arg4118,int arg4119,int arg4120,int arg4121,int arg4122,int arg4123,int arg4124,int arg4125,int arg4126,int arg4127,int arg4128,int arg4129,int arg4130,int arg4131,int arg4132,int arg4133,int arg4134,int arg4135,int arg4136,int arg4137,int arg4138,int arg4139,int arg4140,int arg4141,int arg4142,int arg4143,int arg4144,int arg4145,int arg4146,int arg4147,int arg4148,int arg4149,int arg4150,int arg4151,int arg4152,int arg4153,int arg4154,int arg4155,int arg4156,int arg4157,int arg4158,int arg4159,int arg4160,int arg4161,int arg4162,int arg4163,int arg4164,int arg4165,int arg4166,int arg4167,int arg4168,int arg4169,int arg4170,int arg4171,int arg4172,int arg4173,int arg4174,int arg4175,int arg4176,int arg4177,int arg4178,int arg4179,int arg4180,int arg4181,int arg4182,int arg4183,int arg4184,int arg4185,int arg4186,int arg4187,int arg4188,int arg4189,int arg4190,int arg4191,int arg4192,int arg4193,int arg4194,int arg4195,int arg4196,int arg4197,int arg4198,int arg4199,int arg4200,int arg4201,int arg4202,int arg4203,int arg4204,int arg4205,int arg4206,int arg4207,int arg4208,int arg4209,int arg4210,int arg4211,int arg4212,int arg4213,int arg4214,int arg4215,int arg4216,int arg4217,int arg4218,int arg4219,int arg4220,int arg4221,int arg4222,int arg4223,int arg4224,int arg4225,int arg4226,int arg4227,int arg4228,int arg4229,int arg4230,int arg4231,int arg4232,int arg4233,int arg4234,int arg4235,int arg4236,int arg4237,int arg4238,int arg4239,int arg4240,int arg4241,int arg4242,int arg4243,int arg4244,int arg4245,int arg4246,int arg4247,int arg4248,int arg4249,int arg4250,int arg4251,int arg4252,int arg4253,int arg4254,int arg4255,int arg4256,int arg4257,int arg4258,int arg4259,int arg4260,int arg4261,int arg4262,int arg4263,int arg4264,int arg4265,int arg4266,int arg4267,int arg4268,int arg4269,int arg4270,int arg4271,int arg4272,int arg4273,int arg4274,int arg4275,int arg4276,int arg4277,int arg4278,int arg4279,int arg4280,int arg4281,int arg4282,int arg4283,int arg4284,int arg4285,int arg4286,int arg4287,int arg4288,int arg4289,int arg4290,int arg4291,int arg4292,int arg4293,int arg4294,int arg4295,int arg4296,int arg4297,int arg4298,int arg4299,int arg4300,int arg4301,int arg4302,int arg4303,int arg4304,int arg4305,int arg4306,int arg4307,int arg4308,int arg4309,int arg4310,int arg4311,int arg4312,int arg4313,int arg4314,int arg4315,int arg4316,int arg4317,int arg4318,int arg4319,int arg4320,int arg4321,int arg4322,int arg4323,int arg4324,int arg4325,int arg4326,int arg4327,int arg4328,int arg4329,int arg4330,int arg4331,int arg4332,int arg4333,int arg4334,int arg4335,int arg4336,int arg4337,int arg4338,int arg4339,int arg4340,int arg4341,int arg4342,int arg4343,int arg4344,int arg4345,int arg4346,int arg4347,int arg4348,int arg4349,int arg4350,int arg4351,int arg4352,int arg4353,int arg4354,int arg4355,int arg4356,int arg4357,int arg4358,int arg4359,int arg4360,int arg4361,int arg4362,int arg4363,int arg4364,int arg4365,int arg4366,int arg4367,int arg4368,int arg4369,int arg4370,int arg4371,int arg4372,int arg4373,int arg4374,int arg4375,int arg4376,int arg4377,int arg4378,int arg4379,int arg4380,int arg4381,int arg4382,int arg4383,int arg4384,int arg4385,int arg4386,int arg4387,int arg4388,int arg4389,int arg4390,int arg4391,int arg4392,int arg4393,int arg4394,int arg4395,int arg4396,int arg4397,int arg4398,int arg4399,int arg4400,int arg4401,int arg4402,int arg4403,int arg4404,int arg4405,int arg4406,int arg4407,int arg4408,int arg4409,int arg4410,int arg4411,int arg4412,int arg4413,int arg4414,int arg4415,int arg4416,int arg4417,int arg4418,int arg4419,int arg4420,int arg4421,int arg4422,int arg4423,int arg4424,int arg4425,int arg4426,int arg4427,int arg4428,int arg4429,int arg4430,int arg4431,int arg4432,int arg4433,int arg4434,int arg4435,int arg4436,int arg4437,int arg4438,int arg4439,int arg4440,int arg4441,int arg4442,int arg4443,int arg4444,int arg4445,int arg4446,int arg4447,int arg4448,int arg4449,int arg4450,int arg4451,int arg4452,int arg4453,int arg4454,int arg4455,int arg4456,int arg4457,int arg4458,int arg4459,int arg4460,int arg4461,int arg4462,int arg4463,int arg4464,int arg4465,int arg4466,int arg4467,int arg4468,int arg4469,int arg4470,int arg4471,int arg4472,int arg4473,int arg4474,int arg4475,int arg4476,int arg4477,int arg4478,int arg4479,int arg4480,int arg4481,int arg4482,int arg4483,int arg4484,int arg4485,int arg4486,int arg4487,int arg4488,int arg4489,int arg4490,int arg4491,int arg4492,int arg4493,int arg4494,int arg4495,int arg4496,int arg4497,int arg4498,int arg4499,int arg4500,int arg4501,int arg4502,int arg4503,int arg4504,int arg4505,int arg4506,int arg4507,int arg4508,int arg4509,int arg4510,int arg4511,int arg4512,int arg4513,int arg4514,int arg4515,int arg4516,int arg4517,int arg4518,int arg4519,int arg4520,int arg4521,int arg4522,int arg4523,int arg4524,int arg4525,int arg4526,int arg4527,int arg4528,int arg4529,int arg4530,int arg4531,int arg4532,int arg4533,int arg4534,int arg4535,int arg4536,int arg4537,int arg4538,int arg4539,int arg4540,int arg4541,int arg4542,int arg4543,int arg4544,int arg4545,int arg4546,int arg4547,int arg4548,int arg4549,int arg4550,int arg4551,int arg4552,int arg4553,int arg4554,int arg4555,int arg4556,int arg4557,int arg4558,int arg4559,int arg4560,int arg4561,int arg4562,int arg4563,int arg4564,int arg4565,int arg4566,int arg4567,int arg4568,int arg4569,int arg4570,int arg4571,int arg4572,int arg4573,int arg4574,int arg4575,int arg4576,int arg4577,int arg4578,int arg4579,int arg4580,int arg4581,int arg4582,int arg4583,int arg4584,int arg4585,int arg4586,int arg4587,int arg4588,int arg4589,int arg4590,int arg4591,int arg4592,int arg4593,int arg4594,int arg4595,int arg4596,int arg4597,int arg4598,int arg4599,int arg4600,int arg4601,int arg4602,int arg4603,int arg4604,int arg4605,int arg4606,int arg4607,int arg4608,int arg4609,int arg4610,int arg4611,int arg4612,int arg4613,int arg4614,int arg4615,int arg4616,int arg4617,int arg4618,int arg4619,int arg4620,int arg4621,int arg4622,int arg4623,int arg4624,int arg4625,int arg4626,int arg4627,int arg4628,int arg4629,int arg4630,int arg4631,int arg4632,int arg4633,int arg4634,int arg4635,int arg4636,int arg4637,int arg4638,int arg4639,int arg4640,int arg4641,int arg4642,int arg4643,int arg4644,int arg4645,int arg4646,int arg4647,int arg4648,int arg4649,int arg4650,int arg4651,int arg4652,int arg4653,int arg4654,int arg4655,int arg4656,int arg4657,int arg4658,int arg4659,int arg4660,int arg4661,int arg4662,int arg4663,int arg4664,int arg4665,int arg4666,int arg4667,int arg4668,int arg4669,int arg4670,int arg4671,int arg4672,int arg4673,int arg4674,int arg4675,int arg4676,int arg4677,int arg4678,int arg4679,int arg4680,int arg4681,int arg4682,int arg4683,int arg4684,int arg4685,int arg4686,int arg4687,int arg4688,int arg4689,int arg4690,int arg4691,int arg4692,int arg4693,int arg4694,int arg4695,int arg4696,int arg4697,int arg4698,int arg4699,int arg4700,int arg4701,int arg4702,int arg4703,int arg4704,int arg4705,int arg4706,int arg4707,int arg4708,int arg4709,int arg4710,int arg4711,int arg4712,int arg4713,int arg4714,int arg4715,int arg4716,int arg4717,int arg4718,int arg4719,int arg4720,int arg4721,int arg4722,int arg4723,int arg4724,int arg4725,int arg4726,int arg4727,int arg4728,int arg4729,int arg4730,int arg4731,int arg4732,int arg4733,int arg4734,int arg4735,int arg4736,int arg4737,int arg4738,int arg4739,int arg4740,int arg4741,int arg4742,int arg4743,int arg4744,int arg4745,int arg4746,int arg4747,int arg4748,int arg4749,int arg4750,int arg4751,int arg4752,int arg4753,int arg4754,int arg4755,int arg4756,int arg4757,int arg4758,int arg4759,int arg4760,int arg4761,int arg4762,int arg4763,int arg4764,int arg4765,int arg4766,int arg4767,int arg4768,int arg4769,int arg4770,int arg4771,int arg4772,int arg4773,int arg4774,int arg4775,int arg4776,int arg4777,int arg4778,int arg4779,int arg4780,int arg4781,int arg4782,int arg4783,int arg4784,int arg4785,int arg4786,int arg4787,int arg4788,int arg4789,int arg4790,int arg4791,int arg4792,int arg4793,int arg4794,int arg4795,int arg4796,int arg4797,int arg4798,int arg4799,int arg4800,int arg4801,int arg4802,int arg4803,int arg4804,int arg4805,int arg4806,int arg4807,int arg4808,int arg4809,int arg4810,int arg4811,int arg4812,int arg4813,int arg4814,int arg4815,int arg4816,int arg4817,int arg4818,int arg4819,int arg4820,int arg4821,int arg4822,int arg4823,int arg4824,int arg4825,int arg4826,int arg4827,int arg4828,int arg4829,int arg4830,int arg4831,int arg4832,int arg4833,int arg4834,int arg4835,int arg4836,int arg4837,int arg4838,int arg4839,int arg4840,int arg4841,int arg4842,int arg4843,int arg4844,int arg4845,int arg4846,int arg4847,int arg4848,int arg4849,int arg4850,int arg4851,int arg4852,int arg4853,int arg4854,int arg4855,int arg4856,int arg4857,int arg4858,int arg4859,int arg4860,int arg4861,int arg4862,int arg4863,int arg4864,int arg4865,int arg4866,int arg4867,int arg4868,int arg4869,int arg4870,int arg4871,int arg4872,int arg4873,int arg4874,int arg4875,int arg4876,int arg4877,int arg4878,int arg4879,int arg4880,int arg4881,int arg4882,int arg4883,int arg4884,int arg4885,int arg4886,int arg4887,int arg4888,int arg4889,int arg4890,int arg4891,int arg4892,int arg4893,int arg4894,int arg4895,int arg4896,int arg4897,int arg4898,int arg4899,int arg4900,int arg4901,int arg4902,int arg4903,int arg4904,int arg4905,int arg4906,int arg4907,int arg4908,int arg4909,int arg4910,int arg4911,int arg4912,int arg4913,int arg4914,int arg4915,int arg4916,int arg4917,int arg4918,int arg4919,int arg4920,int arg4921,int arg4922,int arg4923,int arg4924,int arg4925,int arg4926,int arg4927,int arg4928,int arg4929,int arg4930,int arg4931,int arg4932,int arg4933,int arg4934,int arg4935,int arg4936,int arg4937,int arg4938,int arg4939,int arg4940,int arg4941,int arg4942,int arg4943,int arg4944,int arg4945,int arg4946,int arg4947,int arg4948,int arg4949,int arg4950,int arg4951,int arg4952,int arg4953,int arg4954,int arg4955,int arg4956,int arg4957,int arg4958,int arg4959,int arg4960,int arg4961,int arg4962,int arg4963,int arg4964,int arg4965,int arg4966,int arg4967,int arg4968,int arg4969,int arg4970,int arg4971,int arg4972,int arg4973,int arg4974,int arg4975,int arg4976,int arg4977,int arg4978,int arg4979,int arg4980,int arg4981,int arg4982,int arg4983,int arg4984,int arg4985,int arg4986,int arg4987,int arg4988,int arg4989,int arg4990,int arg4991,int arg4992,int arg4993,int arg4994,int arg4995,int arg4996,int arg4997,int arg4998,int arg4999) { return arg0+arg1+arg2+arg3+arg4+arg5+arg6+arg7+arg8+arg9+arg10+arg11+arg12+arg13+arg14+arg15+arg16+arg17+arg18+arg19+arg20+arg21+arg22+arg23+arg24+arg25+arg26+arg27+arg28+arg29+arg30+arg31+arg32+arg33+arg34+arg35+arg36+arg37+arg38+arg39+arg40+arg41+arg42+arg43+arg44+arg45+arg46+arg47+arg48+arg49+arg50+arg51+arg52+arg53+arg54+arg55+arg56+arg57+arg58+arg59+arg60+arg61+arg62+arg63+arg64+arg65+arg66+arg67+arg68+arg69+arg70+arg71+arg72+arg73+arg74+arg75+arg76+arg77+arg78+arg79+arg80+arg81+arg82+arg83+arg84+arg85+arg86+arg87+arg88+arg89+arg90+arg91+arg92+arg93+arg94+arg95+arg96+arg97+arg98+arg99+arg100+arg101+arg102+arg103+arg104+arg105+arg106+arg107+arg108+arg109+arg110+arg111+arg112+arg113+arg114+arg115+arg116+arg117+arg118+arg119+arg120+arg121+arg122+arg123+arg124+arg125+arg126+arg127+arg128+arg129+arg130+arg131+arg132+arg133+arg134+arg135+arg136+arg137+arg138+arg139+arg140+arg141+arg142+arg143+arg144+arg145+arg146+arg147+arg148+arg149+arg150+arg151+arg152+arg153+arg154+arg155+arg156+arg157+arg158+arg159+arg160+arg161+arg162+arg163+arg164+arg165+arg166+arg167+arg168+arg169+arg170+arg171+arg172+arg173+arg174+arg175+arg176+arg177+arg178+arg179+arg180+arg181+arg182+arg183+arg184+arg185+arg186+arg187+arg188+arg189+arg190+arg191+arg192+arg193+arg194+arg195+arg196+arg197+arg198+arg199+arg200+arg201+arg202+arg203+arg204+arg205+arg206+arg207+arg208+arg209+arg210+arg211+arg212+arg213+arg214+arg215+arg216+arg217+arg218+arg219+arg220+arg221+arg222+arg223+arg224+arg225+arg226+arg227+arg228+arg229+arg230+arg231+arg232+arg233+arg234+arg235+arg236+arg237+arg238+arg239+arg240+arg241+arg242+arg243+arg244+arg245+arg246+arg247+arg248+arg249+arg250+arg251+arg252+arg253+arg254+arg255+arg256+arg257+arg258+arg259+arg260+arg261+arg262+arg263+arg264+arg265+arg266+arg267+arg268+arg269+arg270+arg271+arg272+arg273+arg274+arg275+arg276+arg277+arg278+arg279+arg280+arg281+arg282+arg283+arg284+arg285+arg286+arg287+arg288+arg289+arg290+arg291+arg292+arg293+arg294+arg295+arg296+arg297+arg298+arg299+arg300+arg301+arg302+arg303+arg304+arg305+arg306+arg307+arg308+arg309+arg310+arg311+arg312+arg313+arg314+arg315+arg316+arg317+arg318+arg319+arg320+arg321+arg322+arg323+arg324+arg325+arg326+arg327+arg328+arg329+arg330+arg331+arg332+arg333+arg334+arg335+arg336+arg337+arg338+arg339+arg340+arg341+arg342+arg343+arg344+arg345+arg346+arg347+arg348+arg349+arg350+arg351+arg352+arg353+arg354+arg355+arg356+arg357+arg358+arg359+arg360+arg361+arg362+arg363+arg364+arg365+arg366+arg367+arg368+arg369+arg370+arg371+arg372+arg373+arg374+arg375+arg376+arg377+arg378+arg379+arg380+arg381+arg382+arg383+arg384+arg385+arg386+arg387+arg388+arg389+arg390+arg391+arg392+arg393+arg394+arg395+arg396+arg397+arg398+arg399+arg400+arg401+arg402+arg403+arg404+arg405+arg406+arg407+arg408+arg409+arg410+arg411+arg412+arg413+arg414+arg415+arg416+arg417+arg418+arg419+arg420+arg421+arg422+arg423+arg424+arg425+arg426+arg427+arg428+arg429+arg430+arg431+arg432+arg433+arg434+arg435+arg436+arg437+arg438+arg439+arg440+arg441+arg442+arg443+arg444+arg445+arg446+arg447+arg448+arg449+arg450+arg451+arg452+arg453+arg454+arg455+arg456+arg457+arg458+arg459+arg460+arg461+arg462+arg463+arg464+arg465+arg466+arg467+arg468+arg469+arg470+arg471+arg472+arg473+arg474+arg475+arg476+arg477+arg478+arg479+arg480+arg481+arg482+arg483+arg484+arg485+arg486+arg487+arg488+arg489+arg490+arg491+arg492+arg493+arg494+arg495+arg496+arg497+arg498+arg499+arg500+arg501+arg502+arg503+arg504+arg505+arg506+arg507+arg508+arg509+arg510+arg511+arg512+arg513+arg514+arg515+arg516+arg517+arg518+arg519+arg520+arg521+arg522+arg523+arg524+arg525+arg526+arg527+arg528+arg529+arg530+arg531+arg532+arg533+arg534+arg535+arg536+arg537+arg538+arg539+arg540+arg541+arg542+arg543+arg544+arg545+arg546+arg547+arg548+arg549+arg550+arg551+arg552+arg553+arg554+arg555+arg556+arg557+arg558+arg559+arg560+arg561+arg562+arg563+arg564+arg565+arg566+arg567+arg568+arg569+arg570+arg571+arg572+arg573+arg574+arg575+arg576+arg577+arg578+arg579+arg580+arg581+arg582+arg583+arg584+arg585+arg586+arg587+arg588+arg589+arg590+arg591+arg592+arg593+arg594+arg595+arg596+arg597+arg598+arg599+arg600+arg601+arg602+arg603+arg604+arg605+arg606+arg607+arg608+arg609+arg610+arg611+arg612+arg613+arg614+arg615+arg616+arg617+arg618+arg619+arg620+arg621+arg622+arg623+arg624+arg625+arg626+arg627+arg628+arg629+arg630+arg631+arg632+arg633+arg634+arg635+arg636+arg637+arg638+arg639+arg640+arg641+arg642+arg643+arg644+arg645+arg646+arg647+arg648+arg649+arg650+arg651+arg652+arg653+arg654+arg655+arg656+arg657+arg658+arg659+arg660+arg661+arg662+arg663+arg664+arg665+arg666+arg667+arg668+arg669+arg670+arg671+arg672+arg673+arg674+arg675+arg676+arg677+arg678+arg679+arg680+arg681+arg682+arg683+arg684+arg685+arg686+arg687+arg688+arg689+arg690+arg691+arg692+arg693+arg694+arg695+arg696+arg697+arg698+arg699+arg700+arg701+arg702+arg703+arg704+arg705+arg706+arg707+arg708+arg709+arg710+arg711+arg712+arg713+arg714+arg715+arg716+arg717+arg718+arg719+arg720+arg721+arg722+arg723+arg724+arg725+arg726+arg727+arg728+arg729+arg730+arg731+arg732+arg733+arg734+arg735+arg736+arg737+arg738+arg739+arg740+arg741+arg742+arg743+arg744+arg745+arg746+arg747+arg748+arg749+arg750+arg751+arg752+arg753+arg754+arg755+arg756+arg757+arg758+arg759+arg760+arg761+arg762+arg763+arg764+arg765+arg766+arg767+arg768+arg769+arg770+arg771+arg772+arg773+arg774+arg775+arg776+arg777+arg778+arg779+arg780+arg781+arg782+arg783+arg784+arg785+arg786+arg787+arg788+arg789+arg790+arg791+arg792+arg793+arg794+arg795+arg796+arg797+arg798+arg799+arg800+arg801+arg802+arg803+arg804+arg805+arg806+arg807+arg808+arg809+arg810+arg811+arg812+arg813+arg814+arg815+arg816+arg817+arg818+arg819+arg820+arg821+arg822+arg823+arg824+arg825+arg826+arg827+arg828+arg829+arg830+arg831+arg832+arg833+arg834+arg835+arg836+arg837+arg838+arg839+arg840+arg841+arg842+arg843+arg844+arg845+arg846+arg847+arg848+arg849+arg850+arg851+arg852+arg853+arg854+arg855+arg856+arg857+arg858+arg859+arg860+arg861+arg862+arg863+arg864+arg865+arg866+arg867+arg868+arg869+arg870+arg871+arg872+arg873+arg874+arg875+arg876+arg877+arg878+arg879+arg880+arg881+arg882+arg883+arg884+arg885+arg886+arg887+arg888+arg889+arg890+arg891+arg892+arg893+arg894+arg895+arg896+arg897+arg898+arg899+arg900+arg901+arg902+arg903+arg904+arg905+arg906+arg907+arg908+arg909+arg910+arg911+arg912+arg913+arg914+arg915+arg916+arg917+arg918+arg919+arg920+arg921+arg922+arg923+arg924+arg925+arg926+arg927+arg928+arg929+arg930+arg931+arg932+arg933+arg934+arg935+arg936+arg937+arg938+arg939+arg940+arg941+arg942+arg943+arg944+arg945+arg946+arg947+arg948+arg949+arg950+arg951+arg952+arg953+arg954+arg955+arg956+arg957+arg958+arg959+arg960+arg961+arg962+arg963+arg964+arg965+arg966+arg967+arg968+arg969+arg970+arg971+arg972+arg973+arg974+arg975+arg976+arg977+arg978+arg979+arg980+arg981+arg982+arg983+arg984+arg985+arg986+arg987+arg988+arg989+arg990+arg991+arg992+arg993+arg994+arg995+arg996+arg997+arg998+arg999+arg1000+arg1001+arg1002+arg1003+arg1004+arg1005+arg1006+arg1007+arg1008+arg1009+arg1010+arg1011+arg1012+arg1013+arg1014+arg1015+arg1016+arg1017+arg1018+arg1019+arg1020+arg1021+arg1022+arg1023+arg1024+arg1025+arg1026+arg1027+arg1028+arg1029+arg1030+arg1031+arg1032+arg1033+arg1034+arg1035+arg1036+arg1037+arg1038+arg1039+arg1040+arg1041+arg1042+arg1043+arg1044+arg1045+arg1046+arg1047+arg1048+arg1049+arg1050+arg1051+arg1052+arg1053+arg1054+arg1055+arg1056+arg1057+arg1058+arg1059+arg1060+arg1061+arg1062+arg1063+arg1064+arg1065+arg1066+arg1067+arg1068+arg1069+arg1070+arg1071+arg1072+arg1073+arg1074+arg1075+arg1076+arg1077+arg1078+arg1079+arg1080+arg1081+arg1082+arg1083+arg1084+arg1085+arg1086+arg1087+arg1088+arg1089+arg1090+arg1091+arg1092+arg1093+arg1094+arg1095+arg1096+arg1097+arg1098+arg1099+arg1100+arg1101+arg1102+arg1103+arg1104+arg1105+arg1106+arg1107+arg1108+arg1109+arg1110+arg1111+arg1112+arg1113+arg1114+arg1115+arg1116+arg1117+arg1118+arg1119+arg1120+arg1121+arg1122+arg1123+arg1124+arg1125+arg1126+arg1127+arg1128+arg1129+arg1130+arg1131+arg1132+arg1133+arg1134+arg1135+arg1136+arg1137+arg1138+arg1139+arg1140+arg1141+arg1142+arg1143+arg1144+arg1145+arg1146+arg1147+arg1148+arg1149+arg1150+arg1151+arg1152+arg1153+arg1154+arg1155+arg1156+arg1157+arg1158+arg1159+arg1160+arg1161+arg1162+arg1163+arg1164+arg1165+arg1166+arg1167+arg1168+arg1169+arg1170+arg1171+arg1172+arg1173+arg1174+arg1175+arg1176+arg1177+arg1178+arg1179+arg1180+arg1181+arg1182+arg1183+arg1184+arg1185+arg1186+arg1187+arg1188+arg1189+arg1190+arg1191+arg1192+arg1193+arg1194+arg1195+arg1196+arg1197+arg1198+arg1199+arg1200+arg1201+arg1202+arg1203+arg1204+arg1205+arg1206+arg1207+arg1208+arg1209+arg1210+arg1211+arg1212+arg1213+arg1214+arg1215+arg1216+arg1217+arg1218+arg1219+arg1220+arg1221+arg1222+arg1223+arg1224+arg1225+arg1226+arg1227+arg1228+arg1229+arg1230+arg1231+arg1232+arg1233+arg1234+arg1235+arg1236+arg1237+arg1238+arg1239+arg1240+arg1241+arg1242+arg1243+arg1244+arg1245+arg1246+arg1247+arg1248+arg1249+arg1250+arg1251+arg1252+arg1253+arg1254+arg1255+arg1256+arg1257+arg1258+arg1259+arg1260+arg1261+arg1262+arg1263+arg1264+arg1265+arg1266+arg1267+arg1268+arg1269+arg1270+arg1271+arg1272+arg1273+arg1274+arg1275+arg1276+arg1277+arg1278+arg1279+arg1280+arg1281+arg1282+arg1283+arg1284+arg1285+arg1286+arg1287+arg1288+arg1289+arg1290+arg1291+arg1292+arg1293+arg1294+arg1295+arg1296+arg1297+arg1298+arg1299+arg1300+arg1301+arg1302+arg1303+arg1304+arg1305+arg1306+arg1307+arg1308+arg1309+arg1310+arg1311+arg1312+arg1313+arg1314+arg1315+arg1316+arg1317+arg1318+arg1319+arg1320+arg1321+arg1322+arg1323+arg1324+arg1325+arg1326+arg1327+arg1328+arg1329+arg1330+arg1331+arg1332+arg1333+arg1334+arg1335+arg1336+arg1337+arg1338+arg1339+arg1340+arg1341+arg1342+arg1343+arg1344+arg1345+arg1346+arg1347+arg1348+arg1349+arg1350+arg1351+arg1352+arg1353+arg1354+arg1355+arg1356+arg1357+arg1358+arg1359+arg1360+arg1361+arg1362+arg1363+arg1364+arg1365+arg1366+arg1367+arg1368+arg1369+arg1370+arg1371+arg1372+arg1373+arg1374+arg1375+arg1376+arg1377+arg1378+arg1379+arg1380+arg1381+arg1382+arg1383+arg1384+arg1385+arg1386+arg1387+arg1388+arg1389+arg1390+arg1391+arg1392+arg1393+arg1394+arg1395+arg1396+arg1397+arg1398+arg1399+arg1400+arg1401+arg1402+arg1403+arg1404+arg1405+arg1406+arg1407+arg1408+arg1409+arg1410+arg1411+arg1412+arg1413+arg1414+arg1415+arg1416+arg1417+arg1418+arg1419+arg1420+arg1421+arg1422+arg1423+arg1424+arg1425+arg1426+arg1427+arg1428+arg1429+arg1430+arg1431+arg1432+arg1433+arg1434+arg1435+arg1436+arg1437+arg1438+arg1439+arg1440+arg1441+arg1442+arg1443+arg1444+arg1445+arg1446+arg1447+arg1448+arg1449+arg1450+arg1451+arg1452+arg1453+arg1454+arg1455+arg1456+arg1457+arg1458+arg1459+arg1460+arg1461+arg1462+arg1463+arg1464+arg1465+arg1466+arg1467+arg1468+arg1469+arg1470+arg1471+arg1472+arg1473+arg1474+arg1475+arg1476+arg1477+arg1478+arg1479+arg1480+arg1481+arg1482+arg1483+arg1484+arg1485+arg1486+arg1487+arg1488+arg1489+arg1490+arg1491+arg1492+arg1493+arg1494+arg1495+arg1496+arg1497+arg1498+arg1499+arg1500+arg1501+arg1502+arg1503+arg1504+arg1505+arg1506+arg1507+arg1508+arg1509+arg1510+arg1511+arg1512+arg1513+arg1514+arg1515+arg1516+arg1517+arg1518+arg1519+arg1520+arg1521+arg1522+arg1523+arg1524+arg1525+arg1526+arg1527+arg1528+arg1529+arg1530+arg1531+arg1532+arg1533+arg1534+arg1535+arg1536+arg1537+arg1538+arg1539+arg1540+arg1541+arg1542+arg1543+arg1544+arg1545+arg1546+arg1547+arg1548+arg1549+arg1550+arg1551+arg1552+arg1553+arg1554+arg1555+arg1556+arg1557+arg1558+arg1559+arg1560+arg1561+arg1562+arg1563+arg1564+arg1565+arg1566+arg1567+arg1568+arg1569+arg1570+arg1571+arg1572+arg1573+arg1574+arg1575+arg1576+arg1577+arg1578+arg1579+arg1580+arg1581+arg1582+arg1583+arg1584+arg1585+arg1586+arg1587+arg1588+arg1589+arg1590+arg1591+arg1592+arg1593+arg1594+arg1595+arg1596+arg1597+arg1598+arg1599+arg1600+arg1601+arg1602+arg1603+arg1604+arg1605+arg1606+arg1607+arg1608+arg1609+arg1610+arg1611+arg1612+arg1613+arg1614+arg1615+arg1616+arg1617+arg1618+arg1619+arg1620+arg1621+arg1622+arg1623+arg1624+arg1625+arg1626+arg1627+arg1628+arg1629+arg1630+arg1631+arg1632+arg1633+arg1634+arg1635+arg1636+arg1637+arg1638+arg1639+arg1640+arg1641+arg1642+arg1643+arg1644+arg1645+arg1646+arg1647+arg1648+arg1649+arg1650+arg1651+arg1652+arg1653+arg1654+arg1655+arg1656+arg1657+arg1658+arg1659+arg1660+arg1661+arg1662+arg1663+arg1664+arg1665+arg1666+arg1667+arg1668+arg1669+arg1670+arg1671+arg1672+arg1673+arg1674+arg1675+arg1676+arg1677+arg1678+arg1679+arg1680+arg1681+arg1682+arg1683+arg1684+arg1685+arg1686+arg1687+arg1688+arg1689+arg1690+arg1691+arg1692+arg1693+arg1694+arg1695+arg1696+arg1697+arg1698+arg1699+arg1700+arg1701+arg1702+arg1703+arg1704+arg1705+arg1706+arg1707+arg1708+arg1709+arg1710+arg1711+arg1712+arg1713+arg1714+arg1715+arg1716+arg1717+arg1718+arg1719+arg1720+arg1721+arg1722+arg1723+arg1724+arg1725+arg1726+arg1727+arg1728+arg1729+arg1730+arg1731+arg1732+arg1733+arg1734+arg1735+arg1736+arg1737+arg1738+arg1739+arg1740+arg1741+arg1742+arg1743+arg1744+arg1745+arg1746+arg1747+arg1748+arg1749+arg1750+arg1751+arg1752+arg1753+arg1754+arg1755+arg1756+arg1757+arg1758+arg1759+arg1760+arg1761+arg1762+arg1763+arg1764+arg1765+arg1766+arg1767+arg1768+arg1769+arg1770+arg1771+arg1772+arg1773+arg1774+arg1775+arg1776+arg1777+arg1778+arg1779+arg1780+arg1781+arg1782+arg1783+arg1784+arg1785+arg1786+arg1787+arg1788+arg1789+arg1790+arg1791+arg1792+arg1793+arg1794+arg1795+arg1796+arg1797+arg1798+arg1799+arg1800+arg1801+arg1802+arg1803+arg1804+arg1805+arg1806+arg1807+arg1808+arg1809+arg1810+arg1811+arg1812+arg1813+arg1814+arg1815+arg1816+arg1817+arg1818+arg1819+arg1820+arg1821+arg1822+arg1823+arg1824+arg1825+arg1826+arg1827+arg1828+arg1829+arg1830+arg1831+arg1832+arg1833+arg1834+arg1835+arg1836+arg1837+arg1838+arg1839+arg1840+arg1841+arg1842+arg1843+arg1844+arg1845+arg1846+arg1847+arg1848+arg1849+arg1850+arg1851+arg1852+arg1853+arg1854+arg1855+arg1856+arg1857+arg1858+arg1859+arg1860+arg1861+arg1862+arg1863+arg1864+arg1865+arg1866+arg1867+arg1868+arg1869+arg1870+arg1871+arg1872+arg1873+arg1874+arg1875+arg1876+arg1877+arg1878+arg1879+arg1880+arg1881+arg1882+arg1883+arg1884+arg1885+arg1886+arg1887+arg1888+arg1889+arg1890+arg1891+arg1892+arg1893+arg1894+arg1895+arg1896+arg1897+arg1898+arg1899+arg1900+arg1901+arg1902+arg1903+arg1904+arg1905+arg1906+arg1907+arg1908+arg1909+arg1910+arg1911+arg1912+arg1913+arg1914+arg1915+arg1916+arg1917+arg1918+arg1919+arg1920+arg1921+arg1922+arg1923+arg1924+arg1925+arg1926+arg1927+arg1928+arg1929+arg1930+arg1931+arg1932+arg1933+arg1934+arg1935+arg1936+arg1937+arg1938+arg1939+arg1940+arg1941+arg1942+arg1943+arg1944+arg1945+arg1946+arg1947+arg1948+arg1949+arg1950+arg1951+arg1952+arg1953+arg1954+arg1955+arg1956+arg1957+arg1958+arg1959+arg1960+arg1961+arg1962+arg1963+arg1964+arg1965+arg1966+arg1967+arg1968+arg1969+arg1970+arg1971+arg1972+arg1973+arg1974+arg1975+arg1976+arg1977+arg1978+arg1979+arg1980+arg1981+arg1982+arg1983+arg1984+arg1985+arg1986+arg1987+arg1988+arg1989+arg1990+arg1991+arg1992+arg1993+arg1994+arg1995+arg1996+arg1997+arg1998+arg1999+arg2000+arg2001+arg2002+arg2003+arg2004+arg2005+arg2006+arg2007+arg2008+arg2009+arg2010+arg2011+arg2012+arg2013+arg2014+arg2015+arg2016+arg2017+arg2018+arg2019+arg2020+arg2021+arg2022+arg2023+arg2024+arg2025+arg2026+arg2027+arg2028+arg2029+arg2030+arg2031+arg2032+arg2033+arg2034+arg2035+arg2036+arg2037+arg2038+arg2039+arg2040+arg2041+arg2042+arg2043+arg2044+arg2045+arg2046+arg2047+arg2048+arg2049+arg2050+arg2051+arg2052+arg2053+arg2054+arg2055+arg2056+arg2057+arg2058+arg2059+arg2060+arg2061+arg2062+arg2063+arg2064+arg2065+arg2066+arg2067+arg2068+arg2069+arg2070+arg2071+arg2072+arg2073+arg2074+arg2075+arg2076+arg2077+arg2078+arg2079+arg2080+arg2081+arg2082+arg2083+arg2084+arg2085+arg2086+arg2087+arg2088+arg2089+arg2090+arg2091+arg2092+arg2093+arg2094+arg2095+arg2096+arg2097+arg2098+arg2099+arg2100+arg2101+arg2102+arg2103+arg2104+arg2105+arg2106+arg2107+arg2108+arg2109+arg2110+arg2111+arg2112+arg2113+arg2114+arg2115+arg2116+arg2117+arg2118+arg2119+arg2120+arg2121+arg2122+arg2123+arg2124+arg2125+arg2126+arg2127+arg2128+arg2129+arg2130+arg2131+arg2132+arg2133+arg2134+arg2135+arg2136+arg2137+arg2138+arg2139+arg2140+arg2141+arg2142+arg2143+arg2144+arg2145+arg2146+arg2147+arg2148+arg2149+arg2150+arg2151+arg2152+arg2153+arg2154+arg2155+arg2156+arg2157+arg2158+arg2159+arg2160+arg2161+arg2162+arg2163+arg2164+arg2165+arg2166+arg2167+arg2168+arg2169+arg2170+arg2171+arg2172+arg2173+arg2174+arg2175+arg2176+arg2177+arg2178+arg2179+arg2180+arg2181+arg2182+arg2183+arg2184+arg2185+arg2186+arg2187+arg2188+arg2189+arg2190+arg2191+arg2192+arg2193+arg2194+arg2195+arg2196+arg2197+arg2198+arg2199+arg2200+arg2201+arg2202+arg2203+arg2204+arg2205+arg2206+arg2207+arg2208+arg2209+arg2210+arg2211+arg2212+arg2213+arg2214+arg2215+arg2216+arg2217+arg2218+arg2219+arg2220+arg2221+arg2222+arg2223+arg2224+arg2225+arg2226+arg2227+arg2228+arg2229+arg2230+arg2231+arg2232+arg2233+arg2234+arg2235+arg2236+arg2237+arg2238+arg2239+arg2240+arg2241+arg2242+arg2243+arg2244+arg2245+arg2246+arg2247+arg2248+arg2249+arg2250+arg2251+arg2252+arg2253+arg2254+arg2255+arg2256+arg2257+arg2258+arg2259+arg2260+arg2261+arg2262+arg2263+arg2264+arg2265+arg2266+arg2267+arg2268+arg2269+arg2270+arg2271+arg2272+arg2273+arg2274+arg2275+arg2276+arg2277+arg2278+arg2279+arg2280+arg2281+arg2282+arg2283+arg2284+arg2285+arg2286+arg2287+arg2288+arg2289+arg2290+arg2291+arg2292+arg2293+arg2294+arg2295+arg2296+arg2297+arg2298+arg2299+arg2300+arg2301+arg2302+arg2303+arg2304+arg2305+arg2306+arg2307+arg2308+arg2309+arg2310+arg2311+arg2312+arg2313+arg2314+arg2315+arg2316+arg2317+arg2318+arg2319+arg2320+arg2321+arg2322+arg2323+arg2324+arg2325+arg2326+arg2327+arg2328+arg2329+arg2330+arg2331+arg2332+arg2333+arg2334+arg2335+arg2336+arg2337+arg2338+arg2339+arg2340+arg2341+arg2342+arg2343+arg2344+arg2345+arg2346+arg2347+arg2348+arg2349+arg2350+arg2351+arg2352+arg2353+arg2354+arg2355+arg2356+arg2357+arg2358+arg2359+arg2360+arg2361+arg2362+arg2363+arg2364+arg2365+arg2366+arg2367+arg2368+arg2369+arg2370+arg2371+arg2372+arg2373+arg2374+arg2375+arg2376+arg2377+arg2378+arg2379+arg2380+arg2381+arg2382+arg2383+arg2384+arg2385+arg2386+arg2387+arg2388+arg2389+arg2390+arg2391+arg2392+arg2393+arg2394+arg2395+arg2396+arg2397+arg2398+arg2399+arg2400+arg2401+arg2402+arg2403+arg2404+arg2405+arg2406+arg2407+arg2408+arg2409+arg2410+arg2411+arg2412+arg2413+arg2414+arg2415+arg2416+arg2417+arg2418+arg2419+arg2420+arg2421+arg2422+arg2423+arg2424+arg2425+arg2426+arg2427+arg2428+arg2429+arg2430+arg2431+arg2432+arg2433+arg2434+arg2435+arg2436+arg2437+arg2438+arg2439+arg2440+arg2441+arg2442+arg2443+arg2444+arg2445+arg2446+arg2447+arg2448+arg2449+arg2450+arg2451+arg2452+arg2453+arg2454+arg2455+arg2456+arg2457+arg2458+arg2459+arg2460+arg2461+arg2462+arg2463+arg2464+arg2465+arg2466+arg2467+arg2468+arg2469+arg2470+arg2471+arg2472+arg2473+arg2474+arg2475+arg2476+arg2477+arg2478+arg2479+arg2480+arg2481+arg2482+arg2483+arg2484+arg2485+arg2486+arg2487+arg2488+arg2489+arg2490+arg2491+arg2492+arg2493+arg2494+arg2495+arg2496+arg2497+arg2498+arg2499+arg2500+arg2501+arg2502+arg2503+arg2504+arg2505+arg2506+arg2507+arg2508+arg2509+arg2510+arg2511+arg2512+arg2513+arg2514+arg2515+arg2516+arg2517+arg2518+arg2519+arg2520+arg2521+arg2522+arg2523+arg2524+arg2525+arg2526+arg2527+arg2528+arg2529+arg2530+arg2531+arg2532+arg2533+arg2534+arg2535+arg2536+arg2537+arg2538+arg2539+arg2540+arg2541+arg2542+arg2543+arg2544+arg2545+arg2546+arg2547+arg2548+arg2549+arg2550+arg2551+arg2552+arg2553+arg2554+arg2555+arg2556+arg2557+arg2558+arg2559+arg2560+arg2561+arg2562+arg2563+arg2564+arg2565+arg2566+arg2567+arg2568+arg2569+arg2570+arg2571+arg2572+arg2573+arg2574+arg2575+arg2576+arg2577+arg2578+arg2579+arg2580+arg2581+arg2582+arg2583+arg2584+arg2585+arg2586+arg2587+arg2588+arg2589+arg2590+arg2591+arg2592+arg2593+arg2594+arg2595+arg2596+arg2597+arg2598+arg2599+arg2600+arg2601+arg2602+arg2603+arg2604+arg2605+arg2606+arg2607+arg2608+arg2609+arg2610+arg2611+arg2612+arg2613+arg2614+arg2615+arg2616+arg2617+arg2618+arg2619+arg2620+arg2621+arg2622+arg2623+arg2624+arg2625+arg2626+arg2627+arg2628+arg2629+arg2630+arg2631+arg2632+arg2633+arg2634+arg2635+arg2636+arg2637+arg2638+arg2639+arg2640+arg2641+arg2642+arg2643+arg2644+arg2645+arg2646+arg2647+arg2648+arg2649+arg2650+arg2651+arg2652+arg2653+arg2654+arg2655+arg2656+arg2657+arg2658+arg2659+arg2660+arg2661+arg2662+arg2663+arg2664+arg2665+arg2666+arg2667+arg2668+arg2669+arg2670+arg2671+arg2672+arg2673+arg2674+arg2675+arg2676+arg2677+arg2678+arg2679+arg2680+arg2681+arg2682+arg2683+arg2684+arg2685+arg2686+arg2687+arg2688+arg2689+arg2690+arg2691+arg2692+arg2693+arg2694+arg2695+arg2696+arg2697+arg2698+arg2699+arg2700+arg2701+arg2702+arg2703+arg2704+arg2705+arg2706+arg2707+arg2708+arg2709+arg2710+arg2711+arg2712+arg2713+arg2714+arg2715+arg2716+arg2717+arg2718+arg2719+arg2720+arg2721+arg2722+arg2723+arg2724+arg2725+arg2726+arg2727+arg2728+arg2729+arg2730+arg2731+arg2732+arg2733+arg2734+arg2735+arg2736+arg2737+arg2738+arg2739+arg2740+arg2741+arg2742+arg2743+arg2744+arg2745+arg2746+arg2747+arg2748+arg2749+arg2750+arg2751+arg2752+arg2753+arg2754+arg2755+arg2756+arg2757+arg2758+arg2759+arg2760+arg2761+arg2762+arg2763+arg2764+arg2765+arg2766+arg2767+arg2768+arg2769+arg2770+arg2771+arg2772+arg2773+arg2774+arg2775+arg2776+arg2777+arg2778+arg2779+arg2780+arg2781+arg2782+arg2783+arg2784+arg2785+arg2786+arg2787+arg2788+arg2789+arg2790+arg2791+arg2792+arg2793+arg2794+arg2795+arg2796+arg2797+arg2798+arg2799+arg2800+arg2801+arg2802+arg2803+arg2804+arg2805+arg2806+arg2807+arg2808+arg2809+arg2810+arg2811+arg2812+arg2813+arg2814+arg2815+arg2816+arg2817+arg2818+arg2819+arg2820+arg2821+arg2822+arg2823+arg2824+arg2825+arg2826+arg2827+arg2828+arg2829+arg2830+arg2831+arg2832+arg2833+arg2834+arg2835+arg2836+arg2837+arg2838+arg2839+arg2840+arg2841+arg2842+arg2843+arg2844+arg2845+arg2846+arg2847+arg2848+arg2849+arg2850+arg2851+arg2852+arg2853+arg2854+arg2855+arg2856+arg2857+arg2858+arg2859+arg2860+arg2861+arg2862+arg2863+arg2864+arg2865+arg2866+arg2867+arg2868+arg2869+arg2870+arg2871+arg2872+arg2873+arg2874+arg2875+arg2876+arg2877+arg2878+arg2879+arg2880+arg2881+arg2882+arg2883+arg2884+arg2885+arg2886+arg2887+arg2888+arg2889+arg2890+arg2891+arg2892+arg2893+arg2894+arg2895+arg2896+arg2897+arg2898+arg2899+arg2900+arg2901+arg2902+arg2903+arg2904+arg2905+arg2906+arg2907+arg2908+arg2909+arg2910+arg2911+arg2912+arg2913+arg2914+arg2915+arg2916+arg2917+arg2918+arg2919+arg2920+arg2921+arg2922+arg2923+arg2924+arg2925+arg2926+arg2927+arg2928+arg2929+arg2930+arg2931+arg2932+arg2933+arg2934+arg2935+arg2936+arg2937+arg2938+arg2939+arg2940+arg2941+arg2942+arg2943+arg2944+arg2945+arg2946+arg2947+arg2948+arg2949+arg2950+arg2951+arg2952+arg2953+arg2954+arg2955+arg2956+arg2957+arg2958+arg2959+arg2960+arg2961+arg2962+arg2963+arg2964+arg2965+arg2966+arg2967+arg2968+arg2969+arg2970+arg2971+arg2972+arg2973+arg2974+arg2975+arg2976+arg2977+arg2978+arg2979+arg2980+arg2981+arg2982+arg2983+arg2984+arg2985+arg2986+arg2987+arg2988+arg2989+arg2990+arg2991+arg2992+arg2993+arg2994+arg2995+arg2996+arg2997+arg2998+arg2999+arg3000+arg3001+arg3002+arg3003+arg3004+arg3005+arg3006+arg3007+arg3008+arg3009+arg3010+arg3011+arg3012+arg3013+arg3014+arg3015+arg3016+arg3017+arg3018+arg3019+arg3020+arg3021+arg3022+arg3023+arg3024+arg3025+arg3026+arg3027+arg3028+arg3029+arg3030+arg3031+arg3032+arg3033+arg3034+arg3035+arg3036+arg3037+arg3038+arg3039+arg3040+arg3041+arg3042+arg3043+arg3044+arg3045+arg3046+arg3047+arg3048+arg3049+arg3050+arg3051+arg3052+arg3053+arg3054+arg3055+arg3056+arg3057+arg3058+arg3059+arg3060+arg3061+arg3062+arg3063+arg3064+arg3065+arg3066+arg3067+arg3068+arg3069+arg3070+arg3071+arg3072+arg3073+arg3074+arg3075+arg3076+arg3077+arg3078+arg3079+arg3080+arg3081+arg3082+arg3083+arg3084+arg3085+arg3086+arg3087+arg3088+arg3089+arg3090+arg3091+arg3092+arg3093+arg3094+arg3095+arg3096+arg3097+arg3098+arg3099+arg3100+arg3101+arg3102+arg3103+arg3104+arg3105+arg3106+arg3107+arg3108+arg3109+arg3110+arg3111+arg3112+arg3113+arg3114+arg3115+arg3116+arg3117+arg3118+arg3119+arg3120+arg3121+arg3122+arg3123+arg3124+arg3125+arg3126+arg3127+arg3128+arg3129+arg3130+arg3131+arg3132+arg3133+arg3134+arg3135+arg3136+arg3137+arg3138+arg3139+arg3140+arg3141+arg3142+arg3143+arg3144+arg3145+arg3146+arg3147+arg3148+arg3149+arg3150+arg3151+arg3152+arg3153+arg3154+arg3155+arg3156+arg3157+arg3158+arg3159+arg3160+arg3161+arg3162+arg3163+arg3164+arg3165+arg3166+arg3167+arg3168+arg3169+arg3170+arg3171+arg3172+arg3173+arg3174+arg3175+arg3176+arg3177+arg3178+arg3179+arg3180+arg3181+arg3182+arg3183+arg3184+arg3185+arg3186+arg3187+arg3188+arg3189+arg3190+arg3191+arg3192+arg3193+arg3194+arg3195+arg3196+arg3197+arg3198+arg3199+arg3200+arg3201+arg3202+arg3203+arg3204+arg3205+arg3206+arg3207+arg3208+arg3209+arg3210+arg3211+arg3212+arg3213+arg3214+arg3215+arg3216+arg3217+arg3218+arg3219+arg3220+arg3221+arg3222+arg3223+arg3224+arg3225+arg3226+arg3227+arg3228+arg3229+arg3230+arg3231+arg3232+arg3233+arg3234+arg3235+arg3236+arg3237+arg3238+arg3239+arg3240+arg3241+arg3242+arg3243+arg3244+arg3245+arg3246+arg3247+arg3248+arg3249+arg3250+arg3251+arg3252+arg3253+arg3254+arg3255+arg3256+arg3257+arg3258+arg3259+arg3260+arg3261+arg3262+arg3263+arg3264+arg3265+arg3266+arg3267+arg3268+arg3269+arg3270+arg3271+arg3272+arg3273+arg3274+arg3275+arg3276+arg3277+arg3278+arg3279+arg3280+arg3281+arg3282+arg3283+arg3284+arg3285+arg3286+arg3287+arg3288+arg3289+arg3290+arg3291+arg3292+arg3293+arg3294+arg3295+arg3296+arg3297+arg3298+arg3299+arg3300+arg3301+arg3302+arg3303+arg3304+arg3305+arg3306+arg3307+arg3308+arg3309+arg3310+arg3311+arg3312+arg3313+arg3314+arg3315+arg3316+arg3317+arg3318+arg3319+arg3320+arg3321+arg3322+arg3323+arg3324+arg3325+arg3326+arg3327+arg3328+arg3329+arg3330+arg3331+arg3332+arg3333+arg3334+arg3335+arg3336+arg3337+arg3338+arg3339+arg3340+arg3341+arg3342+arg3343+arg3344+arg3345+arg3346+arg3347+arg3348+arg3349+arg3350+arg3351+arg3352+arg3353+arg3354+arg3355+arg3356+arg3357+arg3358+arg3359+arg3360+arg3361+arg3362+arg3363+arg3364+arg3365+arg3366+arg3367+arg3368+arg3369+arg3370+arg3371+arg3372+arg3373+arg3374+arg3375+arg3376+arg3377+arg3378+arg3379+arg3380+arg3381+arg3382+arg3383+arg3384+arg3385+arg3386+arg3387+arg3388+arg3389+arg3390+arg3391+arg3392+arg3393+arg3394+arg3395+arg3396+arg3397+arg3398+arg3399+arg3400+arg3401+arg3402+arg3403+arg3404+arg3405+arg3406+arg3407+arg3408+arg3409+arg3410+arg3411+arg3412+arg3413+arg3414+arg3415+arg3416+arg3417+arg3418+arg3419+arg3420+arg3421+arg3422+arg3423+arg3424+arg3425+arg3426+arg3427+arg3428+arg3429+arg3430+arg3431+arg3432+arg3433+arg3434+arg3435+arg3436+arg3437+arg3438+arg3439+arg3440+arg3441+arg3442+arg3443+arg3444+arg3445+arg3446+arg3447+arg3448+arg3449+arg3450+arg3451+arg3452+arg3453+arg3454+arg3455+arg3456+arg3457+arg3458+arg3459+arg3460+arg3461+arg3462+arg3463+arg3464+arg3465+arg3466+arg3467+arg3468+arg3469+arg3470+arg3471+arg3472+arg3473+arg3474+arg3475+arg3476+arg3477+arg3478+arg3479+arg3480+arg3481+arg3482+arg3483+arg3484+arg3485+arg3486+arg3487+arg3488+arg3489+arg3490+arg3491+arg3492+arg3493+arg3494+arg3495+arg3496+arg3497+arg3498+arg3499+arg3500+arg3501+arg3502+arg3503+arg3504+arg3505+arg3506+arg3507+arg3508+arg3509+arg3510+arg3511+arg3512+arg3513+arg3514+arg3515+arg3516+arg3517+arg3518+arg3519+arg3520+arg3521+arg3522+arg3523+arg3524+arg3525+arg3526+arg3527+arg3528+arg3529+arg3530+arg3531+arg3532+arg3533+arg3534+arg3535+arg3536+arg3537+arg3538+arg3539+arg3540+arg3541+arg3542+arg3543+arg3544+arg3545+arg3546+arg3547+arg3548+arg3549+arg3550+arg3551+arg3552+arg3553+arg3554+arg3555+arg3556+arg3557+arg3558+arg3559+arg3560+arg3561+arg3562+arg3563+arg3564+arg3565+arg3566+arg3567+arg3568+arg3569+arg3570+arg3571+arg3572+arg3573+arg3574+arg3575+arg3576+arg3577+arg3578+arg3579+arg3580+arg3581+arg3582+arg3583+arg3584+arg3585+arg3586+arg3587+arg3588+arg3589+arg3590+arg3591+arg3592+arg3593+arg3594+arg3595+arg3596+arg3597+arg3598+arg3599+arg3600+arg3601+arg3602+arg3603+arg3604+arg3605+arg3606+arg3607+arg3608+arg3609+arg3610+arg3611+arg3612+arg3613+arg3614+arg3615+arg3616+arg3617+arg3618+arg3619+arg3620+arg3621+arg3622+arg3623+arg3624+arg3625+arg3626+arg3627+arg3628+arg3629+arg3630+arg3631+arg3632+arg3633+arg3634+arg3635+arg3636+arg3637+arg3638+arg3639+arg3640+arg3641+arg3642+arg3643+arg3644+arg3645+arg3646+arg3647+arg3648+arg3649+arg3650+arg3651+arg3652+arg3653+arg3654+arg3655+arg3656+arg3657+arg3658+arg3659+arg3660+arg3661+arg3662+arg3663+arg3664+arg3665+arg3666+arg3667+arg3668+arg3669+arg3670+arg3671+arg3672+arg3673+arg3674+arg3675+arg3676+arg3677+arg3678+arg3679+arg3680+arg3681+arg3682+arg3683+arg3684+arg3685+arg3686+arg3687+arg3688+arg3689+arg3690+arg3691+arg3692+arg3693+arg3694+arg3695+arg3696+arg3697+arg3698+arg3699+arg3700+arg3701+arg3702+arg3703+arg3704+arg3705+arg3706+arg3707+arg3708+arg3709+arg3710+arg3711+arg3712+arg3713+arg3714+arg3715+arg3716+arg3717+arg3718+arg3719+arg3720+arg3721+arg3722+arg3723+arg3724+arg3725+arg3726+arg3727+arg3728+arg3729+arg3730+arg3731+arg3732+arg3733+arg3734+arg3735+arg3736+arg3737+arg3738+arg3739+arg3740+arg3741+arg3742+arg3743+arg3744+arg3745+arg3746+arg3747+arg3748+arg3749+arg3750+arg3751+arg3752+arg3753+arg3754+arg3755+arg3756+arg3757+arg3758+arg3759+arg3760+arg3761+arg3762+arg3763+arg3764+arg3765+arg3766+arg3767+arg3768+arg3769+arg3770+arg3771+arg3772+arg3773+arg3774+arg3775+arg3776+arg3777+arg3778+arg3779+arg3780+arg3781+arg3782+arg3783+arg3784+arg3785+arg3786+arg3787+arg3788+arg3789+arg3790+arg3791+arg3792+arg3793+arg3794+arg3795+arg3796+arg3797+arg3798+arg3799+arg3800+arg3801+arg3802+arg3803+arg3804+arg3805+arg3806+arg3807+arg3808+arg3809+arg3810+arg3811+arg3812+arg3813+arg3814+arg3815+arg3816+arg3817+arg3818+arg3819+arg3820+arg3821+arg3822+arg3823+arg3824+arg3825+arg3826+arg3827+arg3828+arg3829+arg3830+arg3831+arg3832+arg3833+arg3834+arg3835+arg3836+arg3837+arg3838+arg3839+arg3840+arg3841+arg3842+arg3843+arg3844+arg3845+arg3846+arg3847+arg3848+arg3849+arg3850+arg3851+arg3852+arg3853+arg3854+arg3855+arg3856+arg3857+arg3858+arg3859+arg3860+arg3861+arg3862+arg3863+arg3864+arg3865+arg3866+arg3867+arg3868+arg3869+arg3870+arg3871+arg3872+arg3873+arg3874+arg3875+arg3876+arg3877+arg3878+arg3879+arg3880+arg3881+arg3882+arg3883+arg3884+arg3885+arg3886+arg3887+arg3888+arg3889+arg3890+arg3891+arg3892+arg3893+arg3894+arg3895+arg3896+arg3897+arg3898+arg3899+arg3900+arg3901+arg3902+arg3903+arg3904+arg3905+arg3906+arg3907+arg3908+arg3909+arg3910+arg3911+arg3912+arg3913+arg3914+arg3915+arg3916+arg3917+arg3918+arg3919+arg3920+arg3921+arg3922+arg3923+arg3924+arg3925+arg3926+arg3927+arg3928+arg3929+arg3930+arg3931+arg3932+arg3933+arg3934+arg3935+arg3936+arg3937+arg3938+arg3939+arg3940+arg3941+arg3942+arg3943+arg3944+arg3945+arg3946+arg3947+arg3948+arg3949+arg3950+arg3951+arg3952+arg3953+arg3954+arg3955+arg3956+arg3957+arg3958+arg3959+arg3960+arg3961+arg3962+arg3963+arg3964+arg3965+arg3966+arg3967+arg3968+arg3969+arg3970+arg3971+arg3972+arg3973+arg3974+arg3975+arg3976+arg3977+arg3978+arg3979+arg3980+arg3981+arg3982+arg3983+arg3984+arg3985+arg3986+arg3987+arg3988+arg3989+arg3990+arg3991+arg3992+arg3993+arg3994+arg3995+arg3996+arg3997+arg3998+arg3999+arg4000+arg4001+arg4002+arg4003+arg4004+arg4005+arg4006+arg4007+arg4008+arg4009+arg4010+arg4011+arg4012+arg4013+arg4014+arg4015+arg4016+arg4017+arg4018+arg4019+arg4020+arg4021+arg4022+arg4023+arg4024+arg4025+arg4026+arg4027+arg4028+arg4029+arg4030+arg4031+arg4032+arg4033+arg4034+arg4035+arg4036+arg4037+arg4038+arg4039+arg4040+arg4041+arg4042+arg4043+arg4044+arg4045+arg4046+arg4047+arg4048+arg4049+arg4050+arg4051+arg4052+arg4053+arg4054+arg4055+arg4056+arg4057+arg4058+arg4059+arg4060+arg4061+arg4062+arg4063+arg4064+arg4065+arg4066+arg4067+arg4068+arg4069+arg4070+arg4071+arg4072+arg4073+arg4074+arg4075+arg4076+arg4077+arg4078+arg4079+arg4080+arg4081+arg4082+arg4083+arg4084+arg4085+arg4086+arg4087+arg4088+arg4089+arg4090+arg4091+arg4092+arg4093+arg4094+arg4095+arg4096+arg4097+arg4098+arg4099+arg4100+arg4101+arg4102+arg4103+arg4104+arg4105+arg4106+arg4107+arg4108+arg4109+arg4110+arg4111+arg4112+arg4113+arg4114+arg4115+arg4116+arg4117+arg4118+arg4119+arg4120+arg4121+arg4122+arg4123+arg4124+arg4125+arg4126+arg4127+arg4128+arg4129+arg4130+arg4131+arg4132+arg4133+arg4134+arg4135+arg4136+arg4137+arg4138+arg4139+arg4140+arg4141+arg4142+arg4143+arg4144+arg4145+arg4146+arg4147+arg4148+arg4149+arg4150+arg4151+arg4152+arg4153+arg4154+arg4155+arg4156+arg4157+arg4158+arg4159+arg4160+arg4161+arg4162+arg4163+arg4164+arg4165+arg4166+arg4167+arg4168+arg4169+arg4170+arg4171+arg4172+arg4173+arg4174+arg4175+arg4176+arg4177+arg4178+arg4179+arg4180+arg4181+arg4182+arg4183+arg4184+arg4185+arg4186+arg4187+arg4188+arg4189+arg4190+arg4191+arg4192+arg4193+arg4194+arg4195+arg4196+arg4197+arg4198+arg4199+arg4200+arg4201+arg4202+arg4203+arg4204+arg4205+arg4206+arg4207+arg4208+arg4209+arg4210+arg4211+arg4212+arg4213+arg4214+arg4215+arg4216+arg4217+arg4218+arg4219+arg4220+arg4221+arg4222+arg4223+arg4224+arg4225+arg4226+arg4227+arg4228+arg4229+arg4230+arg4231+arg4232+arg4233+arg4234+arg4235+arg4236+arg4237+arg4238+arg4239+arg4240+arg4241+arg4242+arg4243+arg4244+arg4245+arg4246+arg4247+arg4248+arg4249+arg4250+arg4251+arg4252+arg4253+arg4254+arg4255+arg4256+arg4257+arg4258+arg4259+arg4260+arg4261+arg4262+arg4263+arg4264+arg4265+arg4266+arg4267+arg4268+arg4269+arg4270+arg4271+arg4272+arg4273+arg4274+arg4275+arg4276+arg4277+arg4278+arg4279+arg4280+arg4281+arg4282+arg4283+arg4284+arg4285+arg4286+arg4287+arg4288+arg4289+arg4290+arg4291+arg4292+arg4293+arg4294+arg4295+arg4296+arg4297+arg4298+arg4299+arg4300+arg4301+arg4302+arg4303+arg4304+arg4305+arg4306+arg4307+arg4308+arg4309+arg4310+arg4311+arg4312+arg4313+arg4314+arg4315+arg4316+arg4317+arg4318+arg4319+arg4320+arg4321+arg4322+arg4323+arg4324+arg4325+arg4326+arg4327+arg4328+arg4329+arg4330+arg4331+arg4332+arg4333+arg4334+arg4335+arg4336+arg4337+arg4338+arg4339+arg4340+arg4341+arg4342+arg4343+arg4344+arg4345+arg4346+arg4347+arg4348+arg4349+arg4350+arg4351+arg4352+arg4353+arg4354+arg4355+arg4356+arg4357+arg4358+arg4359+arg4360+arg4361+arg4362+arg4363+arg4364+arg4365+arg4366+arg4367+arg4368+arg4369+arg4370+arg4371+arg4372+arg4373+arg4374+arg4375+arg4376+arg4377+arg4378+arg4379+arg4380+arg4381+arg4382+arg4383+arg4384+arg4385+arg4386+arg4387+arg4388+arg4389+arg4390+arg4391+arg4392+arg4393+arg4394+arg4395+arg4396+arg4397+arg4398+arg4399+arg4400+arg4401+arg4402+arg4403+arg4404+arg4405+arg4406+arg4407+arg4408+arg4409+arg4410+arg4411+arg4412+arg4413+arg4414+arg4415+arg4416+arg4417+arg4418+arg4419+arg4420+arg4421+arg4422+arg4423+arg4424+arg4425+arg4426+arg4427+arg4428+arg4429+arg4430+arg4431+arg4432+arg4433+arg4434+arg4435+arg4436+arg4437+arg4438+arg4439+arg4440+arg4441+arg4442+arg4443+arg4444+arg4445+arg4446+arg4447+arg4448+arg4449+arg4450+arg4451+arg4452+arg4453+arg4454+arg4455+arg4456+arg4457+arg4458+arg4459+arg4460+arg4461+arg4462+arg4463+arg4464+arg4465+arg4466+arg4467+arg4468+arg4469+arg4470+arg4471+arg4472+arg4473+arg4474+arg4475+arg4476+arg4477+arg4478+arg4479+arg4480+arg4481+arg4482+arg4483+arg4484+arg4485+arg4486+arg4487+arg4488+arg4489+arg4490+arg4491+arg4492+arg4493+arg4494+arg4495+arg4496+arg4497+arg4498+arg4499+arg4500+arg4501+arg4502+arg4503+arg4504+arg4505+arg4506+arg4507+arg4508+arg4509+arg4510+arg4511+arg4512+arg4513+arg4514+arg4515+arg4516+arg4517+arg4518+arg4519+arg4520+arg4521+arg4522+arg4523+arg4524+arg4525+arg4526+arg4527+arg4528+arg4529+arg4530+arg4531+arg4532+arg4533+arg4534+arg4535+arg4536+arg4537+arg4538+arg4539+arg4540+arg4541+arg4542+arg4543+arg4544+arg4545+arg4546+arg4547+arg4548+arg4549+arg4550+arg4551+arg4552+arg4553+arg4554+arg4555+arg4556+arg4557+arg4558+arg4559+arg4560+arg4561+arg4562+arg4563+arg4564+arg4565+arg4566+arg4567+arg4568+arg4569+arg4570+arg4571+arg4572+arg4573+arg4574+arg4575+arg4576+arg4577+arg4578+arg4579+arg4580+arg4581+arg4582+arg4583+arg4584+arg4585+arg4586+arg4587+arg4588+arg4589+arg4590+arg4591+arg4592+arg4593+arg4594+arg4595+arg4596+arg4597+arg4598+arg4599+arg4600+arg4601+arg4602+arg4603+arg4604+arg4605+arg4606+arg4607+arg4608+arg4609+arg4610+arg4611+arg4612+arg4613+arg4614+arg4615+arg4616+arg4617+arg4618+arg4619+arg4620+arg4621+arg4622+arg4623+arg4624+arg4625+arg4626+arg4627+arg4628+arg4629+arg4630+arg4631+arg4632+arg4633+arg4634+arg4635+arg4636+arg4637+arg4638+arg4639+arg4640+arg4641+arg4642+arg4643+arg4644+arg4645+arg4646+arg4647+arg4648+arg4649+arg4650+arg4651+arg4652+arg4653+arg4654+arg4655+arg4656+arg4657+arg4658+arg4659+arg4660+arg4661+arg4662+arg4663+arg4664+arg4665+arg4666+arg4667+arg4668+arg4669+arg4670+arg4671+arg4672+arg4673+arg4674+arg4675+arg4676+arg4677+arg4678+arg4679+arg4680+arg4681+arg4682+arg4683+arg4684+arg4685+arg4686+arg4687+arg4688+arg4689+arg4690+arg4691+arg4692+arg4693+arg4694+arg4695+arg4696+arg4697+arg4698+arg4699+arg4700+arg4701+arg4702+arg4703+arg4704+arg4705+arg4706+arg4707+arg4708+arg4709+arg4710+arg4711+arg4712+arg4713+arg4714+arg4715+arg4716+arg4717+arg4718+arg4719+arg4720+arg4721+arg4722+arg4723+arg4724+arg4725+arg4726+arg4727+arg4728+arg4729+arg4730+arg4731+arg4732+arg4733+arg4734+arg4735+arg4736+arg4737+arg4738+arg4739+arg4740+arg4741+arg4742+arg4743+arg4744+arg4745+arg4746+arg4747+arg4748+arg4749+arg4750+arg4751+arg4752+arg4753+arg4754+arg4755+arg4756+arg4757+arg4758+arg4759+arg4760+arg4761+arg4762+arg4763+arg4764+arg4765+arg4766+arg4767+arg4768+arg4769+arg4770+arg4771+arg4772+arg4773+arg4774+arg4775+arg4776+arg4777+arg4778+arg4779+arg4780+arg4781+arg4782+arg4783+arg4784+arg4785+arg4786+arg4787+arg4788+arg4789+arg4790+arg4791+arg4792+arg4793+arg4794+arg4795+arg4796+arg4797+arg4798+arg4799+arg4800+arg4801+arg4802+arg4803+arg4804+arg4805+arg4806+arg4807+arg4808+arg4809+arg4810+arg4811+arg4812+arg4813+arg4814+arg4815+arg4816+arg4817+arg4818+arg4819+arg4820+arg4821+arg4822+arg4823+arg4824+arg4825+arg4826+arg4827+arg4828+arg4829+arg4830+arg4831+arg4832+arg4833+arg4834+arg4835+arg4836+arg4837+arg4838+arg4839+arg4840+arg4841+arg4842+arg4843+arg4844+arg4845+arg4846+arg4847+arg4848+arg4849+arg4850+arg4851+arg4852+arg4853+arg4854+arg4855+arg4856+arg4857+arg4858+arg4859+arg4860+arg4861+arg4862+arg4863+arg4864+arg4865+arg4866+arg4867+arg4868+arg4869+arg4870+arg4871+arg4872+arg4873+arg4874+arg4875+arg4876+arg4877+arg4878+arg4879+arg4880+arg4881+arg4882+arg4883+arg4884+arg4885+arg4886+arg4887+arg4888+arg4889+arg4890+arg4891+arg4892+arg4893+arg4894+arg4895+arg4896+arg4897+arg4898+arg4899+arg4900+arg4901+arg4902+arg4903+arg4904+arg4905+arg4906+arg4907+arg4908+arg4909+arg4910+arg4911+arg4912+arg4913+arg4914+arg4915+arg4916+arg4917+arg4918+arg4919+arg4920+arg4921+arg4922+arg4923+arg4924+arg4925+arg4926+arg4927+arg4928+arg4929+arg4930+arg4931+arg4932+arg4933+arg4934+arg4935+arg4936+arg4937+arg4938+arg4939+arg4940+arg4941+arg4942+arg4943+arg4944+arg4945+arg4946+arg4947+arg4948+arg4949+arg4950+arg4951+arg4952+arg4953+arg4954+arg4955+arg4956+arg4957+arg4958+arg4959+arg4960+arg4961+arg4962+arg4963+arg4964+arg4965+arg4966+arg4967+arg4968+arg4969+arg4970+arg4971+arg4972+arg4973+arg4974+arg4975+arg4976+arg4977+arg4978+arg4979+arg4980+arg4981+arg4982+arg4983+arg4984+arg4985+arg4986+arg4987+arg4988+arg4989+arg4990+arg4991+arg4992+arg4993+arg4994+arg4995+arg4996+arg4997+arg4998+arg4999;}
10659 void testCallFunctionWithHellaArguments3()
10660 {
10661     Procedure proc;
10662     BasicBlock* root = proc.addBlock();
10663 
10664     Vector&lt;Value*&gt; args;
10665     for (unsigned i = 0; i &lt; 5000; ++i)
10666         args.append(root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 4095 - 5000 + i - 1));
10667 
10668     CCallValue* call = root-&gt;appendNew&lt;CCallValue&gt;(
10669         proc, Int32, Origin(),
10670         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionWithHellaArguments3, B3CCallPtrTag)));
10671     call-&gt;children().appendVector(args);
10672 
10673     root-&gt;appendNewControlValue(proc, Return, Origin(), call);
10674 
10675     std::unique_ptr&lt;Compilation&gt; compilation = compileProc(proc);
10676     CHECK(invoke&lt;int&gt;(*compilation) == invoke&lt;int&gt;(*compilation));
10677     CHECK(invoke&lt;int&gt;(*compilation) == 7967500);
10678     CHECK(invoke&lt;int&gt;(*compilation) == invoke&lt;int&gt;(*compilation));
10679     CHECK(invoke&lt;int&gt;(*compilation) == 7967500);
10680     CHECK(invoke&lt;int&gt;(*compilation) == invoke&lt;int&gt;(*compilation));
10681     CHECK(invoke&lt;int&gt;(*compilation) == 7967500);
10682     CHECK(invoke&lt;int&gt;(*compilation) == invoke&lt;int&gt;(*compilation));
10683     CHECK(invoke&lt;int&gt;(*compilation) == 7967500);
10684 }
10685 
10686 void testReturnDouble(double value)
10687 {
10688     Procedure proc;
10689     BasicBlock* root = proc.addBlock();
10690     root-&gt;appendNewControlValue(
10691         proc, Return, Origin(),
10692         root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), value));
10693 
10694     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc), value));
10695 }
10696 
10697 void testReturnFloat(float value)
10698 {
10699     Procedure proc;
10700     BasicBlock* root = proc.addBlock();
10701     root-&gt;appendNewControlValue(
10702         proc, Return, Origin(),
10703         root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), value));
10704 
10705     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc), value));
10706 }
10707 
10708 double simpleFunctionDouble(double a, double b)
10709 {
10710     return a + b;
10711 }
10712 
10713 void testCallSimpleDouble(double a, double b)
10714 {
10715     Procedure proc;
10716     BasicBlock* root = proc.addBlock();
10717     root-&gt;appendNewControlValue(
10718         proc, Return, Origin(),
10719         root-&gt;appendNew&lt;CCallValue&gt;(
10720             proc, Double, Origin(),
10721             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunctionDouble, B3CCallPtrTag)),
10722             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
10723             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)));
10724 
10725     CHECK(compileAndRun&lt;double&gt;(proc, a, b) == a + b);
10726 }
10727 
10728 float simpleFunctionFloat(float a, float b)
10729 {
10730     return a + b;
10731 }
10732 
10733 void testCallSimpleFloat(float a, float b)
10734 {
10735     Procedure proc;
10736     BasicBlock* root = proc.addBlock();
10737     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
10738         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10739     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
10740         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
10741     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
10742     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
10743     root-&gt;appendNewControlValue(
10744         proc, Return, Origin(),
10745         root-&gt;appendNew&lt;CCallValue&gt;(
10746             proc, Float, Origin(),
10747             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunctionFloat, B3CCallPtrTag)),
10748             floatValue1,
10749             floatValue2));
10750 
10751     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b)), a + b));
10752 }
10753 
10754 double functionWithHellaDoubleArguments(double a, double b, double c, double d, double e, double f, double g, double h, double i, double j, double k, double l, double m, double n, double o, double p, double q, double r, double s, double t, double u, double v, double w, double x, double y, double z)
10755 {
10756     return a * pow(2, 0) + b * pow(2, 1) + c * pow(2, 2) + d * pow(2, 3) + e * pow(2, 4) + f * pow(2, 5) + g * pow(2, 6) + h * pow(2, 7) + i * pow(2, 8) + j * pow(2, 9) + k * pow(2, 10) + l * pow(2, 11) + m * pow(2, 12) + n * pow(2, 13) + o * pow(2, 14) + p * pow(2, 15) + q * pow(2, 16) + r * pow(2, 17) + s * pow(2, 18) + t * pow(2, 19) + u * pow(2, 20) + v * pow(2, 21) + w * pow(2, 22) + x * pow(2, 23) + y * pow(2, 24) + z * pow(2, 25);
10757 }
10758 
10759 void testCallFunctionWithHellaDoubleArguments()
10760 {
10761     Procedure proc;
10762     BasicBlock* root = proc.addBlock();
10763 
10764     Vector&lt;Value*&gt; args;
10765     for (unsigned i = 0; i &lt; 26; ++i)
10766         args.append(root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), i + 1));
10767 
10768     CCallValue* call = root-&gt;appendNew&lt;CCallValue&gt;(
10769         proc, Double, Origin(),
10770         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionWithHellaDoubleArguments, B3CCallPtrTag)));
10771     call-&gt;children().appendVector(args);
10772 
10773     root-&gt;appendNewControlValue(proc, Return, Origin(), call);
10774 
10775     CHECK(compileAndRun&lt;double&gt;(proc) == functionWithHellaDoubleArguments(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26));
10776 }
10777 
10778 float functionWithHellaFloatArguments(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p, float q, float r, float s, float t, float u, float v, float w, float x, float y, float z)
10779 {
10780     return a * pow(2, 0) + b * pow(2, 1) + c * pow(2, 2) + d * pow(2, 3) + e * pow(2, 4) + f * pow(2, 5) + g * pow(2, 6) + h * pow(2, 7) + i * pow(2, 8) + j * pow(2, 9) + k * pow(2, 10) + l * pow(2, 11) + m * pow(2, 12) + n * pow(2, 13) + o * pow(2, 14) + p * pow(2, 15) + q * pow(2, 16) + r * pow(2, 17) + s * pow(2, 18) + t * pow(2, 19) + u * pow(2, 20) + v * pow(2, 21) + w * pow(2, 22) + x * pow(2, 23) + y * pow(2, 24) + z * pow(2, 25);
10781 }
10782 
10783 void testCallFunctionWithHellaFloatArguments()
10784 {
10785     Procedure proc;
10786     BasicBlock* root = proc.addBlock();
10787 
10788     Vector&lt;Value*&gt; args;
10789     for (unsigned i = 0; i &lt; 26; ++i)
10790         args.append(root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), i + 1));
10791 
10792     CCallValue* call = root-&gt;appendNew&lt;CCallValue&gt;(
10793         proc, Float, Origin(),
10794         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionWithHellaFloatArguments, B3CCallPtrTag)));
10795     call-&gt;children().appendVector(args);
10796 
10797     root-&gt;appendNewControlValue(proc, Return, Origin(), call);
10798 
10799     CHECK(compileAndRun&lt;float&gt;(proc) == functionWithHellaFloatArguments(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26));
10800 }
10801 
10802 void testLinearScanWithCalleeOnStack()
10803 {
10804     // This tests proper CCall generation when compiling with a lower optimization
10805     // level and operating with a callee argument that&#39;s spilt on the stack.
10806     // On ARM64, this caused an assert in MacroAssemblerARM64 because of disallowed
10807     // use of the scratch register.
10808     // https://bugs.webkit.org/show_bug.cgi?id=170672
10809 
10810     Procedure proc;
10811     BasicBlock* root = proc.addBlock();
10812 
10813     root-&gt;appendNewControlValue(
10814         proc, Return, Origin(),
10815         root-&gt;appendNew&lt;CCallValue&gt;(
10816             proc, Int32, Origin(),
10817             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(simpleFunction, B3CCallPtrTag)),
10818             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10819             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
10820 
10821     // Force the linear scan algorithm to spill everything.
10822     auto original = Options::airLinearScanSpillsEverything();
10823     Options::airLinearScanSpillsEverything() = true;
10824 
10825     // Compiling with 1 as the optimization level enforces the use of linear scan
10826     // for register allocation.
10827     auto code = compileProc(proc, 1);
10828     CHECK_EQ(invoke&lt;int&gt;(*code, 41, 1), 42);
10829 
10830     Options::airLinearScanSpillsEverything() = original;
10831 }
10832 
10833 void testChillDiv(int num, int den, int res)
10834 {
10835     // Test non-constant.
10836     {
10837         Procedure proc;
10838         BasicBlock* root = proc.addBlock();
10839 
10840         root-&gt;appendNewControlValue(
10841             proc, Return, Origin(),
10842             root-&gt;appendNew&lt;Value&gt;(
10843                 proc, chill(Div), Origin(),
10844                 root-&gt;appendNew&lt;Value&gt;(
10845                     proc, Trunc, Origin(),
10846                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
10847                 root-&gt;appendNew&lt;Value&gt;(
10848                     proc, Trunc, Origin(),
10849                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
10850 
10851         CHECK(compileAndRun&lt;int&gt;(proc, num, den) == res);
10852     }
10853 
10854     // Test constant.
10855     {
10856         Procedure proc;
10857         BasicBlock* root = proc.addBlock();
10858 
10859         root-&gt;appendNewControlValue(
10860             proc, Return, Origin(),
10861             root-&gt;appendNew&lt;Value&gt;(
10862                 proc, chill(Div), Origin(),
10863                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), num),
10864                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), den)));
10865 
10866         CHECK(compileAndRun&lt;int&gt;(proc) == res);
10867     }
10868 }
10869 
10870 void testChillDivTwice(int num1, int den1, int num2, int den2, int res)
10871 {
10872     Procedure proc;
10873     BasicBlock* root = proc.addBlock();
10874 
10875     root-&gt;appendNewControlValue(
10876         proc, Return, Origin(),
10877         root-&gt;appendNew&lt;Value&gt;(
10878             proc, Add, Origin(),
10879             root-&gt;appendNew&lt;Value&gt;(
10880                 proc, chill(Div), Origin(),
10881                 root-&gt;appendNew&lt;Value&gt;(
10882                     proc, Trunc, Origin(),
10883                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
10884                 root-&gt;appendNew&lt;Value&gt;(
10885                     proc, Trunc, Origin(),
10886                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))),
10887             root-&gt;appendNew&lt;Value&gt;(
10888                 proc, chill(Div), Origin(),
10889                 root-&gt;appendNew&lt;Value&gt;(
10890                     proc, Trunc, Origin(),
10891                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)),
10892                 root-&gt;appendNew&lt;Value&gt;(
10893                     proc, Trunc, Origin(),
10894                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)))));
10895 
10896     CHECK(compileAndRun&lt;int&gt;(proc, num1, den1, num2, den2) == res);
10897 }
10898 
10899 void testChillDiv64(int64_t num, int64_t den, int64_t res)
10900 {
10901     if (!is64Bit())
10902         return;
10903 
10904     // Test non-constant.
10905     {
10906         Procedure proc;
10907         BasicBlock* root = proc.addBlock();
10908 
10909         root-&gt;appendNewControlValue(
10910             proc, Return, Origin(),
10911             root-&gt;appendNew&lt;Value&gt;(
10912                 proc, chill(Div), Origin(),
10913                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
10914                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
10915 
10916         CHECK(compileAndRun&lt;int64_t&gt;(proc, num, den) == res);
10917     }
10918 
10919     // Test constant.
10920     {
10921         Procedure proc;
10922         BasicBlock* root = proc.addBlock();
10923 
10924         root-&gt;appendNewControlValue(
10925             proc, Return, Origin(),
10926             root-&gt;appendNew&lt;Value&gt;(
10927                 proc, chill(Div), Origin(),
10928                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), num),
10929                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), den)));
10930 
10931         CHECK(compileAndRun&lt;int64_t&gt;(proc) == res);
10932     }
10933 }
10934 
10935 void testModArg(int64_t value)
10936 {
10937     if (!value)
10938         return;
10939 
10940     Procedure proc;
10941     BasicBlock* root = proc.addBlock();
10942 
10943     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10944     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument, argument);
10945     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
10946 
10947     CHECK(!compileAndRun&lt;int64_t&gt;(proc, value));
10948 }
10949 
10950 void testModArgs(int64_t numerator, int64_t denominator)
10951 {
10952     if (!denominator)
10953         return;
10954     if (numerator == std::numeric_limits&lt;int64_t&gt;::min() &amp;&amp; denominator == -1)
10955         return;
10956 
10957     Procedure proc;
10958     BasicBlock* root = proc.addBlock();
10959 
10960     Value* argument1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
10961     Value* argument2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
10962     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument1, argument2);
10963     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
10964 
10965     CHECK(compileAndRun&lt;int64_t&gt;(proc, numerator, denominator) == numerator % denominator);
10966 }
10967 
10968 void testModImms(int64_t numerator, int64_t denominator)
10969 {
10970     if (!denominator)
10971         return;
10972     if (numerator == std::numeric_limits&lt;int64_t&gt;::min() &amp;&amp; denominator == -1)
10973         return;
10974 
10975     Procedure proc;
10976     BasicBlock* root = proc.addBlock();
10977 
10978     Value* argument1 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), numerator);
10979     Value* argument2 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), denominator);
10980     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument1, argument2);
10981     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
10982 
10983     CHECK(compileAndRun&lt;int64_t&gt;(proc, numerator, denominator) == numerator % denominator);
10984 }
10985 
10986 void testModArg32(int32_t value)
10987 {
10988     if (!value)
10989         return;
10990 
10991     Procedure proc;
10992     BasicBlock* root = proc.addBlock();
10993 
10994     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
10995         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
10996     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument, argument);
10997     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
10998 
10999     CHECK(!compileAndRun&lt;int32_t&gt;(proc, value));
11000 }
11001 
11002 void testModArgs32(int32_t numerator, int32_t denominator)
11003 {
11004     if (!denominator)
11005         return;
11006     if (numerator == std::numeric_limits&lt;int32_t&gt;::min() &amp;&amp; denominator == -1)
11007         return;
11008 
11009     Procedure proc;
11010     BasicBlock* root = proc.addBlock();
11011 
11012     Value* argument1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11013         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11014     Value* argument2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11015         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11016     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument1, argument2);
11017     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11018 
11019     CHECK(compileAndRun&lt;int32_t&gt;(proc, numerator, denominator) == numerator % denominator);
11020 }
11021 
11022 void testModImms32(int32_t numerator, int32_t denominator)
11023 {
11024     if (!denominator)
11025         return;
11026     if (numerator == std::numeric_limits&lt;int32_t&gt;::min() &amp;&amp; denominator == -1)
11027         return;
11028 
11029     Procedure proc;
11030     BasicBlock* root = proc.addBlock();
11031 
11032     Value* argument1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), numerator);
11033     Value* argument2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), denominator);
11034     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Mod, Origin(), argument1, argument2);
11035     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11036 
11037     CHECK(compileAndRun&lt;int32_t&gt;(proc, numerator, denominator) == numerator % denominator);
11038 }
11039 
11040 void testChillModArg(int64_t value)
11041 {
11042     Procedure proc;
11043     BasicBlock* root = proc.addBlock();
11044 
11045     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
11046     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument, argument);
11047     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11048 
11049     CHECK(!compileAndRun&lt;int64_t&gt;(proc, value));
11050 }
11051 
11052 void testChillModArgs(int64_t numerator, int64_t denominator)
11053 {
11054     Procedure proc;
11055     BasicBlock* root = proc.addBlock();
11056 
11057     Value* argument1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
11058     Value* argument2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
11059     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument1, argument2);
11060     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11061 
11062     CHECK(compileAndRun&lt;int64_t&gt;(proc, numerator, denominator) == chillMod(numerator, denominator));
11063 }
11064 
11065 void testChillModImms(int64_t numerator, int64_t denominator)
11066 {
11067     Procedure proc;
11068     BasicBlock* root = proc.addBlock();
11069 
11070     Value* argument1 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), numerator);
11071     Value* argument2 = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), denominator);
11072     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument1, argument2);
11073     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11074 
11075     CHECK(compileAndRun&lt;int64_t&gt;(proc, numerator, denominator) == chillMod(numerator, denominator));
11076 }
11077 
11078 void testChillModArg32(int32_t value)
11079 {
11080     Procedure proc;
11081     BasicBlock* root = proc.addBlock();
11082 
11083     Value* argument = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11084         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11085     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument, argument);
11086     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11087 
11088     CHECK(!compileAndRun&lt;int32_t&gt;(proc, value));
11089 }
11090 
11091 void testChillModArgs32(int32_t numerator, int32_t denominator)
11092 {
11093     Procedure proc;
11094     BasicBlock* root = proc.addBlock();
11095 
11096     Value* argument1 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11097         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11098     Value* argument2 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11099         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11100     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument1, argument2);
11101     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11102 
11103     CHECK(compileAndRun&lt;int32_t&gt;(proc, numerator, denominator) == chillMod(numerator, denominator));
11104 }
11105 
11106 void testChillModImms32(int32_t numerator, int32_t denominator)
11107 {
11108     Procedure proc;
11109     BasicBlock* root = proc.addBlock();
11110 
11111     Value* argument1 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), numerator);
11112     Value* argument2 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), denominator);
11113     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, chill(Mod), Origin(), argument1, argument2);
11114     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11115 
11116     CHECK(compileAndRun&lt;int32_t&gt;(proc, numerator, denominator) == chillMod(numerator, denominator));
11117 }
11118 
11119 void testLoopWithMultipleHeaderEdges()
11120 {
11121     Procedure proc;
11122     BasicBlock* root = proc.addBlock();
11123     BasicBlock* innerHeader = proc.addBlock();
11124     BasicBlock* innerEnd = proc.addBlock();
11125     BasicBlock* outerHeader = proc.addBlock();
11126     BasicBlock* outerEnd = proc.addBlock();
11127     BasicBlock* end = proc.addBlock();
11128 
11129     auto* ne42 = outerHeader-&gt;appendNew&lt;Value&gt;(
11130         proc, NotEqual, Origin(),
11131         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11132         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42));
11133     outerHeader-&gt;appendNewControlValue(
11134         proc, Branch, Origin(),
11135         ne42,
11136         FrequentedBlock(innerHeader), FrequentedBlock(outerEnd));
11137     outerEnd-&gt;appendNewControlValue(
11138         proc, Branch, Origin(),
11139         root-&gt;appendNew&lt;Value&gt;(
11140             proc, Trunc, Origin(),
11141             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
11142         FrequentedBlock(outerHeader), FrequentedBlock(end));
11143 
11144     SwitchValue* switchValue = innerHeader-&gt;appendNew&lt;SwitchValue&gt;(
11145         proc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11146     switchValue-&gt;setFallThrough(FrequentedBlock(innerEnd));
11147     for (unsigned i = 0; i &lt; 20; ++i) {
11148         switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(innerHeader)));
11149     }
11150 
11151     root-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(outerHeader));
11152 
11153     innerEnd-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(outerEnd));
11154     end-&gt;appendNewControlValue(
11155         proc, Return, Origin(),
11156         end-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 5678));
11157 
11158     auto code = compileProc(proc); // This shouldn&#39;t crash in computing NaturalLoops.
11159     CHECK(invoke&lt;int32_t&gt;(*code, 0, 12345) == 5678);
11160 }
11161 
11162 void testSwitch(unsigned degree, unsigned gap = 1)
11163 {
11164     Procedure proc;
11165     BasicBlock* root = proc.addBlock();
11166 
11167     BasicBlock* terminate = proc.addBlock();
11168     terminate-&gt;appendNewControlValue(
11169         proc, Return, Origin(),
11170         terminate-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
11171 
11172     SwitchValue* switchValue = root-&gt;appendNew&lt;SwitchValue&gt;(
11173         proc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11174     switchValue-&gt;setFallThrough(FrequentedBlock(terminate));
11175 
11176     for (unsigned i = 0; i &lt; degree; ++i) {
11177         BasicBlock* newBlock = proc.addBlock();
11178         newBlock-&gt;appendNewControlValue(
11179             proc, Return, Origin(),
11180             newBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(
11181                 proc, Origin(), (i &amp; 1) ? GPRInfo::argumentGPR2 : GPRInfo::argumentGPR1));
11182         switchValue-&gt;appendCase(SwitchCase(gap * i, FrequentedBlock(newBlock)));
11183     }
11184 
11185     auto code = compileProc(proc);
11186 
11187     for (unsigned i = 0; i &lt; degree; ++i) {
11188         CHECK(invoke&lt;int32_t&gt;(*code, i * gap, 42, 11) == ((i &amp; 1) ? 11 : 42));
11189         if (gap &gt; 1) {
11190             CHECK(!invoke&lt;int32_t&gt;(*code, i * gap + 1, 42, 11));
11191             CHECK(!invoke&lt;int32_t&gt;(*code, i * gap - 1, 42, 11));
11192         }
11193     }
11194 
11195     CHECK(!invoke&lt;int32_t&gt;(*code, -1, 42, 11));
11196     CHECK(!invoke&lt;int32_t&gt;(*code, degree * gap, 42, 11));
11197     CHECK(!invoke&lt;int32_t&gt;(*code, degree * gap + 1, 42, 11));
11198 }
11199 
11200 void testSwitchSameCaseAsDefault()
11201 {
11202     Procedure proc;
11203     BasicBlock* root = proc.addBlock();
11204 
11205     BasicBlock* return10 = proc.addBlock();
11206     return10-&gt;appendNewControlValue(
11207         proc, Return, Origin(),
11208         return10-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 10));
11209 
11210     Value* switchOperand = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
11211 
11212     BasicBlock* caseAndDefault = proc.addBlock();
11213     caseAndDefault-&gt;appendNewControlValue(
11214         proc, Return, Origin(),
11215             caseAndDefault-&gt;appendNew&lt;Value&gt;(
11216                 proc, Equal, Origin(),
11217                 switchOperand, caseAndDefault-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)));
11218 
11219     SwitchValue* switchValue = root-&gt;appendNew&lt;SwitchValue&gt;(proc, Origin(), switchOperand);
11220 
11221     switchValue-&gt;appendCase(SwitchCase(100, FrequentedBlock(return10)));
11222 
11223     // Because caseAndDefault is reached both as default case, and when it&#39;s 0,
11224     // we should not incorrectly optimize and assume that switchOperand==0.
11225     switchValue-&gt;appendCase(SwitchCase(0, FrequentedBlock(caseAndDefault)));
11226     switchValue-&gt;setFallThrough(FrequentedBlock(caseAndDefault));
11227 
11228     auto code = compileProc(proc);
11229 
11230     CHECK(invoke&lt;int32_t&gt;(*code, 100) == 10);
11231     CHECK(invoke&lt;int32_t&gt;(*code, 0) == 1);
11232     CHECK(invoke&lt;int32_t&gt;(*code, 1) == 0);
11233     CHECK(invoke&lt;int32_t&gt;(*code, 2) == 0);
11234     CHECK(invoke&lt;int32_t&gt;(*code, 99) == 0);
11235     CHECK(invoke&lt;int32_t&gt;(*code, 0xbaadbeef) == 0);
11236 }
11237 
11238 void testSwitchChillDiv(unsigned degree, unsigned gap = 1)
11239 {
11240     Procedure proc;
11241     BasicBlock* root = proc.addBlock();
11242 
11243     Value* left = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
11244     Value* right = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
11245 
11246     BasicBlock* terminate = proc.addBlock();
11247     terminate-&gt;appendNewControlValue(
11248         proc, Return, Origin(),
11249         terminate-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
11250 
11251     SwitchValue* switchValue = root-&gt;appendNew&lt;SwitchValue&gt;(
11252         proc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11253     switchValue-&gt;setFallThrough(FrequentedBlock(terminate));
11254 
11255     for (unsigned i = 0; i &lt; degree; ++i) {
11256         BasicBlock* newBlock = proc.addBlock();
11257 
11258         newBlock-&gt;appendNewControlValue(
11259             proc, Return, Origin(),
11260             newBlock-&gt;appendNew&lt;Value&gt;(
11261                 proc, chill(Div), Origin(), (i &amp; 1) ? right : left, (i &amp; 1) ? left : right));
11262 
11263         switchValue-&gt;appendCase(SwitchCase(gap * i, FrequentedBlock(newBlock)));
11264     }
11265 
11266     auto code = compileProc(proc);
11267 
11268     for (unsigned i = 0; i &lt; degree; ++i) {
11269         dataLog(&quot;i = &quot;, i, &quot;\n&quot;);
11270         int32_t result = invoke&lt;int32_t&gt;(*code, i * gap, 42, 11);
11271         dataLog(&quot;result = &quot;, result, &quot;\n&quot;);
11272         CHECK(result == ((i &amp; 1) ? 11/42 : 42/11));
11273         if (gap &gt; 1) {
11274             CHECK(!invoke&lt;int32_t&gt;(*code, i * gap + 1, 42, 11));
11275             CHECK(!invoke&lt;int32_t&gt;(*code, i * gap - 1, 42, 11));
11276         }
11277     }
11278 
11279     CHECK(!invoke&lt;int32_t&gt;(*code, -1, 42, 11));
11280     CHECK(!invoke&lt;int32_t&gt;(*code, degree * gap, 42, 11));
11281     CHECK(!invoke&lt;int32_t&gt;(*code, degree * gap + 1, 42, 11));
11282 }
11283 
11284 void testSwitchTargettingSameBlock()
11285 {
11286     Procedure proc;
11287     BasicBlock* root = proc.addBlock();
11288 
11289     BasicBlock* terminate = proc.addBlock();
11290     terminate-&gt;appendNewControlValue(
11291         proc, Return, Origin(),
11292         terminate-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 5));
11293 
11294     SwitchValue* switchValue = root-&gt;appendNew&lt;SwitchValue&gt;(
11295         proc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11296     switchValue-&gt;setFallThrough(FrequentedBlock(terminate));
11297 
11298     BasicBlock* otherTarget = proc.addBlock();
11299     otherTarget-&gt;appendNewControlValue(
11300         proc, Return, Origin(),
11301         otherTarget-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
11302     switchValue-&gt;appendCase(SwitchCase(3, FrequentedBlock(otherTarget)));
11303     switchValue-&gt;appendCase(SwitchCase(13, FrequentedBlock(otherTarget)));
11304 
11305     auto code = compileProc(proc);
11306 
11307     for (unsigned i = 0; i &lt; 20; ++i) {
11308         int32_t expected = (i == 3 || i == 13) ? 42 : 5;
11309         CHECK(invoke&lt;int32_t&gt;(*code, i) == expected);
11310     }
11311 }
11312 
11313 void testSwitchTargettingSameBlockFoldPathConstant()
11314 {
11315     Procedure proc;
11316     BasicBlock* root = proc.addBlock();
11317 
11318     BasicBlock* terminate = proc.addBlock();
11319     terminate-&gt;appendNewControlValue(
11320         proc, Return, Origin(),
11321         terminate-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
11322 
11323     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
11324     SwitchValue* switchValue = root-&gt;appendNew&lt;SwitchValue&gt;(proc, Origin(), argument);
11325     switchValue-&gt;setFallThrough(FrequentedBlock(terminate));
11326 
11327     BasicBlock* otherTarget = proc.addBlock();
11328     otherTarget-&gt;appendNewControlValue(
11329         proc, Return, Origin(), argument);
11330     switchValue-&gt;appendCase(SwitchCase(3, FrequentedBlock(otherTarget)));
11331     switchValue-&gt;appendCase(SwitchCase(13, FrequentedBlock(otherTarget)));
11332 
11333     auto code = compileProc(proc);
11334 
11335     for (unsigned i = 0; i &lt; 20; ++i) {
11336         int32_t expected = (i == 3 || i == 13) ? i : 42;
11337         CHECK(invoke&lt;int32_t&gt;(*code, i) == expected);
11338     }
11339 }
11340 
11341 void testTruncFold(int64_t value)
11342 {
11343     Procedure proc;
11344     BasicBlock* root = proc.addBlock();
11345     root-&gt;appendNewControlValue(
11346         proc, Return, Origin(),
11347         root-&gt;appendNew&lt;Value&gt;(
11348             proc, Trunc, Origin(),
11349             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), value)));
11350 
11351     CHECK(compileAndRun&lt;int&gt;(proc) == static_cast&lt;int&gt;(value));
11352 }
11353 
11354 void testZExt32(int32_t value)
11355 {
11356     Procedure proc;
11357     BasicBlock* root = proc.addBlock();
11358     root-&gt;appendNewControlValue(
11359         proc, Return, Origin(),
11360         root-&gt;appendNew&lt;Value&gt;(
11361             proc, ZExt32, Origin(),
11362             root-&gt;appendNew&lt;Value&gt;(
11363                 proc, Trunc, Origin(),
11364                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
11365 
11366     CHECK(compileAndRun&lt;uint64_t&gt;(proc, value) == static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(value)));
11367 }
11368 
11369 void testZExt32Fold(int32_t value)
11370 {
11371     Procedure proc;
11372     BasicBlock* root = proc.addBlock();
11373     root-&gt;appendNewControlValue(
11374         proc, Return, Origin(),
11375         root-&gt;appendNew&lt;Value&gt;(
11376             proc, ZExt32, Origin(),
11377             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value)));
11378 
11379     CHECK(compileAndRun&lt;uint64_t&gt;(proc, value) == static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(value)));
11380 }
11381 
11382 void testSExt32(int32_t value)
11383 {
11384     Procedure proc;
11385     BasicBlock* root = proc.addBlock();
11386     root-&gt;appendNewControlValue(
11387         proc, Return, Origin(),
11388         root-&gt;appendNew&lt;Value&gt;(
11389             proc, SExt32, Origin(),
11390             root-&gt;appendNew&lt;Value&gt;(
11391                 proc, Trunc, Origin(),
11392                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
11393 
11394     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == static_cast&lt;int64_t&gt;(value));
11395 }
11396 
11397 void testSExt32Fold(int32_t value)
11398 {
11399     Procedure proc;
11400     BasicBlock* root = proc.addBlock();
11401     root-&gt;appendNewControlValue(
11402         proc, Return, Origin(),
11403         root-&gt;appendNew&lt;Value&gt;(
11404             proc, SExt32, Origin(),
11405             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value)));
11406 
11407     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == static_cast&lt;int64_t&gt;(value));
11408 }
11409 
11410 void testTruncZExt32(int32_t value)
11411 {
11412     Procedure proc;
11413     BasicBlock* root = proc.addBlock();
11414     root-&gt;appendNewControlValue(
11415         proc, Return, Origin(),
11416         root-&gt;appendNew&lt;Value&gt;(
11417             proc, Trunc, Origin(),
11418             root-&gt;appendNew&lt;Value&gt;(
11419                 proc, ZExt32, Origin(),
11420                 root-&gt;appendNew&lt;Value&gt;(
11421                     proc, Trunc, Origin(),
11422                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11423 
11424     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == value);
11425 }
11426 
11427 void testTruncSExt32(int32_t value)
11428 {
11429     Procedure proc;
11430     BasicBlock* root = proc.addBlock();
11431     root-&gt;appendNewControlValue(
11432         proc, Return, Origin(),
11433         root-&gt;appendNew&lt;Value&gt;(
11434             proc, Trunc, Origin(),
11435             root-&gt;appendNew&lt;Value&gt;(
11436                 proc, SExt32, Origin(),
11437                 root-&gt;appendNew&lt;Value&gt;(
11438                     proc, Trunc, Origin(),
11439                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11440 
11441     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == value);
11442 }
11443 
11444 void testSExt8(int32_t value)
11445 {
11446     Procedure proc;
11447     BasicBlock* root = proc.addBlock();
11448     root-&gt;appendNewControlValue(
11449         proc, Return, Origin(),
11450         root-&gt;appendNew&lt;Value&gt;(
11451             proc, SExt8, Origin(),
11452             root-&gt;appendNew&lt;Value&gt;(
11453                 proc, Trunc, Origin(),
11454                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
11455 
11456     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)));
11457 }
11458 
11459 void testSExt8Fold(int32_t value)
11460 {
11461     Procedure proc;
11462     BasicBlock* root = proc.addBlock();
11463     root-&gt;appendNewControlValue(
11464         proc, Return, Origin(),
11465         root-&gt;appendNew&lt;Value&gt;(
11466             proc, SExt8, Origin(),
11467             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value)));
11468 
11469     CHECK(compileAndRun&lt;int32_t&gt;(proc) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)));
11470 }
11471 
11472 void testSExt8SExt8(int32_t value)
11473 {
11474     Procedure proc;
11475     BasicBlock* root = proc.addBlock();
11476     root-&gt;appendNewControlValue(
11477         proc, Return, Origin(),
11478         root-&gt;appendNew&lt;Value&gt;(
11479             proc, SExt8, Origin(),
11480             root-&gt;appendNew&lt;Value&gt;(
11481                 proc, SExt8, Origin(),
11482                 root-&gt;appendNew&lt;Value&gt;(
11483                     proc, Trunc, Origin(),
11484                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11485 
11486     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)));
11487 }
11488 
11489 void testSExt8SExt16(int32_t value)
11490 {
11491     Procedure proc;
11492     BasicBlock* root = proc.addBlock();
11493     root-&gt;appendNewControlValue(
11494         proc, Return, Origin(),
11495         root-&gt;appendNew&lt;Value&gt;(
11496             proc, SExt8, Origin(),
11497             root-&gt;appendNew&lt;Value&gt;(
11498                 proc, SExt16, Origin(),
11499                 root-&gt;appendNew&lt;Value&gt;(
11500                     proc, Trunc, Origin(),
11501                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11502 
11503     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)));
11504 }
11505 
11506 void testSExt8BitAnd(int32_t value, int32_t mask)
11507 {
11508     Procedure proc;
11509     BasicBlock* root = proc.addBlock();
11510     root-&gt;appendNewControlValue(
11511         proc, Return, Origin(),
11512         root-&gt;appendNew&lt;Value&gt;(
11513             proc, SExt8, Origin(),
11514             root-&gt;appendNew&lt;Value&gt;(
11515                 proc, BitAnd, Origin(),
11516                 root-&gt;appendNew&lt;Value&gt;(
11517                     proc, Trunc, Origin(),
11518                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
11519                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask))));
11520 
11521     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value &amp; mask)));
11522 }
11523 
11524 void testBitAndSExt8(int32_t value, int32_t mask)
11525 {
11526     Procedure proc;
11527     BasicBlock* root = proc.addBlock();
11528     root-&gt;appendNewControlValue(
11529         proc, Return, Origin(),
11530         root-&gt;appendNew&lt;Value&gt;(
11531             proc, BitAnd, Origin(),
11532             root-&gt;appendNew&lt;Value&gt;(
11533                 proc, SExt8, Origin(),
11534                 root-&gt;appendNew&lt;Value&gt;(
11535                     proc, Trunc, Origin(),
11536                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
11537             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask)));
11538 
11539     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == (static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)) &amp; mask));
11540 }
11541 
11542 void testSExt16(int32_t value)
11543 {
11544     Procedure proc;
11545     BasicBlock* root = proc.addBlock();
11546     root-&gt;appendNewControlValue(
11547         proc, Return, Origin(),
11548         root-&gt;appendNew&lt;Value&gt;(
11549             proc, SExt16, Origin(),
11550             root-&gt;appendNew&lt;Value&gt;(
11551                 proc, Trunc, Origin(),
11552                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
11553 
11554     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int16_t&gt;(value)));
11555 }
11556 
11557 void testSExt16Fold(int32_t value)
11558 {
11559     Procedure proc;
11560     BasicBlock* root = proc.addBlock();
11561     root-&gt;appendNewControlValue(
11562         proc, Return, Origin(),
11563         root-&gt;appendNew&lt;Value&gt;(
11564             proc, SExt16, Origin(),
11565             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), value)));
11566 
11567     CHECK(compileAndRun&lt;int32_t&gt;(proc) == static_cast&lt;int32_t&gt;(static_cast&lt;int16_t&gt;(value)));
11568 }
11569 
11570 void testSExt16SExt16(int32_t value)
11571 {
11572     Procedure proc;
11573     BasicBlock* root = proc.addBlock();
11574     root-&gt;appendNewControlValue(
11575         proc, Return, Origin(),
11576         root-&gt;appendNew&lt;Value&gt;(
11577             proc, SExt16, Origin(),
11578             root-&gt;appendNew&lt;Value&gt;(
11579                 proc, SExt16, Origin(),
11580                 root-&gt;appendNew&lt;Value&gt;(
11581                     proc, Trunc, Origin(),
11582                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11583 
11584     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int16_t&gt;(value)));
11585 }
11586 
11587 void testSExt16SExt8(int32_t value)
11588 {
11589     Procedure proc;
11590     BasicBlock* root = proc.addBlock();
11591     root-&gt;appendNewControlValue(
11592         proc, Return, Origin(),
11593         root-&gt;appendNew&lt;Value&gt;(
11594             proc, SExt16, Origin(),
11595             root-&gt;appendNew&lt;Value&gt;(
11596                 proc, SExt8, Origin(),
11597                 root-&gt;appendNew&lt;Value&gt;(
11598                     proc, Trunc, Origin(),
11599                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)))));
11600 
11601     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int8_t&gt;(value)));
11602 }
11603 
11604 void testSExt16BitAnd(int32_t value, int32_t mask)
11605 {
11606     Procedure proc;
11607     BasicBlock* root = proc.addBlock();
11608     root-&gt;appendNewControlValue(
11609         proc, Return, Origin(),
11610         root-&gt;appendNew&lt;Value&gt;(
11611             proc, SExt16, Origin(),
11612             root-&gt;appendNew&lt;Value&gt;(
11613                 proc, BitAnd, Origin(),
11614                 root-&gt;appendNew&lt;Value&gt;(
11615                     proc, Trunc, Origin(),
11616                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
11617                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask))));
11618 
11619     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;int32_t&gt;(static_cast&lt;int16_t&gt;(value &amp; mask)));
11620 }
11621 
11622 void testBitAndSExt16(int32_t value, int32_t mask)
11623 {
11624     Procedure proc;
11625     BasicBlock* root = proc.addBlock();
11626     root-&gt;appendNewControlValue(
11627         proc, Return, Origin(),
11628         root-&gt;appendNew&lt;Value&gt;(
11629             proc, BitAnd, Origin(),
11630             root-&gt;appendNew&lt;Value&gt;(
11631                 proc, SExt16, Origin(),
11632                 root-&gt;appendNew&lt;Value&gt;(
11633                     proc, Trunc, Origin(),
11634                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
11635             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask)));
11636 
11637     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == (static_cast&lt;int32_t&gt;(static_cast&lt;int16_t&gt;(value)) &amp; mask));
11638 }
11639 
11640 void testSExt32BitAnd(int32_t value, int32_t mask)
11641 {
11642     Procedure proc;
11643     BasicBlock* root = proc.addBlock();
11644     root-&gt;appendNewControlValue(
11645         proc, Return, Origin(),
11646         root-&gt;appendNew&lt;Value&gt;(
11647             proc, SExt32, Origin(),
11648             root-&gt;appendNew&lt;Value&gt;(
11649                 proc, BitAnd, Origin(),
11650                 root-&gt;appendNew&lt;Value&gt;(
11651                     proc, Trunc, Origin(),
11652                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
11653                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), mask))));
11654 
11655     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == static_cast&lt;int64_t&gt;(value &amp; mask));
11656 }
11657 
11658 void testBitAndSExt32(int32_t value, int64_t mask)
11659 {
11660     Procedure proc;
11661     BasicBlock* root = proc.addBlock();
11662     root-&gt;appendNewControlValue(
11663         proc, Return, Origin(),
11664         root-&gt;appendNew&lt;Value&gt;(
11665             proc, BitAnd, Origin(),
11666             root-&gt;appendNew&lt;Value&gt;(
11667                 proc, SExt32, Origin(),
11668                 root-&gt;appendNew&lt;Value&gt;(
11669                     proc, Trunc, Origin(),
11670                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))),
11671             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), mask)));
11672 
11673     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == (static_cast&lt;int64_t&gt;(value) &amp; mask));
11674 }
11675 
11676 void testBasicSelect()
11677 {
11678     Procedure proc;
11679     BasicBlock* root = proc.addBlock();
11680     root-&gt;appendNewControlValue(
11681         proc, Return, Origin(),
11682         root-&gt;appendNew&lt;Value&gt;(
11683             proc, Select, Origin(),
11684             root-&gt;appendNew&lt;Value&gt;(
11685                 proc, Equal, Origin(),
11686                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11687                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)),
11688             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
11689             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
11690 
11691     auto code = compileProc(proc);
11692     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 1, 2) == 1);
11693     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 642462, 32533) == 642462);
11694     CHECK(invoke&lt;intptr_t&gt;(*code, 43, 1, 2) == 2);
11695     CHECK(invoke&lt;intptr_t&gt;(*code, 43, 642462, 32533) == 32533);
11696 }
11697 
11698 void testSelectTest()
11699 {
11700     Procedure proc;
11701     BasicBlock* root = proc.addBlock();
11702     root-&gt;appendNewControlValue(
11703         proc, Return, Origin(),
11704         root-&gt;appendNew&lt;Value&gt;(
11705             proc, Select, Origin(),
11706             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11707             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
11708             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
11709 
11710     auto code = compileProc(proc);
11711     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 1, 2) == 1);
11712     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 642462, 32533) == 642462);
11713     CHECK(invoke&lt;intptr_t&gt;(*code, 0, 1, 2) == 2);
11714     CHECK(invoke&lt;intptr_t&gt;(*code, 0, 642462, 32533) == 32533);
11715 }
11716 
11717 void testSelectCompareDouble()
11718 {
11719     Procedure proc;
11720     BasicBlock* root = proc.addBlock();
11721     root-&gt;appendNewControlValue(
11722         proc, Return, Origin(),
11723         root-&gt;appendNew&lt;Value&gt;(
11724             proc, Select, Origin(),
11725             root-&gt;appendNew&lt;Value&gt;(
11726                 proc, LessThan, Origin(),
11727                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
11728                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)),
11729             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11730             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
11731 
11732     auto code = compileProc(proc);
11733     CHECK(invoke&lt;intptr_t&gt;(*code, -1.0, 1.0, 1, 2) == 1);
11734     CHECK(invoke&lt;intptr_t&gt;(*code, 42.5, 42.51, 642462, 32533) == 642462);
11735     CHECK(invoke&lt;intptr_t&gt;(*code, PNaN, 0.0, 1, 2) == 2);
11736     CHECK(invoke&lt;intptr_t&gt;(*code, 42.51, 42.5, 642462, 32533) == 32533);
11737     CHECK(invoke&lt;intptr_t&gt;(*code, 42.52, 42.52, 524978245, 352) == 352);
11738 }
11739 
11740 template&lt;B3::Opcode opcode&gt;
11741 void testSelectCompareFloat(float a, float b, bool (*operation)(float, float))
11742 {
11743     Procedure proc;
11744     BasicBlock* root = proc.addBlock();
11745     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11746         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11747     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11748         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11749     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
11750     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
11751 
11752     root-&gt;appendNewControlValue(
11753         proc, Return, Origin(),
11754         root-&gt;appendNew&lt;Value&gt;(
11755             proc, Select, Origin(),
11756             root-&gt;appendNew&lt;Value&gt;(
11757                 proc, opcode, Origin(),
11758                 floatValue1,
11759                 floatValue2),
11760             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2),
11761             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
11762     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), 42, -5), operation(a, b) ? 42 : -5));
11763 }
11764 
11765 void testSelectCompareFloat(float a, float b)
11766 {
11767     testSelectCompareFloat&lt;Equal&gt;(a, b, [](float a, float b) -&gt; bool { return a == b; });
11768     testSelectCompareFloat&lt;NotEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a != b; });
11769     testSelectCompareFloat&lt;LessThan&gt;(a, b, [](float a, float b) -&gt; bool { return a &lt; b; });
11770     testSelectCompareFloat&lt;GreaterThan&gt;(a, b, [](float a, float b) -&gt; bool { return a &gt; b; });
11771     testSelectCompareFloat&lt;LessEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a &lt;= b; });
11772     testSelectCompareFloat&lt;GreaterEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a &gt;= b; });
11773     testSelectCompareFloat&lt;EqualOrUnordered&gt;(a, b, [](float a, float b) -&gt; bool { return a != a || b != b || a == b; });
11774 }
11775 
11776 template&lt;B3::Opcode opcode&gt;
11777 void testSelectCompareFloatToDouble(float a, float b, bool (*operation)(float, float))
11778 {
11779     Procedure proc;
11780     BasicBlock* root = proc.addBlock();
11781     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11782         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11783     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11784         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11785     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
11786     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
11787     Value* doubleValue1 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue1);
11788     Value* doubleValue2 = root-&gt;appendNew&lt;Value&gt;(proc, FloatToDouble, Origin(), floatValue2);
11789 
11790     root-&gt;appendNewControlValue(
11791         proc, Return, Origin(),
11792         root-&gt;appendNew&lt;Value&gt;(
11793             proc, Select, Origin(),
11794             root-&gt;appendNew&lt;Value&gt;(
11795                 proc, opcode, Origin(),
11796                 doubleValue1,
11797                 doubleValue2),
11798             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2),
11799             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
11800     CHECK(isIdentical(compileAndRun&lt;int32_t&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), 42, -5), operation(a, b) ? 42 : -5));
11801 }
11802 
11803 void testSelectCompareFloatToDouble(float a, float b)
11804 {
11805     testSelectCompareFloatToDouble&lt;Equal&gt;(a, b, [](float a, float b) -&gt; bool { return a == b; });
11806     testSelectCompareFloatToDouble&lt;NotEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a != b; });
11807     testSelectCompareFloatToDouble&lt;LessThan&gt;(a, b, [](float a, float b) -&gt; bool { return a &lt; b; });
11808     testSelectCompareFloatToDouble&lt;GreaterThan&gt;(a, b, [](float a, float b) -&gt; bool { return a &gt; b; });
11809     testSelectCompareFloatToDouble&lt;LessEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a &lt;= b; });
11810     testSelectCompareFloatToDouble&lt;GreaterEqual&gt;(a, b, [](float a, float b) -&gt; bool { return a &gt;= b; });
11811     testSelectCompareFloatToDouble&lt;EqualOrUnordered&gt;(a, b, [](float a, float b) -&gt; bool { return a != a || b != b || a == b; });
11812 }
11813 
11814 void testSelectDouble()
11815 {
11816     Procedure proc;
11817     BasicBlock* root = proc.addBlock();
11818     root-&gt;appendNewControlValue(
11819         proc, Return, Origin(),
11820         root-&gt;appendNew&lt;Value&gt;(
11821             proc, Select, Origin(),
11822             root-&gt;appendNew&lt;Value&gt;(
11823                 proc, Equal, Origin(),
11824                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11825                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)),
11826             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
11827             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)));
11828 
11829     auto code = compileProc(proc);
11830     CHECK(invoke&lt;double&gt;(*code, 42, 1.5, 2.6) == 1.5);
11831     CHECK(invoke&lt;double&gt;(*code, 42, 642462.7, 32533.8) == 642462.7);
11832     CHECK(invoke&lt;double&gt;(*code, 43, 1.9, 2.0) == 2.0);
11833     CHECK(invoke&lt;double&gt;(*code, 43, 642462.1, 32533.2) == 32533.2);
11834 }
11835 
11836 void testSelectDoubleTest()
11837 {
11838     Procedure proc;
11839     BasicBlock* root = proc.addBlock();
11840     root-&gt;appendNewControlValue(
11841         proc, Return, Origin(),
11842         root-&gt;appendNew&lt;Value&gt;(
11843             proc, Select, Origin(),
11844             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
11845             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
11846             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)));
11847 
11848     auto code = compileProc(proc);
11849     CHECK(invoke&lt;double&gt;(*code, 42, 1.5, 2.6) == 1.5);
11850     CHECK(invoke&lt;double&gt;(*code, 42, 642462.7, 32533.8) == 642462.7);
11851     CHECK(invoke&lt;double&gt;(*code, 0, 1.9, 2.0) == 2.0);
11852     CHECK(invoke&lt;double&gt;(*code, 0, 642462.1, 32533.2) == 32533.2);
11853 }
11854 
11855 void testSelectDoubleCompareDouble()
11856 {
11857     Procedure proc;
11858     BasicBlock* root = proc.addBlock();
11859     root-&gt;appendNewControlValue(
11860         proc, Return, Origin(),
11861         root-&gt;appendNew&lt;Value&gt;(
11862             proc, Select, Origin(),
11863             root-&gt;appendNew&lt;Value&gt;(
11864                 proc, LessThan, Origin(),
11865                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
11866                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)),
11867             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2),
11868             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR3)));
11869 
11870     auto code = compileProc(proc);
11871     CHECK(invoke&lt;double&gt;(*code, -1.0, 1.0, 1.1, 2.2) == 1.1);
11872     CHECK(invoke&lt;double&gt;(*code, 42.5, 42.51, 642462.3, 32533.4) == 642462.3);
11873     CHECK(invoke&lt;double&gt;(*code, PNaN, 0.0, 1.5, 2.6) == 2.6);
11874     CHECK(invoke&lt;double&gt;(*code, 42.51, 42.5, 642462.7, 32533.8) == 32533.8);
11875     CHECK(invoke&lt;double&gt;(*code, 42.52, 42.52, 524978245.9, 352.0) == 352.0);
11876 }
11877 
11878 void testSelectDoubleCompareFloat(float a, float b)
11879 {
11880     Procedure proc;
11881     BasicBlock* root = proc.addBlock();
11882     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11883         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11884     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11885         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11886     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
11887     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
11888 
11889     root-&gt;appendNewControlValue(
11890         proc, Return, Origin(),
11891         root-&gt;appendNew&lt;Value&gt;(
11892             proc, Select, Origin(),
11893             root-&gt;appendNew&lt;Value&gt;(
11894                 proc, LessThan, Origin(),
11895                 floatValue1,
11896                 floatValue2),
11897             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0),
11898             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1)));
11899 
11900     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), 42.1, -M_PI), a &lt; b ? 42.1 : -M_PI));
11901 }
11902 
11903 void testSelectFloatCompareFloat(float a, float b)
11904 {
11905     Procedure proc;
11906     BasicBlock* root = proc.addBlock();
11907     Value* argument1int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11908         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
11909     Value* argument2int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11910         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
11911     Value* argument3int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11912         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
11913     Value* argument4int32 = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
11914         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3));
11915     Value* floatValue1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument1int32);
11916     Value* floatValue2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument2int32);
11917     Value* floatValue3 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument3int32);
11918     Value* floatValue4 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(), argument4int32);
11919 
11920     root-&gt;appendNewControlValue(
11921         proc, Return, Origin(),
11922         root-&gt;appendNew&lt;Value&gt;(
11923             proc, Select, Origin(),
11924             root-&gt;appendNew&lt;Value&gt;(
11925                 proc, LessThan, Origin(),
11926                 floatValue1,
11927                 floatValue2),
11928             floatValue3,
11929             floatValue4));
11930 
11931     CHECK(isIdentical(compileAndRun&lt;float&gt;(proc, bitwise_cast&lt;int32_t&gt;(a), bitwise_cast&lt;int32_t&gt;(b), bitwise_cast&lt;int32_t&gt;(1.1f), bitwise_cast&lt;int32_t&gt;(-42.f)), a &lt; b ? 1.1f : -42.f));
11932 }
11933 
11934 
11935 template&lt;B3::Opcode opcode&gt;
11936 void testSelectDoubleCompareDouble(bool (*operation)(double, double))
11937 {
11938     { // Compare arguments and selected arguments are all different.
11939         Procedure proc;
11940         BasicBlock* root = proc.addBlock();
11941         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
11942         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
11943         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
11944         Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR3);
11945 
11946         root-&gt;appendNewControlValue(
11947             proc, Return, Origin(),
11948             root-&gt;appendNew&lt;Value&gt;(
11949                 proc, Select, Origin(),
11950                 root-&gt;appendNew&lt;Value&gt;(
11951                     proc, opcode, Origin(),
11952                     arg0,
11953                     arg1),
11954                 arg2,
11955                 arg3));
11956         auto code = compileProc(proc);
11957 
11958         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
11959             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
11960                 double expected = operation(left.value, right.value) ? 42.5 : -66.5;
11961                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, -66.5), expected));
11962             }
11963         }
11964     }
11965     { // Compare arguments and selected arguments are all different. &quot;thenCase&quot; is live after operation.
11966         Procedure proc;
11967         BasicBlock* root = proc.addBlock();
11968         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
11969         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
11970         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
11971         Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR3);
11972 
11973         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
11974             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
11975             arg2,
11976             arg3);
11977 
11978         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
11979         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
11980         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
11981 
11982         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
11983         auto code = compileProc(proc);
11984 
11985         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
11986             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
11987                 double expected = operation(left.value, right.value) ? 42.5 : -66.5;
11988                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, -66.5), expected));
11989             }
11990         }
11991     }
11992     { // Compare arguments and selected arguments are all different. &quot;elseCase&quot; is live after operation.
11993         Procedure proc;
11994         BasicBlock* root = proc.addBlock();
11995         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
11996         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
11997         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
11998         Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR3);
11999 
12000         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12001             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12002             arg2,
12003             arg3);
12004 
12005         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12006         keepValuesLive-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
12007         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12008 
12009         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12010         auto code = compileProc(proc);
12011 
12012         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
12013             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
12014                 double expected = operation(left.value, right.value) ? 42.5 : -66.5;
12015                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, -66.5), expected));
12016             }
12017         }
12018     }
12019     { // Compare arguments and selected arguments are all different. Both cases are live after operation.
12020         Procedure proc;
12021         BasicBlock* root = proc.addBlock();
12022         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
12023         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
12024         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
12025         Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR3);
12026 
12027         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12028             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12029             arg2,
12030             arg3);
12031 
12032         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12033         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
12034         keepValuesLive-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
12035         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12036 
12037         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12038         auto code = compileProc(proc);
12039 
12040         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
12041             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
12042                 double expected = operation(left.value, right.value) ? 42.5 : -66.5;
12043                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, -66.5), expected));
12044             }
12045         }
12046     }
12047     { // The left argument is the same as the &quot;elseCase&quot; argument.
12048         Procedure proc;
12049         BasicBlock* root = proc.addBlock();
12050         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
12051         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
12052         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
12053 
12054         root-&gt;appendNewControlValue(
12055             proc, Return, Origin(),
12056             root-&gt;appendNew&lt;Value&gt;(
12057                 proc, Select, Origin(),
12058                 root-&gt;appendNew&lt;Value&gt;(
12059                     proc, opcode, Origin(),
12060                     arg0,
12061                     arg1),
12062                 arg2,
12063                 arg0));
12064         auto code = compileProc(proc);
12065 
12066         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
12067             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
12068                 double expected = operation(left.value, right.value) ? 42.5 : left.value;
12069                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, left.value), expected));
12070             }
12071         }
12072     }
12073     { // The left argument is the same as the &quot;elseCase&quot; argument. &quot;thenCase&quot; is live after operation.
12074         Procedure proc;
12075         BasicBlock* root = proc.addBlock();
12076         Value* arg0 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
12077         Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR1);
12078         Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR2);
12079 
12080         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12081             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12082             arg2,
12083             arg0);
12084 
12085         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12086         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
12087         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12088 
12089         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12090         auto code = compileProc(proc);
12091 
12092         for (auto&amp; left : floatingPointOperands&lt;double&gt;()) {
12093             for (auto&amp; right : floatingPointOperands&lt;double&gt;()) {
12094                 double expected = operation(left.value, right.value) ? 42.5 : left.value;
12095                 CHECK(isIdentical(invoke&lt;double&gt;(*code, left.value, right.value, 42.5, left.value), expected));
12096             }
12097         }
12098     }
12099 }
12100 
12101 void testSelectDoubleCompareDoubleWithAliasing()
12102 {
12103     testSelectDoubleCompareDouble&lt;Equal&gt;([](double a, double b) -&gt; bool { return a == b; });
12104     testSelectDoubleCompareDouble&lt;NotEqual&gt;([](double a, double b) -&gt; bool { return a != b; });
12105     testSelectDoubleCompareDouble&lt;LessThan&gt;([](double a, double b) -&gt; bool { return a &lt; b; });
12106     testSelectDoubleCompareDouble&lt;GreaterThan&gt;([](double a, double b) -&gt; bool { return a &gt; b; });
12107     testSelectDoubleCompareDouble&lt;LessEqual&gt;([](double a, double b) -&gt; bool { return a &lt;= b; });
12108     testSelectDoubleCompareDouble&lt;GreaterEqual&gt;([](double a, double b) -&gt; bool { return a &gt;= b; });
12109     testSelectDoubleCompareDouble&lt;EqualOrUnordered&gt;([](double a, double b) -&gt; bool { return a != a || b != b || a == b; });
12110 }
12111 
12112 template&lt;B3::Opcode opcode&gt;
12113 void testSelectFloatCompareFloat(bool (*operation)(float, float))
12114 {
12115     { // Compare arguments and selected arguments are all different.
12116         Procedure proc;
12117         BasicBlock* root = proc.addBlock();
12118 
12119         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12120             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12121                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12122         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12123             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12124                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12125         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12126             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12127                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12128         Value* arg3 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12129             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12130                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
12131 
12132         root-&gt;appendNewControlValue(
12133             proc, Return, Origin(),
12134             root-&gt;appendNew&lt;Value&gt;(
12135                 proc, Select, Origin(),
12136                 root-&gt;appendNew&lt;Value&gt;(
12137                     proc, opcode, Origin(),
12138                     arg0,
12139                     arg1),
12140                 arg2,
12141                 arg3));
12142         auto code = compileProc(proc);
12143 
12144         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12145             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12146                 float expected = operation(left.value, right.value) ? 42.5 : -66.5;
12147                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(-66.5f)), expected));
12148             }
12149         }
12150     }
12151     { // Compare arguments and selected arguments are all different. &quot;thenCase&quot; is live after operation.
12152         Procedure proc;
12153         BasicBlock* root = proc.addBlock();
12154         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12155             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12156                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12157         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12158             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12159                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12160         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12161             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12162                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12163         Value* arg3 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12164             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12165                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
12166 
12167         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12168             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12169             arg2,
12170             arg3);
12171 
12172         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12173         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
12174         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12175 
12176         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12177         auto code = compileProc(proc);
12178 
12179         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12180             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12181                 float expected = operation(left.value, right.value) ? 42.5 : -66.5;
12182                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(-66.5f)), expected));
12183             }
12184         }
12185     }
12186     { // Compare arguments and selected arguments are all different. &quot;elseCase&quot; is live after operation.
12187         Procedure proc;
12188         BasicBlock* root = proc.addBlock();
12189         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12190             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12191                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12192         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12193             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12194                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12195         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12196             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12197                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12198         Value* arg3 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12199             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12200                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
12201 
12202         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12203             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12204             arg2,
12205             arg3);
12206 
12207         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12208         keepValuesLive-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
12209         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12210 
12211         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12212         auto code = compileProc(proc);
12213 
12214         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12215             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12216                 float expected = operation(left.value, right.value) ? 42.5 : -66.5;
12217                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(-66.5f)), expected));
12218             }
12219         }
12220     }
12221     { // Compare arguments and selected arguments are all different. Both cases are live after operation.
12222         Procedure proc;
12223         BasicBlock* root = proc.addBlock();
12224         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12225             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12226                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12227         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12228             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12229                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12230         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12231             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12232                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12233         Value* arg3 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12234             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12235                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3)));
12236 
12237         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12238             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12239             arg2,
12240             arg3);
12241 
12242         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12243         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
12244         keepValuesLive-&gt;append(ConstrainedValue(arg3, ValueRep::SomeRegister));
12245         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12246 
12247         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12248         auto code = compileProc(proc);
12249 
12250         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12251             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12252                 float expected = operation(left.value, right.value) ? 42.5 : -66.5;
12253                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(-66.5f)), expected));
12254             }
12255         }
12256     }
12257     { // The left argument is the same as the &quot;elseCase&quot; argument.
12258         Procedure proc;
12259         BasicBlock* root = proc.addBlock();
12260         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12261             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12262                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12263         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12264             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12265                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12266         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12267             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12268                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12269 
12270         root-&gt;appendNewControlValue(
12271             proc, Return, Origin(),
12272             root-&gt;appendNew&lt;Value&gt;(
12273                 proc, Select, Origin(),
12274                 root-&gt;appendNew&lt;Value&gt;(
12275                     proc, opcode, Origin(),
12276                     arg0,
12277                     arg1),
12278                 arg2,
12279                 arg0));
12280         auto code = compileProc(proc);
12281 
12282         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12283             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12284                 float expected = operation(left.value, right.value) ? 42.5 : left.value;
12285                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(left.value)), expected));
12286             }
12287         }
12288     }
12289     { // The left argument is the same as the &quot;elseCase&quot; argument. &quot;thenCase&quot; is live after operation.
12290         Procedure proc;
12291         BasicBlock* root = proc.addBlock();
12292         Value* arg0 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12293             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12294                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
12295         Value* arg1 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12296             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12297                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12298         Value* arg2 = root-&gt;appendNew&lt;Value&gt;(proc, BitwiseCast, Origin(),
12299             root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12300                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12301 
12302         Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Select, Origin(),
12303             root-&gt;appendNew&lt;Value&gt;(proc, opcode, Origin(), arg0, arg1),
12304             arg2,
12305             arg0);
12306 
12307         PatchpointValue* keepValuesLive = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
12308         keepValuesLive-&gt;append(ConstrainedValue(arg2, ValueRep::SomeRegister));
12309         keepValuesLive-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
12310 
12311         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
12312         auto code = compileProc(proc);
12313 
12314         for (auto&amp; left : floatingPointOperands&lt;float&gt;()) {
12315             for (auto&amp; right : floatingPointOperands&lt;float&gt;()) {
12316                 float expected = operation(left.value, right.value) ? 42.5 : left.value;
12317                 CHECK(isIdentical(invoke&lt;float&gt;(*code, bitwise_cast&lt;int32_t&gt;(left.value), bitwise_cast&lt;int32_t&gt;(right.value), bitwise_cast&lt;int32_t&gt;(42.5f), bitwise_cast&lt;int32_t&gt;(left.value)), expected));
12318             }
12319         }
12320     }
12321 }
12322 
12323 void testSelectFloatCompareFloatWithAliasing()
12324 {
12325     testSelectFloatCompareFloat&lt;Equal&gt;([](float a, float b) -&gt; bool { return a == b; });
12326     testSelectFloatCompareFloat&lt;NotEqual&gt;([](float a, float b) -&gt; bool { return a != b; });
12327     testSelectFloatCompareFloat&lt;LessThan&gt;([](float a, float b) -&gt; bool { return a &lt; b; });
12328     testSelectFloatCompareFloat&lt;GreaterThan&gt;([](float a, float b) -&gt; bool { return a &gt; b; });
12329     testSelectFloatCompareFloat&lt;LessEqual&gt;([](float a, float b) -&gt; bool { return a &lt;= b; });
12330     testSelectFloatCompareFloat&lt;GreaterEqual&gt;([](float a, float b) -&gt; bool { return a &gt;= b; });
12331     testSelectFloatCompareFloat&lt;EqualOrUnordered&gt;([](float a, float b) -&gt; bool { return a != a || b != b || a == b; });
12332 }
12333 
12334 void testSelectFold(intptr_t value)
12335 {
12336     Procedure proc;
12337     BasicBlock* root = proc.addBlock();
12338     root-&gt;appendNewControlValue(
12339         proc, Return, Origin(),
12340         root-&gt;appendNew&lt;Value&gt;(
12341             proc, Select, Origin(),
12342             root-&gt;appendNew&lt;Value&gt;(
12343                 proc, Equal, Origin(),
12344                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), value),
12345                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)),
12346             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12347             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
12348 
12349     auto code = compileProc(proc);
12350     CHECK(invoke&lt;intptr_t&gt;(*code, 1, 2) == (value == 42 ? 1 : 2));
12351     CHECK(invoke&lt;intptr_t&gt;(*code, 642462, 32533) == (value == 42 ? 642462 : 32533));
12352 }
12353 
12354 void testSelectInvert()
12355 {
12356     Procedure proc;
12357     BasicBlock* root = proc.addBlock();
12358     root-&gt;appendNewControlValue(
12359         proc, Return, Origin(),
12360         root-&gt;appendNew&lt;Value&gt;(
12361             proc, Select, Origin(),
12362             root-&gt;appendNew&lt;Value&gt;(
12363                 proc, Equal, Origin(),
12364                 root-&gt;appendNew&lt;Value&gt;(
12365                     proc, NotEqual, Origin(),
12366                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12367                     root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)),
12368                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)),
12369             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
12370             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2)));
12371 
12372     auto code = compileProc(proc);
12373     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 1, 2) == 1);
12374     CHECK(invoke&lt;intptr_t&gt;(*code, 42, 642462, 32533) == 642462);
12375     CHECK(invoke&lt;intptr_t&gt;(*code, 43, 1, 2) == 2);
12376     CHECK(invoke&lt;intptr_t&gt;(*code, 43, 642462, 32533) == 32533);
12377 }
12378 
12379 void testCheckSelect()
12380 {
12381     Procedure proc;
12382     BasicBlock* root = proc.addBlock();
12383 
12384     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
12385         proc, Check, Origin(),
12386         root-&gt;appendNew&lt;Value&gt;(
12387             proc, Add, Origin(),
12388             root-&gt;appendNew&lt;Value&gt;(
12389                 proc, Select, Origin(),
12390                 root-&gt;appendNew&lt;Value&gt;(
12391                     proc, BitAnd, Origin(),
12392                     root-&gt;appendNew&lt;Value&gt;(
12393                         proc, Trunc, Origin(),
12394                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(
12395                             proc, Origin(), GPRInfo::argumentGPR0)),
12396                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0xff)),
12397                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), -42),
12398                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 35)),
12399             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)));
12400     unsigned generationCount = 0;
12401     check-&gt;setGenerator(
12402         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
12403             AllowMacroScratchRegisterUsage allowScratch(jit);
12404 
12405             generationCount++;
12406             jit.move(CCallHelpers::TrustedImm32(666), GPRInfo::returnValueGPR);
12407             jit.emitFunctionEpilogue();
12408             jit.ret();
12409         });
12410 
12411     root-&gt;appendNewControlValue(
12412         proc, Return, Origin(),
12413         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
12414 
12415     auto code = compileProc(proc);
12416     CHECK(generationCount == 1);
12417     CHECK(invoke&lt;int&gt;(*code, true) == 0);
12418     CHECK(invoke&lt;int&gt;(*code, false) == 666);
12419 }
12420 
12421 void testCheckSelectCheckSelect()
12422 {
12423     Procedure proc;
12424     BasicBlock* root = proc.addBlock();
12425 
12426     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(
12427         proc, Check, Origin(),
12428         root-&gt;appendNew&lt;Value&gt;(
12429             proc, Add, Origin(),
12430             root-&gt;appendNew&lt;Value&gt;(
12431                 proc, Select, Origin(),
12432                 root-&gt;appendNew&lt;Value&gt;(
12433                     proc, BitAnd, Origin(),
12434                     root-&gt;appendNew&lt;Value&gt;(
12435                         proc, Trunc, Origin(),
12436                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(
12437                             proc, Origin(), GPRInfo::argumentGPR0)),
12438                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0xff)),
12439                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), -42),
12440                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 35)),
12441             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42)));
12442 
12443     unsigned generationCount = 0;
12444     check-&gt;setGenerator(
12445         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
12446             AllowMacroScratchRegisterUsage allowScratch(jit);
12447 
12448             generationCount++;
12449             jit.move(CCallHelpers::TrustedImm32(666), GPRInfo::returnValueGPR);
12450             jit.emitFunctionEpilogue();
12451             jit.ret();
12452         });
12453 
12454     CheckValue* check2 = root-&gt;appendNew&lt;CheckValue&gt;(
12455         proc, Check, Origin(),
12456         root-&gt;appendNew&lt;Value&gt;(
12457             proc, Add, Origin(),
12458             root-&gt;appendNew&lt;Value&gt;(
12459                 proc, Select, Origin(),
12460                 root-&gt;appendNew&lt;Value&gt;(
12461                     proc, BitAnd, Origin(),
12462                     root-&gt;appendNew&lt;Value&gt;(
12463                         proc, Trunc, Origin(),
12464                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(
12465                             proc, Origin(), GPRInfo::argumentGPR1)),
12466                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0xff)),
12467                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), -43),
12468                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 36)),
12469             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 43)));
12470 
12471     unsigned generationCount2 = 0;
12472     check2-&gt;setGenerator(
12473         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
12474             AllowMacroScratchRegisterUsage allowScratch(jit);
12475 
12476             generationCount2++;
12477             jit.move(CCallHelpers::TrustedImm32(667), GPRInfo::returnValueGPR);
12478             jit.emitFunctionEpilogue();
12479             jit.ret();
12480         });
12481 
12482     root-&gt;appendNewControlValue(
12483         proc, Return, Origin(),
12484         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
12485 
12486     auto code = compileProc(proc);
12487     CHECK(generationCount == 1);
12488     CHECK(generationCount2 == 1);
12489     CHECK(invoke&lt;int&gt;(*code, true, true) == 0);
12490     CHECK(invoke&lt;int&gt;(*code, false, true) == 666);
12491     CHECK(invoke&lt;int&gt;(*code, true, false) == 667);
12492 }
12493 
12494 void testCheckSelectAndCSE()
12495 {
12496     Procedure proc;
12497     BasicBlock* root = proc.addBlock();
12498 
12499     auto* selectValue = root-&gt;appendNew&lt;Value&gt;(
12500         proc, Select, Origin(),
12501         root-&gt;appendNew&lt;Value&gt;(
12502             proc, BitAnd, Origin(),
12503             root-&gt;appendNew&lt;Value&gt;(
12504                 proc, Trunc, Origin(),
12505                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(
12506                     proc, Origin(), GPRInfo::argumentGPR0)),
12507             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0xff)),
12508         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), -42),
12509         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 35));
12510 
12511     auto* constant = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42);
12512     auto* addValue = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), selectValue, constant);
12513 
12514     CheckValue* check = root-&gt;appendNew&lt;CheckValue&gt;(proc, Check, Origin(), addValue);
12515     unsigned generationCount = 0;
12516     check-&gt;setGenerator(
12517         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
12518             AllowMacroScratchRegisterUsage allowScratch(jit);
12519 
12520             generationCount++;
12521             jit.move(CCallHelpers::TrustedImm32(666), GPRInfo::returnValueGPR);
12522             jit.emitFunctionEpilogue();
12523             jit.ret();
12524         });
12525 
12526     auto* addValue2 = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), selectValue, constant);
12527 
12528     root-&gt;appendNewControlValue(
12529         proc, Return, Origin(),
12530         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), addValue, addValue2));
12531 
12532     auto code = compileProc(proc);
12533     CHECK(generationCount == 1);
12534     CHECK(invoke&lt;int&gt;(*code, true) == 0);
12535     CHECK(invoke&lt;int&gt;(*code, false) == 666);
12536 }
12537 
12538 double b3Pow(double x, int y)
12539 {
12540     if (y &lt; 0 || y &gt; 1000)
12541         return pow(x, y);
12542     double result = 1;
12543     while (y) {
12544         if (y &amp; 1)
12545             result *= x;
12546         x *= x;
12547         y &gt;&gt;= 1;
12548     }
12549     return result;
12550 }
12551 
12552 void testPowDoubleByIntegerLoop(double xOperand, int32_t yOperand)
12553 {
12554     Procedure proc;
12555     BasicBlock* root = proc.addBlock();
12556 
12557     Value* x = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
12558     Value* y = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12559         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
12560     auto result = powDoubleInt32(proc, root, Origin(), x, y);
12561     BasicBlock* continuation = result.first;
12562     continuation-&gt;appendNewControlValue(proc, Return, Origin(), result.second);
12563 
12564     CHECK(isIdentical(compileAndRun&lt;double&gt;(proc, xOperand, yOperand), b3Pow(xOperand, yOperand)));
12565 }
12566 
12567 void testTruncOrHigh()
12568 {
12569     Procedure proc;
12570     BasicBlock* root = proc.addBlock();
12571 
12572     root-&gt;appendNewControlValue(
12573         proc, Return, Origin(),
12574         root-&gt;appendNew&lt;Value&gt;(
12575             proc, Trunc, Origin(),
12576             root-&gt;appendNew&lt;Value&gt;(
12577                 proc, BitOr, Origin(),
12578                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12579                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x100000000))));
12580 
12581     int64_t value = 0x123456781234;
12582     CHECK(compileAndRun&lt;int&gt;(proc, value) == 0x56781234);
12583 }
12584 
12585 void testTruncOrLow()
12586 {
12587     Procedure proc;
12588     BasicBlock* root = proc.addBlock();
12589 
12590     root-&gt;appendNewControlValue(
12591         proc, Return, Origin(),
12592         root-&gt;appendNew&lt;Value&gt;(
12593             proc, Trunc, Origin(),
12594             root-&gt;appendNew&lt;Value&gt;(
12595                 proc, BitOr, Origin(),
12596                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12597                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x1000000))));
12598 
12599     int64_t value = 0x123456781234;
12600     CHECK(compileAndRun&lt;int&gt;(proc, value) == 0x57781234);
12601 }
12602 
12603 void testBitAndOrHigh()
12604 {
12605     Procedure proc;
12606     BasicBlock* root = proc.addBlock();
12607 
12608     root-&gt;appendNewControlValue(
12609         proc, Return, Origin(),
12610         root-&gt;appendNew&lt;Value&gt;(
12611             proc, BitAnd, Origin(),
12612             root-&gt;appendNew&lt;Value&gt;(
12613                 proc, BitOr, Origin(),
12614                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12615                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x8)),
12616             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x777777777777)));
12617 
12618     int64_t value = 0x123456781234;
12619     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == 0x123456701234ll);
12620 }
12621 
12622 void testBitAndOrLow()
12623 {
12624     Procedure proc;
12625     BasicBlock* root = proc.addBlock();
12626 
12627     root-&gt;appendNewControlValue(
12628         proc, Return, Origin(),
12629         root-&gt;appendNew&lt;Value&gt;(
12630             proc, BitAnd, Origin(),
12631             root-&gt;appendNew&lt;Value&gt;(
12632                 proc, BitOr, Origin(),
12633                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12634                 root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x1)),
12635             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0x777777777777)));
12636 
12637     int64_t value = 0x123456781234;
12638     CHECK(compileAndRun&lt;int64_t&gt;(proc, value) == 0x123456701235ll);
12639 }
12640 
12641 void testBranch64Equal(int64_t left, int64_t right)
12642 {
12643     Procedure proc;
12644     BasicBlock* root = proc.addBlock();
12645     BasicBlock* thenCase = proc.addBlock();
12646     BasicBlock* elseCase = proc.addBlock();
12647 
12648     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12649     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
12650     root-&gt;appendNewControlValue(
12651         proc, Branch, Origin(),
12652         root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2),
12653         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
12654 
12655     bool trueResult = true;
12656     thenCase-&gt;appendNewControlValue(
12657         proc, Return, Origin(),
12658         thenCase-&gt;appendNew&lt;MemoryValue&gt;(
12659             proc, Load8Z, Origin(),
12660             thenCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;trueResult)));
12661 
12662     bool elseResult = false;
12663     elseCase-&gt;appendNewControlValue(
12664         proc, Return, Origin(),
12665         elseCase-&gt;appendNew&lt;MemoryValue&gt;(
12666             proc, Load8Z, Origin(),
12667             elseCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;elseResult)));
12668 
12669     CHECK(compileAndRun&lt;bool&gt;(proc, left, right) == (left == right));
12670 }
12671 
12672 void testBranch64EqualImm(int64_t left, int64_t right)
12673 {
12674     Procedure proc;
12675     BasicBlock* root = proc.addBlock();
12676     BasicBlock* thenCase = proc.addBlock();
12677     BasicBlock* elseCase = proc.addBlock();
12678 
12679     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12680     Value* arg2 = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), right);
12681     root-&gt;appendNewControlValue(
12682         proc, Branch, Origin(),
12683         root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2),
12684         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
12685 
12686     bool trueResult = true;
12687     thenCase-&gt;appendNewControlValue(
12688         proc, Return, Origin(),
12689         thenCase-&gt;appendNew&lt;MemoryValue&gt;(
12690             proc, Load8Z, Origin(),
12691             thenCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;trueResult)));
12692 
12693     bool elseResult = false;
12694     elseCase-&gt;appendNewControlValue(
12695         proc, Return, Origin(),
12696         elseCase-&gt;appendNew&lt;MemoryValue&gt;(
12697             proc, Load8Z, Origin(),
12698             elseCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;elseResult)));
12699 
12700     CHECK(compileAndRun&lt;bool&gt;(proc, left) == (left == right));
12701 }
12702 
12703 void testBranch64EqualMem(int64_t left, int64_t right)
12704 {
12705     Procedure proc;
12706     BasicBlock* root = proc.addBlock();
12707     BasicBlock* thenCase = proc.addBlock();
12708     BasicBlock* elseCase = proc.addBlock();
12709 
12710     Value* arg1 = root-&gt;appendNew&lt;MemoryValue&gt;(
12711         proc, Load, pointerType(), Origin(),
12712         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
12713     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
12714     root-&gt;appendNewControlValue(
12715         proc, Branch, Origin(),
12716         root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2),
12717         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
12718 
12719     bool trueResult = true;
12720     thenCase-&gt;appendNewControlValue(
12721         proc, Return, Origin(),
12722         thenCase-&gt;appendNew&lt;MemoryValue&gt;(
12723             proc, Load8Z, Origin(),
12724             thenCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;trueResult)));
12725 
12726     bool elseResult = false;
12727     elseCase-&gt;appendNewControlValue(
12728         proc, Return, Origin(),
12729         elseCase-&gt;appendNew&lt;MemoryValue&gt;(
12730             proc, Load8Z, Origin(),
12731             elseCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;elseResult)));
12732 
12733     CHECK(compileAndRun&lt;bool&gt;(proc, &amp;left, right) == (left == right));
12734 }
12735 
12736 void testBranch64EqualMemImm(int64_t left, int64_t right)
12737 {
12738     Procedure proc;
12739     BasicBlock* root = proc.addBlock();
12740     BasicBlock* thenCase = proc.addBlock();
12741     BasicBlock* elseCase = proc.addBlock();
12742 
12743     Value* arg1 = root-&gt;appendNew&lt;MemoryValue&gt;(
12744         proc, Load, pointerType(), Origin(),
12745         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
12746     Value* arg2 = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), right);
12747     root-&gt;appendNewControlValue(
12748         proc, Branch, Origin(),
12749         root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), arg1, arg2),
12750         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
12751 
12752     bool trueResult = true;
12753     thenCase-&gt;appendNewControlValue(
12754         proc, Return, Origin(),
12755         thenCase-&gt;appendNew&lt;MemoryValue&gt;(
12756             proc, Load8Z, Origin(),
12757             thenCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;trueResult)));
12758 
12759     bool elseResult = false;
12760     elseCase-&gt;appendNewControlValue(
12761         proc, Return, Origin(),
12762         elseCase-&gt;appendNew&lt;MemoryValue&gt;(
12763             proc, Load8Z, Origin(),
12764             elseCase-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;elseResult)));
12765 
12766     CHECK(compileAndRun&lt;bool&gt;(proc, &amp;left) == (left == right));
12767 }
12768 
12769 void testStore8Load8Z(int32_t value)
12770 {
12771     Procedure proc;
12772     BasicBlock* root = proc.addBlock();
12773 
12774     int8_t byte;
12775     Value* ptr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;byte);
12776 
12777     root-&gt;appendNew&lt;MemoryValue&gt;(
12778         proc, Store8, Origin(),
12779         root-&gt;appendNew&lt;Value&gt;(
12780             proc, Trunc, Origin(),
12781             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
12782         ptr);
12783 
12784     root-&gt;appendNewControlValue(
12785         proc, Return, Origin(),
12786         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load8Z, Origin(), ptr));
12787 
12788     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;uint8_t&gt;(value));
12789 }
12790 
12791 void testStore16Load16Z(int32_t value)
12792 {
12793     Procedure proc;
12794     BasicBlock* root = proc.addBlock();
12795 
12796     int16_t byte;
12797     Value* ptr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;byte);
12798 
12799     root-&gt;appendNew&lt;MemoryValue&gt;(
12800         proc, Store16, Origin(),
12801         root-&gt;appendNew&lt;Value&gt;(
12802             proc, Trunc, Origin(),
12803             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
12804         ptr);
12805 
12806     root-&gt;appendNewControlValue(
12807         proc, Return, Origin(),
12808         root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load16Z, Origin(), ptr));
12809 
12810     CHECK(compileAndRun&lt;int32_t&gt;(proc, value) == static_cast&lt;uint16_t&gt;(value));
12811 }
12812 
12813 void testSShrShl32(int32_t value, int32_t sshrAmount, int32_t shlAmount)
12814 {
12815     Procedure proc;
12816     BasicBlock* root = proc.addBlock();
12817 
12818     root-&gt;appendNewControlValue(
12819         proc, Return, Origin(),
12820         root-&gt;appendNew&lt;Value&gt;(
12821             proc, SShr, Origin(),
12822             root-&gt;appendNew&lt;Value&gt;(
12823                 proc, Shl, Origin(),
12824                 root-&gt;appendNew&lt;Value&gt;(
12825                     proc, Trunc, Origin(),
12826                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
12827                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), shlAmount)),
12828             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), sshrAmount)));
12829 
12830     CHECK(
12831         compileAndRun&lt;int32_t&gt;(proc, value)
12832         == ((value &lt;&lt; (shlAmount &amp; 31)) &gt;&gt; (sshrAmount &amp; 31)));
12833 }
12834 
12835 void testSShrShl64(int64_t value, int32_t sshrAmount, int32_t shlAmount)
12836 {
12837     Procedure proc;
12838     BasicBlock* root = proc.addBlock();
12839 
12840     root-&gt;appendNewControlValue(
12841         proc, Return, Origin(),
12842         root-&gt;appendNew&lt;Value&gt;(
12843             proc, SShr, Origin(),
12844             root-&gt;appendNew&lt;Value&gt;(
12845                 proc, Shl, Origin(),
12846                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
12847                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), shlAmount)),
12848             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), sshrAmount)));
12849 
12850     CHECK(
12851         compileAndRun&lt;int64_t&gt;(proc, value)
12852         == ((value &lt;&lt; (shlAmount &amp; 63)) &gt;&gt; (sshrAmount &amp; 63)));
12853 }
12854 
12855 template&lt;typename T&gt;
12856 void testRotR(T valueInt, int32_t shift)
12857 {
12858     Procedure proc;
12859     BasicBlock* root = proc.addBlock();
12860 
12861     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12862     if (sizeof(T) == 4)
12863         value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), value);
12864 
12865     Value* ammount = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12866         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
12867     root-&gt;appendNewControlValue(proc, Return, Origin(),
12868         root-&gt;appendNew&lt;Value&gt;(proc, RotR, Origin(), value, ammount));
12869 
12870     CHECK_EQ(compileAndRun&lt;T&gt;(proc, valueInt, shift), rotateRight(valueInt, shift));
12871 }
12872 
12873 template&lt;typename T&gt;
12874 void testRotL(T valueInt, int32_t shift)
12875 {
12876     Procedure proc;
12877     BasicBlock* root = proc.addBlock();
12878 
12879     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12880     if (sizeof(T) == 4)
12881         value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), value);
12882 
12883     Value* ammount = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(),
12884         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
12885     root-&gt;appendNewControlValue(proc, Return, Origin(),
12886         root-&gt;appendNew&lt;Value&gt;(proc, RotL, Origin(), value, ammount));
12887 
12888     CHECK_EQ(compileAndRun&lt;T&gt;(proc, valueInt, shift), rotateLeft(valueInt, shift));
12889 }
12890 
12891 template&lt;typename T&gt;
12892 void testRotRWithImmShift(T valueInt, int32_t shift)
12893 {
12894     Procedure proc;
12895     BasicBlock* root = proc.addBlock();
12896 
12897     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12898     if (sizeof(T) == 4)
12899         value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), value);
12900 
12901     Value* ammount = root-&gt;appendIntConstant(proc, Origin(), Int32, shift);
12902     root-&gt;appendNewControlValue(proc, Return, Origin(),
12903         root-&gt;appendNew&lt;Value&gt;(proc, RotR, Origin(), value, ammount));
12904 
12905     CHECK_EQ(compileAndRun&lt;T&gt;(proc, valueInt, shift), rotateRight(valueInt, shift));
12906 }
12907 
12908 template&lt;typename T&gt;
12909 void testRotLWithImmShift(T valueInt, int32_t shift)
12910 {
12911     Procedure proc;
12912     BasicBlock* root = proc.addBlock();
12913 
12914     Value* value = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12915     if (sizeof(T) == 4)
12916         value = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), value);
12917 
12918     Value* ammount = root-&gt;appendIntConstant(proc, Origin(), Int32, shift);
12919     root-&gt;appendNewControlValue(proc, Return, Origin(),
12920         root-&gt;appendNew&lt;Value&gt;(proc, RotL, Origin(), value, ammount));
12921 
12922     CHECK_EQ(compileAndRun&lt;T&gt;(proc, valueInt, shift), rotateLeft(valueInt, shift));
12923 }
12924 
12925 template&lt;typename T&gt;
12926 void testComputeDivisionMagic(T value, T magicMultiplier, unsigned shift)
12927 {
12928     DivisionMagic&lt;T&gt; magic = computeDivisionMagic(value);
12929     CHECK(magic.magicMultiplier == magicMultiplier);
12930     CHECK(magic.shift == shift);
12931 }
12932 
12933 void testTrivialInfiniteLoop()
12934 {
12935     Procedure proc;
12936     BasicBlock* root = proc.addBlock();
12937     BasicBlock* loop = proc.addBlock();
12938     root-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loop));
12939     loop-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(loop));
12940 
12941     compileProc(proc);
12942 }
12943 
12944 void testFoldPathEqual()
12945 {
12946     Procedure proc;
12947     BasicBlock* root = proc.addBlock();
12948     BasicBlock* thenBlock = proc.addBlock();
12949     BasicBlock* elseBlock = proc.addBlock();
12950 
12951     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
12952 
12953     root-&gt;appendNewControlValue(
12954         proc, Branch, Origin(), arg, FrequentedBlock(thenBlock), FrequentedBlock(elseBlock));
12955 
12956     thenBlock-&gt;appendNewControlValue(
12957         proc, Return, Origin(),
12958         thenBlock-&gt;appendNew&lt;Value&gt;(
12959             proc, Equal, Origin(), arg, thenBlock-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)));
12960 
12961     elseBlock-&gt;appendNewControlValue(
12962         proc, Return, Origin(),
12963         elseBlock-&gt;appendNew&lt;Value&gt;(
12964             proc, Equal, Origin(), arg, elseBlock-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0)));
12965 
12966     auto code = compileProc(proc);
12967     CHECK(invoke&lt;intptr_t&gt;(*code, 0) == 1);
12968     CHECK(invoke&lt;intptr_t&gt;(*code, 1) == 0);
12969     CHECK(invoke&lt;intptr_t&gt;(*code, 42) == 0);
12970 }
12971 
12972 void testLShiftSelf32()
12973 {
12974     Procedure proc;
12975     BasicBlock* root = proc.addBlock();
12976     Value* arg = root-&gt;appendNew&lt;Value&gt;(
12977         proc, Trunc, Origin(),
12978         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
12979     root-&gt;appendNewControlValue(
12980         proc, Return, Origin(),
12981         root-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), arg, arg));
12982 
12983     auto code = compileProc(proc);
12984 
12985     auto check = [&amp;] (int32_t value) {
12986         CHECK(invoke&lt;int32_t&gt;(*code, value) == value &lt;&lt; (value &amp; 31));
12987     };
12988 
12989     check(0);
12990     check(1);
12991     check(31);
12992     check(32);
12993 }
12994 
12995 void testRShiftSelf32()
12996 {
12997     Procedure proc;
12998     BasicBlock* root = proc.addBlock();
12999     Value* arg = root-&gt;appendNew&lt;Value&gt;(
13000         proc, Trunc, Origin(),
13001         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
13002     root-&gt;appendNewControlValue(
13003         proc, Return, Origin(),
13004         root-&gt;appendNew&lt;Value&gt;(proc, SShr, Origin(), arg, arg));
13005 
13006     auto code = compileProc(proc);
13007 
13008     auto check = [&amp;] (int32_t value) {
13009         CHECK(invoke&lt;int32_t&gt;(*code, value) == value &gt;&gt; (value &amp; 31));
13010     };
13011 
13012     check(0);
13013     check(1);
13014     check(31);
13015     check(32);
13016 }
13017 
13018 void testURShiftSelf32()
13019 {
13020     Procedure proc;
13021     BasicBlock* root = proc.addBlock();
13022     Value* arg = root-&gt;appendNew&lt;Value&gt;(
13023         proc, Trunc, Origin(),
13024         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
13025     root-&gt;appendNewControlValue(
13026         proc, Return, Origin(),
13027         root-&gt;appendNew&lt;Value&gt;(proc, ZShr, Origin(), arg, arg));
13028 
13029     auto code = compileProc(proc);
13030 
13031     auto check = [&amp;] (uint32_t value) {
13032         CHECK(invoke&lt;uint32_t&gt;(*code, value) == value &gt;&gt; (value &amp; 31));
13033     };
13034 
13035     check(0);
13036     check(1);
13037     check(31);
13038     check(32);
13039 }
13040 
13041 void testLShiftSelf64()
13042 {
13043     Procedure proc;
13044     BasicBlock* root = proc.addBlock();
13045     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
13046     root-&gt;appendNewControlValue(
13047         proc, Return, Origin(),
13048         root-&gt;appendNew&lt;Value&gt;(
13049             proc, Shl, Origin(), arg, root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), arg)));
13050 
13051     auto code = compileProc(proc);
13052 
13053     auto check = [&amp;] (int64_t value) {
13054         CHECK(invoke&lt;int64_t&gt;(*code, value) == value &lt;&lt; (value &amp; 63));
13055     };
13056 
13057     check(0);
13058     check(1);
13059     check(31);
13060     check(32);
13061     check(63);
13062     check(64);
13063 }
13064 
13065 void testRShiftSelf64()
13066 {
13067     Procedure proc;
13068     BasicBlock* root = proc.addBlock();
13069     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
13070     root-&gt;appendNewControlValue(
13071         proc, Return, Origin(),
13072         root-&gt;appendNew&lt;Value&gt;(
13073             proc, SShr, Origin(), arg, root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), arg)));
13074 
13075     auto code = compileProc(proc);
13076 
13077     auto check = [&amp;] (int64_t value) {
13078         CHECK(invoke&lt;int64_t&gt;(*code, value) == value &gt;&gt; (value &amp; 63));
13079     };
13080 
13081     check(0);
13082     check(1);
13083     check(31);
13084     check(32);
13085     check(63);
13086     check(64);
13087 }
13088 
13089 void testURShiftSelf64()
13090 {
13091     Procedure proc;
13092     BasicBlock* root = proc.addBlock();
13093     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
13094     root-&gt;appendNewControlValue(
13095         proc, Return, Origin(),
13096         root-&gt;appendNew&lt;Value&gt;(
13097             proc, ZShr, Origin(), arg, root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), arg)));
13098 
13099     auto code = compileProc(proc);
13100 
13101     auto check = [&amp;] (uint64_t value) {
13102         CHECK(invoke&lt;uint64_t&gt;(*code, value) == value &gt;&gt; (value &amp; 63));
13103     };
13104 
13105     check(0);
13106     check(1);
13107     check(31);
13108     check(32);
13109     check(63);
13110     check(64);
13111 }
13112 
13113 void testPatchpointDoubleRegs()
13114 {
13115     Procedure proc;
13116     BasicBlock* root = proc.addBlock();
13117 
13118     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0);
13119 
13120     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Double, Origin());
13121     patchpoint-&gt;append(arg, ValueRep(FPRInfo::fpRegT0));
13122     patchpoint-&gt;resultConstraint = ValueRep(FPRInfo::fpRegT0);
13123 
13124     unsigned numCalls = 0;
13125     patchpoint-&gt;setGenerator(
13126         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
13127             numCalls++;
13128         });
13129 
13130     root-&gt;appendNewControlValue(proc, Return, Origin(), patchpoint);
13131 
13132     auto code = compileProc(proc);
13133     CHECK(numCalls == 1);
13134     CHECK(invoke&lt;double&gt;(*code, 42.5) == 42.5);
13135 }
13136 
13137 void testSpillDefSmallerThanUse()
13138 {
13139     Procedure proc;
13140     BasicBlock* root = proc.addBlock();
13141 
13142     // Move32.
13143     Value* arg32 = root-&gt;appendNew&lt;Value&gt;(
13144         proc, Trunc, Origin(),
13145         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
13146     Value* arg64 = root-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), arg32);
13147 
13148     // Make sure arg64 is on the stack.
13149     PatchpointValue* forceSpill = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
13150     RegisterSet clobberSet = RegisterSet::allGPRs();
13151     clobberSet.exclude(RegisterSet::stackRegisters());
13152     clobberSet.exclude(RegisterSet::reservedHardwareRegisters());
13153     clobberSet.clear(GPRInfo::returnValueGPR); // Force the return value for aliasing below.
13154     forceSpill-&gt;clobberLate(clobberSet);
13155     forceSpill-&gt;setGenerator(
13156         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13157             AllowMacroScratchRegisterUsage allowScratch(jit);
13158             jit.xor64(params[0].gpr(), params[0].gpr());
13159         });
13160 
13161     // On x86, Sub admit an address for any operand. If it uses the stack, the top bits must be zero.
13162     Value* result = root-&gt;appendNew&lt;Value&gt;(proc, Sub, Origin(), forceSpill, arg64);
13163     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
13164 
13165     auto code = compileProc(proc);
13166     CHECK(invoke&lt;int64_t&gt;(*code, 0xffffffff00000000) == 0);
13167 }
13168 
13169 void testSpillUseLargerThanDef()
13170 {
13171     Procedure proc;
13172     BasicBlock* root = proc.addBlock();
13173     BasicBlock* thenCase = proc.addBlock();
13174     BasicBlock* elseCase = proc.addBlock();
13175     BasicBlock* tail = proc.addBlock();
13176 
13177     RegisterSet clobberSet = RegisterSet::allGPRs();
13178     clobberSet.exclude(RegisterSet::stackRegisters());
13179     clobberSet.exclude(RegisterSet::reservedHardwareRegisters());
13180 
13181     Value* condition = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
13182     Value* argument = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
13183     root-&gt;appendNewControlValue(
13184         proc, Branch, Origin(),
13185         root-&gt;appendNew&lt;Value&gt;(
13186             proc, Trunc, Origin(),
13187             condition),
13188         FrequentedBlock(thenCase), FrequentedBlock(elseCase));
13189 
13190     Value* truncated = thenCase-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(),
13191         thenCase-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), argument));
13192     UpsilonValue* thenResult = thenCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), truncated);
13193     thenCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
13194 
13195     UpsilonValue* elseResult = elseCase-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), argument);
13196     elseCase-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(tail));
13197 
13198     for (unsigned i = 0; i &lt; 100; ++i) {
13199         PatchpointValue* preventTailDuplication = tail-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
13200         preventTailDuplication-&gt;clobberLate(clobberSet);
13201         preventTailDuplication-&gt;setGenerator([] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
13202     }
13203 
13204     PatchpointValue* forceSpill = tail-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
13205     forceSpill-&gt;clobberLate(clobberSet);
13206     forceSpill-&gt;setGenerator(
13207         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
13208             AllowMacroScratchRegisterUsage allowScratch(jit);
13209             clobberSet.forEach([&amp;] (Reg reg) {
13210                 jit.move(CCallHelpers::TrustedImm64(0xffffffffffffffff), reg.gpr());
13211             });
13212         });
13213 
13214     Value* phi = tail-&gt;appendNew&lt;Value&gt;(proc, Phi, Int64, Origin());
13215     thenResult-&gt;setPhi(phi);
13216     elseResult-&gt;setPhi(phi);
13217     tail-&gt;appendNewControlValue(proc, Return, Origin(), phi);
13218 
13219     auto code = compileProc(proc);
13220     CHECK(invoke&lt;uint64_t&gt;(*code, 1, 0xffffffff00000000) == 0);
13221     CHECK(invoke&lt;uint64_t&gt;(*code, 0, 0xffffffff00000000) == 0xffffffff00000000);
13222 
13223     // A second time since the previous run is still on the stack.
13224     CHECK(invoke&lt;uint64_t&gt;(*code, 1, 0xffffffff00000000) == 0);
13225 
13226 }
13227 
13228 void testLateRegister()
13229 {
13230     Procedure proc;
13231     BasicBlock* root = proc.addBlock();
13232 
13233     // This works by making all but 1 register be input to the first patchpoint as LateRegister.
13234     // The other 1 register is just a regular Register input. We assert our result is the regular
13235     // register input. There would be no other way for the register allocator to arrange things
13236     // because LateRegister interferes with the result.
13237     // Then, the second patchpoint takes the result of the first as an argument and asks for
13238     // it in a register that was a LateRegister. This is to incentivize the register allocator
13239     // to use that LateRegister as the result for the first patchpoint. But of course it can not do that.
13240     // So it must issue a mov after the first patchpoint from the first&#39;s result into the second&#39;s input.
13241 
13242     RegisterSet regs = RegisterSet::allGPRs();
13243     regs.exclude(RegisterSet::stackRegisters());
13244     regs.exclude(RegisterSet::reservedHardwareRegisters());
13245     Vector&lt;Value*&gt; lateUseArgs;
13246     unsigned result = 0;
13247     for (GPRReg reg = CCallHelpers::firstRegister(); reg &lt;= CCallHelpers::lastRegister(); reg = CCallHelpers::nextRegister(reg)) {
13248         if (!regs.get(reg))
13249             continue;
13250         result++;
13251         if (reg == GPRInfo::regT0)
13252             continue;
13253         Value* value = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 1);
13254         lateUseArgs.append(value);
13255     }
13256     Value* regularUse = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 1);
13257     PatchpointValue* firstPatchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
13258     {
13259         unsigned i = 0;
13260         for (GPRReg reg = CCallHelpers::firstRegister(); reg &lt;= CCallHelpers::lastRegister(); reg = CCallHelpers::nextRegister(reg)) {
13261             if (!regs.get(reg))
13262                 continue;
13263             if (reg == GPRInfo::regT0)
13264                 continue;
13265             Value* value = lateUseArgs[i++];
13266             firstPatchpoint-&gt;append(value, ValueRep::lateReg(reg));
13267         }
13268         firstPatchpoint-&gt;append(regularUse, ValueRep::reg(GPRInfo::regT0));
13269     }
13270 
13271     firstPatchpoint-&gt;setGenerator(
13272         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13273             AllowMacroScratchRegisterUsage allowScratch(jit);
13274             CHECK(params[0].gpr() == GPRInfo::regT0);
13275             // Note that regT0 should also start off as 1, so we&#39;re implicitly starting our add with 1, which is also an argument.
13276             unsigned skipped = 0;
13277             for (unsigned i = 1; i &lt; params.size(); i++) {
13278                 if (params[i].gpr() == params[0].gpr()) {
13279                     skipped = i;
13280                     continue;
13281                 }
13282                 jit.add64(params[i].gpr(), params[0].gpr());
13283             }
13284             CHECK(!!skipped);
13285         });
13286 
13287     PatchpointValue* secondPatchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
13288     secondPatchpoint-&gt;append(firstPatchpoint, ValueRep::reg(GPRInfo::regT1));
13289     secondPatchpoint-&gt;setGenerator(
13290         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13291             AllowMacroScratchRegisterUsage allowScratch(jit);
13292             CHECK(params[1].gpr() == GPRInfo::regT1);
13293             jit.nop();
13294             jit.nop();
13295             jit.move(params[1].gpr(), params[0].gpr());
13296             jit.nop();
13297             jit.nop();
13298         });
13299     root-&gt;appendNewControlValue(proc, Return, Origin(), secondPatchpoint);
13300 
13301     auto code = compileProc(proc);
13302     CHECK(invoke&lt;uint64_t&gt;(*code) == result);
13303 }
13304 
13305 void interpreterPrint(Vector&lt;intptr_t&gt;* stream, intptr_t value)
13306 {
13307     stream-&gt;append(value);
13308 }
13309 
13310 void testInterpreter()
13311 {
13312     // This implements a silly interpreter to test building custom switch statements using
13313     // Patchpoint.
13314 
13315     Procedure proc;
13316 
13317     BasicBlock* root = proc.addBlock();
13318     BasicBlock* dispatch = proc.addBlock();
13319     BasicBlock* addToDataPointer = proc.addBlock();
13320     BasicBlock* addToCodePointer = proc.addBlock();
13321     BasicBlock* addToCodePointerTaken = proc.addBlock();
13322     BasicBlock* addToCodePointerNotTaken = proc.addBlock();
13323     BasicBlock* addToData = proc.addBlock();
13324     BasicBlock* print = proc.addBlock();
13325     BasicBlock* stop = proc.addBlock();
13326 
13327     Variable* dataPointer = proc.addVariable(pointerType());
13328     Variable* codePointer = proc.addVariable(pointerType());
13329 
13330     root-&gt;appendNew&lt;VariableValue&gt;(
13331         proc, Set, Origin(), dataPointer,
13332         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
13333     root-&gt;appendNew&lt;VariableValue&gt;(
13334         proc, Set, Origin(), codePointer,
13335         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
13336     Value* context = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
13337     root-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(dispatch));
13338 
13339     // NOTE: It&#39;s totally valid for this patchpoint to be tail-duplicated.
13340     Value* codePointerValue =
13341         dispatch-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), codePointer);
13342     Value* opcode = dispatch-&gt;appendNew&lt;MemoryValue&gt;(
13343         proc, Load, pointerType(), Origin(), codePointerValue);
13344     PatchpointValue* polyJump = dispatch-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
13345     polyJump-&gt;effects = Effects();
13346     polyJump-&gt;effects.terminal = true;
13347     polyJump-&gt;appendSomeRegister(opcode);
13348     polyJump-&gt;clobber(RegisterSet::macroScratchRegisters());
13349     polyJump-&gt;numGPScratchRegisters = 2;
13350     dispatch-&gt;appendSuccessor(FrequentedBlock(addToDataPointer));
13351     dispatch-&gt;appendSuccessor(FrequentedBlock(addToCodePointer));
13352     dispatch-&gt;appendSuccessor(FrequentedBlock(addToData));
13353     dispatch-&gt;appendSuccessor(FrequentedBlock(print));
13354     dispatch-&gt;appendSuccessor(FrequentedBlock(stop));
13355 
13356     // Our &quot;opcodes&quot;.
13357     static const intptr_t AddDP = 0;
13358     static const intptr_t AddCP = 1;
13359     static const intptr_t Add = 2;
13360     static const intptr_t Print = 3;
13361     static const intptr_t Stop = 4;
13362 
13363     polyJump-&gt;setGenerator(
13364         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13365             AllowMacroScratchRegisterUsage allowScratch(jit);
13366             Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
13367 
13368             MacroAssemblerCodePtr&lt;B3CompilationPtrTag&gt;* jumpTable = bitwise_cast&lt;MacroAssemblerCodePtr&lt;B3CompilationPtrTag&gt;*&gt;(
13369                 params.proc().addDataSection(sizeof(MacroAssemblerCodePtr&lt;B3CompilationPtrTag&gt;) * labels.size()));
13370 
13371             GPRReg scratch = params.gpScratch(0);
13372 
13373             jit.move(CCallHelpers::TrustedImmPtr(jumpTable), scratch);
13374             jit.load64(CCallHelpers::BaseIndex(scratch, params[0].gpr(), CCallHelpers::timesPtr()), scratch);
13375             jit.jump(scratch, B3CompilationPtrTag);
13376 
13377             jit.addLinkTask(
13378                 [&amp;, jumpTable, labels] (LinkBuffer&amp; linkBuffer) {
13379                     for (unsigned i = labels.size(); i--;)
13380                         jumpTable[i] = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(*labels[i]);
13381                 });
13382         });
13383 
13384     // AddDP &lt;operand&gt;: adds &lt;operand&gt; to DP.
13385     codePointerValue =
13386         addToDataPointer-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), codePointer);
13387     addToDataPointer-&gt;appendNew&lt;VariableValue&gt;(
13388         proc, Set, Origin(), dataPointer,
13389         addToDataPointer-&gt;appendNew&lt;Value&gt;(
13390             proc, B3::Add, Origin(),
13391             addToDataPointer-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), dataPointer),
13392             addToDataPointer-&gt;appendNew&lt;Value&gt;(
13393                 proc, Mul, Origin(),
13394                 addToDataPointer-&gt;appendNew&lt;MemoryValue&gt;(
13395                     proc, Load, pointerType(), Origin(), codePointerValue, static_cast&lt;int32_t&gt;(sizeof(intptr_t))),
13396                 addToDataPointer-&gt;appendIntConstant(
13397                     proc, Origin(), pointerType(), sizeof(intptr_t)))));
13398     addToDataPointer-&gt;appendNew&lt;VariableValue&gt;(
13399         proc, Set, Origin(), codePointer,
13400         addToDataPointer-&gt;appendNew&lt;Value&gt;(
13401             proc, B3::Add, Origin(), codePointerValue,
13402             addToDataPointer-&gt;appendIntConstant(
13403                 proc, Origin(), pointerType(), sizeof(intptr_t) * 2)));
13404     addToDataPointer-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(dispatch));
13405 
13406     // AddCP &lt;operand&gt;: adds &lt;operand&gt; to CP if the current value at DP is non-zero, otherwise
13407     // falls through normally.
13408     codePointerValue =
13409         addToCodePointer-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), codePointer);
13410     Value* dataPointerValue =
13411         addToCodePointer-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), dataPointer);
13412     addToCodePointer-&gt;appendNewControlValue(
13413         proc, Branch, Origin(),
13414         addToCodePointer-&gt;appendNew&lt;MemoryValue&gt;(
13415             proc, Load, pointerType(), Origin(), dataPointerValue),
13416         FrequentedBlock(addToCodePointerTaken), FrequentedBlock(addToCodePointerNotTaken));
13417     addToCodePointerTaken-&gt;appendNew&lt;VariableValue&gt;(
13418         proc, Set, Origin(), codePointer,
13419         addToCodePointerTaken-&gt;appendNew&lt;Value&gt;(
13420             proc, B3::Add, Origin(), codePointerValue,
13421             addToCodePointerTaken-&gt;appendNew&lt;Value&gt;(
13422                 proc, Mul, Origin(),
13423                 addToCodePointerTaken-&gt;appendNew&lt;MemoryValue&gt;(
13424                     proc, Load, pointerType(), Origin(), codePointerValue, static_cast&lt;int32_t&gt;(sizeof(intptr_t))),
13425                 addToCodePointerTaken-&gt;appendIntConstant(
13426                     proc, Origin(), pointerType(), sizeof(intptr_t)))));
13427     addToCodePointerTaken-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(dispatch));
13428     addToCodePointerNotTaken-&gt;appendNew&lt;VariableValue&gt;(
13429         proc, Set, Origin(), codePointer,
13430         addToCodePointerNotTaken-&gt;appendNew&lt;Value&gt;(
13431             proc, B3::Add, Origin(), codePointerValue,
13432             addToCodePointerNotTaken-&gt;appendIntConstant(
13433                 proc, Origin(), pointerType(), sizeof(intptr_t) * 2)));
13434     addToCodePointerNotTaken-&gt;appendNewControlValue(
13435         proc, Jump, Origin(), FrequentedBlock(dispatch));
13436 
13437     // Add &lt;operand&gt;: adds &lt;operand&gt; to the slot pointed to by DP.
13438     codePointerValue = addToData-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), codePointer);
13439     dataPointerValue = addToData-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), dataPointer);
13440     addToData-&gt;appendNew&lt;MemoryValue&gt;(
13441         proc, Store, Origin(),
13442         addToData-&gt;appendNew&lt;Value&gt;(
13443             proc, B3::Add, Origin(),
13444             addToData-&gt;appendNew&lt;MemoryValue&gt;(
13445                 proc, Load, pointerType(), Origin(), dataPointerValue),
13446             addToData-&gt;appendNew&lt;MemoryValue&gt;(
13447                 proc, Load, pointerType(), Origin(), codePointerValue, static_cast&lt;int32_t&gt;(sizeof(intptr_t)))),
13448         dataPointerValue);
13449     addToData-&gt;appendNew&lt;VariableValue&gt;(
13450         proc, Set, Origin(), codePointer,
13451         addToData-&gt;appendNew&lt;Value&gt;(
13452             proc, B3::Add, Origin(), codePointerValue,
13453             addToData-&gt;appendIntConstant(proc, Origin(), pointerType(), sizeof(intptr_t) * 2)));
13454     addToData-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(dispatch));
13455 
13456     // Print: &quot;prints&quot; the value pointed to by DP. What this actually means is that the value is
13457     // appended to the stream vector by the interpreterPrint function.
13458     codePointerValue = print-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), codePointer);
13459     dataPointerValue = print-&gt;appendNew&lt;VariableValue&gt;(proc, B3::Get, Origin(), dataPointer);
13460     print-&gt;appendNew&lt;CCallValue&gt;(
13461         proc, Void, Origin(),
13462         print-&gt;appendNew&lt;ConstPtrValue&gt;(
13463             proc, Origin(), tagCFunctionPtr&lt;void*&gt;(interpreterPrint, B3CCallPtrTag)),
13464         context,
13465         print-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, pointerType(), Origin(), dataPointerValue));
13466     print-&gt;appendNew&lt;VariableValue&gt;(
13467         proc, Set, Origin(), codePointer,
13468         print-&gt;appendNew&lt;Value&gt;(
13469             proc, B3::Add, Origin(), codePointerValue,
13470             print-&gt;appendIntConstant(proc, Origin(), pointerType(), sizeof(intptr_t))));
13471     print-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(dispatch));
13472 
13473     // Stop: returns.
13474     stop-&gt;appendNewControlValue(
13475         proc, Return, Origin(),
13476         stop-&gt;appendIntConstant(proc, Origin(), pointerType(), 0));
13477 
13478     auto interpreter = compileProc(proc);
13479 
13480     Vector&lt;uintptr_t&gt; data;
13481     Vector&lt;uintptr_t&gt; code;
13482     Vector&lt;uintptr_t&gt; stream;
13483 
13484     data.append(1);
13485     data.append(0);
13486 
13487     if (shouldBeVerbose())
13488         dataLog(&quot;data = &quot;, listDump(data), &quot;\n&quot;);
13489 
13490     // We&#39;ll write a program that prints the numbers 1..100.
13491     // We expect DP to point at #0.
13492     code.append(AddCP);
13493     code.append(6); // go to loop body
13494 
13495     // Loop re-entry:
13496     // We expect DP to point at #1 and for #1 to be offset by -100.
13497     code.append(Add);
13498     code.append(100);
13499 
13500     code.append(AddDP);
13501     code.append(-1);
13502 
13503     // Loop header:
13504     // We expect DP to point at #0.
13505     code.append(AddDP);
13506     code.append(1);
13507 
13508     code.append(Add);
13509     code.append(1);
13510 
13511     code.append(Print);
13512 
13513     code.append(Add);
13514     code.append(-100);
13515 
13516     // We want to stop if it&#39;s zero and continue if it&#39;s non-zero. AddCP takes the branch if it&#39;s
13517     // non-zero.
13518     code.append(AddCP);
13519     code.append(-11); // go to loop re-entry.
13520 
13521     code.append(Stop);
13522 
13523     if (shouldBeVerbose())
13524         dataLog(&quot;code = &quot;, listDump(code), &quot;\n&quot;);
13525 
13526     CHECK(!invoke&lt;intptr_t&gt;(*interpreter, data.data(), code.data(), &amp;stream));
13527 
13528     CHECK(stream.size() == 100);
13529     for (unsigned i = 0; i &lt; 100; ++i)
13530         CHECK(stream[i] == i + 1);
13531 
13532     if (shouldBeVerbose())
13533         dataLog(&quot;stream = &quot;, listDump(stream), &quot;\n&quot;);
13534 }
13535 
13536 void testReduceStrengthCheckBottomUseInAnotherBlock()
13537 {
13538     Procedure proc;
13539 
13540     BasicBlock* one = proc.addBlock();
13541     BasicBlock* two = proc.addBlock();
13542 
13543     CheckValue* check = one-&gt;appendNew&lt;CheckValue&gt;(
13544         proc, Check, Origin(), one-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
13545     check-&gt;setGenerator(
13546         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
13547             AllowMacroScratchRegisterUsage allowScratch(jit);
13548 
13549             jit.move(CCallHelpers::TrustedImm32(666), GPRInfo::returnValueGPR);
13550             jit.emitFunctionEpilogue();
13551             jit.ret();
13552         });
13553     Value* arg = one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
13554     one-&gt;appendNewControlValue(proc, Jump, Origin(), FrequentedBlock(two));
13555 
13556     check = two-&gt;appendNew&lt;CheckValue&gt;(
13557         proc, CheckAdd, Origin(), arg,
13558         two-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 1));
13559     check-&gt;setGenerator(
13560         [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) {
13561             CHECK(!&quot;Should not execute&quot;);
13562         });
13563     two-&gt;appendNewControlValue(proc, Return, Origin(), check);
13564 
13565     proc.resetReachability();
13566     reduceStrength(proc);
13567 }
13568 
13569 void testResetReachabilityDanglingReference()
13570 {
13571     Procedure proc;
13572 
13573     BasicBlock* one = proc.addBlock();
13574     BasicBlock* two = proc.addBlock();
13575 
13576     UpsilonValue* upsilon = one-&gt;appendNew&lt;UpsilonValue&gt;(
13577         proc, Origin(), one-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42));
13578     one-&gt;appendNewControlValue(proc, Oops, Origin());
13579 
13580     Value* phi = two-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
13581     upsilon-&gt;setPhi(phi);
13582     two-&gt;appendNewControlValue(proc, Oops, Origin());
13583 
13584     proc.resetReachability();
13585     validate(proc);
13586 }
13587 
13588 void testEntrySwitchSimple()
13589 {
13590     Procedure proc;
13591     proc.setNumEntrypoints(3);
13592 
13593     BasicBlock* root = proc.addBlock();
13594     BasicBlock* one = proc.addBlock();
13595     BasicBlock* two = proc.addBlock();
13596     BasicBlock* three = proc.addBlock();
13597 
13598     root-&gt;appendNew&lt;Value&gt;(proc, EntrySwitch, Origin());
13599     root-&gt;appendSuccessor(FrequentedBlock(one));
13600     root-&gt;appendSuccessor(FrequentedBlock(two));
13601     root-&gt;appendSuccessor(FrequentedBlock(three));
13602 
13603     one-&gt;appendNew&lt;Value&gt;(
13604         proc, Return, Origin(),
13605         one-&gt;appendNew&lt;Value&gt;(
13606             proc, Add, Origin(),
13607             one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
13608             one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
13609 
13610     two-&gt;appendNew&lt;Value&gt;(
13611         proc, Return, Origin(),
13612         two-&gt;appendNew&lt;Value&gt;(
13613             proc, Sub, Origin(),
13614             two-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
13615             two-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
13616 
13617     three-&gt;appendNew&lt;Value&gt;(
13618         proc, Return, Origin(),
13619         three-&gt;appendNew&lt;Value&gt;(
13620             proc, Mul, Origin(),
13621             three-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
13622             three-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
13623 
13624     prepareForGeneration(proc);
13625 
13626     CCallHelpers jit;
13627     generate(proc, jit);
13628     LinkBuffer linkBuffer(jit, nullptr);
13629     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelOne = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(0));
13630     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelTwo = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(1));
13631     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelThree = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(2));
13632 
13633     MacroAssemblerCodeRef&lt;B3CompilationPtrTag&gt; codeRef = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;testb3 compilation&quot;);
13634 
13635     CHECK(invoke&lt;int&gt;(labelOne, 1, 2) == 3);
13636     CHECK(invoke&lt;int&gt;(labelTwo, 1, 2) == -1);
13637     CHECK(invoke&lt;int&gt;(labelThree, 1, 2) == 2);
13638     CHECK(invoke&lt;int&gt;(labelOne, -1, 2) == 1);
13639     CHECK(invoke&lt;int&gt;(labelTwo, -1, 2) == -3);
13640     CHECK(invoke&lt;int&gt;(labelThree, -1, 2) == -2);
13641 }
13642 
13643 void testEntrySwitchNoEntrySwitch()
13644 {
13645     Procedure proc;
13646     proc.setNumEntrypoints(3);
13647 
13648     BasicBlock* root = proc.addBlock();
13649 
13650     root-&gt;appendNew&lt;Value&gt;(
13651         proc, Return, Origin(),
13652         root-&gt;appendNew&lt;Value&gt;(
13653             proc, Add, Origin(),
13654             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
13655             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1)));
13656 
13657     prepareForGeneration(proc);
13658 
13659     CCallHelpers jit;
13660     generate(proc, jit);
13661     LinkBuffer linkBuffer(jit, nullptr);
13662     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelOne = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(0));
13663     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelTwo = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(1));
13664     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelThree = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(2));
13665 
13666     MacroAssemblerCodeRef&lt;B3CompilationPtrTag&gt; codeRef = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;testb3 compilation&quot;);
13667 
13668     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2), 3);
13669     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2), 3);
13670     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2), 3);
13671     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2), 1);
13672     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2), 1);
13673     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2), 1);
13674 }
13675 
13676 void testEntrySwitchWithCommonPaths()
13677 {
13678     Procedure proc;
13679     proc.setNumEntrypoints(3);
13680 
13681     BasicBlock* root = proc.addBlock();
13682     BasicBlock* one = proc.addBlock();
13683     BasicBlock* two = proc.addBlock();
13684     BasicBlock* three = proc.addBlock();
13685     BasicBlock* end = proc.addBlock();
13686 
13687     root-&gt;appendNew&lt;Value&gt;(proc, EntrySwitch, Origin());
13688     root-&gt;appendSuccessor(FrequentedBlock(one));
13689     root-&gt;appendSuccessor(FrequentedBlock(two));
13690     root-&gt;appendSuccessor(FrequentedBlock(three));
13691 
13692     UpsilonValue* upsilonOne = one-&gt;appendNew&lt;UpsilonValue&gt;(
13693         proc, Origin(),
13694         one-&gt;appendNew&lt;Value&gt;(
13695             proc, Add, Origin(),
13696             one-&gt;appendNew&lt;Value&gt;(
13697                 proc, Trunc, Origin(),
13698                 one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
13699             one-&gt;appendNew&lt;Value&gt;(
13700                 proc, Trunc, Origin(),
13701                 one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13702     one-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13703     one-&gt;setSuccessors(FrequentedBlock(end));
13704 
13705     UpsilonValue* upsilonTwo = two-&gt;appendNew&lt;UpsilonValue&gt;(
13706         proc, Origin(),
13707         two-&gt;appendNew&lt;Value&gt;(
13708             proc, Sub, Origin(),
13709             two-&gt;appendNew&lt;Value&gt;(
13710                 proc, Trunc, Origin(),
13711                 two-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
13712             two-&gt;appendNew&lt;Value&gt;(
13713                 proc, Trunc, Origin(),
13714                 two-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13715     two-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13716     two-&gt;setSuccessors(FrequentedBlock(end));
13717 
13718     UpsilonValue* upsilonThree = three-&gt;appendNew&lt;UpsilonValue&gt;(
13719         proc, Origin(),
13720         three-&gt;appendNew&lt;Value&gt;(
13721             proc, Mul, Origin(),
13722             three-&gt;appendNew&lt;Value&gt;(
13723                 proc, Trunc, Origin(),
13724                 three-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
13725             three-&gt;appendNew&lt;Value&gt;(
13726                 proc, Trunc, Origin(),
13727                 three-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13728     three-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13729     three-&gt;setSuccessors(FrequentedBlock(end));
13730 
13731     Value* phi = end-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
13732     upsilonOne-&gt;setPhi(phi);
13733     upsilonTwo-&gt;setPhi(phi);
13734     upsilonThree-&gt;setPhi(phi);
13735 
13736     end-&gt;appendNew&lt;Value&gt;(
13737         proc, Return, Origin(),
13738         end-&gt;appendNew&lt;Value&gt;(
13739             proc, chill(Mod), Origin(),
13740             phi, end-&gt;appendNew&lt;Value&gt;(
13741                 proc, Trunc, Origin(),
13742                 end-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2))));
13743 
13744     prepareForGeneration(proc);
13745 
13746     CCallHelpers jit;
13747     generate(proc, jit);
13748     LinkBuffer linkBuffer(jit, nullptr);
13749     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelOne = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(0));
13750     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelTwo = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(1));
13751     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelThree = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(2));
13752 
13753     MacroAssemblerCodeRef&lt;B3CompilationPtrTag&gt; codeRef = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;testb3 compilation&quot;);
13754 
13755     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 10), 3);
13756     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 10), -1);
13757     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 10), 2);
13758     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 10), 1);
13759     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 10), -3);
13760     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 10), -2);
13761     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 2), 1);
13762     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 2), -1);
13763     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 2), 0);
13764     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 2), 1);
13765     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 2), -1);
13766     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 2), 0);
13767     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 0), 0);
13768     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 0), 0);
13769     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 0), 0);
13770     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 0), 0);
13771     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 0), 0);
13772     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 0), 0);
13773 }
13774 
13775 void testEntrySwitchWithCommonPathsAndNonTrivialEntrypoint()
13776 {
13777     Procedure proc;
13778     proc.setNumEntrypoints(3);
13779 
13780     BasicBlock* root = proc.addBlock();
13781     BasicBlock* negate = proc.addBlock();
13782     BasicBlock* dispatch = proc.addBlock();
13783     BasicBlock* one = proc.addBlock();
13784     BasicBlock* two = proc.addBlock();
13785     BasicBlock* three = proc.addBlock();
13786     BasicBlock* end = proc.addBlock();
13787 
13788     UpsilonValue* upsilonBase = root-&gt;appendNew&lt;UpsilonValue&gt;(
13789         proc, Origin(), root-&gt;appendNew&lt;Value&gt;(
13790             proc, Trunc, Origin(),
13791             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
13792     root-&gt;appendNew&lt;Value&gt;(
13793         proc, Branch, Origin(),
13794         root-&gt;appendNew&lt;Value&gt;(
13795             proc, BitAnd, Origin(),
13796             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR3),
13797             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0xff)));
13798     root-&gt;setSuccessors(FrequentedBlock(negate), FrequentedBlock(dispatch));
13799 
13800     UpsilonValue* upsilonNegate = negate-&gt;appendNew&lt;UpsilonValue&gt;(
13801         proc, Origin(),
13802         negate-&gt;appendNew&lt;Value&gt;(
13803             proc, Neg, Origin(),
13804             negate-&gt;appendNew&lt;Value&gt;(
13805                 proc, Trunc, Origin(),
13806                 negate-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
13807     negate-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13808     negate-&gt;setSuccessors(FrequentedBlock(dispatch));
13809 
13810     Value* arg0 = dispatch-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
13811     upsilonBase-&gt;setPhi(arg0);
13812     upsilonNegate-&gt;setPhi(arg0);
13813     dispatch-&gt;appendNew&lt;Value&gt;(proc, EntrySwitch, Origin());
13814     dispatch-&gt;appendSuccessor(FrequentedBlock(one));
13815     dispatch-&gt;appendSuccessor(FrequentedBlock(two));
13816     dispatch-&gt;appendSuccessor(FrequentedBlock(three));
13817 
13818     UpsilonValue* upsilonOne = one-&gt;appendNew&lt;UpsilonValue&gt;(
13819         proc, Origin(),
13820         one-&gt;appendNew&lt;Value&gt;(
13821             proc, Add, Origin(),
13822             arg0, one-&gt;appendNew&lt;Value&gt;(
13823                 proc, Trunc, Origin(),
13824                 one-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13825     one-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13826     one-&gt;setSuccessors(FrequentedBlock(end));
13827 
13828     UpsilonValue* upsilonTwo = two-&gt;appendNew&lt;UpsilonValue&gt;(
13829         proc, Origin(),
13830         two-&gt;appendNew&lt;Value&gt;(
13831             proc, Sub, Origin(),
13832             arg0, two-&gt;appendNew&lt;Value&gt;(
13833                 proc, Trunc, Origin(),
13834                 two-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13835     two-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13836     two-&gt;setSuccessors(FrequentedBlock(end));
13837 
13838     UpsilonValue* upsilonThree = three-&gt;appendNew&lt;UpsilonValue&gt;(
13839         proc, Origin(),
13840         three-&gt;appendNew&lt;Value&gt;(
13841             proc, Mul, Origin(),
13842             arg0, three-&gt;appendNew&lt;Value&gt;(
13843                 proc, Trunc, Origin(),
13844                 three-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1))));
13845     three-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13846     three-&gt;setSuccessors(FrequentedBlock(end));
13847 
13848     Value* phi = end-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
13849     upsilonOne-&gt;setPhi(phi);
13850     upsilonTwo-&gt;setPhi(phi);
13851     upsilonThree-&gt;setPhi(phi);
13852 
13853     end-&gt;appendNew&lt;Value&gt;(
13854         proc, Return, Origin(),
13855         end-&gt;appendNew&lt;Value&gt;(
13856             proc, chill(Mod), Origin(),
13857             phi, end-&gt;appendNew&lt;Value&gt;(
13858                 proc, Trunc, Origin(),
13859                 end-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2))));
13860 
13861     prepareForGeneration(proc);
13862 
13863     CCallHelpers jit;
13864     generate(proc, jit);
13865     LinkBuffer linkBuffer(jit, nullptr);
13866     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelOne = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(0));
13867     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelTwo = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(1));
13868     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelThree = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(2));
13869 
13870     MacroAssemblerCodeRef&lt;B3CompilationPtrTag&gt; codeRef = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;testb3 compilation&quot;);
13871 
13872     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 10, false), 3);
13873     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 10, false), -1);
13874     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 10, false), 2);
13875     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 10, false), 1);
13876     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 10, false), -3);
13877     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 10, false), -2);
13878     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 10, true), 1);
13879     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 10, true), -3);
13880     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 10, true), -2);
13881     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 10, true), 3);
13882     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 10, true), -1);
13883     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 10, true), 2);
13884     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 2, false), 1);
13885     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 2, false), -1);
13886     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 2, false), 0);
13887     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 2, false), 1);
13888     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 2, false), -1);
13889     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 2, false), 0);
13890     CHECK_EQ(invoke&lt;int&gt;(labelOne, 1, 2, 0, false), 0);
13891     CHECK_EQ(invoke&lt;int&gt;(labelTwo, 1, 2, 0, false), 0);
13892     CHECK_EQ(invoke&lt;int&gt;(labelThree, 1, 2, 0, false), 0);
13893     CHECK_EQ(invoke&lt;int&gt;(labelOne, -1, 2, 0, false), 0);
13894     CHECK_EQ(invoke&lt;int&gt;(labelTwo, -1, 2, 0, false), 0);
13895     CHECK_EQ(invoke&lt;int&gt;(labelThree, -1, 2, 0, false), 0);
13896 }
13897 
13898 void testEntrySwitchLoop()
13899 {
13900     // This is a completely absurd use of EntrySwitch, where it impacts the loop condition. This
13901     // should cause duplication of either nearly the entire Procedure. At time of writing, we ended
13902     // up duplicating all of it, which is fine. It&#39;s important to test this case, to make sure that
13903     // the duplication algorithm can handle interesting control flow.
13904 
13905     Procedure proc;
13906     proc.setNumEntrypoints(2);
13907 
13908     BasicBlock* root = proc.addBlock();
13909     BasicBlock* loopHeader = proc.addBlock();
13910     BasicBlock* loopFooter = proc.addBlock();
13911     BasicBlock* end = proc.addBlock();
13912 
13913     UpsilonValue* initialValue = root-&gt;appendNew&lt;UpsilonValue&gt;(
13914         proc, Origin(), root-&gt;appendNew&lt;Value&gt;(
13915             proc, Trunc, Origin(),
13916             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
13917     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
13918     root-&gt;setSuccessors(loopHeader);
13919 
13920     Value* valueInLoop = loopHeader-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
13921     initialValue-&gt;setPhi(valueInLoop);
13922     Value* newValue = loopHeader-&gt;appendNew&lt;Value&gt;(
13923         proc, Add, Origin(), valueInLoop,
13924         loopHeader-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
13925     loopHeader-&gt;appendNew&lt;Value&gt;(proc, EntrySwitch, Origin());
13926     loopHeader-&gt;appendSuccessor(end);
13927     loopHeader-&gt;appendSuccessor(loopFooter);
13928 
13929     loopFooter-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newValue, valueInLoop);
13930     loopFooter-&gt;appendNew&lt;Value&gt;(
13931         proc, Branch, Origin(),
13932         loopFooter-&gt;appendNew&lt;Value&gt;(
13933             proc, LessThan, Origin(), newValue,
13934             loopFooter-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 100)));
13935     loopFooter-&gt;setSuccessors(loopHeader, end);
13936 
13937     end-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), newValue);
13938 
13939     prepareForGeneration(proc);
13940 
13941     CCallHelpers jit;
13942     generate(proc, jit);
13943     LinkBuffer linkBuffer(jit, nullptr);
13944     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelOne = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(0));
13945     CodeLocationLabel&lt;B3CompilationPtrTag&gt; labelTwo = linkBuffer.locationOf&lt;B3CompilationPtrTag&gt;(proc.entrypointLabel(1));
13946 
13947     MacroAssemblerCodeRef&lt;B3CompilationPtrTag&gt; codeRef = FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;testb3 compilation&quot;);
13948 
13949     CHECK(invoke&lt;int&gt;(labelOne, 0) == 1);
13950     CHECK(invoke&lt;int&gt;(labelOne, 42) == 43);
13951     CHECK(invoke&lt;int&gt;(labelOne, 1000) == 1001);
13952 
13953     CHECK(invoke&lt;int&gt;(labelTwo, 0) == 100);
13954     CHECK(invoke&lt;int&gt;(labelTwo, 42) == 100);
13955     CHECK(invoke&lt;int&gt;(labelTwo, 1000) == 1001);
13956 }
13957 
13958 void testSomeEarlyRegister()
13959 {
13960     auto run = [&amp;] (bool succeed) {
13961         Procedure proc;
13962 
13963         BasicBlock* root = proc.addBlock();
13964 
13965         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
13966         patchpoint-&gt;resultConstraint = ValueRep::reg(GPRInfo::returnValueGPR);
13967         bool ranFirstPatchpoint = false;
13968         patchpoint-&gt;setGenerator(
13969             [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
13970                 CHECK(params[0].gpr() == GPRInfo::returnValueGPR);
13971                 ranFirstPatchpoint = true;
13972             });
13973 
13974         Value* arg = patchpoint;
13975 
13976         patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
13977         patchpoint-&gt;appendSomeRegister(arg);
13978         if (succeed)
13979             patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;
13980         bool ranSecondPatchpoint = false;
13981         patchpoint-&gt;setGenerator(
13982             [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
13983                 if (succeed)
13984                     CHECK(params[0].gpr() != params[1].gpr());
13985                 else
13986                     CHECK(params[0].gpr() == params[1].gpr());
13987                 ranSecondPatchpoint = true;
13988             });
13989 
13990         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
13991 
13992         compileProc(proc);
13993         CHECK(ranFirstPatchpoint);
13994         CHECK(ranSecondPatchpoint);
13995     };
13996 
13997     run(true);
13998     run(false);
13999 }
14000 
14001 void testBranchBitAndImmFusion(
14002     B3::Opcode valueModifier, Type valueType, int64_t constant,
14003     Air::Opcode expectedOpcode, Air::Arg::Kind firstKind)
14004 {
14005     // Currently this test should pass on all CPUs. But some CPUs may not support this fused
14006     // instruction. It&#39;s OK to skip this test on those CPUs.
14007 
14008     Procedure proc;
14009 
14010     BasicBlock* root = proc.addBlock();
14011     BasicBlock* one = proc.addBlock();
14012     BasicBlock* two = proc.addBlock();
14013 
14014     Value* left = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
14015 
14016     if (valueModifier != Identity) {
14017         if (MemoryValue::accepts(valueModifier))
14018             left = root-&gt;appendNew&lt;MemoryValue&gt;(proc, valueModifier, valueType, Origin(), left);
14019         else
14020             left = root-&gt;appendNew&lt;Value&gt;(proc, valueModifier, valueType, Origin(), left);
14021     }
14022 
14023     root-&gt;appendNew&lt;Value&gt;(
14024         proc, Branch, Origin(),
14025         root-&gt;appendNew&lt;Value&gt;(
14026             proc, BitAnd, Origin(), left,
14027             root-&gt;appendIntConstant(proc, Origin(), valueType, constant)));
14028     root-&gt;setSuccessors(FrequentedBlock(one), FrequentedBlock(two));
14029 
14030     one-&gt;appendNew&lt;Value&gt;(proc, Oops, Origin());
14031     two-&gt;appendNew&lt;Value&gt;(proc, Oops, Origin());
14032 
14033     lowerToAirForTesting(proc);
14034 
14035     // The first basic block must end in a BranchTest64(resCond, tmp, bitImm).
14036     Air::Inst terminal = proc.code()[0]-&gt;last();
14037     CHECK_EQ(terminal.kind.opcode, expectedOpcode);
14038     CHECK_EQ(terminal.args[0].kind(), Air::Arg::ResCond);
14039     CHECK_EQ(terminal.args[1].kind(), firstKind);
14040     CHECK(terminal.args[2].kind() == Air::Arg::BitImm || terminal.args[2].kind() == Air::Arg::BitImm64);
14041 }
14042 
14043 void testTerminalPatchpointThatNeedsToBeSpilled()
14044 {
14045     // This is a unit test for how FTL&#39;s heap allocation fast paths behave.
14046     Procedure proc;
14047 
14048     BasicBlock* root = proc.addBlock();
14049     BasicBlock* success = proc.addBlock();
14050     BasicBlock* slowPath = proc.addBlock();
14051 
14052     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
14053     patchpoint-&gt;effects.terminal = true;
14054     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14055 
14056     root-&gt;appendSuccessor(success);
14057     root-&gt;appendSuccessor(FrequentedBlock(slowPath, FrequencyClass::Rare));
14058 
14059     patchpoint-&gt;setGenerator(
14060         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14061             AllowMacroScratchRegisterUsage allowScratch(jit);
14062             jit.move(CCallHelpers::TrustedImm32(42), params[0].gpr());
14063 
14064             CCallHelpers::Jump jumpToSuccess;
14065             if (!params.fallsThroughToSuccessor(0))
14066                 jumpToSuccess = jit.jump();
14067 
14068             Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
14069 
14070             params.addLatePath(
14071                 [=] (CCallHelpers&amp; jit) {
14072                     if (jumpToSuccess.isSet())
14073                         jumpToSuccess.linkTo(*labels[0], &amp;jit);
14074                 });
14075         });
14076 
14077     Vector&lt;Value*&gt; args;
14078     {
14079         RegisterSet fillAllGPRsSet = proc.mutableGPRs();
14080         for (unsigned i = 0; i &lt; fillAllGPRsSet.numberOfSetRegisters(); i++)
14081             args.append(success-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), i));
14082     }
14083 
14084     {
14085         // Now force all values into every available register.
14086         PatchpointValue* p = success-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14087         for (Value* v : args)
14088             p-&gt;append(v, ValueRep::SomeRegister);
14089         p-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
14090     }
14091 
14092     {
14093         // Now require the original patchpoint to be materialized into a register.
14094         PatchpointValue* p = success-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14095         p-&gt;append(patchpoint, ValueRep::SomeRegister);
14096         p-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
14097     }
14098 
14099     success-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), success-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 10));
14100 
14101     slowPath-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), slowPath-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 20));
14102 
14103     auto code = compileProc(proc);
14104     CHECK_EQ(invoke&lt;int&gt;(*code), 10);
14105 }
14106 
14107 void testTerminalPatchpointThatNeedsToBeSpilled2()
14108 {
14109     // This is a unit test for how FTL&#39;s heap allocation fast paths behave.
14110     Procedure proc;
14111 
14112     BasicBlock* root = proc.addBlock();
14113     BasicBlock* one = proc.addBlock();
14114     BasicBlock* success = proc.addBlock();
14115     BasicBlock* slowPath = proc.addBlock();
14116 
14117     Value* arg = root-&gt;appendNew&lt;Value&gt;(
14118         proc, Trunc, Origin(),
14119         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
14120 
14121     root-&gt;appendNew&lt;Value&gt;(
14122         proc, Branch, Origin(), arg);
14123     root-&gt;appendSuccessor(one);
14124     root-&gt;appendSuccessor(FrequentedBlock(slowPath, FrequencyClass::Rare));
14125 
14126     PatchpointValue* patchpoint = one-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
14127     patchpoint-&gt;effects.terminal = true;
14128     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14129     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
14130 
14131     one-&gt;appendSuccessor(success);
14132     one-&gt;appendSuccessor(FrequentedBlock(slowPath, FrequencyClass::Rare));
14133 
14134     patchpoint-&gt;setGenerator(
14135         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14136             AllowMacroScratchRegisterUsage allowScratch(jit);
14137             jit.move(CCallHelpers::TrustedImm32(666), params[0].gpr());
14138             auto goToFastPath = jit.branch32(CCallHelpers::Equal, params[1].gpr(), CCallHelpers::TrustedImm32(42));
14139             auto jumpToSlow = jit.jump();
14140 
14141             // Make sure the asserts here pass.
14142             params.fallsThroughToSuccessor(0);
14143             params.fallsThroughToSuccessor(1);
14144 
14145             Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
14146 
14147             params.addLatePath(
14148                 [=] (CCallHelpers&amp; jit) {
14149                     goToFastPath.linkTo(*labels[0], &amp;jit);
14150                     jumpToSlow.linkTo(*labels[1], &amp;jit);
14151                 });
14152         });
14153 
14154     Vector&lt;Value*&gt; args;
14155     {
14156         RegisterSet fillAllGPRsSet = proc.mutableGPRs();
14157         for (unsigned i = 0; i &lt; fillAllGPRsSet.numberOfSetRegisters(); i++)
14158             args.append(success-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), i));
14159     }
14160 
14161     {
14162         // Now force all values into every available register.
14163         PatchpointValue* p = success-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14164         for (Value* v : args)
14165             p-&gt;append(v, ValueRep::SomeRegister);
14166         p-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
14167     }
14168 
14169     {
14170         // Now require the original patchpoint to be materialized into a register.
14171         PatchpointValue* p = success-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14172         p-&gt;append(patchpoint, ValueRep::SomeRegister);
14173         p-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
14174     }
14175 
14176     success-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
14177 
14178     slowPath-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), arg);
14179 
14180     auto original1 = Options::maxB3TailDupBlockSize();
14181     auto original2 = Options::maxB3TailDupBlockSuccessors();
14182 
14183     // Tail duplication will break the critical edge we&#39;re trying to test because it
14184     // will clone the slowPath block for both edges to it!
14185     Options::maxB3TailDupBlockSize() = 0;
14186     Options::maxB3TailDupBlockSuccessors() = 0;
14187 
14188     auto code = compileProc(proc);
14189     CHECK_EQ(invoke&lt;int&gt;(*code, 1), 1);
14190     CHECK_EQ(invoke&lt;int&gt;(*code, 0), 0);
14191     CHECK_EQ(invoke&lt;int&gt;(*code, 42), 666);
14192 
14193     Options::maxB3TailDupBlockSize() = original1;
14194     Options::maxB3TailDupBlockSuccessors() = original2;
14195 }
14196 
14197 void testPatchpointTerminalReturnValue(bool successIsRare)
14198 {
14199     // This is a unit test for how FTL&#39;s heap allocation fast paths behave.
14200     Procedure proc;
14201 
14202     BasicBlock* root = proc.addBlock();
14203     BasicBlock* success = proc.addBlock();
14204     BasicBlock* slowPath = proc.addBlock();
14205     BasicBlock* continuation = proc.addBlock();
14206 
14207     Value* arg = root-&gt;appendNew&lt;Value&gt;(
14208         proc, Trunc, Origin(),
14209         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
14210 
14211     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
14212     patchpoint-&gt;effects.terminal = true;
14213     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14214 
14215     if (successIsRare) {
14216         root-&gt;appendSuccessor(FrequentedBlock(success, FrequencyClass::Rare));
14217         root-&gt;appendSuccessor(slowPath);
14218     } else {
14219         root-&gt;appendSuccessor(success);
14220         root-&gt;appendSuccessor(FrequentedBlock(slowPath, FrequencyClass::Rare));
14221     }
14222 
14223     patchpoint-&gt;appendSomeRegister(arg);
14224 
14225     patchpoint-&gt;setGenerator(
14226         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14227             AllowMacroScratchRegisterUsage allowScratch(jit);
14228 
14229             CCallHelpers::Jump jumpToSlow =
14230                 jit.branch32(CCallHelpers::Above, params[1].gpr(), CCallHelpers::TrustedImm32(42));
14231 
14232             jit.add32(CCallHelpers::TrustedImm32(31), params[1].gpr(), params[0].gpr());
14233 
14234             CCallHelpers::Jump jumpToSuccess;
14235             if (!params.fallsThroughToSuccessor(0))
14236                 jumpToSuccess = jit.jump();
14237 
14238             Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
14239 
14240             params.addLatePath(
14241                 [=] (CCallHelpers&amp; jit) {
14242                     jumpToSlow.linkTo(*labels[1], &amp;jit);
14243                     if (jumpToSuccess.isSet())
14244                         jumpToSuccess.linkTo(*labels[0], &amp;jit);
14245                 });
14246         });
14247 
14248     UpsilonValue* successUpsilon = success-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), patchpoint);
14249     success-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
14250     success-&gt;setSuccessors(continuation);
14251 
14252     UpsilonValue* slowPathUpsilon = slowPath-&gt;appendNew&lt;UpsilonValue&gt;(
14253         proc, Origin(), slowPath-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 666));
14254     slowPath-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
14255     slowPath-&gt;setSuccessors(continuation);
14256 
14257     Value* phi = continuation-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
14258     successUpsilon-&gt;setPhi(phi);
14259     slowPathUpsilon-&gt;setPhi(phi);
14260     continuation-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), phi);
14261 
14262     auto code = compileProc(proc);
14263     CHECK_EQ(invoke&lt;int&gt;(*code, 0), 31);
14264     CHECK_EQ(invoke&lt;int&gt;(*code, 1), 32);
14265     CHECK_EQ(invoke&lt;int&gt;(*code, 41), 72);
14266     CHECK_EQ(invoke&lt;int&gt;(*code, 42), 73);
14267     CHECK_EQ(invoke&lt;int&gt;(*code, 43), 666);
14268     CHECK_EQ(invoke&lt;int&gt;(*code, -1), 666);
14269 }
14270 
14271 void testMemoryFence()
14272 {
14273     Procedure proc;
14274 
14275     BasicBlock* root = proc.addBlock();
14276 
14277     root-&gt;appendNew&lt;FenceValue&gt;(proc, Origin());
14278     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendIntConstant(proc, Origin(), Int32, 42));
14279 
14280     auto code = compileProc(proc);
14281     CHECK_EQ(invoke&lt;int&gt;(*code), 42);
14282     if (isX86())
14283         checkUsesInstruction(*code, &quot;lock or $0x0, (%rsp)&quot;);
14284     if (isARM64())
14285         checkUsesInstruction(*code, &quot;dmb    ish&quot;);
14286     checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
14287     checkDoesNotUseInstruction(*code, &quot;dmb    ishst&quot;);
14288 }
14289 
14290 void testStoreFence()
14291 {
14292     Procedure proc;
14293 
14294     BasicBlock* root = proc.addBlock();
14295 
14296     root-&gt;appendNew&lt;FenceValue&gt;(proc, Origin(), HeapRange::top(), HeapRange());
14297     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendIntConstant(proc, Origin(), Int32, 42));
14298 
14299     auto code = compileProc(proc);
14300     CHECK_EQ(invoke&lt;int&gt;(*code), 42);
14301     checkDoesNotUseInstruction(*code, &quot;lock&quot;);
14302     checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
14303     if (isARM64())
14304         checkUsesInstruction(*code, &quot;dmb    ishst&quot;);
14305 }
14306 
14307 void testLoadFence()
14308 {
14309     Procedure proc;
14310 
14311     BasicBlock* root = proc.addBlock();
14312 
14313     root-&gt;appendNew&lt;FenceValue&gt;(proc, Origin(), HeapRange(), HeapRange::top());
14314     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), root-&gt;appendIntConstant(proc, Origin(), Int32, 42));
14315 
14316     auto code = compileProc(proc);
14317     CHECK_EQ(invoke&lt;int&gt;(*code), 42);
14318     checkDoesNotUseInstruction(*code, &quot;lock&quot;);
14319     checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
14320     if (isARM64())
14321         checkUsesInstruction(*code, &quot;dmb    ish&quot;);
14322     checkDoesNotUseInstruction(*code, &quot;dmb    ishst&quot;);
14323 }
14324 
14325 void testTrappingLoad()
14326 {
14327     Procedure proc;
14328     BasicBlock* root = proc.addBlock();
14329     int x = 42;
14330     MemoryValue* value = root-&gt;appendNew&lt;MemoryValue&gt;(
14331         proc, trapping(Load), Int32, Origin(),
14332         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x));
14333     Effects expectedEffects;
14334     expectedEffects.exitsSideways = true;
14335     expectedEffects.controlDependent= true;
14336     expectedEffects.reads = HeapRange::top();
14337     CHECK_EQ(value-&gt;range(), HeapRange::top());
14338     CHECK_EQ(value-&gt;effects(), expectedEffects);
14339     value-&gt;setRange(HeapRange(0));
14340     CHECK_EQ(value-&gt;range(), HeapRange(0));
14341     CHECK_EQ(value-&gt;effects(), expectedEffects); // We still reads top!
14342     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), value);
14343     CHECK_EQ(compileAndRun&lt;int&gt;(proc), 42);
14344     unsigned trapsCount = 0;
14345     for (Air::BasicBlock* block : proc.code()) {
14346         for (Air::Inst&amp; inst : *block) {
14347             if (inst.kind.effects)
14348                 trapsCount++;
14349         }
14350     }
14351     CHECK_EQ(trapsCount, 1u);
14352 }
14353 
14354 void testTrappingStore()
14355 {
14356     Procedure proc;
14357     BasicBlock* root = proc.addBlock();
14358     int x = 42;
14359     MemoryValue* value = root-&gt;appendNew&lt;MemoryValue&gt;(
14360         proc, trapping(Store), Origin(),
14361         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 111),
14362         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x), 0);
14363     Effects expectedEffects;
14364     expectedEffects.exitsSideways = true;
14365     expectedEffects.controlDependent= true;
14366     expectedEffects.reads = HeapRange::top();
14367     expectedEffects.writes = HeapRange::top();
14368     CHECK_EQ(value-&gt;range(), HeapRange::top());
14369     CHECK_EQ(value-&gt;effects(), expectedEffects);
14370     value-&gt;setRange(HeapRange(0));
14371     CHECK_EQ(value-&gt;range(), HeapRange(0));
14372     expectedEffects.writes = HeapRange(0);
14373     CHECK_EQ(value-&gt;effects(), expectedEffects); // We still reads top!
14374     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14375     compileAndRun&lt;int&gt;(proc);
14376     CHECK_EQ(x, 111);
14377     unsigned trapsCount = 0;
14378     for (Air::BasicBlock* block : proc.code()) {
14379         for (Air::Inst&amp; inst : *block) {
14380             if (inst.kind.effects)
14381                 trapsCount++;
14382         }
14383     }
14384     CHECK_EQ(trapsCount, 1u);
14385 }
14386 
14387 void testTrappingLoadAddStore()
14388 {
14389     Procedure proc;
14390     BasicBlock* root = proc.addBlock();
14391     int x = 42;
14392     ConstPtrValue* ptr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x);
14393     root-&gt;appendNew&lt;MemoryValue&gt;(
14394         proc, trapping(Store), Origin(),
14395         root-&gt;appendNew&lt;Value&gt;(
14396             proc, Add, Origin(),
14397             root-&gt;appendNew&lt;MemoryValue&gt;(proc, trapping(Load), Int32, Origin(), ptr),
14398             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 3)),
14399         ptr, 0);
14400     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14401     compileAndRun&lt;int&gt;(proc);
14402     CHECK_EQ(x, 45);
14403     bool traps = false;
14404     for (Air::BasicBlock* block : proc.code()) {
14405         for (Air::Inst&amp; inst : *block) {
14406             if (inst.kind.effects)
14407                 traps = true;
14408         }
14409     }
14410     CHECK(traps);
14411 }
14412 
14413 void testTrappingLoadDCE()
14414 {
14415     Procedure proc;
14416     BasicBlock* root = proc.addBlock();
14417     int x = 42;
14418     root-&gt;appendNew&lt;MemoryValue&gt;(
14419         proc, trapping(Load), Int32, Origin(),
14420         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x));
14421     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14422     compileAndRun&lt;int&gt;(proc);
14423     unsigned trapsCount = 0;
14424     for (Air::BasicBlock* block : proc.code()) {
14425         for (Air::Inst&amp; inst : *block) {
14426             if (inst.kind.effects)
14427                 trapsCount++;
14428         }
14429     }
14430     CHECK_EQ(trapsCount, 1u);
14431 }
14432 
14433 void testTrappingStoreElimination()
14434 {
14435     Procedure proc;
14436     BasicBlock* root = proc.addBlock();
14437     int x = 42;
14438     Value* ptr = root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;x);
14439     root-&gt;appendNew&lt;MemoryValue&gt;(
14440         proc, trapping(Store), Origin(),
14441         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 43),
14442         ptr);
14443     root-&gt;appendNew&lt;MemoryValue&gt;(
14444         proc, trapping(Store), Origin(),
14445         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 44),
14446         ptr);
14447     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14448     compileAndRun&lt;int&gt;(proc);
14449     unsigned storeCount = 0;
14450     for (Value* value : proc.values()) {
14451         if (isStore(value-&gt;opcode()))
14452             storeCount++;
14453     }
14454     CHECK_EQ(storeCount, 2u);
14455 }
14456 
14457 void testMoveConstants()
14458 {
14459     auto check = [] (Procedure&amp; proc) {
14460         proc.resetReachability();
14461 
14462         if (shouldBeVerbose()) {
14463             dataLog(&quot;IR before:\n&quot;);
14464             dataLog(proc);
14465         }
14466 
14467         moveConstants(proc);
14468 
14469         if (shouldBeVerbose()) {
14470             dataLog(&quot;IR after:\n&quot;);
14471             dataLog(proc);
14472         }
14473 
14474         UseCounts useCounts(proc);
14475         unsigned count = 0;
14476         for (Value* value : proc.values()) {
14477             if (useCounts.numUses(value) &amp;&amp; value-&gt;hasInt64())
14478                 count++;
14479         }
14480 
14481         if (count == 1)
14482             return;
14483 
14484         crashLock.lock();
14485         dataLog(&quot;Fail in testMoveConstants: got more than one Const64:\n&quot;);
14486         dataLog(proc);
14487         CRASH();
14488     };
14489 
14490     {
14491         Procedure proc;
14492         BasicBlock* root = proc.addBlock();
14493         Value* a = root-&gt;appendNew&lt;MemoryValue&gt;(
14494             proc, Load, pointerType(), Origin(),
14495             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123412341234));
14496         Value* b = root-&gt;appendNew&lt;MemoryValue&gt;(
14497             proc, Load, pointerType(), Origin(),
14498             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123412341334));
14499         root-&gt;appendNew&lt;CCallValue&gt;(proc, Void, Origin(), a, b);
14500         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14501         check(proc);
14502     }
14503 
14504     {
14505         Procedure proc;
14506         BasicBlock* root = proc.addBlock();
14507         Value* x = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
14508         Value* a = root-&gt;appendNew&lt;Value&gt;(
14509             proc, Add, Origin(), x, root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123412341234));
14510         Value* b = root-&gt;appendNew&lt;Value&gt;(
14511             proc, Add, Origin(), x, root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), -0x123412341234));
14512         root-&gt;appendNew&lt;CCallValue&gt;(proc, Void, Origin(), a, b);
14513         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14514         check(proc);
14515     }
14516 }
14517 
14518 void testPCOriginMapDoesntInsertNops()
14519 {
14520     Procedure proc;
14521     BasicBlock* root = proc.addBlock();
14522 
14523     CCallHelpers::Label watchpointLabel;
14524 
14525     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14526     patchpoint-&gt;setGenerator(
14527         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
14528             watchpointLabel = jit.watchpointLabel();
14529         });
14530 
14531     patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14532     patchpoint-&gt;setGenerator(
14533         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
14534             CCallHelpers::Label labelIgnoringWatchpoints = jit.labelIgnoringWatchpoints();
14535 
14536             CHECK(watchpointLabel == labelIgnoringWatchpoints);
14537         });
14538 
14539     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14540 
14541     compileProc(proc);
14542 }
14543 
14544 void testPinRegisters()
14545 {
14546     auto go = [&amp;] (bool pin) {
14547         Procedure proc;
14548         RegisterSet csrs;
14549         csrs.merge(RegisterSet::calleeSaveRegisters());
14550         csrs.exclude(RegisterSet::stackRegisters());
14551         if (pin) {
14552             csrs.forEach(
14553                 [&amp;] (Reg reg) {
14554                     proc.pinRegister(reg);
14555                 });
14556         }
14557         BasicBlock* root = proc.addBlock();
14558         Value* a = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
14559         Value* b = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
14560         Value* c = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
14561         Value* d = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::regCS0);
14562         root-&gt;appendNew&lt;CCallValue&gt;(
14563             proc, Void, Origin(),
14564             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;intptr_t&gt;(0x1234)));
14565         root-&gt;appendNew&lt;CCallValue&gt;(
14566             proc, Void, Origin(),
14567             root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), static_cast&lt;intptr_t&gt;(0x1235)),
14568             a, b, c);
14569         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
14570         patchpoint-&gt;appendSomeRegister(d);
14571         patchpoint-&gt;setGenerator(
14572             [&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
14573                 CHECK_EQ(params[0].gpr(), GPRInfo::regCS0);
14574             });
14575         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14576         auto code = compileProc(proc);
14577         bool usesCSRs = false;
14578         for (Air::BasicBlock* block : proc.code()) {
14579             for (Air::Inst&amp; inst : *block) {
14580                 if (inst.kind.opcode == Air::Patch &amp;&amp; inst.origin == patchpoint)
14581                     continue;
14582                 inst.forEachTmpFast(
14583                     [&amp;] (Air::Tmp tmp) {
14584                         if (tmp.isReg())
14585                             usesCSRs |= csrs.get(tmp.reg());
14586                     });
14587             }
14588         }
14589         for (const RegisterAtOffset&amp; regAtOffset : proc.calleeSaveRegisterAtOffsetList())
14590             usesCSRs |= csrs.get(regAtOffset.reg());
14591         CHECK_EQ(usesCSRs, !pin);
14592     };
14593 
14594     go(true);
14595     go(false);
14596 }
14597 
14598 void testX86LeaAddAddShlLeft()
14599 {
14600     // Add(Add(Shl(@x, $c), @y), $d)
14601     Procedure proc;
14602     BasicBlock* root = proc.addBlock();
14603     Value* result = root-&gt;appendNew&lt;Value&gt;(
14604         proc, Add, Origin(),
14605         root-&gt;appendNew&lt;Value&gt;(
14606             proc, Add, Origin(),
14607             root-&gt;appendNew&lt;Value&gt;(
14608                 proc, Shl, Origin(),
14609                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14610                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)),
14611             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
14612         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
14613     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14614 
14615     auto code = compileProc(proc);
14616     checkUsesInstruction(*code, &quot;lea 0x64(%rdi,%rsi,4), %rax&quot;);
14617     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + (2 &lt;&lt; 2)) + 100);
14618 }
14619 
14620 void testX86LeaAddAddShlRight()
14621 {
14622     // Add(Add(@x, Shl(@y, $c)), $d)
14623     Procedure proc;
14624     BasicBlock* root = proc.addBlock();
14625     Value* result = root-&gt;appendNew&lt;Value&gt;(
14626         proc, Add, Origin(),
14627         root-&gt;appendNew&lt;Value&gt;(
14628             proc, Add, Origin(),
14629             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14630             root-&gt;appendNew&lt;Value&gt;(
14631                 proc, Shl, Origin(),
14632                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14633                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2))),
14634         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
14635     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14636 
14637     auto code = compileProc(proc);
14638     checkUsesInstruction(*code, &quot;lea 0x64(%rdi,%rsi,4), %rax&quot;);
14639     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + (2 &lt;&lt; 2)) + 100);
14640 }
14641 
14642 void testX86LeaAddAdd()
14643 {
14644     // Add(Add(@x, @y), $c)
14645     Procedure proc;
14646     BasicBlock* root = proc.addBlock();
14647     Value* result = root-&gt;appendNew&lt;Value&gt;(
14648         proc, Add, Origin(),
14649         root-&gt;appendNew&lt;Value&gt;(
14650             proc, Add, Origin(),
14651             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14652             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
14653         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 100));
14654     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14655 
14656     auto code = compileProc(proc);
14657     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), (1 + 2) + 100);
14658     checkDisassembly(
14659         *code,
14660         [&amp;] (const char* disassembly) -&gt; bool {
14661             return strstr(disassembly, &quot;lea 0x64(%rdi,%rsi), %rax&quot;)
14662                 || strstr(disassembly, &quot;lea 0x64(%rsi,%rdi), %rax&quot;);
14663         },
14664         &quot;Expected to find something like lea 0x64(%rdi,%rsi), %rax but didn&#39;t!&quot;);
14665 }
14666 
14667 void testX86LeaAddShlRight()
14668 {
14669     // Add(Shl(@x, $c), @y)
14670     Procedure proc;
14671     BasicBlock* root = proc.addBlock();
14672     Value* result = root-&gt;appendNew&lt;Value&gt;(
14673         proc, Add, Origin(),
14674         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14675         root-&gt;appendNew&lt;Value&gt;(
14676             proc, Shl, Origin(),
14677             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14678             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)));
14679     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14680 
14681     auto code = compileProc(proc);
14682     checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,4), %rax&quot;);
14683     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 2));
14684 }
14685 
14686 void testX86LeaAddShlLeftScale1()
14687 {
14688     // Add(Shl(@x, $c), @y)
14689     Procedure proc;
14690     BasicBlock* root = proc.addBlock();
14691     Value* result = root-&gt;appendNew&lt;Value&gt;(
14692         proc, Add, Origin(),
14693         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14694         root-&gt;appendNew&lt;Value&gt;(
14695             proc, Shl, Origin(),
14696             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14697             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
14698     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14699 
14700     auto code = compileProc(proc);
14701     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + 2);
14702     checkDisassembly(
14703         *code,
14704         [&amp;] (const char* disassembly) -&gt; bool {
14705             return strstr(disassembly, &quot;lea (%rdi,%rsi), %rax&quot;)
14706                 || strstr(disassembly, &quot;lea (%rsi,%rdi), %rax&quot;);
14707         },
14708         &quot;Expected to find something like lea (%rdi,%rsi), %rax but didn&#39;t!&quot;);
14709 }
14710 
14711 void testX86LeaAddShlLeftScale2()
14712 {
14713     // Add(Shl(@x, $c), @y)
14714     Procedure proc;
14715     BasicBlock* root = proc.addBlock();
14716     Value* result = root-&gt;appendNew&lt;Value&gt;(
14717         proc, Add, Origin(),
14718         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14719         root-&gt;appendNew&lt;Value&gt;(
14720             proc, Shl, Origin(),
14721             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14722             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
14723     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14724 
14725     auto code = compileProc(proc);
14726     checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,2), %rax&quot;);
14727     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 1));
14728 }
14729 
14730 void testX86LeaAddShlLeftScale4()
14731 {
14732     // Add(Shl(@x, $c), @y)
14733     Procedure proc;
14734     BasicBlock* root = proc.addBlock();
14735     Value* result = root-&gt;appendNew&lt;Value&gt;(
14736         proc, Add, Origin(),
14737         root-&gt;appendNew&lt;Value&gt;(
14738             proc, Shl, Origin(),
14739             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14740             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)),
14741         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
14742     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14743 
14744     auto code = compileProc(proc);
14745     checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,4), %rax&quot;);
14746     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 2));
14747 }
14748 
14749 void testX86LeaAddShlLeftScale8()
14750 {
14751     // Add(Shl(@x, $c), @y)
14752     Procedure proc;
14753     BasicBlock* root = proc.addBlock();
14754     Value* result = root-&gt;appendNew&lt;Value&gt;(
14755         proc, Add, Origin(),
14756         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14757         root-&gt;appendNew&lt;Value&gt;(
14758             proc, Shl, Origin(),
14759             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14760             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 3)));
14761     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14762 
14763     auto code = compileProc(proc);
14764     checkUsesInstruction(*code, &quot;lea (%rdi,%rsi,8), %rax&quot;);
14765     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 3));
14766 }
14767 
14768 void testAddShl32()
14769 {
14770     // Add(Shl(@x, $c), @y)
14771     Procedure proc;
14772     BasicBlock* root = proc.addBlock();
14773     Value* result = root-&gt;appendNew&lt;Value&gt;(
14774         proc, Add, Origin(),
14775         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14776         root-&gt;appendNew&lt;Value&gt;(
14777             proc, Shl, Origin(),
14778             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14779             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 32)));
14780     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14781 
14782     auto code = compileProc(proc);
14783     CHECK_EQ(invoke&lt;int64_t&gt;(*code, 1, 2), 1 + (static_cast&lt;int64_t&gt;(2) &lt;&lt; static_cast&lt;int64_t&gt;(32)));
14784 }
14785 
14786 void testAddShl64()
14787 {
14788     // Add(Shl(@x, $c), @y)
14789     Procedure proc;
14790     BasicBlock* root = proc.addBlock();
14791     Value* result = root-&gt;appendNew&lt;Value&gt;(
14792         proc, Add, Origin(),
14793         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14794         root-&gt;appendNew&lt;Value&gt;(
14795             proc, Shl, Origin(),
14796             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14797             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 64)));
14798     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14799 
14800     auto code = compileProc(proc);
14801     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + 2);
14802 }
14803 
14804 void testAddShl65()
14805 {
14806     // Add(Shl(@x, $c), @y)
14807     Procedure proc;
14808     BasicBlock* root = proc.addBlock();
14809     Value* result = root-&gt;appendNew&lt;Value&gt;(
14810         proc, Add, Origin(),
14811         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14812         root-&gt;appendNew&lt;Value&gt;(
14813             proc, Shl, Origin(),
14814             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14815             root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 65)));
14816     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), result);
14817 
14818     auto code = compileProc(proc);
14819     CHECK_EQ(invoke&lt;intptr_t&gt;(*code, 1, 2), 1 + (2 &lt;&lt; 1));
14820 }
14821 
14822 void testReduceStrengthReassociation(bool flip)
14823 {
14824     // Add(Add(@x, $c), @y) -&gt; Add(Add(@x, @y), $c)
14825     // and
14826     // Add(@y, Add(@x, $c)) -&gt; Add(Add(@x, @y), $c)
14827     Procedure proc;
14828     BasicBlock* root = proc.addBlock();
14829     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
14830     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
14831 
14832     Value* innerAdd = root-&gt;appendNew&lt;Value&gt;(
14833         proc, Add, Origin(), arg1,
14834         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 42));
14835 
14836     Value* outerAdd;
14837     if (flip)
14838         outerAdd = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arg2, innerAdd);
14839     else
14840         outerAdd = root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), innerAdd, arg2);
14841 
14842     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), outerAdd);
14843 
14844     proc.resetReachability();
14845 
14846     if (shouldBeVerbose()) {
14847         dataLog(&quot;IR before reduceStrength:\n&quot;);
14848         dataLog(proc);
14849     }
14850 
14851     reduceStrength(proc);
14852 
14853     if (shouldBeVerbose()) {
14854         dataLog(&quot;IR after reduceStrength:\n&quot;);
14855         dataLog(proc);
14856     }
14857 
14858     CHECK_EQ(root-&gt;last()-&gt;opcode(), Return);
14859     CHECK_EQ(root-&gt;last()-&gt;child(0)-&gt;opcode(), Add);
14860     CHECK(root-&gt;last()-&gt;child(0)-&gt;child(1)-&gt;isIntPtr(42));
14861     CHECK_EQ(root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;opcode(), Add);
14862     CHECK(
14863         (root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(0) == arg1 &amp;&amp; root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(1) == arg2) ||
14864         (root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(0) == arg2 &amp;&amp; root-&gt;last()-&gt;child(0)-&gt;child(0)-&gt;child(1) == arg1));
14865 }
14866 
14867 void testLoadBaseIndexShift2()
14868 {
14869     Procedure proc;
14870     BasicBlock* root = proc.addBlock();
14871     root-&gt;appendNew&lt;Value&gt;(
14872         proc, Return, Origin(),
14873         root-&gt;appendNew&lt;MemoryValue&gt;(
14874             proc, Load, Int32, Origin(),
14875             root-&gt;appendNew&lt;Value&gt;(
14876                 proc, Add, Origin(),
14877                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14878                 root-&gt;appendNew&lt;Value&gt;(
14879                     proc, Shl, Origin(),
14880                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14881                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2)))));
14882     auto code = compileProc(proc);
14883     if (isX86())
14884         checkUsesInstruction(*code, &quot;(%rdi,%rsi,4)&quot;);
14885     int32_t value = 12341234;
14886     char* ptr = bitwise_cast&lt;char*&gt;(&amp;value);
14887     for (unsigned i = 0; i &lt; 10; ++i)
14888         CHECK_EQ(invoke&lt;int32_t&gt;(*code, ptr - (static_cast&lt;intptr_t&gt;(1) &lt;&lt; static_cast&lt;intptr_t&gt;(2)) * i, i), 12341234);
14889 }
14890 
14891 void testLoadBaseIndexShift32()
14892 {
14893 #if CPU(ADDRESS64)
14894     Procedure proc;
14895     BasicBlock* root = proc.addBlock();
14896     root-&gt;appendNew&lt;Value&gt;(
14897         proc, Return, Origin(),
14898         root-&gt;appendNew&lt;MemoryValue&gt;(
14899             proc, Load, Int32, Origin(),
14900             root-&gt;appendNew&lt;Value&gt;(
14901                 proc, Add, Origin(),
14902                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
14903                 root-&gt;appendNew&lt;Value&gt;(
14904                     proc, Shl, Origin(),
14905                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
14906                     root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 32)))));
14907     auto code = compileProc(proc);
14908     int32_t value = 12341234;
14909     char* ptr = bitwise_cast&lt;char*&gt;(&amp;value);
14910     for (unsigned i = 0; i &lt; 10; ++i)
14911         CHECK_EQ(invoke&lt;int32_t&gt;(*code, ptr - (static_cast&lt;intptr_t&gt;(1) &lt;&lt; static_cast&lt;intptr_t&gt;(32)) * i, i), 12341234);
14912 #endif
14913 }
14914 
14915 void testOptimizeMaterialization()
14916 {
14917     Procedure proc;
14918     BasicBlock* root = proc.addBlock();
14919     root-&gt;appendNew&lt;CCallValue&gt;(
14920         proc, Void, Origin(),
14921         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123423453456llu),
14922         root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), 0x123423453456llu + 35));
14923     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14924 
14925     auto code = compileProc(proc);
14926     bool found = false;
14927     for (Air::BasicBlock* block : proc.code()) {
14928         for (Air::Inst&amp; inst : *block) {
14929             if (inst.kind.opcode != Air::Add64)
14930                 continue;
14931             if (inst.args[0] != Air::Arg::imm(35))
14932                 continue;
14933             found = true;
14934         }
14935     }
14936     CHECK(found);
14937 }
14938 
14939 template&lt;typename Func&gt;
14940 void generateLoop(Procedure&amp; proc, const Func&amp; func)
14941 {
14942     BasicBlock* root = proc.addBlock();
14943     BasicBlock* loop = proc.addBlock();
14944     BasicBlock* end = proc.addBlock();
14945 
14946     UpsilonValue* initialIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(
14947         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
14948     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
14949     root-&gt;setSuccessors(loop);
14950 
14951     Value* index = loop-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
14952     initialIndex-&gt;setPhi(index);
14953 
14954     Value* one = func(loop, index);
14955 
14956     Value* nextIndex = loop-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
14957     UpsilonValue* loopIndex = loop-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), nextIndex);
14958     loopIndex-&gt;setPhi(index);
14959     loop-&gt;appendNew&lt;Value&gt;(
14960         proc, Branch, Origin(),
14961         loop-&gt;appendNew&lt;Value&gt;(
14962             proc, LessThan, Origin(), nextIndex,
14963             loop-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 100)));
14964     loop-&gt;setSuccessors(loop, end);
14965 
14966     end-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
14967 }
14968 
14969 std::array&lt;int, 100&gt; makeArrayForLoops()
14970 {
14971     std::array&lt;int, 100&gt; result;
14972     for (unsigned i = 0; i &lt; result.size(); ++i)
14973         result[i] = i &amp; 1;
14974     return result;
14975 }
14976 
14977 template&lt;typename Func&gt;
14978 void generateLoopNotBackwardsDominant(Procedure&amp; proc, std::array&lt;int, 100&gt;&amp; array, const Func&amp; func)
14979 {
14980     BasicBlock* root = proc.addBlock();
14981     BasicBlock* loopHeader = proc.addBlock();
14982     BasicBlock* loopCall = proc.addBlock();
14983     BasicBlock* loopFooter = proc.addBlock();
14984     BasicBlock* end = proc.addBlock();
14985 
14986     UpsilonValue* initialIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(
14987         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
14988     // If you look carefully, you&#39;ll notice that this is an extremely sneaky use of Upsilon that demonstrates
14989     // the extent to which our SSA is different from normal-person SSA.
14990     UpsilonValue* defaultOne = root-&gt;appendNew&lt;UpsilonValue&gt;(
14991         proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1));
14992     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
14993     root-&gt;setSuccessors(loopHeader);
14994 
14995     Value* index = loopHeader-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
14996     initialIndex-&gt;setPhi(index);
14997 
14998     // if (array[index])
14999     loopHeader-&gt;appendNew&lt;Value&gt;(
15000         proc, Branch, Origin(),
15001         loopHeader-&gt;appendNew&lt;MemoryValue&gt;(
15002             proc, Load, Int32, Origin(),
15003             loopHeader-&gt;appendNew&lt;Value&gt;(
15004                 proc, Add, Origin(),
15005                 loopHeader-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;array),
15006                 loopHeader-&gt;appendNew&lt;Value&gt;(
15007                     proc, Mul, Origin(),
15008                     loopHeader-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), index),
15009                     loopHeader-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), sizeof(int))))));
15010     loopHeader-&gt;setSuccessors(loopCall, loopFooter);
15011 
15012     Value* functionCall = func(loopCall, index);
15013     UpsilonValue* oneFromFunction = loopCall-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), functionCall);
15014     loopCall-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
15015     loopCall-&gt;setSuccessors(loopFooter);
15016 
15017     Value* one = loopFooter-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
15018     defaultOne-&gt;setPhi(one);
15019     oneFromFunction-&gt;setPhi(one);
15020     Value* nextIndex = loopFooter-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
15021     UpsilonValue* loopIndex = loopFooter-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), nextIndex);
15022     loopIndex-&gt;setPhi(index);
15023     loopFooter-&gt;appendNew&lt;Value&gt;(
15024         proc, Branch, Origin(),
15025         loopFooter-&gt;appendNew&lt;Value&gt;(
15026             proc, LessThan, Origin(), nextIndex,
15027             loopFooter-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 100)));
15028     loopFooter-&gt;setSuccessors(loopHeader, end);
15029 
15030     end-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15031 }
15032 
15033 static int oneFunction(int* callCount)
15034 {
15035     (*callCount)++;
15036     return 1;
15037 }
15038 
15039 static void noOpFunction()
15040 {
15041 }
15042 
15043 void testLICMPure()
15044 {
15045     Procedure proc;
15046     generateLoop(
15047         proc,
15048         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15049             return loop-&gt;appendNew&lt;CCallValue&gt;(
15050                 proc, Int32, Origin(), Effects::none(),
15051                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15052                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15053         });
15054 
15055     unsigned callCount = 0;
15056     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15057     CHECK_EQ(callCount, 1u);
15058 }
15059 
15060 void testLICMPureSideExits()
15061 {
15062     Procedure proc;
15063     generateLoop(
15064         proc,
15065         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15066             Effects effects = Effects::none();
15067             effects.exitsSideways = true;
15068             loop-&gt;appendNew&lt;CCallValue&gt;(
15069                 proc, Void, Origin(), effects,
15070                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15071 
15072             return loop-&gt;appendNew&lt;CCallValue&gt;(
15073                 proc, Int32, Origin(), Effects::none(),
15074                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15075                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15076         });
15077 
15078     unsigned callCount = 0;
15079     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15080     CHECK_EQ(callCount, 1u);
15081 }
15082 
15083 void testLICMPureWritesPinned()
15084 {
15085     Procedure proc;
15086     generateLoop(
15087         proc,
15088         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15089             Effects effects = Effects::none();
15090             effects.writesPinned = true;
15091             loop-&gt;appendNew&lt;CCallValue&gt;(
15092                 proc, Void, Origin(), effects,
15093                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15094 
15095             return loop-&gt;appendNew&lt;CCallValue&gt;(
15096                 proc, Int32, Origin(), Effects::none(),
15097                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15098                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15099         });
15100 
15101     unsigned callCount = 0;
15102     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15103     CHECK_EQ(callCount, 1u);
15104 }
15105 
15106 void testLICMPureWrites()
15107 {
15108     Procedure proc;
15109     generateLoop(
15110         proc,
15111         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15112             Effects effects = Effects::none();
15113             effects.writes = HeapRange(63479);
15114             loop-&gt;appendNew&lt;CCallValue&gt;(
15115                 proc, Void, Origin(), effects,
15116                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15117 
15118             return loop-&gt;appendNew&lt;CCallValue&gt;(
15119                 proc, Int32, Origin(), Effects::none(),
15120                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15121                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15122         });
15123 
15124     unsigned callCount = 0;
15125     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15126     CHECK_EQ(callCount, 1u);
15127 }
15128 
15129 void testLICMReadsLocalState()
15130 {
15131     Procedure proc;
15132     generateLoop(
15133         proc,
15134         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15135             Effects effects = Effects::none();
15136             effects.readsLocalState = true;
15137             return loop-&gt;appendNew&lt;CCallValue&gt;(
15138                 proc, Int32, Origin(), effects,
15139                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15140                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15141         });
15142 
15143     unsigned callCount = 0;
15144     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15145     CHECK_EQ(callCount, 100u); // We&#39;ll fail to hoist because the loop has Upsilons.
15146 }
15147 
15148 void testLICMReadsPinned()
15149 {
15150     Procedure proc;
15151     generateLoop(
15152         proc,
15153         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15154             Effects effects = Effects::none();
15155             effects.readsPinned = true;
15156             return loop-&gt;appendNew&lt;CCallValue&gt;(
15157                 proc, Int32, Origin(), effects,
15158                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15159                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15160         });
15161 
15162     unsigned callCount = 0;
15163     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15164     CHECK_EQ(callCount, 1u);
15165 }
15166 
15167 void testLICMReads()
15168 {
15169     Procedure proc;
15170     generateLoop(
15171         proc,
15172         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15173             Effects effects = Effects::none();
15174             effects.reads = HeapRange::top();
15175             return loop-&gt;appendNew&lt;CCallValue&gt;(
15176                 proc, Int32, Origin(), effects,
15177                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15178                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15179         });
15180 
15181     unsigned callCount = 0;
15182     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15183     CHECK_EQ(callCount, 1u);
15184 }
15185 
15186 void testLICMPureNotBackwardsDominant()
15187 {
15188     Procedure proc;
15189     auto array = makeArrayForLoops();
15190     generateLoopNotBackwardsDominant(
15191         proc, array,
15192         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15193             return loop-&gt;appendNew&lt;CCallValue&gt;(
15194                 proc, Int32, Origin(), Effects::none(),
15195                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15196                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15197         });
15198 
15199     unsigned callCount = 0;
15200     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15201     CHECK_EQ(callCount, 1u);
15202 }
15203 
15204 void testLICMPureFoiledByChild()
15205 {
15206     Procedure proc;
15207     generateLoop(
15208         proc,
15209         [&amp;] (BasicBlock* loop, Value* index) -&gt; Value* {
15210             return loop-&gt;appendNew&lt;CCallValue&gt;(
15211                 proc, Int32, Origin(), Effects::none(),
15212                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15213                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
15214                 index);
15215         });
15216 
15217     unsigned callCount = 0;
15218     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15219     CHECK_EQ(callCount, 100u);
15220 }
15221 
15222 void testLICMPureNotBackwardsDominantFoiledByChild()
15223 {
15224     Procedure proc;
15225     auto array = makeArrayForLoops();
15226     generateLoopNotBackwardsDominant(
15227         proc, array,
15228         [&amp;] (BasicBlock* loop, Value* index) -&gt; Value* {
15229             return loop-&gt;appendNew&lt;CCallValue&gt;(
15230                 proc, Int32, Origin(), Effects::none(),
15231                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15232                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
15233                 index);
15234         });
15235 
15236     unsigned callCount = 0;
15237     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15238     CHECK_EQ(callCount, 50u);
15239 }
15240 
15241 void testLICMExitsSideways()
15242 {
15243     Procedure proc;
15244     generateLoop(
15245         proc,
15246         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15247             Effects effects = Effects::none();
15248             effects.exitsSideways = true;
15249             return loop-&gt;appendNew&lt;CCallValue&gt;(
15250                 proc, Int32, Origin(), effects,
15251                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15252                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15253         });
15254 
15255     unsigned callCount = 0;
15256     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15257     CHECK_EQ(callCount, 100u);
15258 }
15259 
15260 void testLICMWritesLocalState()
15261 {
15262     Procedure proc;
15263     generateLoop(
15264         proc,
15265         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15266             Effects effects = Effects::none();
15267             effects.writesLocalState = true;
15268             return loop-&gt;appendNew&lt;CCallValue&gt;(
15269                 proc, Int32, Origin(), effects,
15270                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15271                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15272         });
15273 
15274     unsigned callCount = 0;
15275     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15276     CHECK_EQ(callCount, 100u);
15277 }
15278 
15279 void testLICMWrites()
15280 {
15281     Procedure proc;
15282     generateLoop(
15283         proc,
15284         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15285             Effects effects = Effects::none();
15286             effects.writes = HeapRange(666);
15287             return loop-&gt;appendNew&lt;CCallValue&gt;(
15288                 proc, Int32, Origin(), effects,
15289                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15290                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15291         });
15292 
15293     unsigned callCount = 0;
15294     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15295     CHECK_EQ(callCount, 100u);
15296 }
15297 
15298 void testLICMFence()
15299 {
15300     Procedure proc;
15301     generateLoop(
15302         proc,
15303         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15304             Effects effects = Effects::none();
15305             effects.fence = true;
15306             return loop-&gt;appendNew&lt;CCallValue&gt;(
15307                 proc, Int32, Origin(), effects,
15308                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15309                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15310         });
15311 
15312     unsigned callCount = 0;
15313     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15314     CHECK_EQ(callCount, 100u);
15315 }
15316 
15317 void testLICMWritesPinned()
15318 {
15319     Procedure proc;
15320     generateLoop(
15321         proc,
15322         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15323             Effects effects = Effects::none();
15324             effects.writesPinned = true;
15325             return loop-&gt;appendNew&lt;CCallValue&gt;(
15326                 proc, Int32, Origin(), effects,
15327                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15328                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15329         });
15330 
15331     unsigned callCount = 0;
15332     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15333     CHECK_EQ(callCount, 100u);
15334 }
15335 
15336 void testLICMControlDependent()
15337 {
15338     Procedure proc;
15339     generateLoop(
15340         proc,
15341         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15342             Effects effects = Effects::none();
15343             effects.controlDependent = true;
15344             return loop-&gt;appendNew&lt;CCallValue&gt;(
15345                 proc, Int32, Origin(), effects,
15346                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15347                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15348         });
15349 
15350     unsigned callCount = 0;
15351     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15352     CHECK_EQ(callCount, 1u);
15353 }
15354 
15355 void testLICMControlDependentNotBackwardsDominant()
15356 {
15357     Procedure proc;
15358     auto array = makeArrayForLoops();
15359     generateLoopNotBackwardsDominant(
15360         proc, array,
15361         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15362             Effects effects = Effects::none();
15363             effects.controlDependent = true;
15364             return loop-&gt;appendNew&lt;CCallValue&gt;(
15365                 proc, Int32, Origin(), effects,
15366                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15367                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15368         });
15369 
15370     unsigned callCount = 0;
15371     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15372     CHECK_EQ(callCount, 50u);
15373 }
15374 
15375 void testLICMControlDependentSideExits()
15376 {
15377     Procedure proc;
15378     generateLoop(
15379         proc,
15380         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15381             Effects effects = Effects::none();
15382             effects.exitsSideways = true;
15383             loop-&gt;appendNew&lt;CCallValue&gt;(
15384                 proc, Void, Origin(), effects,
15385                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15386 
15387             effects = Effects::none();
15388             effects.controlDependent = true;
15389             return loop-&gt;appendNew&lt;CCallValue&gt;(
15390                 proc, Int32, Origin(), effects,
15391                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15392                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15393         });
15394 
15395     unsigned callCount = 0;
15396     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15397     CHECK_EQ(callCount, 100u);
15398 }
15399 
15400 void testLICMReadsPinnedWritesPinned()
15401 {
15402     Procedure proc;
15403     generateLoop(
15404         proc,
15405         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15406             Effects effects = Effects::none();
15407             effects.writesPinned = true;
15408             loop-&gt;appendNew&lt;CCallValue&gt;(
15409                 proc, Void, Origin(), effects,
15410                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15411 
15412             effects = Effects::none();
15413             effects.readsPinned = true;
15414             return loop-&gt;appendNew&lt;CCallValue&gt;(
15415                 proc, Int32, Origin(), effects,
15416                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15417                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15418         });
15419 
15420     unsigned callCount = 0;
15421     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15422     CHECK_EQ(callCount, 100u);
15423 }
15424 
15425 void testLICMReadsWritesDifferentHeaps()
15426 {
15427     Procedure proc;
15428     generateLoop(
15429         proc,
15430         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15431             Effects effects = Effects::none();
15432             effects.writes = HeapRange(6436);
15433             loop-&gt;appendNew&lt;CCallValue&gt;(
15434                 proc, Void, Origin(), effects,
15435                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15436 
15437             effects = Effects::none();
15438             effects.reads = HeapRange(4886);
15439             return loop-&gt;appendNew&lt;CCallValue&gt;(
15440                 proc, Int32, Origin(), effects,
15441                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15442                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15443         });
15444 
15445     unsigned callCount = 0;
15446     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15447     CHECK_EQ(callCount, 1u);
15448 }
15449 
15450 void testLICMReadsWritesOverlappingHeaps()
15451 {
15452     Procedure proc;
15453     generateLoop(
15454         proc,
15455         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15456             Effects effects = Effects::none();
15457             effects.writes = HeapRange(6436, 74458);
15458             loop-&gt;appendNew&lt;CCallValue&gt;(
15459                 proc, Void, Origin(), effects,
15460                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(noOpFunction, B3CCallPtrTag)));
15461 
15462             effects = Effects::none();
15463             effects.reads = HeapRange(48864, 78239);
15464             return loop-&gt;appendNew&lt;CCallValue&gt;(
15465                 proc, Int32, Origin(), effects,
15466                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15467                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15468         });
15469 
15470     unsigned callCount = 0;
15471     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15472     CHECK_EQ(callCount, 100u);
15473 }
15474 
15475 void testLICMDefaultCall()
15476 {
15477     Procedure proc;
15478     generateLoop(
15479         proc,
15480         [&amp;] (BasicBlock* loop, Value*) -&gt; Value* {
15481             return loop-&gt;appendNew&lt;CCallValue&gt;(
15482                 proc, Int32, Origin(),
15483                 loop-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(oneFunction, B3CCallPtrTag)),
15484                 loop-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
15485         });
15486 
15487     unsigned callCount = 0;
15488     compileAndRun&lt;void&gt;(proc, &amp;callCount);
15489     CHECK_EQ(callCount, 100u);
15490 }
15491 
15492 template&lt;typename T&gt;
15493 void testAtomicWeakCAS()
15494 {
15495     Type type = NativeTraits&lt;T&gt;::type;
15496     Width width = NativeTraits&lt;T&gt;::width;
15497 
15498     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
15499         if (isX86()) {
15500             checkUsesInstruction(compilation, &quot;lock&quot;);
15501             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
15502         } else {
15503             if (fenced) {
15504                 checkUsesInstruction(compilation, &quot;ldax&quot;);
15505                 checkUsesInstruction(compilation, &quot;stlx&quot;);
15506             } else {
15507                 checkUsesInstruction(compilation, &quot;ldx&quot;);
15508                 checkUsesInstruction(compilation, &quot;stx&quot;);
15509             }
15510         }
15511     };
15512 
15513     {
15514         Procedure proc;
15515         BasicBlock* root = proc.addBlock();
15516         BasicBlock* reloop = proc.addBlock();
15517         BasicBlock* done = proc.addBlock();
15518 
15519         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15520         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
15521         root-&gt;setSuccessors(reloop);
15522 
15523         reloop-&gt;appendNew&lt;Value&gt;(
15524             proc, Branch, Origin(),
15525             reloop-&gt;appendNew&lt;AtomicValue&gt;(
15526                 proc, AtomicWeakCAS, Origin(), width,
15527                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
15528                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15529                 ptr));
15530         reloop-&gt;setSuccessors(done, reloop);
15531 
15532         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15533 
15534         auto code = compileProc(proc);
15535         T value[2];
15536         value[0] = 42;
15537         value[1] = 13;
15538         invoke&lt;void&gt;(*code, value);
15539         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15540         CHECK_EQ(value[1], 13);
15541         checkMyDisassembly(*code, true);
15542     }
15543 
15544     {
15545         Procedure proc;
15546         BasicBlock* root = proc.addBlock();
15547         BasicBlock* reloop = proc.addBlock();
15548         BasicBlock* done = proc.addBlock();
15549 
15550         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15551         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
15552         root-&gt;setSuccessors(reloop);
15553 
15554         reloop-&gt;appendNew&lt;Value&gt;(
15555             proc, Branch, Origin(),
15556             reloop-&gt;appendNew&lt;AtomicValue&gt;(
15557                 proc, AtomicWeakCAS, Origin(), width,
15558                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
15559                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15560                 ptr, 0, HeapRange(42), HeapRange()));
15561         reloop-&gt;setSuccessors(done, reloop);
15562 
15563         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15564 
15565         auto code = compileProc(proc);
15566         T value[2];
15567         value[0] = 42;
15568         value[1] = 13;
15569         invoke&lt;void&gt;(*code, value);
15570         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15571         CHECK_EQ(value[1], 13);
15572         checkMyDisassembly(*code, false);
15573     }
15574 
15575     {
15576         Procedure proc;
15577         BasicBlock* root = proc.addBlock();
15578         BasicBlock* succ = proc.addBlock();
15579         BasicBlock* fail = proc.addBlock();
15580 
15581         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15582         root-&gt;appendNew&lt;Value&gt;(
15583             proc, Branch, Origin(),
15584             root-&gt;appendNew&lt;AtomicValue&gt;(
15585                 proc, AtomicWeakCAS, Origin(), width,
15586                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
15587                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15588                 ptr));
15589         root-&gt;setSuccessors(succ, fail);
15590 
15591         succ-&gt;appendNew&lt;MemoryValue&gt;(
15592             proc, storeOpcode(GP, width), Origin(),
15593             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
15594             ptr);
15595         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15596 
15597         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15598 
15599         auto code = compileProc(proc);
15600         T value[2];
15601         value[0] = 42;
15602         value[1] = 13;
15603         while (value[0] == 42)
15604             invoke&lt;void&gt;(*code, value);
15605         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
15606         CHECK_EQ(value[1], 13);
15607         value[0] = static_cast&lt;T&gt;(300);
15608         invoke&lt;void&gt;(*code, value);
15609         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15610         CHECK_EQ(value[1], 13);
15611         checkMyDisassembly(*code, true);
15612     }
15613 
15614     {
15615         Procedure proc;
15616         BasicBlock* root = proc.addBlock();
15617         BasicBlock* succ = proc.addBlock();
15618         BasicBlock* fail = proc.addBlock();
15619 
15620         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15621         root-&gt;appendNew&lt;Value&gt;(
15622             proc, Branch, Origin(),
15623             root-&gt;appendNew&lt;Value&gt;(
15624                 proc, Equal, Origin(),
15625                 root-&gt;appendNew&lt;AtomicValue&gt;(
15626                     proc, AtomicWeakCAS, Origin(), width,
15627                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15628                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15629                     ptr),
15630                 root-&gt;appendIntConstant(proc, Origin(), Int32, 0)));
15631         root-&gt;setSuccessors(fail, succ);
15632 
15633         succ-&gt;appendNew&lt;MemoryValue&gt;(
15634             proc, storeOpcode(GP, width), Origin(),
15635             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
15636             ptr);
15637         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15638 
15639         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15640 
15641         auto code = compileProc(proc);
15642         T value[2];
15643         value[0] = 42;
15644         value[1] = 13;
15645         while (value[0] == 42)
15646             invoke&lt;void&gt;(*code, value);
15647         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
15648         CHECK_EQ(value[1], 13);
15649         value[0] = static_cast&lt;T&gt;(300);
15650         invoke&lt;void&gt;(*code, value);
15651         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15652         CHECK_EQ(value[1], 13);
15653         checkMyDisassembly(*code, true);
15654     }
15655 
15656     {
15657         Procedure proc;
15658         BasicBlock* root = proc.addBlock();
15659         root-&gt;appendNew&lt;Value&gt;(
15660             proc, Return, Origin(),
15661             root-&gt;appendNew&lt;AtomicValue&gt;(
15662                 proc, AtomicWeakCAS, Origin(), width,
15663                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
15664                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15665                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
15666 
15667         auto code = compileProc(proc);
15668         T value[2];
15669         value[0] = 42;
15670         value[1] = 13;
15671         while (!invoke&lt;bool&gt;(*code, value)) { }
15672         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15673         CHECK_EQ(value[1], 13);
15674 
15675         value[0] = static_cast&lt;T&gt;(300);
15676         CHECK(!invoke&lt;bool&gt;(*code, value));
15677         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15678         CHECK_EQ(value[1], 13);
15679         checkMyDisassembly(*code, true);
15680     }
15681 
15682     {
15683         Procedure proc;
15684         BasicBlock* root = proc.addBlock();
15685         root-&gt;appendNew&lt;Value&gt;(
15686             proc, Return, Origin(),
15687             root-&gt;appendNew&lt;Value&gt;(
15688                 proc, Equal, Origin(),
15689                 root-&gt;appendNew&lt;AtomicValue&gt;(
15690                     proc, AtomicWeakCAS, Origin(), width,
15691                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15692                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15693                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
15694                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
15695 
15696         auto code = compileProc(proc);
15697         T value[2];
15698         value[0] = 42;
15699         value[1] = 13;
15700         while (invoke&lt;bool&gt;(*code, value)) { }
15701         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15702         CHECK_EQ(value[1], 13);
15703 
15704         value[0] = static_cast&lt;T&gt;(300);
15705         CHECK(invoke&lt;bool&gt;(*code, value));
15706         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15707         CHECK_EQ(value[1], 13);
15708         checkMyDisassembly(*code, true);
15709     }
15710 
15711     {
15712         Procedure proc;
15713         BasicBlock* root = proc.addBlock();
15714         root-&gt;appendNew&lt;Value&gt;(
15715             proc, Return, Origin(),
15716             root-&gt;appendNew&lt;AtomicValue&gt;(
15717                 proc, AtomicWeakCAS, Origin(), width,
15718                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
15719                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15720                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
15721                 42));
15722 
15723         auto code = compileProc(proc);
15724         T value[2];
15725         value[0] = 42;
15726         value[1] = 13;
15727         while (!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42)) { }
15728         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15729         CHECK_EQ(value[1], 13);
15730 
15731         value[0] = static_cast&lt;T&gt;(300);
15732         CHECK(!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42));
15733         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15734         CHECK_EQ(value[1], 13);
15735         checkMyDisassembly(*code, true);
15736     }
15737 }
15738 
15739 template&lt;typename T&gt;
15740 void testAtomicStrongCAS()
15741 {
15742     Type type = NativeTraits&lt;T&gt;::type;
15743     Width width = NativeTraits&lt;T&gt;::width;
15744 
15745     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
15746         if (isX86()) {
15747             checkUsesInstruction(compilation, &quot;lock&quot;);
15748             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
15749         } else {
15750             if (fenced) {
15751                 checkUsesInstruction(compilation, &quot;ldax&quot;);
15752                 checkUsesInstruction(compilation, &quot;stlx&quot;);
15753             } else {
15754                 checkUsesInstruction(compilation, &quot;ldx&quot;);
15755                 checkUsesInstruction(compilation, &quot;stx&quot;);
15756             }
15757         }
15758     };
15759 
15760     {
15761         Procedure proc;
15762         BasicBlock* root = proc.addBlock();
15763         BasicBlock* succ = proc.addBlock();
15764         BasicBlock* fail = proc.addBlock();
15765 
15766         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15767         root-&gt;appendNew&lt;Value&gt;(
15768             proc, Branch, Origin(),
15769             root-&gt;appendNew&lt;Value&gt;(
15770                 proc, Equal, Origin(),
15771                 root-&gt;appendNew&lt;AtomicValue&gt;(
15772                     proc, AtomicStrongCAS, Origin(), width,
15773                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15774                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15775                     ptr),
15776                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
15777         root-&gt;setSuccessors(succ, fail);
15778 
15779         succ-&gt;appendNew&lt;MemoryValue&gt;(
15780             proc, storeOpcode(GP, width), Origin(),
15781             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
15782             ptr);
15783         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15784 
15785         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15786 
15787         auto code = compileProc(proc);
15788         T value[2];
15789         value[0] = 42;
15790         value[1] = 13;
15791         invoke&lt;void&gt;(*code, value);
15792         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
15793         CHECK_EQ(value[1], 13);
15794         value[0] = static_cast&lt;T&gt;(300);
15795         invoke&lt;void&gt;(*code, value);
15796         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15797         CHECK_EQ(value[1], 13);
15798         checkMyDisassembly(*code, true);
15799     }
15800 
15801     {
15802         Procedure proc;
15803         BasicBlock* root = proc.addBlock();
15804         BasicBlock* succ = proc.addBlock();
15805         BasicBlock* fail = proc.addBlock();
15806 
15807         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15808         root-&gt;appendNew&lt;Value&gt;(
15809             proc, Branch, Origin(),
15810             root-&gt;appendNew&lt;Value&gt;(
15811                 proc, Equal, Origin(),
15812                 root-&gt;appendNew&lt;AtomicValue&gt;(
15813                     proc, AtomicStrongCAS, Origin(), width,
15814                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15815                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15816                     ptr, 0, HeapRange(42), HeapRange()),
15817                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
15818         root-&gt;setSuccessors(succ, fail);
15819 
15820         succ-&gt;appendNew&lt;MemoryValue&gt;(
15821             proc, storeOpcode(GP, width), Origin(),
15822             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
15823             ptr);
15824         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15825 
15826         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15827 
15828         auto code = compileProc(proc);
15829         T value[2];
15830         value[0] = 42;
15831         value[1] = 13;
15832         invoke&lt;void&gt;(*code, value);
15833         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
15834         CHECK_EQ(value[1], 13);
15835         value[0] = static_cast&lt;T&gt;(300);
15836         invoke&lt;void&gt;(*code, value);
15837         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15838         CHECK_EQ(value[1], 13);
15839         checkMyDisassembly(*code, false);
15840     }
15841 
15842     {
15843         Procedure proc;
15844         BasicBlock* root = proc.addBlock();
15845         BasicBlock* succ = proc.addBlock();
15846         BasicBlock* fail = proc.addBlock();
15847 
15848         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
15849         root-&gt;appendNew&lt;Value&gt;(
15850             proc, Branch, Origin(),
15851             root-&gt;appendNew&lt;Value&gt;(
15852                 proc, NotEqual, Origin(),
15853                 root-&gt;appendNew&lt;AtomicValue&gt;(
15854                     proc, AtomicStrongCAS, Origin(), width,
15855                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15856                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15857                     ptr),
15858                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
15859         root-&gt;setSuccessors(fail, succ);
15860 
15861         succ-&gt;appendNew&lt;MemoryValue&gt;(
15862             proc, storeOpcode(GP, width), Origin(),
15863             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
15864             ptr);
15865         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15866 
15867         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
15868 
15869         auto code = compileProc(proc);
15870         T value[2];
15871         value[0] = 42;
15872         value[1] = 13;
15873         invoke&lt;void&gt;(*code, value);
15874         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
15875         CHECK_EQ(value[1], 13);
15876         value[0] = static_cast&lt;T&gt;(300);
15877         invoke&lt;void&gt;(*code, value);
15878         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15879         CHECK_EQ(value[1], 13);
15880         checkMyDisassembly(*code, true);
15881     }
15882 
15883     {
15884         Procedure proc;
15885         BasicBlock* root = proc.addBlock();
15886         root-&gt;appendNew&lt;Value&gt;(
15887             proc, Return, Origin(),
15888             root-&gt;appendNew&lt;AtomicValue&gt;(
15889                 proc, AtomicStrongCAS, Origin(), width,
15890                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
15891                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15892                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
15893 
15894         auto code = compileProc(proc);
15895         T value[2];
15896         value[0] = 42;
15897         value[1] = 13;
15898         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42);
15899         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15900         CHECK_EQ(value[1], 13);
15901         value[0] = static_cast&lt;T&gt;(300);
15902         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)));
15903         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15904         CHECK_EQ(value[1], 13);
15905         value[0] = static_cast&lt;T&gt;(-1);
15906         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)));
15907         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
15908         CHECK_EQ(value[1], 13);
15909         checkMyDisassembly(*code, true);
15910     }
15911 
15912     {
15913         // Test for https://bugs.webkit.org/show_bug.cgi?id=169867.
15914 
15915         Procedure proc;
15916         BasicBlock* root = proc.addBlock();
15917         root-&gt;appendNew&lt;Value&gt;(
15918             proc, Return, Origin(),
15919             root-&gt;appendNew&lt;Value&gt;(
15920                 proc, BitXor, Origin(),
15921                 root-&gt;appendNew&lt;AtomicValue&gt;(
15922                     proc, AtomicStrongCAS, Origin(), width,
15923                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15924                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15925                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
15926                 root-&gt;appendIntConstant(proc, Origin(), type, 1)));
15927 
15928         typename NativeTraits&lt;T&gt;::CanonicalType one = 1;
15929 
15930         auto code = compileProc(proc);
15931         T value[2];
15932         value[0] = 42;
15933         value[1] = 13;
15934         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42 ^ one);
15935         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15936         CHECK_EQ(value[1], 13);
15937         value[0] = static_cast&lt;T&gt;(300);
15938         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)) ^ one);
15939         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15940         CHECK_EQ(value[1], 13);
15941         value[0] = static_cast&lt;T&gt;(-1);
15942         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)) ^ one);
15943         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
15944         CHECK_EQ(value[1], 13);
15945         checkMyDisassembly(*code, true);
15946     }
15947 
15948     {
15949         Procedure proc;
15950         BasicBlock* root = proc.addBlock();
15951         root-&gt;appendNew&lt;Value&gt;(
15952             proc, Return, Origin(),
15953             root-&gt;appendNew&lt;Value&gt;(
15954                 proc, Equal, Origin(),
15955                 root-&gt;appendNew&lt;AtomicValue&gt;(
15956                     proc, AtomicStrongCAS, Origin(), width,
15957                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
15958                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15959                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
15960                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
15961 
15962         auto code = compileProc(proc);
15963         T value[2];
15964         value[0] = 42;
15965         value[1] = 13;
15966         CHECK(invoke&lt;bool&gt;(*code, value));
15967         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15968         CHECK_EQ(value[1], 13);
15969         value[0] = static_cast&lt;T&gt;(300);
15970         CHECK(!invoke&lt;bool&gt;(*code, value));
15971         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
15972         CHECK_EQ(value[1], 13);
15973         checkMyDisassembly(*code, true);
15974     }
15975 
15976     {
15977         Procedure proc;
15978         BasicBlock* root = proc.addBlock();
15979         root-&gt;appendNew&lt;Value&gt;(
15980             proc, Return, Origin(),
15981             root-&gt;appendNew&lt;Value&gt;(
15982                 proc, Equal, Origin(),
15983                 root-&gt;appendNew&lt;Value&gt;(
15984                     proc, NotEqual, Origin(),
15985                     root-&gt;appendNew&lt;AtomicValue&gt;(
15986                         proc, AtomicStrongCAS, Origin(), width,
15987                         root-&gt;appendIntConstant(proc, Origin(), type, 42),
15988                         root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
15989                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
15990                     root-&gt;appendIntConstant(proc, Origin(), type, 42)),
15991                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
15992 
15993         auto code = compileProc(proc);
15994         T value[2];
15995         value[0] = 42;
15996         value[1] = 13;
15997         CHECK(invoke&lt;bool&gt;(*code, value));
15998         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
15999         CHECK_EQ(value[1], 13);
16000         value[0] = static_cast&lt;T&gt;(300);
16001         CHECK(!invoke&lt;bool&gt;(*code, &amp;value));
16002         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
16003         CHECK_EQ(value[1], 13);
16004         checkMyDisassembly(*code, true);
16005     }
16006 }
16007 
16008 template&lt;typename T&gt;
16009 void testAtomicXchg(B3::Opcode opcode)
16010 {
16011     Type type = NativeTraits&lt;T&gt;::type;
16012     Width width = NativeTraits&lt;T&gt;::width;
16013 
16014     auto doTheMath = [&amp;] (T&amp; memory, T operand) -&gt; T {
16015         T oldValue = memory;
16016         switch (opcode) {
16017         case AtomicXchgAdd:
16018             memory += operand;
16019             break;
16020         case AtomicXchgAnd:
16021             memory &amp;= operand;
16022             break;
16023         case AtomicXchgOr:
16024             memory |= operand;
16025             break;
16026         case AtomicXchgSub:
16027             memory -= operand;
16028             break;
16029         case AtomicXchgXor:
16030             memory ^= operand;
16031             break;
16032         case AtomicXchg:
16033             memory = operand;
16034             break;
16035         default:
16036             RELEASE_ASSERT_NOT_REACHED();
16037         }
16038         return oldValue;
16039     };
16040 
16041     auto oldValue = [&amp;] (T memory, T operand) -&gt; T {
16042         return doTheMath(memory, operand);
16043     };
16044 
16045     auto newValue = [&amp;] (T memory, T operand) -&gt; T {
16046         doTheMath(memory, operand);
16047         return memory;
16048     };
16049 
16050     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
16051         if (isX86())
16052             checkUsesInstruction(compilation, &quot;lock&quot;);
16053         else {
16054             if (fenced) {
16055                 checkUsesInstruction(compilation, &quot;ldax&quot;);
16056                 checkUsesInstruction(compilation, &quot;stlx&quot;);
16057             } else {
16058                 checkUsesInstruction(compilation, &quot;ldx&quot;);
16059                 checkUsesInstruction(compilation, &quot;stx&quot;);
16060             }
16061         }
16062     };
16063 
16064     {
16065         Procedure proc;
16066         BasicBlock* root = proc.addBlock();
16067         root-&gt;appendNew&lt;Value&gt;(
16068             proc, Return, Origin(),
16069             root-&gt;appendNew&lt;AtomicValue&gt;(
16070                 proc, opcode, Origin(), width,
16071                 root-&gt;appendIntConstant(proc, Origin(), type, 1),
16072                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
16073 
16074         auto code = compileProc(proc);
16075         T value[2];
16076         value[0] = 5;
16077         value[1] = 100;
16078         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 1));
16079         CHECK_EQ(value[0], newValue(5, 1));
16080         CHECK_EQ(value[1], 100);
16081         checkMyDisassembly(*code, true);
16082     }
16083 
16084     {
16085         Procedure proc;
16086         BasicBlock* root = proc.addBlock();
16087         root-&gt;appendNew&lt;Value&gt;(
16088             proc, Return, Origin(),
16089             root-&gt;appendNew&lt;AtomicValue&gt;(
16090                 proc, opcode, Origin(), width,
16091                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
16092                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
16093 
16094         auto code = compileProc(proc);
16095         T value[2];
16096         value[0] = 5;
16097         value[1] = 100;
16098         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 42));
16099         CHECK_EQ(value[0], newValue(5, 42));
16100         CHECK_EQ(value[1], 100);
16101         checkMyDisassembly(*code, true);
16102     }
16103 
16104     {
16105         Procedure proc;
16106         BasicBlock* root = proc.addBlock();
16107         root-&gt;appendNew&lt;AtomicValue&gt;(
16108             proc, opcode, Origin(), width,
16109             root-&gt;appendIntConstant(proc, Origin(), type, 42),
16110             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
16111         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
16112 
16113         auto code = compileProc(proc);
16114         T value[2];
16115         value[0] = 5;
16116         value[1] = 100;
16117         invoke&lt;T&gt;(*code, value);
16118         CHECK_EQ(value[0], newValue(5, 42));
16119         CHECK_EQ(value[1], 100);
16120         checkMyDisassembly(*code, true);
16121     }
16122 
16123     {
16124         Procedure proc;
16125         BasicBlock* root = proc.addBlock();
16126         root-&gt;appendNew&lt;AtomicValue&gt;(
16127             proc, opcode, Origin(), width,
16128             root-&gt;appendIntConstant(proc, Origin(), type, 42),
16129             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
16130             0, HeapRange(42), HeapRange());
16131         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
16132 
16133         auto code = compileProc(proc);
16134         T value[2];
16135         value[0] = 5;
16136         value[1] = 100;
16137         invoke&lt;T&gt;(*code, value);
16138         CHECK_EQ(value[0], newValue(5, 42));
16139         CHECK_EQ(value[1], 100);
16140         checkMyDisassembly(*code, false);
16141     }
16142 }
16143 
16144 void testDepend32()
16145 {
16146     Procedure proc;
16147     BasicBlock* root = proc.addBlock();
16148     Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
16149     Value* first = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), ptr, 0);
16150     Value* second = root-&gt;appendNew&lt;MemoryValue&gt;(
16151         proc, Load, Int32, Origin(),
16152         root-&gt;appendNew&lt;Value&gt;(
16153             proc, Add, Origin(), ptr,
16154             root-&gt;appendNew&lt;Value&gt;(
16155                 proc, ZExt32, Origin(),
16156                 root-&gt;appendNew&lt;Value&gt;(proc, Depend, Origin(), first))),
16157         4);
16158     root-&gt;appendNew&lt;Value&gt;(
16159         proc, Return, Origin(),
16160         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), first, second));
16161 
16162     int32_t values[2];
16163     values[0] = 42;
16164     values[1] = 0xbeef;
16165 
16166     auto code = compileProc(proc);
16167     if (isARM64())
16168         checkUsesInstruction(*code, &quot;eor&quot;);
16169     else if (isX86()) {
16170         checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
16171         checkDoesNotUseInstruction(*code, &quot;lock&quot;);
16172     }
16173     CHECK_EQ(invoke&lt;int32_t&gt;(*code, values), 42 + 0xbeef);
16174 }
16175 
16176 void testDepend64()
16177 {
16178     Procedure proc;
16179     BasicBlock* root = proc.addBlock();
16180     Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
16181     Value* first = root-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), ptr, 0);
16182     Value* second = root-&gt;appendNew&lt;MemoryValue&gt;(
16183         proc, Load, Int64, Origin(),
16184         root-&gt;appendNew&lt;Value&gt;(
16185             proc, Add, Origin(), ptr,
16186             root-&gt;appendNew&lt;Value&gt;(proc, Depend, Origin(), first)),
16187         8);
16188     root-&gt;appendNew&lt;Value&gt;(
16189         proc, Return, Origin(),
16190         root-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), first, second));
16191 
16192     int64_t values[2];
16193     values[0] = 42;
16194     values[1] = 0xbeef;
16195 
16196     auto code = compileProc(proc);
16197     if (isARM64())
16198         checkUsesInstruction(*code, &quot;eor&quot;);
16199     else if (isX86()) {
16200         checkDoesNotUseInstruction(*code, &quot;mfence&quot;);
16201         checkDoesNotUseInstruction(*code, &quot;lock&quot;);
16202     }
16203     CHECK_EQ(invoke&lt;int64_t&gt;(*code, values), 42 + 0xbeef);
16204 }
16205 
16206 void testWasmBoundsCheck(unsigned offset)
16207 {
16208     Procedure proc;
16209     GPRReg pinned = GPRInfo::argumentGPR1;
16210     proc.pinRegister(pinned);
16211 
16212     proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
16213         CHECK_EQ(pinnedGPR, pinned);
16214 
16215         // This should always work because a function this simple should never have callee
16216         // saves.
16217         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
16218         jit.emitFunctionEpilogue();
16219         jit.ret();
16220     });
16221 
16222     BasicBlock* root = proc.addBlock();
16223     Value* left = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
16224     if (pointerType() != Int32)
16225         left = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), left);
16226     root-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(proc, Origin(), pinned, left, offset);
16227     Value* result = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x42);
16228     root-&gt;appendNewControlValue(proc, Return, Origin(), result);
16229 
16230     auto code = compileProc(proc);
16231     uint32_t bound = 2 + offset;
16232     auto computeResult = [&amp;] (uint32_t input) {
16233         return input + offset &lt; bound ? 0x42 : 42;
16234     };
16235 
16236     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 1, bound), computeResult(1));
16237     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 3, bound), computeResult(3));
16238     CHECK_EQ(invoke&lt;int32_t&gt;(*code, 2, bound), computeResult(2));
16239 }
16240 
16241 void testWasmAddress()
16242 {
16243     Procedure proc;
16244     GPRReg pinnedGPR = GPRInfo::argumentGPR2;
16245     proc.pinRegister(pinnedGPR);
16246 
16247     unsigned loopCount = 100;
16248     Vector&lt;unsigned&gt; values(loopCount);
16249     unsigned numToStore = 42;
16250 
16251     BasicBlock* root = proc.addBlock();
16252     BasicBlock* header = proc.addBlock();
16253     BasicBlock* body = proc.addBlock();
16254     BasicBlock* continuation = proc.addBlock();
16255 
16256     // Root
16257     Value* loopCountValue = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
16258     Value* valueToStore = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));
16259     UpsilonValue* beginUpsilon = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
16260     root-&gt;appendNewControlValue(proc, Jump, Origin(), header);
16261 
16262     // Header
16263     Value* indexPhi = header-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
16264     header-&gt;appendNewControlValue(proc, Branch, Origin(),
16265         header-&gt;appendNew&lt;Value&gt;(proc, Below, Origin(), indexPhi, loopCountValue),
16266         body, continuation);
16267 
16268     // Body
16269     Value* pointer = body-&gt;appendNew&lt;Value&gt;(proc, Mul, Origin(), indexPhi,
16270         body-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), sizeof(unsigned)));
16271     pointer = body-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), pointer);
16272     body-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), valueToStore,
16273         body-&gt;appendNew&lt;WasmAddressValue&gt;(proc, Origin(), pointer, pinnedGPR), 0);
16274     UpsilonValue* incUpsilon = body-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(),
16275         body-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), indexPhi,
16276             body-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1)));
16277     body-&gt;appendNewControlValue(proc, Jump, Origin(), header);
16278 
16279     // Continuation
16280     continuation-&gt;appendNewControlValue(proc, Return, Origin());
16281 
16282     beginUpsilon-&gt;setPhi(indexPhi);
16283     incUpsilon-&gt;setPhi(indexPhi);
16284 
16285 
16286     auto code = compileProc(proc);
16287     invoke&lt;void&gt;(*code, loopCount, numToStore, values.data());
16288     for (unsigned value : values)
16289         CHECK_EQ(numToStore, value);
16290 }
16291 
16292 void testFastTLSLoad()
16293 {
16294 #if ENABLE(FAST_TLS_JIT)
16295     _pthread_setspecific_direct(WTF_TESTING_KEY, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(0xbeef)));
16296 
16297     Procedure proc;
16298     BasicBlock* root = proc.addBlock();
16299 
16300     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, pointerType(), Origin());
16301     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
16302     patchpoint-&gt;setGenerator(
16303         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
16304             AllowMacroScratchRegisterUsage allowScratch(jit);
16305             jit.loadFromTLSPtr(fastTLSOffsetForKey(WTF_TESTING_KEY), params[0].gpr());
16306         });
16307 
16308     root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
16309 
16310     CHECK_EQ(compileAndRun&lt;uintptr_t&gt;(proc), static_cast&lt;uintptr_t&gt;(0xbeef));
16311 #endif
16312 }
16313 
16314 void testFastTLSStore()
16315 {
16316 #if ENABLE(FAST_TLS_JIT)
16317     Procedure proc;
16318     BasicBlock* root = proc.addBlock();
16319 
16320     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
16321     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
16322     patchpoint-&gt;numGPScratchRegisters = 1;
16323     patchpoint-&gt;setGenerator(
16324         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
16325             AllowMacroScratchRegisterUsage allowScratch(jit);
16326             GPRReg scratch = params.gpScratch(0);
16327             jit.move(CCallHelpers::TrustedImm32(0xdead), scratch);
16328             jit.storeToTLSPtr(scratch, fastTLSOffsetForKey(WTF_TESTING_KEY));
16329         });
16330 
16331     root-&gt;appendNewControlValue(proc, Return, Origin());
16332 
16333     compileAndRun&lt;void&gt;(proc);
16334     CHECK_EQ(bitwise_cast&lt;uintptr_t&gt;(_pthread_getspecific_direct(WTF_TESTING_KEY)), static_cast&lt;uintptr_t&gt;(0xdead));
16335 #endif
16336 }
16337 
16338 NEVER_INLINE bool doubleEq(double a, double b) { return a == b; }
16339 NEVER_INLINE bool doubleNeq(double a, double b) { return a != b; }
16340 NEVER_INLINE bool doubleGt(double a, double b) { return a &gt; b; }
16341 NEVER_INLINE bool doubleGte(double a, double b) { return a &gt;= b; }
16342 NEVER_INLINE bool doubleLt(double a, double b) { return a &lt; b; }
16343 NEVER_INLINE bool doubleLte(double a, double b) { return a &lt;= b; }
16344 
16345 void testDoubleLiteralComparison(double a, double b)
16346 {
16347     using Test = std::tuple&lt;B3::Opcode, bool (*)(double, double)&gt;;
16348     StdList&lt;Test&gt; tests = {
16349         Test { NotEqual, doubleNeq },
16350         Test { Equal, doubleEq },
16351         Test { EqualOrUnordered, doubleEq },
16352         Test { GreaterThan, doubleGt },
16353         Test { GreaterEqual, doubleGte },
16354         Test { LessThan, doubleLt },
16355         Test { LessEqual, doubleLte },
16356     };
16357 
16358     for (const Test&amp; test : tests) {
16359         Procedure proc;
16360         BasicBlock* root = proc.addBlock();
16361         Value* valueA = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), a);
16362         Value* valueB = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), b);
16363 
16364         // This is here just to make reduceDoubleToFloat do things.
16365         Value* valueC = root-&gt;appendNew&lt;ConstDoubleValue&gt;(proc, Origin(), 0.0);
16366         Value* valueAsFloat = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(), valueC);
16367 
16368         root-&gt;appendNewControlValue(
16369             proc, Return, Origin(),
16370                 root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(),
16371                     root-&gt;appendNew&lt;Value&gt;(proc, std::get&lt;0&gt;(test), Origin(), valueA, valueB),
16372                     root-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(), valueAsFloat, valueAsFloat)));
16373 
16374         CHECK(!!compileAndRun&lt;int32_t&gt;(proc) == std::get&lt;1&gt;(test)(a, b));
16375     }
16376 }
16377 
16378 void testFloatEqualOrUnorderedFolding()
16379 {
16380     for (auto&amp; first : floatingPointOperands&lt;float&gt;()) {
16381         for (auto&amp; second : floatingPointOperands&lt;float&gt;()) {
16382             float a = first.value;
16383             float b = second.value;
16384             bool expectedResult = (a == b) || std::isunordered(a, b);
16385             Procedure proc;
16386             BasicBlock* root = proc.addBlock();
16387             Value* constA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
16388             Value* constB = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), b);
16389 
16390             root-&gt;appendNewControlValue(proc, Return, Origin(),
16391                 root-&gt;appendNew&lt;Value&gt;(
16392                     proc, EqualOrUnordered, Origin(),
16393                     constA,
16394                     constB));
16395             CHECK(!!compileAndRun&lt;int32_t&gt;(proc) == expectedResult);
16396         }
16397     }
16398 }
16399 
16400 void testFloatEqualOrUnorderedFoldingNaN()
16401 {
16402     StdList&lt;float&gt; nans = {
16403         bitwise_cast&lt;float&gt;(0xfffffffd),
16404         bitwise_cast&lt;float&gt;(0xfffffffe),
16405         bitwise_cast&lt;float&gt;(0xfffffff0),
16406         static_cast&lt;float&gt;(PNaN),
16407     };
16408 
16409     unsigned i = 0;
16410     for (float nan : nans) {
16411         RELEASE_ASSERT(std::isnan(nan));
16412         Procedure proc;
16413         BasicBlock* root = proc.addBlock();
16414         Value* a = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), nan);
16415         Value* b = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(),
16416             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
16417 
16418         if (i % 2)
16419             std::swap(a, b);
16420         ++i;
16421         root-&gt;appendNewControlValue(proc, Return, Origin(),
16422             root-&gt;appendNew&lt;Value&gt;(proc, EqualOrUnordered, Origin(), a, b));
16423         CHECK(!!compileAndRun&lt;int32_t&gt;(proc, static_cast&lt;double&gt;(1.0)));
16424     }
16425 }
16426 
16427 void testFloatEqualOrUnorderedDontFold()
16428 {
16429     for (auto&amp; first : floatingPointOperands&lt;float&gt;()) {
16430         float a = first.value;
16431         Procedure proc;
16432         BasicBlock* root = proc.addBlock();
16433         Value* constA = root-&gt;appendNew&lt;ConstFloatValue&gt;(proc, Origin(), a);
16434         Value* b = root-&gt;appendNew&lt;Value&gt;(proc, DoubleToFloat, Origin(),
16435             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), FPRInfo::argumentFPR0));
16436         root-&gt;appendNewControlValue(proc, Return, Origin(),
16437             root-&gt;appendNew&lt;Value&gt;(
16438                 proc, EqualOrUnordered, Origin(), constA, b));
16439 
16440         auto code = compileProc(proc);
16441 
16442         for (auto&amp; second : floatingPointOperands&lt;float&gt;()) {
16443             float b = second.value;
16444             bool expectedResult = (a == b) || std::isunordered(a, b);
16445             CHECK(!!invoke&lt;int32_t&gt;(*code, static_cast&lt;double&gt;(b)) == expectedResult);
16446         }
16447     }
16448 }
16449 
16450 void functionNineArgs(int32_t, void*, void*, void*, void*, void*, void*, void*, void*) { }
16451 
16452 void testShuffleDoesntTrashCalleeSaves()
16453 {
16454     Procedure proc;
16455 
16456     BasicBlock* root = proc.addBlock();
16457     BasicBlock* likely = proc.addBlock();
16458     BasicBlock* unlikely = proc.addBlock();
16459 
16460     RegisterSet regs = RegisterSet::allGPRs();
16461     regs.exclude(RegisterSet::stackRegisters());
16462     regs.exclude(RegisterSet::reservedHardwareRegisters());
16463     regs.exclude(RegisterSet::calleeSaveRegisters());
16464     regs.exclude(RegisterSet::argumentGPRS());
16465 
16466     unsigned i = 0;
16467     Vector&lt;Value*&gt; patches;
16468     for (Reg reg : regs) {
16469         ++i;
16470         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
16471         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
16472         RELEASE_ASSERT(reg.isGPR());
16473         patchpoint-&gt;resultConstraint = ValueRep::reg(reg.gpr());
16474         patchpoint-&gt;setGenerator(
16475             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
16476                 AllowMacroScratchRegisterUsage allowScratch(jit);
16477                 jit.move(CCallHelpers::TrustedImm32(i), params[0].gpr());
16478             });
16479         patches.append(patchpoint);
16480     }
16481 
16482     Value* arg1 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(0 % GPRInfo::numberOfArgumentRegisters));
16483     Value* arg2 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(1 % GPRInfo::numberOfArgumentRegisters));
16484     Value* arg3 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(2 % GPRInfo::numberOfArgumentRegisters));
16485     Value* arg4 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(3 % GPRInfo::numberOfArgumentRegisters));
16486     Value* arg5 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(4 % GPRInfo::numberOfArgumentRegisters));
16487     Value* arg6 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(5 % GPRInfo::numberOfArgumentRegisters));
16488     Value* arg7 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(6 % GPRInfo::numberOfArgumentRegisters));
16489     Value* arg8 = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::toArgumentRegister(7 % GPRInfo::numberOfArgumentRegisters));
16490 
16491     PatchpointValue* ptr = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int64, Origin());
16492     ptr-&gt;clobber(RegisterSet::macroScratchRegisters());
16493     ptr-&gt;resultConstraint = ValueRep::reg(GPRInfo::regCS0);
16494     ptr-&gt;appendSomeRegister(arg1);
16495     ptr-&gt;setGenerator(
16496         [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
16497             AllowMacroScratchRegisterUsage allowScratch(jit);
16498             jit.move(params[1].gpr(), params[0].gpr());
16499         });
16500 
16501     Value* condition = root-&gt;appendNew&lt;Value&gt;(
16502         proc, Equal, Origin(),
16503         ptr,
16504         root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 0));
16505 
16506     root-&gt;appendNewControlValue(
16507         proc, Branch, Origin(),
16508         condition,
16509         FrequentedBlock(likely, FrequencyClass::Normal), FrequentedBlock(unlikely, FrequencyClass::Rare));
16510 
16511     // Never executes.
16512     Value* const42 = likely-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
16513     likely-&gt;appendNewControlValue(proc, Return, Origin(), const42);
16514 
16515     // Always executes.
16516     Value* constNumber = unlikely-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0x1);
16517 
16518     unlikely-&gt;appendNew&lt;CCallValue&gt;(
16519         proc, Void, Origin(),
16520         unlikely-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), tagCFunctionPtr&lt;void*&gt;(functionNineArgs, B3CCallPtrTag)),
16521         constNumber, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
16522 
16523     PatchpointValue* voidPatch = unlikely-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
16524     voidPatch-&gt;clobber(RegisterSet::macroScratchRegisters());
16525     for (Value* v : patches)
16526         voidPatch-&gt;appendSomeRegister(v);
16527     voidPatch-&gt;appendSomeRegister(arg1);
16528     voidPatch-&gt;appendSomeRegister(arg2);
16529     voidPatch-&gt;appendSomeRegister(arg3);
16530     voidPatch-&gt;appendSomeRegister(arg4);
16531     voidPatch-&gt;appendSomeRegister(arg5);
16532     voidPatch-&gt;appendSomeRegister(arg6);
16533     voidPatch-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
16534 
16535     unlikely-&gt;appendNewControlValue(proc, Return, Origin(),
16536         unlikely-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), ptr));
16537 
16538     int32_t* inputPtr = static_cast&lt;int32_t*&gt;(fastMalloc(sizeof(int32_t)));
16539     *inputPtr = 48;
16540     CHECK(compileAndRun&lt;int32_t&gt;(proc, inputPtr) == 48);
16541     fastFree(inputPtr);
16542 }
16543 
16544 void testDemotePatchpointTerminal()
16545 {
16546     Procedure proc;
16547 
16548     BasicBlock* root = proc.addBlock();
16549     BasicBlock* done = proc.addBlock();
16550 
16551     PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
16552     patchpoint-&gt;effects.terminal = true;
16553     root-&gt;setSuccessors(done);
16554 
16555     done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin(), patchpoint);
16556 
16557     proc.resetReachability();
16558     breakCriticalEdges(proc);
16559     IndexSet&lt;Value*&gt; valuesToDemote;
16560     valuesToDemote.add(patchpoint);
16561     demoteValues(proc, valuesToDemote);
16562     validate(proc);
16563 }
16564 
16565 void testReportUsedRegistersLateUseFollowedByEarlyDefDoesNotMarkUseAsDead()
16566 {
16567     Procedure proc;
16568     if (proc.optLevel() &lt; 2)
16569         return;
16570     BasicBlock* root = proc.addBlock();
16571 
16572     RegisterSet allRegs = RegisterSet::allGPRs();
16573     allRegs.exclude(RegisterSet::stackRegisters());
16574     allRegs.exclude(RegisterSet::reservedHardwareRegisters());
16575 
16576     {
16577         // Make every reg 42 (just needs to be a value other than 10).
16578         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
16579         Value* const42 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 42);
16580         for (Reg reg : allRegs)
16581             patchpoint-&gt;append(const42, ValueRep::reg(reg));
16582         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
16583     }
16584 
16585     {
16586         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
16587         Value* const10 = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 10);
16588         for (Reg reg : allRegs)
16589             patchpoint-&gt;append(const10, ValueRep::lateReg(reg));
16590         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
16591             for (Reg reg : allRegs) {
16592                 auto done = jit.branch32(CCallHelpers::Equal, reg.gpr(), CCallHelpers::TrustedImm32(10));
16593                 jit.breakpoint();
16594                 done.link(&amp;jit);
16595             }
16596         });
16597     }
16598 
16599     {
16600         PatchpointValue* patchpoint = root-&gt;appendNew&lt;PatchpointValue&gt;(proc, Int32, Origin());
16601         patchpoint-&gt;resultConstraint = ValueRep::SomeEarlyRegister;
16602         patchpoint-&gt;setGenerator([&amp;] (CCallHelpers&amp;, const StackmapGenerationParams&amp; params) {
16603             RELEASE_ASSERT(allRegs.contains(params[0].gpr()));
16604         });
16605     }
16606 
16607     root-&gt;appendNewControlValue(proc, Return, Origin());
16608 
16609     compileAndRun&lt;void&gt;(proc);
16610 }
16611 
16612 void testInfiniteLoopDoesntCauseBadHoisting()
16613 {
16614     Procedure proc;
16615     if (proc.optLevel() &lt; 2)
16616         return;
16617     BasicBlock* root = proc.addBlock();
16618     BasicBlock* header = proc.addBlock();
16619     BasicBlock* loadBlock = proc.addBlock();
16620     BasicBlock* postLoadBlock = proc.addBlock();
16621 
16622     Value* arg = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
16623     root-&gt;appendNewControlValue(proc, Jump, Origin(), header);
16624 
16625     header-&gt;appendNewControlValue(
16626         proc, Branch, Origin(),
16627         header-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(),
16628             arg,
16629             header-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 10)), header, loadBlock);
16630 
16631     PatchpointValue* patchpoint = loadBlock-&gt;appendNew&lt;PatchpointValue&gt;(proc, Void, Origin());
16632     patchpoint-&gt;effects = Effects::none();
16633     patchpoint-&gt;effects.writesLocalState = true; // Don&#39;t DCE this.
16634     patchpoint-&gt;setGenerator(
16635         [&amp;] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
16636             // This works because we don&#39;t have callee saves.
16637             jit.emitFunctionEpilogue();
16638             jit.ret();
16639         });
16640 
16641     Value* badLoad = loadBlock-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int64, Origin(), arg, 0);
16642 
16643     loadBlock-&gt;appendNewControlValue(
16644         proc, Branch, Origin(),
16645         loadBlock-&gt;appendNew&lt;Value&gt;(proc, Equal, Origin(),
16646             badLoad,
16647             loadBlock-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), 45)), header, postLoadBlock);
16648 
16649     postLoadBlock-&gt;appendNewControlValue(proc, Return, Origin(), badLoad);
16650 
16651     // The patchpoint early ret() works because we don&#39;t have callee saves.
16652     auto code = compileProc(proc);
16653     RELEASE_ASSERT(!proc.calleeSaveRegisterAtOffsetList().size());
16654     invoke&lt;void&gt;(*code, static_cast&lt;uint64_t&gt;(55)); // Shouldn&#39;t crash dereferncing 55.
16655 }
16656 
16657 // Make sure the compiler does not try to optimize anything out.
16658 NEVER_INLINE double zero()
16659 {
16660     return 0.;
16661 }
16662 
16663 double negativeZero()
16664 {
16665     return -zero();
16666 }
16667 
16668 #define RUN_NOW(test) do {                      \
16669         if (!shouldRun(#test))                  \
16670             break;                              \
16671         dataLog(#test &quot;...\n&quot;);                 \
16672         test;                                   \
16673         dataLog(#test &quot;: OK!\n&quot;);               \
16674     } while (false)
16675 #define RUN(test) do {                          \
16676         if (!shouldRun(#test))                  \
16677             break;                              \
16678         tasks.append(                           \
16679             createSharedTask&lt;void()&gt;(           \
16680                 [&amp;] () {                        \
16681                     dataLog(#test &quot;...\n&quot;);     \
16682                     test;                       \
16683                     dataLog(#test &quot;: OK!\n&quot;);   \
16684                 }));                            \
16685     } while (false);
16686 
16687 #define RUN_UNARY(test, values) \
16688     for (auto a : values) {                             \
16689         CString testStr = toCString(#test, &quot;(&quot;, a.name, &quot;)&quot;); \
16690         if (!shouldRun(testStr.data()))                 \
16691             continue;                                   \
16692         tasks.append(createSharedTask&lt;void()&gt;(          \
16693             [=] () {                                    \
16694                 dataLog(toCString(testStr, &quot;...\n&quot;));   \
16695                 test(a.value);                          \
16696                 dataLog(toCString(testStr, &quot;: OK!\n&quot;)); \
16697             }));                                        \
16698     }
16699 
16700 #define RUN_BINARY(test, valuesA, valuesB) \
16701     for (auto a : valuesA) {                                \
16702         for (auto b : valuesB) {                            \
16703             CString testStr = toCString(#test, &quot;(&quot;, a.name, &quot;, &quot;, b.name, &quot;)&quot;); \
16704             if (!shouldRun(testStr.data()))                 \
16705                 continue;                                   \
16706             tasks.append(createSharedTask&lt;void()&gt;(          \
16707                 [=] () {                                    \
16708                     dataLog(toCString(testStr, &quot;...\n&quot;));   \
16709                     test(a.value, b.value);                 \
16710                     dataLog(toCString(testStr, &quot;: OK!\n&quot;)); \
16711                 }));                                        \
16712         }                                                   \
16713     }
16714 #define RUN_TERNARY(test, valuesA, valuesB, valuesC) \
16715     for (auto a : valuesA) {                                    \
16716         for (auto b : valuesB) {                                \
16717             for (auto c : valuesC) {                            \
16718                 CString testStr = toCString(#test, &quot;(&quot;, a.name, &quot;, &quot;, b.name, &quot;,&quot;, c.name, &quot;)&quot;); \
16719                 if (!shouldRun(testStr.data()))                 \
16720                     continue;                                   \
16721                 tasks.append(createSharedTask&lt;void()&gt;(          \
16722                     [=] () {                                    \
16723                         dataLog(toCString(testStr, &quot;...\n&quot;));   \
16724                         test(a.value, b.value, c.value);        \
16725                         dataLog(toCString(testStr, &quot;: OK!\n&quot;)); \
16726                     }));                                        \
16727             }                                                   \
16728         }                                                       \
16729     }
16730 
16731 void run(const char* filter)
16732 {
16733     JSC::initializeThreading();
16734 
16735     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
16736 
16737     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
16738         return !filter || !!strcasestr(testName, filter);
16739     };
16740 
16741     RUN_NOW(testTerminalPatchpointThatNeedsToBeSpilled2());
16742     RUN(test42());
16743     RUN(testLoad42());
16744     RUN(testLoadAcq42());
16745     RUN(testLoadOffsetImm9Max());
16746     RUN(testLoadOffsetImm9MaxPlusOne());
16747     RUN(testLoadOffsetImm9MaxPlusTwo());
16748     RUN(testLoadOffsetImm9Min());
16749     RUN(testLoadOffsetImm9MinMinusOne());
16750     RUN(testLoadOffsetScaledUnsignedImm12Max());
16751     RUN(testLoadOffsetScaledUnsignedOverImm12Max());
16752     RUN(testArg(43));
16753     RUN(testReturnConst64(5));
16754     RUN(testReturnConst64(-42));
16755     RUN(testReturnVoid());
16756 
16757     RUN(testAddArg(111));
16758     RUN(testAddArgs(1, 1));
16759     RUN(testAddArgs(1, 2));
16760     RUN(testAddArgImm(1, 2));
16761     RUN(testAddArgImm(0, 2));
16762     RUN(testAddArgImm(1, 0));
16763     RUN(testAddImmArg(1, 2));
16764     RUN(testAddImmArg(0, 2));
16765     RUN(testAddImmArg(1, 0));
16766     RUN_BINARY(testAddArgMem, int64Operands(), int64Operands());
16767     RUN_BINARY(testAddMemArg, int64Operands(), int64Operands());
16768     RUN_BINARY(testAddImmMem, int64Operands(), int64Operands());
16769     RUN_UNARY(testAddArg32, int32Operands());
16770     RUN(testAddArgs32(1, 1));
16771     RUN(testAddArgs32(1, 2));
16772     RUN_BINARY(testAddArgMem32, int32Operands(), int32Operands());
16773     RUN_BINARY(testAddMemArg32, int32Operands(), int32Operands());
16774     RUN_BINARY(testAddImmMem32, int32Operands(), int32Operands());
16775     RUN_BINARY(testAddNeg1, int32Operands(), int32Operands());
16776     RUN_BINARY(testAddNeg2, int32Operands(), int32Operands());
16777     RUN(testAddArgZeroImmZDef());
16778     RUN(testAddLoadTwice());
16779 
16780     RUN(testAddArgDouble(M_PI));
16781     RUN(testAddArgsDouble(M_PI, 1));
16782     RUN(testAddArgsDouble(M_PI, -M_PI));
16783     RUN(testAddArgImmDouble(M_PI, 1));
16784     RUN(testAddArgImmDouble(M_PI, 0));
16785     RUN(testAddArgImmDouble(M_PI, negativeZero()));
16786     RUN(testAddArgImmDouble(0, 0));
16787     RUN(testAddArgImmDouble(0, negativeZero()));
16788     RUN(testAddArgImmDouble(negativeZero(), 0));
16789     RUN(testAddArgImmDouble(negativeZero(), negativeZero()));
16790     RUN(testAddImmArgDouble(M_PI, 1));
16791     RUN(testAddImmArgDouble(M_PI, 0));
16792     RUN(testAddImmArgDouble(M_PI, negativeZero()));
16793     RUN(testAddImmArgDouble(0, 0));
16794     RUN(testAddImmArgDouble(0, negativeZero()));
16795     RUN(testAddImmArgDouble(negativeZero(), 0));
16796     RUN(testAddImmArgDouble(negativeZero(), negativeZero()));
16797     RUN(testAddImmsDouble(M_PI, 1));
16798     RUN(testAddImmsDouble(M_PI, 0));
16799     RUN(testAddImmsDouble(M_PI, negativeZero()));
16800     RUN(testAddImmsDouble(0, 0));
16801     RUN(testAddImmsDouble(0, negativeZero()));
16802     RUN(testAddImmsDouble(negativeZero(), negativeZero()));
16803     RUN_UNARY(testAddArgFloat, floatingPointOperands&lt;float&gt;());
16804     RUN_BINARY(testAddArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16805     RUN_BINARY(testAddFPRArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16806     RUN_BINARY(testAddArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16807     RUN_BINARY(testAddImmArgFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16808     RUN_BINARY(testAddImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16809     RUN_UNARY(testAddArgFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
16810     RUN_BINARY(testAddArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16811     RUN_BINARY(testAddArgsFloatWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16812 
16813     RUN(testMulArg(5));
16814     RUN(testMulAddArg(5));
16815     RUN(testMulAddArg(85));
16816     RUN(testMulArgStore(5));
16817     RUN(testMulArgStore(85));
16818     RUN(testMulArgs(1, 1));
16819     RUN(testMulArgs(1, 2));
16820     RUN(testMulArgs(3, 3));
16821     RUN(testMulArgImm(1, 2));
16822     RUN(testMulArgImm(1, 4));
16823     RUN(testMulArgImm(1, 8));
16824     RUN(testMulArgImm(1, 16));
16825     RUN(testMulArgImm(1, 0x80000000llu));
16826     RUN(testMulArgImm(1, 0x800000000000llu));
16827     RUN(testMulArgImm(7, 2));
16828     RUN(testMulArgImm(7, 4));
16829     RUN(testMulArgImm(7, 8));
16830     RUN(testMulArgImm(7, 16));
16831     RUN(testMulArgImm(7, 0x80000000llu));
16832     RUN(testMulArgImm(7, 0x800000000000llu));
16833     RUN(testMulArgImm(-42, 2));
16834     RUN(testMulArgImm(-42, 4));
16835     RUN(testMulArgImm(-42, 8));
16836     RUN(testMulArgImm(-42, 16));
16837     RUN(testMulArgImm(-42, 0x80000000llu));
16838     RUN(testMulArgImm(-42, 0x800000000000llu));
16839     RUN(testMulArgImm(0, 2));
16840     RUN(testMulArgImm(1, 0));
16841     RUN(testMulArgImm(3, 3));
16842     RUN(testMulArgImm(3, -1));
16843     RUN(testMulArgImm(-3, -1));
16844     RUN(testMulArgImm(0, -1));
16845     RUN(testMulImmArg(1, 2));
16846     RUN(testMulImmArg(0, 2));
16847     RUN(testMulImmArg(1, 0));
16848     RUN(testMulImmArg(3, 3));
16849     RUN(testMulArgs32(1, 1));
16850     RUN(testMulArgs32(1, 2));
16851     RUN(testMulLoadTwice());
16852     RUN(testMulAddArgsLeft());
16853     RUN(testMulAddArgsRight());
16854     RUN(testMulAddArgsLeft32());
16855     RUN(testMulAddArgsRight32());
16856     RUN(testMulSubArgsLeft());
16857     RUN(testMulSubArgsRight());
16858     RUN(testMulSubArgsLeft32());
16859     RUN(testMulSubArgsRight32());
16860     RUN(testMulNegArgs());
16861     RUN(testMulNegArgs32());
16862 
16863     RUN_UNARY(testMulArgDouble, floatingPointOperands&lt;double&gt;());
16864     RUN_BINARY(testMulArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16865     RUN_BINARY(testMulArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16866     RUN_BINARY(testMulImmArgDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16867     RUN_BINARY(testMulImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16868     RUN_UNARY(testMulArgFloat, floatingPointOperands&lt;float&gt;());
16869     RUN_BINARY(testMulArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16870     RUN_BINARY(testMulArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16871     RUN_BINARY(testMulImmArgFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16872     RUN_BINARY(testMulImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16873     RUN_UNARY(testMulArgFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
16874     RUN_BINARY(testMulArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16875     RUN_BINARY(testMulArgsFloatWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16876 
16877     RUN(testDivArgDouble(M_PI));
16878     RUN(testDivArgsDouble(M_PI, 1));
16879     RUN(testDivArgsDouble(M_PI, -M_PI));
16880     RUN(testDivArgImmDouble(M_PI, 1));
16881     RUN(testDivArgImmDouble(M_PI, 0));
16882     RUN(testDivArgImmDouble(M_PI, negativeZero()));
16883     RUN(testDivArgImmDouble(0, 0));
16884     RUN(testDivArgImmDouble(0, negativeZero()));
16885     RUN(testDivArgImmDouble(negativeZero(), 0));
16886     RUN(testDivArgImmDouble(negativeZero(), negativeZero()));
16887     RUN(testDivImmArgDouble(M_PI, 1));
16888     RUN(testDivImmArgDouble(M_PI, 0));
16889     RUN(testDivImmArgDouble(M_PI, negativeZero()));
16890     RUN(testDivImmArgDouble(0, 0));
16891     RUN(testDivImmArgDouble(0, negativeZero()));
16892     RUN(testDivImmArgDouble(negativeZero(), 0));
16893     RUN(testDivImmArgDouble(negativeZero(), negativeZero()));
16894     RUN(testDivImmsDouble(M_PI, 1));
16895     RUN(testDivImmsDouble(M_PI, 0));
16896     RUN(testDivImmsDouble(M_PI, negativeZero()));
16897     RUN(testDivImmsDouble(0, 0));
16898     RUN(testDivImmsDouble(0, negativeZero()));
16899     RUN(testDivImmsDouble(negativeZero(), negativeZero()));
16900     RUN_UNARY(testDivArgFloat, floatingPointOperands&lt;float&gt;());
16901     RUN_BINARY(testDivArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16902     RUN_BINARY(testDivArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16903     RUN_BINARY(testDivImmArgFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16904     RUN_BINARY(testDivImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16905     RUN_UNARY(testDivArgFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
16906     RUN_BINARY(testDivArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16907     RUN_BINARY(testDivArgsFloatWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16908 
16909     RUN_BINARY(testUDivArgsInt32, int32Operands(), int32Operands());
16910     RUN_BINARY(testUDivArgsInt64, int64Operands(), int64Operands());
16911 
16912     RUN_UNARY(testModArgDouble, floatingPointOperands&lt;double&gt;());
16913     RUN_BINARY(testModArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16914     RUN_BINARY(testModArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16915     RUN_BINARY(testModImmArgDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16916     RUN_BINARY(testModImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16917     RUN_UNARY(testModArgFloat, floatingPointOperands&lt;float&gt;());
16918     RUN_BINARY(testModArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16919     RUN_BINARY(testModArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16920     RUN_BINARY(testModImmArgFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16921     RUN_BINARY(testModImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16922 
16923     RUN_BINARY(testUModArgsInt32, int32Operands(), int32Operands());
16924     RUN_BINARY(testUModArgsInt64, int64Operands(), int64Operands());
16925 
16926     RUN(testSubArg(24));
16927     RUN(testSubArgs(1, 1));
16928     RUN(testSubArgs(1, 2));
16929     RUN(testSubArgs(13, -42));
16930     RUN(testSubArgs(-13, 42));
16931     RUN(testSubArgImm(1, 1));
16932     RUN(testSubArgImm(1, 2));
16933     RUN(testSubArgImm(13, -42));
16934     RUN(testSubArgImm(-13, 42));
16935     RUN(testSubArgImm(42, 0));
16936     RUN(testSubImmArg(1, 1));
16937     RUN(testSubImmArg(1, 2));
16938     RUN(testSubImmArg(13, -42));
16939     RUN(testSubImmArg(-13, 42));
16940     RUN_BINARY(testSubArgMem, int64Operands(), int64Operands());
16941     RUN_BINARY(testSubMemArg, int64Operands(), int64Operands());
16942     RUN_BINARY(testSubImmMem, int32Operands(), int32Operands());
16943     RUN_BINARY(testSubMemImm, int32Operands(), int32Operands());
16944     RUN_BINARY(testSubNeg, int32Operands(), int32Operands());
16945     RUN_BINARY(testNegSub, int32Operands(), int32Operands());
16946     RUN_UNARY(testNegValueSubOne, int32Operands());
16947 
16948     RUN(testSubArgs32(1, 1));
16949     RUN(testSubArgs32(1, 2));
16950     RUN(testSubArgs32(13, -42));
16951     RUN(testSubArgs32(-13, 42));
16952     RUN(testSubArgImm32(1, 1));
16953     RUN(testSubArgImm32(1, 2));
16954     RUN(testSubArgImm32(13, -42));
16955     RUN(testSubArgImm32(-13, 42));
16956     RUN(testSubImmArg32(1, 1));
16957     RUN(testSubImmArg32(1, 2));
16958     RUN(testSubImmArg32(13, -42));
16959     RUN(testSubImmArg32(-13, 42));
16960     RUN_BINARY(testSubArgMem32, int32Operands(), int32Operands());
16961     RUN_BINARY(testSubMemArg32, int32Operands(), int32Operands());
16962     RUN_BINARY(testSubImmMem32, int32Operands(), int32Operands());
16963     RUN_BINARY(testSubMemImm32, int32Operands(), int32Operands());
16964     RUN_UNARY(testNegValueSubOne32, int64Operands());
16965 
16966     RUN_UNARY(testSubArgDouble, floatingPointOperands&lt;double&gt;());
16967     RUN_BINARY(testSubArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16968     RUN_BINARY(testSubArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16969     RUN_BINARY(testSubImmArgDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16970     RUN_BINARY(testSubImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
16971     RUN_UNARY(testSubArgFloat, floatingPointOperands&lt;float&gt;());
16972     RUN_BINARY(testSubArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16973     RUN_BINARY(testSubArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16974     RUN_BINARY(testSubImmArgFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16975     RUN_BINARY(testSubImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16976     RUN_UNARY(testSubArgFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
16977     RUN_BINARY(testSubArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16978     RUN_BINARY(testSubArgsFloatWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
16979 
16980     RUN_UNARY(testNegDouble, floatingPointOperands&lt;double&gt;());
16981     RUN_UNARY(testNegFloat, floatingPointOperands&lt;float&gt;());
16982     RUN_UNARY(testNegFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
16983 
16984     RUN(testBitAndArgs(43, 43));
16985     RUN(testBitAndArgs(43, 0));
16986     RUN(testBitAndArgs(10, 3));
16987     RUN(testBitAndArgs(42, 0xffffffffffffffff));
16988     RUN(testBitAndSameArg(43));
16989     RUN(testBitAndSameArg(0));
16990     RUN(testBitAndSameArg(3));
16991     RUN(testBitAndSameArg(0xffffffffffffffff));
16992     RUN(testBitAndImms(43, 43));
16993     RUN(testBitAndImms(43, 0));
16994     RUN(testBitAndImms(10, 3));
16995     RUN(testBitAndImms(42, 0xffffffffffffffff));
16996     RUN(testBitAndArgImm(43, 43));
16997     RUN(testBitAndArgImm(43, 0));
16998     RUN(testBitAndArgImm(10, 3));
16999     RUN(testBitAndArgImm(42, 0xffffffffffffffff));
17000     RUN(testBitAndArgImm(42, 0xff));
17001     RUN(testBitAndArgImm(300, 0xff));
17002     RUN(testBitAndArgImm(-300, 0xff));
17003     RUN(testBitAndArgImm(42, 0xffff));
17004     RUN(testBitAndArgImm(40000, 0xffff));
17005     RUN(testBitAndArgImm(-40000, 0xffff));
17006     RUN(testBitAndImmArg(43, 43));
17007     RUN(testBitAndImmArg(43, 0));
17008     RUN(testBitAndImmArg(10, 3));
17009     RUN(testBitAndImmArg(42, 0xffffffffffffffff));
17010     RUN(testBitAndBitAndArgImmImm(2, 7, 3));
17011     RUN(testBitAndBitAndArgImmImm(1, 6, 6));
17012     RUN(testBitAndBitAndArgImmImm(0xffff, 24, 7));
17013     RUN(testBitAndImmBitAndArgImm(7, 2, 3));
17014     RUN(testBitAndImmBitAndArgImm(6, 1, 6));
17015     RUN(testBitAndImmBitAndArgImm(24, 0xffff, 7));
17016     RUN(testBitAndArgs32(43, 43));
17017     RUN(testBitAndArgs32(43, 0));
17018     RUN(testBitAndArgs32(10, 3));
17019     RUN(testBitAndArgs32(42, 0xffffffff));
17020     RUN(testBitAndSameArg32(43));
17021     RUN(testBitAndSameArg32(0));
17022     RUN(testBitAndSameArg32(3));
17023     RUN(testBitAndSameArg32(0xffffffff));
17024     RUN(testBitAndImms32(43, 43));
17025     RUN(testBitAndImms32(43, 0));
17026     RUN(testBitAndImms32(10, 3));
17027     RUN(testBitAndImms32(42, 0xffffffff));
17028     RUN(testBitAndArgImm32(43, 43));
17029     RUN(testBitAndArgImm32(43, 0));
17030     RUN(testBitAndArgImm32(10, 3));
17031     RUN(testBitAndArgImm32(42, 0xffffffff));
17032     RUN(testBitAndImmArg32(43, 43));
17033     RUN(testBitAndImmArg32(43, 0));
17034     RUN(testBitAndImmArg32(10, 3));
17035     RUN(testBitAndImmArg32(42, 0xffffffff));
17036     RUN(testBitAndImmArg32(42, 0xff));
17037     RUN(testBitAndImmArg32(300, 0xff));
17038     RUN(testBitAndImmArg32(-300, 0xff));
17039     RUN(testBitAndImmArg32(42, 0xffff));
17040     RUN(testBitAndImmArg32(40000, 0xffff));
17041     RUN(testBitAndImmArg32(-40000, 0xffff));
17042     RUN(testBitAndBitAndArgImmImm32(2, 7, 3));
17043     RUN(testBitAndBitAndArgImmImm32(1, 6, 6));
17044     RUN(testBitAndBitAndArgImmImm32(0xffff, 24, 7));
17045     RUN(testBitAndImmBitAndArgImm32(7, 2, 3));
17046     RUN(testBitAndImmBitAndArgImm32(6, 1, 6));
17047     RUN(testBitAndImmBitAndArgImm32(24, 0xffff, 7));
17048     RUN_BINARY(testBitAndWithMaskReturnsBooleans, int64Operands(), int64Operands());
17049     RUN_UNARY(testBitAndArgDouble, floatingPointOperands&lt;double&gt;());
17050     RUN_BINARY(testBitAndArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17051     RUN_BINARY(testBitAndArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17052     RUN_BINARY(testBitAndImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17053     RUN_UNARY(testBitAndArgFloat, floatingPointOperands&lt;float&gt;());
17054     RUN_BINARY(testBitAndArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17055     RUN_BINARY(testBitAndArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17056     RUN_BINARY(testBitAndImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17057     RUN_BINARY(testBitAndArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17058     RUN_BINARY(testBitAndNotNot, int64Operands(), int64Operands());
17059     RUN_BINARY(testBitAndNotImm, int64Operands(), int64Operands());
17060 
17061     RUN(testBitOrArgs(43, 43));
17062     RUN(testBitOrArgs(43, 0));
17063     RUN(testBitOrArgs(10, 3));
17064     RUN(testBitOrArgs(42, 0xffffffffffffffff));
17065     RUN(testBitOrSameArg(43));
17066     RUN(testBitOrSameArg(0));
17067     RUN(testBitOrSameArg(3));
17068     RUN(testBitOrSameArg(0xffffffffffffffff));
17069     RUN(testBitOrImms(43, 43));
17070     RUN(testBitOrImms(43, 0));
17071     RUN(testBitOrImms(10, 3));
17072     RUN(testBitOrImms(42, 0xffffffffffffffff));
17073     RUN(testBitOrArgImm(43, 43));
17074     RUN(testBitOrArgImm(43, 0));
17075     RUN(testBitOrArgImm(10, 3));
17076     RUN(testBitOrArgImm(42, 0xffffffffffffffff));
17077     RUN(testBitOrImmArg(43, 43));
17078     RUN(testBitOrImmArg(43, 0));
17079     RUN(testBitOrImmArg(10, 3));
17080     RUN(testBitOrImmArg(42, 0xffffffffffffffff));
17081     RUN(testBitOrBitOrArgImmImm(2, 7, 3));
17082     RUN(testBitOrBitOrArgImmImm(1, 6, 6));
17083     RUN(testBitOrBitOrArgImmImm(0xffff, 24, 7));
17084     RUN(testBitOrImmBitOrArgImm(7, 2, 3));
17085     RUN(testBitOrImmBitOrArgImm(6, 1, 6));
17086     RUN(testBitOrImmBitOrArgImm(24, 0xffff, 7));
17087     RUN(testBitOrArgs32(43, 43));
17088     RUN(testBitOrArgs32(43, 0));
17089     RUN(testBitOrArgs32(10, 3));
17090     RUN(testBitOrArgs32(42, 0xffffffff));
17091     RUN(testBitOrSameArg32(43));
17092     RUN(testBitOrSameArg32(0));
17093     RUN(testBitOrSameArg32(3));
17094     RUN(testBitOrSameArg32(0xffffffff));
17095     RUN(testBitOrImms32(43, 43));
17096     RUN(testBitOrImms32(43, 0));
17097     RUN(testBitOrImms32(10, 3));
17098     RUN(testBitOrImms32(42, 0xffffffff));
17099     RUN(testBitOrArgImm32(43, 43));
17100     RUN(testBitOrArgImm32(43, 0));
17101     RUN(testBitOrArgImm32(10, 3));
17102     RUN(testBitOrArgImm32(42, 0xffffffff));
17103     RUN(testBitOrImmArg32(43, 43));
17104     RUN(testBitOrImmArg32(43, 0));
17105     RUN(testBitOrImmArg32(10, 3));
17106     RUN(testBitOrImmArg32(42, 0xffffffff));
17107     RUN(testBitOrBitOrArgImmImm32(2, 7, 3));
17108     RUN(testBitOrBitOrArgImmImm32(1, 6, 6));
17109     RUN(testBitOrBitOrArgImmImm32(0xffff, 24, 7));
17110     RUN(testBitOrImmBitOrArgImm32(7, 2, 3));
17111     RUN(testBitOrImmBitOrArgImm32(6, 1, 6));
17112     RUN(testBitOrImmBitOrArgImm32(24, 0xffff, 7));
17113     RUN_UNARY(testBitOrArgDouble, floatingPointOperands&lt;double&gt;());
17114     RUN_BINARY(testBitOrArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17115     RUN_BINARY(testBitOrArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17116     RUN_BINARY(testBitOrImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17117     RUN_UNARY(testBitOrArgFloat, floatingPointOperands&lt;float&gt;());
17118     RUN_BINARY(testBitOrArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17119     RUN_BINARY(testBitOrArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17120     RUN_BINARY(testBitOrImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17121     RUN_BINARY(testBitOrArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17122     RUN_TERNARY(testBitOrAndAndArgs, int64Operands(), int64Operands(), int64Operands());
17123     RUN_BINARY(testBitOrAndSameArgs, int64Operands(), int64Operands());
17124     RUN_BINARY(testBitOrNotNot, int64Operands(), int64Operands());
17125     RUN_BINARY(testBitOrNotImm, int64Operands(), int64Operands());
17126 
17127     RUN_BINARY(testBitXorArgs, int64Operands(), int64Operands());
17128     RUN_UNARY(testBitXorSameArg, int64Operands());
17129     RUN_BINARY(testBitXorImms, int64Operands(), int64Operands());
17130     RUN_BINARY(testBitXorArgImm, int64Operands(), int64Operands());
17131     RUN_BINARY(testBitXorImmArg, int64Operands(), int64Operands());
17132     RUN(testBitXorBitXorArgImmImm(2, 7, 3));
17133     RUN(testBitXorBitXorArgImmImm(1, 6, 6));
17134     RUN(testBitXorBitXorArgImmImm(0xffff, 24, 7));
17135     RUN(testBitXorImmBitXorArgImm(7, 2, 3));
17136     RUN(testBitXorImmBitXorArgImm(6, 1, 6));
17137     RUN(testBitXorImmBitXorArgImm(24, 0xffff, 7));
17138     RUN(testBitXorArgs32(43, 43));
17139     RUN(testBitXorArgs32(43, 0));
17140     RUN(testBitXorArgs32(10, 3));
17141     RUN(testBitXorArgs32(42, 0xffffffff));
17142     RUN(testBitXorSameArg32(43));
17143     RUN(testBitXorSameArg32(0));
17144     RUN(testBitXorSameArg32(3));
17145     RUN(testBitXorSameArg32(0xffffffff));
17146     RUN(testBitXorImms32(43, 43));
17147     RUN(testBitXorImms32(43, 0));
17148     RUN(testBitXorImms32(10, 3));
17149     RUN(testBitXorImms32(42, 0xffffffff));
17150     RUN(testBitXorArgImm32(43, 43));
17151     RUN(testBitXorArgImm32(43, 0));
17152     RUN(testBitXorArgImm32(10, 3));
17153     RUN(testBitXorArgImm32(42, 0xffffffff));
17154     RUN(testBitXorImmArg32(43, 43));
17155     RUN(testBitXorImmArg32(43, 0));
17156     RUN(testBitXorImmArg32(10, 3));
17157     RUN(testBitXorImmArg32(42, 0xffffffff));
17158     RUN(testBitXorBitXorArgImmImm32(2, 7, 3));
17159     RUN(testBitXorBitXorArgImmImm32(1, 6, 6));
17160     RUN(testBitXorBitXorArgImmImm32(0xffff, 24, 7));
17161     RUN(testBitXorImmBitXorArgImm32(7, 2, 3));
17162     RUN(testBitXorImmBitXorArgImm32(6, 1, 6));
17163     RUN(testBitXorImmBitXorArgImm32(24, 0xffff, 7));
17164     RUN_TERNARY(testBitXorAndAndArgs, int64Operands(), int64Operands(), int64Operands());
17165     RUN_BINARY(testBitXorAndSameArgs, int64Operands(), int64Operands());
17166 
17167     RUN_UNARY(testBitNotArg, int64Operands());
17168     RUN_UNARY(testBitNotImm, int64Operands());
17169     RUN_UNARY(testBitNotMem, int64Operands());
17170     RUN_UNARY(testBitNotArg32, int32Operands());
17171     RUN_UNARY(testBitNotImm32, int32Operands());
17172     RUN_UNARY(testBitNotMem32, int32Operands());
17173     RUN_BINARY(testNotOnBooleanAndBranch32, int32Operands(), int32Operands());
17174     RUN_BINARY(testBitNotOnBooleanAndBranch32, int32Operands(), int32Operands());
17175 
17176     RUN(testShlArgs(1, 0));
17177     RUN(testShlArgs(1, 1));
17178     RUN(testShlArgs(1, 62));
17179     RUN(testShlArgs(0xffffffffffffffff, 0));
17180     RUN(testShlArgs(0xffffffffffffffff, 1));
17181     RUN(testShlArgs(0xffffffffffffffff, 63));
17182     RUN(testShlImms(1, 0));
17183     RUN(testShlImms(1, 1));
17184     RUN(testShlImms(1, 62));
17185     RUN(testShlImms(1, 65));
17186     RUN(testShlImms(0xffffffffffffffff, 0));
17187     RUN(testShlImms(0xffffffffffffffff, 1));
17188     RUN(testShlImms(0xffffffffffffffff, 63));
17189     RUN(testShlArgImm(1, 0));
17190     RUN(testShlArgImm(1, 1));
17191     RUN(testShlArgImm(1, 62));
17192     RUN(testShlArgImm(1, 65));
17193     RUN(testShlArgImm(0xffffffffffffffff, 0));
17194     RUN(testShlArgImm(0xffffffffffffffff, 1));
17195     RUN(testShlArgImm(0xffffffffffffffff, 63));
17196     RUN(testShlArg32(2));
17197     RUN(testShlArgs32(1, 0));
17198     RUN(testShlArgs32(1, 1));
17199     RUN(testShlArgs32(1, 62));
17200     RUN(testShlImms32(1, 33));
17201     RUN(testShlArgs32(0xffffffff, 0));
17202     RUN(testShlArgs32(0xffffffff, 1));
17203     RUN(testShlArgs32(0xffffffff, 63));
17204     RUN(testShlImms32(1, 0));
17205     RUN(testShlImms32(1, 1));
17206     RUN(testShlImms32(1, 62));
17207     RUN(testShlImms32(1, 33));
17208     RUN(testShlImms32(0xffffffff, 0));
17209     RUN(testShlImms32(0xffffffff, 1));
17210     RUN(testShlImms32(0xffffffff, 63));
17211     RUN(testShlArgImm32(1, 0));
17212     RUN(testShlArgImm32(1, 1));
17213     RUN(testShlArgImm32(1, 62));
17214     RUN(testShlArgImm32(0xffffffff, 0));
17215     RUN(testShlArgImm32(0xffffffff, 1));
17216     RUN(testShlArgImm32(0xffffffff, 63));
17217 
17218     RUN(testSShrArgs(1, 0));
17219     RUN(testSShrArgs(1, 1));
17220     RUN(testSShrArgs(1, 62));
17221     RUN(testSShrArgs(0xffffffffffffffff, 0));
17222     RUN(testSShrArgs(0xffffffffffffffff, 1));
17223     RUN(testSShrArgs(0xffffffffffffffff, 63));
17224     RUN(testSShrImms(1, 0));
17225     RUN(testSShrImms(1, 1));
17226     RUN(testSShrImms(1, 62));
17227     RUN(testSShrImms(1, 65));
17228     RUN(testSShrImms(0xffffffffffffffff, 0));
17229     RUN(testSShrImms(0xffffffffffffffff, 1));
17230     RUN(testSShrImms(0xffffffffffffffff, 63));
17231     RUN(testSShrArgImm(1, 0));
17232     RUN(testSShrArgImm(1, 1));
17233     RUN(testSShrArgImm(1, 62));
17234     RUN(testSShrArgImm(1, 65));
17235     RUN(testSShrArgImm(0xffffffffffffffff, 0));
17236     RUN(testSShrArgImm(0xffffffffffffffff, 1));
17237     RUN(testSShrArgImm(0xffffffffffffffff, 63));
17238     RUN(testSShrArg32(32));
17239     RUN(testSShrArgs32(1, 0));
17240     RUN(testSShrArgs32(1, 1));
17241     RUN(testSShrArgs32(1, 62));
17242     RUN(testSShrArgs32(1, 33));
17243     RUN(testSShrArgs32(0xffffffff, 0));
17244     RUN(testSShrArgs32(0xffffffff, 1));
17245     RUN(testSShrArgs32(0xffffffff, 63));
17246     RUN(testSShrImms32(1, 0));
17247     RUN(testSShrImms32(1, 1));
17248     RUN(testSShrImms32(1, 62));
17249     RUN(testSShrImms32(1, 33));
17250     RUN(testSShrImms32(0xffffffff, 0));
17251     RUN(testSShrImms32(0xffffffff, 1));
17252     RUN(testSShrImms32(0xffffffff, 63));
17253     RUN(testSShrArgImm32(1, 0));
17254     RUN(testSShrArgImm32(1, 1));
17255     RUN(testSShrArgImm32(1, 62));
17256     RUN(testSShrArgImm32(0xffffffff, 0));
17257     RUN(testSShrArgImm32(0xffffffff, 1));
17258     RUN(testSShrArgImm32(0xffffffff, 63));
17259 
17260     RUN(testZShrArgs(1, 0));
17261     RUN(testZShrArgs(1, 1));
17262     RUN(testZShrArgs(1, 62));
17263     RUN(testZShrArgs(0xffffffffffffffff, 0));
17264     RUN(testZShrArgs(0xffffffffffffffff, 1));
17265     RUN(testZShrArgs(0xffffffffffffffff, 63));
17266     RUN(testZShrImms(1, 0));
17267     RUN(testZShrImms(1, 1));
17268     RUN(testZShrImms(1, 62));
17269     RUN(testZShrImms(1, 65));
17270     RUN(testZShrImms(0xffffffffffffffff, 0));
17271     RUN(testZShrImms(0xffffffffffffffff, 1));
17272     RUN(testZShrImms(0xffffffffffffffff, 63));
17273     RUN(testZShrArgImm(1, 0));
17274     RUN(testZShrArgImm(1, 1));
17275     RUN(testZShrArgImm(1, 62));
17276     RUN(testZShrArgImm(1, 65));
17277     RUN(testZShrArgImm(0xffffffffffffffff, 0));
17278     RUN(testZShrArgImm(0xffffffffffffffff, 1));
17279     RUN(testZShrArgImm(0xffffffffffffffff, 63));
17280     RUN(testZShrArg32(32));
17281     RUN(testZShrArgs32(1, 0));
17282     RUN(testZShrArgs32(1, 1));
17283     RUN(testZShrArgs32(1, 62));
17284     RUN(testZShrArgs32(1, 33));
17285     RUN(testZShrArgs32(0xffffffff, 0));
17286     RUN(testZShrArgs32(0xffffffff, 1));
17287     RUN(testZShrArgs32(0xffffffff, 63));
17288     RUN(testZShrImms32(1, 0));
17289     RUN(testZShrImms32(1, 1));
17290     RUN(testZShrImms32(1, 62));
17291     RUN(testZShrImms32(1, 33));
17292     RUN(testZShrImms32(0xffffffff, 0));
17293     RUN(testZShrImms32(0xffffffff, 1));
17294     RUN(testZShrImms32(0xffffffff, 63));
17295     RUN(testZShrArgImm32(1, 0));
17296     RUN(testZShrArgImm32(1, 1));
17297     RUN(testZShrArgImm32(1, 62));
17298     RUN(testZShrArgImm32(0xffffffff, 0));
17299     RUN(testZShrArgImm32(0xffffffff, 1));
17300     RUN(testZShrArgImm32(0xffffffff, 63));
17301 
17302     RUN_UNARY(testClzArg64, int64Operands());
17303     RUN_UNARY(testClzMem64, int64Operands());
17304     RUN_UNARY(testClzArg32, int32Operands());
17305     RUN_UNARY(testClzMem32, int64Operands());
17306 
17307     RUN_UNARY(testAbsArg, floatingPointOperands&lt;double&gt;());
17308     RUN_UNARY(testAbsImm, floatingPointOperands&lt;double&gt;());
17309     RUN_UNARY(testAbsMem, floatingPointOperands&lt;double&gt;());
17310     RUN_UNARY(testAbsAbsArg, floatingPointOperands&lt;double&gt;());
17311     RUN_UNARY(testAbsNegArg, floatingPointOperands&lt;double&gt;());
17312     RUN_UNARY(testAbsBitwiseCastArg, floatingPointOperands&lt;double&gt;());
17313     RUN_UNARY(testBitwiseCastAbsBitwiseCastArg, floatingPointOperands&lt;double&gt;());
17314     RUN_UNARY(testAbsArg, floatingPointOperands&lt;float&gt;());
17315     RUN_UNARY(testAbsImm, floatingPointOperands&lt;float&gt;());
17316     RUN_UNARY(testAbsMem, floatingPointOperands&lt;float&gt;());
17317     RUN_UNARY(testAbsAbsArg, floatingPointOperands&lt;float&gt;());
17318     RUN_UNARY(testAbsNegArg, floatingPointOperands&lt;float&gt;());
17319     RUN_UNARY(testAbsBitwiseCastArg, floatingPointOperands&lt;float&gt;());
17320     RUN_UNARY(testBitwiseCastAbsBitwiseCastArg, floatingPointOperands&lt;float&gt;());
17321     RUN_UNARY(testAbsArgWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
17322     RUN_UNARY(testAbsArgWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;());
17323 
17324     RUN_UNARY(testCeilArg, floatingPointOperands&lt;double&gt;());
17325     RUN_UNARY(testCeilImm, floatingPointOperands&lt;double&gt;());
17326     RUN_UNARY(testCeilMem, floatingPointOperands&lt;double&gt;());
17327     RUN_UNARY(testCeilCeilArg, floatingPointOperands&lt;double&gt;());
17328     RUN_UNARY(testFloorCeilArg, floatingPointOperands&lt;double&gt;());
17329     RUN_UNARY(testCeilIToD64, int64Operands());
17330     RUN_UNARY(testCeilIToD32, int32Operands());
17331     RUN_UNARY(testCeilArg, floatingPointOperands&lt;float&gt;());
17332     RUN_UNARY(testCeilImm, floatingPointOperands&lt;float&gt;());
17333     RUN_UNARY(testCeilMem, floatingPointOperands&lt;float&gt;());
17334     RUN_UNARY(testCeilCeilArg, floatingPointOperands&lt;float&gt;());
17335     RUN_UNARY(testFloorCeilArg, floatingPointOperands&lt;float&gt;());
17336     RUN_UNARY(testCeilArgWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
17337     RUN_UNARY(testCeilArgWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;());
17338 
17339     RUN_UNARY(testFloorArg, floatingPointOperands&lt;double&gt;());
17340     RUN_UNARY(testFloorImm, floatingPointOperands&lt;double&gt;());
17341     RUN_UNARY(testFloorMem, floatingPointOperands&lt;double&gt;());
17342     RUN_UNARY(testFloorFloorArg, floatingPointOperands&lt;double&gt;());
17343     RUN_UNARY(testCeilFloorArg, floatingPointOperands&lt;double&gt;());
17344     RUN_UNARY(testFloorIToD64, int64Operands());
17345     RUN_UNARY(testFloorIToD32, int32Operands());
17346     RUN_UNARY(testFloorArg, floatingPointOperands&lt;float&gt;());
17347     RUN_UNARY(testFloorImm, floatingPointOperands&lt;float&gt;());
17348     RUN_UNARY(testFloorMem, floatingPointOperands&lt;float&gt;());
17349     RUN_UNARY(testFloorFloorArg, floatingPointOperands&lt;float&gt;());
17350     RUN_UNARY(testCeilFloorArg, floatingPointOperands&lt;float&gt;());
17351     RUN_UNARY(testFloorArgWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
17352     RUN_UNARY(testFloorArgWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;());
17353 
17354     RUN_UNARY(testSqrtArg, floatingPointOperands&lt;double&gt;());
17355     RUN_UNARY(testSqrtImm, floatingPointOperands&lt;double&gt;());
17356     RUN_UNARY(testSqrtMem, floatingPointOperands&lt;double&gt;());
17357     RUN_UNARY(testSqrtArg, floatingPointOperands&lt;float&gt;());
17358     RUN_UNARY(testSqrtImm, floatingPointOperands&lt;float&gt;());
17359     RUN_UNARY(testSqrtMem, floatingPointOperands&lt;float&gt;());
17360     RUN_UNARY(testSqrtArgWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;());
17361     RUN_UNARY(testSqrtArgWithEffectfulDoubleConversion, floatingPointOperands&lt;float&gt;());
17362 
17363     RUN_BINARY(testCompareTwoFloatToDouble, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17364     RUN_BINARY(testCompareOneFloatToDouble, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;double&gt;());
17365     RUN_BINARY(testCompareFloatToDoubleThroughPhi, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17366     RUN_UNARY(testDoubleToFloatThroughPhi, floatingPointOperands&lt;float&gt;());
17367     RUN(testReduceFloatToDoubleValidates());
17368     RUN_UNARY(testDoubleProducerPhiToFloatConversion, floatingPointOperands&lt;float&gt;());
17369     RUN_UNARY(testDoubleProducerPhiToFloatConversionWithDoubleConsumer, floatingPointOperands&lt;float&gt;());
17370     RUN_BINARY(testDoubleProducerPhiWithNonFloatConst, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;double&gt;());
17371 
17372     RUN_UNARY(testDoubleArgToInt64BitwiseCast, floatingPointOperands&lt;double&gt;());
17373     RUN_UNARY(testDoubleImmToInt64BitwiseCast, floatingPointOperands&lt;double&gt;());
17374     RUN_UNARY(testTwoBitwiseCastOnDouble, floatingPointOperands&lt;double&gt;());
17375     RUN_UNARY(testBitwiseCastOnDoubleInMemory, floatingPointOperands&lt;double&gt;());
17376     RUN_UNARY(testBitwiseCastOnDoubleInMemoryIndexed, floatingPointOperands&lt;double&gt;());
17377     RUN_UNARY(testInt64BArgToDoubleBitwiseCast, int64Operands());
17378     RUN_UNARY(testInt64BImmToDoubleBitwiseCast, int64Operands());
17379     RUN_UNARY(testTwoBitwiseCastOnInt64, int64Operands());
17380     RUN_UNARY(testBitwiseCastOnInt64InMemory, int64Operands());
17381     RUN_UNARY(testBitwiseCastOnInt64InMemoryIndexed, int64Operands());
17382     RUN_UNARY(testFloatImmToInt32BitwiseCast, floatingPointOperands&lt;float&gt;());
17383     RUN_UNARY(testBitwiseCastOnFloatInMemory, floatingPointOperands&lt;float&gt;());
17384     RUN_UNARY(testInt32BArgToFloatBitwiseCast, int32Operands());
17385     RUN_UNARY(testInt32BImmToFloatBitwiseCast, int32Operands());
17386     RUN_UNARY(testTwoBitwiseCastOnInt32, int32Operands());
17387     RUN_UNARY(testBitwiseCastOnInt32InMemory, int32Operands());
17388 
17389     RUN_UNARY(testConvertDoubleToFloatArg, floatingPointOperands&lt;double&gt;());
17390     RUN_UNARY(testConvertDoubleToFloatImm, floatingPointOperands&lt;double&gt;());
17391     RUN_UNARY(testConvertDoubleToFloatMem, floatingPointOperands&lt;double&gt;());
17392     RUN_UNARY(testConvertFloatToDoubleArg, floatingPointOperands&lt;float&gt;());
17393     RUN_UNARY(testConvertFloatToDoubleImm, floatingPointOperands&lt;float&gt;());
17394     RUN_UNARY(testConvertFloatToDoubleMem, floatingPointOperands&lt;float&gt;());
17395     RUN_UNARY(testConvertDoubleToFloatToDoubleToFloat, floatingPointOperands&lt;double&gt;());
17396     RUN_UNARY(testStoreFloat, floatingPointOperands&lt;double&gt;());
17397     RUN_UNARY(testStoreDoubleConstantAsFloat, floatingPointOperands&lt;double&gt;());
17398     RUN_UNARY(testLoadFloatConvertDoubleConvertFloatStoreFloat, floatingPointOperands&lt;float&gt;());
17399     RUN_UNARY(testFroundArg, floatingPointOperands&lt;double&gt;());
17400     RUN_UNARY(testFroundMem, floatingPointOperands&lt;double&gt;());
17401 
17402     RUN(testIToD64Arg());
17403     RUN(testIToF64Arg());
17404     RUN(testIToD32Arg());
17405     RUN(testIToF32Arg());
17406     RUN(testIToD64Mem());
17407     RUN(testIToF64Mem());
17408     RUN(testIToD32Mem());
17409     RUN(testIToF32Mem());
17410     RUN_UNARY(testIToD64Imm, int64Operands());
17411     RUN_UNARY(testIToF64Imm, int64Operands());
17412     RUN_UNARY(testIToD32Imm, int32Operands());
17413     RUN_UNARY(testIToF32Imm, int32Operands());
17414     RUN(testIToDReducedToIToF64Arg());
17415     RUN(testIToDReducedToIToF32Arg());
17416 
17417     RUN(testStore32(44));
17418     RUN(testStoreConstant(49));
17419     RUN(testStoreConstantPtr(49));
17420     RUN(testStore8Arg());
17421     RUN(testStore8Imm());
17422     RUN(testStorePartial8BitRegisterOnX86());
17423     RUN(testStore16Arg());
17424     RUN(testStore16Imm());
17425     RUN(testTrunc((static_cast&lt;int64_t&gt;(1) &lt;&lt; 40) + 42));
17426     RUN(testAdd1(45));
17427     RUN(testAdd1Ptr(51));
17428     RUN(testAdd1Ptr(static_cast&lt;intptr_t&gt;(0xbaadbeef)));
17429     RUN(testNeg32(52));
17430     RUN(testNegPtr(53));
17431     RUN(testStoreAddLoad32(46));
17432     RUN(testStoreRelAddLoadAcq32(46));
17433     RUN(testStoreAddLoadImm32(46));
17434     RUN(testStoreAddLoad64(4600));
17435     RUN(testStoreRelAddLoadAcq64(4600));
17436     RUN(testStoreAddLoadImm64(4600));
17437     RUN(testStoreAddLoad8(4, Load8Z));
17438     RUN(testStoreRelAddLoadAcq8(4, Load8Z));
17439     RUN(testStoreRelAddFenceLoadAcq8(4, Load8Z));
17440     RUN(testStoreAddLoadImm8(4, Load8Z));
17441     RUN(testStoreAddLoad8(4, Load8S));
17442     RUN(testStoreRelAddLoadAcq8(4, Load8S));
17443     RUN(testStoreAddLoadImm8(4, Load8S));
17444     RUN(testStoreAddLoad16(6, Load16Z));
17445     RUN(testStoreRelAddLoadAcq16(6, Load16Z));
17446     RUN(testStoreAddLoadImm16(6, Load16Z));
17447     RUN(testStoreAddLoad16(6, Load16S));
17448     RUN(testStoreRelAddLoadAcq16(6, Load16S));
17449     RUN(testStoreAddLoadImm16(6, Load16S));
17450     RUN(testStoreAddLoad32Index(46));
17451     RUN(testStoreAddLoadImm32Index(46));
17452     RUN(testStoreAddLoad64Index(4600));
17453     RUN(testStoreAddLoadImm64Index(4600));
17454     RUN(testStoreAddLoad8Index(4, Load8Z));
17455     RUN(testStoreAddLoadImm8Index(4, Load8Z));
17456     RUN(testStoreAddLoad8Index(4, Load8S));
17457     RUN(testStoreAddLoadImm8Index(4, Load8S));
17458     RUN(testStoreAddLoad16Index(6, Load16Z));
17459     RUN(testStoreAddLoadImm16Index(6, Load16Z));
17460     RUN(testStoreAddLoad16Index(6, Load16S));
17461     RUN(testStoreAddLoadImm16Index(6, Load16S));
17462     RUN(testStoreSubLoad(46));
17463     RUN(testStoreAddLoadInterference(52));
17464     RUN(testStoreAddAndLoad(47, 0xffff));
17465     RUN(testStoreAddAndLoad(470000, 0xffff));
17466     RUN(testStoreNegLoad32(54));
17467     RUN(testStoreNegLoadPtr(55));
17468     RUN(testAdd1Uncommuted(48));
17469     RUN(testLoadOffset());
17470     RUN(testLoadOffsetNotConstant());
17471     RUN(testLoadOffsetUsingAdd());
17472     RUN(testLoadOffsetUsingAddInterference());
17473     RUN(testLoadOffsetUsingAddNotConstant());
17474     RUN(testLoadAddrShift(0));
17475     RUN(testLoadAddrShift(1));
17476     RUN(testLoadAddrShift(2));
17477     RUN(testLoadAddrShift(3));
17478     RUN(testFramePointer());
17479     RUN(testOverrideFramePointer());
17480     RUN(testStackSlot());
17481     RUN(testLoadFromFramePointer());
17482     RUN(testStoreLoadStackSlot(50));
17483 
17484     RUN(testBranch());
17485     RUN(testBranchPtr());
17486     RUN(testDiamond());
17487     RUN(testBranchNotEqual());
17488     RUN(testBranchNotEqualCommute());
17489     RUN(testBranchNotEqualNotEqual());
17490     RUN(testBranchEqual());
17491     RUN(testBranchEqualEqual());
17492     RUN(testBranchEqualCommute());
17493     RUN(testBranchEqualEqual1());
17494     RUN_BINARY(testBranchEqualOrUnorderedArgs, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17495     RUN_BINARY(testBranchEqualOrUnorderedArgs, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17496     RUN_BINARY(testBranchNotEqualAndOrderedArgs, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17497     RUN_BINARY(testBranchNotEqualAndOrderedArgs, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17498     RUN_BINARY(testBranchEqualOrUnorderedDoubleArgImm, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17499     RUN_BINARY(testBranchEqualOrUnorderedFloatArgImm, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17500     RUN_BINARY(testBranchEqualOrUnorderedDoubleImms, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17501     RUN_BINARY(testBranchEqualOrUnorderedFloatImms, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17502     RUN_BINARY(testBranchEqualOrUnorderedFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17503     RUN_BINARY(testBranchNotEqualAndOrderedArgs, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
17504     RUN_BINARY(testBranchNotEqualAndOrderedArgs, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17505     RUN(testBranchFold(42));
17506     RUN(testBranchFold(0));
17507     RUN(testDiamondFold(42));
17508     RUN(testDiamondFold(0));
17509     RUN(testBranchNotEqualFoldPtr(42));
17510     RUN(testBranchNotEqualFoldPtr(0));
17511     RUN(testBranchEqualFoldPtr(42));
17512     RUN(testBranchEqualFoldPtr(0));
17513     RUN(testBranchLoadPtr());
17514     RUN(testBranchLoad32());
17515     RUN(testBranchLoad8S());
17516     RUN(testBranchLoad8Z());
17517     RUN(testBranchLoad16S());
17518     RUN(testBranchLoad16Z());
17519     RUN(testBranch8WithLoad8ZIndex());
17520 
17521     RUN(testComplex(64, 128));
17522     RUN(testComplex(4, 128));
17523     RUN(testComplex(4, 256));
17524     RUN(testComplex(4, 384));
17525 
17526     RUN(testSimplePatchpoint());
17527     RUN(testSimplePatchpointWithoutOuputClobbersGPArgs());
17528     RUN(testSimplePatchpointWithOuputClobbersGPArgs());
17529     RUN(testSimplePatchpointWithoutOuputClobbersFPArgs());
17530     RUN(testSimplePatchpointWithOuputClobbersFPArgs());
17531     RUN(testPatchpointWithEarlyClobber());
17532     RUN(testPatchpointCallArg());
17533     RUN(testPatchpointFixedRegister());
17534     RUN(testPatchpointAny(ValueRep::WarmAny));
17535     RUN(testPatchpointAny(ValueRep::ColdAny));
17536     RUN(testPatchpointGPScratch());
17537     RUN(testPatchpointFPScratch());
17538     RUN(testPatchpointLotsOfLateAnys());
17539     RUN(testPatchpointAnyImm(ValueRep::WarmAny));
17540     RUN(testPatchpointAnyImm(ValueRep::ColdAny));
17541     RUN(testPatchpointAnyImm(ValueRep::LateColdAny));
17542     RUN(testPatchpointManyImms());
17543     RUN(testPatchpointWithRegisterResult());
17544     RUN(testPatchpointWithStackArgumentResult());
17545     RUN(testPatchpointWithAnyResult());
17546     RUN(testSimpleCheck());
17547     RUN(testCheckFalse());
17548     RUN(testCheckTrue());
17549     RUN(testCheckLessThan());
17550     RUN(testCheckMegaCombo());
17551     RUN(testCheckTrickyMegaCombo());
17552     RUN(testCheckTwoMegaCombos());
17553     RUN(testCheckTwoNonRedundantMegaCombos());
17554     RUN(testCheckAddImm());
17555     RUN(testCheckAddImmCommute());
17556     RUN(testCheckAddImmSomeRegister());
17557     RUN(testCheckAdd());
17558     RUN(testCheckAdd64());
17559     RUN(testCheckAddFold(100, 200));
17560     RUN(testCheckAddFoldFail(2147483647, 100));
17561     RUN(testCheckAddArgumentAliasing64());
17562     RUN(testCheckAddArgumentAliasing32());
17563     RUN(testCheckAddSelfOverflow64());
17564     RUN(testCheckAddSelfOverflow32());
17565     RUN(testCheckSubImm());
17566     RUN(testCheckSubBadImm());
17567     RUN(testCheckSub());
17568     RUN(testCheckSub64());
17569     RUN(testCheckSubFold(100, 200));
17570     RUN(testCheckSubFoldFail(-2147483647, 100));
17571     RUN(testCheckNeg());
17572     RUN(testCheckNeg64());
17573     RUN(testCheckMul());
17574     RUN(testCheckMulMemory());
17575     RUN(testCheckMul2());
17576     RUN(testCheckMul64());
17577     RUN(testCheckMulFold(100, 200));
17578     RUN(testCheckMulFoldFail(2147483647, 100));
17579     RUN(testCheckMulArgumentAliasing64());
17580     RUN(testCheckMulArgumentAliasing32());
17581 
17582     RUN_BINARY([](int32_t a, int32_t b) { testCompare(Equal, a, b); }, int64Operands(), int64Operands());
17583     RUN_BINARY([](int32_t a, int32_t b) { testCompare(NotEqual, a, b); }, int64Operands(), int64Operands());
17584     RUN_BINARY([](int32_t a, int32_t b) { testCompare(LessThan, a, b); }, int64Operands(), int64Operands());
17585     RUN_BINARY([](int32_t a, int32_t b) { testCompare(GreaterThan, a, b); }, int64Operands(), int64Operands());
17586     RUN_BINARY([](int32_t a, int32_t b) { testCompare(LessEqual, a, b); }, int64Operands(), int64Operands());
17587     RUN_BINARY([](int32_t a, int32_t b) { testCompare(GreaterEqual, a, b); }, int64Operands(), int64Operands());
17588     RUN_BINARY([](int32_t a, int32_t b) { testCompare(Below, a, b); }, int64Operands(), int64Operands());
17589     RUN_BINARY([](int32_t a, int32_t b) { testCompare(Above, a, b); }, int64Operands(), int64Operands());
17590     RUN_BINARY([](int32_t a, int32_t b) { testCompare(BelowEqual, a, b); }, int64Operands(), int64Operands());
17591     RUN_BINARY([](int32_t a, int32_t b) { testCompare(AboveEqual, a, b); }, int64Operands(), int64Operands());
17592     RUN_BINARY([](int32_t a, int32_t b) { testCompare(BitAnd, a, b); }, int64Operands(), int64Operands());
17593 
17594     RUN(testEqualDouble(42, 42, true));
17595     RUN(testEqualDouble(0, -0, true));
17596     RUN(testEqualDouble(42, 43, false));
17597     RUN(testEqualDouble(PNaN, 42, false));
17598     RUN(testEqualDouble(42, PNaN, false));
17599     RUN(testEqualDouble(PNaN, PNaN, false));
17600 
17601     RUN(testLoad&lt;Int32&gt;(60));
17602     RUN(testLoad&lt;Int32&gt;(-60));
17603     RUN(testLoad&lt;Int32&gt;(1000));
17604     RUN(testLoad&lt;Int32&gt;(-1000));
17605     RUN(testLoad&lt;Int32&gt;(1000000));
17606     RUN(testLoad&lt;Int32&gt;(-1000000));
17607     RUN(testLoad&lt;Int32&gt;(1000000000));
17608     RUN(testLoad&lt;Int32&gt;(-1000000000));
17609     RUN_UNARY(testLoad&lt;Int64&gt;, int64Operands());
17610     RUN_UNARY(testLoad&lt;Float&gt;, floatingPointOperands&lt;float&gt;());
17611     RUN_UNARY(testLoad&lt;Double&gt;, floatingPointOperands&lt;double&gt;());
17612 
17613     RUN(testLoad&lt;int8_t&gt;(Load8S, 60));
17614     RUN(testLoad&lt;int8_t&gt;(Load8S, -60));
17615     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000));
17616     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000));
17617     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000));
17618     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000));
17619     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000000));
17620     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000000));
17621 
17622     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 60));
17623     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -60));
17624     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000));
17625     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000));
17626     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000));
17627     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000));
17628     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000000));
17629     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000000));
17630 
17631     RUN(testLoad&lt;int16_t&gt;(Load16S, 60));
17632     RUN(testLoad&lt;int16_t&gt;(Load16S, -60));
17633     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000));
17634     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000));
17635     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000));
17636     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000));
17637     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000000));
17638     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000000));
17639 
17640     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 60));
17641     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -60));
17642     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000));
17643     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000));
17644     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000));
17645     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000));
17646     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000000));
17647     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000000));
17648 
17649     RUN(testSpillGP());
17650     RUN(testSpillFP());
17651 
17652     RUN(testInt32ToDoublePartialRegisterStall());
17653     RUN(testInt32ToDoublePartialRegisterWithoutStall());
17654 
17655     RUN(testCallSimple(1, 2));
17656     RUN(testCallRare(1, 2));
17657     RUN(testCallRareLive(1, 2, 3));
17658     RUN(testCallSimplePure(1, 2));
17659     RUN(testCallFunctionWithHellaArguments());
17660     RUN(testCallFunctionWithHellaArguments2());
17661     RUN(testCallFunctionWithHellaArguments3());
17662 
17663     RUN(testReturnDouble(0.0));
17664     RUN(testReturnDouble(negativeZero()));
17665     RUN(testReturnDouble(42.5));
17666     RUN_UNARY(testReturnFloat, floatingPointOperands&lt;float&gt;());
17667 
17668     RUN(testCallSimpleDouble(1, 2));
17669     RUN(testCallFunctionWithHellaDoubleArguments());
17670     RUN_BINARY(testCallSimpleFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17671     RUN(testCallFunctionWithHellaFloatArguments());
17672 
17673     RUN(testLinearScanWithCalleeOnStack());
17674 
17675     RUN(testChillDiv(4, 2, 2));
17676     RUN(testChillDiv(1, 0, 0));
17677     RUN(testChillDiv(0, 0, 0));
17678     RUN(testChillDiv(1, -1, -1));
17679     RUN(testChillDiv(-2147483647 - 1, 0, 0));
17680     RUN(testChillDiv(-2147483647 - 1, 1, -2147483647 - 1));
17681     RUN(testChillDiv(-2147483647 - 1, -1, -2147483647 - 1));
17682     RUN(testChillDiv(-2147483647 - 1, 2, -1073741824));
17683     RUN(testChillDiv64(4, 2, 2));
17684     RUN(testChillDiv64(1, 0, 0));
17685     RUN(testChillDiv64(0, 0, 0));
17686     RUN(testChillDiv64(1, -1, -1));
17687     RUN(testChillDiv64(-9223372036854775807ll - 1, 0, 0));
17688     RUN(testChillDiv64(-9223372036854775807ll - 1, 1, -9223372036854775807ll - 1));
17689     RUN(testChillDiv64(-9223372036854775807ll - 1, -1, -9223372036854775807ll - 1));
17690     RUN(testChillDiv64(-9223372036854775807ll - 1, 2, -4611686018427387904));
17691     RUN(testChillDivTwice(4, 2, 6, 2, 5));
17692     RUN(testChillDivTwice(4, 0, 6, 2, 3));
17693     RUN(testChillDivTwice(4, 2, 6, 0, 2));
17694 
17695     RUN_UNARY(testModArg, int64Operands());
17696     RUN_BINARY(testModArgs, int64Operands(), int64Operands());
17697     RUN_BINARY(testModImms, int64Operands(), int64Operands());
17698     RUN_UNARY(testModArg32, int32Operands());
17699     RUN_BINARY(testModArgs32, int32Operands(), int32Operands());
17700     RUN_BINARY(testModImms32, int32Operands(), int32Operands());
17701     RUN_UNARY(testChillModArg, int64Operands());
17702     RUN_BINARY(testChillModArgs, int64Operands(), int64Operands());
17703     RUN_BINARY(testChillModImms, int64Operands(), int64Operands());
17704     RUN_UNARY(testChillModArg32, int32Operands());
17705     RUN_BINARY(testChillModArgs32, int32Operands(), int32Operands());
17706     RUN_BINARY(testChillModImms32, int32Operands(), int32Operands());
17707 
17708     RUN(testSwitch(0, 1));
17709     RUN(testSwitch(1, 1));
17710     RUN(testSwitch(2, 1));
17711     RUN(testSwitch(2, 2));
17712     RUN(testSwitch(10, 1));
17713     RUN(testSwitch(10, 2));
17714     RUN(testSwitch(100, 1));
17715     RUN(testSwitch(100, 100));
17716 
17717     RUN(testSwitchSameCaseAsDefault());
17718 
17719     RUN(testSwitchChillDiv(0, 1));
17720     RUN(testSwitchChillDiv(1, 1));
17721     RUN(testSwitchChillDiv(2, 1));
17722     RUN(testSwitchChillDiv(2, 2));
17723     RUN(testSwitchChillDiv(10, 1));
17724     RUN(testSwitchChillDiv(10, 2));
17725     RUN(testSwitchChillDiv(100, 1));
17726     RUN(testSwitchChillDiv(100, 100));
17727 
17728     RUN(testSwitchTargettingSameBlock());
17729     RUN(testSwitchTargettingSameBlockFoldPathConstant());
17730 
17731     RUN(testTrunc(0));
17732     RUN(testTrunc(1));
17733     RUN(testTrunc(-1));
17734     RUN(testTrunc(1000000000000ll));
17735     RUN(testTrunc(-1000000000000ll));
17736     RUN(testTruncFold(0));
17737     RUN(testTruncFold(1));
17738     RUN(testTruncFold(-1));
17739     RUN(testTruncFold(1000000000000ll));
17740     RUN(testTruncFold(-1000000000000ll));
17741 
17742     RUN(testZExt32(0));
17743     RUN(testZExt32(1));
17744     RUN(testZExt32(-1));
17745     RUN(testZExt32(1000000000ll));
17746     RUN(testZExt32(-1000000000ll));
17747     RUN(testZExt32Fold(0));
17748     RUN(testZExt32Fold(1));
17749     RUN(testZExt32Fold(-1));
17750     RUN(testZExt32Fold(1000000000ll));
17751     RUN(testZExt32Fold(-1000000000ll));
17752 
17753     RUN(testSExt32(0));
17754     RUN(testSExt32(1));
17755     RUN(testSExt32(-1));
17756     RUN(testSExt32(1000000000ll));
17757     RUN(testSExt32(-1000000000ll));
17758     RUN(testSExt32Fold(0));
17759     RUN(testSExt32Fold(1));
17760     RUN(testSExt32Fold(-1));
17761     RUN(testSExt32Fold(1000000000ll));
17762     RUN(testSExt32Fold(-1000000000ll));
17763 
17764     RUN(testTruncZExt32(0));
17765     RUN(testTruncZExt32(1));
17766     RUN(testTruncZExt32(-1));
17767     RUN(testTruncZExt32(1000000000ll));
17768     RUN(testTruncZExt32(-1000000000ll));
17769     RUN(testTruncSExt32(0));
17770     RUN(testTruncSExt32(1));
17771     RUN(testTruncSExt32(-1));
17772     RUN(testTruncSExt32(1000000000ll));
17773     RUN(testTruncSExt32(-1000000000ll));
17774 
17775     RUN(testSExt8(0));
17776     RUN(testSExt8(1));
17777     RUN(testSExt8(42));
17778     RUN(testSExt8(-1));
17779     RUN(testSExt8(0xff));
17780     RUN(testSExt8(0x100));
17781     RUN(testSExt8Fold(0));
17782     RUN(testSExt8Fold(1));
17783     RUN(testSExt8Fold(42));
17784     RUN(testSExt8Fold(-1));
17785     RUN(testSExt8Fold(0xff));
17786     RUN(testSExt8Fold(0x100));
17787     RUN(testSExt8SExt8(0));
17788     RUN(testSExt8SExt8(1));
17789     RUN(testSExt8SExt8(42));
17790     RUN(testSExt8SExt8(-1));
17791     RUN(testSExt8SExt8(0xff));
17792     RUN(testSExt8SExt8(0x100));
17793     RUN(testSExt8SExt16(0));
17794     RUN(testSExt8SExt16(1));
17795     RUN(testSExt8SExt16(42));
17796     RUN(testSExt8SExt16(-1));
17797     RUN(testSExt8SExt16(0xff));
17798     RUN(testSExt8SExt16(0x100));
17799     RUN(testSExt8SExt16(0xffff));
17800     RUN(testSExt8SExt16(0x10000));
17801     RUN(testSExt8BitAnd(0, 0));
17802     RUN(testSExt8BitAnd(1, 0));
17803     RUN(testSExt8BitAnd(42, 0));
17804     RUN(testSExt8BitAnd(-1, 0));
17805     RUN(testSExt8BitAnd(0xff, 0));
17806     RUN(testSExt8BitAnd(0x100, 0));
17807     RUN(testSExt8BitAnd(0xffff, 0));
17808     RUN(testSExt8BitAnd(0x10000, 0));
17809     RUN(testSExt8BitAnd(0, 0xf));
17810     RUN(testSExt8BitAnd(1, 0xf));
17811     RUN(testSExt8BitAnd(42, 0xf));
17812     RUN(testSExt8BitAnd(-1, 0xf));
17813     RUN(testSExt8BitAnd(0xff, 0xf));
17814     RUN(testSExt8BitAnd(0x100, 0xf));
17815     RUN(testSExt8BitAnd(0xffff, 0xf));
17816     RUN(testSExt8BitAnd(0x10000, 0xf));
17817     RUN(testSExt8BitAnd(0, 0xff));
17818     RUN(testSExt8BitAnd(1, 0xff));
17819     RUN(testSExt8BitAnd(42, 0xff));
17820     RUN(testSExt8BitAnd(-1, 0xff));
17821     RUN(testSExt8BitAnd(0xff, 0xff));
17822     RUN(testSExt8BitAnd(0x100, 0xff));
17823     RUN(testSExt8BitAnd(0xffff, 0xff));
17824     RUN(testSExt8BitAnd(0x10000, 0xff));
17825     RUN(testSExt8BitAnd(0, 0x80));
17826     RUN(testSExt8BitAnd(1, 0x80));
17827     RUN(testSExt8BitAnd(42, 0x80));
17828     RUN(testSExt8BitAnd(-1, 0x80));
17829     RUN(testSExt8BitAnd(0xff, 0x80));
17830     RUN(testSExt8BitAnd(0x100, 0x80));
17831     RUN(testSExt8BitAnd(0xffff, 0x80));
17832     RUN(testSExt8BitAnd(0x10000, 0x80));
17833     RUN(testBitAndSExt8(0, 0xf));
17834     RUN(testBitAndSExt8(1, 0xf));
17835     RUN(testBitAndSExt8(42, 0xf));
17836     RUN(testBitAndSExt8(-1, 0xf));
17837     RUN(testBitAndSExt8(0xff, 0xf));
17838     RUN(testBitAndSExt8(0x100, 0xf));
17839     RUN(testBitAndSExt8(0xffff, 0xf));
17840     RUN(testBitAndSExt8(0x10000, 0xf));
17841     RUN(testBitAndSExt8(0, 0xff));
17842     RUN(testBitAndSExt8(1, 0xff));
17843     RUN(testBitAndSExt8(42, 0xff));
17844     RUN(testBitAndSExt8(-1, 0xff));
17845     RUN(testBitAndSExt8(0xff, 0xff));
17846     RUN(testBitAndSExt8(0x100, 0xff));
17847     RUN(testBitAndSExt8(0xffff, 0xff));
17848     RUN(testBitAndSExt8(0x10000, 0xff));
17849     RUN(testBitAndSExt8(0, 0xfff));
17850     RUN(testBitAndSExt8(1, 0xfff));
17851     RUN(testBitAndSExt8(42, 0xfff));
17852     RUN(testBitAndSExt8(-1, 0xfff));
17853     RUN(testBitAndSExt8(0xff, 0xfff));
17854     RUN(testBitAndSExt8(0x100, 0xfff));
17855     RUN(testBitAndSExt8(0xffff, 0xfff));
17856     RUN(testBitAndSExt8(0x10000, 0xfff));
17857 
17858     RUN(testSExt16(0));
17859     RUN(testSExt16(1));
17860     RUN(testSExt16(42));
17861     RUN(testSExt16(-1));
17862     RUN(testSExt16(0xffff));
17863     RUN(testSExt16(0x10000));
17864     RUN(testSExt16Fold(0));
17865     RUN(testSExt16Fold(1));
17866     RUN(testSExt16Fold(42));
17867     RUN(testSExt16Fold(-1));
17868     RUN(testSExt16Fold(0xffff));
17869     RUN(testSExt16Fold(0x10000));
17870     RUN(testSExt16SExt8(0));
17871     RUN(testSExt16SExt8(1));
17872     RUN(testSExt16SExt8(42));
17873     RUN(testSExt16SExt8(-1));
17874     RUN(testSExt16SExt8(0xffff));
17875     RUN(testSExt16SExt8(0x10000));
17876     RUN(testSExt16SExt16(0));
17877     RUN(testSExt16SExt16(1));
17878     RUN(testSExt16SExt16(42));
17879     RUN(testSExt16SExt16(-1));
17880     RUN(testSExt16SExt16(0xffff));
17881     RUN(testSExt16SExt16(0x10000));
17882     RUN(testSExt16SExt16(0xffffff));
17883     RUN(testSExt16SExt16(0x1000000));
17884     RUN(testSExt16BitAnd(0, 0));
17885     RUN(testSExt16BitAnd(1, 0));
17886     RUN(testSExt16BitAnd(42, 0));
17887     RUN(testSExt16BitAnd(-1, 0));
17888     RUN(testSExt16BitAnd(0xffff, 0));
17889     RUN(testSExt16BitAnd(0x10000, 0));
17890     RUN(testSExt16BitAnd(0xffffff, 0));
17891     RUN(testSExt16BitAnd(0x1000000, 0));
17892     RUN(testSExt16BitAnd(0, 0xf));
17893     RUN(testSExt16BitAnd(1, 0xf));
17894     RUN(testSExt16BitAnd(42, 0xf));
17895     RUN(testSExt16BitAnd(-1, 0xf));
17896     RUN(testSExt16BitAnd(0xffff, 0xf));
17897     RUN(testSExt16BitAnd(0x10000, 0xf));
17898     RUN(testSExt16BitAnd(0xffffff, 0xf));
17899     RUN(testSExt16BitAnd(0x1000000, 0xf));
17900     RUN(testSExt16BitAnd(0, 0xffff));
17901     RUN(testSExt16BitAnd(1, 0xffff));
17902     RUN(testSExt16BitAnd(42, 0xffff));
17903     RUN(testSExt16BitAnd(-1, 0xffff));
17904     RUN(testSExt16BitAnd(0xffff, 0xffff));
17905     RUN(testSExt16BitAnd(0x10000, 0xffff));
17906     RUN(testSExt16BitAnd(0xffffff, 0xffff));
17907     RUN(testSExt16BitAnd(0x1000000, 0xffff));
17908     RUN(testSExt16BitAnd(0, 0x8000));
17909     RUN(testSExt16BitAnd(1, 0x8000));
17910     RUN(testSExt16BitAnd(42, 0x8000));
17911     RUN(testSExt16BitAnd(-1, 0x8000));
17912     RUN(testSExt16BitAnd(0xffff, 0x8000));
17913     RUN(testSExt16BitAnd(0x10000, 0x8000));
17914     RUN(testSExt16BitAnd(0xffffff, 0x8000));
17915     RUN(testSExt16BitAnd(0x1000000, 0x8000));
17916     RUN(testBitAndSExt16(0, 0xf));
17917     RUN(testBitAndSExt16(1, 0xf));
17918     RUN(testBitAndSExt16(42, 0xf));
17919     RUN(testBitAndSExt16(-1, 0xf));
17920     RUN(testBitAndSExt16(0xffff, 0xf));
17921     RUN(testBitAndSExt16(0x10000, 0xf));
17922     RUN(testBitAndSExt16(0xffffff, 0xf));
17923     RUN(testBitAndSExt16(0x1000000, 0xf));
17924     RUN(testBitAndSExt16(0, 0xffff));
17925     RUN(testBitAndSExt16(1, 0xffff));
17926     RUN(testBitAndSExt16(42, 0xffff));
17927     RUN(testBitAndSExt16(-1, 0xffff));
17928     RUN(testBitAndSExt16(0xffff, 0xffff));
17929     RUN(testBitAndSExt16(0x10000, 0xffff));
17930     RUN(testBitAndSExt16(0xffffff, 0xffff));
17931     RUN(testBitAndSExt16(0x1000000, 0xffff));
17932     RUN(testBitAndSExt16(0, 0xfffff));
17933     RUN(testBitAndSExt16(1, 0xfffff));
17934     RUN(testBitAndSExt16(42, 0xfffff));
17935     RUN(testBitAndSExt16(-1, 0xfffff));
17936     RUN(testBitAndSExt16(0xffff, 0xfffff));
17937     RUN(testBitAndSExt16(0x10000, 0xfffff));
17938     RUN(testBitAndSExt16(0xffffff, 0xfffff));
17939     RUN(testBitAndSExt16(0x1000000, 0xfffff));
17940 
17941     RUN(testSExt32BitAnd(0, 0));
17942     RUN(testSExt32BitAnd(1, 0));
17943     RUN(testSExt32BitAnd(42, 0));
17944     RUN(testSExt32BitAnd(-1, 0));
17945     RUN(testSExt32BitAnd(0x80000000, 0));
17946     RUN(testSExt32BitAnd(0, 0xf));
17947     RUN(testSExt32BitAnd(1, 0xf));
17948     RUN(testSExt32BitAnd(42, 0xf));
17949     RUN(testSExt32BitAnd(-1, 0xf));
17950     RUN(testSExt32BitAnd(0x80000000, 0xf));
17951     RUN(testSExt32BitAnd(0, 0x80000000));
17952     RUN(testSExt32BitAnd(1, 0x80000000));
17953     RUN(testSExt32BitAnd(42, 0x80000000));
17954     RUN(testSExt32BitAnd(-1, 0x80000000));
17955     RUN(testSExt32BitAnd(0x80000000, 0x80000000));
17956     RUN(testBitAndSExt32(0, 0xf));
17957     RUN(testBitAndSExt32(1, 0xf));
17958     RUN(testBitAndSExt32(42, 0xf));
17959     RUN(testBitAndSExt32(-1, 0xf));
17960     RUN(testBitAndSExt32(0xffff, 0xf));
17961     RUN(testBitAndSExt32(0x10000, 0xf));
17962     RUN(testBitAndSExt32(0xffffff, 0xf));
17963     RUN(testBitAndSExt32(0x1000000, 0xf));
17964     RUN(testBitAndSExt32(0, 0xffff00000000llu));
17965     RUN(testBitAndSExt32(1, 0xffff00000000llu));
17966     RUN(testBitAndSExt32(42, 0xffff00000000llu));
17967     RUN(testBitAndSExt32(-1, 0xffff00000000llu));
17968     RUN(testBitAndSExt32(0x80000000, 0xffff00000000llu));
17969 
17970     RUN(testBasicSelect());
17971     RUN(testSelectTest());
17972     RUN(testSelectCompareDouble());
17973     RUN_BINARY(testSelectCompareFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17974     RUN_BINARY(testSelectCompareFloatToDouble, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17975     RUN(testSelectDouble());
17976     RUN(testSelectDoubleTest());
17977     RUN(testSelectDoubleCompareDouble());
17978     RUN_BINARY(testSelectDoubleCompareFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17979     RUN_BINARY(testSelectFloatCompareFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
17980     RUN(testSelectDoubleCompareDoubleWithAliasing());
17981     RUN(testSelectFloatCompareFloatWithAliasing());
17982     RUN(testSelectFold(42));
17983     RUN(testSelectFold(43));
17984     RUN(testSelectInvert());
17985     RUN(testCheckSelect());
17986     RUN(testCheckSelectCheckSelect());
17987     RUN(testCheckSelectAndCSE());
17988     RUN_BINARY(testPowDoubleByIntegerLoop, floatingPointOperands&lt;double&gt;(), int64Operands());
17989 
17990     RUN(testTruncOrHigh());
17991     RUN(testTruncOrLow());
17992     RUN(testBitAndOrHigh());
17993     RUN(testBitAndOrLow());
17994 
17995     RUN(testBranch64Equal(0, 0));
17996     RUN(testBranch64Equal(1, 1));
17997     RUN(testBranch64Equal(-1, -1));
17998     RUN(testBranch64Equal(1, -1));
17999     RUN(testBranch64Equal(-1, 1));
18000     RUN(testBranch64EqualImm(0, 0));
18001     RUN(testBranch64EqualImm(1, 1));
18002     RUN(testBranch64EqualImm(-1, -1));
18003     RUN(testBranch64EqualImm(1, -1));
18004     RUN(testBranch64EqualImm(-1, 1));
18005     RUN(testBranch64EqualMem(0, 0));
18006     RUN(testBranch64EqualMem(1, 1));
18007     RUN(testBranch64EqualMem(-1, -1));
18008     RUN(testBranch64EqualMem(1, -1));
18009     RUN(testBranch64EqualMem(-1, 1));
18010     RUN(testBranch64EqualMemImm(0, 0));
18011     RUN(testBranch64EqualMemImm(1, 1));
18012     RUN(testBranch64EqualMemImm(-1, -1));
18013     RUN(testBranch64EqualMemImm(1, -1));
18014     RUN(testBranch64EqualMemImm(-1, 1));
18015 
18016     RUN(testStore8Load8Z(0));
18017     RUN(testStore8Load8Z(123));
18018     RUN(testStore8Load8Z(12345));
18019     RUN(testStore8Load8Z(-123));
18020 
18021     RUN(testStore16Load16Z(0));
18022     RUN(testStore16Load16Z(123));
18023     RUN(testStore16Load16Z(12345));
18024     RUN(testStore16Load16Z(12345678));
18025     RUN(testStore16Load16Z(-123));
18026 
18027     RUN(testSShrShl32(42, 24, 24));
18028     RUN(testSShrShl32(-42, 24, 24));
18029     RUN(testSShrShl32(4200, 24, 24));
18030     RUN(testSShrShl32(-4200, 24, 24));
18031     RUN(testSShrShl32(4200000, 24, 24));
18032     RUN(testSShrShl32(-4200000, 24, 24));
18033 
18034     RUN(testSShrShl32(42, 16, 16));
18035     RUN(testSShrShl32(-42, 16, 16));
18036     RUN(testSShrShl32(4200, 16, 16));
18037     RUN(testSShrShl32(-4200, 16, 16));
18038     RUN(testSShrShl32(4200000, 16, 16));
18039     RUN(testSShrShl32(-4200000, 16, 16));
18040 
18041     RUN(testSShrShl32(42, 8, 8));
18042     RUN(testSShrShl32(-42, 8, 8));
18043     RUN(testSShrShl32(4200, 8, 8));
18044     RUN(testSShrShl32(-4200, 8, 8));
18045     RUN(testSShrShl32(4200000, 8, 8));
18046     RUN(testSShrShl32(-4200000, 8, 8));
18047     RUN(testSShrShl32(420000000, 8, 8));
18048     RUN(testSShrShl32(-420000000, 8, 8));
18049 
18050     RUN(testSShrShl64(42, 56, 56));
18051     RUN(testSShrShl64(-42, 56, 56));
18052     RUN(testSShrShl64(4200, 56, 56));
18053     RUN(testSShrShl64(-4200, 56, 56));
18054     RUN(testSShrShl64(4200000, 56, 56));
18055     RUN(testSShrShl64(-4200000, 56, 56));
18056     RUN(testSShrShl64(420000000, 56, 56));
18057     RUN(testSShrShl64(-420000000, 56, 56));
18058     RUN(testSShrShl64(42000000000, 56, 56));
18059     RUN(testSShrShl64(-42000000000, 56, 56));
18060 
18061     RUN(testSShrShl64(42, 48, 48));
18062     RUN(testSShrShl64(-42, 48, 48));
18063     RUN(testSShrShl64(4200, 48, 48));
18064     RUN(testSShrShl64(-4200, 48, 48));
18065     RUN(testSShrShl64(4200000, 48, 48));
18066     RUN(testSShrShl64(-4200000, 48, 48));
18067     RUN(testSShrShl64(420000000, 48, 48));
18068     RUN(testSShrShl64(-420000000, 48, 48));
18069     RUN(testSShrShl64(42000000000, 48, 48));
18070     RUN(testSShrShl64(-42000000000, 48, 48));
18071 
18072     RUN(testSShrShl64(42, 32, 32));
18073     RUN(testSShrShl64(-42, 32, 32));
18074     RUN(testSShrShl64(4200, 32, 32));
18075     RUN(testSShrShl64(-4200, 32, 32));
18076     RUN(testSShrShl64(4200000, 32, 32));
18077     RUN(testSShrShl64(-4200000, 32, 32));
18078     RUN(testSShrShl64(420000000, 32, 32));
18079     RUN(testSShrShl64(-420000000, 32, 32));
18080     RUN(testSShrShl64(42000000000, 32, 32));
18081     RUN(testSShrShl64(-42000000000, 32, 32));
18082 
18083     RUN(testSShrShl64(42, 24, 24));
18084     RUN(testSShrShl64(-42, 24, 24));
18085     RUN(testSShrShl64(4200, 24, 24));
18086     RUN(testSShrShl64(-4200, 24, 24));
18087     RUN(testSShrShl64(4200000, 24, 24));
18088     RUN(testSShrShl64(-4200000, 24, 24));
18089     RUN(testSShrShl64(420000000, 24, 24));
18090     RUN(testSShrShl64(-420000000, 24, 24));
18091     RUN(testSShrShl64(42000000000, 24, 24));
18092     RUN(testSShrShl64(-42000000000, 24, 24));
18093 
18094     RUN(testSShrShl64(42, 16, 16));
18095     RUN(testSShrShl64(-42, 16, 16));
18096     RUN(testSShrShl64(4200, 16, 16));
18097     RUN(testSShrShl64(-4200, 16, 16));
18098     RUN(testSShrShl64(4200000, 16, 16));
18099     RUN(testSShrShl64(-4200000, 16, 16));
18100     RUN(testSShrShl64(420000000, 16, 16));
18101     RUN(testSShrShl64(-420000000, 16, 16));
18102     RUN(testSShrShl64(42000000000, 16, 16));
18103     RUN(testSShrShl64(-42000000000, 16, 16));
18104 
18105     RUN(testSShrShl64(42, 8, 8));
18106     RUN(testSShrShl64(-42, 8, 8));
18107     RUN(testSShrShl64(4200, 8, 8));
18108     RUN(testSShrShl64(-4200, 8, 8));
18109     RUN(testSShrShl64(4200000, 8, 8));
18110     RUN(testSShrShl64(-4200000, 8, 8));
18111     RUN(testSShrShl64(420000000, 8, 8));
18112     RUN(testSShrShl64(-420000000, 8, 8));
18113     RUN(testSShrShl64(42000000000, 8, 8));
18114     RUN(testSShrShl64(-42000000000, 8, 8));
18115 
18116     RUN(testCheckMul64SShr());
18117 
18118     RUN_BINARY(testRotR, int32Operands(), int32Operands());
18119     RUN_BINARY(testRotR, int64Operands(), int32Operands());
18120     RUN_BINARY(testRotL, int32Operands(), int32Operands());
18121     RUN_BINARY(testRotL, int64Operands(), int32Operands());
18122 
18123     RUN_BINARY(testRotRWithImmShift, int32Operands(), int32Operands());
18124     RUN_BINARY(testRotRWithImmShift, int64Operands(), int32Operands());
18125     RUN_BINARY(testRotLWithImmShift, int32Operands(), int32Operands());
18126     RUN_BINARY(testRotLWithImmShift, int64Operands(), int32Operands());
18127 
18128     RUN(testComputeDivisionMagic&lt;int32_t&gt;(2, -2147483647, 0));
18129     RUN(testTrivialInfiniteLoop());
18130     RUN(testFoldPathEqual());
18131 
18132     RUN(testRShiftSelf32());
18133     RUN(testURShiftSelf32());
18134     RUN(testLShiftSelf32());
18135     RUN(testRShiftSelf64());
18136     RUN(testURShiftSelf64());
18137     RUN(testLShiftSelf64());
18138 
18139     RUN(testPatchpointDoubleRegs());
18140     RUN(testSpillDefSmallerThanUse());
18141     RUN(testSpillUseLargerThanDef());
18142     RUN(testLateRegister());
18143     RUN(testInterpreter());
18144     RUN(testReduceStrengthCheckBottomUseInAnotherBlock());
18145     RUN(testResetReachabilityDanglingReference());
18146 
18147     RUN(testEntrySwitchSimple());
18148     RUN(testEntrySwitchNoEntrySwitch());
18149     RUN(testEntrySwitchWithCommonPaths());
18150     RUN(testEntrySwitchWithCommonPathsAndNonTrivialEntrypoint());
18151     RUN(testEntrySwitchLoop());
18152 
18153     RUN(testSomeEarlyRegister());
18154     RUN(testPatchpointTerminalReturnValue(true));
18155     RUN(testPatchpointTerminalReturnValue(false));
18156     RUN(testTerminalPatchpointThatNeedsToBeSpilled());
18157 
18158     RUN(testMemoryFence());
18159     RUN(testStoreFence());
18160     RUN(testLoadFence());
18161     RUN(testTrappingLoad());
18162     RUN(testTrappingStore());
18163     RUN(testTrappingLoadAddStore());
18164     RUN(testTrappingLoadDCE());
18165     RUN(testTrappingStoreElimination());
18166     RUN(testMoveConstants());
18167     RUN(testPCOriginMapDoesntInsertNops());
18168     RUN(testPinRegisters());
18169     RUN(testReduceStrengthReassociation(true));
18170     RUN(testReduceStrengthReassociation(false));
18171     RUN(testAddShl32());
18172     RUN(testAddShl64());
18173     RUN(testAddShl65());
18174     RUN(testLoadBaseIndexShift2());
18175     RUN(testLoadBaseIndexShift32());
18176     RUN(testOptimizeMaterialization());
18177     RUN(testLICMPure());
18178     RUN(testLICMPureSideExits());
18179     RUN(testLICMPureWritesPinned());
18180     RUN(testLICMPureWrites());
18181     RUN(testLICMReadsLocalState());
18182     RUN(testLICMReadsPinned());
18183     RUN(testLICMReads());
18184     RUN(testLICMPureNotBackwardsDominant());
18185     RUN(testLICMPureFoiledByChild());
18186     RUN(testLICMPureNotBackwardsDominantFoiledByChild());
18187     RUN(testLICMExitsSideways());
18188     RUN(testLICMWritesLocalState());
18189     RUN(testLICMWrites());
18190     RUN(testLICMWritesPinned());
18191     RUN(testLICMFence());
18192     RUN(testLICMControlDependent());
18193     RUN(testLICMControlDependentNotBackwardsDominant());
18194     RUN(testLICMControlDependentSideExits());
18195     RUN(testLICMReadsPinnedWritesPinned());
18196     RUN(testLICMReadsWritesDifferentHeaps());
18197     RUN(testLICMReadsWritesOverlappingHeaps());
18198     RUN(testLICMDefaultCall());
18199 
18200     RUN(testAtomicWeakCAS&lt;int8_t&gt;());
18201     RUN(testAtomicWeakCAS&lt;int16_t&gt;());
18202     RUN(testAtomicWeakCAS&lt;int32_t&gt;());
18203     RUN(testAtomicWeakCAS&lt;int64_t&gt;());
18204     RUN(testAtomicStrongCAS&lt;int8_t&gt;());
18205     RUN(testAtomicStrongCAS&lt;int16_t&gt;());
18206     RUN(testAtomicStrongCAS&lt;int32_t&gt;());
18207     RUN(testAtomicStrongCAS&lt;int64_t&gt;());
18208     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAdd));
18209     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAdd));
18210     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAdd));
18211     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAdd));
18212     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAnd));
18213     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAnd));
18214     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAnd));
18215     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAnd));
18216     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgOr));
18217     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgOr));
18218     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgOr));
18219     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgOr));
18220     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgSub));
18221     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgSub));
18222     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgSub));
18223     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgSub));
18224     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgXor));
18225     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgXor));
18226     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgXor));
18227     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgXor));
18228     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchg));
18229     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchg));
18230     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchg));
18231     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchg));
18232     RUN(testDepend32());
18233     RUN(testDepend64());
18234 
18235     RUN(testWasmBoundsCheck(0));
18236     RUN(testWasmBoundsCheck(100));
18237     RUN(testWasmBoundsCheck(10000));
18238     RUN(testWasmBoundsCheck(std::numeric_limits&lt;unsigned&gt;::max() - 5));
18239 
18240     RUN(testWasmAddress());
18241 
18242     RUN(testFastTLSLoad());
18243     RUN(testFastTLSStore());
18244 
18245     RUN(testDoubleLiteralComparison(bitwise_cast&lt;double&gt;(0x8000000000000001ull), bitwise_cast&lt;double&gt;(0x0000000000000000ull)));
18246     RUN(testDoubleLiteralComparison(bitwise_cast&lt;double&gt;(0x0000000000000000ull), bitwise_cast&lt;double&gt;(0x8000000000000001ull)));
18247     RUN(testDoubleLiteralComparison(125.3144446948241, 125.3144446948242));
18248     RUN(testDoubleLiteralComparison(125.3144446948242, 125.3144446948241));
18249 
18250     RUN(testFloatEqualOrUnorderedFolding());
18251     RUN(testFloatEqualOrUnorderedFoldingNaN());
18252     RUN(testFloatEqualOrUnorderedDontFold());
18253 
18254     RUN(testShuffleDoesntTrashCalleeSaves());
18255     RUN(testDemotePatchpointTerminal());
18256 
18257     RUN(testLoopWithMultipleHeaderEdges());
18258 
18259     RUN(testInfiniteLoopDoesntCauseBadHoisting());
18260 
18261     if (isX86()) {
18262         RUN(testBranchBitAndImmFusion(Identity, Int64, 1, Air::BranchTest32, Air::Arg::Tmp));
18263         RUN(testBranchBitAndImmFusion(Identity, Int64, 0xff, Air::BranchTest32, Air::Arg::Tmp));
18264         RUN(testBranchBitAndImmFusion(Trunc, Int32, 1, Air::BranchTest32, Air::Arg::Tmp));
18265         RUN(testBranchBitAndImmFusion(Trunc, Int32, 0xff, Air::BranchTest32, Air::Arg::Tmp));
18266         RUN(testBranchBitAndImmFusion(Load8S, Int32, 1, Air::BranchTest8, Air::Arg::Addr));
18267         RUN(testBranchBitAndImmFusion(Load8Z, Int32, 1, Air::BranchTest8, Air::Arg::Addr));
18268         RUN(testBranchBitAndImmFusion(Load, Int32, 1, Air::BranchTest32, Air::Arg::Addr));
18269         RUN(testBranchBitAndImmFusion(Load, Int64, 1, Air::BranchTest32, Air::Arg::Addr));
18270         RUN(testX86LeaAddAddShlLeft());
18271         RUN(testX86LeaAddAddShlRight());
18272         RUN(testX86LeaAddAdd());
18273         RUN(testX86LeaAddShlRight());
18274         RUN(testX86LeaAddShlLeftScale1());
18275         RUN(testX86LeaAddShlLeftScale2());
18276         RUN(testX86LeaAddShlLeftScale4());
18277         RUN(testX86LeaAddShlLeftScale8());
18278     }
18279 
18280     if (isARM64()) {
18281         RUN(testTernarySubInstructionSelection(Identity, Int64, Air::Sub64));
18282         RUN(testTernarySubInstructionSelection(Trunc, Int32, Air::Sub32));
18283     }
18284 
18285     RUN(testReportUsedRegistersLateUseFollowedByEarlyDefDoesNotMarkUseAsDead());
18286 
18287     if (tasks.isEmpty())
18288         usage();
18289 
18290     Lock lock;
18291 
18292     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
18293     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
18294         threads.append(
18295             Thread::create(
18296                 &quot;testb3 thread&quot;,
18297                 [&amp;] () {
18298                     for (;;) {
18299                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
18300                         {
18301                             LockHolder locker(lock);
18302                             if (tasks.isEmpty())
18303                                 return;
18304                             task = tasks.takeFirst();
18305                         }
18306 
18307                         task-&gt;run();
18308                     }
18309                 }));
18310     }
18311 
18312     for (auto&amp; thread : threads)
18313         thread-&gt;waitForCompletion();
18314     crashLock.lock();
18315 }
18316 
18317 } // anonymous namespace
18318 
18319 #else // ENABLE(B3_JIT)
18320 
18321 static void run(const char*)
18322 {
18323     dataLog(&quot;B3 JIT is not enabled.\n&quot;);
18324 }
18325 
18326 #endif // ENABLE(B3_JIT)
18327 
18328 int main(int argc, char** argv)
18329 {
18330     const char* filter = nullptr;
18331     switch (argc) {
18332     case 1:
18333         break;
18334     case 2:
18335         filter = argv[1];
18336         break;
18337     default:
18338         usage();
18339         break;
18340     }
18341 
18342     run(filter);
18343     return 0;
18344 }
18345 
    </pre>
  </body>
</html>