<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserToken.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 
  33 #include &quot;CSSAspectRatioValue.h&quot;
  34 #include &quot;CSSBasicShapes.h&quot;
  35 #include &quot;CSSBorderImage.h&quot;
  36 #include &quot;CSSBorderImageSliceValue.h&quot;
  37 #include &quot;CSSContentDistributionValue.h&quot;
  38 #include &quot;CSSCursorImageValue.h&quot;
  39 #include &quot;CSSCustomIdentValue.h&quot;
  40 #include &quot;CSSCustomPropertyValue.h&quot;
  41 #include &quot;CSSFontFaceSrcValue.h&quot;
  42 #include &quot;CSSFontFeatureValue.h&quot;
  43 #if ENABLE(VARIATION_FONTS)
  44 #include &quot;CSSFontVariationValue.h&quot;
  45 #endif
  46 #include &quot;CSSFontStyleRangeValue.h&quot;
  47 #include &quot;CSSFontStyleValue.h&quot;
  48 #include &quot;CSSFunctionValue.h&quot;
  49 #include &quot;CSSGridAutoRepeatValue.h&quot;

  50 #include &quot;CSSGridLineNamesValue.h&quot;
  51 #include &quot;CSSGridTemplateAreasValue.h&quot;
  52 #include &quot;CSSLineBoxContainValue.h&quot;
  53 #include &quot;CSSParserFastPaths.h&quot;
  54 #include &quot;CSSParserIdioms.h&quot;
  55 #include &quot;CSSPendingSubstitutionValue.h&quot;
  56 #include &quot;CSSPrimitiveValueMappings.h&quot;
  57 #include &quot;CSSPropertyParserHelpers.h&quot;
  58 #include &quot;CSSReflectValue.h&quot;
  59 #include &quot;CSSShadowValue.h&quot;
  60 #include &quot;CSSTimingFunctionValue.h&quot;
  61 #include &quot;CSSUnicodeRangeValue.h&quot;
  62 #include &quot;CSSVariableParser.h&quot;
  63 #include &quot;CSSVariableReferenceValue.h&quot;
  64 #include &quot;Counter.h&quot;
<span class="line-removed">  65 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">  66 #include &quot;DashboardRegion.h&quot;</span>
<span class="line-removed">  67 #endif</span>
  68 #include &quot;FontFace.h&quot;
  69 #include &quot;HashTools.h&quot;
  70 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  71 #include &quot;Pair.h&quot;
  72 #include &quot;Rect.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RuntimeEnabledFeatures.h&quot;
  75 #include &quot;SVGPathByteStream.h&quot;
  76 #include &quot;SVGPathUtilities.h&quot;
  77 #include &quot;StyleBuilderConverter.h&quot;
  78 #include &quot;StylePropertyShorthand.h&quot;
  79 #include &quot;StylePropertyShorthandFunctions.h&quot;
  80 #include &quot;StyleResolver.h&quot;
  81 #include &lt;bitset&gt;
  82 #include &lt;memory&gt;
  83 #include &lt;wtf/text/StringBuilder.h&gt;
  84 
  85 namespace WebCore {
  86 
  87 bool isCustomPropertyName(const String&amp; propertyName)
</pre>
<hr />
<pre>
 139 #endif
 140 #if PLATFORM(IOS_FAMILY)
 141         cssPropertyNameIOSAliasing(buffer, name, length);
 142 #endif
 143     }
 144 
 145     const Property* hashTableEntry = findProperty(name, length);
 146     if (hashTableEntry) {
 147         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 148         if (isEnabledCSSProperty(propertyID))
 149             return propertyID;
 150     }
 151     return CSSPropertyInvalid;
 152 }
 153 
 154 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 155 {
 156     static const char applePrefix[] = &quot;-apple-&quot;;
 157     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 158     static const char applePayPrefix[] = &quot;-apple-pay&quot;;


 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);

 160 
 161     return hasPrefix(valueKeyword, length, applePrefix)
 162     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified"> 164     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length);</span>



 165 }
 166 
 167 template &lt;typename CharacterType&gt;
 168 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 169 {
 170     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 171 
 172     for (unsigned i = 0; i != length; ++i) {
 173         CharacterType c = valueKeyword[i];
 174         if (!c || c &gt;= 0x7F)
 175             return CSSValueInvalid; // illegal keyword.
 176         buffer[i] = WTF::toASCIILower(c);
 177     }
 178     buffer[length] = &#39;\0&#39;;
 179 
 180     if (buffer[0] == &#39;-&#39;) {
 181         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 182         // This makes the string one character longer.
 183         // On iOS we don&#39;t want to change values starting with -apple-system to -webkit-system.
 184         // FIXME: Remove this mangling without breaking the web.
</pre>
<hr />
<pre>
 291 {
 292     CSSPropertyParser parser(tokens, context, nullptr);
 293     return parser.canParseTypedCustomPropertyValue(syntax);
 294 }
 295 
 296 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)
 297 {
 298     CSSPropertyParser parser(tokens, context, nullptr, false);
 299     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);
 300     if (!value || !parser.m_range.atEnd())
 301         return nullptr;
 302     return value;
 303 }
 304 
 305 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 306 {
 307     CSSPropertyParser parser(tokens, context, nullptr);
 308     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 309 }
 310 
<span class="line-removed"> 311 static bool isLegacyBreakProperty(CSSPropertyID propertyID)</span>
<span class="line-removed"> 312 {</span>
<span class="line-removed"> 313     switch (propertyID) {</span>
<span class="line-removed"> 314     case CSSPropertyPageBreakAfter:</span>
<span class="line-removed"> 315     case CSSPropertyPageBreakBefore:</span>
<span class="line-removed"> 316     case CSSPropertyPageBreakInside:</span>
<span class="line-removed"> 317     case CSSPropertyWebkitColumnBreakAfter:</span>
<span class="line-removed"> 318     case CSSPropertyWebkitColumnBreakBefore:</span>
<span class="line-removed"> 319     case CSSPropertyWebkitColumnBreakInside:</span>
<span class="line-removed"> 320         return true;</span>
<span class="line-removed"> 321     default:</span>
<span class="line-removed"> 322         break;</span>
<span class="line-removed"> 323     }</span>
<span class="line-removed"> 324     return false;</span>
<span class="line-removed"> 325 }</span>
<span class="line-removed"> 326 </span>
 327 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 328 {
 329     if (consumeCSSWideKeyword(propertyID, important))
 330         return true;
 331 
 332     CSSParserTokenRange originalRange = m_range;
 333     bool isShorthand = isShorthandCSSProperty(propertyID);
 334 
 335     if (isShorthand) {
 336         // Variable references will fail to parse here and will fall out to the variable ref parser below.
 337         if (parseShorthand(propertyID, important))
 338             return true;
<span class="line-removed"> 339     } else if (isLegacyBreakProperty(propertyID)) {</span>
<span class="line-removed"> 340         // FIXME-NEWPARSER: Can turn this into a shorthand once old parser is gone, and then</span>
<span class="line-removed"> 341         // we don&#39;t need the special case.</span>
<span class="line-removed"> 342         if (consumeLegacyBreakProperty(propertyID, important))</span>
<span class="line-removed"> 343             return true;</span>
 344     } else {
 345         RefPtr&lt;CSSValue&gt; parsedValue = parseSingleValue(propertyID);
 346         if (parsedValue &amp;&amp; m_range.atEnd()) {
 347             addProperty(propertyID, CSSPropertyInvalid, *parsedValue, important);
 348             return true;
 349         }
 350     }
 351 
 352     if (CSSVariableParser::containsValidVariableReferences(originalRange, m_context)) {
 353         RefPtr&lt;CSSVariableReferenceValue&gt; variable = CSSVariableReferenceValue::create(originalRange);
 354 
 355         if (isShorthand) {
 356             RefPtr&lt;CSSPendingSubstitutionValue&gt; pendingValue = CSSPendingSubstitutionValue::create(propertyID, variable.releaseNonNull());
 357             addExpandedPropertyForValue(propertyID, pendingValue.releaseNonNull(), important);
 358         } else
 359             addProperty(propertyID, CSSPropertyInvalid, variable.releaseNonNull(), important);
 360         return true;
 361     }
 362 
 363     return false;
</pre>
<hr />
<pre>
 552 
 553     return CSSFontVariationValue::create(tag, tagValue);
 554 }
 555 
 556 static RefPtr&lt;CSSValue&gt; consumeFontVariationSettings(CSSParserTokenRange&amp; range)
 557 {
 558     if (range.peek().id() == CSSValueNormal)
 559         return consumeIdent(range);
 560 
 561     auto settings = CSSValueList::createCommaSeparated();
 562     do {
 563         RefPtr&lt;CSSValue&gt; variationValue = consumeFontVariationTag(range);
 564         if (!variationValue)
 565             return nullptr;
 566         settings-&gt;append(variationValue.releaseNonNull());
 567     } while (consumeCommaIncludingWhitespace(range));
 568 
 569     if (!settings-&gt;length())
 570         return nullptr;
 571 
<span class="line-modified"> 572     return WTFMove(settings);</span>
 573 }
 574 #endif // ENABLE(VARIATION_FONTS)
 575 
 576 static RefPtr&lt;CSSValue&gt; consumePage(CSSParserTokenRange&amp; range)
 577 {
 578     if (range.peek().id() == CSSValueAuto)
 579         return consumeIdent(range);
 580     return consumeCustomIdent(range);
 581 }
 582 
 583 static RefPtr&lt;CSSValue&gt; consumeQuotes(CSSParserTokenRange&amp; range)
 584 {
 585     if (range.peek().id() == CSSValueNone)
 586         return consumeIdent(range);
 587     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 588     while (!range.atEnd()) {
 589         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeString(range);
 590         if (!parsedValue)
 591             return nullptr;
 592         values-&gt;append(parsedValue.releaseNonNull());
</pre>
<hr />
<pre>
1064 }
1065 
1066 static RefPtr&lt;CSSValueList&gt; consumeFontFamily(CSSParserTokenRange&amp; range)
1067 {
1068     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1069     do {
1070         if (auto parsedValue = consumeGenericFamily(range))
1071             list-&gt;append(parsedValue.releaseNonNull());
1072         else {
1073             if (auto parsedValue = consumeFamilyName(range))
1074                 list-&gt;append(parsedValue.releaseNonNull());
1075             else
1076                 return nullptr;
1077         }
1078     } while (consumeCommaIncludingWhitespace(range));
1079     return list;
1080 }
1081 
1082 static RefPtr&lt;CSSValueList&gt; consumeFontFamilyDescriptor(CSSParserTokenRange&amp; range)
1083 {
<span class="line-modified">1084     // FIXME-NEWPARSER: For compatibility with the old parser, we have to make</span>
1085     // a list here, even though the list always contains only a single family name.
1086     // Once the old parser is gone, we can delete this function, make the caller
1087     // use consumeFamilyName instead, and then patch the @font-face code to
1088     // not expect a list with a single name in it.
1089     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1090     RefPtr&lt;CSSValue&gt; parsedValue = consumeFamilyName(range);
1091     if (parsedValue)
1092         list-&gt;append(parsedValue.releaseNonNull());
1093 
1094     if (!range.atEnd() || !list-&gt;length())
1095         return nullptr;
1096 
1097     return list;
1098 }
1099 
1100 static RefPtr&lt;CSSValue&gt; consumeFontSynthesis(CSSParserTokenRange&amp; range)
1101 {
1102     // none | [ weight || style || small-caps ]
1103     CSSValueID id = range.peek().id();
1104     if (id == CSSValueNone)
</pre>
<hr />
<pre>
1118         return nullptr;
1119     return list;
1120 }
1121 
1122 static RefPtr&lt;CSSValue&gt; consumeLetterSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1123 {
1124     if (range.peek().id() == CSSValueNormal)
1125         return consumeIdent(range);
1126 
1127     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1128 }
1129 
1130 static RefPtr&lt;CSSValue&gt; consumeWordSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1131 {
1132     if (range.peek().id() == CSSValueNormal)
1133         return consumeIdent(range);
1134 
1135     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1136 }
1137 
<span class="line-modified">1138 static RefPtr&lt;CSSValue&gt; consumeTabSize(CSSParserTokenRange&amp; range, CSSParserMode)</span>
1139 {
<span class="line-modified">1140     return consumeInteger(range, 0);</span>



1141 }
1142 
1143 #if ENABLE(TEXT_AUTOSIZING)
1144 static RefPtr&lt;CSSValue&gt; consumeTextSizeAdjust(CSSParserTokenRange&amp; range, CSSParserMode /* cssParserMode */)
1145 {
1146     if (range.peek().id() == CSSValueAuto)
1147         return consumeIdent(range);
1148     if (range.peek().id() == CSSValueNone)
1149         return consumeIdent(range);
1150     return consumePercent(range, ValueRangeNonNegative);
1151 }
1152 #endif
1153 
1154 static RefPtr&lt;CSSValue&gt; consumeFontSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1155 {
1156     if (range.peek().id() &gt;= CSSValueXxSmall &amp;&amp; range.peek().id() &lt;= CSSValueLarger)
1157         return consumeIdent(range);
1158     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, unitless);
1159 }
1160 
</pre>
<hr />
<pre>
2194         cursorType = CSSValuePool::singleton().createIdentifierValue(CSSValuePointer);
2195         range.consumeIncludingWhitespace();
2196     } else if ((id &gt;= CSSValueAuto &amp;&amp; id &lt;= CSSValueWebkitZoomOut) || id == CSSValueCopy || id == CSSValueNone) {
2197         cursorType = consumeIdent(range);
2198     } else {
2199         return nullptr;
2200     }
2201 
2202     if (!list)
2203         return cursorType;
2204     list-&gt;append(cursorType.releaseNonNull());
2205     return list;
2206 }
2207 
2208 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2209 {
2210     if (args.peek().type() != IdentToken)
2211         return nullptr;
2212 
2213     CSSParserToken token = args.consumeIncludingWhitespace();
<span class="line-modified">2214     auto attrName = token.value().toAtomicString();</span>
2215     if (context.isHTMLDocument)
2216         attrName = attrName.convertToASCIILowercase();
2217 
2218     if (!args.atEnd())
2219         return nullptr;
2220 
2221     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2222     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2223     // attr() primitive value.
2224     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);
2225 }
2226 
2227 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2228 {
2229     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2230     if (!identifier)
2231         return nullptr;
2232 
2233     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2234     if (!counters)
</pre>
<hr />
<pre>
2432         RefPtr&lt;CSSPrimitiveValue&gt; yLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2433         if (!yLength)
2434             return nullptr;
2435         shape-&gt;appendPoint(xLength.releaseNonNull(), yLength.releaseNonNull());
2436     } while (consumeCommaIncludingWhitespace(args));
2437     return shape;
2438 }
2439 
2440 static RefPtr&lt;CSSBasicShapePath&gt; consumeBasicShapePath(CSSParserTokenRange&amp; args)
2441 {
2442     WindRule windRule = WindRule::NonZero;
2443     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2444         windRule = args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero;
2445         if (!consumeCommaIncludingWhitespace(args))
2446             return nullptr;
2447     }
2448 
2449     if (args.peek().type() != StringToken)
2450         return nullptr;
2451 
<span class="line-modified">2452     auto byteStream = std::make_unique&lt;SVGPathByteStream&gt;();</span>
2453     if (!buildSVGPathByteStreamFromString(args.consumeIncludingWhitespace().value().toString(), *byteStream, UnalteredParsing))
2454         return nullptr;
2455 
2456     auto shape = CSSBasicShapePath::create(WTFMove(byteStream));
2457     shape-&gt;setWindRule(windRule);
2458 
<span class="line-modified">2459     return WTFMove(shape);</span>
2460 }
2461 
2462 static void complete4Sides(RefPtr&lt;CSSPrimitiveValue&gt; side[4])
2463 {
2464     if (side[3])
2465         return;
2466     if (!side[2]) {
2467         if (!side[1])
2468             side[1] = side[0];
2469         side[2] = side[0];
2470     }
2471     side[3] = side[1];
2472 }
2473 
2474 static bool consumeRadii(RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4], RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4], CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool useLegacyParsing)
2475 {
2476     unsigned i = 0;
2477     for (; i &lt; 4 &amp;&amp; !range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken; ++i) {
2478         horizontalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2479         if (!horizontalRadii[i])
</pre>
<hr />
<pre>
3402         RefPtr&lt;CSSValue&gt; trackSize = consumeGridTrackSize(args, cssParserMode);
3403         if (!trackSize)
3404             return false;
3405         if (allTracksAreFixedSized)
3406             allTracksAreFixedSized = isGridTrackFixedSized(*trackSize);
3407         repeatedValues-&gt;append(trackSize.releaseNonNull());
3408         ++numberOfTracks;
3409         lineNames = consumeGridLineNames(args);
3410         if (lineNames)
3411             repeatedValues-&gt;append(lineNames.releaseNonNull());
3412     }
3413     // We should have found at least one &lt;track-size&gt; or else it is not a valid &lt;track-list&gt;.
3414     if (!numberOfTracks)
3415         return false;
3416 
3417     if (isAutoRepeat)
3418         list.append(repeatedValues.releaseNonNull());
3419     else {
3420         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3421         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
<span class="line-modified">3422         for (size_t i = 0; i &lt; repetitions; ++i) {</span>
<span class="line-modified">3423             for (size_t j = 0; j &lt; repeatedValues-&gt;length(); ++j)</span>
<span class="line-modified">3424                 list.append(*repeatedValues-&gt;itemWithoutBoundsCheck(j));</span>
<span class="line-modified">3425         }</span>
3426     }
3427     return true;
3428 }
3429 
3430 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3431 
3432 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3433 {
3434     bool allowGridLineNames = trackListType != GridAuto;
3435     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3436     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
3437     if (lineNames) {
3438         if (!allowGridLineNames)
3439             return nullptr;
3440         values-&gt;append(lineNames.releaseNonNull());
3441     }
3442 
3443     bool allowRepeat = trackListType == GridTemplate;
3444     bool seenAutoRepeat = false;
3445     bool allTracksAreFixedSized = true;
</pre>
<hr />
<pre>
3744             foundLeftOrRight = true;
3745             leftRightValueID = CSSValueRight;
3746             break;
3747         default:
3748             return nullptr;
3749         }
3750 
3751         range.consumeIncludingWhitespace();
3752     }
3753     if (!foundOverOrUnder)
3754         return nullptr;
3755     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3756     list-&gt;append(CSSValuePool::singleton().createIdentifierValue(overUnderValueID));
3757     if (foundLeftOrRight)
3758         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(leftRightValueID));
3759     return list;
3760 }
3761 
3762 #if ENABLE(DARK_MODE_CSS)
3763 
<span class="line-modified">3764 static RefPtr&lt;CSSValue&gt; consumeSupportedColorSchemes(CSSParserTokenRange&amp; range)</span>
3765 {
3766     if (isAuto(range.peek().id()))
3767         return consumeIdent(range);
3768 
3769     Vector&lt;CSSValueID, 3&gt; identifiers;
3770 
3771     while (!range.atEnd()) {
3772         if (range.peek().type() != IdentToken)
3773             return nullptr;
3774 
3775         CSSValueID id = range.peek().id();
3776 
3777         switch (id) {
3778         case CSSValueAuto:
3779             // Auto is only allowed as a single value, and was handled earlier.
3780             // Don&#39;t allow it in the list.
3781             return nullptr;
3782 
3783         case CSSValueOnly:
3784         case CSSValueLight:
</pre>
<hr />
<pre>
3786             if (!identifiers.appendIfNotContains(id))
3787                 return nullptr;
3788             break;
3789 
3790         default:
3791             // Unknown identifiers are allowed and ignored.
3792             break;
3793         }
3794 
3795         range.consumeIncludingWhitespace();
3796     }
3797 
3798     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3799     for (auto id : identifiers)
3800         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(id));
3801     return list;
3802 }
3803 
3804 #endif
3805 
<span class="line-removed">3806 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">3807 </span>
<span class="line-removed">3808 static RefPtr&lt;CSSValue&gt; consumeWebkitDashboardRegion(CSSParserTokenRange&amp; range, CSSParserMode mode)</span>
<span class="line-removed">3809 {</span>
<span class="line-removed">3810     if (range.atEnd())</span>
<span class="line-removed">3811         return nullptr;</span>
<span class="line-removed">3812 </span>
<span class="line-removed">3813     if (range.peek().id() == CSSValueNone)</span>
<span class="line-removed">3814         return consumeIdent(range);</span>
<span class="line-removed">3815 </span>
<span class="line-removed">3816     auto firstRegion = DashboardRegion::create();</span>
<span class="line-removed">3817     DashboardRegion* region = nullptr;</span>
<span class="line-removed">3818 </span>
<span class="line-removed">3819     bool requireCommas = false;</span>
<span class="line-removed">3820 </span>
<span class="line-removed">3821     while (!range.atEnd()) {</span>
<span class="line-removed">3822         if (!region)</span>
<span class="line-removed">3823             region = firstRegion.ptr();</span>
<span class="line-removed">3824         else {</span>
<span class="line-removed">3825             auto nextRegion = DashboardRegion::create();</span>
<span class="line-removed">3826             region-&gt;m_next = nextRegion.copyRef();</span>
<span class="line-removed">3827             region = nextRegion.ptr();</span>
<span class="line-removed">3828         }</span>
<span class="line-removed">3829 </span>
<span class="line-removed">3830         if (range.peek().functionId() != CSSValueDashboardRegion)</span>
<span class="line-removed">3831             return nullptr;</span>
<span class="line-removed">3832 </span>
<span class="line-removed">3833         CSSParserTokenRange rangeCopy = range;</span>
<span class="line-removed">3834         CSSParserTokenRange args = consumeFunction(rangeCopy);</span>
<span class="line-removed">3835         if (rangeCopy.end() == args.end())</span>
<span class="line-removed">3836             return nullptr; // No ) was found. Be strict about this, since tests are.</span>
<span class="line-removed">3837 </span>
<span class="line-removed">3838         // First arg is a label.</span>
<span class="line-removed">3839         if (args.peek().type() != IdentToken)</span>
<span class="line-removed">3840             return nullptr;</span>
<span class="line-removed">3841         region-&gt;m_label = args.consumeIncludingWhitespace().value().toString();</span>
<span class="line-removed">3842 </span>
<span class="line-removed">3843         // Comma is optional, so don&#39;t fail if we can&#39;t consume one.</span>
<span class="line-removed">3844         requireCommas = consumeCommaIncludingWhitespace(args);</span>
<span class="line-removed">3845 </span>
<span class="line-removed">3846         // Second arg is a type.</span>
<span class="line-removed">3847         if (args.peek().type() != IdentToken)</span>
<span class="line-removed">3848             return nullptr;</span>
<span class="line-removed">3849         region-&gt;m_geometryType = args.consumeIncludingWhitespace().value().toString();</span>
<span class="line-removed">3850         if (equalLettersIgnoringASCIICase(region-&gt;m_geometryType, &quot;circle&quot;))</span>
<span class="line-removed">3851             region-&gt;m_isCircle = true;</span>
<span class="line-removed">3852         else if (equalLettersIgnoringASCIICase(region-&gt;m_geometryType, &quot;rectangle&quot;))</span>
<span class="line-removed">3853             region-&gt;m_isRectangle = true;</span>
<span class="line-removed">3854         else</span>
<span class="line-removed">3855             return nullptr;</span>
<span class="line-removed">3856 </span>
<span class="line-removed">3857         if (args.atEnd()) {</span>
<span class="line-removed">3858             // This originally used CSSValueInvalid by accident. It might be more logical to use something else.</span>
<span class="line-removed">3859             RefPtr&lt;CSSPrimitiveValue&gt; amount = CSSValuePool::singleton().createIdentifierValue(CSSValueInvalid);</span>
<span class="line-removed">3860             region-&gt;setTop(amount.copyRef());</span>
<span class="line-removed">3861             region-&gt;setRight(amount.copyRef());</span>
<span class="line-removed">3862             region-&gt;setBottom(amount.copyRef());</span>
<span class="line-removed">3863             region-&gt;setLeft(WTFMove(amount));</span>
<span class="line-removed">3864             range = rangeCopy;</span>
<span class="line-removed">3865             continue;</span>
<span class="line-removed">3866         }</span>
<span class="line-removed">3867 </span>
<span class="line-removed">3868         // Next four arguments must be offset numbers or auto.</span>
<span class="line-removed">3869         for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-removed">3870             if (args.atEnd() || (requireCommas &amp;&amp; !consumeCommaIncludingWhitespace(args)))</span>
<span class="line-removed">3871                 return nullptr;</span>
<span class="line-removed">3872 </span>
<span class="line-removed">3873             if (args.atEnd())</span>
<span class="line-removed">3874                 return nullptr;</span>
<span class="line-removed">3875 </span>
<span class="line-removed">3876             RefPtr&lt;CSSPrimitiveValue&gt; amount;</span>
<span class="line-removed">3877             if (args.peek().id() == CSSValueAuto)</span>
<span class="line-removed">3878                 amount = consumeIdent(args);</span>
<span class="line-removed">3879             else</span>
<span class="line-removed">3880                 amount = consumeLength(args, mode, ValueRangeAll);</span>
<span class="line-removed">3881 </span>
<span class="line-removed">3882             if (!i)</span>
<span class="line-removed">3883                 region-&gt;setTop(WTFMove(amount));</span>
<span class="line-removed">3884             else if (i == 1)</span>
<span class="line-removed">3885                 region-&gt;setRight(WTFMove(amount));</span>
<span class="line-removed">3886             else if (i == 2)</span>
<span class="line-removed">3887                 region-&gt;setBottom(WTFMove(amount));</span>
<span class="line-removed">3888             else</span>
<span class="line-removed">3889                 region-&gt;setLeft(WTFMove(amount));</span>
<span class="line-removed">3890         }</span>
<span class="line-removed">3891 </span>
<span class="line-removed">3892         if (!args.atEnd())</span>
<span class="line-removed">3893             return nullptr;</span>
<span class="line-removed">3894 </span>
<span class="line-removed">3895         range = rangeCopy;</span>
<span class="line-removed">3896     }</span>
<span class="line-removed">3897 </span>
<span class="line-removed">3898     return CSSValuePool::singleton().createValue(RefPtr&lt;DashboardRegion&gt;(WTFMove(firstRegion)));</span>
<span class="line-removed">3899 }</span>
<span class="line-removed">3900 </span>
<span class="line-removed">3901 #endif</span>
<span class="line-removed">3902 </span>
3903 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, CSSPropertyID currentShorthand)
3904 {
3905     if (CSSParserFastPaths::isKeywordPropertyID(property)) {
<span class="line-modified">3906         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(property, m_range.peek().id(), m_context.mode))</span>
3907             return nullptr;

3908         return consumeIdent(m_range);
3909     }
3910     switch (property) {
3911     case CSSPropertyWillChange:
3912         return consumeWillChange(m_range);
3913     case CSSPropertyPage:
3914         return consumePage(m_range);
3915     case CSSPropertyQuotes:
3916         return consumeQuotes(m_range);
3917     case CSSPropertyFontVariantCaps:
3918         return consumeFontVariantCaps(m_range);
3919     case CSSPropertyFontVariantLigatures:
3920         return consumeFontVariantLigatures(m_range);
3921     case CSSPropertyFontVariantNumeric:
3922         return consumeFontVariantNumeric(m_range);
3923     case CSSPropertyFontVariantEastAsian:
3924         return consumeFontVariantEastAsian(m_range);
3925     case CSSPropertyFontFeatureSettings:
3926         return consumeFontFeatureSettings(m_range);
3927     case CSSPropertyFontFamily:
</pre>
<hr />
<pre>
4333         return consumeLineGrid(m_range);
4334     case CSSPropertyWebkitInitialLetter:
4335         return consumeInitialLetter(m_range);
4336     case CSSPropertySpeakAs:
4337         return consumeSpeakAs(m_range);
4338     case CSSPropertyHangingPunctuation:
4339         return consumeHangingPunctuation(m_range);
4340     case CSSPropertyWebkitMarqueeIncrement:
4341         return consumeWebkitMarqueeIncrement(m_range, m_context.mode);
4342     case CSSPropertyWebkitMarqueeRepetition:
4343         return consumeWebkitMarqueeRepetition(m_range);
4344     case CSSPropertyWebkitMarqueeSpeed:
4345         return consumeWebkitMarqueeSpeed(m_range, m_context.mode);
4346     case CSSPropertyAlt:
4347         return consumeAlt(m_range, m_context);
4348     case CSSPropertyWebkitAspectRatio:
4349         return consumeWebkitAspectRatio(m_range);
4350     case CSSPropertyWebkitTextEmphasisPosition:
4351         return consumeTextEmphasisPosition(m_range);
4352 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">4353     case CSSPropertySupportedColorSchemes:</span>
<span class="line-modified">4354         if (!RuntimeEnabledFeatures::sharedFeatures().darkModeCSSEnabled())</span>
<span class="line-removed">4355             return nullptr;</span>
<span class="line-removed">4356         return consumeSupportedColorSchemes(m_range);</span>
<span class="line-removed">4357 #endif</span>
<span class="line-removed">4358 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">4359     case CSSPropertyWebkitDashboardRegion:</span>
<span class="line-removed">4360         return consumeWebkitDashboardRegion(m_range, m_context.mode);</span>
4361 #endif
4362     default:
4363         return nullptr;
4364     }
4365 }
4366 
4367 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax)
4368 {
4369     if (syntax != &quot;*&quot;) {
4370         m_range.consumeWhitespace();
4371 
4372         // First check for keywords
4373         CSSValueID id = m_range.peek().id();
4374         if (id == CSSValueInherit || id == CSSValueInitial || id == CSSValueRevert)
4375             return true;
4376 
4377         auto localRange = m_range;
4378         while (!localRange.atEnd()) {
4379             auto id = localRange.consume().functionId();
4380             if (id == CSSValueVar || id == CSSValueEnv)
</pre>
<hr />
<pre>
5115             return true;
5116         case CSSPropertyBorderImage:
5117             addProperty(CSSPropertyBorderImageSource, CSSPropertyBorderImage, source.releaseNonNull(), important);
5118             addProperty(CSSPropertyBorderImageSlice, CSSPropertyBorderImage, slice.releaseNonNull(), important);
5119             addProperty(CSSPropertyBorderImageWidth, CSSPropertyBorderImage, width.releaseNonNull() , important);
5120             addProperty(CSSPropertyBorderImageOutset, CSSPropertyBorderImage, outset.releaseNonNull(), important);
5121             addProperty(CSSPropertyBorderImageRepeat, CSSPropertyBorderImage, repeat.releaseNonNull(), important);
5122             return true;
5123         default:
5124             ASSERT_NOT_REACHED();
5125             return false;
5126         }
5127     }
5128     return false;
5129 }
5130 
5131 static inline CSSValueID mapFromPageBreakBetween(CSSValueID value)
5132 {
5133     if (value == CSSValueAlways)
5134         return CSSValuePage;
<span class="line-modified">5135     if (value == CSSValueAuto || value == CSSValueLeft || value == CSSValueRight)</span>
5136         return value;
<span class="line-removed">5137     if (value == CSSValueAvoid)</span>
<span class="line-removed">5138         return CSSValueAvoidPage;</span>
5139     return CSSValueInvalid;
5140 }
5141 
5142 static inline CSSValueID mapFromColumnBreakBetween(CSSValueID value)
5143 {
5144     if (value == CSSValueAlways)
5145         return CSSValueColumn;
5146     if (value == CSSValueAuto)
5147         return value;
5148     if (value == CSSValueAvoid)
5149         return CSSValueAvoidColumn;
5150     return CSSValueInvalid;
5151 }
5152 
5153 static inline CSSValueID mapFromColumnRegionOrPageBreakInside(CSSValueID value)
5154 {
5155     if (value == CSSValueAuto || value == CSSValueAvoid)
5156         return value;
5157     return CSSValueInvalid;
5158 }
</pre>
<hr />
<pre>
5508     if (range.atEnd())
5509         return nullptr;
5510     auto list = CSSValueList::createSpaceSeparated();
5511     list-&gt;append(WTFMove(flowDirection));
5512     if (range.peek().id() == CSSValueAutoFlow) {
5513         range.consumeIncludingWhitespace();
5514         RefPtr&lt;CSSValue&gt; denseIdent = consumeIdent&lt;CSSValueDense&gt;(range);
5515         if (denseIdent)
5516             list-&gt;append(denseIdent.releaseNonNull());
5517     } else {
5518         // Dense case
5519         if (range.peek().id() != CSSValueDense)
5520             return nullptr;
5521         range.consumeIncludingWhitespace();
5522         if (range.atEnd() || range.peek().id() != CSSValueAutoFlow)
5523             return nullptr;
5524         range.consumeIncludingWhitespace();
5525         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDense));
5526     }
5527 
<span class="line-modified">5528     return WTFMove(list);</span>
5529 }
5530 
5531 bool CSSPropertyParser::consumeGridShorthand(bool important)
5532 {
5533     ASSERT(shorthandForProperty(CSSPropertyGrid).length() == 6);
5534 
5535     CSSParserTokenRange rangeCopy = m_range;
5536 
5537     // 1- &lt;grid-template&gt;
5538     if (consumeGridTemplateShorthand(CSSPropertyGrid, important)) {
5539         // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5540         // The sub-properties not specified are set to their initial value, as normal for shorthands.
5541         addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5542         addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5543         addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5544         return true;
5545     }
5546 
5547     m_range = rangeCopy;
5548 
</pre>
<hr />
<pre>
5675 
5676     if (m_range.atEnd())
5677         m_range = rangeCopy;
5678     RefPtr&lt;CSSValue&gt; justifySelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
5679     if (!justifySelfValue)
5680         return false;
5681 
5682     if (!m_range.atEnd())
5683         return false;
5684 
5685     addProperty(CSSPropertyAlignSelf, CSSPropertyPlaceSelf, alignSelfValue.releaseNonNull(), important);
5686     addProperty(CSSPropertyJustifySelf, CSSPropertyPlaceSelf, justifySelfValue.releaseNonNull(), important);
5687     return true;
5688 }
5689 
5690 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5691 {
5692     switch (property) {
5693     case CSSPropertyWebkitMarginCollapse: {
5694         CSSValueID id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5695         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context.mode))</span>
5696             return false;
5697         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5698         if (m_range.atEnd()) {
5699             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5700             return true;
5701         }
5702         id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5703         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context.mode))</span>
5704             return false;
5705         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5706         return true;
5707     }
5708     case CSSPropertyOverflow: {
5709         CSSValueID id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5710         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context.mode))</span>
5711             return false;
5712         if (!m_range.atEnd())
5713             return false;
5714         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);
5715         RefPtr&lt;CSSValue&gt; overflowXValue;
5716 
5717         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been
5718         // set using the shorthand, then for now overflow-x will default to auto, but once we implement
5719         // pagination controls, it should default to hidden. If the overflow-y value is anything but
5720         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.
5721         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)
5722             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5723         else
5724             overflowXValue = overflowYValue;
5725         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);
5726         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);
5727         return true;
5728     }
5729     case CSSPropertyFont: {
5730         const CSSParserToken&amp; token = m_range.peek();
</pre>
<hr />
<pre>
5863         return consumeShorthandGreedily(borderRightShorthand(), important);
5864     case CSSPropertyBorderBottom:
5865         return consumeShorthandGreedily(borderBottomShorthand(), important);
5866     case CSSPropertyBorderLeft:
5867         return consumeShorthandGreedily(borderLeftShorthand(), important);
5868     case CSSPropertyBorder: {
5869         RefPtr&lt;CSSValue&gt; width;
5870         RefPtr&lt;CSSValue&gt; style;
5871         RefPtr&lt;CSSValue&gt; color;
5872         if (!consumeBorder(width, style, color))
5873             return false;
5874 
5875         addExpandedPropertyForValue(CSSPropertyBorderWidth, width.releaseNonNull(), important);
5876         addExpandedPropertyForValue(CSSPropertyBorderStyle, style.releaseNonNull(), important);
5877         addExpandedPropertyForValue(CSSPropertyBorderColor, color.releaseNonNull(), important);
5878         addExpandedPropertyForValue(CSSPropertyBorderImage, CSSValuePool::singleton().createImplicitInitialValue(), important);
5879         return true;
5880     }
5881     case CSSPropertyBorderImage:
5882         return consumeBorderImage(property, important);







5883     case CSSPropertyWebkitMaskPosition:
5884     case CSSPropertyBackgroundPosition: {
5885         RefPtr&lt;CSSValue&gt; resultX;
5886         RefPtr&lt;CSSValue&gt; resultY;
5887         if (!consumeBackgroundPosition(m_range, m_context, UnitlessQuirk::Allow, resultX, resultY) || !m_range.atEnd())
5888             return false;
5889         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionX : CSSPropertyWebkitMaskPositionX, property, resultX.releaseNonNull(), important);
5890         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionY : CSSPropertyWebkitMaskPositionY, property, resultY.releaseNonNull(), important);
5891         return true;
5892     }
5893     case CSSPropertyBackgroundRepeat:
5894     case CSSPropertyWebkitMaskRepeat: {
5895         RefPtr&lt;CSSValue&gt; resultX;
5896         RefPtr&lt;CSSValue&gt; resultY;
5897         bool implicit = false;
5898         if (!consumeRepeatStyle(m_range, resultX, resultY, implicit) || !m_range.atEnd())
5899             return false;
5900         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatX : CSSPropertyWebkitMaskRepeatX, property, resultX.releaseNonNull(), important, implicit);
5901         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatY : CSSPropertyWebkitMaskRepeatY, property, resultY.releaseNonNull(), important, implicit);
5902         return true;
</pre>
</td>
<td>
<hr />
<pre>
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 
  33 #include &quot;CSSAspectRatioValue.h&quot;
  34 #include &quot;CSSBasicShapes.h&quot;
  35 #include &quot;CSSBorderImage.h&quot;
  36 #include &quot;CSSBorderImageSliceValue.h&quot;
  37 #include &quot;CSSContentDistributionValue.h&quot;
  38 #include &quot;CSSCursorImageValue.h&quot;
  39 #include &quot;CSSCustomIdentValue.h&quot;
  40 #include &quot;CSSCustomPropertyValue.h&quot;
  41 #include &quot;CSSFontFaceSrcValue.h&quot;
  42 #include &quot;CSSFontFeatureValue.h&quot;
  43 #if ENABLE(VARIATION_FONTS)
  44 #include &quot;CSSFontVariationValue.h&quot;
  45 #endif
  46 #include &quot;CSSFontStyleRangeValue.h&quot;
  47 #include &quot;CSSFontStyleValue.h&quot;
  48 #include &quot;CSSFunctionValue.h&quot;
  49 #include &quot;CSSGridAutoRepeatValue.h&quot;
<span class="line-added">  50 #include &quot;CSSGridIntegerRepeatValue.h&quot;</span>
  51 #include &quot;CSSGridLineNamesValue.h&quot;
  52 #include &quot;CSSGridTemplateAreasValue.h&quot;
  53 #include &quot;CSSLineBoxContainValue.h&quot;
  54 #include &quot;CSSParserFastPaths.h&quot;
  55 #include &quot;CSSParserIdioms.h&quot;
  56 #include &quot;CSSPendingSubstitutionValue.h&quot;
  57 #include &quot;CSSPrimitiveValueMappings.h&quot;
  58 #include &quot;CSSPropertyParserHelpers.h&quot;
  59 #include &quot;CSSReflectValue.h&quot;
  60 #include &quot;CSSShadowValue.h&quot;
  61 #include &quot;CSSTimingFunctionValue.h&quot;
  62 #include &quot;CSSUnicodeRangeValue.h&quot;
  63 #include &quot;CSSVariableParser.h&quot;
  64 #include &quot;CSSVariableReferenceValue.h&quot;
  65 #include &quot;Counter.h&quot;



  66 #include &quot;FontFace.h&quot;
  67 #include &quot;HashTools.h&quot;
  68 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  69 #include &quot;Pair.h&quot;
  70 #include &quot;Rect.h&quot;
  71 #include &quot;RenderTheme.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;SVGPathByteStream.h&quot;
  74 #include &quot;SVGPathUtilities.h&quot;
  75 #include &quot;StyleBuilderConverter.h&quot;
  76 #include &quot;StylePropertyShorthand.h&quot;
  77 #include &quot;StylePropertyShorthandFunctions.h&quot;
  78 #include &quot;StyleResolver.h&quot;
  79 #include &lt;bitset&gt;
  80 #include &lt;memory&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 namespace WebCore {
  84 
  85 bool isCustomPropertyName(const String&amp; propertyName)
</pre>
<hr />
<pre>
 137 #endif
 138 #if PLATFORM(IOS_FAMILY)
 139         cssPropertyNameIOSAliasing(buffer, name, length);
 140 #endif
 141     }
 142 
 143     const Property* hashTableEntry = findProperty(name, length);
 144     if (hashTableEntry) {
 145         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 146         if (isEnabledCSSProperty(propertyID))
 147             return propertyID;
 148     }
 149     return CSSPropertyInvalid;
 150 }
 151 
 152 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 153 {
 154     static const char applePrefix[] = &quot;-apple-&quot;;
 155     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 156     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
<span class="line-added"> 157 </span>
<span class="line-added"> 158 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
<span class="line-added"> 160 #endif</span>
 161 
 162     return hasPrefix(valueKeyword, length, applePrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 164     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified"> 165 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 166     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)</span>
<span class="line-added"> 167 #endif</span>
<span class="line-added"> 168     ;</span>
 169 }
 170 
 171 template &lt;typename CharacterType&gt;
 172 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 173 {
 174     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 175 
 176     for (unsigned i = 0; i != length; ++i) {
 177         CharacterType c = valueKeyword[i];
 178         if (!c || c &gt;= 0x7F)
 179             return CSSValueInvalid; // illegal keyword.
 180         buffer[i] = WTF::toASCIILower(c);
 181     }
 182     buffer[length] = &#39;\0&#39;;
 183 
 184     if (buffer[0] == &#39;-&#39;) {
 185         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 186         // This makes the string one character longer.
 187         // On iOS we don&#39;t want to change values starting with -apple-system to -webkit-system.
 188         // FIXME: Remove this mangling without breaking the web.
</pre>
<hr />
<pre>
 295 {
 296     CSSPropertyParser parser(tokens, context, nullptr);
 297     return parser.canParseTypedCustomPropertyValue(syntax);
 298 }
 299 
 300 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)
 301 {
 302     CSSPropertyParser parser(tokens, context, nullptr, false);
 303     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);
 304     if (!value || !parser.m_range.atEnd())
 305         return nullptr;
 306     return value;
 307 }
 308 
 309 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 310 {
 311     CSSPropertyParser parser(tokens, context, nullptr);
 312     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 313 }
 314 
















 315 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 316 {
 317     if (consumeCSSWideKeyword(propertyID, important))
 318         return true;
 319 
 320     CSSParserTokenRange originalRange = m_range;
 321     bool isShorthand = isShorthandCSSProperty(propertyID);
 322 
 323     if (isShorthand) {
 324         // Variable references will fail to parse here and will fall out to the variable ref parser below.
 325         if (parseShorthand(propertyID, important))
 326             return true;





 327     } else {
 328         RefPtr&lt;CSSValue&gt; parsedValue = parseSingleValue(propertyID);
 329         if (parsedValue &amp;&amp; m_range.atEnd()) {
 330             addProperty(propertyID, CSSPropertyInvalid, *parsedValue, important);
 331             return true;
 332         }
 333     }
 334 
 335     if (CSSVariableParser::containsValidVariableReferences(originalRange, m_context)) {
 336         RefPtr&lt;CSSVariableReferenceValue&gt; variable = CSSVariableReferenceValue::create(originalRange);
 337 
 338         if (isShorthand) {
 339             RefPtr&lt;CSSPendingSubstitutionValue&gt; pendingValue = CSSPendingSubstitutionValue::create(propertyID, variable.releaseNonNull());
 340             addExpandedPropertyForValue(propertyID, pendingValue.releaseNonNull(), important);
 341         } else
 342             addProperty(propertyID, CSSPropertyInvalid, variable.releaseNonNull(), important);
 343         return true;
 344     }
 345 
 346     return false;
</pre>
<hr />
<pre>
 535 
 536     return CSSFontVariationValue::create(tag, tagValue);
 537 }
 538 
 539 static RefPtr&lt;CSSValue&gt; consumeFontVariationSettings(CSSParserTokenRange&amp; range)
 540 {
 541     if (range.peek().id() == CSSValueNormal)
 542         return consumeIdent(range);
 543 
 544     auto settings = CSSValueList::createCommaSeparated();
 545     do {
 546         RefPtr&lt;CSSValue&gt; variationValue = consumeFontVariationTag(range);
 547         if (!variationValue)
 548             return nullptr;
 549         settings-&gt;append(variationValue.releaseNonNull());
 550     } while (consumeCommaIncludingWhitespace(range));
 551 
 552     if (!settings-&gt;length())
 553         return nullptr;
 554 
<span class="line-modified"> 555     return settings;</span>
 556 }
 557 #endif // ENABLE(VARIATION_FONTS)
 558 
 559 static RefPtr&lt;CSSValue&gt; consumePage(CSSParserTokenRange&amp; range)
 560 {
 561     if (range.peek().id() == CSSValueAuto)
 562         return consumeIdent(range);
 563     return consumeCustomIdent(range);
 564 }
 565 
 566 static RefPtr&lt;CSSValue&gt; consumeQuotes(CSSParserTokenRange&amp; range)
 567 {
 568     if (range.peek().id() == CSSValueNone)
 569         return consumeIdent(range);
 570     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 571     while (!range.atEnd()) {
 572         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeString(range);
 573         if (!parsedValue)
 574             return nullptr;
 575         values-&gt;append(parsedValue.releaseNonNull());
</pre>
<hr />
<pre>
1047 }
1048 
1049 static RefPtr&lt;CSSValueList&gt; consumeFontFamily(CSSParserTokenRange&amp; range)
1050 {
1051     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1052     do {
1053         if (auto parsedValue = consumeGenericFamily(range))
1054             list-&gt;append(parsedValue.releaseNonNull());
1055         else {
1056             if (auto parsedValue = consumeFamilyName(range))
1057                 list-&gt;append(parsedValue.releaseNonNull());
1058             else
1059                 return nullptr;
1060         }
1061     } while (consumeCommaIncludingWhitespace(range));
1062     return list;
1063 }
1064 
1065 static RefPtr&lt;CSSValueList&gt; consumeFontFamilyDescriptor(CSSParserTokenRange&amp; range)
1066 {
<span class="line-modified">1067     // FIXME-NEWPARSER: https://bugs.webkit.org/show_bug.cgi?id=196381 For compatibility with the old parser, we have to make</span>
1068     // a list here, even though the list always contains only a single family name.
1069     // Once the old parser is gone, we can delete this function, make the caller
1070     // use consumeFamilyName instead, and then patch the @font-face code to
1071     // not expect a list with a single name in it.
1072     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1073     RefPtr&lt;CSSValue&gt; parsedValue = consumeFamilyName(range);
1074     if (parsedValue)
1075         list-&gt;append(parsedValue.releaseNonNull());
1076 
1077     if (!range.atEnd() || !list-&gt;length())
1078         return nullptr;
1079 
1080     return list;
1081 }
1082 
1083 static RefPtr&lt;CSSValue&gt; consumeFontSynthesis(CSSParserTokenRange&amp; range)
1084 {
1085     // none | [ weight || style || small-caps ]
1086     CSSValueID id = range.peek().id();
1087     if (id == CSSValueNone)
</pre>
<hr />
<pre>
1101         return nullptr;
1102     return list;
1103 }
1104 
1105 static RefPtr&lt;CSSValue&gt; consumeLetterSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1106 {
1107     if (range.peek().id() == CSSValueNormal)
1108         return consumeIdent(range);
1109 
1110     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1111 }
1112 
1113 static RefPtr&lt;CSSValue&gt; consumeWordSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1114 {
1115     if (range.peek().id() == CSSValueNormal)
1116         return consumeIdent(range);
1117 
1118     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1119 }
1120 
<span class="line-modified">1121 static RefPtr&lt;CSSValue&gt; consumeTabSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)</span>
1122 {
<span class="line-modified">1123     auto tabSize = consumeNumber(range, ValueRangeNonNegative);</span>
<span class="line-added">1124     if (tabSize)</span>
<span class="line-added">1125         return tabSize;</span>
<span class="line-added">1126     return consumeLength(range, cssParserMode, ValueRangeNonNegative);</span>
1127 }
1128 
1129 #if ENABLE(TEXT_AUTOSIZING)
1130 static RefPtr&lt;CSSValue&gt; consumeTextSizeAdjust(CSSParserTokenRange&amp; range, CSSParserMode /* cssParserMode */)
1131 {
1132     if (range.peek().id() == CSSValueAuto)
1133         return consumeIdent(range);
1134     if (range.peek().id() == CSSValueNone)
1135         return consumeIdent(range);
1136     return consumePercent(range, ValueRangeNonNegative);
1137 }
1138 #endif
1139 
1140 static RefPtr&lt;CSSValue&gt; consumeFontSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1141 {
1142     if (range.peek().id() &gt;= CSSValueXxSmall &amp;&amp; range.peek().id() &lt;= CSSValueLarger)
1143         return consumeIdent(range);
1144     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, unitless);
1145 }
1146 
</pre>
<hr />
<pre>
2180         cursorType = CSSValuePool::singleton().createIdentifierValue(CSSValuePointer);
2181         range.consumeIncludingWhitespace();
2182     } else if ((id &gt;= CSSValueAuto &amp;&amp; id &lt;= CSSValueWebkitZoomOut) || id == CSSValueCopy || id == CSSValueNone) {
2183         cursorType = consumeIdent(range);
2184     } else {
2185         return nullptr;
2186     }
2187 
2188     if (!list)
2189         return cursorType;
2190     list-&gt;append(cursorType.releaseNonNull());
2191     return list;
2192 }
2193 
2194 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2195 {
2196     if (args.peek().type() != IdentToken)
2197         return nullptr;
2198 
2199     CSSParserToken token = args.consumeIncludingWhitespace();
<span class="line-modified">2200     auto attrName = token.value().toAtomString();</span>
2201     if (context.isHTMLDocument)
2202         attrName = attrName.convertToASCIILowercase();
2203 
2204     if (!args.atEnd())
2205         return nullptr;
2206 
2207     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2208     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2209     // attr() primitive value.
2210     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);
2211 }
2212 
2213 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2214 {
2215     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2216     if (!identifier)
2217         return nullptr;
2218 
2219     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2220     if (!counters)
</pre>
<hr />
<pre>
2418         RefPtr&lt;CSSPrimitiveValue&gt; yLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2419         if (!yLength)
2420             return nullptr;
2421         shape-&gt;appendPoint(xLength.releaseNonNull(), yLength.releaseNonNull());
2422     } while (consumeCommaIncludingWhitespace(args));
2423     return shape;
2424 }
2425 
2426 static RefPtr&lt;CSSBasicShapePath&gt; consumeBasicShapePath(CSSParserTokenRange&amp; args)
2427 {
2428     WindRule windRule = WindRule::NonZero;
2429     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2430         windRule = args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero;
2431         if (!consumeCommaIncludingWhitespace(args))
2432             return nullptr;
2433     }
2434 
2435     if (args.peek().type() != StringToken)
2436         return nullptr;
2437 
<span class="line-modified">2438     auto byteStream = makeUnique&lt;SVGPathByteStream&gt;();</span>
2439     if (!buildSVGPathByteStreamFromString(args.consumeIncludingWhitespace().value().toString(), *byteStream, UnalteredParsing))
2440         return nullptr;
2441 
2442     auto shape = CSSBasicShapePath::create(WTFMove(byteStream));
2443     shape-&gt;setWindRule(windRule);
2444 
<span class="line-modified">2445     return shape;</span>
2446 }
2447 
2448 static void complete4Sides(RefPtr&lt;CSSPrimitiveValue&gt; side[4])
2449 {
2450     if (side[3])
2451         return;
2452     if (!side[2]) {
2453         if (!side[1])
2454             side[1] = side[0];
2455         side[2] = side[0];
2456     }
2457     side[3] = side[1];
2458 }
2459 
2460 static bool consumeRadii(RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4], RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4], CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool useLegacyParsing)
2461 {
2462     unsigned i = 0;
2463     for (; i &lt; 4 &amp;&amp; !range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken; ++i) {
2464         horizontalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2465         if (!horizontalRadii[i])
</pre>
<hr />
<pre>
3388         RefPtr&lt;CSSValue&gt; trackSize = consumeGridTrackSize(args, cssParserMode);
3389         if (!trackSize)
3390             return false;
3391         if (allTracksAreFixedSized)
3392             allTracksAreFixedSized = isGridTrackFixedSized(*trackSize);
3393         repeatedValues-&gt;append(trackSize.releaseNonNull());
3394         ++numberOfTracks;
3395         lineNames = consumeGridLineNames(args);
3396         if (lineNames)
3397             repeatedValues-&gt;append(lineNames.releaseNonNull());
3398     }
3399     // We should have found at least one &lt;track-size&gt; or else it is not a valid &lt;track-list&gt;.
3400     if (!numberOfTracks)
3401         return false;
3402 
3403     if (isAutoRepeat)
3404         list.append(repeatedValues.releaseNonNull());
3405     else {
3406         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3407         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
<span class="line-modified">3408         RefPtr&lt;CSSValueList&gt; integerRepeatedValues = CSSGridIntegerRepeatValue::create(repetitions);</span>
<span class="line-modified">3409         for (size_t i = 0; i &lt; repeatedValues-&gt;length(); ++i)</span>
<span class="line-modified">3410             integerRepeatedValues-&gt;append(*repeatedValues-&gt;itemWithoutBoundsCheck(i));</span>
<span class="line-modified">3411         list.append(integerRepeatedValues.releaseNonNull());</span>
3412     }
3413     return true;
3414 }
3415 
3416 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3417 
3418 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3419 {
3420     bool allowGridLineNames = trackListType != GridAuto;
3421     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3422     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
3423     if (lineNames) {
3424         if (!allowGridLineNames)
3425             return nullptr;
3426         values-&gt;append(lineNames.releaseNonNull());
3427     }
3428 
3429     bool allowRepeat = trackListType == GridTemplate;
3430     bool seenAutoRepeat = false;
3431     bool allTracksAreFixedSized = true;
</pre>
<hr />
<pre>
3730             foundLeftOrRight = true;
3731             leftRightValueID = CSSValueRight;
3732             break;
3733         default:
3734             return nullptr;
3735         }
3736 
3737         range.consumeIncludingWhitespace();
3738     }
3739     if (!foundOverOrUnder)
3740         return nullptr;
3741     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3742     list-&gt;append(CSSValuePool::singleton().createIdentifierValue(overUnderValueID));
3743     if (foundLeftOrRight)
3744         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(leftRightValueID));
3745     return list;
3746 }
3747 
3748 #if ENABLE(DARK_MODE_CSS)
3749 
<span class="line-modified">3750 static RefPtr&lt;CSSValue&gt; consumeColorScheme(CSSParserTokenRange&amp; range)</span>
3751 {
3752     if (isAuto(range.peek().id()))
3753         return consumeIdent(range);
3754 
3755     Vector&lt;CSSValueID, 3&gt; identifiers;
3756 
3757     while (!range.atEnd()) {
3758         if (range.peek().type() != IdentToken)
3759             return nullptr;
3760 
3761         CSSValueID id = range.peek().id();
3762 
3763         switch (id) {
3764         case CSSValueAuto:
3765             // Auto is only allowed as a single value, and was handled earlier.
3766             // Don&#39;t allow it in the list.
3767             return nullptr;
3768 
3769         case CSSValueOnly:
3770         case CSSValueLight:
</pre>
<hr />
<pre>
3772             if (!identifiers.appendIfNotContains(id))
3773                 return nullptr;
3774             break;
3775 
3776         default:
3777             // Unknown identifiers are allowed and ignored.
3778             break;
3779         }
3780 
3781         range.consumeIncludingWhitespace();
3782     }
3783 
3784     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3785     for (auto id : identifiers)
3786         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(id));
3787     return list;
3788 }
3789 
3790 #endif
3791 

































































































3792 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, CSSPropertyID currentShorthand)
3793 {
3794     if (CSSParserFastPaths::isKeywordPropertyID(property)) {
<span class="line-modified">3795         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(property, m_range.peek().id(), m_context))</span>
3796             return nullptr;
<span class="line-added">3797 </span>
3798         return consumeIdent(m_range);
3799     }
3800     switch (property) {
3801     case CSSPropertyWillChange:
3802         return consumeWillChange(m_range);
3803     case CSSPropertyPage:
3804         return consumePage(m_range);
3805     case CSSPropertyQuotes:
3806         return consumeQuotes(m_range);
3807     case CSSPropertyFontVariantCaps:
3808         return consumeFontVariantCaps(m_range);
3809     case CSSPropertyFontVariantLigatures:
3810         return consumeFontVariantLigatures(m_range);
3811     case CSSPropertyFontVariantNumeric:
3812         return consumeFontVariantNumeric(m_range);
3813     case CSSPropertyFontVariantEastAsian:
3814         return consumeFontVariantEastAsian(m_range);
3815     case CSSPropertyFontFeatureSettings:
3816         return consumeFontFeatureSettings(m_range);
3817     case CSSPropertyFontFamily:
</pre>
<hr />
<pre>
4223         return consumeLineGrid(m_range);
4224     case CSSPropertyWebkitInitialLetter:
4225         return consumeInitialLetter(m_range);
4226     case CSSPropertySpeakAs:
4227         return consumeSpeakAs(m_range);
4228     case CSSPropertyHangingPunctuation:
4229         return consumeHangingPunctuation(m_range);
4230     case CSSPropertyWebkitMarqueeIncrement:
4231         return consumeWebkitMarqueeIncrement(m_range, m_context.mode);
4232     case CSSPropertyWebkitMarqueeRepetition:
4233         return consumeWebkitMarqueeRepetition(m_range);
4234     case CSSPropertyWebkitMarqueeSpeed:
4235         return consumeWebkitMarqueeSpeed(m_range, m_context.mode);
4236     case CSSPropertyAlt:
4237         return consumeAlt(m_range, m_context);
4238     case CSSPropertyWebkitAspectRatio:
4239         return consumeWebkitAspectRatio(m_range);
4240     case CSSPropertyWebkitTextEmphasisPosition:
4241         return consumeTextEmphasisPosition(m_range);
4242 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">4243     case CSSPropertyColorScheme:</span>
<span class="line-modified">4244         return consumeColorScheme(m_range);</span>






4245 #endif
4246     default:
4247         return nullptr;
4248     }
4249 }
4250 
4251 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax)
4252 {
4253     if (syntax != &quot;*&quot;) {
4254         m_range.consumeWhitespace();
4255 
4256         // First check for keywords
4257         CSSValueID id = m_range.peek().id();
4258         if (id == CSSValueInherit || id == CSSValueInitial || id == CSSValueRevert)
4259             return true;
4260 
4261         auto localRange = m_range;
4262         while (!localRange.atEnd()) {
4263             auto id = localRange.consume().functionId();
4264             if (id == CSSValueVar || id == CSSValueEnv)
</pre>
<hr />
<pre>
4999             return true;
5000         case CSSPropertyBorderImage:
5001             addProperty(CSSPropertyBorderImageSource, CSSPropertyBorderImage, source.releaseNonNull(), important);
5002             addProperty(CSSPropertyBorderImageSlice, CSSPropertyBorderImage, slice.releaseNonNull(), important);
5003             addProperty(CSSPropertyBorderImageWidth, CSSPropertyBorderImage, width.releaseNonNull() , important);
5004             addProperty(CSSPropertyBorderImageOutset, CSSPropertyBorderImage, outset.releaseNonNull(), important);
5005             addProperty(CSSPropertyBorderImageRepeat, CSSPropertyBorderImage, repeat.releaseNonNull(), important);
5006             return true;
5007         default:
5008             ASSERT_NOT_REACHED();
5009             return false;
5010         }
5011     }
5012     return false;
5013 }
5014 
5015 static inline CSSValueID mapFromPageBreakBetween(CSSValueID value)
5016 {
5017     if (value == CSSValueAlways)
5018         return CSSValuePage;
<span class="line-modified">5019     if (value == CSSValueAuto || value == CSSValueAvoid || value == CSSValueLeft || value == CSSValueRight)</span>
5020         return value;


5021     return CSSValueInvalid;
5022 }
5023 
5024 static inline CSSValueID mapFromColumnBreakBetween(CSSValueID value)
5025 {
5026     if (value == CSSValueAlways)
5027         return CSSValueColumn;
5028     if (value == CSSValueAuto)
5029         return value;
5030     if (value == CSSValueAvoid)
5031         return CSSValueAvoidColumn;
5032     return CSSValueInvalid;
5033 }
5034 
5035 static inline CSSValueID mapFromColumnRegionOrPageBreakInside(CSSValueID value)
5036 {
5037     if (value == CSSValueAuto || value == CSSValueAvoid)
5038         return value;
5039     return CSSValueInvalid;
5040 }
</pre>
<hr />
<pre>
5390     if (range.atEnd())
5391         return nullptr;
5392     auto list = CSSValueList::createSpaceSeparated();
5393     list-&gt;append(WTFMove(flowDirection));
5394     if (range.peek().id() == CSSValueAutoFlow) {
5395         range.consumeIncludingWhitespace();
5396         RefPtr&lt;CSSValue&gt; denseIdent = consumeIdent&lt;CSSValueDense&gt;(range);
5397         if (denseIdent)
5398             list-&gt;append(denseIdent.releaseNonNull());
5399     } else {
5400         // Dense case
5401         if (range.peek().id() != CSSValueDense)
5402             return nullptr;
5403         range.consumeIncludingWhitespace();
5404         if (range.atEnd() || range.peek().id() != CSSValueAutoFlow)
5405             return nullptr;
5406         range.consumeIncludingWhitespace();
5407         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDense));
5408     }
5409 
<span class="line-modified">5410     return list;</span>
5411 }
5412 
5413 bool CSSPropertyParser::consumeGridShorthand(bool important)
5414 {
5415     ASSERT(shorthandForProperty(CSSPropertyGrid).length() == 6);
5416 
5417     CSSParserTokenRange rangeCopy = m_range;
5418 
5419     // 1- &lt;grid-template&gt;
5420     if (consumeGridTemplateShorthand(CSSPropertyGrid, important)) {
5421         // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5422         // The sub-properties not specified are set to their initial value, as normal for shorthands.
5423         addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5424         addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5425         addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5426         return true;
5427     }
5428 
5429     m_range = rangeCopy;
5430 
</pre>
<hr />
<pre>
5557 
5558     if (m_range.atEnd())
5559         m_range = rangeCopy;
5560     RefPtr&lt;CSSValue&gt; justifySelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
5561     if (!justifySelfValue)
5562         return false;
5563 
5564     if (!m_range.atEnd())
5565         return false;
5566 
5567     addProperty(CSSPropertyAlignSelf, CSSPropertyPlaceSelf, alignSelfValue.releaseNonNull(), important);
5568     addProperty(CSSPropertyJustifySelf, CSSPropertyPlaceSelf, justifySelfValue.releaseNonNull(), important);
5569     return true;
5570 }
5571 
5572 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5573 {
5574     switch (property) {
5575     case CSSPropertyWebkitMarginCollapse: {
5576         CSSValueID id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5577         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context))</span>
5578             return false;
5579         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5580         if (m_range.atEnd()) {
5581             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5582             return true;
5583         }
5584         id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5585         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))</span>
5586             return false;
5587         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5588         return true;
5589     }
5590     case CSSPropertyOverflow: {
5591         CSSValueID id = m_range.consumeIncludingWhitespace().id();
<span class="line-modified">5592         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context))</span>
5593             return false;
5594         if (!m_range.atEnd())
5595             return false;
5596         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);
5597         RefPtr&lt;CSSValue&gt; overflowXValue;
5598 
5599         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been
5600         // set using the shorthand, then for now overflow-x will default to auto, but once we implement
5601         // pagination controls, it should default to hidden. If the overflow-y value is anything but
5602         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.
5603         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)
5604             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5605         else
5606             overflowXValue = overflowYValue;
5607         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);
5608         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);
5609         return true;
5610     }
5611     case CSSPropertyFont: {
5612         const CSSParserToken&amp; token = m_range.peek();
</pre>
<hr />
<pre>
5745         return consumeShorthandGreedily(borderRightShorthand(), important);
5746     case CSSPropertyBorderBottom:
5747         return consumeShorthandGreedily(borderBottomShorthand(), important);
5748     case CSSPropertyBorderLeft:
5749         return consumeShorthandGreedily(borderLeftShorthand(), important);
5750     case CSSPropertyBorder: {
5751         RefPtr&lt;CSSValue&gt; width;
5752         RefPtr&lt;CSSValue&gt; style;
5753         RefPtr&lt;CSSValue&gt; color;
5754         if (!consumeBorder(width, style, color))
5755             return false;
5756 
5757         addExpandedPropertyForValue(CSSPropertyBorderWidth, width.releaseNonNull(), important);
5758         addExpandedPropertyForValue(CSSPropertyBorderStyle, style.releaseNonNull(), important);
5759         addExpandedPropertyForValue(CSSPropertyBorderColor, color.releaseNonNull(), important);
5760         addExpandedPropertyForValue(CSSPropertyBorderImage, CSSValuePool::singleton().createImplicitInitialValue(), important);
5761         return true;
5762     }
5763     case CSSPropertyBorderImage:
5764         return consumeBorderImage(property, important);
<span class="line-added">5765     case CSSPropertyPageBreakAfter:</span>
<span class="line-added">5766     case CSSPropertyPageBreakBefore:</span>
<span class="line-added">5767     case CSSPropertyPageBreakInside:</span>
<span class="line-added">5768     case CSSPropertyWebkitColumnBreakAfter:</span>
<span class="line-added">5769     case CSSPropertyWebkitColumnBreakBefore:</span>
<span class="line-added">5770     case CSSPropertyWebkitColumnBreakInside:</span>
<span class="line-added">5771         return consumeLegacyBreakProperty(property, important);</span>
5772     case CSSPropertyWebkitMaskPosition:
5773     case CSSPropertyBackgroundPosition: {
5774         RefPtr&lt;CSSValue&gt; resultX;
5775         RefPtr&lt;CSSValue&gt; resultY;
5776         if (!consumeBackgroundPosition(m_range, m_context, UnitlessQuirk::Allow, resultX, resultY) || !m_range.atEnd())
5777             return false;
5778         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionX : CSSPropertyWebkitMaskPositionX, property, resultX.releaseNonNull(), important);
5779         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionY : CSSPropertyWebkitMaskPositionY, property, resultY.releaseNonNull(), important);
5780         return true;
5781     }
5782     case CSSPropertyBackgroundRepeat:
5783     case CSSPropertyWebkitMaskRepeat: {
5784         RefPtr&lt;CSSValue&gt; resultX;
5785         RefPtr&lt;CSSValue&gt; resultY;
5786         bool implicit = false;
5787         if (!consumeRepeatStyle(m_range, resultX, resultY, implicit) || !m_range.atEnd())
5788             return false;
5789         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatX : CSSPropertyWebkitMaskRepeatX, property, resultX.releaseNonNull(), important, implicit);
5790         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatY : CSSPropertyWebkitMaskRepeatY, property, resultY.releaseNonNull(), important, implicit);
5791         return true;
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserToken.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>