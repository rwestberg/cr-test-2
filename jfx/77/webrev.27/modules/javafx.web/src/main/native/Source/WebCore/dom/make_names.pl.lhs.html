<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/make_names.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #!/usr/bin/env perl
   2 
   3 # Copyright (C) 2005-2007, 2009, 2013-2014 Apple Inc. All rights reserved.
   4 # Copyright (C) 2009, Julien Chaffraix &lt;jchaffraix@webkit.org&gt;
   5 # Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   6 # Copyright (C) 2011 Ericsson AB. All rights reserved.
   7 #
   8 # Redistribution and use in source and binary forms, with or without
   9 # modification, are permitted provided that the following conditions
  10 # are met:
  11 #
  12 # 1.  Redistributions of source code must retain the above copyright
  13 #     notice, this list of conditions and the following disclaimer. 
  14 # 2.  Redistributions in binary form must reproduce the above copyright
  15 #     notice, this list of conditions and the following disclaimer in the
  16 #     documentation and/or other materials provided with the distribution. 
  17 # 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  18 #     its contributors may be used to endorse or promote products derived
  19 #     from this software without specific prior written permission. 
  20 #
  21 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31 
  32 use strict;
  33 use warnings;
  34 use FindBin;
  35 use lib &quot;$FindBin::Bin/../bindings/scripts&quot;;
  36 
  37 use StaticString;
  38 use Config;
  39 use Getopt::Long;
  40 use File::Path;
  41 use File::Spec;
  42 use IO::File;
  43 use InFilesParser;
  44 
  45 sub readTags($$);
  46 sub readAttrs($$);
  47 
  48 my $printFactory = 0; 
  49 my $printWrapperFactory = 0; 
  50 my $fontNamesIn = &quot;&quot;;
  51 my $tagsFile = &quot;&quot;;
  52 my $attrsFile = &quot;&quot;;
  53 my $outputDir = &quot;.&quot;;
  54 my %parsedTags = ();
  55 my %parsedAttrs = ();
  56 my %enabledTags = ();
  57 my %enabledAttrs = ();
  58 my %allTags = ();
  59 my %allAttrs = ();
  60 my %allStrings = ();
  61 my %parameters = ();
  62 my $extraDefines = 0;
  63 my $initDefaults = 1;
  64 my %extensionAttrs = ();
  65 
  66 require Config;
  67 
  68 my $ccLocation = &quot;&quot;;
  69 if ($ENV{CC}) {
  70     $ccLocation = $ENV{CC};
  71 } elsif ($Config::Config{&quot;osname&quot;} eq &quot;darwin&quot; &amp;&amp; $ENV{SDKROOT}) {
  72     chomp($ccLocation = `xcrun -find cc -sdk &#39;$ENV{SDKROOT}&#39;`);
  73 } else {
  74     $ccLocation = &quot;/usr/bin/cc&quot;;
  75 }
  76 
  77 my $preprocessor = &quot;&quot;;
  78 if ($Config::Config{&quot;osname&quot;} eq &quot;MSWin32&quot;) {
  79     $preprocessor = &quot;\&quot;$ccLocation\&quot; /EP&quot;;
  80 } else {
  81     $preprocessor = $ccLocation . &quot; -E -x c++&quot;;
  82 }
  83 
  84 GetOptions(
  85     &#39;tags=s&#39; =&gt; \$tagsFile, 
  86     &#39;attrs=s&#39; =&gt; \$attrsFile,
  87     &#39;factory&#39; =&gt; \$printFactory,
  88     &#39;outputDir=s&#39; =&gt; \$outputDir,
  89     &#39;extraDefines=s&#39; =&gt; \$extraDefines,
  90     &#39;preprocessor=s&#39; =&gt; \$preprocessor,
  91     &#39;wrapperFactory&#39; =&gt; \$printWrapperFactory,
  92     &#39;fonts=s&#39; =&gt; \$fontNamesIn
  93 );
  94 
  95 mkpath($outputDir);
  96 
  97 if (length($fontNamesIn)) {
  98     my $names = new IO::File;
  99     my $familyNamesFileBase = &quot;WebKitFontFamily&quot;;
 100 
 101     open($names, $fontNamesIn) or die &quot;Failed to open file: $fontNamesIn&quot;;
 102 
 103     $initDefaults = 0;
 104     my $Parser = InFilesParser-&gt;new();
 105     my $dummy;
 106     $Parser-&gt;parse($names, \&amp;parametersHandler, \&amp;dummy);
 107 
 108     my $F;
 109     my $header = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.h&quot;);
 110     open F, &quot;&gt;$header&quot; or die &quot;Unable to open $header for writing.&quot;;
 111 
 112     printLicenseHeader($F);
 113     printHeaderHead($F, &quot;CSS&quot;, $familyNamesFileBase, &lt;&lt;END, &quot;&quot;);
 114 #include &lt;wtf/NeverDestroyed.h&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 115 #include &lt;wtf/text/AtomicString.h&gt;</span>
 116 END
 117 
<a name="2" id="anc2"></a><span class="line-modified"> 118     printMacros($F, &quot;extern LazyNeverDestroyed&lt;const WTF::AtomicString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 119     print F &quot;#endif\n\n&quot;;
 120 
 121     printInit($F, 1);
 122     close F;
 123 
 124     my $source = File::Spec-&gt;catfile($outputDir, &quot;${familyNamesFileBase}Names.cpp&quot;);
 125     open F, &quot;&gt;$source&quot; or die &quot;Unable to open $source for writing.&quot;;
 126 
 127     printLicenseHeader($F);
 128     printCppHead($F, &quot;CSS&quot;, $familyNamesFileBase, &quot;WTF&quot;);
 129 
 130     print F StaticString::GenerateStrings(\%parameters);
 131 
<a name="3" id="anc3"></a><span class="line-modified"> 132     printMacros($F, &quot;LazyNeverDestroyed&lt;const WTF::AtomicString&gt;&quot;, &quot;&quot;, \%parameters);</span>
 133 
 134     printInit($F, 0);
 135 
 136     print F &quot;\n&quot;;
 137     print F StaticString::GenerateStringAsserts(\%parameters);
 138 
 139     for my $name (sort keys %parameters) {
 140         print F &quot;    ${name}.construct(&amp;${name}Data);\n&quot;;
 141     }
 142 
 143     print F &quot;}\n}\n}\n&quot;;
 144     close F;
 145     exit 0;
 146 }
 147 
 148 die &quot;You must specify at least one of --tags &lt;file&gt; or --attrs &lt;file&gt;&quot; unless (length($tagsFile) || length($attrsFile));
 149 
 150 if (length($tagsFile)) {
 151     %allTags = %{readTags($tagsFile, 0)};
 152     %enabledTags = %{readTags($tagsFile, 1)};
 153     namesToStrings(\%allTags, \%allStrings);
 154 }
 155 
 156 if (length($attrsFile)) {
 157     %allAttrs = %{readAttrs($attrsFile, 0)};
 158     %enabledAttrs = %{readAttrs($attrsFile, 1)};
 159     namesToStrings(\%allAttrs, \%allStrings);
 160 }
 161 
 162 die &quot;You must specify a namespace (e.g. SVG) for &lt;namespace&gt;Names.h&quot; unless $parameters{namespace};
 163 die &quot;You must specify a namespaceURI (e.g. http://www.w3.org/2000/svg)&quot; unless $parameters{namespaceURI};
 164 
 165 $parameters{namespacePrefix} = $parameters{namespace} unless $parameters{namespacePrefix};
 166 $parameters{fallbackJSInterfaceName} = $parameters{fallbackInterfaceName} unless $parameters{fallbackJSInterfaceName};
 167 
 168 my $typeHelpersBasePath = &quot;$outputDir/$parameters{namespace}ElementTypeHelpers&quot;;
 169 my $namesBasePath = &quot;$outputDir/$parameters{namespace}Names&quot;;
 170 my $factoryBasePath = &quot;$outputDir/$parameters{namespace}ElementFactory&quot;;
 171 my $wrapperFactoryFileName = &quot;$parameters{namespace}ElementWrapperFactory&quot;;
 172 
 173 printNamesHeaderFile(&quot;$namesBasePath.h&quot;);
 174 printNamesCppFile(&quot;$namesBasePath.cpp&quot;);
 175 printTypeHelpersHeaderFile(&quot;$typeHelpersBasePath.h&quot;);
 176 
 177 if ($printFactory) {
 178     printFactoryCppFile(&quot;$factoryBasePath.cpp&quot;);
 179     printFactoryHeaderFile(&quot;$factoryBasePath.h&quot;);
 180 }
 181 
 182 if ($printWrapperFactory) {
 183     printWrapperFactoryCppFile($outputDir, $wrapperFactoryFileName);
 184     printWrapperFactoryHeaderFile($outputDir, $wrapperFactoryFileName);
 185 }
 186 
 187 ### Hash initialization
 188 
 189 sub defaultTagPropertyHash
 190 {
 191     return (
 192         &#39;constructorNeedsCreatedByParser&#39; =&gt; 0,
 193         &#39;constructorNeedsFormElement&#39; =&gt; 0,
 194         &#39;noConstructor&#39; =&gt; 0,
 195         &#39;interfaceName&#39; =&gt; defaultInterfaceName($_[0]),
 196         # By default, the JSInterfaceName is the same as the interfaceName.
 197         &#39;JSInterfaceName&#39; =&gt; defaultInterfaceName($_[0]),
 198         &#39;mapToTagName&#39; =&gt; &#39;&#39;,
 199         &#39;wrapperOnlyIfMediaIsAvailable&#39; =&gt; 0,
 200         &#39;settingsConditional&#39; =&gt; 0,
 201         &#39;conditional&#39; =&gt; 0,
 202         &#39;runtimeEnabled&#39; =&gt; 0,
 203         &#39;customTypeHelper&#39; =&gt; 0,
 204     );
 205 }
 206 
 207 sub defaultParametersHash
 208 {
 209     return (
 210         &#39;namespace&#39; =&gt; &#39;&#39;,
 211         &#39;namespacePrefix&#39; =&gt; &#39;&#39;,
 212         &#39;namespaceURI&#39; =&gt; &#39;&#39;,
 213         &#39;guardFactoryWith&#39; =&gt; &#39;&#39;,
 214         &#39;tagsNullNamespace&#39; =&gt; 0,
 215         &#39;attrsNullNamespace&#39; =&gt; 0,
 216         &#39;fallbackInterfaceName&#39; =&gt; &#39;&#39;,
 217         &#39;fallbackJSInterfaceName&#39; =&gt; &#39;&#39;,
 218         &#39;customElementInterfaceName&#39; =&gt; &#39;&#39;,
 219     );
 220 }
 221 
 222 sub defaultInterfaceName
 223 {
 224     die &quot;No namespace found&quot; if !$parameters{namespace};
 225     return $parameters{namespace} . upperCaseName($_[0]) . &quot;Element&quot;
 226 }
 227 
 228 ### Parsing handlers
 229 
 230 sub valueForName
 231 {
 232     my $name = shift;
 233     my $value = $extensionAttrs{$name};
 234 
 235     if (!$value) {
 236         $value = $name;
 237         $value =~ s/_/-/g;
 238     }
 239 
 240     return $value;
 241 }
 242 
 243 sub namesToStrings
 244 {
 245     my $namesRef = shift;
 246     my $stringsRef = shift;
 247 
 248     my %names = %$namesRef;
 249 
 250     for my $name (keys %names) {
 251         $stringsRef-&gt;{$name} = valueForName($name);
 252     }
 253 }
 254 
 255 sub tagsHandler
 256 {
 257     my ($tag, $property, $value) = @_;
 258 
 259     $tag =~ s/-/_/g;
 260 
 261     # Initialize default property values.
 262     $parsedTags{$tag} = { defaultTagPropertyHash($tag) } if !defined($parsedTags{$tag});
 263 
 264     if ($property) {
 265         die &quot;Unknown property $property for tag $tag\n&quot; if !defined($parsedTags{$tag}{$property});
 266 
 267         # The code relies on JSInterfaceName deriving from interfaceName to check for custom JSInterfaceName.
 268         # So override JSInterfaceName if it was not already set.
 269         $parsedTags{$tag}{JSInterfaceName} = $value if $property eq &quot;interfaceName&quot; &amp;&amp; $parsedTags{$tag}{JSInterfaceName} eq $parsedTags{$tag}{interfaceName};
 270 
 271         $parsedTags{$tag}{$property} = $value;
 272     }
 273 }
 274 
 275 sub attrsHandler
 276 {
 277     my ($attr, $property, $value) = @_;
 278     # Translate HTML5 extension attributes of the form &#39;x-webkit-feature&#39; to &#39;webkitfeature&#39;.
 279     # We don&#39;t just check for the &#39;x-&#39; prefix because there are attributes such as x-height
 280     # which should follow the default path below.
 281     if ($attr =~ m/^x-webkit-(.*)/) {
 282         my $newAttr = &quot;webkit$1&quot;;
 283         $extensionAttrs{$newAttr} = $attr;
 284         $attr = $newAttr;
 285     }
 286     $attr =~ s/-/_/g;
 287 
 288     # Initialize default properties&#39; values.
 289     $parsedAttrs{$attr} = {} if !defined($parsedAttrs{$attr});
 290 
 291     if ($property) {
 292         die &quot;Unknown property $property for attribute $attr\n&quot; if !defined($parsedAttrs{$attr}{$property});
 293         $parsedAttrs{$attr}{$property} = $value;
 294     }
 295 }
 296 
 297 sub parametersHandler
 298 {
 299     my ($parameter, $value) = @_;
 300 
 301     # Initialize default properties&#39; values.
 302     %parameters = defaultParametersHash() if (!(keys %parameters) &amp;&amp; $initDefaults);
 303 
 304     die &quot;Unknown parameter $parameter for tags/attrs\n&quot; if (!defined($parameters{$parameter}) &amp;&amp; $initDefaults);
 305     $parameters{$parameter} = $value;
 306 }
 307 
 308 ## Support routines
 309 
 310 sub preprocessorCommand()
 311 {
 312     return $preprocessor if $extraDefines eq 0;
 313     return $preprocessor . &quot; -D&quot; . join(&quot; -D&quot;, split(&quot; &quot;, $extraDefines));
 314 }
 315 
 316 sub readNames($$$$)
 317 {
 318     my ($namesFile, $hashToFillRef, $handler, $usePreprocessor) = @_;
 319 
 320     my $names = new IO::File;
 321     if ($usePreprocessor) {
 322         open($names, preprocessorCommand() . &quot; &quot; . $namesFile . &quot;|&quot;) or die &quot;Failed to open file: $namesFile&quot;;
 323     } else {
 324         open($names, $namesFile) or die &quot;Failed to open file: $namesFile&quot;;
 325     }
 326 
 327     my $InParser = InFilesParser-&gt;new();
 328     $InParser-&gt;parse($names, \&amp;parametersHandler, $handler);
 329 
 330     close($names);
 331     die &quot;Failed to read names from file: $namesFile&quot; if (keys %{$hashToFillRef} == 0);
 332     return $hashToFillRef;
 333 }
 334 
 335 sub readAttrs($$)
 336 {
 337     my ($namesFile, $usePreprocessor) = @_;
 338     %parsedAttrs = ();
 339     return readNames($namesFile, \%parsedAttrs, \&amp;attrsHandler, $usePreprocessor);
 340 }
 341 
 342 sub readTags($$)
 343 {
 344     my ($namesFile, $usePreprocessor) = @_;
 345     %parsedTags = ();
 346     return readNames($namesFile, \%parsedTags, \&amp;tagsHandler, $usePreprocessor);
 347 }
 348 
 349 sub printMacros
 350 {
 351     my ($F, $macro, $suffix, $namesRef) = @_;
 352     my %names = %$namesRef;
 353 
 354     for my $name (sort keys %names) {
 355         print F &quot;$macro $name&quot;,&quot;$suffix;\n&quot;;
 356     }
 357 }
 358 
 359 sub usesDefaultWrapper
 360 {
 361     my $tagName = shift;
 362     return $tagName eq $parameters{namespace} . &quot;Element&quot;;
 363 }
 364 
 365 # Build a direct mapping from the tags to the Element to create.
 366 sub buildConstructorMap
 367 {
 368     my %tagConstructorMap = ();
 369     for my $tagName (keys %enabledTags) {
 370         my $interfaceName = $enabledTags{$tagName}{interfaceName};
 371 
 372         if ($enabledTags{$tagName}{mapToTagName}) {
 373             die &quot;Cannot handle multiple mapToTagName for $tagName\n&quot; if $enabledTags{$enabledTags{$tagName}{mapToTagName}}{mapToTagName};
 374             $interfaceName = $enabledTags{ $enabledTags{$tagName}{mapToTagName} }{interfaceName};
 375         }
 376 
 377         # Chop the string to keep the interesting part.
 378         $interfaceName =~ s/$parameters{namespace}(.*)Element/$1/;
 379         $tagConstructorMap{$tagName} = lc($interfaceName);
 380     }
 381 
 382     return %tagConstructorMap;
 383 }
 384 
 385 # Helper method that print the constructor&#39;s signature avoiding
 386 # unneeded arguments.
 387 sub printConstructorSignature
 388 {
 389     my ($F, $tagName, $constructorName, $constructorTagName) = @_;
 390 
 391     print F &quot;static Ref&lt;$parameters{namespace}Element&gt; ${constructorName}Constructor(const QualifiedName&amp; $constructorTagName, Document&amp; document&quot;;
 392     if ($parameters{namespace} eq &quot;HTML&quot;) {
 393         print F &quot;, HTMLFormElement*&quot;;
 394         print F &quot; formElement&quot; if $enabledTags{$tagName}{constructorNeedsFormElement};
 395     }
 396     print F &quot;, bool&quot;;
 397     print F &quot; createdByParser&quot; if $enabledTags{$tagName}{constructorNeedsCreatedByParser};
 398     print F &quot;)\n{\n&quot;;
 399 }
 400 
 401 # Helper method to dump the constructor interior and call the 
 402 # Element constructor with the right arguments.
 403 # The variable names should be kept in sync with the previous method.
 404 sub printConstructorInterior
 405 {
 406     my ($F, $tagName, $interfaceName, $constructorTagName) = @_;
 407 
 408     # Handle media elements.
 409     # Note that wrapperOnlyIfMediaIsAvailable is a misnomer, because media availability
 410     # does not just control the wrapper; it controls the element object that is created.
 411     # FIXME: Could we instead do this entirely in the wrapper, and use custom wrappers
 412     # instead of having all the support for this here in this script?
 413     if ($enabledTags{$tagName}{wrapperOnlyIfMediaIsAvailable}) {
 414         print F &lt;&lt;END
 415     if (!document.settings().mediaEnabled())
 416         return $parameters{fallbackInterfaceName}::create($constructorTagName, document);
 417     
 418 END
 419 ;
 420     }
 421 
 422     my $runtimeCondition;
 423     my $settingsConditional = $enabledTags{$tagName}{settingsConditional};
 424     my $runtimeEnabled = $enabledTags{$tagName}{runtimeEnabled};
 425     if ($settingsConditional) {
 426         $runtimeCondition = &quot;document.settings().${settingsConditional}()&quot;;
 427     } elsif ($runtimeEnabled) {
 428         $runtimeCondition = &quot;RuntimeEnabledFeatures::sharedFeatures().${runtimeEnabled}Enabled()&quot;;
 429     }
 430 
 431     if ($runtimeCondition) {
 432         print F &lt;&lt;END
 433     if (!$runtimeCondition)
 434         return $parameters{fallbackInterfaceName}::create($constructorTagName, document);
 435 END
 436 ;
 437     }
 438 
 439     # Call the constructor with the right parameters.
 440     print F &quot;    return ${interfaceName}::create($constructorTagName, document&quot;;
 441     print F &quot;, formElement&quot; if $enabledTags{$tagName}{constructorNeedsFormElement};
 442     print F &quot;, createdByParser&quot; if $enabledTags{$tagName}{constructorNeedsCreatedByParser};
 443     print F &quot;);\n}\n&quot;;
 444 }
 445 
 446 sub printConstructors
 447 {
 448     my ($F, $tagConstructorMapRef) = @_;
 449     my %tagConstructorMap = %$tagConstructorMapRef;
 450 
 451     # This is to avoid generating the same constructor several times.
 452     my %uniqueTags = ();
 453     for my $tagName (sort keys %tagConstructorMap) {
 454         my $interfaceName = $enabledTags{$tagName}{interfaceName};
 455 
 456         # Ignore the mapped tag
 457         # FIXME: It could be moved inside this loop but was split for readibility.
 458         next if (defined($uniqueTags{$interfaceName}) || $enabledTags{$tagName}{mapToTagName});
 459         # Tags can have wrappers without constructors.
 460         # This is useful to make user-agent shadow elements internally testable
 461         # while keeping them from being avaialble in the HTML markup.
 462         next if $enabledTags{$tagName}{noConstructor};
 463 
 464         $uniqueTags{$interfaceName} = &#39;1&#39;;
 465 
 466         my $conditional = $enabledTags{$tagName}{conditional};
 467         if ($conditional) {
 468             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
 469             print F &quot;#if ${conditionalString}\n&quot;;
 470         }
 471 
 472         printConstructorSignature($F, $tagName, $tagConstructorMap{$tagName}, &quot;tagName&quot;);
 473         printConstructorInterior($F, $tagName, $interfaceName, &quot;tagName&quot;);
 474 
 475         if ($conditional) {
 476             print F &quot;#endif\n&quot;;
 477         }
 478 
 479         print F &quot;\n&quot;;
 480     }
 481 
 482     # Mapped tag name uses a special wrapper to keep their prefix and namespaceURI while using the mapped localname.
 483     for my $tagName (sort keys %tagConstructorMap) {
 484         if ($enabledTags{$tagName}{mapToTagName}) {
 485             my $mappedName = $enabledTags{$tagName}{mapToTagName};
 486             printConstructorSignature($F, $mappedName, $mappedName . &quot;To&quot; . $tagName, &quot;tagName&quot;);
 487             printConstructorInterior($F, $mappedName, $enabledTags{$mappedName}{interfaceName}, &quot;QualifiedName(tagName.prefix(), ${mappedName}Tag-&gt;localName(), tagName.namespaceURI())&quot;);
 488         }
 489     }
 490 }
 491 
 492 sub printFunctionTable
 493 {
 494     my ($F, $tagConstructorMap) = @_;
 495     my %tagConstructorMap = %$tagConstructorMap;
 496 
 497     for my $tagName (sort keys %tagConstructorMap) {
 498         next if $enabledTags{$tagName}{noConstructor};
 499 
 500         my $conditional = $enabledTags{$tagName}{conditional};
 501         if ($conditional) {
 502             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
 503             print F &quot;#if ${conditionalString}\n&quot;;
 504         }
 505 
 506         if ($enabledTags{$tagName}{mapToTagName}) {
 507             print F &quot;        { ${tagName}Tag, $enabledTags{$tagName}{mapToTagName}To${tagName}Constructor },\n&quot;;
 508         } else {
 509             print F &quot;        { ${tagName}Tag, $tagConstructorMap{$tagName}Constructor },\n&quot;;
 510         }
 511 
 512         if ($conditional) {
 513             print F &quot;#endif\n&quot;;
 514         }
 515     }
 516 }
 517 
 518 sub svgCapitalizationHacks
 519 {
 520     my $name = shift;
 521 
 522     $name = &quot;FE&quot; . ucfirst $1 if $name =~ /^fe(.+)$/;
 523 
 524     return $name;
 525 }
 526 
 527 sub upperCaseName
 528 {
 529     my $name = shift;
 530     
 531     $name = svgCapitalizationHacks($name) if ($parameters{namespace} eq &quot;SVG&quot;);
 532 
 533     while ($name =~ /^(.*?)_(.*)/) {
 534         $name = $1 . ucfirst $2;
 535     }
 536     
 537     return ucfirst $name;
 538 }
 539 
 540 sub printHeaderHead
 541 {
 542     my ($F, $prefix, $namespace, $includes, $definitions) = @_;
 543 
 544     print F&lt;&lt;END
 545 #ifndef ${prefix}_${namespace}Names_h
 546 
 547 #define ${prefix}_${namespace}Names_h
 548 
 549 $includes
 550 
 551 namespace WebCore {
 552 
 553 ${definitions}namespace ${namespace}Names {
 554 
 555 #ifndef ${prefix}_${namespace}_NAMES_HIDE_GLOBALS
 556 
 557 END
 558     ;
 559 }
 560 
 561 sub printCppHead
 562 {
 563     my ($F, $prefix, $namespace, $usedNamespace) = @_;
 564 
 565     print F &quot;#include \&quot;config.h\&quot;\n\n&quot;;
 566     print F &quot;#ifdef SKIP_STATIC_CONSTRUCTORS_ON_GCC\n&quot;;
 567     print F &quot;#define ${prefix}_${namespace}_NAMES_HIDE_GLOBALS 1\n&quot;;
 568     print F &quot;#else\n&quot;;
 569     print F &quot;#define QNAME_DEFAULT_CONSTRUCTOR 1\n&quot;;
 570     print F &quot;#endif\n\n&quot;;
 571 
 572     print F &quot;#include \&quot;${namespace}Names.h\&quot;\n\n&quot;;
 573 
 574     print F &quot;namespace WebCore {\n\n&quot;;
 575     print F &quot;namespace ${namespace}Names {\n\n&quot;;
 576     print F &quot;using namespace $usedNamespace;\n\n&quot;;
 577 }
 578 
 579 sub printInit
 580 {
 581     my ($F, $isDefinition) = @_;
 582 
 583     if ($isDefinition) {
 584         print F &quot;\nWEBCORE_EXPORT void init();\n\n&quot;;
 585         print F &quot;} }\n\n&quot;;
 586         print F &quot;#endif\n\n&quot;;
 587         return;
 588     }
 589 
 590 print F &quot;\nvoid init()
 591 {
 592     static bool initialized = false;
 593     if (initialized)
 594         return;
 595     initialized = true;
 596 
 597     // Use placement new to initialize the globals.
 598 
<a name="4" id="anc4"></a><span class="line-modified"> 599     AtomicString::init();</span>
 600 &quot;;
 601 }
 602 
 603 sub printLicenseHeader
 604 {
 605     my $F = shift;
 606     print F &quot;/*
 607  * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 608  *
 609  * This file was generated by the dom/make_names.pl script.
 610  *
 611  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 612  *
 613  * Redistribution and use in source and binary forms, with or without
 614  * modification, are permitted provided that the following conditions
 615  * are met:
 616  * 1. Redistributions of source code must retain the above copyright
 617  *    notice, this list of conditions and the following disclaimer.
 618  * 2. Redistributions in binary form must reproduce the above copyright
 619  *    notice, this list of conditions and the following disclaimer in the
 620  *    documentation and/or other materials provided with the distribution.
 621  *
 622  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 623  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 624  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 625  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 626  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 627  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 628  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 629  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 630  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 631  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 632  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 633  */
 634 
 635 &quot;;
 636 }
 637 
 638 sub printTypeHelpers
 639 {
 640     my ($F, $namesRef) = @_;
 641     my %names = %$namesRef;
 642 
 643     # Do a first pass to discard classes that map to several tags.
 644     my %classToTags = ();
 645     for my $name (keys %names) {
 646         my $class = $parsedTags{$name}{interfaceName};
 647         push(@{$classToTags{$class}}, $name) if defined $class;
 648     }
 649 
 650     for my $class (sort keys %classToTags) {
 651         my $name = $classToTags{$class}[0];
 652         next if $parsedTags{$name}{customTypeHelper};
 653         # Skip classes that map to more than 1 tag.
 654         my $tagCount = scalar @{$classToTags{$class}};
 655         next if $tagCount &gt; 1;
 656 
 657         print F &lt;&lt;END
 658 namespace WebCore {
 659 class $class;
 660 }
 661 namespace WTF {
 662 template&lt;typename ArgType&gt; class TypeCastTraits&lt;const WebCore::$class, ArgType, false /* isBaseType */&gt; {
 663 public:
 664     static bool isOfType(ArgType&amp; node) { return checkTagName(node); }
 665 private:
 666 END
 667        ;
 668        if ($parameters{namespace} eq &quot;HTML&quot; &amp;&amp; ($parsedTags{$name}{wrapperOnlyIfMediaIsAvailable} || $parsedTags{$name}{settingsConditional} || $parsedTags{$name}{runtimeEnabled})) {
 669            print F &lt;&lt;END
 670     static bool checkTagName(const WebCore::HTMLElement&amp; element) { return !element.isHTMLUnknownElement() &amp;&amp; element.hasTagName(WebCore::$parameters{namespace}Names::${name}Tag); }
 671     static bool checkTagName(const WebCore::Node&amp; node) { return is&lt;WebCore::HTMLElement&gt;(node) &amp;&amp; checkTagName(downcast&lt;WebCore::HTMLElement&gt;(node)); }
 672 END
 673            ;
 674        } else {
 675            print F &lt;&lt;END
 676     static bool checkTagName(const WebCore::$parameters{namespace}Element&amp; element) { return element.hasTagName(WebCore::$parameters{namespace}Names::${name}Tag); }
 677     static bool checkTagName(const WebCore::Node&amp; node) { return node.hasTagName(WebCore::$parameters{namespace}Names::${name}Tag); }
 678 END
 679            ;
 680        }
 681        print F &lt;&lt;END
 682     static bool checkTagName(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; checkTagName(downcast&lt;WebCore::Node&gt;(target)); }
 683 };
 684 }
 685 END
 686        ;
 687        print F &quot;\n&quot;;
 688     }
 689 }
 690 
 691 sub printTypeHelpersHeaderFile
 692 {
 693     my ($headerPath) = shift;
 694     my $F;
 695     open F, &quot;&gt;$headerPath&quot;;
 696     printLicenseHeader($F);
 697 
 698     print F &quot;#ifndef &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n&quot;;
 699     print F &quot;#define &quot;.$parameters{namespace}.&quot;ElementTypeHelpers_h\n\n&quot;;
 700     print F &quot;#include \&quot;&quot;.$parameters{namespace}.&quot;Names.h\&quot;\n\n&quot;;
 701 
 702     printTypeHelpers($F, \%allTags);
 703 
 704     print F &quot;#endif\n&quot;;
 705 
 706     close F;
 707 }
 708 
 709 sub printNamesHeaderFile
 710 {
 711     my ($headerPath) = shift;
 712     my $F;
 713     open F, &quot;&gt;$headerPath&quot;;
 714 
 715     printLicenseHeader($F);
 716     printHeaderHead($F, &quot;DOM&quot;, $parameters{namespace}, &lt;&lt;END, &quot;class $parameters{namespace}QualifiedName : public QualifiedName { };\n\n&quot;);
 717 #include &lt;wtf/NeverDestroyed.h&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 718 #include &lt;wtf/text/AtomicString.h&gt;</span>
 719 #include &quot;QualifiedName.h&quot;
 720 END
 721 
 722     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 723 
 724     print F &quot;// Namespace\n&quot;;
<a name="6" id="anc6"></a><span class="line-modified"> 725     print F &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WTF::AtomicString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 726 
 727     if (keys %allTags) {
 728         print F &quot;// Tags\n&quot;;
 729         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::$parameters{namespace}QualifiedName&gt;&quot;, &quot;Tag&quot;, \%allTags);
 730     }
 731 
 732     if (keys %allAttrs) {
 733         print F &quot;// Attributes\n&quot;;
 734         printMacros($F, &quot;WEBCORE_EXPORT extern LazyNeverDestroyed&lt;const WebCore::QualifiedName&gt;&quot;, &quot;Attr&quot;, \%allAttrs);
 735     }
 736     print F &quot;#endif\n\n&quot;;
 737 
 738     if (keys %allTags) {
 739         print F &quot;const unsigned $parameters{namespace}TagsCount = &quot;, scalar(keys %allTags), &quot;;\n&quot;;
 740         print F &quot;const WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags();\n&quot;;
 741     }
 742 
 743     if (keys %allAttrs) {
 744         print F &quot;const unsigned $parameters{namespace}AttrsCount = &quot;, scalar(keys %allAttrs), &quot;;\n&quot;;
 745         print F &quot;const WebCore::QualifiedName* const* get$parameters{namespace}Attrs();\n&quot;;
 746     }
 747 
 748     printInit($F, 1);
 749     close F;
 750 }
 751 
 752 sub printNamesCppFile
 753 {
 754     my $cppPath = shift;
 755     my $F;
 756     open F, &quot;&gt;$cppPath&quot;;
 757     
 758     printLicenseHeader($F);
 759     printCppHead($F, &quot;DOM&quot;, $parameters{namespace}, &quot;WebCore&quot;);
 760     
 761     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 762 
<a name="7" id="anc7"></a><span class="line-modified"> 763     print F &quot;LazyNeverDestroyed&lt;const AtomicString&gt; ${lowercaseNamespacePrefix}NamespaceURI;\n\n&quot;;</span>
 764 
 765     print F StaticString::GenerateStrings(\%allStrings);
 766 
 767     if (keys %allTags) {
 768         print F &quot;// Tags\n&quot;;
 769         for my $name (sort keys %allTags) {
 770             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const $parameters{namespace}QualifiedName&gt; ${name}Tag;\n&quot;;
 771         }
 772         
 773         print F &quot;\n\nconst WebCore::$parameters{namespace}QualifiedName* const* get$parameters{namespace}Tags()\n&quot;;
 774         print F &quot;{\n    static const WebCore::$parameters{namespace}QualifiedName* const $parameters{namespace}Tags[] = {\n&quot;;
 775         for my $name (sort keys %allTags) {
 776             print F &quot;        &amp;${name}Tag.get(),\n&quot;;
 777         }
 778         print F &quot;    };\n&quot;;
 779         print F &quot;    return $parameters{namespace}Tags;\n&quot;;
 780         print F &quot;}\n&quot;;
 781     }
 782 
 783     if (keys %allAttrs) {
 784         print F &quot;\n// Attributes\n&quot;;
 785         for my $name (sort keys %allAttrs) {
 786             print F &quot;WEBCORE_EXPORT LazyNeverDestroyed&lt;const QualifiedName&gt; ${name}Attr;\n&quot;;
 787         }
 788         print F &quot;\n\nconst WebCore::QualifiedName* const* get$parameters{namespace}Attrs()\n&quot;;
 789         print F &quot;{\n    static const WebCore::QualifiedName* const $parameters{namespace}Attrs[] = {\n&quot;;
 790         for my $name (sort keys %allAttrs) {
 791             print F &quot;        &amp;${name}Attr.get(),\n&quot;;
 792         }
 793         print F &quot;    };\n&quot;;
 794         print F &quot;    return $parameters{namespace}Attrs;\n&quot;;
 795         print F &quot;}\n&quot;;
 796     }
 797 
 798     printInit($F, 0);
 799 
<a name="8" id="anc8"></a><span class="line-modified"> 800     print(F &quot;    AtomicString ${lowercaseNamespacePrefix}NS(\&quot;$parameters{namespaceURI}\&quot;, AtomicString::ConstructFromLiteral);\n\n&quot;);</span>
 801 
 802     print(F &quot;    // Namespace\n&quot;);
 803     print(F &quot;    ${lowercaseNamespacePrefix}NamespaceURI.construct(${lowercaseNamespacePrefix}NS);\n&quot;);
 804     print(F &quot;\n&quot;);
 805     print F StaticString::GenerateStringAsserts(\%allStrings);
 806 
 807     if (keys %allTags) {
 808         my $tagsNamespace = $parameters{tagsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 809         printDefinitions($F, \%allTags, &quot;tags&quot;, $tagsNamespace);
 810     }
 811     if (keys %allAttrs) {
 812         my $attrsNamespace = $parameters{attrsNullNamespace} ? &quot;nullAtom()&quot; : &quot;${lowercaseNamespacePrefix}NS&quot;;
 813         printDefinitions($F, \%allAttrs, &quot;attributes&quot;, $attrsNamespace);
 814     }
 815 
 816     print F &quot;}\n\n} }\n\n&quot;;
 817     close F;
 818 }
 819 
 820 sub printJSElementIncludes
 821 {
 822     my $F = shift;
 823 
 824     my %tagsSeen;
 825     for my $tagName (sort keys %enabledTags) {
 826         my $JSInterfaceName = $enabledTags{$tagName}{JSInterfaceName};
 827         next if defined($tagsSeen{$JSInterfaceName}) || usesDefaultJSWrapper($tagName);
 828         if ($enabledTags{$tagName}{conditional}) {
 829             # We skip feature-define-specific #includes here since we handle them separately.
 830             next;
 831         }
 832         $tagsSeen{$JSInterfaceName} = 1;
 833 
 834         print F &quot;#include \&quot;JS${JSInterfaceName}.h\&quot;\n&quot;;
 835     }
 836     print F &quot;#include \&quot;JS$parameters{fallbackJSInterfaceName}.h\&quot;\n&quot;;
 837 }
 838 
 839 sub printElementIncludes
 840 {
 841     my $F = shift;
 842 
 843     my %tagsSeen;
 844     for my $tagName (sort keys %enabledTags) {
 845         my $interfaceName = $enabledTags{$tagName}{interfaceName};
 846         next if defined($tagsSeen{$interfaceName});
 847         if ($enabledTags{$tagName}{conditional}) {
 848             # We skip feature-define-specific #includes here since we handle them separately.
 849             next;
 850         }
 851         $tagsSeen{$interfaceName} = 1;
 852 
 853         print F &quot;#include \&quot;${interfaceName}.h\&quot;\n&quot;;
 854     }
 855     print F &quot;#include \&quot;$parameters{fallbackInterfaceName}.h\&quot;\n&quot;;
 856 }
 857 
 858 sub printConditionalElementIncludes
 859 {
 860     my ($F, $wrapperIncludes) = @_;
 861 
 862     my %conditionals;
 863     my %unconditionalElementIncludes;
 864     my %unconditionalJSElementIncludes;
 865 
 866     for my $tagName (keys %enabledTags) {
 867         my $conditional = $enabledTags{$tagName}{conditional};
 868         my $interfaceName = $enabledTags{$tagName}{interfaceName};
 869         my $JSInterfaceName = $enabledTags{$tagName}{JSInterfaceName};
 870 
 871         if ($conditional) {
 872             $conditionals{$conditional}{interfaceNames}{$interfaceName} = 1;
 873             $conditionals{$conditional}{JSInterfaceNames}{$JSInterfaceName} = 1;
 874         } else {
 875             $unconditionalElementIncludes{$interfaceName} = 1;
 876             $unconditionalJSElementIncludes{$JSInterfaceName} = 1;
 877         }
 878     }
 879 
 880     for my $conditional (sort keys %conditionals) {
 881         print F &quot;\n#if ENABLE($conditional)\n&quot;;
 882         for my $interfaceName (sort keys %{$conditionals{$conditional}{interfaceNames}}) {
 883             next if $unconditionalElementIncludes{$interfaceName};
 884             print F &quot;#include \&quot;$interfaceName.h\&quot;\n&quot;;
 885         }
 886         if ($wrapperIncludes) {
 887             for my $JSInterfaceName (sort keys %{$conditionals{$conditional}{JSInterfaceNames}}) {
 888                 next if $unconditionalJSElementIncludes{$JSInterfaceName};
 889                 print F &quot;#include \&quot;JS$JSInterfaceName.h\&quot;\n&quot;;
 890             }
 891         }
 892         print F &quot;#endif\n&quot;;
 893     }
 894 }
 895 
 896 sub printDefinitions
 897 {
 898     my ($F, $namesRef, $type, $namespaceURI) = @_;
 899 
 900     my $shortCamelType = ucfirst(substr(substr($type, 0, -1), 0, 4));
 901     my $capitalizedType = ucfirst($type);
 902     
 903 print F &lt;&lt;END;
 904 
 905     struct ${capitalizedType}TableEntry {
 906         LazyNeverDestroyed&lt;const QualifiedName&gt;* targetAddress;
 907         const StaticStringImpl&amp; name;
 908     };
 909 
 910     static const ${capitalizedType}TableEntry ${type}Table[] = {
 911 END
 912 
 913     my $cast = $type eq &quot;tags&quot; ? &quot;(LazyNeverDestroyed&lt;const QualifiedName&gt;*)&quot; : &quot;&quot;;
 914     for my $name (sort keys %$namesRef) {
 915         print F &quot;        { $cast&amp;$name$shortCamelType, *(&amp;${name}Data) },\n&quot;;
 916     }
 917 
 918 print F &lt;&lt;END;
 919     };
 920 
 921     for (auto&amp; entry : ${type}Table)
<a name="9" id="anc9"></a><span class="line-modified"> 922         entry.targetAddress-&gt;construct(nullAtom(), AtomicString(&amp;entry.name), $namespaceURI);</span>
 923 END
 924 
 925 }
 926 
 927 ## ElementFactory routines
 928 
 929 sub printFactoryCppFile
 930 {
 931     my $cppPath = shift;
 932     my $F;
 933     open F, &quot;&gt;$cppPath&quot;;
 934 
 935     my $formElementArgumentForDeclaration = &quot;&quot;;
 936     my $formElementArgumentForDefinition = &quot;&quot;;
 937     $formElementArgumentForDeclaration = &quot;, HTMLFormElement*&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 938     $formElementArgumentForDefinition = &quot;, HTMLFormElement* formElement&quot; if $parameters{namespace} eq &quot;HTML&quot;;
 939 
 940     printLicenseHeader($F);
 941 
 942     print F &lt;&lt;END
 943 #include &quot;config.h&quot;
 944 END
 945     ;
 946 
 947     print F &quot;\n#if $parameters{guardFactoryWith}\n\n&quot; if $parameters{guardFactoryWith};
 948 
 949     print F &lt;&lt;END
 950 #include &quot;$parameters{namespace}ElementFactory.h&quot;
 951 
 952 #include &quot;$parameters{namespace}Names.h&quot;
 953 
 954 END
 955     ;
 956 
 957     printElementIncludes($F);
 958     printConditionalElementIncludes($F, 0);
 959 
 960     print F &lt;&lt;END
 961 
 962 #include &quot;Document.h&quot;
 963 #include &quot;RuntimeEnabledFeatures.h&quot;
 964 #include &quot;Settings.h&quot;
 965 #include &lt;wtf/HashMap.h&gt;
 966 #include &lt;wtf/NeverDestroyed.h&gt;
 967 
 968 namespace WebCore {
 969 
 970 using namespace $parameters{namespace}Names;
 971 
 972 typedef Ref&lt;$parameters{namespace}Element&gt; (*$parameters{namespace}ConstructorFunction)(const QualifiedName&amp;, Document&amp;$formElementArgumentForDeclaration, bool createdByParser);
 973 
 974 END
 975     ;
 976 
 977     my %tagConstructorMap = buildConstructorMap();
 978     my $argumentList;
 979 
 980     if ($parameters{namespace} eq &quot;HTML&quot;) {
 981         $argumentList = &quot;name, document, formElement, createdByParser&quot;;
 982     } else {
 983         $argumentList = &quot;name, document, createdByParser&quot;;
 984     }
 985 
 986     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 987 
 988     printConstructors($F, \%tagConstructorMap);
 989 
 990     print F &lt;&lt;END
 991 
 992 struct $parameters{namespace}ConstructorFunctionMapEntry {
 993     $parameters{namespace}ConstructorFunctionMapEntry($parameters{namespace}ConstructorFunction function, const QualifiedName&amp; name)
 994         : function(function)
 995         , qualifiedName(&amp;name)
 996     { }
 997 
 998     $parameters{namespace}ConstructorFunctionMapEntry()
 999         : function(nullptr)
1000         , qualifiedName(nullptr)
1001     { }
1002 
1003     $parameters{namespace}ConstructorFunction function;
1004     const QualifiedName* qualifiedName; // Use pointer instead of reference so that emptyValue() in HashMap is cheap to create.
1005 };
1006 
<a name="10" id="anc10"></a><span class="line-modified">1007 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; create$parameters{namespace}FactoryMap()</span>
1008 {
1009     struct TableEntry {
1010         const QualifiedName&amp; name;
1011         $parameters{namespace}ConstructorFunction function;
1012     };
1013 
1014     static const TableEntry table[] = {
1015 END
1016     ;
1017 
1018     printFunctionTable($F, \%tagConstructorMap);
1019 
1020     print F &lt;&lt;END
1021     };
1022 
<a name="11" id="anc11"></a><span class="line-modified">1023     HashMap&lt;AtomicStringImpl*, $parameters{namespace}ConstructorFunctionMapEntry&gt; map;</span>
1024     for (auto&amp; entry : table)
1025         map.add(entry.name.localName().impl(), $parameters{namespace}ConstructorFunctionMapEntry(entry.function, entry.name));
1026     return map;
1027 }
1028 
<a name="12" id="anc12"></a><span class="line-modified">1029 static $parameters{namespace}ConstructorFunctionMapEntry find$parameters{namespace}ElementConstructorFunction(const AtomicString&amp; localName)</span>
1030 {
1031     static const auto map = makeNeverDestroyed(create$parameters{namespace}FactoryMap());
1032     return map.get().get(localName.impl());
1033 }
1034 
<a name="13" id="anc13"></a><span class="line-modified">1035 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const AtomicString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1036 {
1037     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1038     if (LIKELY(entry.function)) {
1039         ASSERT(entry.qualifiedName);
1040         const auto&amp; name = *entry.qualifiedName;
1041         return entry.function($argumentList);
1042     }
1043     return nullptr;
1044 }
1045 
1046 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1047 {
1048     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1049     if (LIKELY(entry.function))
1050         return entry.function($argumentList);
1051     return nullptr;
1052 }
1053 
<a name="14" id="anc14"></a><span class="line-modified">1054 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const AtomicString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)</span>
1055 {
1056     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1057     if (LIKELY(entry.function)) {
1058         ASSERT(entry.qualifiedName);
1059         const auto&amp; name = *entry.qualifiedName;
1060         return entry.function($argumentList);
1061     }
1062     return $parameters{fallbackInterfaceName}::create(QualifiedName(nullAtom(), localName, ${lowercaseNamespacePrefix}NamespaceURI), document);
1063 }
1064 
1065 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1066 {
1067     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1068     if (LIKELY(entry.function))
1069         return entry.function($argumentList);
1070     return $parameters{fallbackInterfaceName}::create(name, document);
1071 }
1072 
1073 } // namespace WebCore
1074 
1075 END
1076     ;
1077 
1078     print F &quot;#endif\n&quot; if $parameters{guardFactoryWith};
1079 
1080     close F;
1081 }
1082 
1083 sub printFactoryHeaderFile
1084 {
1085     my $headerPath = shift;
1086     my $F;
1087     open F, &quot;&gt;$headerPath&quot;;
1088 
1089     printLicenseHeader($F);
1090 
1091     print F&lt;&lt;END
1092 #ifndef $parameters{namespace}ElementFactory_h
1093 #define $parameters{namespace}ElementFactory_h
1094 
1095 #include &lt;wtf/Forward.h&gt;
1096 
1097 namespace WebCore {
1098 
1099 class Document;
1100 class HTMLFormElement;
1101 class QualifiedName;
1102 
1103 class $parameters{namespace}Element;
1104 
1105 class $parameters{namespace}ElementFactory {
1106 public:
1107 END
1108 ;
1109 
<a name="15" id="anc15"></a><span class="line-modified">1110 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const AtomicString&amp;, Document&amp;&quot;;</span>
1111 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1112 print F &quot;, bool createdByParser = false);\n&quot;;
1113 
1114 print F &quot;static RefPtr&lt;$parameters{namespace}Element&gt; createKnownElement(const QualifiedName&amp;, Document&amp;&quot;;
1115 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1116 print F &quot;, bool createdByParser = false);\n&quot;;
1117 
<a name="16" id="anc16"></a><span class="line-modified">1118 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const AtomicString&amp;, Document&amp;&quot;;</span>
1119 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1120 print F &quot;, bool createdByParser = false);\n&quot;;
1121 
1122 print F &quot;static Ref&lt;$parameters{namespace}Element&gt; createElement(const QualifiedName&amp;, Document&amp;&quot;;
1123 print F &quot;, HTMLFormElement* = nullptr&quot; if $parameters{namespace} eq &quot;HTML&quot;;
1124 print F &quot;, bool createdByParser = false);\n&quot;;
1125 
1126 printf F&lt;&lt;END
1127 };
1128 
1129 }
1130 
1131 #endif // $parameters{namespace}ElementFactory_h
1132 
1133 END
1134 ;
1135 
1136     close F;
1137 }
1138 
1139 ## Wrapper Factory routines
1140 
1141 sub usesDefaultJSWrapper
1142 {
1143     my $name = shift;
1144 
1145     # A tag reuses the default wrapper if its JSInterfaceName matches the default namespace Element.
1146     return $enabledTags{$name}{JSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;;
1147 }
1148 
1149 sub printWrapperFunctions
1150 {
1151     my $F = shift;
1152 
1153     my %tagsSeen;
1154     for my $tagName (sort keys %enabledTags) {
1155         # Avoid defining the same wrapper method twice.
1156         my $JSInterfaceName = $enabledTags{$tagName}{JSInterfaceName};
1157         next if (defined($tagsSeen{$JSInterfaceName}) || (usesDefaultJSWrapper($tagName) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;))) &amp;&amp; !$enabledTags{$tagName}{settingsConditional};
1158         $tagsSeen{$JSInterfaceName} = 1;
1159 
1160         my $conditional = $enabledTags{$tagName}{conditional};
1161         if ($conditional) {
1162             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1163             print F &quot;#if ${conditionalString}\n\n&quot;;
1164         }
1165 
1166         if ($enabledTags{$tagName}{wrapperOnlyIfMediaIsAvailable}) {
1167             print F &lt;&lt;END
1168 static JSDOMObject* create${JSInterfaceName}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1169 {
1170     if (element-&gt;is$parameters{fallbackInterfaceName}())
1171         return createWrapper&lt;$parameters{fallbackInterfaceName}&gt;(globalObject, WTFMove(element));
1172     return createWrapper&lt;${JSInterfaceName}&gt;(globalObject, WTFMove(element));
1173 }
1174 
1175 END
1176             ;
1177         } elsif ($enabledTags{$tagName}{settingsConditional}) {
1178             print F &lt;&lt;END
1179 static JSDOMObject* create$enabledTags{$tagName}{interfaceName}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1180 {
1181     if (element-&gt;is$parameters{fallbackInterfaceName}())
1182         return createWrapper&lt;$parameters{fallbackInterfaceName}&gt;(globalObject, WTFMove(element));
1183     return createWrapper&lt;${JSInterfaceName}&gt;(globalObject, WTFMove(element));
1184 }
1185 
1186 END
1187             ;
1188         } elsif ($enabledTags{$tagName}{runtimeEnabled}) {
1189             my $runtimeEnabled = $enabledTags{$tagName}{runtimeEnabled};
1190             print F &lt;&lt;END
1191 static JSDOMObject* create${JSInterfaceName}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1192 {
1193     if (element-&gt;is$parameters{fallbackInterfaceName}())
1194         return createWrapper&lt;$parameters{fallbackJSInterfaceName}&gt;(globalObject, WTFMove(element));
1195     return createWrapper&lt;${JSInterfaceName}&gt;(globalObject, WTFMove(element));
1196 }
1197 END
1198     ;
1199         } else {
1200             print F &lt;&lt;END
1201 static JSDOMObject* create${JSInterfaceName}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1202 {
1203     return createWrapper&lt;${JSInterfaceName}&gt;(globalObject, WTFMove(element));
1204 }
1205 
1206 END
1207     ;
1208         }
1209 
1210         if ($conditional) {
1211             print F &quot;#endif\n\n&quot;;
1212         }
1213     }
1214 }
1215 
1216 sub printWrapperFactoryCppFile
1217 {
1218     my $outputDir = shift;
1219     my $wrapperFactoryFileName = shift;
1220     my $F;
1221     open F, &quot;&gt;&quot; . $outputDir . &quot;/JS&quot; . $wrapperFactoryFileName . &quot;.cpp&quot;;
1222 
1223     printLicenseHeader($F);
1224 
1225     print F &quot;#include \&quot;config.h\&quot;\n&quot;;
1226     print F &quot;#include \&quot;JS$parameters{namespace}ElementWrapperFactory.h\&quot;\n\n&quot;;
1227 
1228     print F &quot;\n#if $parameters{guardFactoryWith}\n\n&quot; if $parameters{guardFactoryWith};
1229 
1230     printJSElementIncludes($F);
1231     printElementIncludes($F);
1232 
1233     print F &quot;\n#include \&quot;$parameters{namespace}Names.h\&quot;\n&quot;;
1234     print F &lt;&lt;END
1235 
1236 #include &quot;Document.h&quot;
1237 #include &quot;RuntimeEnabledFeatures.h&quot;
1238 #include &quot;Settings.h&quot;
1239 #include &lt;wtf/NeverDestroyed.h&gt;
1240 #include &lt;wtf/StdLibExtras.h&gt;
1241 END
1242 ;
1243 
1244     printConditionalElementIncludes($F, 1);
1245 
1246     print F &lt;&lt;END
1247 
1248 using namespace JSC;
1249 
1250 namespace WebCore {
1251 
1252 using namespace $parameters{namespace}Names;
1253 
1254 typedef JSDOMObject* (*Create$parameters{namespace}ElementWrapperFunction)(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1255 
1256 END
1257 ;
1258 
1259     printWrapperFunctions($F);
1260 
1261 print F &lt;&lt;END
1262 
<a name="17" id="anc17"></a><span class="line-modified">1263 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; create$parameters{namespace}WrapperMap()</span>
1264 {
1265     struct TableEntry {
1266         const QualifiedName&amp; name;
1267         Create$parameters{namespace}ElementWrapperFunction function;
1268     };
1269 
1270     static const TableEntry table[] = {
1271 END
1272 ;
1273 
1274     for my $tag (sort keys %enabledTags) {
1275         # Do not add the name to the map if it does not have a JS wrapper constructor or uses the default wrapper.
1276         next if (usesDefaultJSWrapper($tag, \%enabledTags) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;));
1277 
1278         my $conditional = $enabledTags{$tag}{conditional};
1279         if ($conditional) {
1280             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1281             print F &quot;#if ${conditionalString}\n&quot;;
1282         }
1283 
1284         my $ucTag;
1285         if ($enabledTags{$tag}{settingsConditional}) {
1286             $ucTag = $enabledTags{$tag}{interfaceName};
1287         } else {
1288             $ucTag = $enabledTags{$tag}{JSInterfaceName};
1289         }
1290 
1291         print F &quot;        { ${tag}Tag, create${ucTag}Wrapper },\n&quot;;
1292 
1293         if ($conditional) {
1294             print F &quot;#endif\n&quot;;
1295         }
1296     }
1297 
1298     print F &lt;&lt;END
1299     };
1300 
<a name="18" id="anc18"></a><span class="line-modified">1301     HashMap&lt;AtomicStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; map;</span>
1302     for (auto&amp; entry : table)
1303         map.add(entry.name.localName().impl(), entry.function);
1304     return map;
1305 }
1306 
1307 JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1308 {
1309     static const auto functions = makeNeverDestroyed(create$parameters{namespace}WrapperMap());
1310     if (auto function = functions.get().get(element-&gt;localName().impl()))
1311         return function(globalObject, WTFMove(element));
1312 END
1313 ;
1314 
1315     if ($parameters{customElementInterfaceName}) {
1316         print F &lt;&lt;END
1317     if (element-&gt;isCustomElementUpgradeCandidate())
1318         return createWrapper&lt;$parameters{customElementInterfaceName}&gt;(globalObject, WTFMove(element));
1319 END
1320 ;
1321     }
1322 
1323     print F &lt;&lt;END
1324     return createWrapper&lt;$parameters{fallbackJSInterfaceName}&gt;(globalObject, WTFMove(element));
1325 }
1326 
1327 }
1328 END
1329 ;
1330 
1331     print F &quot;\n#endif\n&quot; if $parameters{guardFactoryWith};
1332 
1333     close F;
1334 }
1335 
1336 sub printWrapperFactoryHeaderFile
1337 {
1338     my $outputDir = shift;
1339     my $wrapperFactoryFileName = shift;
1340     my $F;
1341     open F, &quot;&gt;&quot; . $outputDir . &quot;/JS&quot; . $wrapperFactoryFileName . &quot;.h&quot;;
1342 
1343     printLicenseHeader($F);
1344 
1345     print F &quot;#ifndef JS$parameters{namespace}ElementWrapperFactory_h\n&quot;;
1346     print F &quot;#define JS$parameters{namespace}ElementWrapperFactory_h\n\n&quot;;
1347 
1348     print F &quot;#if $parameters{guardFactoryWith}\n&quot; if $parameters{guardFactoryWith};
1349 
1350     print F &lt;&lt;END
1351 #include &lt;wtf/Forward.h&gt;
1352 
1353 namespace WebCore {
1354 
1355     class JSDOMObject;
1356     class JSDOMGlobalObject;
1357     class $parameters{namespace}Element;
1358 
1359     JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1360 
1361 }
1362  
1363 END
1364     ;
1365 
1366     print F &quot;#endif // $parameters{guardFactoryWith}\n\n&quot; if $parameters{guardFactoryWith};
1367 
1368     print F &quot;#endif // JS$parameters{namespace}ElementWrapperFactory_h\n&quot;;
1369 
1370     close F;
1371 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>