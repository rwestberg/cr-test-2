<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2009, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Position.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;Editing.h&quot;
  31 #include &quot;HTMLBRElement.h&quot;
  32 #include &quot;HTMLBodyElement.h&quot;
  33 #include &quot;HTMLHtmlElement.h&quot;
  34 #include &quot;HTMLNames.h&quot;
  35 #include &quot;HTMLParserIdioms.h&quot;
  36 #include &quot;HTMLTableElement.h&quot;
  37 #include &quot;InlineElementBox.h&quot;
  38 #include &quot;InlineIterator.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;NodeTraversal.h&quot;
  42 #include &quot;PositionIterator.h&quot;
  43 #include &quot;RenderBlock.h&quot;
  44 #include &quot;RenderFlexibleBox.h&quot;
  45 #include &quot;RenderGrid.h&quot;
  46 #include &quot;RenderInline.h&quot;
  47 #include &quot;RenderIterator.h&quot;
  48 #include &quot;RenderLineBreak.h&quot;
  49 #include &quot;RenderText.h&quot;
  50 #include &quot;RuntimeEnabledFeatures.h&quot;
  51 #include &quot;Text.h&quot;
  52 #include &quot;TextIterator.h&quot;
  53 #include &quot;VisiblePosition.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;stdio.h&gt;
  56 #include &lt;wtf/text/CString.h&gt;
  57 #include &lt;wtf/text/TextStream.h&gt;
  58 #include &lt;wtf/unicode/CharacterNames.h&gt;
  59 
  60 #if ENABLE(TREE_DEBUGGING)
  61 #include &lt;wtf/text/StringBuilder.h&gt;
  62 #endif
  63 
  64 namespace WebCore {
  65 
  66 using namespace HTMLNames;
  67 
  68 static bool hasInlineBoxWrapper(RenderObject&amp; renderer)
  69 {
  70     if (is&lt;RenderBox&gt;(renderer) &amp;&amp; downcast&lt;RenderBox&gt;(renderer).inlineBoxWrapper())
  71         return true;
  72     if (is&lt;RenderText&gt;(renderer) &amp;&amp; downcast&lt;RenderText&gt;(renderer).firstTextBox())
  73         return true;
  74     if (is&lt;RenderLineBreak&gt;(renderer) &amp;&amp; downcast&lt;RenderLineBreak&gt;(renderer).inlineBoxWrapper())
  75         return true;
  76     return false;
  77 }
  78 
  79 static Node* nextRenderedEditable(Node* node)
  80 {
  81     while ((node = nextLeafNode(node))) {
  82         RenderObject* renderer = node-&gt;renderer();
  83         if (!renderer || !node-&gt;hasEditableStyle())
  84             continue;
  85         if (hasInlineBoxWrapper(*renderer))
  86             return node;
  87     }
  88     return nullptr;
  89 }
  90 
  91 static Node* previousRenderedEditable(Node* node)
  92 {
  93     while ((node = previousLeafNode(node))) {
  94         RenderObject* renderer = node-&gt;renderer();
  95         if (!renderer || !node-&gt;hasEditableStyle())
  96             continue;
  97         if (hasInlineBoxWrapper(*renderer))
  98             return node;
  99     }
 100     return nullptr;
 101 }
 102 
 103 Position::Position(Node* anchorNode, unsigned offset, LegacyEditingPositionFlag)
 104     : m_anchorNode(anchorNode)
 105     , m_offset(offset)
 106     , m_anchorType(anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset))
 107     , m_isLegacyEditingPosition(true)
 108 {
 109     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isShadowRoot() || m_anchorNode == containerNode());
 110     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 111 }
 112 
 113 Position::Position(Node* anchorNode, AnchorType anchorType)
 114     : m_anchorNode(anchorNode)
 115     , m_offset(0)
 116     , m_anchorType(anchorType)
 117     , m_isLegacyEditingPosition(false)
 118 {
 119     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isShadowRoot() || m_anchorNode == containerNode());
 120     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 121     ASSERT(anchorType != PositionIsOffsetInAnchor);
 122     ASSERT(!((anchorType == PositionIsBeforeChildren || anchorType == PositionIsAfterChildren)
 123         &amp;&amp; (is&lt;Text&gt;(*m_anchorNode) || editingIgnoresContent(*m_anchorNode))));
 124 }
 125 
 126 Position::Position(Node* anchorNode, int offset, AnchorType anchorType)
 127     : m_anchorNode(anchorNode)
 128     , m_offset(offset)
 129     , m_anchorType(anchorType)
 130     , m_isLegacyEditingPosition(false)
 131 {
 132     ASSERT(!m_anchorNode || !editingIgnoresContent(*m_anchorNode));
 133     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 134     ASSERT(anchorType == PositionIsOffsetInAnchor);
 135 }
 136 
 137 Position::Position(Text* textNode, unsigned offset)
 138     : m_anchorNode(textNode)
 139     , m_offset(offset)
 140     , m_anchorType(PositionIsOffsetInAnchor)
 141     , m_isLegacyEditingPosition(false)
 142 {
 143     ASSERT(m_anchorNode);
 144 }
 145 
 146 void Position::moveToPosition(Node* node, int offset)
 147 {
 148     ASSERT(!editingIgnoresContent(*node));
 149     ASSERT(anchorType() == PositionIsOffsetInAnchor || m_isLegacyEditingPosition);
 150     m_anchorNode = node;
 151     m_offset = offset;
 152     if (m_isLegacyEditingPosition)
 153         m_anchorType = anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset);
 154 }
 155 void Position::moveToOffset(int offset)
 156 {
 157     ASSERT(anchorType() == PositionIsOffsetInAnchor || m_isLegacyEditingPosition);
 158     m_offset = offset;
 159     if (m_isLegacyEditingPosition)
 160         m_anchorType = anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset);
 161 }
 162 
 163 Node* Position::containerNode() const
 164 {
 165     if (!m_anchorNode)
 166         return nullptr;
 167 
 168     switch (anchorType()) {
 169     case PositionIsBeforeChildren:
 170     case PositionIsAfterChildren:
 171     case PositionIsOffsetInAnchor:
 172         return m_anchorNode.get();
 173     case PositionIsBeforeAnchor:
 174     case PositionIsAfterAnchor:
 175         return m_anchorNode-&gt;parentNode();
 176     }
 177     ASSERT_NOT_REACHED();
 178     return nullptr;
 179 }
 180 
 181 Text* Position::containerText() const
 182 {
 183     switch (anchorType()) {
 184     case PositionIsOffsetInAnchor:
 185         return m_anchorNode &amp;&amp; is&lt;Text&gt;(*m_anchorNode) ? downcast&lt;Text&gt;(m_anchorNode.get()) : nullptr;
 186     case PositionIsBeforeAnchor:
 187     case PositionIsAfterAnchor:
 188         return nullptr;
 189     case PositionIsBeforeChildren:
 190     case PositionIsAfterChildren:
 191         ASSERT(!m_anchorNode || !is&lt;Text&gt;(*m_anchorNode));
 192         return nullptr;
 193     }
 194     ASSERT_NOT_REACHED();
 195     return nullptr;
 196 }
 197 
 198 int Position::computeOffsetInContainerNode() const
 199 {
 200     if (!m_anchorNode)
 201         return 0;
 202 
 203     switch (anchorType()) {
 204     case PositionIsBeforeChildren:
 205         return 0;
 206     case PositionIsAfterChildren:
 207         return lastOffsetInNode(m_anchorNode.get());
 208     case PositionIsOffsetInAnchor:
 209         return minOffsetForNode(m_anchorNode.get(), m_offset);
 210     case PositionIsBeforeAnchor:
 211         return m_anchorNode-&gt;computeNodeIndex();
 212     case PositionIsAfterAnchor:
 213         return m_anchorNode-&gt;computeNodeIndex() + 1;
 214     }
 215     ASSERT_NOT_REACHED();
 216     return 0;
 217 }
 218 
 219 int Position::offsetForPositionAfterAnchor() const
 220 {
 221     ASSERT(m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren);
 222     ASSERT(!m_isLegacyEditingPosition);
 223     ASSERT(m_anchorNode);
 224     return m_anchorNode ? lastOffsetForEditing(*m_anchorNode) : 0;
 225 }
 226 
 227 // Neighbor-anchored positions are invalid DOM positions, so they need to be
 228 // fixed up before handing them off to the Range object.
 229 Position Position::parentAnchoredEquivalent() const
 230 {
 231     if (!m_anchorNode)
 232         return { };
 233 
 234     // FIXME: This should only be necessary for legacy positions, but is also needed for positions before and after Tables
 235     if (m_offset &lt;= 0 &amp;&amp; (m_anchorType != PositionIsAfterAnchor &amp;&amp; m_anchorType != PositionIsAfterChildren)) {
 236         if (m_anchorNode-&gt;parentNode() &amp;&amp; (editingIgnoresContent(*m_anchorNode) || isRenderedTable(m_anchorNode.get())))
 237             return positionInParentBeforeNode(m_anchorNode.get());
 238         return Position(m_anchorNode.get(), 0, PositionIsOffsetInAnchor);
 239     }
 240 
 241     if (!m_anchorNode-&gt;isCharacterDataNode()
 242         &amp;&amp; (m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren || static_cast&lt;unsigned&gt;(m_offset) == m_anchorNode-&gt;countChildNodes())
 243         &amp;&amp; (editingIgnoresContent(*m_anchorNode) || isRenderedTable(m_anchorNode.get()))
 244         &amp;&amp; containerNode()) {
 245         return positionInParentAfterNode(m_anchorNode.get());
 246     }
 247 
 248     return { containerNode(), computeOffsetInContainerNode(), PositionIsOffsetInAnchor };
 249 }
 250 
 251 RefPtr&lt;Node&gt; Position::firstNode() const
 252 {
 253     auto container = makeRefPtr(containerNode());
 254     if (!container)
 255         return nullptr;
 256     if (is&lt;CharacterData&gt;(*container))
 257         return container;
 258     if (auto* node = computeNodeAfterPosition())
 259         return node;
 260     if (!computeOffsetInContainerNode())
 261         return container;
 262     return NodeTraversal::nextSkippingChildren(*container);
 263 }
 264 
 265 Node* Position::computeNodeBeforePosition() const
 266 {
 267     if (!m_anchorNode)
 268         return nullptr;
 269 
 270     switch (anchorType()) {
 271     case PositionIsBeforeChildren:
 272         return nullptr;
 273     case PositionIsAfterChildren:
 274         return m_anchorNode-&gt;lastChild();
 275     case PositionIsOffsetInAnchor:
 276         return m_offset ? m_anchorNode-&gt;traverseToChildAt(m_offset - 1) : nullptr;
 277     case PositionIsBeforeAnchor:
 278         return m_anchorNode-&gt;previousSibling();
 279     case PositionIsAfterAnchor:
 280         return m_anchorNode.get();
 281     }
 282     ASSERT_NOT_REACHED();
 283     return nullptr;
 284 }
 285 
 286 Node* Position::computeNodeAfterPosition() const
 287 {
 288     if (!m_anchorNode)
 289         return nullptr;
 290 
 291     switch (anchorType()) {
 292     case PositionIsBeforeChildren:
 293         return m_anchorNode-&gt;firstChild();
 294     case PositionIsAfterChildren:
 295         return nullptr;
 296     case PositionIsOffsetInAnchor:
 297         return m_anchorNode-&gt;traverseToChildAt(m_offset);
 298     case PositionIsBeforeAnchor:
 299         return m_anchorNode.get();
 300     case PositionIsAfterAnchor:
 301         return m_anchorNode-&gt;nextSibling();
 302     }
 303     ASSERT_NOT_REACHED();
 304     return nullptr;
 305 }
 306 
 307 Position::AnchorType Position::anchorTypeForLegacyEditingPosition(Node* anchorNode, int offset)
 308 {
 309     if (anchorNode &amp;&amp; editingIgnoresContent(*anchorNode)) {
 310         if (offset == 0)
 311             return Position::PositionIsBeforeAnchor;
 312         return Position::PositionIsAfterAnchor;
 313     }
 314     return Position::PositionIsOffsetInAnchor;
 315 }
 316 
 317 // FIXME: This method is confusing (does it return anchorNode() or containerNode()?) and should be renamed or removed
 318 Element* Position::element() const
 319 {
 320     Node* node = anchorNode();
 321     while (node &amp;&amp; !is&lt;Element&gt;(*node))
 322         node = node-&gt;parentNode();
 323     return downcast&lt;Element&gt;(node);
 324 }
 325 
 326 Position Position::previous(PositionMoveType moveType) const
 327 {
 328     Node* node = deprecatedNode();
 329     if (!node)
 330         return *this;
 331 
 332     int offset = deprecatedEditingOffset();
 333     // FIXME: Negative offsets shouldn&#39;t be allowed. We should catch this earlier.
 334     ASSERT(offset &gt;= 0);
 335 
 336     if (anchorType() == PositionIsBeforeAnchor) {
 337         node = containerNode();
 338         if (!node)
 339             return *this;
 340 
 341         offset = computeOffsetInContainerNode();
 342     }
 343 
 344     if (offset &gt; 0) {
 345         if (Node* child = node-&gt;traverseToChildAt(offset - 1))
 346             return lastPositionInOrAfterNode(child);
 347 
 348         // There are two reasons child might be 0:
 349         //   1) The node is node like a text node that is not an element, and therefore has no children.
 350         //      Going backward one character at a time is correct.
 351         //   2) The old offset was a bogus offset like (&lt;br&gt;, 1), and there is no child.
 352         //      Going from 1 to 0 is correct.
 353         switch (moveType) {
 354         case CodePoint:
 355             return createLegacyEditingPosition(node, offset - 1);
 356         case Character:
 357             return createLegacyEditingPosition(node, uncheckedPreviousOffset(node, offset));
 358         case BackwardDeletion:
 359             return createLegacyEditingPosition(node, uncheckedPreviousOffsetForBackwardDeletion(node, offset));
 360         }
 361     }
 362 
 363     ContainerNode* parent = node-&gt;parentNode();
 364     if (!parent)
 365         return *this;
 366 
 367     if (positionBeforeOrAfterNodeIsCandidate(*node))
 368         return positionBeforeNode(node);
 369 
 370     Node* previousSibling = node-&gt;previousSibling();
 371     if (previousSibling &amp;&amp; positionBeforeOrAfterNodeIsCandidate(*previousSibling))
 372         return positionAfterNode(previousSibling);
 373 
 374     return createLegacyEditingPosition(parent, node-&gt;computeNodeIndex());
 375 }
 376 
 377 Position Position::next(PositionMoveType moveType) const
 378 {
 379     ASSERT(moveType != BackwardDeletion);
 380 
 381     Node* node = deprecatedNode();
 382     if (!node)
 383         return *this;
 384 
 385     int offset = deprecatedEditingOffset();
 386     // FIXME: Negative offsets shouldn&#39;t be allowed. We should catch this earlier.
 387     ASSERT(offset &gt;= 0);
 388 
 389     if (anchorType() == PositionIsAfterAnchor) {
 390         node = containerNode();
 391         if (!node)
 392             return *this;
 393 
 394         offset = computeOffsetInContainerNode();
 395     }
 396 
 397     Node* child = node-&gt;traverseToChildAt(offset);
 398     if (child || (!node-&gt;hasChildNodes() &amp;&amp; offset &lt; lastOffsetForEditing(*node))) {
 399         if (child)
 400             return firstPositionInOrBeforeNode(child);
 401 
 402         // There are two reasons child might be 0:
 403         //   1) The node is node like a text node that is not an element, and therefore has no children.
 404         //      Going forward one character at a time is correct.
 405         //   2) The new offset is a bogus offset like (&lt;br&gt;, 1), and there is no child.
 406         //      Going from 0 to 1 is correct.
 407         return createLegacyEditingPosition(node, (moveType == Character) ? uncheckedNextOffset(node, offset) : offset + 1);
 408     }
 409 
 410     ContainerNode* parent = node-&gt;parentNode();
 411     if (!parent)
 412         return *this;
 413 
 414     if (isRenderedTable(node) || editingIgnoresContent(*node))
 415         return positionAfterNode(node);
 416 
 417     Node* nextSibling = node-&gt;nextSibling();
 418     if (nextSibling &amp;&amp; positionBeforeOrAfterNodeIsCandidate(*nextSibling))
 419         return positionBeforeNode(nextSibling);
 420 
 421     return createLegacyEditingPosition(parent, node-&gt;computeNodeIndex() + 1);
 422 }
 423 
 424 int Position::uncheckedPreviousOffset(const Node* n, int current)
 425 {
 426     return n-&gt;renderer() ? n-&gt;renderer()-&gt;previousOffset(current) : current - 1;
 427 }
 428 
 429 int Position::uncheckedPreviousOffsetForBackwardDeletion(const Node* n, int current)
 430 {
 431     return n-&gt;renderer() ? n-&gt;renderer()-&gt;previousOffsetForBackwardDeletion(current) : current - 1;
 432 }
 433 
 434 int Position::uncheckedNextOffset(const Node* n, int current)
 435 {
 436     return n-&gt;renderer() ? n-&gt;renderer()-&gt;nextOffset(current) : current + 1;
 437 }
 438 
 439 bool Position::atFirstEditingPositionForNode() const
 440 {
 441     if (isNull())
 442         return true;
 443     // FIXME: Position before anchor shouldn&#39;t be considered as at the first editing position for node
 444     // since that position resides outside of the node.
 445     switch (m_anchorType) {
 446     case PositionIsOffsetInAnchor:
 447         return m_offset &lt;= 0;
 448     case PositionIsBeforeChildren:
 449     case PositionIsBeforeAnchor:
 450         return true;
 451     case PositionIsAfterChildren:
 452     case PositionIsAfterAnchor:
 453         return !lastOffsetForEditing(*deprecatedNode());
 454     }
 455     ASSERT_NOT_REACHED();
 456     return false;
 457 }
 458 
 459 bool Position::atLastEditingPositionForNode() const
 460 {
 461     if (isNull())
 462         return true;
 463     // FIXME: Position after anchor shouldn&#39;t be considered as at the first editing position for node
 464     // since that position resides outside of the node.
 465     return m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren || m_offset &gt;= lastOffsetForEditing(*deprecatedNode());
 466 }
 467 
 468 // A position is considered at editing boundary if one of the following is true:
 469 // 1. It is the first position in the node and the next visually equivalent position
 470 //    is non editable.
 471 // 2. It is the last position in the node and the previous visually equivalent position
 472 //    is non editable.
 473 // 3. It is an editable position and both the next and previous visually equivalent
 474 //    positions are both non editable.
 475 bool Position::atEditingBoundary() const
 476 {
 477     Position nextPosition = downstream(CanCrossEditingBoundary);
 478     if (atFirstEditingPositionForNode() &amp;&amp; nextPosition.isNotNull() &amp;&amp; !nextPosition.deprecatedNode()-&gt;hasEditableStyle())
 479         return true;
 480 
 481     Position prevPosition = upstream(CanCrossEditingBoundary);
 482     if (atLastEditingPositionForNode() &amp;&amp; prevPosition.isNotNull() &amp;&amp; !prevPosition.deprecatedNode()-&gt;hasEditableStyle())
 483         return true;
 484 
 485     return nextPosition.isNotNull() &amp;&amp; !nextPosition.deprecatedNode()-&gt;hasEditableStyle()
 486         &amp;&amp; prevPosition.isNotNull() &amp;&amp; !prevPosition.deprecatedNode()-&gt;hasEditableStyle();
 487 }
 488 
 489 Node* Position::parentEditingBoundary() const
 490 {
 491     if (!m_anchorNode)
 492         return nullptr;
 493 
 494     Node* documentElement = m_anchorNode-&gt;document().documentElement();
 495     if (!documentElement)
 496         return nullptr;
 497 
 498     Node* boundary = m_anchorNode.get();
 499     while (boundary != documentElement &amp;&amp; boundary-&gt;nonShadowBoundaryParentNode() &amp;&amp; m_anchorNode-&gt;hasEditableStyle() == boundary-&gt;parentNode()-&gt;hasEditableStyle())
 500         boundary = boundary-&gt;nonShadowBoundaryParentNode();
 501 
 502     return boundary;
 503 }
 504 
 505 
 506 bool Position::atStartOfTree() const
 507 {
 508     if (isNull())
 509         return true;
 510 
 511     Node* container = containerNode();
 512     if (container &amp;&amp; container-&gt;parentNode())
 513         return false;
 514 
 515     switch (m_anchorType) {
 516     case PositionIsOffsetInAnchor:
 517         return m_offset &lt;= 0;
 518     case PositionIsBeforeAnchor:
 519         return !m_anchorNode-&gt;previousSibling();
 520     case PositionIsAfterAnchor:
 521         return false;
 522     case PositionIsBeforeChildren:
 523         return true;
 524     case PositionIsAfterChildren:
 525         return !lastOffsetForEditing(*m_anchorNode);
 526     }
 527     ASSERT_NOT_REACHED();
 528     return false;
 529 }
 530 
 531 bool Position::atEndOfTree() const
 532 {
 533     if (isNull())
 534         return true;
 535 
 536     Node* container = containerNode();
 537     if (container &amp;&amp; container-&gt;parentNode())
 538         return false;
 539 
 540     switch (m_anchorType) {
 541     case PositionIsOffsetInAnchor:
 542         return m_offset &gt;= lastOffsetForEditing(*m_anchorNode);
 543     case PositionIsBeforeAnchor:
 544         return false;
 545     case PositionIsAfterAnchor:
 546         return !m_anchorNode-&gt;nextSibling();
 547     case PositionIsBeforeChildren:
 548         return !lastOffsetForEditing(*m_anchorNode);
 549     case PositionIsAfterChildren:
 550         return true;
 551     }
 552     ASSERT_NOT_REACHED();
 553     return false;
 554 }
 555 
 556 // return first preceding DOM position rendered at a different location, or &quot;this&quot;
 557 Position Position::previousCharacterPosition(EAffinity affinity) const
 558 {
 559     if (isNull())
 560         return { };
 561 
 562     Node* fromRootEditableElement = deprecatedNode()-&gt;rootEditableElement();
 563 
 564     bool atStartOfLine = isStartOfLine(VisiblePosition(*this, affinity));
 565     bool rendered = isCandidate();
 566 
 567     Position currentPosition = *this;
 568     while (!currentPosition.atStartOfTree()) {
 569         currentPosition = currentPosition.previous();
 570 
 571         if (currentPosition.deprecatedNode()-&gt;rootEditableElement() != fromRootEditableElement)
 572             return *this;
 573 
 574         if (atStartOfLine || !rendered) {
 575             if (currentPosition.isCandidate())
 576                 return currentPosition;
 577         } else if (rendersInDifferentPosition(currentPosition))
 578             return currentPosition;
 579     }
 580 
 581     return *this;
 582 }
 583 
 584 // return first following position rendered at a different location, or &quot;this&quot;
 585 Position Position::nextCharacterPosition(EAffinity affinity) const
 586 {
 587     if (isNull())
 588         return { };
 589 
 590     Node* fromRootEditableElement = deprecatedNode()-&gt;rootEditableElement();
 591 
 592     bool atEndOfLine = isEndOfLine({ *this, affinity });
 593     bool rendered = isCandidate();
 594 
 595     Position currentPosition = *this;
 596     while (!currentPosition.atEndOfTree()) {
 597         currentPosition = currentPosition.next();
 598 
 599         if (currentPosition.deprecatedNode()-&gt;rootEditableElement() != fromRootEditableElement)
 600             return *this;
 601 
 602         if (atEndOfLine || !rendered) {
 603             if (currentPosition.isCandidate())
 604                 return currentPosition;
 605         } else if (rendersInDifferentPosition(currentPosition))
 606             return currentPosition;
 607     }
 608 
 609     return *this;
 610 }
 611 
 612 // Whether or not [node, 0] and [node, lastOffsetForEditing(node)] are their own VisiblePositions.
 613 // If true, adjacent candidates are visually distinct.
 614 // FIXME: Disregard nodes with renderers that have no height, as we do in isCandidate.
 615 // FIXME: Share code with isCandidate, if possible.
 616 static bool endsOfNodeAreVisuallyDistinctPositions(Node* node)
 617 {
 618     if (!node || !node-&gt;renderer())
 619         return false;
 620 
 621     if (!node-&gt;renderer()-&gt;isInline())
 622         return true;
 623 
 624     // Don&#39;t include inline tables.
 625     if (is&lt;HTMLTableElement&gt;(*node))
 626         return false;
 627 
 628     if (!node-&gt;renderer()-&gt;isReplaced() || !canHaveChildrenForEditing(*node) || !downcast&lt;RenderBox&gt;(*node-&gt;renderer()).height())
 629         return false;
 630 
 631     // There is a VisiblePosition inside an empty inline-block container.
 632     if (!node-&gt;hasChildNodes())
 633         return true;
 634 
 635     return !Position::hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderElement&gt;(*node-&gt;renderer()));
 636 }
 637 
 638 static Node* enclosingVisualBoundary(Node* node)
 639 {
 640     while (node &amp;&amp; !endsOfNodeAreVisuallyDistinctPositions(node))
 641         node = node-&gt;parentNode();
 642 
 643     return node;
 644 }
 645 
 646 // upstream() and downstream() want to return positions that are either in a
 647 // text node or at just before a non-text node.  This method checks for that.
 648 static bool isStreamer(const PositionIterator&amp; pos)
 649 {
 650     if (!pos.node())
 651         return true;
 652 
 653     if (isAtomicNode(pos.node()))
 654         return true;
 655 
 656     return pos.atStartOfNode();
 657 }
 658 
 659 static void ensureLineBoxesIfNeeded(RenderObject&amp; renderer)
 660 {
 661     if (!is&lt;RenderText&gt;(renderer) &amp;&amp; !is&lt;RenderLineBreak&gt;(renderer))
 662         return;
 663     is&lt;RenderText&gt;(renderer) ? downcast&lt;RenderText&gt;(renderer).ensureLineBoxes() : downcast&lt;RenderLineBreak&gt;(renderer).ensureLineBoxes();
 664 }
 665 
 666 // This function and downstream() are used for moving back and forth between visually equivalent candidates.
 667 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 668 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the left candidate
 669 // and downstream() will return the right one.
 670 // Also, upstream() will return [boundary, 0] for any of the positions from [boundary, 0] to the first candidate
 671 // in boundary, where endsOfNodeAreVisuallyDistinctPositions(boundary) is true.
 672 Position Position::upstream(EditingBoundaryCrossingRule rule) const
 673 {
 674     Node* startNode = deprecatedNode();
 675     if (!startNode)
 676         return { };
 677 
 678     // iterate backward from there, looking for a qualified position
 679     Node* boundary = enclosingVisualBoundary(startNode);
 680     // FIXME: PositionIterator should respect Before and After positions.
 681     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 682     PositionIterator currentPosition = lastVisible;
 683     bool startEditable = startNode-&gt;hasEditableStyle();
 684     Node* lastNode = startNode;
 685     bool boundaryCrossed = false;
 686     for (; !currentPosition.atStart(); currentPosition.decrement()) {
 687         auto&amp; currentNode = *currentPosition.node();
 688 
 689         // Don&#39;t check for an editability change if we haven&#39;t moved to a different node,
 690         // to avoid the expense of computing hasEditableStyle().
 691         if (&amp;currentNode != lastNode) {
 692             // Don&#39;t change editability.
 693             bool currentEditable = currentNode.hasEditableStyle();
 694             if (startEditable != currentEditable) {
 695                 if (rule == CannotCrossEditingBoundary)
 696                     break;
 697                 boundaryCrossed = true;
 698             }
 699             lastNode = &amp;currentNode;
 700         }
 701 
 702         // If we&#39;ve moved to a position that is visually distinct, return the last saved position. There
 703         // is code below that terminates early if we&#39;re *about* to move to a visually distinct position.
 704         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 705             return lastVisible;
 706 
 707         // skip position in unrendered or invisible node
 708         RenderObject* renderer = currentNode.renderer();
 709         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 710             continue;
 711         ensureLineBoxesIfNeeded(*renderer);
 712         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 713             lastVisible = currentPosition;
 714             break;
 715         }
 716 
 717         // track last visible streamer position
 718         if (isStreamer(currentPosition))
 719             lastVisible = currentPosition;
 720 
 721         // Don&#39;t move past a position that is visually distinct.  We could rely on code above to terminate and
 722         // return lastVisible on the next iteration, but we terminate early to avoid doing a computeNodeIndex() call.
 723         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; currentPosition.atStartOfNode())
 724             return lastVisible;
 725 
 726         // Return position after tables and nodes which have content that can be ignored.
 727         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 728             if (currentPosition.atEndOfNode())
 729                 return positionAfterNode(&amp;currentNode);
 730             continue;
 731         }
 732 
 733         // return current position if it is in rendered text
 734         if (is&lt;RenderText&gt;(*renderer)) {
 735             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
 736             if (!textRenderer.firstTextBox())
 737                 continue;
 738             if (&amp;currentNode != startNode) {
 739                 // This assertion fires in layout tests in the case-transform.html test because
 740                 // of a mix-up between offsets in the text in the DOM tree with text in the
 741                 // render tree which can have a different length due to case transformation.
 742                 // Until we resolve that, disable this so we can run the layout tests!
 743                 //ASSERT(currentOffset &gt;= renderer-&gt;caretMaxOffset());
 744                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMaxOffset());
 745             }
 746 
 747             unsigned textOffset = currentPosition.offsetInLeafNode();
 748             auto lastTextBox = textRenderer.lastTextBox();
 749             for (auto* box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
 750                 if (textOffset &lt;= box-&gt;start() + box-&gt;len()) {
 751                     if (textOffset &gt; box-&gt;start())
 752                         return currentPosition;
 753                     continue;
 754                 }
 755 
 756                 if (box == lastTextBox || textOffset != box-&gt;start() + box-&gt;len() + 1)
 757                     continue;
 758 
 759                 // The text continues on the next line only if the last text box is not on this line and
 760                 // none of the boxes on this line have a larger start offset.
 761 
 762                 bool continuesOnNextLine = true;
 763                 InlineBox* otherBox = box;
 764                 while (continuesOnNextLine) {
 765                     otherBox = otherBox-&gt;nextLeafChild();
 766                     if (!otherBox)
 767                         break;
 768                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt; textOffset))
 769                         continuesOnNextLine = false;
 770                 }
 771 
 772                 otherBox = box;
 773                 while (continuesOnNextLine) {
 774                     otherBox = otherBox-&gt;prevLeafChild();
 775                     if (!otherBox)
 776                         break;
 777                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt; textOffset))
 778                         continuesOnNextLine = false;
 779                 }
 780 
 781                 if (continuesOnNextLine)
 782                     return currentPosition;
 783             }
 784         }
 785     }
 786 
 787     return lastVisible;
 788 }
 789 
 790 // This function and upstream() are used for moving back and forth between visually equivalent candidates.
 791 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 792 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the right candidate
 793 // and upstream() will return the left one.
 794 // Also, downstream() will return the last position in the last atomic node in boundary for all of the positions
 795 // in boundary after the last candidate, where endsOfNodeAreVisuallyDistinctPositions(boundary).
 796 // FIXME: This function should never be called when the line box tree is dirty. See https://bugs.webkit.org/show_bug.cgi?id=97264
 797 Position Position::downstream(EditingBoundaryCrossingRule rule) const
 798 {
 799     Node* startNode = deprecatedNode();
 800     if (!startNode)
 801         return { };
 802 
 803     // iterate forward from there, looking for a qualified position
 804     Node* boundary = enclosingVisualBoundary(startNode);
 805     // FIXME: PositionIterator should respect Before and After positions.
 806     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 807     PositionIterator currentPosition = lastVisible;
 808     bool startEditable = startNode-&gt;hasEditableStyle();
 809     Node* lastNode = startNode;
 810     bool boundaryCrossed = false;
 811     for (; !currentPosition.atEnd(); currentPosition.increment()) {
 812         auto&amp; currentNode = *currentPosition.node();
 813 
 814         // Don&#39;t check for an editability change if we haven&#39;t moved to a different node,
 815         // to avoid the expense of computing hasEditableStyle().
 816         if (&amp;currentNode != lastNode) {
 817             // Don&#39;t change editability.
 818             bool currentEditable = currentNode.hasEditableStyle();
 819             if (startEditable != currentEditable) {
 820                 if (rule == CannotCrossEditingBoundary)
 821                     break;
 822                 boundaryCrossed = true;
 823             }
 824 
 825             lastNode = &amp;currentNode;
 826         }
 827 
 828         // stop before going above the body, up into the head
 829         // return the last visible streamer position
 830         if (is&lt;HTMLBodyElement&gt;(currentNode) &amp;&amp; currentPosition.atEndOfNode())
 831             break;
 832 
 833         // Do not move to a visually distinct position.
 834         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 835             return lastVisible;
 836         // Do not move past a visually disinct position.
 837         // Note: The first position after the last in a node whose ends are visually distinct
 838         // positions will be [boundary-&gt;parentNode(), originalBlock-&gt;computeNodeIndex() + 1].
 839         if (boundary &amp;&amp; boundary-&gt;parentNode() == &amp;currentNode)
 840             return lastVisible;
 841 
 842         // skip position in unrendered or invisible node
 843         auto* renderer = currentNode.renderer();
 844         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 845             continue;
 846         ensureLineBoxesIfNeeded(*renderer);
 847         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 848             lastVisible = currentPosition;
 849             break;
 850         }
 851 
 852         // track last visible streamer position
 853         if (isStreamer(currentPosition))
 854             lastVisible = currentPosition;
 855 
 856         // Return position before tables and nodes which have content that can be ignored.
 857         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 858             if (currentPosition.atStartOfNode())
 859                 return positionBeforeNode(&amp;currentNode);
 860             continue;
 861         }
 862 
 863         // return current position if it is in rendered text
 864         if (is&lt;RenderText&gt;(*renderer)) {
 865             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
 866             if (!textRenderer.firstTextBox())
 867                 continue;
 868             if (&amp;currentNode != startNode) {
 869                 ASSERT(currentPosition.atStartOfNode());
 870                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMinOffset());
 871             }
 872 
 873             unsigned textOffset = currentPosition.offsetInLeafNode();
 874             auto lastTextBox = textRenderer.lastTextBox();
 875             for (auto* box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
 876                 if (textOffset &lt;= box-&gt;end()) {
 877                     if (textOffset &gt;= box-&gt;start())
 878                         return currentPosition;
 879                     continue;
 880                 }
 881 
 882                 if (box == lastTextBox || textOffset != box-&gt;start() + box-&gt;len())
 883                     continue;
 884 
 885                 // The text continues on the next line only if the last text box is not on this line and
 886                 // none of the boxes on this line have a larger start offset.
 887 
 888                 bool continuesOnNextLine = true;
 889                 InlineBox* otherBox = box;
 890                 while (continuesOnNextLine) {
 891                     otherBox = otherBox-&gt;nextLeafChild();
 892                     if (!otherBox)
 893                         break;
 894                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt;= textOffset))
 895                         continuesOnNextLine = false;
 896                 }
 897 
 898                 otherBox = box;
 899                 while (continuesOnNextLine) {
 900                     otherBox = otherBox-&gt;prevLeafChild();
 901                     if (!otherBox)
 902                         break;
 903                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt;= textOffset))
 904                         continuesOnNextLine = false;
 905                 }
 906 
 907                 if (continuesOnNextLine)
 908                     return currentPosition;
 909             }
 910         }
 911     }
 912 
 913     return lastVisible;
 914 }
 915 
 916 unsigned Position::positionCountBetweenPositions(const Position&amp; a, const Position&amp; b)
 917 {
 918     if (a.isNull() || b.isNull())
 919         return UINT_MAX;
 920 
 921     Position endPos;
 922     Position pos;
 923     if (a &gt; b) {
 924         endPos = a;
 925         pos = b;
 926     } else if (a &lt; b) {
 927         endPos = b;
 928         pos = a;
 929     } else
 930         return 0;
 931 
 932     unsigned posCount = 0;
 933     while (!pos.atEndOfTree() &amp;&amp; pos != endPos) {
 934         pos = pos.next();
 935         ++posCount;
 936     }
 937     return posCount;
 938 }
 939 
 940 static int boundingBoxLogicalHeight(RenderObject *o, const IntRect &amp;rect)
 941 {
 942     return o-&gt;style().isHorizontalWritingMode() ? rect.height() : rect.width();
 943 }
 944 
 945 bool Position::hasRenderedNonAnonymousDescendantsWithHeight(const RenderElement&amp; renderer)
 946 {
 947     RenderObject* stop = renderer.nextInPreOrderAfterChildren();
 948     for (RenderObject* o = renderer.firstChild(); o &amp;&amp; o != stop; o = o-&gt;nextInPreOrder()) {
 949         if (!o-&gt;nonPseudoNode())
 950             continue;
 951         if (is&lt;RenderText&gt;(*o)) {
 952             if (boundingBoxLogicalHeight(o, downcast&lt;RenderText&gt;(*o).linesBoundingBox()))
 953                 return true;
 954             continue;
 955         }
 956         if (is&lt;RenderLineBreak&gt;(*o)) {
 957             if (boundingBoxLogicalHeight(o, downcast&lt;RenderLineBreak&gt;(*o).linesBoundingBox()))
 958                 return true;
 959             continue;
 960         }
 961         if (is&lt;RenderBox&gt;(*o)) {
 962             if (roundToInt(downcast&lt;RenderBox&gt;(*o).logicalHeight()))
 963                 return true;
 964             continue;
 965         }
 966         if (is&lt;RenderInline&gt;(*o)) {
 967             const RenderInline&amp; renderInline = downcast&lt;RenderInline&gt;(*o);
 968             if (isEmptyInline(renderInline) &amp;&amp; boundingBoxLogicalHeight(o, renderInline.linesBoundingBox()))
 969                 return true;
 970             continue;
 971         }
 972     }
 973     return false;
 974 }
 975 
 976 bool Position::nodeIsUserSelectNone(Node* node)
 977 {
 978     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;style().userSelect() == UserSelect::None;
 979 }
 980 
 981 #if ENABLE(USERSELECT_ALL)
 982 bool Position::nodeIsUserSelectAll(const Node* node)
 983 {
 984     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;style().userSelect() == UserSelect::All;
 985 }
 986 
 987 Node* Position::rootUserSelectAllForNode(Node* node)
 988 {
 989     if (!node || !nodeIsUserSelectAll(node))
 990         return nullptr;
 991     Node* parent = node-&gt;parentNode();
 992     if (!parent)
 993         return node;
 994 
 995     Node* candidateRoot = node;
 996     while (parent) {
 997         if (!parent-&gt;renderer()) {
 998             parent = parent-&gt;parentNode();
 999             continue;
1000         }
1001         if (!nodeIsUserSelectAll(parent))
1002             break;
1003         candidateRoot = parent;
1004         parent = candidateRoot-&gt;parentNode();
1005     }
1006     return candidateRoot;
1007 }
1008 #endif
1009 
1010 bool Position::isCandidate() const
1011 {
1012     if (isNull())
1013         return false;
1014 
1015     auto* renderer = deprecatedNode()-&gt;renderer();
1016     if (!renderer)
1017         return false;
1018 
1019     if (renderer-&gt;style().visibility() != Visibility::Visible)
1020         return false;
1021 
1022     if (renderer-&gt;isBR()) {
1023         // FIXME: The condition should be m_anchorType == PositionIsBeforeAnchor, but for now we still need to support legacy positions.
1024         return !m_offset &amp;&amp; m_anchorType != PositionIsAfterAnchor &amp;&amp; !nodeIsUserSelectNone(deprecatedNode()-&gt;parentNode());
1025     }
1026 
1027     if (is&lt;RenderText&gt;(*renderer))
1028         return !nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; downcast&lt;RenderText&gt;(*renderer).containsCaretOffset(m_offset);
1029 
1030     if (positionBeforeOrAfterNodeIsCandidate(*deprecatedNode())) {
1031         return ((atFirstEditingPositionForNode() &amp;&amp; m_anchorType == PositionIsBeforeAnchor)
1032             || (atLastEditingPositionForNode() &amp;&amp; m_anchorType == PositionIsAfterAnchor))
1033             &amp;&amp; !nodeIsUserSelectNone(deprecatedNode()-&gt;parentNode());
1034     }
1035 
1036     if (is&lt;HTMLHtmlElement&gt;(*m_anchorNode))
1037         return false;
1038 
1039     if (is&lt;RenderBlockFlow&gt;(*renderer) || is&lt;RenderGrid&gt;(*renderer) || is&lt;RenderFlexibleBox&gt;(*renderer)) {
1040         RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(*renderer);
1041         if (block.logicalHeight() || is&lt;HTMLBodyElement&gt;(*m_anchorNode) || m_anchorNode-&gt;isRootEditableElement()) {
1042             if (!Position::hasRenderedNonAnonymousDescendantsWithHeight(block))
1043                 return atFirstEditingPositionForNode() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode());
1044             return m_anchorNode-&gt;hasEditableStyle() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; atEditingBoundary();
1045         }
1046         return false;
1047     }
1048 
1049     return m_anchorNode-&gt;hasEditableStyle() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; atEditingBoundary();
1050 }
1051 
1052 bool Position::isRenderedCharacter() const
1053 {
1054     if (!is&lt;Text&gt;(deprecatedNode()))
1055         return false;
1056 
1057     RenderText* renderer = downcast&lt;Text&gt;(*deprecatedNode()).renderer();
1058     if (!renderer)
1059         return false;
1060 
1061     return renderer-&gt;containsRenderedCharacterOffset(m_offset);
1062 }
1063 
1064 static bool inSameEnclosingBlockFlowElement(Node* a, Node* b)
1065 {
1066     return a &amp;&amp; b &amp;&amp; deprecatedEnclosingBlockFlowElement(a) == deprecatedEnclosingBlockFlowElement(b);
1067 }
1068 
1069 bool Position::rendersInDifferentPosition(const Position&amp; position) const
1070 {
1071     if (isNull() || position.isNull())
1072         return false;
1073 
1074     auto* renderer = deprecatedNode()-&gt;renderer();
1075     if (!renderer)
1076         return false;
1077 
1078     auto* positionRenderer = position.deprecatedNode()-&gt;renderer();
1079     if (!positionRenderer)
1080         return false;
1081 
1082     if (renderer-&gt;style().visibility() != Visibility::Visible || positionRenderer-&gt;style().visibility() != Visibility::Visible)
1083         return false;
1084 
1085     if (deprecatedNode() == position.deprecatedNode()) {
1086         if (is&lt;HTMLBRElement&gt;(*deprecatedNode()))
1087             return false;
1088 
1089         if (m_offset == position.deprecatedEditingOffset())
1090             return false;
1091 
1092         if (!is&lt;Text&gt;(*deprecatedNode()) &amp;&amp; !is&lt;Text&gt;(*position.deprecatedNode())) {
1093             if (m_offset != position.deprecatedEditingOffset())
1094                 return true;
1095         }
1096     }
1097 
1098     if (is&lt;HTMLBRElement&gt;(*deprecatedNode()) &amp;&amp; position.isCandidate())
1099         return true;
1100 
1101     if (is&lt;HTMLBRElement&gt;(*position.deprecatedNode()) &amp;&amp; isCandidate())
1102         return true;
1103 
1104     if (!inSameEnclosingBlockFlowElement(deprecatedNode(), position.deprecatedNode()))
1105         return true;
1106 
1107     if (is&lt;RenderText&gt;(*renderer) &amp;&amp; !downcast&lt;RenderText&gt;(*renderer).containsCaretOffset(m_offset))
1108         return false;
1109 
1110     if (is&lt;RenderText&gt;(*positionRenderer) &amp;&amp; !downcast&lt;RenderText&gt;(*positionRenderer).containsCaretOffset(position.m_offset))
1111         return false;
1112 
1113     int thisRenderedOffset = is&lt;RenderText&gt;(*renderer) ? downcast&lt;RenderText&gt;(*renderer).countRenderedCharacterOffsetsUntil(m_offset) : m_offset;
1114     int positionRenderedOffset = is&lt;RenderText&gt;(*positionRenderer) ? downcast&lt;RenderText&gt;(*positionRenderer).countRenderedCharacterOffsetsUntil(position.m_offset) : position.m_offset;
1115 
1116     if (renderer == positionRenderer &amp;&amp; thisRenderedOffset == positionRenderedOffset)
1117         return false;
1118 
1119     int ignoredCaretOffset;
1120     InlineBox* b1;
1121     getInlineBoxAndOffset(DOWNSTREAM, b1, ignoredCaretOffset);
1122     InlineBox* b2;
1123     position.getInlineBoxAndOffset(DOWNSTREAM, b2, ignoredCaretOffset);
1124 
1125     LOG(Editing, &quot;renderer:               %p [%p]\n&quot;, renderer, b1);
1126     LOG(Editing, &quot;thisRenderedOffset:         %d\n&quot;, thisRenderedOffset);
1127     LOG(Editing, &quot;posRenderer:            %p [%p]\n&quot;, positionRenderer, b2);
1128     LOG(Editing, &quot;posRenderedOffset:      %d\n&quot;, positionRenderedOffset);
1129     LOG(Editing, &quot;node min/max:           %d:%d\n&quot;, caretMinOffset(*deprecatedNode()), caretMaxOffset(*deprecatedNode()));
1130     LOG(Editing, &quot;pos node min/max:       %d:%d\n&quot;, caretMinOffset(*position.deprecatedNode()), caretMaxOffset(*position.deprecatedNode()));
1131     LOG(Editing, &quot;----------------------------------------------------------------------\n&quot;);
1132 
1133     if (!b1 || !b2) {
1134         return false;
1135     }
1136 
1137     if (&amp;b1-&gt;root() != &amp;b2-&gt;root()) {
1138         return true;
1139     }
1140 
1141     if (nextRenderedEditable(deprecatedNode()) == position.deprecatedNode()
1142         &amp;&amp; thisRenderedOffset == caretMaxOffset(*deprecatedNode()) &amp;&amp; !positionRenderedOffset) {
1143         return false;
1144     }
1145 
1146     if (previousRenderedEditable(deprecatedNode()) == position.deprecatedNode()
1147         &amp;&amp; !thisRenderedOffset &amp;&amp; positionRenderedOffset == caretMaxOffset(*position.deprecatedNode())) {
1148         return false;
1149     }
1150 
1151     return true;
1152 }
1153 
1154 // This assumes that it starts in editable content.
1155 Position Position::leadingWhitespacePosition(EAffinity affinity, bool considerNonCollapsibleWhitespace) const
1156 {
1157     ASSERT(isEditablePosition(*this));
1158     if (isNull())
1159         return { };
1160 
1161     if (is&lt;HTMLBRElement&gt;(*upstream().deprecatedNode()))
1162         return { };
1163 
1164     Position prev = previousCharacterPosition(affinity);
1165     if (prev != *this &amp;&amp; inSameEnclosingBlockFlowElement(deprecatedNode(), prev.deprecatedNode()) &amp;&amp; is&lt;Text&gt;(*prev.deprecatedNode())) {
1166         UChar c = downcast&lt;Text&gt;(*prev.deprecatedNode()).data()[prev.deprecatedEditingOffset()];
1167         if (considerNonCollapsibleWhitespace ? (isHTMLSpace(c) || c == noBreakSpace) : deprecatedIsCollapsibleWhitespace(c)) {
1168             if (isEditablePosition(prev))
1169                 return prev;
1170         }
1171     }
1172 
1173     return { };
1174 }
1175 
1176 // This assumes that it starts in editable content.
1177 Position Position::trailingWhitespacePosition(EAffinity, bool considerNonCollapsibleWhitespace) const
1178 {
1179     ASSERT(isEditablePosition(*this));
1180     if (isNull())
1181         return { };
1182 
1183     VisiblePosition v(*this);
1184     UChar c = v.characterAfter();
1185     // The space must not be in another paragraph and it must be editable.
1186     if (!isEndOfParagraph(v) &amp;&amp; v.next(CannotCrossEditingBoundary).isNotNull())
1187         if (considerNonCollapsibleWhitespace ? (isHTMLSpace(c) || c == noBreakSpace) : deprecatedIsCollapsibleWhitespace(c))
1188             return *this;
1189 
1190     return { };
1191 }
1192 
1193 void Position::getInlineBoxAndOffset(EAffinity affinity, InlineBox*&amp; inlineBox, int&amp; caretOffset) const
1194 {
1195     getInlineBoxAndOffset(affinity, primaryDirection(), inlineBox, caretOffset);
1196 }
1197 
1198 static bool isNonTextLeafChild(RenderObject&amp; object)
1199 {
1200     if (is&lt;RenderText&gt;(object))
1201         return false;
1202     return !downcast&lt;RenderElement&gt;(object).firstChild();
1203 }
1204 
1205 static InlineTextBox* searchAheadForBetterMatch(RenderObject* renderer)
1206 {
1207     RenderBlock* container = renderer-&gt;containingBlock();
1208     RenderObject* next = renderer;
1209     while ((next = next-&gt;nextInPreOrder(container))) {
1210         if (is&lt;RenderBlock&gt;(*next))
1211             return nullptr;
1212         if (next-&gt;isBR())
1213             return nullptr;
1214         if (isNonTextLeafChild(*next))
1215             return nullptr;
1216         if (is&lt;RenderText&gt;(*next)) {
1217             InlineTextBox* match = nullptr;
1218             int minOffset = INT_MAX;
1219             for (InlineTextBox* box = downcast&lt;RenderText&gt;(*next).firstTextBox(); box; box = box-&gt;nextTextBox()) {
1220                 int caretMinOffset = box-&gt;caretMinOffset();
1221                 if (caretMinOffset &lt; minOffset) {
1222                     match = box;
1223                     minOffset = caretMinOffset;
1224                 }
1225             }
1226             if (match)
1227                 return match;
1228         }
1229     }
1230     return nullptr;
1231 }
1232 
1233 static Position downstreamIgnoringEditingBoundaries(Position position)
1234 {
1235     Position lastPosition;
1236     while (position != lastPosition) {
1237         lastPosition = position;
1238         position = position.downstream(CanCrossEditingBoundary);
1239     }
1240     return position;
1241 }
1242 
1243 static Position upstreamIgnoringEditingBoundaries(Position position)
1244 {
1245     Position lastPosition;
1246     while (position != lastPosition) {
1247         lastPosition = position;
1248         position = position.upstream(CanCrossEditingBoundary);
1249     }
1250     return position;
1251 }
1252 
1253 void Position::getInlineBoxAndOffset(EAffinity affinity, TextDirection primaryDirection, InlineBox*&amp; inlineBox, int&amp; caretOffset) const
1254 {
1255     caretOffset = deprecatedEditingOffset();
1256     RenderObject* renderer = deprecatedNode()-&gt;renderer();
1257 
1258     if (renderer-&gt;isBR()) {
1259         auto&amp; lineBreakRenderer = downcast&lt;RenderLineBreak&gt;(*renderer);
1260         lineBreakRenderer.ensureLineBoxes();
1261         inlineBox = !caretOffset ? lineBreakRenderer.inlineBoxWrapper() : nullptr;
1262     } else if (is&lt;RenderText&gt;(*renderer)) {
1263         auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1264         textRenderer.ensureLineBoxes();
1265 
1266         InlineTextBox* box;
1267         InlineTextBox* candidate = nullptr;
1268 
1269         for (box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
1270             int caretMinOffset = box-&gt;caretMinOffset();
1271             int caretMaxOffset = box-&gt;caretMaxOffset();
1272 
1273             if (caretOffset &lt; caretMinOffset || caretOffset &gt; caretMaxOffset || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;isLineBreak()))
1274                 continue;
1275 
1276             if (caretOffset &gt; caretMinOffset &amp;&amp; caretOffset &lt; caretMaxOffset) {
1277                 inlineBox = box;
1278                 return;
1279             }
1280 
1281             if (((caretOffset == caretMaxOffset) ^ (affinity == DOWNSTREAM))
1282                 || ((caretOffset == caretMinOffset) ^ (affinity == UPSTREAM))
1283                 || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;nextLeafChild() &amp;&amp; box-&gt;nextLeafChild()-&gt;isLineBreak()))
1284                 break;
1285 
1286             candidate = box;
1287         }
1288         if (candidate &amp;&amp; candidate == textRenderer.lastTextBox() &amp;&amp; affinity == DOWNSTREAM) {
1289             box = searchAheadForBetterMatch(&amp;textRenderer);
1290             if (box)
1291                 caretOffset = box-&gt;caretMinOffset();
1292         }
1293         inlineBox = box ? box : candidate;
1294     } else {
1295         inlineBox = nullptr;
1296         if (canHaveChildrenForEditing(*deprecatedNode()) &amp;&amp; is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderBlockFlow&gt;(*renderer))) {
1297             // Try a visually equivalent position with possibly opposite editability. This helps in case |this| is in
1298             // an editable block but surrounded by non-editable positions. It acts to negate the logic at the beginning
1299             // of RenderObject::createVisiblePosition().
1300             Position equivalent = downstreamIgnoringEditingBoundaries(*this);
1301             if (equivalent == *this) {
1302                 equivalent = upstreamIgnoringEditingBoundaries(*this);
1303                 if (equivalent == *this || downstreamIgnoringEditingBoundaries(equivalent) == *this)
1304                     return;
1305             }
1306 
1307             equivalent.getInlineBoxAndOffset(UPSTREAM, primaryDirection, inlineBox, caretOffset);
1308             return;
1309         }
1310         if (is&lt;RenderBox&gt;(*renderer)) {
1311             inlineBox = downcast&lt;RenderBox&gt;(*renderer).inlineBoxWrapper();
1312             if (!inlineBox || (caretOffset &gt; inlineBox-&gt;caretMinOffset() &amp;&amp; caretOffset &lt; inlineBox-&gt;caretMaxOffset()))
1313                 return;
1314         }
1315     }
1316 
1317     if (!inlineBox)
1318         return;
1319 
1320     unsigned char level = inlineBox-&gt;bidiLevel();
1321 
1322     if (inlineBox-&gt;direction() == primaryDirection) {
1323         if (caretOffset == inlineBox-&gt;caretRightmostOffset()) {
1324             InlineBox* nextBox = inlineBox-&gt;nextLeafChild();
1325             if (!nextBox || nextBox-&gt;bidiLevel() &gt;= level)
1326                 return;
1327 
1328             level = nextBox-&gt;bidiLevel();
1329             InlineBox* prevBox = inlineBox;
1330             do {
1331                 prevBox = prevBox-&gt;prevLeafChild();
1332             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
1333 
1334             if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
1335                 return;
1336 
1337             // For example, abc 123 ^ CBA
1338             while (InlineBox* nextBox = inlineBox-&gt;nextLeafChild()) {
1339                 if (nextBox-&gt;bidiLevel() &lt; level)
1340                     break;
1341                 inlineBox = nextBox;
1342             }
1343             caretOffset = inlineBox-&gt;caretRightmostOffset();
1344         } else {
1345             InlineBox* prevBox = inlineBox-&gt;prevLeafChild();
1346             if (!prevBox || prevBox-&gt;bidiLevel() &gt;= level)
1347                 return;
1348 
1349             level = prevBox-&gt;bidiLevel();
1350             InlineBox* nextBox = inlineBox;
1351             do {
1352                 nextBox = nextBox-&gt;nextLeafChild();
1353             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
1354 
1355             if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
1356                 return;
1357 
1358             while (InlineBox* prevBox = inlineBox-&gt;prevLeafChild()) {
1359                 if (prevBox-&gt;bidiLevel() &lt; level)
1360                     break;
1361                 inlineBox = prevBox;
1362             }
1363             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1364         }
1365         return;
1366     }
1367 
1368     if (caretOffset == inlineBox-&gt;caretLeftmostOffset()) {
1369         InlineBox* prevBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak();
1370         if (!prevBox || prevBox-&gt;bidiLevel() &lt; level) {
1371             // Left edge of a secondary run. Set to the right edge of the entire run.
1372             while (InlineBox* nextBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak()) {
1373                 if (nextBox-&gt;bidiLevel() &lt; level)
1374                     break;
1375                 inlineBox = nextBox;
1376             }
1377             caretOffset = inlineBox-&gt;caretRightmostOffset();
1378         } else if (prevBox-&gt;bidiLevel() &gt; level) {
1379             // Right edge of a &quot;tertiary&quot; run. Set to the left edge of that run.
1380             while (InlineBox* tertiaryBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak()) {
1381                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1382                     break;
1383                 inlineBox = tertiaryBox;
1384             }
1385             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1386         }
1387     } else {
1388         InlineBox* nextBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak();
1389         if (!nextBox || nextBox-&gt;bidiLevel() &lt; level) {
1390             // Right edge of a secondary run. Set to the left edge of the entire run.
1391             while (InlineBox* prevBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak()) {
1392                 if (prevBox-&gt;bidiLevel() &lt; level)
1393                     break;
1394                 inlineBox = prevBox;
1395             }
1396             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1397         } else if (nextBox-&gt;bidiLevel() &gt; level) {
1398             // Left edge of a &quot;tertiary&quot; run. Set to the right edge of that run.
1399             while (InlineBox* tertiaryBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak()) {
1400                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1401                     break;
1402                 inlineBox = tertiaryBox;
1403             }
1404             caretOffset = inlineBox-&gt;caretRightmostOffset();
1405         }
1406     }
1407 }
1408 
1409 TextDirection Position::primaryDirection() const
1410 {
1411     if (!m_anchorNode-&gt;renderer())
1412         return TextDirection::LTR;
1413     if (auto* blockFlow = lineageOfType&lt;RenderBlockFlow&gt;(*m_anchorNode-&gt;renderer()).first())
1414         return blockFlow-&gt;style().direction();
1415     return TextDirection::LTR;
1416 }
1417 
1418 #if ENABLE(TREE_DEBUGGING)
1419 
1420 void Position::debugPosition(const char* msg) const
1421 {
1422     if (isNull())
1423         fprintf(stderr, &quot;Position [%s]: null\n&quot;, msg);
1424     else
1425         fprintf(stderr, &quot;Position [%s]: %s [%p] at %d\n&quot;, msg, deprecatedNode()-&gt;nodeName().utf8().data(), deprecatedNode(), m_offset);
1426 }
1427 
1428 void Position::formatForDebugger(char* buffer, unsigned length) const
1429 {
1430     StringBuilder result;
1431 
1432     if (isNull())
1433         result.appendLiteral(&quot;&lt;null&gt;&quot;);
1434     else {
1435         char s[1024];
1436         result.appendLiteral(&quot;offset &quot;);
1437         result.appendNumber(m_offset);
1438         result.appendLiteral(&quot; of &quot;);
1439         deprecatedNode()-&gt;formatForDebugger(s, sizeof(s));
1440         result.append(s);
1441     }
1442 
1443     strncpy(buffer, result.toString().utf8().data(), length - 1);
1444 }
1445 
1446 void Position::showAnchorTypeAndOffset() const
1447 {
1448     if (m_isLegacyEditingPosition)
1449         fputs(&quot;legacy, &quot;, stderr);
1450     switch (anchorType()) {
1451     case PositionIsOffsetInAnchor:
1452         fputs(&quot;offset&quot;, stderr);
1453         break;
1454     case PositionIsBeforeChildren:
1455         fputs(&quot;beforeChildren&quot;, stderr);
1456         break;
1457     case PositionIsAfterChildren:
1458         fputs(&quot;afterChildren&quot;, stderr);
1459         break;
1460     case PositionIsBeforeAnchor:
1461         fputs(&quot;before&quot;, stderr);
1462         break;
1463     case PositionIsAfterAnchor:
1464         fputs(&quot;after&quot;, stderr);
1465         break;
1466     }
1467     fprintf(stderr, &quot;, offset:%d\n&quot;, m_offset);
1468 }
1469 
1470 void Position::showTreeForThis() const
1471 {
1472     if (anchorNode()) {
1473         anchorNode()-&gt;showTreeForThis();
1474         showAnchorTypeAndOffset();
1475     }
1476 }
1477 
1478 #endif
1479 
1480 bool Position::equals(const Position&amp; other) const
1481 {
1482     if (!m_anchorNode)
1483         return !m_anchorNode == !other.m_anchorNode;
1484     if (!other.m_anchorNode)
1485         return false;
1486 
1487     switch (anchorType()) {
1488     case PositionIsBeforeChildren:
1489         ASSERT(!is&lt;Text&gt;(*m_anchorNode));
1490         switch (other.anchorType()) {
1491         case PositionIsBeforeChildren:
1492             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1493             return m_anchorNode == other.m_anchorNode;
1494         case PositionIsAfterChildren:
1495             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1496             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_anchorNode-&gt;hasChildNodes();
1497         case PositionIsOffsetInAnchor:
1498             return m_anchorNode == other.m_anchorNode &amp;&amp; !other.m_offset;
1499         case PositionIsBeforeAnchor:
1500             return m_anchorNode-&gt;firstChild() == other.m_anchorNode;
1501         case PositionIsAfterAnchor:
1502             return false;
1503         }
1504         break;
1505     case PositionIsAfterChildren:
1506         ASSERT(!is&lt;Text&gt;(*m_anchorNode));
1507         switch (other.anchorType()) {
1508         case PositionIsBeforeChildren:
1509             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1510             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_anchorNode-&gt;hasChildNodes();
1511         case PositionIsAfterChildren:
1512             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1513             return m_anchorNode == other.m_anchorNode;
1514         case PositionIsOffsetInAnchor:
1515             return m_anchorNode == other.m_anchorNode &amp;&amp; m_anchorNode-&gt;countChildNodes() == static_cast&lt;unsigned&gt;(m_offset);
1516         case PositionIsBeforeAnchor:
1517             return false;
1518         case PositionIsAfterAnchor:
1519             return m_anchorNode-&gt;lastChild() == other.m_anchorNode;
1520         }
1521         break;
1522     case PositionIsOffsetInAnchor:
1523         switch (other.anchorType()) {
1524         case PositionIsBeforeChildren:
1525             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1526             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_offset;
1527         case PositionIsAfterChildren:
1528             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1529             return m_anchorNode == other.m_anchorNode &amp;&amp; m_offset == static_cast&lt;int&gt;(other.m_anchorNode-&gt;countChildNodes());
1530         case PositionIsOffsetInAnchor:
1531             return m_anchorNode == other.m_anchorNode &amp;&amp; m_offset == other.m_offset;
1532         case PositionIsBeforeAnchor:
1533             return m_anchorNode-&gt;traverseToChildAt(m_offset) == other.m_anchorNode;
1534         case PositionIsAfterAnchor:
1535             return m_offset &amp;&amp; m_anchorNode-&gt;traverseToChildAt(m_offset - 1) == other.m_anchorNode;
1536         }
1537         break;
1538     case PositionIsBeforeAnchor:
1539         switch (other.anchorType()) {
1540         case PositionIsBeforeChildren:
1541             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1542             return m_anchorNode == other.m_anchorNode-&gt;firstChild();
1543         case PositionIsAfterChildren:
1544             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1545             return false;
1546         case PositionIsOffsetInAnchor:
1547             return m_anchorNode == other.m_anchorNode-&gt;traverseToChildAt(other.m_offset);
1548         case PositionIsBeforeAnchor:
1549             return m_anchorNode == other.m_anchorNode;
1550         case PositionIsAfterAnchor:
1551             return m_anchorNode-&gt;previousSibling() == other.m_anchorNode;
1552         }
1553         break;
1554     case PositionIsAfterAnchor:
1555         switch (other.anchorType()) {
1556         case PositionIsBeforeChildren:
1557             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1558             return false;
1559         case PositionIsAfterChildren:
1560             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1561             return m_anchorNode == other.m_anchorNode-&gt;lastChild();
1562         case PositionIsOffsetInAnchor:
1563             return other.m_offset &amp;&amp; m_anchorNode == other.m_anchorNode-&gt;traverseToChildAt(other.m_offset - 1);
1564         case PositionIsBeforeAnchor:
1565             return m_anchorNode-&gt;nextSibling() == other.m_anchorNode;
1566         case PositionIsAfterAnchor:
1567             return m_anchorNode == other.m_anchorNode;
1568         }
1569         break;
1570     }
1571 
1572     ASSERT_NOT_REACHED();
1573     return false;
1574 }
1575 
1576 static TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, Position::AnchorType anchorType)
1577 {
1578     switch (anchorType) {
1579     case Position::PositionIsOffsetInAnchor:
1580         stream &lt;&lt; &quot;offset in anchor&quot;;
1581         break;
1582     case Position::PositionIsBeforeAnchor:
1583         stream &lt;&lt; &quot;before anchor&quot;;
1584         break;
1585     case Position::PositionIsAfterAnchor:
1586         stream &lt;&lt; &quot;after anchor&quot;;
1587         break;
1588     case Position::PositionIsBeforeChildren:
1589         stream &lt;&lt; &quot;before children&quot;;
1590         break;
1591     case Position::PositionIsAfterChildren:
1592         stream &lt;&lt; &quot;after children&quot;;
1593         break;
1594     }
1595     return stream;
1596 }
1597 
1598 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Position&amp; position)
1599 {
1600     TextStream::GroupScope scope(stream);
1601     stream &lt;&lt; &quot;Position &quot; &lt;&lt; &amp;position;
1602 
1603     stream.dumpProperty(&quot;anchor node&quot;, position.anchorNode());
1604     stream.dumpProperty(&quot;offset&quot;, position.offsetInContainerNode());
1605     stream.dumpProperty(&quot;anchor type&quot;, position.anchorType());
1606 
1607     return stream;
1608 }
1609 
1610 RefPtr&lt;Node&gt; commonShadowIncludingAncestor(const Position&amp; a, const Position&amp; b)
1611 {
1612     auto* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
1613     if (!commonScope)
1614         return nullptr;
1615     auto* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
1616     ASSERT(nodeA);
1617     auto* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
1618     ASSERT(nodeB);
1619     return Range::commonAncestorContainer(nodeA, nodeB);
1620 }
1621 
1622 } // namespace WebCore
1623 
1624 #if ENABLE(TREE_DEBUGGING)
1625 
1626 void showTree(const WebCore::Position&amp; pos)
1627 {
1628     pos.showTreeForThis();
1629 }
1630 
1631 void showTree(const WebCore::Position* pos)
1632 {
1633     if (pos)
1634         pos-&gt;showTreeForThis();
1635 }
1636 
1637 #endif
    </pre>
  </body>
</html>