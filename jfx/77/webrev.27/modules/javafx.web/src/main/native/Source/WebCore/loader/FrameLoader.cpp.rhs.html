<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
   7  * Copyright (C) 2011 Kris Jordan &lt;krisjordan@gmail.com&gt;
   8  * Copyright (C) 2011 Google Inc. All rights reserved.
   9  *
  10  * Redistribution and use in source and binary forms, with or without
  11  * modification, are permitted provided that the following conditions
  12  * are met:
  13  *
  14  * 1.  Redistributions of source code must retain the above copyright
  15  *     notice, this list of conditions and the following disclaimer.
  16  * 2.  Redistributions in binary form must reproduce the above copyright
  17  *     notice, this list of conditions and the following disclaimer in the
  18  *     documentation and/or other materials provided with the distribution.
  19  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardController.h&quot;
  41 #include &quot;BeforeUnloadEvent.h&quot;
  42 #include &quot;CachedPage.h&quot;
  43 #include &quot;CachedResourceLoader.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ContentFilter.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  48 #include &quot;ContentRuleListResults.h&quot;</span>
  49 #include &quot;ContentSecurityPolicy.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  50 #include &quot;CustomHeaderFields.h&quot;</span>
  51 #include &quot;DOMWindow.h&quot;
  52 #include &quot;DatabaseManager.h&quot;
  53 #include &quot;DiagnosticLoggingClient.h&quot;
  54 #include &quot;DiagnosticLoggingKeys.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentLoader.h&quot;
  57 #include &quot;Editor.h&quot;
  58 #include &quot;EditorClient.h&quot;
  59 #include &quot;Element.h&quot;
  60 #include &quot;Event.h&quot;
  61 #include &quot;EventHandler.h&quot;
  62 #include &quot;EventNames.h&quot;
  63 #include &quot;FloatRect.h&quot;
  64 #include &quot;FormState.h&quot;
  65 #include &quot;FormSubmission.h&quot;
  66 #include &quot;Frame.h&quot;
  67 #include &quot;FrameLoadRequest.h&quot;
  68 #include &quot;FrameLoaderClient.h&quot;
  69 #include &quot;FrameNetworkingContext.h&quot;
  70 #include &quot;FrameTree.h&quot;
  71 #include &quot;FrameView.h&quot;
  72 #include &quot;GCController.h&quot;
  73 #include &quot;HTMLFormElement.h&quot;
  74 #include &quot;HTMLInputElement.h&quot;
  75 #include &quot;HTMLNames.h&quot;
  76 #include &quot;HTMLObjectElement.h&quot;
  77 #include &quot;HTMLParserIdioms.h&quot;
  78 #include &quot;HTTPHeaderNames.h&quot;
  79 #include &quot;HTTPParsers.h&quot;
  80 #include &quot;HistoryController.h&quot;
  81 #include &quot;HistoryItem.h&quot;
  82 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  83 #include &quot;InspectorController.h&quot;
  84 #include &quot;InspectorInstrumentation.h&quot;
  85 #include &quot;LinkLoader.h&quot;
  86 #include &quot;LoadTiming.h&quot;
  87 #include &quot;LoaderStrategy.h&quot;
  88 #include &quot;Logging.h&quot;
  89 #include &quot;MemoryCache.h&quot;
  90 #include &quot;MemoryRelease.h&quot;
  91 #include &quot;NavigationDisabler.h&quot;
  92 #include &quot;NavigationScheduler.h&quot;
  93 #include &quot;Node.h&quot;
  94 #include &quot;Page.h&quot;
  95 #include &quot;PageCache.h&quot;
  96 #include &quot;PageTransitionEvent.h&quot;
  97 #include &quot;PerformanceLogging.h&quot;
  98 #include &quot;PlatformStrategies.h&quot;
  99 #include &quot;PluginData.h&quot;
 100 #include &quot;PluginDocument.h&quot;
 101 #include &quot;PolicyChecker.h&quot;
 102 #include &quot;ProgressTracker.h&quot;
 103 #include &quot;ResourceHandle.h&quot;
 104 #include &quot;ResourceLoadInfo.h&quot;
 105 #include &quot;ResourceLoadObserver.h&quot;
 106 #include &quot;ResourceRequest.h&quot;
 107 #include &quot;SVGDocument.h&quot;
 108 #include &quot;SVGLocatable.h&quot;
 109 #include &quot;SVGNames.h&quot;
 110 #include &quot;SVGViewElement.h&quot;
 111 #include &quot;SVGViewSpec.h&quot;
 112 #include &quot;ScriptController.h&quot;
 113 #include &quot;ScriptSourceCode.h&quot;
 114 #include &quot;ScrollAnimator.h&quot;
 115 #include &quot;SecurityOrigin.h&quot;
 116 #include &quot;SecurityPolicy.h&quot;
 117 #include &quot;SegmentedString.h&quot;
 118 #include &quot;SerializedScriptValue.h&quot;
 119 #include &quot;Settings.h&quot;
 120 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 121 #include &quot;StyleTreeResolver.h&quot;</span>
 122 #include &quot;SubframeLoader.h&quot;
 123 #include &quot;SubresourceLoader.h&quot;
 124 #include &quot;TextResourceDecoder.h&quot;
 125 #include &quot;UserContentController.h&quot;
 126 #include &quot;UserGestureIndicator.h&quot;
 127 #include &quot;WindowFeatures.h&quot;
 128 #include &quot;XMLDocumentParser.h&quot;
 129 #include &lt;dom/ScriptDisallowedScope.h&gt;
 130 #include &lt;wtf/CompletionHandler.h&gt;
 131 #include &lt;wtf/URL.h&gt;
 132 #include &lt;wtf/Ref.h&gt;
 133 #include &lt;wtf/SetForScope.h&gt;
 134 #include &lt;wtf/StdLibExtras.h&gt;
 135 #include &lt;wtf/SystemTracing.h&gt;
 136 #include &lt;wtf/text/CString.h&gt;
 137 #include &lt;wtf/text/WTFString.h&gt;
 138 
 139 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 140 #include &quot;Archive.h&quot;
 141 #endif
 142 
 143 #if ENABLE(DATA_DETECTION)
 144 #include &quot;DataDetection.h&quot;
 145 #endif
 146 
 147 #if PLATFORM(IOS_FAMILY)
 148 #include &quot;DocumentType.h&quot;
 149 #include &quot;ResourceLoader.h&quot;
 150 #include &quot;RuntimeApplicationChecks.h&quot;
<a name="4" id="anc4"></a>
 151 #endif
 152 
 153 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - FrameLoader::&quot; fmt, this, ##__VA_ARGS__)
 154 
 155 namespace WebCore {
 156 
 157 using namespace HTMLNames;
 158 using namespace SVGNames;
 159 
 160 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 161 
 162 bool isBackForwardLoadType(FrameLoadType type)
 163 {
 164     switch (type) {
 165     case FrameLoadType::Standard:
 166     case FrameLoadType::Reload:
 167     case FrameLoadType::ReloadFromOrigin:
 168     case FrameLoadType::ReloadExpiredOnly:
 169     case FrameLoadType::Same:
 170     case FrameLoadType::RedirectWithLockedBackForwardList:
 171     case FrameLoadType::Replace:
 172         return false;
 173     case FrameLoadType::Back:
 174     case FrameLoadType::Forward:
 175     case FrameLoadType::IndexedBackForward:
 176         return true;
 177     }
 178     ASSERT_NOT_REACHED();
 179     return false;
 180 }
 181 
 182 bool isReload(FrameLoadType type)
 183 {
 184     switch (type) {
 185     case FrameLoadType::Reload:
 186     case FrameLoadType::ReloadFromOrigin:
 187     case FrameLoadType::ReloadExpiredOnly:
 188         return true;
 189     case FrameLoadType::Standard:
 190     case FrameLoadType::Same:
 191     case FrameLoadType::RedirectWithLockedBackForwardList:
 192     case FrameLoadType::Replace:
 193     case FrameLoadType::Back:
 194     case FrameLoadType::Forward:
 195     case FrameLoadType::IndexedBackForward:
 196         return false;
 197     }
 198     ASSERT_NOT_REACHED();
 199     return false;
 200 }
 201 
 202 // This is not in the FrameLoader class to emphasize that it does not depend on
 203 // private FrameLoader data, and to avoid increasing the number of public functions
 204 // with access to private data.  Since only this .cpp file needs it, making it
 205 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 206 // API simpler.
 207 //
 208 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 209 {
 210     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 211 }
 212 
 213 struct ForbidPromptsScope {
 214     ForbidPromptsScope(Page* page) : m_page(page)
 215     {
 216         if (!m_page)
 217             return;
 218         m_page-&gt;forbidPrompts();
 219     }
 220 
 221     ~ForbidPromptsScope()
 222     {
 223         if (!m_page)
 224             return;
 225         m_page-&gt;allowPrompts();
 226     }
 227 
 228     Page* m_page;
 229 };
 230 
 231 class FrameLoader::FrameProgressTracker {
 232     WTF_MAKE_FAST_ALLOCATED;
 233 public:
 234     explicit FrameProgressTracker(Frame&amp; frame)
 235         : m_frame(frame)
 236         , m_inProgress(false)
 237     {
 238     }
 239 
 240     ~FrameProgressTracker()
 241     {
 242         if (m_inProgress &amp;&amp; m_frame.page())
 243             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 244     }
 245 
 246     void progressStarted()
 247     {
 248         ASSERT(m_frame.page());
 249         if (!m_inProgress)
 250             m_frame.page()-&gt;progress().progressStarted(m_frame);
 251         m_inProgress = true;
 252     }
 253 
 254     void progressCompleted()
 255     {
 256         ASSERT(m_inProgress);
 257         ASSERT(m_frame.page());
 258         m_inProgress = false;
 259         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 260 
 261         if (auto pageID = m_frame.loader().client().pageID())
 262             platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(pageID.value());
 263     }
 264 
 265 private:
 266     Frame&amp; m_frame;
 267     bool m_inProgress;
 268 };
 269 
 270 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 271     : m_frame(frame)
 272     , m_client(client)
<a name="5" id="anc5"></a><span class="line-modified"> 273     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))</span>
<span class="line-modified"> 274     , m_history(makeUnique&lt;HistoryController&gt;(frame))</span>
 275     , m_notifier(frame)
<a name="6" id="anc6"></a><span class="line-modified"> 276     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))</span>
 277     , m_mixedContentChecker(frame)
 278     , m_state(FrameStateProvisional)
 279     , m_loadType(FrameLoadType::Standard)
 280     , m_quickRedirectComing(false)
 281     , m_sentRedirectNotification(false)
 282     , m_inStopAllLoaders(false)
 283     , m_isExecutingJavaScriptFormAction(false)
 284     , m_didCallImplicitClose(true)
 285     , m_wasUnloadEventEmitted(false)
 286     , m_isComplete(false)
 287     , m_needsClear(false)
 288     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 289     , m_shouldCallCheckCompleted(false)
 290     , m_shouldCallCheckLoadComplete(false)
 291     , m_opener(nullptr)
 292     , m_loadingFromCachedPage(false)
 293     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 294     , m_loadsSynchronously(false)
 295     , m_forcedSandboxFlags(SandboxNone)
 296 {
 297 }
 298 
 299 FrameLoader::~FrameLoader()
 300 {
 301     setOpener(nullptr);
 302 
 303     for (auto&amp; frame : m_openedFrames)
 304         frame-&gt;loader().m_opener = nullptr;
 305 
 306     m_client.frameLoaderDestroyed();
 307 
 308     if (m_networkingContext)
 309         m_networkingContext-&gt;invalidate();
 310 }
 311 
 312 void FrameLoader::init()
 313 {
 314     // This somewhat odd set of steps gives the frame an initial empty document.
 315     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 316     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 317     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 318 
 319     Ref&lt;Frame&gt; protect(m_frame);
 320     m_frame.document()-&gt;cancelParsing();
 321     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 322 
 323     m_networkingContext = m_client.createNetworkingContext();
<a name="7" id="anc7"></a><span class="line-modified"> 324     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);</span>
 325 }
 326 
 327 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 328 {
 329     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 330     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 331 
 332     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 333     loader-&gt;attachToFrame(m_frame);
 334     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 335     loader-&gt;setCommitted(true);
 336     setDocumentLoader(loader.ptr());
 337 
 338     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 339     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 340     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 341     m_client.transitionToCommittedForNewPage();
 342 
 343     m_didCallImplicitClose = true;
 344     m_isComplete = true;
 345     m_state = FrameStateComplete;
 346     m_needsClear = true;
 347 
 348     m_networkingContext = m_client.createNetworkingContext();
<a name="8" id="anc8"></a><span class="line-modified"> 349     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);</span>
 350 }
 351 
 352 void FrameLoader::setDefersLoading(bool defers)
 353 {
 354     if (m_documentLoader)
 355         m_documentLoader-&gt;setDefersLoading(defers);
 356     if (m_provisionalDocumentLoader)
 357         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 358     if (m_policyDocumentLoader)
 359         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 360     history().setDefersLoading(defers);
 361 
 362     if (!defers) {
 363         m_frame.navigationScheduler().startTimer();
 364         startCheckCompleteTimer();
 365     }
 366 }
 367 
 368 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 369 {
 370     if (!activeDocumentLoader()) {
 371         // Load was cancelled
 372         function(PolicyAction::Ignore, identifier);
 373         return;
 374     }
 375 
 376     // FIXME: Validate the policy check identifier.
<a name="9" id="anc9"></a><span class="line-modified"> 377     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));</span>
 378 }
 379 
 380 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 381 {
 382     urlSelected(WTFMove(request), nullptr);
 383 }
 384 
<a name="10" id="anc10"></a><span class="line-modified"> 385 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)</span>
 386 {
 387     auto* frame = lexicalFrameFromCommonVM();
 388     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 389 
 390     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 391     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 392 }
 393 
 394 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 395 {
 396     RELEASE_LOG_IF_ALLOWED(&quot;urlSelected: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 397 
 398     Ref&lt;Frame&gt; protect(m_frame);
 399 
 400     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), frameRequest.shouldReplaceDocumentIfJavaScriptURL()))
 401         return;
 402 
 403     if (frameRequest.frameName().isEmpty())
 404         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 405 
 406     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 407     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 408 
 409     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 410 }
 411 
 412 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 413 {
 414     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 415 
 416     // FIXME: Find a good spot for these.
 417     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 418 
 419     if (!m_frame.page())
 420         return;
 421 
 422     if (submission-&gt;action().isEmpty())
 423         return;
 424 
 425     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 426         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 427         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 428         return;
 429     }
 430 
 431     if (WTF::protocolIsJavaScript(submission-&gt;action())) {
 432         if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(URL(submission-&gt;action())))
 433             return;
 434         m_isExecutingJavaScriptFormAction = true;
 435         Ref&lt;Frame&gt; protect(m_frame);
 436         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), DoNotReplaceDocumentIfJavaScriptURL);
 437         m_isExecutingJavaScriptFormAction = false;
 438         return;
 439     }
 440 
 441     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 442     if (!targetFrame) {
 443         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 444             return;
 445 
 446         // FIXME: targetFrame can be null for two distinct reasons:
 447         // 1. The frame was not found by name, so we should try opening a new window.
 448         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 449         // Continuing form submission makes no sense in the latter case.
 450         // There is a repeat check after timer fires, so this is not a correctness issue.
 451 
 452         targetFrame = &amp;m_frame;
 453     } else
 454         submission-&gt;clearTarget();
 455 
 456     if (!targetFrame-&gt;page())
 457         return;
 458 
 459     // FIXME: We&#39;d like to remove this altogether and fix the multiple form submission issue another way.
 460 
 461     // We do not want to submit more than one form from the same page, nor do we want to submit a single
 462     // form more than once. This flag prevents these from happening; not sure how other browsers prevent this.
 463     // The flag is reset in each time we start dispatching a new mouse or key down event, and
 464     // also in setView since this part may get reused for a page from the back/forward cache.
 465     // The form multi-submit logic here is only needed when we are submitting a form that affects this frame.
 466 
 467     // FIXME: Frame targeting is only one of the ways the submission could end up doing something other
 468     // than replacing this frame&#39;s content, so this check is flawed. On the other hand, the check is hardly
 469     // needed any more now that we reset m_submittedFormURL on each mouse or key down event.
 470 
 471     if (m_frame.tree().isDescendantOf(targetFrame)) {
 472         if (m_submittedFormURL == submission-&gt;requestURL())
 473             return;
 474         m_submittedFormURL = submission-&gt;requestURL();
 475     }
 476 
<a name="11" id="anc11"></a>
 477     submission-&gt;setReferrer(outgoingReferrer());
 478     submission-&gt;setOrigin(outgoingOrigin());
 479 
 480     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 481 }
 482 
 483 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 484 {
 485     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 486         m_frame.document()-&gt;parser()-&gt;stopParsing();
 487 
 488     if (unloadEventPolicy != UnloadEventPolicyNone)
 489         dispatchUnloadEvents(unloadEventPolicy);
 490 
 491     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 492     m_didCallImplicitClose = true; // don&#39;t want that one either
 493 
 494     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 495         finishedParsing();
 496         m_frame.document()-&gt;setParsing(false);
 497     }
 498 
 499     if (auto* document = m_frame.document()) {
<a name="12" id="anc12"></a>



 500         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 501         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 502     }
 503 
 504     policyChecker().stopCheck();
 505 
 506     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 507     m_frame.navigationScheduler().cancel();
 508 }
 509 
 510 void FrameLoader::stop()
 511 {
 512     // http://bugs.webkit.org/show_bug.cgi?id=10854
 513     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 514     Ref&lt;Frame&gt; protect(m_frame);
 515 
 516     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 517         parser-&gt;stopParsing();
 518         parser-&gt;finish();
 519     }
 520 }
 521 
 522 void FrameLoader::willTransitionToCommitted()
 523 {
 524     // This function is called when a frame is still fully in place (not cached, not detached), but will be replaced.
 525 
 526     if (m_frame.editor().hasComposition()) {
 527         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 528         m_frame.editor().confirmComposition();
 529         if (EditorClient* editorClient = m_frame.editor().client()) {
 530             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 531             editorClient-&gt;discardedComposition(&amp;m_frame);
 532         }
 533     }
 534 }
 535 
 536 bool FrameLoader::closeURL()
 537 {
 538     history().saveDocumentState();
 539 
 540     Document* currentDocument = m_frame.document();
 541     UnloadEventPolicy unloadEventPolicy;
 542     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 543         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 544         unloadEventPolicy = UnloadEventPolicyNone;
 545     } else {
 546         // Should only send the pagehide event here if the current document exists and has not been placed in the page cache.
 547         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;pageCacheState() == Document::NotInPageCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;
 548     }
 549 
 550     stopLoading(unloadEventPolicy);
 551 
 552     m_frame.editor().clearUndoRedoOperations();
 553     return true;
 554 }
 555 
 556 bool FrameLoader::didOpenURL()
 557 {
 558     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 559         // A redirect was scheduled before the document was created.
 560         // This can happen when one frame changes another frame&#39;s location.
 561         return false;
 562     }
 563 
 564     m_frame.navigationScheduler().cancel();
 565     m_frame.editor().clearLastEditCommand();
 566 
 567     m_isComplete = false;
 568     m_didCallImplicitClose = false;
 569 
 570     // If we are still in the process of initializing an empty document then
 571     // its frame is not in a consistent state for rendering, so avoid setJSStatusBarText
 572     // since it may cause clients to attempt to render the frame.
 573     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 574         DOMWindow* window = m_frame.document()-&gt;domWindow();
 575         window-&gt;setStatus(String());
 576         window-&gt;setDefaultStatus(String());
 577     }
 578 
 579     started();
 580 
 581     return true;
 582 }
 583 
 584 void FrameLoader::didExplicitOpen()
 585 {
 586     m_isComplete = false;
 587     m_didCallImplicitClose = false;
 588 
 589     // Calling document.open counts as committing the first real document load.
 590     if (!m_stateMachine.committedFirstRealDocumentLoad())
 591         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 592 
<a name="13" id="anc13"></a><span class="line-added"> 593     m_client.dispatchDidExplicitOpen(m_frame.document() ? m_frame.document()-&gt;url() : URL());</span>
<span class="line-added"> 594 </span>
 595     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 596     // from a subsequent window.document.open / window.document.write call.
 597     // Canceling redirection here works for all cases because document.open
 598     // implicitly precedes document.write.
 599     m_frame.navigationScheduler().cancel();
 600 }
 601 
 602 
 603 void FrameLoader::cancelAndClear()
 604 {
 605     m_frame.navigationScheduler().cancel();
 606 
 607     if (!m_isComplete)
 608         closeURL();
 609 
 610     clear(m_frame.document(), false);
 611     m_frame.script().updatePlatformScriptObjects();
 612 }
 613 
 614 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 615 {
 616     if (!frame.isMainFrame())
 617         return false;
 618 
 619     if (frame.loader().opener())
 620         return false;
 621 
 622     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 623 }
 624 
<a name="14" id="anc14"></a><span class="line-modified"> 625 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)</span>
 626 {
 627     m_frame.editor().clear();
 628 
<a name="15" id="anc15"></a><span class="line-modified"> 629     bool neededClear = m_needsClear;</span>

 630     m_needsClear = false;
 631 
<a name="16" id="anc16"></a><span class="line-modified"> 632     if (neededClear &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
 633         m_frame.document()-&gt;cancelParsing();
 634         m_frame.document()-&gt;stopActiveDOMObjects();
 635         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 636         m_frame.document()-&gt;prepareForDestruction();
 637         if (hadLivingRenderTree)
 638             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 639     }
 640 
<a name="17" id="anc17"></a><span class="line-added"> 641     if (handleDOMWindowCreation)</span>
<span class="line-added"> 642         handleDOMWindowCreation();</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     if (!neededClear)</span>
<span class="line-added"> 645         return;</span>
<span class="line-added"> 646 </span>
 647     // Do this after detaching the document so that the unload event works.
 648     if (clearWindowProperties) {
 649         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 650         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 651         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);
 652 
 653         if (shouldClearWindowName(m_frame, *newDocument))
 654             m_frame.tree().setName(nullAtom());
 655     }
 656 
 657     m_frame.selection().prepareForDestruction();
 658     m_frame.eventHandler().clear();
 659 
 660     if (clearFrameView &amp;&amp; m_frame.view())
 661         m_frame.view()-&gt;clear();
 662 
 663     // Do not drop the document before the ScriptController and view are cleared
 664     // as some destructors might still try to access the document.
 665     m_frame.setDocument(nullptr);
 666 
 667     subframeLoader().clear();
 668 
 669     if (clearWindowProperties)
 670         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 671 
 672     if (clearScriptObjects)
 673         m_frame.script().clearScriptObjects();
 674 
 675     m_frame.script().enableEval();
 676 
 677     m_frame.navigationScheduler().clear();
 678 
 679     m_checkTimer.stop();
 680     m_shouldCallCheckCompleted = false;
 681     m_shouldCallCheckLoadComplete = false;
 682 
 683     if (m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad())
 684         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 685 }
 686 
 687 void FrameLoader::receivedFirstData()
 688 {
 689     dispatchDidCommitLoad(WTF::nullopt);
 690     dispatchDidClearWindowObjectsInAllWorlds();
 691     dispatchGlobalObjectAvailableInAllWorlds();
 692 
 693     if (!m_documentLoader)
 694         return;
 695 
 696     auto&amp; documentLoader = *m_documentLoader;
 697     auto&amp; title = documentLoader.title();
 698     if (!title.string.isNull())
 699         m_client.dispatchDidReceiveTitle(title);
 700 
 701     ASSERT(m_frame.document());
 702     auto&amp; document = *m_frame.document();
 703 
 704     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 705 
 706     double delay;
 707     String urlString;
 708     if (!parseHTTPRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))
 709         return;
 710     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 711     if (!WTF::protocolIsJavaScript(completedURL))
 712         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 713     else {
 714         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 715         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 716     }
 717 }
 718 
 719 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 720 {
 721     m_outgoingReferrer = url.strippedForUseAsReferrer();
 722 }
 723 
 724 void FrameLoader::didBeginDocument(bool dispatch, ContentSecurityPolicy* previousPolicy)
 725 {
 726     m_needsClear = true;
 727     m_isComplete = false;
 728     m_didCallImplicitClose = false;
 729     m_frame.document()-&gt;setReadyState(Document::Loading);
 730 
 731     if (m_pendingStateObject) {
 732         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 733         m_pendingStateObject = nullptr;
 734     }
 735 
 736     if (dispatch)
 737         dispatchDidClearWindowObjectsInAllWorlds();
 738 
 739     updateFirstPartyForCookies();
 740     m_frame.document()-&gt;initContentSecurityPolicy(previousPolicy);
 741 
 742     const Settings&amp; settings = m_frame.settings();
 743     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 744     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 745 
 746     if (m_documentLoader) {
 747         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 748         if (!dnsPrefetchControl.isEmpty())
 749             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 750 
 751         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 752 
 753         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 754         if (!referrerPolicy.isNull())
 755             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 756 
 757         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 758         if (!headerContentLanguage.isEmpty()) {
 759             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 760             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
 761             headerContentLanguage = stripLeadingAndTrailingHTMLSpaces(headerContentLanguage);
 762             if (!headerContentLanguage.isEmpty())
 763                 m_frame.document()-&gt;setContentLanguage(headerContentLanguage);
 764         }
 765     }
 766 
 767     history().restoreDocumentState();
 768 }
 769 
 770 void FrameLoader::finishedParsing()
 771 {
 772     LOG(Loading, &quot;WebCoreLoading %s: Finished parsing&quot;, m_frame.tree().uniqueName().string().utf8().data());
 773 
 774     m_frame.injectUserScripts(InjectAtDocumentEnd);
 775 
 776     if (m_stateMachine.creatingInitialEmptyDocument())
 777         return;
 778 
 779     // This can be called from the Frame&#39;s destructor, in which case we shouldn&#39;t protect ourselves
 780     // because doing so will cause us to re-enter the destructor when protector goes out of scope.
 781     // Null-checking the FrameView indicates whether or not we&#39;re in the destructor.
 782     RefPtr&lt;Frame&gt; protector = m_frame.view() ? &amp;m_frame : 0;
 783 
 784     m_client.dispatchDidFinishDocumentLoad();
 785 
 786     scrollToFragmentWithParentBoundary(m_frame.document()-&gt;url());
 787 
 788     checkCompleted();
 789 
 790     if (!m_frame.view())
 791         return; // We are being destroyed by something checkCompleted called.
 792 
 793     // Check if the scrollbars are really needed for the content.
 794     // If not, remove them, relayout, and repaint.
 795     m_frame.view()-&gt;restoreScrollbar();
 796 }
 797 
 798 void FrameLoader::loadDone(LoadCompletionType type)
 799 {
 800     if (type == LoadCompletionType::Finish)
 801         checkCompleted();
 802     else
 803         scheduleCheckCompleted();
 804 }
 805 
 806 void FrameLoader::subresourceLoadDone(LoadCompletionType type)
 807 {
 808     if (type == LoadCompletionType::Finish)
 809         checkLoadComplete();
 810     else
 811         scheduleCheckLoadComplete();
 812 }
 813 
 814 bool FrameLoader::allChildrenAreComplete() const
 815 {
 816     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
 817         if (!child-&gt;loader().m_isComplete)
 818             return false;
 819     }
 820     return true;
 821 }
 822 
 823 bool FrameLoader::allAncestorsAreComplete() const
 824 {
 825     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 826         if (!ancestor-&gt;loader().m_isComplete)
 827             return false;
 828     }
 829     return true;
 830 }
 831 
 832 void FrameLoader::checkCompleted()
 833 {
 834     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 835     m_shouldCallCheckCompleted = false;
 836 
 837     // Have we completed before?
 838     if (m_isComplete)
 839         return;
 840 
 841 #if ENABLE(VIDEO)
 842     // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.
 843     if (HTMLMediaElement::isRunningDestructor()) {
 844         ASSERT_NOT_REACHED();
 845         scheduleCheckCompleted();
 846         return;
 847     }
 848 #endif
 849 
 850     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 851     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 852     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 853         scheduleCheckCompleted();
 854         return;
 855     }
 856 
 857     // Are we still parsing?
 858     if (m_frame.document()-&gt;parsing())
 859         return;
 860 
 861     // Still waiting for images/scripts?
 862     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 863         return;
 864 
 865     // Still waiting for elements that don&#39;t go through a FrameLoader?
 866     if (m_frame.document()-&gt;isDelayingLoadEvent())
 867         return;
 868 
 869     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 870     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 871         return;
 872 
 873     // Any frame that hasn&#39;t completed yet?
 874     if (!allChildrenAreComplete())
 875         return;
 876 
 877     // Important not to protect earlier in this function, because earlier parts
 878     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 879     // to ref an object while it&#39;s being destroyed.
 880     Ref&lt;Frame&gt; protect(m_frame);
 881 
 882     // OK, completed.
 883     m_isComplete = true;
 884     m_requestedHistoryItem = nullptr;
 885     m_frame.document()-&gt;setReadyState(Document::Complete);
 886 
 887 #if PLATFORM(IOS_FAMILY)
 888     if (m_frame.document()-&gt;url().isEmpty()) {
 889         // We need to update the document URL of a PDF document to be non-empty so that both back/forward history navigation
 890         // between PDF pages and fragment navigation works. See &lt;rdar://problem/9544769&gt; for more details.
 891         // FIXME: Is there a better place for this code, say DocumentLoader? Also, we should explicitly only update the URL
 892         // of the document when it&#39;s a PDFDocument object instead of assuming that a Document object with an empty URL is a PDFDocument.
 893         // FIXME: This code is incorrect for a synthesized document (which also has an empty URL). The URL for a synthesized
 894         // document should be the URL specified to FrameLoader::initForSynthesizedDocument().
 895         m_frame.document()-&gt;setURL(activeDocumentLoader()-&gt;documentURL());
 896     }
 897 #endif
 898 
 899     checkCallImplicitClose(); // if we didn&#39;t do it before
 900 
 901     m_frame.navigationScheduler().startTimer();
 902 
 903     completed();
 904     if (m_frame.page())
 905         checkLoadComplete();
 906 }
 907 
 908 void FrameLoader::checkTimerFired()
 909 {
 910     checkCompletenessNow();
 911 }
 912 
 913 void FrameLoader::checkCompletenessNow()
 914 {
 915     Ref&lt;Frame&gt; protect(m_frame);
 916 
 917     if (Page* page = m_frame.page()) {
 918         if (page-&gt;defersLoading())
 919             return;
 920     }
 921     if (m_shouldCallCheckCompleted)
 922         checkCompleted();
 923     if (m_shouldCallCheckLoadComplete)
 924         checkLoadComplete();
 925 }
 926 
 927 void FrameLoader::startCheckCompleteTimer()
 928 {
 929     if (!(m_shouldCallCheckCompleted || m_shouldCallCheckLoadComplete))
 930         return;
 931     if (m_checkTimer.isActive())
 932         return;
 933     m_checkTimer.startOneShot(0_s);
 934 }
 935 
 936 void FrameLoader::scheduleCheckCompleted()
 937 {
 938     m_shouldCallCheckCompleted = true;
 939     startCheckCompleteTimer();
 940 }
 941 
 942 void FrameLoader::scheduleCheckLoadComplete()
 943 {
 944     m_shouldCallCheckLoadComplete = true;
 945     startCheckCompleteTimer();
 946 }
 947 
 948 void FrameLoader::checkCallImplicitClose()
 949 {
 950     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 951         return;
 952 
 953     if (!allChildrenAreComplete())
 954         return; // still got a frame running -&gt; too early
 955 
 956     m_didCallImplicitClose = true;
 957     m_wasUnloadEventEmitted = false;
 958     m_frame.document()-&gt;implicitClose();
 959 }
 960 
 961 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 962 {
 963     RELEASE_LOG_IF_ALLOWED(&quot;loadURLIntoChildFrame: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 964 
 965     ASSERT(childFrame);
 966 
 967 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 968     if (auto activeLoader = activeDocumentLoader()) {
 969         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 970             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 971             return;
 972         }
 973     }
 974 #endif
 975 
 976     // If we&#39;re moving in the back/forward list, we might want to replace the content
 977     // of this child frame with whatever was there at that point.
 978     auto* parentItem = history().currentItem();
 979     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 980         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 981             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
<a name="18" id="anc18"></a><span class="line-modified"> 982             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>
 983             return;
 984         }
 985     }
 986 
 987     auto* lexicalFrame = lexicalFrameFromCommonVM();
 988     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 989 
 990     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 991     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 992 }
 993 
 994 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 995 
 996 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 997 {
 998     RELEASE_LOG_IF_ALLOWED(&quot;loadArchive: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 999 
1000     ArchiveResource* mainResource = archive-&gt;mainResource();
1001     ASSERT(mainResource);
1002     if (!mainResource)
1003         return;
1004 
1005     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1006     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1007 
1008     ResourceRequest request(mainResource-&gt;url());
1009 
1010     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1011     documentLoader-&gt;setArchive(WTFMove(archive));
1012     load(documentLoader.get());
1013 }
1014 
1015 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1016 
1017 String FrameLoader::outgoingReferrer() const
1018 {
1019     // See http://www.whatwg.org/specs/web-apps/current-work/#fetching-resources
1020     // for why we walk the parent chain for srcdoc documents.
1021     Frame* frame = &amp;m_frame;
1022     while (frame &amp;&amp; frame-&gt;document()-&gt;isSrcdocDocument()) {
1023         frame = frame-&gt;tree().parent();
1024         // Srcdoc documents cannot be top-level documents, by definition,
1025         // because they need to be contained in iframes with the srcdoc.
1026         ASSERT(frame);
1027     }
1028     if (!frame)
1029         return emptyString();
1030     return frame-&gt;loader().m_outgoingReferrer;
1031 }
1032 
1033 String FrameLoader::outgoingOrigin() const
1034 {
1035     return m_frame.document()-&gt;securityOrigin().toString();
1036 }
1037 
1038 bool FrameLoader::checkIfFormActionAllowedByCSP(const URL&amp; url, bool didReceiveRedirectResponse) const
1039 {
1040     if (m_submittedFormURL.isEmpty())
1041         return true;
1042 
1043     auto redirectResponseReceived = didReceiveRedirectResponse ? ContentSecurityPolicy::RedirectResponseReceived::Yes : ContentSecurityPolicy::RedirectResponseReceived::No;
1044     return m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(url, redirectResponseReceived);
1045 }
1046 
1047 Frame* FrameLoader::opener()
1048 {
1049     return m_opener;
1050 }
1051 
1052 void FrameLoader::setOpener(Frame* opener)
1053 {
1054     if (m_opener &amp;&amp; !opener)
1055         m_client.didDisownOpener();
1056 
1057     if (m_opener) {
1058         // When setOpener is called in ~FrameLoader, opener&#39;s m_frameLoader is already cleared.
1059         auto&amp; openerFrameLoader = m_opener == &amp;m_frame ? *this : m_opener-&gt;loader();
1060         openerFrameLoader.m_openedFrames.remove(&amp;m_frame);
1061     }
1062     if (opener) {
1063         opener-&gt;loader().m_openedFrames.add(&amp;m_frame);
1064         if (auto* page = m_frame.page())
1065             page-&gt;setOpenedByDOMWithOpener();
1066     }
1067     m_opener = opener;
1068 
1069     if (m_frame.document())
1070         m_frame.document()-&gt;initSecurityContext();
1071 }
1072 
1073 // FIXME: This does not belong in FrameLoader!
1074 void FrameLoader::handleFallbackContent()
1075 {
1076     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
1077     if (!is&lt;HTMLObjectElement&gt;(owner))
1078         return;
1079     downcast&lt;HTMLObjectElement&gt;(*owner).renderFallbackContent();
1080 }
1081 
1082 void FrameLoader::provisionalLoadStarted()
1083 {
1084     if (m_stateMachine.firstLayoutDone())
1085         m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
1086     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1087     m_client.provisionalLoadStarted();
1088 
1089     if (m_frame.isMainFrame()) {
1090         tracePoint(MainResourceLoadDidStartProvisional);
1091 
1092         if (auto* page = m_frame.page())
1093             page-&gt;didStartProvisionalLoad();
1094     }
1095 }
1096 
1097 void FrameLoader::resetMultipleFormSubmissionProtection()
1098 {
1099     m_submittedFormURL = URL();
1100 }
1101 
1102 void FrameLoader::updateFirstPartyForCookies()
1103 {
1104     if (m_frame.tree().parent())
1105         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1106     else
1107         setFirstPartyForCookies(m_frame.document()-&gt;url());
1108 }
1109 
1110 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1111 {
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1113         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1114 
<a name="19" id="anc19"></a><span class="line-modified">1115     RegistrableDomain registrableDomain(url);</span>
1116     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
<a name="20" id="anc20"></a><span class="line-modified">1117         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))</span>
1118             frame-&gt;document()-&gt;setSiteForCookies(url);
1119     }
1120 }
1121 
1122 // This does the same kind of work that didOpenURL does, except it relies on the fact
1123 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1124 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1125 {
1126     RELEASE_LOG_IF_ALLOWED(&quot;loadInSameDocument: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1127 
1128     // If we have a state object, we cannot also be a new navigation.
1129     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1130 
1131     // Update the data source&#39;s request with the new URL to fake the URL change
1132     URL oldURL = m_frame.document()-&gt;url();
1133     m_frame.document()-&gt;setURL(url);
1134     setOutgoingReferrer(url);
1135     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1136     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1137         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1138         // based on the current request. Must also happen before we openURL and displace the
1139         // scroll position, since adding the BF item will save away scroll state.
1140 
1141         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1142         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1143         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1144         // though its load is not yet done.  I think this all works out OK, for one because
1145         // we have already saved away the scroll and doc state for the long slow load,
1146         // but it&#39;s not an obvious case.
1147 
1148         history().updateBackForwardListForFragmentScroll();
1149     }
1150 
1151     bool hashChange = equalIgnoringFragmentIdentifier(url, oldURL) &amp;&amp; url.fragmentIdentifier() != oldURL.fragmentIdentifier();
1152 
1153     history().updateForSameDocumentNavigation();
1154 
1155     // If we were in the autoscroll/panScroll mode we want to stop it before following the link to the anchor
1156     if (hashChange)
1157         m_frame.eventHandler().stopAutoscrollTimer();
1158 
1159     // It&#39;s important to model this as a load that starts and immediately finishes.
1160     // Otherwise, the parent frame may think we never finished loading.
1161     started();
1162 
1163     if (auto* ownerElement = m_frame.ownerElement()) {
1164         auto* ownerRenderer = ownerElement-&gt;renderer();
1165         auto* view = m_frame.view();
1166         if (is&lt;RenderWidget&gt;(ownerRenderer) &amp;&amp; view)
1167             downcast&lt;RenderWidget&gt;(*ownerRenderer).setWidget(view);
1168     }
1169 
1170     // We need to scroll to the fragment whether or not a hash change occurred, since
1171     // the user might have scrolled since the previous navigation.
1172     scrollToFragmentWithParentBoundary(url, isNewNavigation);
1173 
1174     m_isComplete = false;
1175     checkCompleted();
1176 
1177     if (isNewNavigation) {
1178         // This will clear previousItem from the rest of the frame tree that didn&#39;t
1179         // doing any loading. We need to make a pass on this now, since for fragment
1180         // navigation we&#39;ll not go through a real load and reach Completed state.
1181         checkLoadComplete();
1182     }
1183 
1184     m_client.dispatchDidNavigateWithinPage();
1185 
1186     m_frame.document()-&gt;statePopped(stateObject ? Ref&lt;SerializedScriptValue&gt; { *stateObject } : SerializedScriptValue::nullValue());
1187     m_client.dispatchDidPopStateWithinPage();
1188 
1189     if (hashChange) {
1190         m_frame.document()-&gt;enqueueHashchangeEvent(oldURL, url);
1191         m_client.dispatchDidChangeLocationWithinPage();
1192     }
1193 
1194     // FrameLoaderClient::didFinishLoad() tells the internal load delegate the load finished with no error
1195     m_client.didFinishLoad();
1196 }
1197 
1198 bool FrameLoader::isComplete() const
1199 {
1200     return m_isComplete;
1201 }
1202 
1203 void FrameLoader::completed()
1204 {
1205     Ref&lt;Frame&gt; protect(m_frame);
1206 
1207     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1208         descendant-&gt;navigationScheduler().startTimer();
1209 
1210     if (Frame* parent = m_frame.tree().parent())
1211         parent-&gt;loader().checkCompleted();
1212 
1213     if (m_frame.view())
1214         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1215 }
1216 
1217 void FrameLoader::started()
1218 {
1219     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1220         frame-&gt;loader().m_isComplete = false;
1221 }
1222 
1223 void FrameLoader::prepareForLoadStart()
1224 {
1225     RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart: Starting frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1226 
1227     m_progressTracker-&gt;progressStarted();
1228     m_client.dispatchDidStartProvisionalLoad();
1229 
1230     if (AXObjectCache::accessibilityEnabled()) {
1231         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1232             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1233             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1234         }
1235     }
1236 }
1237 
1238 void FrameLoader::setupForReplace()
1239 {
1240     m_client.revertToProvisionalState(m_documentLoader.get());
1241     setState(FrameStateProvisional);
1242     m_provisionalDocumentLoader = m_documentLoader;
1243     m_documentLoader = nullptr;
1244     detachChildren();
1245 }
1246 
1247 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1248 {
1249     RELEASE_LOG_IF_ALLOWED(&quot;loadFrameRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1250 
1251     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1252     auto protectFrame = makeRef(m_frame);
1253 
1254     URL url = request.resourceRequest().url();
1255 
1256     ASSERT(m_frame.document());
1257     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1258         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1259         return;
1260     }
1261 
1262     String argsReferrer = request.resourceRequest().httpReferrer();
1263     if (argsReferrer.isEmpty())
1264         argsReferrer = outgoingReferrer();
1265 
1266     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1267     if (request.shouldSendReferrer() == NeverSendReferrer)
1268         referrer = String();
1269 
1270     FrameLoadType loadType;
1271     if (request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1272         loadType = FrameLoadType::Reload;
1273     else if (request.lockBackForwardList() == LockBackForwardList::Yes)
1274         loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1275     else
1276         loadType = FrameLoadType::Standard;
1277 
1278     auto completionHandler = [this, protectedFrame = makeRef(m_frame), formState = makeWeakPtr(formState.get()), frameName = request.frameName()] {
1279         // FIXME: It&#39;s possible this targetFrame will not be the same frame that was targeted by the actual
1280         // load if frame names have changed.
1281         Frame* sourceFrame = formState ? formState-&gt;sourceDocument().frame() : &amp;m_frame;
1282         if (!sourceFrame)
1283             sourceFrame = &amp;m_frame;
1284         Frame* targetFrame = sourceFrame-&gt;loader().findFrameForNavigation(frameName);
1285         if (targetFrame &amp;&amp; targetFrame != sourceFrame) {
1286             if (Page* page = targetFrame-&gt;page())
1287                 page-&gt;chrome().focus();
1288         }
1289     };
1290 
1291     if (request.resourceRequest().httpMethod() == &quot;POST&quot;)
1292         loadPostRequest(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(completionHandler));
1293     else
1294         loadURL(WTFMove(request), referrer, loadType, event, WTFMove(formState), WTFMove(adClickAttribution), WTFMove(completionHandler));
1295 }
1296 
1297 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1298 {
1299     if (UserGestureIndicator::processingUserGesture())
1300         return ShouldOpenExternalURLsPolicy::ShouldAllow;
1301 
1302     if (initiatedByMainFrame == InitiatedByMainFrame::Yes)
1303         return propagatedPolicy;
1304 
1305     if (!currentFrame.isMainFrame())
1306         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
1307 
1308     return propagatedPolicy;
1309 }
1310 
1311 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1312 {
1313     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1314 }
1315 
1316 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1317 {
1318     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1319 }
1320 
1321 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1322 {
1323     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1324 }
1325 
1326 bool FrameLoader::isNavigationAllowed() const
1327 {
<a name="21" id="anc21"></a><span class="line-modified">1328     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);</span>
1329 }
1330 
1331 bool FrameLoader::isStopLoadingAllowed() const
1332 {
1333     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1334 }
1335 
1336 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1337 {
1338     RELEASE_LOG_IF_ALLOWED(&quot;loadURL: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1339 
1340     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1341     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1342         return;
1343 
1344     Ref&lt;Frame&gt; protect(m_frame);
1345 
1346     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1347     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1348     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1349     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1350     LockHistory lockHistory = frameLoadRequest.lockHistory();
1351     bool isFormSubmission = formState;
1352 
1353     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1354     ResourceRequest request(newURL);
1355     if (!referrer.isEmpty()) {
1356         request.setHTTPReferrer(referrer);
1357         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1358         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
1359     }
1360     if (&amp;m_frame.tree().top() != &amp;m_frame)
1361         request.setDomainForCachePartition(m_frame.tree().top().document()-&gt;domainForCachePartition());
1362 
1363     addExtraFieldsToRequest(request, newLoadType, true);
1364     if (isReload(newLoadType))
1365         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1366 
1367     ASSERT(newLoadType != FrameLoadType::Same);
1368 
1369     // The search for a target frame is done earlier in the case of form submission.
1370     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1371     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1372         frameLoadRequest.setFrameName(&quot;_self&quot;);
1373         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1374         return;
1375     }
1376 
1377     if (!isNavigationAllowed())
1378         return;
1379 
1380     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1381     action.setLockHistory(lockHistory);
1382     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1383     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1384         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1385 
1386     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1387         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
1388         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
1389             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1390             completionHandler();
1391         });
1392         return;
1393     }
1394 
1395     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1396 
1397     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1398     const String&amp; httpMethod = request.httpMethod();
1399 
1400     // Make sure to do scroll to fragment processing even if the URL is
1401     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1402     // work properly.
1403     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1404         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1405         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1406         policyChecker().stopCheck();
1407         policyChecker().setLoadType(newLoadType);
1408         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1409         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1410             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1411         }, PolicyDecisionMode::Synchronous);
1412         return;
1413     }
1414 
1415     // Must grab this now, since this load may stop the previous load and clear this flag.
1416     bool isRedirect = m_quickRedirectComing;
1417 #if USE(SYSTEM_PREVIEW)
1418     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1419     request.setSystemPreview(isSystemPreview);
1420     if (isSystemPreview)
1421         request.setSystemPreviewRect(frameLoadRequest.systemPreviewRect());
1422 #endif
<a name="22" id="anc22"></a><span class="line-modified">1423     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {</span>
1424         if (isRedirect) {
1425             m_quickRedirectComing = false;
1426             if (m_provisionalDocumentLoader)
1427                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1428             else if (m_policyDocumentLoader)
1429                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1430         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1431             // Example of this case are sites that reload the same URL with a different cookie
1432             // driving the generated content, or a master frame with links that drive a target
1433             // frame, where the user has clicked on the same link repeatedly.
1434             m_loadType = FrameLoadType::Same;
1435         }
1436         completionHandler();
1437     });
1438 }
1439 
1440 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1441 {
1442     if (!shouldTreatURLAsSrcdocDocument(url))
1443         return SubstituteData();
1444     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1445     ASSERT(!srcdoc.isNull());
1446     CString encodedSrcdoc = srcdoc.string().utf8();
1447 
1448     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1449     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1450 }
1451 
1452 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1453 {
1454     RELEASE_LOG_IF_ALLOWED(&quot;load (FrameLoadRequest): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1455 
1456     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1457         return;
1458 
1459     if (!request.frameName().isEmpty()) {
1460         Frame* frame = findFrameForNavigation(request.frameName());
1461         if (frame) {
1462             request.setShouldCheckNewWindowPolicy(false);
1463             if (&amp;frame-&gt;loader() != this) {
1464                 frame-&gt;loader().load(WTFMove(request));
1465                 return;
1466             }
1467         }
1468     }
1469 
1470     if (request.shouldCheckNewWindowPolicy()) {
1471         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
1472         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) {
1473             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1474         });
1475 
1476         return;
1477     }
1478 
1479     if (!request.hasSubstituteData())
1480         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1481 
1482     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1483     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1484     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1485     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1486 
1487     if (request.shouldTreatAsContinuingLoad()) {
1488         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1489         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1490             loader-&gt;setIsClientRedirect(true);
1491             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1492         }
1493     }
1494 
1495     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1496     load(loader.get());
1497 }
1498 
<a name="23" id="anc23"></a><span class="line-modified">1499 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)</span>
1500 {
1501     RELEASE_LOG_IF_ALLOWED(&quot;loadWithNavigationAction: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1502 
1503     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
<a name="24" id="anc24"></a><span class="line-added">1504     loader-&gt;setDownloadAttribute(downloadAttribute);</span>
1505     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1506 
1507     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1508         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1509 
1510     loader-&gt;setTriggeringAction(WTFMove(action));
1511     if (m_documentLoader)
1512         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1513 
1514     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1515 }
1516 
1517 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1518 {
1519     RELEASE_LOG_IF_ALLOWED(&quot;load (DocumentLoader): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1520 
1521     ResourceRequest&amp; r = newDocumentLoader.request();
1522     addExtraFieldsToMainResourceRequest(r);
1523     FrameLoadType type;
1524 
1525     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1526         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1527         type = FrameLoadType::Same;
1528     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1529         type = m_loadType;
1530     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1531         type = FrameLoadType::RedirectWithLockedBackForwardList;
1532     else
1533         type = FrameLoadType::Standard;
1534 
1535     if (m_documentLoader)
1536         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1537 
1538     // When we loading alternate content for an unreachable URL that we&#39;re
1539     // visiting in the history list, we treat it as a reload so the history list
1540     // is appropriately maintained.
1541     //
1542     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1543     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1544     // &quot;load without affecting history&quot; ?
1545     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1546         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1547         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1548         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1549         history().saveDocumentAndScrollState();
1550 
1551         ASSERT(type == FrameLoadType::Standard);
1552         type = FrameLoadType::Reload;
1553     }
1554 
1555     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1556 }
1557 
1558 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1559 {
1560     RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1561 
1562     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1563     Ref&lt;Frame&gt; protect(m_frame);
1564 
1565     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1566 
1567     ASSERT(m_client.hasWebView());
1568 
1569     // Unfortunately the view must be non-nil, this is ultimately due
1570     // to parser requiring a FrameView.  We should fix this dependency.
1571 
1572     ASSERT(m_frame.view());
1573 
1574     if (!isNavigationAllowed())
1575         return;
1576 
1577     if (m_frame.document())
1578         m_previousURL = m_frame.document()-&gt;url();
1579 
1580     const URL&amp; newURL = loader-&gt;request().url();
1581 
1582     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1583     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1584     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1585         m_shouldReportResourceTimingToParentFrame = false;
1586 
1587     // Log main frame navigation types.
1588     if (m_frame.isMainFrame()) {
1589         if (auto* page = m_frame.page()) {
1590             RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: main frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1591             page-&gt;mainFrameLoadStarted(newURL, type);
1592             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1593         }
1594     }
1595 
1596     policyChecker().setLoadType(type);
1597     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1598     bool isFormSubmission = formState;
1599 
1600     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1601 
1602     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1603         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1604         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1605 
1606         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1607         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1608         policyChecker().stopCheck();
1609         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1610         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1611             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1612         }, PolicyDecisionMode::Synchronous);
1613         return;
1614     }
1615 
1616     if (Frame* parent = m_frame.tree().parent())
1617         loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());
1618 
1619     policyChecker().stopCheck();
1620     setPolicyDocumentLoader(loader);
1621     if (loader-&gt;triggeringAction().isEmpty())
1622         loader-&gt;setTriggeringAction({ *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission });
1623 
1624     if (Element* ownerElement = m_frame.ownerElement()) {
1625         // We skip dispatching the beforeload event if we&#39;ve already
1626         // committed a real document load because the event would leak
1627         // subsequent activity by the frame which the parent frame isn&#39;t
1628         // supposed to learn. For example, if the child frame navigated to
1629         // a new URL, the parent frame shouldn&#39;t learn the URL.
1630         if (!m_stateMachine.committedFirstRealDocumentLoad()
1631             &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) {
1632             continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::IgnoreLoad, allowNavigationToInvalidURL);
1633             return;
1634         }
1635     }
1636 
1637     m_frame.navigationScheduler().cancel(NewLoadInProgress::Yes);
1638 
1639     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1640         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1641         return;
1642     }
1643 
1644     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1645     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1646         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1647         completionHandler();
1648     }, PolicyDecisionMode::Asynchronous);
1649 }
1650 
1651 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1652 {
1653     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1654         return;
1655 
1656     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1657     m_provisionalDocumentLoader-&gt;stopLoading();
1658     setProvisionalDocumentLoader(nullptr);
1659 }
1660 
1661 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1662 {
1663     ASSERT(!url.isEmpty());
1664     if (!frame)
1665         return;
1666 
1667     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1668 }
1669 
1670 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1671 {
1672     ASSERT(!url.isEmpty());
1673     if (!frame)
1674         return;
1675 
1676     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1677 }
1678 
1679 void FrameLoader::reportAuthenticationChallengeBlocked(Frame* frame, const URL&amp; url, const String&amp; reason)
1680 {
1681     if (!frame)
1682         return;
1683 
1684     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Blocked &quot;, url.stringCenterEllipsizedToLength(), &quot; from asking for credentials because &quot;, reason, &#39;.&#39;));
1685 }
1686 
1687 const ResourceRequest&amp; FrameLoader::initialRequest() const
1688 {
1689     return activeDocumentLoader()-&gt;originalRequest();
1690 }
1691 
1692 bool FrameLoader::willLoadMediaElementURL(URL&amp; url, Node&amp; initiatorNode)
1693 {
1694 #if PLATFORM(IOS_FAMILY)
1695     // MobileStore depends on the iOS 4.0 era client delegate method because webView:resource:willSendRequest:redirectResponse:fromDataSource
1696     // doesn&#39;t let them tell when a load request is coming from a media element. See &lt;rdar://problem/8266916&gt; for more details.
1697     if (IOSApplication::isMobileStore())
1698         return m_client.shouldLoadMediaElementURL(url);
1699 #endif
1700 
1701     ResourceRequest request(url);
1702     request.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(initiatorNode));
1703 
1704     unsigned long identifier;
1705     ResourceError error;
1706     requestFromDelegate(request, identifier, error);
1707     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, ResourceResponse(url, String(), -1, String()), 0, -1, -1, error);
1708 
1709     url = request.url();
1710 
1711     return error.isNull();
1712 }
1713 
1714 bool FrameLoader::shouldReloadToHandleUnreachableURL(DocumentLoader&amp; docLoader)
1715 {
1716     URL unreachableURL = docLoader.unreachableURL();
1717 
1718     if (unreachableURL.isEmpty())
1719         return false;
1720 
1721     if (!isBackForwardLoadType(policyChecker().loadType()))
1722         return false;
1723 
1724     // We only treat unreachableURLs specially during the delegate callbacks
1725     // for provisional load errors and navigation policy decisions. The former
1726     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1727     // case handles malformed URLs and unknown schemes. Loading alternate content
1728     // at other times behaves like a standard load.
1729     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1730         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1731 
1732     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1733 }
1734 
1735 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1736 {
1737     if (!m_documentLoader)
1738         return;
1739 
1740     RELEASE_LOG_IF_ALLOWED(&quot;reloadWithOverrideEncoding: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1741 
1742     ResourceRequest request = m_documentLoader-&gt;request();
1743     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1744     if (!unreachableURL.isEmpty())
1745         request.setURL(unreachableURL);
1746 
1747     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1748     // We should ask the user for confirmation in this case.
1749     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1750 
1751     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1752     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1753 
1754     setPolicyDocumentLoader(loader.ptr());
1755 
1756     loader-&gt;setOverrideEncoding(encoding);
1757 
1758     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1759 }
1760 
1761 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1762 {
1763     if (!m_documentLoader)
1764         return;
1765 
1766     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1767     // Reloading in this case will lose the current contents (see 4151001).
1768     if (m_documentLoader-&gt;request().url().isEmpty())
1769         return;
1770 
1771     RELEASE_LOG_IF_ALLOWED(&quot;reload: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1772 
1773     // Replace error-page URL with the URL we were trying to reach.
1774     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1775     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1776     if (!unreachableURL.isEmpty())
1777         initialRequest.setURL(unreachableURL);
1778 
1779     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1780     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1781     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1782     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());
1783     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1784 
1785     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1786 
1787     ResourceRequest&amp; request = loader-&gt;request();
1788 
1789     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1790     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1791 
1792     addSameSiteInfoToRequestIfNeeded(request);
1793 
1794     // If we&#39;re about to re-post, set up action so the application can warn the user.
1795     if (request.httpMethod() == &quot;POST&quot;)
1796         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1797 
1798     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1799 
1800     auto frameLoadTypeForReloadOptions = [] (auto options) {
1801         if (options &amp; ReloadOption::FromOrigin)
1802             return FrameLoadType::ReloadFromOrigin;
1803         if (options &amp; ReloadOption::ExpiredOnly)
1804             return FrameLoadType::ReloadExpiredOnly;
1805         return FrameLoadType::Reload;
1806     };
1807 
1808     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1809 }
1810 
<a name="25" id="anc25"></a><span class="line-modified">1811 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)</span>
1812 {
1813     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;pageCacheState() == Document::InPageCache)
1814         return;
1815 
<a name="26" id="anc26"></a><span class="line-modified">1816     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())</span>
1817         return;
1818 
1819     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1820     if (m_inStopAllLoaders)
1821         return;
1822 
1823     // This method might dispatch events.
1824     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1825 
1826     // Calling stopLoading() on the provisional document loader can blow away
1827     // the frame from underneath.
1828     Ref&lt;Frame&gt; protect(m_frame);
1829 
1830     m_inStopAllLoaders = true;
1831 
1832     policyChecker().stopCheck();
1833 
1834     // If no new load is in progress, we should clear the provisional item from history
1835     // before we call stopLoading.
1836     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1837         history().setProvisionalItem(nullptr);
1838 
1839     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1840         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1841     if (m_provisionalDocumentLoader)
1842         m_provisionalDocumentLoader-&gt;stopLoading();
1843     if (m_documentLoader)
1844         m_documentLoader-&gt;stopLoading();
1845 
1846     setProvisionalDocumentLoader(nullptr);
1847 
1848     m_inStopAllLoaders = false;
1849 }
1850 
1851 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1852 {
1853     stopAllLoaders();
1854 
1855     if (!m_checkTimer.isActive())
1856         return;
1857 
1858     m_checkTimer.stop();
1859     m_checkingLoadCompleteForDetachment = true;
1860     checkCompletenessNow();
1861     m_checkingLoadCompleteForDetachment = false;
1862 }
1863 
1864 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1865 {
1866     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1867     Ref&lt;Frame&gt; protectedFrame(m_frame);
1868 
1869     stopAllLoaders();
1870 
1871 #if PLATFORM(IOS_FAMILY)
1872     // Lay out immediately when stopping to immediately clear the old page if we just committed this one
1873     // but haven&#39;t laid out/painted yet.
1874     // FIXME: Is this behavior specific to iOS? Or should we expose a setting to toggle this behavior?
1875     if (m_frame.view() &amp;&amp; !m_frame.view()-&gt;didFirstLayout())
1876         m_frame.view()-&gt;layoutContext().layout();
1877 #endif
1878 
1879     if (deferCheckLoadComplete)
1880         scheduleCheckLoadComplete();
1881     else if (m_frame.page())
1882         checkLoadComplete();
1883 }
1884 
1885 DocumentLoader* FrameLoader::activeDocumentLoader() const
1886 {
1887     if (m_state == FrameStateProvisional)
1888         return m_provisionalDocumentLoader.get();
1889     return m_documentLoader.get();
1890 }
1891 
1892 bool FrameLoader::isLoading() const
1893 {
1894     DocumentLoader* docLoader = activeDocumentLoader();
1895     if (!docLoader)
1896         return false;
1897     return docLoader-&gt;isLoading();
1898 }
1899 
1900 bool FrameLoader::frameHasLoaded() const
1901 {
1902     return m_stateMachine.committedFirstRealDocumentLoad() || (m_provisionalDocumentLoader &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument());
1903 }
1904 
1905 void FrameLoader::setDocumentLoader(DocumentLoader* loader)
1906 {
1907     if (!loader &amp;&amp; !m_documentLoader)
1908         return;
1909 
1910     if (loader == m_documentLoader)
1911         return;
1912 
1913     ASSERT(loader != m_documentLoader);
1914     ASSERT(!loader || loader-&gt;frameLoader() == this);
1915 
1916     m_client.prepareForDataSourceReplacement();
1917     detachChildren();
1918 
1919     // detachChildren() can trigger this frame&#39;s unload event, and therefore
1920     // script can run and do just about anything. For example, an unload event that calls
1921     // document.write(&quot;&quot;) on its parent frame can lead to a recursive detachChildren()
1922     // invocation for this frame. In that case, we can end up at this point with a
1923     // loader that hasn&#39;t been deleted but has been detached from its frame. Such a
1924     // DocumentLoader has been sufficiently detached that we&#39;ll end up in an inconsistent
1925     // state if we try to use it.
1926     if (loader &amp;&amp; !loader-&gt;frame())
1927         return;
1928 
1929     if (m_documentLoader)
1930         m_documentLoader-&gt;detachFromFrame();
1931 
1932     m_documentLoader = loader;
1933 }
1934 
1935 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1936 {
1937     if (m_policyDocumentLoader == loader)
1938         return;
1939 
1940     if (loader)
1941         loader-&gt;attachToFrame(m_frame);
1942     if (m_policyDocumentLoader
1943             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1944             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1945         m_policyDocumentLoader-&gt;detachFromFrame();
1946 
1947     m_policyDocumentLoader = loader;
1948 }
1949 
1950 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1951 {
1952     ASSERT(!loader || !m_provisionalDocumentLoader);
1953     ASSERT(!loader || loader-&gt;frameLoader() == this);
1954 
1955     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1956         m_provisionalDocumentLoader-&gt;detachFromFrame();
1957 
1958     m_provisionalDocumentLoader = loader;
1959 }
1960 
1961 void FrameLoader::setState(FrameState newState)
1962 {
1963     FrameState oldState = m_state;
1964     m_state = newState;
1965 
1966     if (newState == FrameStateProvisional)
1967         provisionalLoadStarted();
1968     else if (newState == FrameStateComplete) {
1969         frameLoadCompleted();
1970         if (m_documentLoader)
1971             m_documentLoader-&gt;stopRecordingResponses();
1972         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
1973             RELEASE_LOG_IF_ALLOWED(&quot;setState: main frame load completed (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1974             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
1975         }
1976     }
1977 }
1978 
1979 void FrameLoader::clearProvisionalLoad()
1980 {
1981     setProvisionalDocumentLoader(nullptr);
1982     m_progressTracker-&gt;progressCompleted();
1983     setState(FrameStateComplete);
1984 }
1985 
1986 void FrameLoader::commitProvisionalLoad()
1987 {
1988     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
1989     Ref&lt;Frame&gt; protect(m_frame);
1990 
1991     std::unique_ptr&lt;CachedPage&gt; cachedPage;
1992     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
1993         cachedPage = PageCache::singleton().take(*history().provisionalItem(), m_frame.page());
1994 
1995     LOG(PageCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),
1996         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
1997         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
1998 
1999     willTransitionToCommitted();
2000 
2001     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
2002         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
2003         // We are doing this here because we know for sure that a new page is about to be loaded.
2004         PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());
2005 
2006         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2007     }
2008 
2009     if (m_loadType != FrameLoadType::Replace)
2010         closeOldDataSources();
2011 
2012     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2013         m_client.makeRepresentation(pdl.get());
2014 
2015     transitionToCommitted(cachedPage.get());
2016 
2017     if (pdl &amp;&amp; m_documentLoader) {
2018         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2019         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2020         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2021     }
2022 
2023     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2024     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
2025     // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:.  Since we are
2026     // just about to commit a new page, there cannot possibly be a pending redirect at this point.
2027     if (m_sentRedirectNotification)
2028         clientRedirectCancelledOrFinished(NewLoadInProgress::No);
2029 
2030     if (cachedPage &amp;&amp; cachedPage-&gt;document()) {
2031 #if PLATFORM(IOS_FAMILY)
2032         // FIXME: CachedPage::restore() would dispatch viewport change notification. However UIKit expects load
2033         // commit to happen before any changes to viewport arguments and dealing with this there is difficult.
2034         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(true);
2035 #endif
2036         willRestoreFromCachedPage();
2037 
2038         // Start request for the main resource and dispatch didReceiveResponse before the load is committed for
2039         // consistency with all other loads. See https://bugs.webkit.org/show_bug.cgi?id=150927.
2040         ResourceError mainResouceError;
2041         unsigned long mainResourceIdentifier;
2042         ResourceRequest mainResourceRequest(cachedPage-&gt;documentLoader()-&gt;request());
2043         requestFromDelegate(mainResourceRequest, mainResourceIdentifier, mainResouceError);
2044         notifier().dispatchDidReceiveResponse(cachedPage-&gt;documentLoader(), mainResourceIdentifier, cachedPage-&gt;documentLoader()-&gt;response());
2045 
2046         Optional&lt;HasInsecureContent&gt; hasInsecureContent = cachedPage-&gt;cachedMainFrame()-&gt;hasInsecureContent();
2047 
2048         dispatchDidCommitLoad(hasInsecureContent);
2049 
2050         // FIXME: This API should be turned around so that we ground CachedPage into the Page.
2051         cachedPage-&gt;restore(*m_frame.page());
2052 
2053 #if PLATFORM(IOS_FAMILY)
2054         m_frame.page()-&gt;chrome().setDispatchViewportDataDidChangeSuppressed(false);
2055         m_frame.page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_frame.page()-&gt;viewportArguments());
2056 #endif
2057         m_frame.page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_frame.page()-&gt;disabledAdaptations());
2058 
2059         auto&amp; title = m_documentLoader-&gt;title();
2060         if (!title.string.isNull())
2061             m_client.dispatchDidReceiveTitle(title);
2062 
2063         // Send remaining notifications for the main resource.
2064         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2065             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2066 
2067         checkCompleted();
2068     } else
2069         didOpenURL();
2070 
2071     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2072         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2073 
2074     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2075         history().updateForClientRedirect();
2076 
2077     if (m_loadingFromCachedPage) {
2078         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2079         if (auto* page = m_frame.page())
2080             page-&gt;chrome().didReceiveDocType(m_frame);
2081         m_frame.document()-&gt;resume(ReasonForSuspension::PageCache);
2082 
2083         // Force a layout to update view size and thereby update scrollbars.
2084 #if PLATFORM(IOS_FAMILY)
2085         if (!m_client.forceLayoutOnRestoreFromPageCache())
2086             m_frame.view()-&gt;forceLayout();
2087 #else
2088         m_frame.view()-&gt;forceLayout();
2089 #endif
2090 
2091         // Main resource delegates were already sent, so we skip the first response here.
2092         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2093             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2094             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2095             ResourceError error;
2096             unsigned long identifier;
2097             ResourceRequest request(response.url());
2098             requestFromDelegate(request, identifier, error);
2099             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2100             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2101             // Could be an issue with a giant local file.
2102             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2103         }
2104 
2105         // FIXME: Why only this frame and not parent frames?
2106         checkLoadCompleteForThisFrame();
2107     }
2108 }
2109 
2110 void FrameLoader::transitionToCommitted(CachedPage* cachedPage)
2111 {
2112     ASSERT(m_client.hasWebView());
2113     ASSERT(m_state == FrameStateProvisional);
2114 
2115     if (m_state != FrameStateProvisional)
2116         return;
2117 
2118     if (FrameView* view = m_frame.view()) {
2119         if (ScrollAnimator* scrollAnimator = view-&gt;existingScrollAnimator())
2120             scrollAnimator-&gt;cancelAnimations();
2121     }
2122 
2123     m_client.setCopiesOnScroll();
2124     history().updateForCommit();
2125 
2126     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2127     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2128     // or the two will stomp each other.
2129     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2130     if (m_documentLoader)
2131         closeURL();
2132     if (pdl != m_provisionalDocumentLoader)
2133         return;
2134 
2135     if (m_documentLoader)
2136         m_documentLoader-&gt;stopLoadingSubresources();
2137     if (m_documentLoader)
2138         m_documentLoader-&gt;stopLoadingPlugIns();
2139 
2140     // Setting our document loader invokes the unload event handler of our child frames.
2141     // Script can do anything. If the script initiates a new load, we need to abandon the
2142     // current load or the two will stomp each other.
2143     setDocumentLoader(m_provisionalDocumentLoader.get());
2144     if (pdl != m_provisionalDocumentLoader)
2145         return;
2146     setProvisionalDocumentLoader(nullptr);
2147 
2148     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2149     setState(FrameStateCommittedPage);
2150 
2151     // Handle adding the URL to the back/forward list.
2152     DocumentLoader* dl = m_documentLoader.get();
2153 
2154     switch (m_loadType) {
2155     case FrameLoadType::Forward:
2156     case FrameLoadType::Back:
2157     case FrameLoadType::IndexedBackForward:
2158         if (m_frame.page()) {
2159             // If the first load within a frame is a navigation within a back/forward list that was attached
2160             // without any of the items being loaded then we need to update the history in a similar manner as
2161             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2162             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2163                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2164 
2165             history().updateForBackForwardNavigation();
2166 
2167             // For cached pages, CachedFrame::restore will take care of firing the popstate event with the history item&#39;s state object
2168             if (history().currentItem() &amp;&amp; !cachedPage)
2169                 m_pendingStateObject = history().currentItem()-&gt;stateObject();
2170 
2171             // Create a document view for this document, or used the cached view.
2172             if (cachedPage) {
2173                 DocumentLoader* cachedDocumentLoader = cachedPage-&gt;documentLoader();
2174                 ASSERT(cachedDocumentLoader);
2175                 cachedDocumentLoader-&gt;attachToFrame(m_frame);
2176                 m_client.transitionToCommittedFromCachedFrame(cachedPage-&gt;cachedMainFrame());
2177             } else
2178                 m_client.transitionToCommittedForNewPage();
2179         }
2180         break;
2181 
2182     case FrameLoadType::Reload:
2183     case FrameLoadType::ReloadFromOrigin:
2184     case FrameLoadType::ReloadExpiredOnly:
2185     case FrameLoadType::Same:
2186     case FrameLoadType::Replace:
2187         history().updateForReload();
2188         m_client.transitionToCommittedForNewPage();
2189         break;
2190 
2191     case FrameLoadType::Standard:
2192         history().updateForStandardLoad();
2193         if (m_frame.view())
2194             m_frame.view()-&gt;setScrollbarsSuppressed(true);
2195         m_client.transitionToCommittedForNewPage();
2196         break;
2197 
2198     case FrameLoadType::RedirectWithLockedBackForwardList:
2199         history().updateForRedirectWithLockedBackForwardList();
2200         m_client.transitionToCommittedForNewPage();
2201         break;
2202     }
2203 
2204     m_documentLoader-&gt;writer().setMIMEType(dl-&gt;responseMIMEType());
2205 
2206     // Tell the client we&#39;ve committed this URL.
2207     ASSERT(m_frame.view());
2208 
2209     if (m_stateMachine.creatingInitialEmptyDocument())
2210         return;
2211 
2212     if (!m_stateMachine.committedFirstRealDocumentLoad())
2213         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
2214 }
2215 
2216 void FrameLoader::clientRedirectCancelledOrFinished(NewLoadInProgress newLoadInProgress)
2217 {
2218     // Note that -webView:didCancelClientRedirectForFrame: is called on the frame load delegate even if
2219     // the redirect succeeded.  We should either rename this API, or add a new method, like
2220     // -webView:didFinishClientRedirectForFrame:
2221     m_client.dispatchDidCancelClientRedirect();
2222 
2223     if (newLoadInProgress == NewLoadInProgress::No)
2224         m_quickRedirectComing = false;
2225 
2226     m_sentRedirectNotification = false;
2227 }
2228 
2229 void FrameLoader::clientRedirected(const URL&amp; url, double seconds, WallTime fireDate, LockBackForwardList lockBackForwardList)
2230 {
2231     m_client.dispatchWillPerformClientRedirect(url, seconds, fireDate, lockBackForwardList);
2232 
2233     // Remember that we sent a redirect notification to the frame load delegate so that when we commit
2234     // the next provisional load, we can send a corresponding -webView:didCancelClientRedirectForFrame:
2235     m_sentRedirectNotification = true;
2236 
2237     // If a &quot;quick&quot; redirect comes in, we set a special mode so we treat the next
2238     // load as part of the original navigation. If we don&#39;t have a document loader, we have
2239     // no &quot;original&quot; load on which to base a redirect, so we treat the redirect as a normal load.
2240     // Loads triggered by JavaScript form submissions never count as quick redirects.
2241     m_quickRedirectComing = (lockBackForwardList == LockBackForwardList::Yes || history().currentItemShouldBeReplaced()) &amp;&amp; m_documentLoader &amp;&amp; !m_isExecutingJavaScriptFormAction;
2242 }
2243 
2244 bool FrameLoader::shouldReload(const URL&amp; currentURL, const URL&amp; destinationURL)
2245 {
2246     // This function implements the rule: &quot;Don&#39;t reload if navigating by fragment within
2247     // the same URL, but do reload if going to a new URL or to the same URL with no
2248     // fragment identifier at all.&quot;
2249     if (!destinationURL.hasFragmentIdentifier())
2250         return true;
2251     return !equalIgnoringFragmentIdentifier(currentURL, destinationURL);
2252 }
2253 
2254 void FrameLoader::closeOldDataSources()
2255 {
2256     // FIXME: Is it important for this traversal to be postorder instead of preorder?
2257     // If so, add helpers for postorder traversal, and use them. If not, then lets not
2258     // use a recursive algorithm here.
2259     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
2260         child-&gt;loader().closeOldDataSources();
2261 
2262     if (m_documentLoader)
2263         m_client.dispatchWillClose();
2264 
2265     m_client.setMainFrameDocumentReady(false); // stop giving out the actual DOMDocument to observers
2266 }
2267 
2268 void FrameLoader::willRestoreFromCachedPage()
2269 {
2270     ASSERT(!m_frame.tree().parent());
2271     ASSERT(m_frame.page());
2272     ASSERT(m_frame.isMainFrame());
2273 
2274     m_frame.navigationScheduler().cancel();
2275 
2276     // We still have to close the previous part page.
2277     closeURL();
2278 
2279     // Delete old status bar messages (if it _was_ activated on last URL).
2280     if (m_frame.script().canExecuteScripts(NotAboutToExecuteScript)) {
2281         DOMWindow* window = m_frame.document()-&gt;domWindow();
2282         window-&gt;setStatus(String());
2283         window-&gt;setDefaultStatus(String());
2284     }
2285 }
2286 
2287 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2288 {
2289     m_isComplete = false;
2290 
2291     // Don&#39;t re-emit the load event.
2292     m_didCallImplicitClose = true;
2293 
2294     URL url = cachedFrame.url();
2295 
2296     // FIXME: I suspect this block of code doesn&#39;t do anything.
2297     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2298         url.setPath(&quot;/&quot;);
2299 
2300     started();
<a name="27" id="anc27"></a><span class="line-modified">2301     auto document = makeRef(*cachedFrame.document());</span>

2302     ASSERT(document-&gt;domWindow());
2303 
<a name="28" id="anc28"></a><span class="line-modified">2304     clear(document.ptr(), true, true, cachedFrame.isMainFrame());</span>
2305 
<a name="29" id="anc29"></a><span class="line-added">2306     document-&gt;attachToCachedFrame(cachedFrame);</span>
2307     document-&gt;setPageCacheState(Document::NotInPageCache);
2308 
2309     m_needsClear = true;
2310     m_isComplete = false;
2311     m_didCallImplicitClose = false;
<a name="30" id="anc30"></a><span class="line-modified">2312     setOutgoingReferrer(url);</span>
2313 
2314     FrameView* view = cachedFrame.view();
2315 
2316     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2317     ASSERT(view);
2318     view-&gt;setWasScrolledByUser(false);
2319 
2320     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2321     m_frame.setView(view);
2322 
2323     // Use the previous ScrollView&#39;s frame rect.
2324     if (previousViewFrameRect)
2325         view-&gt;setFrameRect(previousViewFrameRect.value());
2326 
<a name="31" id="anc31"></a><span class="line-modified">2327 </span>
<span class="line-modified">2328     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,</span>
<span class="line-modified">2329     // including loading a child frame before its been re-attached to the frame tree as part of this restore.</span>
<span class="line-modified">2330     // For example, the HTML object element may load its content into a frame in a post style resolution callback.</span>
<span class="line-modified">2331     Style::PostResolutionCallbackDisabler disabler(document.get());</span>
<span class="line-modified">2332     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;</span>
<span class="line-modified">2333     NavigationDisabler disableNavigation { &amp;m_frame };</span>
<span class="line-added">2334 </span>
<span class="line-added">2335     m_frame.setDocument(document.copyRef());</span>
2336 
2337     document-&gt;domWindow()-&gt;resumeFromPageCache();
2338 
2339     updateFirstPartyForCookies();
2340 
2341     cachedFrame.restore();
2342 }
2343 
2344 bool FrameLoader::isHostedByObjectElement() const
2345 {
2346     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2347     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2348 }
2349 
2350 bool FrameLoader::isReplacing() const
2351 {
2352     return m_loadType == FrameLoadType::Replace;
2353 }
2354 
2355 void FrameLoader::setReplacing()
2356 {
2357     m_loadType = FrameLoadType::Replace;
2358 }
2359 
2360 bool FrameLoader::subframeIsLoading() const
2361 {
2362     // It&#39;s most likely that the last added frame is the last to load so we walk backwards.
2363     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling()) {
2364         FrameLoader&amp; childLoader = child-&gt;loader();
2365         DocumentLoader* documentLoader = childLoader.documentLoader();
2366         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2367             return true;
2368         documentLoader = childLoader.provisionalDocumentLoader();
2369         if (documentLoader &amp;&amp; documentLoader-&gt;isLoadingInAPISense())
2370             return true;
2371         documentLoader = childLoader.policyDocumentLoader();
2372         if (documentLoader)
2373             return true;
2374     }
2375     return false;
2376 }
2377 
2378 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2379 {
2380     m_client.willChangeTitle(loader);
2381 }
2382 
2383 FrameLoadType FrameLoader::loadType() const
2384 {
2385     return m_loadType;
2386 }
2387 
2388 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2389 {
2390     if (Page* page = m_frame.page()) {
2391         if (page-&gt;isResourceCachingDisabled())
2392             return CachePolicyReload;
2393     }
2394 
2395     if (m_isComplete)
2396         return CachePolicyVerify;
2397 
2398     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2399         return CachePolicyReload;
2400 
2401     if (Frame* parentFrame = m_frame.tree().parent()) {
2402         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2403         if (parentCachePolicy != CachePolicyVerify)
2404             return parentCachePolicy;
2405     }
2406 
2407     switch (m_loadType) {
2408     case FrameLoadType::Reload:
2409         return CachePolicyRevalidate;
2410     case FrameLoadType::Back:
2411     case FrameLoadType::Forward:
2412     case FrameLoadType::IndexedBackForward:
2413         return CachePolicyHistoryBuffer;
2414     case FrameLoadType::ReloadFromOrigin:
2415         ASSERT_NOT_REACHED(); // Already handled above.
2416         return CachePolicyReload;
2417     case FrameLoadType::RedirectWithLockedBackForwardList:
2418     case FrameLoadType::Replace:
2419     case FrameLoadType::Same:
2420     case FrameLoadType::Standard:
2421         return CachePolicyVerify;
2422     case FrameLoadType::ReloadExpiredOnly:
2423         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2424         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2425             return CachePolicyReload;
2426         return CachePolicyVerify;
2427     }
2428 
2429     RELEASE_ASSERT_NOT_REACHED();
2430     return CachePolicyVerify;
2431 }
2432 
<a name="32" id="anc32"></a><span class="line-added">2433 void FrameLoader::dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp; error)</span>
<span class="line-added">2434 {</span>
<span class="line-added">2435     m_provisionalLoadErrorBeingHandledURL = provisionalDocumentLoader.url();</span>
<span class="line-added">2436 </span>
<span class="line-added">2437 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2438     auto contentFilter = provisionalDocumentLoader.contentFilter();</span>
<span class="line-added">2439     auto contentFilterWillContinueLoading = false;</span>
<span class="line-added">2440 #endif</span>
<span class="line-added">2441 </span>
<span class="line-added">2442     auto willContinueLoading = WillContinueLoading::No;</span>
<span class="line-added">2443     if (history().provisionalItem())</span>
<span class="line-added">2444         willContinueLoading = WillContinueLoading::Yes;</span>
<span class="line-added">2445 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2446     if (contentFilter &amp;&amp; contentFilter-&gt;willHandleProvisionalLoadFailure(error)) {</span>
<span class="line-added">2447         willContinueLoading = WillContinueLoading::Yes;</span>
<span class="line-added">2448         contentFilterWillContinueLoading = true;</span>
<span class="line-added">2449     }</span>
<span class="line-added">2450 #endif</span>
<span class="line-added">2451 </span>
<span class="line-added">2452     m_client.dispatchDidFailProvisionalLoad(error, willContinueLoading);</span>
<span class="line-added">2453 </span>
<span class="line-added">2454 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2455     if (contentFilterWillContinueLoading)</span>
<span class="line-added">2456         contentFilter-&gt;handleProvisionalLoadFailure(error);</span>
<span class="line-added">2457 #endif</span>
<span class="line-added">2458 </span>
<span class="line-added">2459     m_provisionalLoadErrorBeingHandledURL = { };</span>
<span class="line-added">2460 }</span>
<span class="line-added">2461 </span>
2462 void FrameLoader::checkLoadCompleteForThisFrame()
2463 {
2464     ASSERT(m_client.hasWebView());
2465 
2466     // FIXME: Should this check be done in checkLoadComplete instead of here?
2467     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2468     if (m_frame.document()-&gt;isDelayingLoadEvent())
2469         return;
2470 
2471     switch (m_state) {
2472         case FrameStateProvisional: {
2473             // FIXME: Prohibiting any provisional load failures from being sent to clients
2474             // while handling provisional load failures is too heavy. For example, the current
2475             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2476             // load state being handled properly.
2477             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2478                 return;
2479 
2480             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2481             if (!pdl)
2482                 return;
2483 
2484             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2485             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2486             if (error.isNull())
2487                 return;
2488 
2489             // Check all children first.
2490             RefPtr&lt;HistoryItem&gt; item;
2491             if (Page* page = m_frame.page())
2492                 if (isBackForwardLoadType(loadType()))
2493                     // Reset the back forward list to the last committed history item at the top level.
2494                     item = page-&gt;mainFrame().loader().history().currentItem();
2495 
2496             // Only reset if we aren&#39;t already going to a new provisional item.
2497             bool shouldReset = !history().provisionalItem();
2498             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2499                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Failed provisional load (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());
<a name="33" id="anc33"></a>






2500 
<a name="34" id="anc34"></a><span class="line-added">2501                 dispatchDidFailProvisionalLoad(*pdl, error);</span>
2502                 ASSERT(!pdl-&gt;isLoading());
2503 
2504                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2505                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2506                     setDocumentLoader(m_provisionalDocumentLoader.get());
2507 
2508                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2509                 // delegate callback.
2510                 if (pdl == m_provisionalDocumentLoader)
2511                     clearProvisionalLoad();
2512                 else if (activeDocumentLoader()) {
2513                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2514                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2515                         shouldReset = false;
2516                 }
2517             }
2518             if (shouldReset &amp;&amp; item)
2519                 if (Page* page = m_frame.page()) {
2520                     page-&gt;backForward().setCurrentItem(*item);
2521                 }
2522             return;
2523         }
2524 
2525         case FrameStateCommittedPage: {
2526             if (!m_documentLoader)
2527                 return;
2528             if (m_documentLoader-&gt;isLoadingInAPISense() &amp;&amp; !m_documentLoader-&gt;isStopping() &amp;&amp; !m_checkingLoadCompleteForDetachment)
2529                 return;
2530 
2531             setState(FrameStateComplete);
2532 
2533             // FIXME: Is this subsequent work important if we already navigated away?
2534             // Maybe there are bugs because of that, or extra work we can skip because
2535             // the new page is ready.
2536 
2537             m_client.forceLayoutForNonHTML();
2538 
2539             // If the user had a scroll point, scroll to it, overriding the anchor point if any.
2540             if (m_frame.page()) {
2541                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2542                     history().restoreScrollPositionAndViewState();
2543             }
2544 
2545             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2546                 return;
2547 
2548             m_progressTracker-&gt;progressCompleted();
2549             Page* page = m_frame.page();
2550             if (page) {
2551                 if (m_frame.isMainFrame()) {
2552                     tracePoint(MainResourceLoadDidEnd);
2553                     page-&gt;didFinishLoad();
2554                 }
2555             }
2556 
2557             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2558 
2559             AXObjectCache::AXLoadingEvent loadingEvent;
2560             if (!error.isNull()) {
2561                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load with error (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());
2562                 m_client.dispatchDidFailLoad(error);
2563                 loadingEvent = AXObjectCache::AXLoadingFailed;
2564             } else {
2565                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
2566 #if ENABLE(DATA_DETECTION)
2567                 auto* document = m_frame.document();
2568                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2569                     if (auto* documentElement = document-&gt;documentElement()) {
2570                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2571                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2572                         if (m_frame.isMainFrame())
2573                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2574                     }
2575                 }
2576 #endif
2577                 m_client.dispatchDidFinishLoad();
2578                 loadingEvent = AXObjectCache::AXLoadingFinished;
2579             }
2580 
2581             // Notify accessibility.
2582             if (auto* document = m_frame.document()) {
2583                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2584                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2585             }
2586 
2587             // The above calls to dispatchDidFinishLoad() might have detached the Frame
2588             // from its Page and also might have caused Page to be deleted.
2589             // Don&#39;t assume &#39;page&#39; is still available to use.
2590             if (m_frame.isMainFrame() &amp;&amp; m_frame.page()) {
2591                 ASSERT(&amp;m_frame.page()-&gt;mainFrame() == &amp;m_frame);
2592                 m_frame.page()-&gt;diagnosticLoggingClient().logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageLoadedKey(), emptyString(), error.isNull() ? DiagnosticLoggingResultPass : DiagnosticLoggingResultFail, ShouldSample::Yes);
2593             }
2594 
2595             return;
2596         }
2597 
2598         case FrameStateComplete:
2599             m_loadType = FrameLoadType::Standard;
2600             frameLoadCompleted();
2601             return;
2602     }
2603 
2604     ASSERT_NOT_REACHED();
2605 }
2606 
2607 void FrameLoader::setOriginalURLForDownloadRequest(ResourceRequest&amp; request)
2608 {
2609     // FIXME: Rename firstPartyForCookies back to mainDocumentURL. It was a mistake to think that it was only used for cookies.
2610     // The originalURL is defined as the URL of the page where the download was initiated.
2611     URL originalURL;
2612     auto* initiator = m_frame.document();
2613     if (initiator) {
2614         originalURL = initiator-&gt;firstPartyForCookies();
2615         // If there is no main document URL, it means that this document is newly opened and just for download purpose.
2616         // In this case, we need to set the originalURL to this document&#39;s opener&#39;s main document URL.
2617         if (originalURL.isEmpty() &amp;&amp; opener() &amp;&amp; opener()-&gt;document()) {
2618             originalURL = opener()-&gt;document()-&gt;firstPartyForCookies();
2619             initiator = opener()-&gt;document();
2620         }
2621     }
2622     // If the originalURL is the same as the requested URL, we are processing a download
2623     // initiated directly without a page and do not need to specify the originalURL.
2624     if (originalURL == request.url())
2625         request.setFirstPartyForCookies(URL());
2626     else
2627         request.setFirstPartyForCookies(originalURL);
2628     addSameSiteInfoToRequestIfNeeded(request, initiator);
2629 }
2630 
2631 void FrameLoader::didReachLayoutMilestone(OptionSet&lt;LayoutMilestone&gt; milestones)
2632 {
2633     ASSERT(m_frame.isMainFrame());
2634 
2635     m_client.dispatchDidReachLayoutMilestone(milestones);
2636 }
2637 
2638 void FrameLoader::didFirstLayout()
2639 {
2640 #if PLATFORM(IOS_FAMILY)
2641     // Only send layout-related delegate callbacks synchronously for the main frame to
2642     // avoid reentering layout for the main frame while delivering a layout-related delegate
2643     // callback for a subframe.
2644     if (&amp;m_frame != &amp;m_frame.page()-&gt;mainFrame())
2645         return;
2646 #endif
2647     if (m_frame.page() &amp;&amp; isBackForwardLoadType(m_loadType))
2648         history().restoreScrollPositionAndViewState();
2649 
2650     if (m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2651         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2652 }
2653 
2654 void FrameLoader::frameLoadCompleted()
2655 {
2656     // Note: Can be called multiple times.
2657 
2658     m_client.frameLoadCompleted();
2659 
2660     history().updateForFrameLoadCompleted();
2661 
2662     // After a canceled provisional load, firstLayoutDone is false.
2663     // Reset it to true if we&#39;re displaying a page.
2664     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2665         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2666 }
2667 
2668 void FrameLoader::detachChildren()
2669 {
2670     // detachChildren() will fire the unload event in each subframe and the
2671     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2672     // this event is being fired in its subframes:
2673     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2674     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2675 
<a name="35" id="anc35"></a><span class="line-added">2676     // detachChildren() will fire the unload event in each subframe and the</span>
<span class="line-added">2677     // HTML specification states that navigations should be prevented during the prompt to unload algorithm:</span>
<span class="line-added">2678     // https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate</span>
<span class="line-added">2679     std::unique_ptr&lt;NavigationDisabler&gt; navigationDisabler;</span>
<span class="line-added">2680     if (m_frame.isMainFrame())</span>
<span class="line-added">2681         navigationDisabler = makeUnique&lt;NavigationDisabler&gt;(&amp;m_frame);</span>
<span class="line-added">2682 </span>
2683     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2684     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2685     // allow loading of subframes at this point.
2686     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2687 
2688     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2689     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2690     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2691         childrenToDetach.uncheckedAppend(*child);
2692     for (auto&amp; child : childrenToDetach)
2693         child-&gt;loader().detachFromParent();
2694 }
2695 
2696 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2697 {
2698     child.tree().detachFromParent();
2699 
2700     child.setView(nullptr);
2701     if (child.ownerElement() &amp;&amp; child.page())
2702         child.page()-&gt;decrementSubframeCount();
2703     child.willDetachPage();
2704     child.detachFromPage();
2705 
2706     m_frame.tree().removeChild(child);
2707 }
2708 
2709 // Called every time a resource is completely loaded or an error is received.
2710 void FrameLoader::checkLoadComplete()
2711 {
2712     m_shouldCallCheckLoadComplete = false;
2713 
2714     if (!m_frame.page())
2715         return;
2716 
2717     ASSERT(m_client.hasWebView());
2718 
2719     // FIXME: Always traversing the entire frame tree is a bit inefficient, but
2720     // is currently needed in order to null out the previous history item for all frames.
2721     Vector&lt;Ref&lt;Frame&gt;, 16&gt; frames;
2722     for (Frame* frame = &amp;m_frame.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2723         frames.append(*frame);
2724 
2725     // To process children before their parents, iterate the vector backwards.
2726     for (auto frame = frames.rbegin(); frame != frames.rend(); ++frame) {
2727         if ((*frame)-&gt;page())
2728             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2729     }
2730 }
2731 
2732 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2733 {
2734     if (!recurse)
2735         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2736 
2737     int count = 0;
2738     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2739         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2740     return count;
2741 }
2742 
2743 String FrameLoader::userAgent(const URL&amp; url) const
2744 {
2745     String userAgent;
2746 
2747     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader())
2748         userAgent = documentLoader-&gt;customUserAgent();
2749 
2750     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2751 
2752     if (!userAgent.isEmpty())
2753         return userAgent;
2754 
2755     return m_client.userAgent(url);
2756 }
2757 
2758 String FrameLoader::userAgentForJavaScript(const URL&amp; url) const
2759 {
2760     String userAgent;
2761 
2762     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2763         if (m_frame.settings().needsSiteSpecificQuirks())
2764             userAgent = documentLoader-&gt;customJavaScriptUserAgentAsSiteSpecificQuirks();
2765         if (userAgent.isEmpty())
2766             userAgent = documentLoader-&gt;customUserAgent();
2767     }
2768 
2769     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2770 
2771     if (!userAgent.isEmpty())
2772         return userAgent;
2773 
2774     return m_client.userAgent(url);
2775 }
2776 
2777 String FrameLoader::navigatorPlatform() const
2778 {
2779     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2780         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2781         if (!customNavigatorPlatform.isEmpty())
2782             return customNavigatorPlatform;
2783     }
2784     return String();
2785 }
2786 
2787 void FrameLoader::dispatchOnloadEvents()
2788 {
2789     m_client.dispatchDidDispatchOnloadEvents();
2790 
2791     if (documentLoader())
2792         documentLoader()-&gt;dispatchOnloadEvents();
2793 }
2794 
2795 void FrameLoader::frameDetached()
2796 {
2797     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2798     Ref&lt;Frame&gt; protectedFrame(m_frame);
2799 
2800     if (m_checkTimer.isActive()) {
2801         m_checkTimer.stop();
2802         checkCompletenessNow();
2803     }
2804 
2805     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2806         stopAllLoadersAndCheckCompleteness();
2807         m_frame.document()-&gt;stopActiveDOMObjects();
2808     }
2809 
2810     detachFromParent();
2811 }
2812 
2813 void FrameLoader::detachFromParent()
2814 {
2815     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2816     Ref&lt;Frame&gt; protect(m_frame);
2817 
2818     closeURL();
2819     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2820     detachChildren();
2821     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2822         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the page cache,
2823         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2824         // handlers might start a new subresource load in this frame.
<a name="36" id="anc36"></a><span class="line-modified">2825         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);</span>
2826     }
2827 
2828     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2829 
2830     detachViewsAndDocumentLoader();
2831 
2832     m_progressTracker = nullptr;
2833 
2834     if (Frame* parent = m_frame.tree().parent()) {
2835         parent-&gt;loader().closeAndRemoveChild(m_frame);
2836         parent-&gt;loader().scheduleCheckCompleted();
2837         parent-&gt;loader().scheduleCheckLoadComplete();
2838     } else {
2839         m_frame.setView(nullptr);
2840         m_frame.willDetachPage();
2841         m_frame.detachFromPage();
2842     }
2843 }
2844 
2845 void FrameLoader::detachViewsAndDocumentLoader()
2846 {
2847     m_client.detachedFromParent2();
2848     setDocumentLoader(nullptr);
2849     m_client.detachedFromParent3();
2850 }
2851 
2852 void FrameLoader::addExtraFieldsToSubresourceRequest(ResourceRequest&amp; request)
2853 {
2854     addExtraFieldsToRequest(request, m_loadType, false);
2855 }
2856 
2857 void FrameLoader::addExtraFieldsToMainResourceRequest(ResourceRequest&amp; request)
2858 {
2859     // FIXME: Using m_loadType seems wrong for some callers.
2860     // If we are only preparing to load the main resource, that is previous load&#39;s load type!
2861     addExtraFieldsToRequest(request, m_loadType, true);
2862 
2863     // Upgrade-Insecure-Requests should only be added to main resource requests
2864     addHTTPUpgradeInsecureRequestsIfNeeded(request);
2865 }
2866 
2867 ResourceRequestCachePolicy FrameLoader::defaultRequestCachingPolicy(const ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2868 {
2869     if (m_overrideCachePolicyForTesting)
2870         return m_overrideCachePolicyForTesting.value();
2871 
2872     if (isMainResource) {
2873         if (isReload(loadType) || request.isConditional())
2874             return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2875 
2876         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2877     }
2878 
2879     if (request.isConditional())
2880         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
2881 
2882     if (documentLoader()-&gt;isLoadingInAPISense()) {
2883         // If we inherit cache policy from a main resource, we use the DocumentLoader&#39;s
2884         // original request cache policy for two reasons:
2885         // 1. For POST requests, we mutate the cache policy for the main resource,
2886         //    but we do not want this to apply to subresources
2887         // 2. Delegates that modify the cache policy using willSendRequest: should
2888         //    not affect any other resources. Such changes need to be done
2889         //    per request.
2890         ResourceRequestCachePolicy mainDocumentOriginalCachePolicy = documentLoader()-&gt;originalRequest().cachePolicy();
2891         // Back-forward navigations try to load main resource from cache only to avoid re-submitting form data, and start over (with a warning dialog) if that fails.
2892         // This policy is set on initial request too, but should not be inherited.
2893         return (mainDocumentOriginalCachePolicy == ResourceRequestCachePolicy::ReturnCacheDataDontLoad) ? ResourceRequestCachePolicy::ReturnCacheDataElseLoad : mainDocumentOriginalCachePolicy;
2894     }
2895 
2896     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
2897 }
2898 
2899 void FrameLoader::addExtraFieldsToRequest(ResourceRequest&amp; request, FrameLoadType loadType, bool isMainResource)
2900 {
2901     // If the request came from a previous process due to process-swap-on-navigation then we should not modify the request.
2902     if (m_currentLoadContinuingState == LoadContinuingState::ContinuingWithRequest)
2903         return;
2904 
2905     // Don&#39;t set the cookie policy URL if it&#39;s already been set.
2906     // But make sure to set it on all requests regardless of protocol, as it has significance beyond the cookie policy (&lt;rdar://problem/6616664&gt;).
2907     bool isMainFrameMainResource = isMainResource &amp;&amp; m_frame.isMainFrame();
2908     if (request.firstPartyForCookies().isEmpty()) {
2909         if (isMainFrameMainResource)
2910             request.setFirstPartyForCookies(request.url());
2911         else if (Document* document = m_frame.document())
2912             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2913     }
2914 
2915     if (request.isSameSiteUnspecified()) {
2916         auto* initiator = m_frame.document();
2917         if (isMainResource) {
2918             auto* ownerFrame = m_frame.tree().parent();
2919             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2920                 ownerFrame = m_opener;
2921             if (ownerFrame)
2922                 initiator = ownerFrame-&gt;document();
2923             ASSERT(ownerFrame || m_frame.isMainFrame());
2924         }
2925         addSameSiteInfoToRequestIfNeeded(request, initiator);
2926     }
2927     request.setIsTopSite(isMainFrameMainResource);
2928 
2929     Page* page = frame().page();
2930     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2931 
2932     if (page &amp;&amp; page-&gt;isResourceCachingDisabled()) {
2933         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2934         loadType = FrameLoadType::ReloadFromOrigin;
2935     } else if (!hasSpecificCachePolicy)
2936         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2937 
2938     // The remaining modifications are only necessary for HTTP and HTTPS.
2939     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2940         return;
2941 
2942     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2943         if (loadType == FrameLoadType::Reload)
2944             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;max-age=0&quot;);
2945         else if (loadType == FrameLoadType::ReloadFromOrigin) {
2946             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-cache&quot;);
2947             request.setHTTPHeaderField(HTTPHeaderName::Pragma, &quot;no-cache&quot;);
2948         }
2949     }
2950 
2951     if (m_overrideResourceLoadPriorityForTesting)
2952         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2953 
2954     applyUserAgentIfNeeded(request);
2955 
2956     if (isMainResource)
2957         request.setHTTPAccept(defaultAcceptHeader);
2958 
2959     // Make sure we send the Origin header.
2960     addHTTPOriginIfNeeded(request, String());
2961 
2962     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2963     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2964         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2965         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2966     }
2967 }
2968 
2969 void FrameLoader::addHTTPOriginIfNeeded(ResourceRequest&amp; request, const String&amp; origin)
2970 {
2971     if (!request.httpOrigin().isEmpty())
2972         return;  // Request already has an Origin header.
2973 
2974     // Don&#39;t send an Origin header for GET or HEAD to avoid privacy issues.
2975     // For example, if an intranet page has a hyperlink to an external web
2976     // site, we don&#39;t want to include the Origin of the request because it
2977     // will leak the internal host name. Similar privacy concerns have lead
2978     // to the widespread suppression of the Referer header at the network
2979     // layer.
2980     if (request.httpMethod() == &quot;GET&quot; || request.httpMethod() == &quot;HEAD&quot;)
2981         return;
2982 
2983     // For non-GET and non-HEAD methods, always send an Origin header so the
2984     // server knows we support this feature.
2985 
2986     if (origin.isEmpty()) {
2987         // If we don&#39;t know what origin header to attach, we attach the value
2988         // for an empty origin.
2989         request.setHTTPOrigin(SecurityOrigin::createUnique()-&gt;toString());
2990         return;
2991     }
2992 
2993     request.setHTTPOrigin(origin);
2994 }
2995 
2996 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
2997 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
2998 // as same-site. This matches the behavior of Chrome and Firefox.
2999 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
3000 {
3001     if (!request.isSameSiteUnspecified())
3002         return;
3003     if (!initiator) {
3004         request.setIsSameSite(true);
3005         return;
3006     }
3007     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3008         request.setIsSameSite(true);
3009         return;
3010     }
<a name="37" id="anc37"></a><span class="line-modified">3011     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));</span>
3012 }
3013 
3014 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3015 {
3016     if (request.url().protocolIs(&quot;https&quot;)) {
3017         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3018         return;
3019     }
3020 
3021     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3022 }
3023 
3024 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3025 {
3026     RELEASE_LOG_IF_ALLOWED(&quot;loadPostRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3027 
3028     String frameName = request.frameName();
3029     LockHistory lockHistory = request.lockHistory();
3030     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3031     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
3032 
3033     const ResourceRequest&amp; inRequest = request.resourceRequest();
3034     const URL&amp; url = inRequest.url();
3035     const String&amp; contentType = inRequest.httpContentType();
3036     String origin = inRequest.httpOrigin();
3037 
3038     ResourceRequest workingResourceRequest(url);
3039 
3040     if (!referrer.isEmpty())
3041         workingResourceRequest.setHTTPReferrer(referrer);
3042     workingResourceRequest.setHTTPOrigin(origin);
3043     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3044     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3045     workingResourceRequest.setHTTPContentType(contentType);
3046     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3047 
3048     if (Document* document = m_frame.document())
3049         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3050 
3051     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3052 
3053     if (!frameName.isEmpty()) {
3054         // The search for a target frame is done earlier in the case of form submission.
3055         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
<a name="38" id="anc38"></a><span class="line-modified">3056             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));</span>
3057             return;
3058         }
3059 
3060         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
3061             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3062             completionHandler();
3063         });
3064         return;
3065     }
3066 
3067     // must grab this now, since this load may stop the previous load and clear this flag
3068     bool isRedirect = m_quickRedirectComing;
<a name="39" id="anc39"></a><span class="line-modified">3069     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {</span>
3070         if (isRedirect) {
3071             m_quickRedirectComing = false;
3072             if (m_provisionalDocumentLoader)
3073                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3074             else if (m_policyDocumentLoader)
3075                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3076         }
3077         completionHandler();
3078     });
3079 }
3080 
3081 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3082 {
3083     ASSERT(m_frame.document());
3084     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3085 
3086     ResourceRequest initialRequest = request;
3087     initialRequest.setTimeoutInterval(10);
3088 
3089     if (!referrer.isEmpty())
3090         initialRequest.setHTTPReferrer(referrer);
3091     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3092 
3093     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3094 
3095     addExtraFieldsToSubresourceRequest(initialRequest);
3096 
3097     unsigned long identifier = 0;
3098     ResourceRequest newRequest(initialRequest);
3099     requestFromDelegate(newRequest, identifier, error);
3100 
3101 #if ENABLE(CONTENT_EXTENSIONS)
3102     if (error.isNull()) {
3103         if (auto* page = m_frame.page()) {
3104             if (m_documentLoader) {
<a name="40" id="anc40"></a><span class="line-modified">3105                 auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(newRequest.url(), ContentExtensions::ResourceType::Raw, *m_documentLoader);</span>
<span class="line-modified">3106                 bool blockedLoad = results.summary.blockedLoad;</span>
<span class="line-modified">3107                 ContentExtensions::applyResultsToRequest(WTFMove(results), page, newRequest);</span>
<span class="line-added">3108                 if (blockedLoad) {</span>
3109                     newRequest = { };
3110                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3111                     response = { };
3112                     data = nullptr;
3113                 }
3114             }
3115         }
3116     }
3117 #endif
3118 
3119     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3120 
3121     if (error.isNull()) {
3122         ASSERT(!newRequest.isNull());
3123 
3124         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3125             Vector&lt;char&gt; buffer;
3126             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3127             data = SharedBuffer::create(WTFMove(buffer));
3128             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
3129             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response);
3130         }
3131     }
3132     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3133     return identifier;
3134 }
3135 
3136 const ResourceRequest&amp; FrameLoader::originalRequest() const
3137 {
3138     return activeDocumentLoader()-&gt;originalRequestCopy();
3139 }
3140 
3141 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3142 {
3143     // Retain because the stop may release the last reference to it.
3144     Ref&lt;Frame&gt; protect(m_frame);
3145 
3146     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3147     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3148     // that both data sources on the frame are either this or nil.
3149     stop();
3150     if (m_client.shouldFallBack(error))
3151         handleFallbackContent();
3152 
3153     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3154         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3155             m_submittedFormURL = URL();
3156 
3157         // We might have made a page cache item, but now we&#39;re bailing out due to an error before we ever
3158         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3159         // so that the existing view (that wenever got far enough to replace) can continue being used.
3160         history().invalidateCurrentItemCachedPage();
3161 
3162         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3163         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3164         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3165         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3166         // has ended.
3167         if (m_sentRedirectNotification)
3168             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3169     }
3170 
3171     checkCompleted();
3172     if (m_frame.page())
3173         checkLoadComplete();
3174 }
3175 
3176 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3177 {
3178     m_quickRedirectComing = false;
3179 
3180     if (!shouldContinue)
3181         return;
3182 
3183     // Calling stopLoading() on the provisional document loader can cause the underlying
3184     // frame to be deallocated.
3185     Ref&lt;Frame&gt; protectedFrame(m_frame);
3186 
3187     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3188     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3189         m_provisionalDocumentLoader-&gt;stopLoading();
3190         setProvisionalDocumentLoader(nullptr);
3191     }
3192 
3193     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3194     loadInSameDocument(request.url(), 0, !isRedirect);
3195 }
3196 
3197 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3198 {
3199     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3200     // currently displaying a frameset, or if the URL does not have a fragment.
3201     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3202 
3203     // FIXME: What about load types other than Standard and Reload?
3204 
3205     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3206         &amp;&amp; !isReload(loadType)
3207         &amp;&amp; loadType != FrameLoadType::Same
3208         &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache
3209         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3210         // We don&#39;t want to just scroll if a link from within a
3211         // frameset is trying to reload the frameset into _top.
3212         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3213 }
3214 
3215 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3216 {
3217     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3218 }
3219 
3220 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3221 {
3222     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3223 }
3224 
3225 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3226 {
3227     FrameView* view = m_frame.view();
3228     if (!view)
3229         return;
3230 
3231     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem()))
3232         view-&gt;scrollToFragment(url);
3233 }
3234 
3235 bool FrameLoader::shouldClose()
3236 {
3237     Page* page = m_frame.page();
3238     if (!page)
3239         return true;
3240     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3241         return true;
3242 
3243     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3244     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3245     targetFrames.append(m_frame);
3246     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3247         targetFrames.append(*child);
3248 
3249     bool shouldClose = false;
3250     {
3251         NavigationDisabler navigationDisabler(&amp;m_frame);
3252         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3253         size_t i;
3254 
3255         for (i = 0; i &lt; targetFrames.size(); i++) {
3256             if (!targetFrames[i]-&gt;tree().isDescendantOf(&amp;m_frame))
3257                 continue;
3258             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3259                 break;
3260         }
3261 
3262         if (i == targetFrames.size())
3263             shouldClose = true;
3264     }
3265 
3266     if (!shouldClose)
3267         m_submittedFormURL = URL();
3268 
3269     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3270     return shouldClose;
3271 }
3272 
3273 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3274 {
3275     if (!m_frame.document())
3276         return;
3277 
<a name="41" id="anc41"></a><span class="line-added">3278     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)</span>
<span class="line-added">3279         return;</span>
<span class="line-added">3280 </span>
3281     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3282     ForbidPromptsScope forbidPrompts(m_frame.page());
3283     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3284 
3285     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3286         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3287         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3288             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3289         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3290             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3291                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3292                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache), m_frame.document());
3293             }
3294 
3295             // FIXME: update Page Visibility state here.
3296             // https://bugs.webkit.org/show_bug.cgi?id=116770
3297 
3298             if (m_frame.document()-&gt;pageCacheState() == Document::NotInPageCache) {
3299                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3300                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3301                 // while dispatching the event, so protect it to prevent writing the end
3302                 // time into freed memory.
3303                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3304                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3305                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3306                     auto&amp; timing = documentLoader-&gt;timing();
3307                     timing.markUnloadEventStart();
3308                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3309                     timing.markUnloadEventEnd();
3310                 } else
3311                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3312             }
3313         }
3314         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3315         m_wasUnloadEventEmitted = true;
3316     }
3317 
3318     // Dispatching the unload event could have made m_frame.document() null.
3319     if (!m_frame.document())
3320         return;
3321 
3322     if (m_frame.document()-&gt;pageCacheState() != Document::NotInPageCache)
3323         return;
3324 
3325     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3326     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3327         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3328 
3329     if (!keepEventListeners)
3330         m_frame.document()-&gt;removeAllEventListeners();
3331 }
3332 
3333 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3334 {
3335     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3336     if (document.isSandboxed(SandboxModals))
3337         return false;
3338 
3339     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3340     // Web pages can request we ask for confirmation before navigating by:
3341     // - Cancelling the BeforeUnloadEvent (modern way)
3342     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3343     // - Returning a non-empty string from the event handler, which is then set as returnValue
3344     //   attribute on the BeforeUnloadEvent.
3345     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3346 }
3347 
3348 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3349 {
3350     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3351     if (!domWindow)
3352         return true;
3353 
3354     RefPtr&lt;Document&gt; document = m_frame.document();
3355     if (!document-&gt;bodyOrFrameset())
3356         return true;
3357 
3358     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
<a name="42" id="anc42"></a>
3359 
3360     {
<a name="43" id="anc43"></a><span class="line-added">3361         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);</span>
3362         ForbidPromptsScope forbidPrompts(m_frame.page());
3363         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3364     }
3365 
<a name="44" id="anc44"></a>

3366     if (!beforeUnloadEvent-&gt;defaultPrevented())
3367         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3368 
3369     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3370         return true;
3371 
3372     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3373     // this frame is not allowed to cause another one to be shown.
3374     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3375         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3376         return true;
3377     }
3378 
3379     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3380     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3381     if (frameLoaderBeingNavigated != this) {
3382         Frame* parentFrame = m_frame.tree().parent();
3383         while (parentFrame) {
3384             Document* parentDocument = parentFrame-&gt;document();
3385             if (!parentDocument)
3386                 return true;
3387             if (!m_frame.document() || !m_frame.document()-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin())) {
3388                 document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show beforeunload confirmation dialog on behalf of a frame with different security origin. Protocols, domains, and ports must match.&quot;_s);
3389                 return true;
3390             }
3391 
3392             if (&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated)
3393                 break;
3394 
3395             parentFrame = parentFrame-&gt;tree().parent();
3396         }
3397 
3398         // The navigatingFrameLoader should always be in our ancestory.
3399         ASSERT(parentFrame);
3400         ASSERT(&amp;parentFrame-&gt;loader() == frameLoaderBeingNavigated);
3401     }
3402 
3403     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3404 
3405     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3406     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3407 }
3408 
3409 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3410 {
3411     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3412     // nil policyDataSource because loading the alternate page will have passed
3413     // through this method already, nested; otherwise, policyDataSource should still be set.
3414     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3415 
3416     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3417 
3418     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3419     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3420 
3421     if (!canContinue) {
3422         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;
3423             &quot;frame = %p, &quot;
3424             &quot;main = %d, &quot;
3425             &quot;allowNavigationToInvalidURL = %d, &quot;
3426             &quot;requestURLIsValid = %d, &quot;
3427             &quot;navigationPolicyDecision = %d)&quot;,
3428             &amp;m_frame,
3429             m_frame.isMainFrame(),
3430             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3431             request.url().isValid(),
3432             static_cast&lt;int&gt;(navigationPolicyDecision));
3433 
3434         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3435         // need to report that the client redirect was cancelled.
3436         // FIXME: The client should be told about ignored non-quick redirects, too.
3437         if (m_quickRedirectComing)
3438             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3439 
3440         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3441             stopAllLoaders();
3442             m_checkTimer.stop();
3443         }
3444 
3445         setPolicyDocumentLoader(nullptr);
3446         checkCompleted();
3447 
3448         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3449             checkLoadComplete();
3450 
3451         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3452         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3453         // we only do this when punting a navigation for the target frame or top-level frame.
3454         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3455             if (Page* page = m_frame.page()) {
3456                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3457                     page-&gt;backForward().setCurrentItem(*resetItem);
3458             }
3459         }
3460         return;
3461     }
3462 
3463     FrameLoadType type = policyChecker().loadType();
3464     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3465     stopAllLoaders(ShouldNotClearProvisionalItem);
3466 
3467     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3468     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3469     if (!m_frame.page()) {
3470         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3471         return;
3472     }
3473 
3474     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3475     m_loadType = type;
3476     setState(FrameStateProvisional);
3477 
3478     setPolicyDocumentLoader(nullptr);
3479 
3480     if (isBackForwardLoadType(type)) {
3481         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
<a name="45" id="anc45"></a><span class="line-modified">3482         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInPageCache()) {</span>
3483             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3484             loadProvisionalItemFromCachedPage();
3485             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3486             return;
3487         }
3488         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3489     }
3490 
3491     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3492         if (!m_provisionalDocumentLoader) {
3493             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy completionHandler: Frame load canceled #1 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3494             return;
3495         }
3496 
3497         prepareForLoadStart();
3498 
3499         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3500         // so we need to null check it again.
3501         if (!m_provisionalDocumentLoader) {
3502             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Frame load canceled #2 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3503             return;
3504         }
3505 
3506         DocumentLoader* activeDocLoader = activeDocumentLoader();
3507         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
3508             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Main frame already being loaded (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3509             return;
3510         }
3511 
3512         m_loadingFromCachedPage = false;
3513 
3514         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3515     };
3516 
3517     if (!formState) {
3518         completionHandler();
3519         return;
3520     }
3521 
3522     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3523 }
3524 
3525 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
3526     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)
3527 {
3528     if (shouldContinue != ShouldContinue::Yes)
3529         return;
3530 
3531     Ref&lt;Frame&gt; frame(m_frame);
3532     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3533     if (!mainFrame)
3534         return;
3535 
3536     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3537     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3538         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3539 
3540     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3541         mainFrame-&gt;tree().setName(frameName);
3542 
3543     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3544     mainFrame-&gt;loader().m_client.dispatchShow();
3545     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3546         mainFrame-&gt;loader().setOpener(frame.ptr());
3547         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3548     }
3549 
3550     NavigationAction newAction { *frame-&gt;document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, action.shouldOpenExternalURLsPolicy(), nullptr, action.downloadAttribute() };
3551     mainFrame-&gt;loader().loadWithNavigationAction(request, WTFMove(newAction), LockHistory::No, FrameLoadType::Standard, formState, allowNavigationToInvalidURL);
3552 }
3553 
3554 void FrameLoader::requestFromDelegate(ResourceRequest&amp; request, unsigned long&amp; identifier, ResourceError&amp; error)
3555 {
3556     ASSERT(!request.isNull());
3557 
3558     identifier = 0;
3559     if (Page* page = m_frame.page()) {
3560         identifier = page-&gt;progress().createUniqueIdentifier();
3561         notifier().assignIdentifierToInitialRequest(identifier, m_documentLoader.get(), request);
3562     }
3563 
3564     ResourceRequest newRequest(request);
3565     notifier().dispatchWillSendRequest(m_documentLoader.get(), identifier, newRequest, ResourceResponse());
3566 
3567     if (newRequest.isNull())
3568         error = cancelledError(request);
3569     else
3570         error = ResourceError();
3571 
3572     request = newRequest;
3573 }
3574 
3575 void FrameLoader::loadedResourceFromMemoryCache(CachedResource&amp; resource, ResourceRequest&amp; newRequest, ResourceError&amp; error)
3576 {
3577     Page* page = m_frame.page();
3578     if (!page)
3579         return;
3580 
3581     if (!resource.shouldSendResourceLoadCallbacks() || m_documentLoader-&gt;haveToldClientAboutLoad(resource.url()))
3582         return;
3583 
3584     // Main resource delegate messages are synthesized in MainResourceLoader, so we must not send them here.
3585     if (resource.type() == CachedResource::Type::MainResource)
3586         return;
3587 
3588     if (!page-&gt;areMemoryCacheClientCallsEnabled()) {
3589         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3590         m_documentLoader-&gt;recordMemoryCacheLoadForFutureClientNotification(resource.resourceRequest());
3591         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3592         return;
3593     }
3594 
3595     if (m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), newRequest, resource.response(), resource.encodedSize())) {
3596         InspectorInstrumentation::didLoadResourceFromMemoryCache(*page, m_documentLoader.get(), &amp;resource);
3597         m_documentLoader-&gt;didTellClientAboutLoad(resource.url());
3598         return;
3599     }
3600 
3601     unsigned long identifier;
3602     requestFromDelegate(newRequest, identifier, error);
3603 
3604     ResourceResponse response = resource.response();
3605     response.setSource(ResourceResponse::Source::MemoryCache);
3606     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, newRequest, response, 0, resource.encodedSize(), 0, error);
3607 }
3608 
3609 void FrameLoader::applyUserAgentIfNeeded(ResourceRequest&amp; request)
3610 {
3611     if (!request.hasHTTPHeaderField(HTTPHeaderName::UserAgent)) {
3612         String userAgent = this-&gt;userAgent(request.url());
3613         ASSERT(!userAgent.isNull());
3614         request.setHTTPUserAgent(userAgent);
3615     }
3616 }
3617 
3618 bool FrameLoader::shouldInterruptLoadForXFrameOptions(const String&amp; content, const URL&amp; url, unsigned long requestIdentifier)
3619 {
3620     Frame&amp; topFrame = m_frame.tree().top();
3621     if (&amp;m_frame == &amp;topFrame)
3622         return false;
3623 
3624     XFrameOptionsDisposition disposition = parseXFrameOptionsHeader(content);
3625 
3626     switch (disposition) {
3627     case XFrameOptionsSameOrigin: {
3628         auto origin = SecurityOrigin::create(url);
3629         if (!origin-&gt;isSameSchemeHostPort(topFrame.document()-&gt;securityOrigin()))
3630             return true;
3631         for (Frame* frame = m_frame.tree().parent(); frame; frame = frame-&gt;tree().parent()) {
3632             if (!origin-&gt;isSameSchemeHostPort(frame-&gt;document()-&gt;securityOrigin()))
3633                 return true;
3634         }
3635         return false;
3636     }
3637     case XFrameOptionsDeny:
3638         return true;
3639     case XFrameOptionsAllowAll:
3640         return false;
3641     case XFrameOptionsConflict:
3642         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3643         return true;
3644     case XFrameOptionsInvalid:
3645         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3646         return false;
3647     case XFrameOptionsNone:
3648         return false;
3649     }
3650     ASSERT_NOT_REACHED();
3651     return false;
3652 }
3653 
3654 void FrameLoader::loadProvisionalItemFromCachedPage()
3655 {
3656     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
3657     LOG(PageCache, &quot;WebCorePageCache: Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());
3658 
3659     prepareForLoadStart();
3660 
3661     m_loadingFromCachedPage = true;
3662 
3663     // Should have timing data from previous time(s) the page was shown.
3664     ASSERT(provisionalLoader-&gt;timing().startTime());
3665     provisionalLoader-&gt;resetTiming();
3666     provisionalLoader-&gt;timing().markStartTime();
3667 
3668     provisionalLoader-&gt;setCommitted(true);
3669     commitProvisionalLoad();
3670 }
3671 
3672 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3673 {
3674     if (!history().currentItem())
3675         return false;
3676     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3677 }
3678 
3679 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3680 {
3681     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3682         return false;
3683     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3684     if (!ownerElement)
3685         return false;
3686     if (!ownerElement-&gt;hasTagName(iframeTag))
3687         return false;
3688     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3689 }
3690 
<a name="46" id="anc46"></a><span class="line-modified">3691 Frame* FrameLoader::findFrameForNavigation(const AtomString&amp; name, Document* activeDocument)</span>
3692 {
3693     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3694     if (!activeDocument)
3695         activeDocument = m_frame.document();
3696 
3697     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3698 
3699     if (!activeDocument-&gt;canNavigate(frame))
3700         return nullptr;
3701 
3702     return frame;
3703 }
3704 
3705 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3706 {
3707     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3708 
3709     Ref&lt;Frame&gt; protect(m_frame);
3710 
3711     // Save user view state to the current history item here since we don&#39;t do a normal load.
3712     // FIXME: Does form state need to be saved here too?
3713     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3714     if (FrameView* view = m_frame.view())
3715         view-&gt;setWasScrolledByUser(false);
3716 
3717     history().setCurrentItem(item);
3718 
3719     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3720     loadInSameDocument(item.url(), item.stateObject(), false);
3721 
3722     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3723     history().restoreScrollPositionAndViewState();
3724 }
3725 
3726 // FIXME: This function should really be split into a couple pieces, some of
3727 // which should be methods of HistoryController and some of which should be
3728 // methods of FrameLoader.
<a name="47" id="anc47"></a><span class="line-modified">3729 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3730 {
3731     RELEASE_LOG_IF_ALLOWED(&quot;loadDifferentDocumentItem: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3732 
3733     Ref&lt;Frame&gt; protectedFrame(m_frame);
3734 
3735     // History items should not be reported to the parent.
3736     m_shouldReportResourceTimingToParentFrame = false;
3737 
3738     // Remember this item so we can traverse any child items as child frames load
3739     history().setProvisionalItem(&amp;item);
3740 
3741     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3742 
3743     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3744 
3745     if (CachedPage* cachedPage = PageCache::singleton().get(item, m_frame.page())) {
3746         auto documentLoader = cachedPage-&gt;documentLoader();
3747         m_client.updateCachedDocumentLoader(*documentLoader);
3748 
3749         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3750         action.setTargetBackForwardItem(item);
<a name="48" id="anc48"></a><span class="line-added">3751         action.setSourceBackForwardItem(fromItem);</span>
3752         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3753 
3754         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3755         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3756         return;
3757     }
3758 
3759     URL itemURL = item.url();
3760     URL itemOriginalURL = item.originalURL();
3761     URL currentURL;
3762     if (documentLoader())
3763         currentURL = documentLoader()-&gt;url();
3764     RefPtr&lt;FormData&gt; formData = item.formData();
3765 
3766     ResourceRequest request(itemURL);
3767 
3768     if (!item.referrer().isNull())
3769         request.setHTTPReferrer(item.referrer());
3770 
3771     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3772     bool isFormSubmission = false;
3773     Event* event = nullptr;
3774 
3775     // If this was a repost that failed the page cache, we might try to repost the form.
3776     NavigationAction action;
3777     if (formData) {
<a name="49" id="anc49"></a>

3778         request.setHTTPMethod(&quot;POST&quot;);
3779         request.setHTTPBody(WTFMove(formData));
3780         request.setHTTPContentType(item.formContentType());
3781         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3782         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3783         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3784 
3785         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3786         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3787         addExtraFieldsToRequest(request, loadType, true);
3788 
3789         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3790         // We want to know this before talking to the policy delegate, since it affects whether
3791         // we show the DoYouReallyWantToRepost nag.
3792         //
3793         // This trick has a small bug (3123893) where we might find a cache hit, but then
3794         // have the item vanish when we try to use it in the ensuing nav.  This should be
3795         // extremely rare, but in that case the user will get an error on the navigation.
3796 
3797         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
3798             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataDontLoad);
3799             action = { *m_frame.document(), request, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3800         } else {
3801             request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3802             action = { *m_frame.document(), request, initiatedByMainFrame, NavigationType::FormResubmitted, shouldOpenExternalURLsPolicy, event };
3803         }
3804     } else {
3805         switch (loadType) {
3806         case FrameLoadType::Reload:
3807         case FrameLoadType::ReloadFromOrigin:
3808         case FrameLoadType::ReloadExpiredOnly:
3809             request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
3810             break;
3811         case FrameLoadType::Back:
3812         case FrameLoadType::Forward:
3813         case FrameLoadType::IndexedBackForward: {
3814 #if PLATFORM(COCOA)
3815             bool allowStaleData = true;
3816 #else
3817             bool allowStaleData = !item.wasRestoredFromSession();
3818 #endif
3819             if (allowStaleData)
3820                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3821             item.setWasRestoredFromSession(false);
3822             break;
3823         }
3824         case FrameLoadType::Standard:
3825         case FrameLoadType::RedirectWithLockedBackForwardList:
3826             break;
3827         case FrameLoadType::Same:
3828         case FrameLoadType::Replace:
3829             ASSERT_NOT_REACHED();
3830         }
3831 
3832         addExtraFieldsToRequest(request, loadType, true);
3833 
3834         ResourceRequest requestForOriginalURL(request);
3835         requestForOriginalURL.setURL(itemOriginalURL);
3836         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3837     }
3838 
3839     action.setTargetBackForwardItem(item);
<a name="50" id="anc50"></a><span class="line-added">3840     action.setSourceBackForwardItem(fromItem);</span>
3841 
3842     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3843 }
3844 
3845 // Loads content into this frame, as specified by history item
<a name="51" id="anc51"></a><span class="line-modified">3846 void FrameLoader::loadItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3847 {
3848     m_requestedHistoryItem = &amp;item;
3849     HistoryItem* currentItem = history().currentItem();
3850     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3851 
3852     if (sameDocumentNavigation)
3853         loadSameDocumentItem(item);
3854     else
<a name="52" id="anc52"></a><span class="line-modified">3855         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);</span>
3856 }
3857 
3858 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3859 {
3860     ASSERT(m_state == FrameStateProvisional);
3861     ASSERT(!m_loadingFromCachedPage);
3862     ASSERT(history().provisionalItem());
3863     ASSERT(history().provisionalItem()-&gt;formData());
3864     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3865 
3866     FrameLoadType loadType = m_loadType;
<a name="53" id="anc53"></a><span class="line-modified">3867     HistoryItem* item = history().provisionalItem();</span>
3868 
3869     stopAllLoaders(ShouldNotClearProvisionalItem);
<a name="54" id="anc54"></a><span class="line-modified">3870     if (item)</span>
<span class="line-added">3871         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>
<span class="line-added">3872     else {</span>
<span class="line-added">3873         ASSERT_NOT_REACHED();</span>
<span class="line-added">3874         RELEASE_LOG_ERROR(ResourceLoading, &quot;Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);</span>
<span class="line-added">3875     }</span>
3876 }
3877 
3878 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3879 {
3880     ResourceError error = m_client.cancelledError(request);
3881     error.setType(ResourceError::Type::Cancellation);
3882     return error;
3883 }
3884 
3885 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3886 {
3887     return m_client.blockedByContentBlockerError(request);
3888 }
3889 
3890 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3891 {
3892     ResourceError error = m_client.blockedError(request);
3893     error.setType(ResourceError::Type::Cancellation);
3894     return error;
3895 }
3896 
3897 #if ENABLE(CONTENT_FILTERING)
3898 ResourceError FrameLoader::blockedByContentFilterError(const ResourceRequest&amp; request) const
3899 {
3900     ResourceError error = m_client.blockedByContentFilterError(request);
3901     error.setType(ResourceError::Type::General);
3902     return error;
3903 }
3904 #endif
3905 
3906 #if PLATFORM(IOS_FAMILY)
3907 RetainPtr&lt;CFDictionaryRef&gt; FrameLoader::connectionProperties(ResourceLoader* loader)
3908 {
3909     return m_client.connectionProperties(loader-&gt;documentLoader(), loader-&gt;identifier());
3910 }
3911 #endif
3912 
3913 ReferrerPolicy FrameLoader::effectiveReferrerPolicy() const
3914 {
3915     if (auto* parentFrame = m_frame.tree().parent())
3916         return parentFrame-&gt;document()-&gt;referrerPolicy();
3917     if (m_opener)
3918         return m_opener-&gt;document()-&gt;referrerPolicy();
3919     return ReferrerPolicy::NoReferrerWhenDowngrade;
3920 }
3921 
3922 String FrameLoader::referrer() const
3923 {
3924     return m_documentLoader ? m_documentLoader-&gt;request().httpReferrer() : emptyString();
3925 }
3926 
3927 void FrameLoader::dispatchDidClearWindowObjectsInAllWorlds()
3928 {
3929     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript))
3930         return;
3931 
3932     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3933     ScriptController::getAllWorlds(worlds);
3934     for (auto&amp; world : worlds)
3935         dispatchDidClearWindowObjectInWorld(world);
3936 }
3937 
3938 void FrameLoader::dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp; world)
3939 {
3940     if (!m_frame.script().canExecuteScripts(NotAboutToExecuteScript) || !m_frame.windowProxy().existingJSWindowProxy(world))
3941         return;
3942 
3943     m_client.dispatchDidClearWindowObjectInWorld(world);
3944 
3945     if (Page* page = m_frame.page())
3946         page-&gt;inspectorController().didClearWindowObjectInWorld(m_frame, world);
3947 
3948     InspectorInstrumentation::didClearWindowObjectInWorld(m_frame, world);
3949 }
3950 
3951 void FrameLoader::dispatchGlobalObjectAvailableInAllWorlds()
3952 {
3953     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; worlds;
3954     ScriptController::getAllWorlds(worlds);
3955     for (auto&amp; world : worlds)
3956         m_client.dispatchGlobalObjectAvailable(world);
3957 }
3958 
3959 SandboxFlags FrameLoader::effectiveSandboxFlags() const
3960 {
3961     SandboxFlags flags = m_forcedSandboxFlags;
3962     if (Frame* parentFrame = m_frame.tree().parent())
3963         flags |= parentFrame-&gt;document()-&gt;sandboxFlags();
3964     if (HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement())
3965         flags |= ownerElement-&gt;sandboxFlags();
3966     return flags;
3967 }
3968 
3969 void FrameLoader::didChangeTitle(DocumentLoader* loader)
3970 {
3971     m_client.didChangeTitle(loader);
3972 
3973     if (loader == m_documentLoader) {
3974         // Must update the entries in the back-forward list too.
3975         history().setCurrentItemTitle(loader-&gt;title());
3976         // This must go through the WebFrame because it has the right notion of the current b/f item.
3977         m_client.setTitle(loader-&gt;title(), loader-&gt;urlForHistory());
3978         m_client.setMainFrameDocumentReady(true); // update observers with new DOMDocument
3979         m_client.dispatchDidReceiveTitle(loader-&gt;title());
3980     }
3981 
3982 #if ENABLE(REMOTE_INSPECTOR)
3983     if (m_frame.isMainFrame())
3984         m_frame.page()-&gt;remoteInspectorInformationDidChange();
3985 #endif
3986 }
3987 
3988 void FrameLoader::dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent)
3989 {
3990     if (m_stateMachine.creatingInitialEmptyDocument())
3991         return;
3992 
3993     m_client.dispatchDidCommitLoad(initialHasInsecureContent);
3994 
3995     if (m_frame.isMainFrame()) {
3996         m_frame.page()-&gt;resetSeenPlugins();
3997         m_frame.page()-&gt;resetSeenMediaEngines();
3998     }
3999 
4000     InspectorInstrumentation::didCommitLoad(m_frame, m_documentLoader.get());
4001 
4002 #if ENABLE(REMOTE_INSPECTOR)
4003     if (m_frame.isMainFrame())
4004         m_frame.page()-&gt;remoteInspectorInformationDidChange();
4005 #endif
4006 }
4007 
4008 void FrameLoader::tellClientAboutPastMemoryCacheLoads()
4009 {
4010     ASSERT(m_frame.page());
4011     ASSERT(m_frame.page()-&gt;areMemoryCacheClientCallsEnabled());
4012 
4013     if (!m_documentLoader)
4014         return;
4015 
4016     Vector&lt;ResourceRequest&gt; pastLoads;
4017     m_documentLoader-&gt;takeMemoryCacheLoadsForClientNotification(pastLoads);
4018 
4019     for (auto&amp; pastLoad : pastLoads) {
4020         CachedResource* resource = MemoryCache::singleton().resourceForRequest(pastLoad, m_frame.page()-&gt;sessionID());
4021 
4022         // FIXME: These loads, loaded from cache, but now gone from the cache by the time
4023         // Page::setMemoryCacheClientCallsEnabled(true) is called, will not be seen by the client.
4024         // Consider if there&#39;s some efficient way of remembering enough to deliver this client call.
4025         // We have the URL, but not the rest of the response or the length.
4026         if (!resource)
4027             continue;
4028 
4029         ResourceRequest request(resource-&gt;url());
4030         m_client.dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), request, resource-&gt;response(), resource-&gt;encodedSize());
4031     }
4032 }
4033 
4034 NetworkingContext* FrameLoader::networkingContext() const
4035 {
4036     return m_networkingContext.get();
4037 }
4038 
4039 void FrameLoader::loadProgressingStatusChanged()
4040 {
4041     if (auto* view = m_frame.mainFrame().view())
4042         view-&gt;loadProgressingStatusChanged();
4043 }
4044 
4045 void FrameLoader::forcePageTransitionIfNeeded()
4046 {
4047     m_client.forcePageTransitionIfNeeded();
4048 }
4049 
4050 void FrameLoader::clearTestingOverrides()
4051 {
4052     m_overrideCachePolicyForTesting = WTF::nullopt;
4053     m_overrideResourceLoadPriorityForTesting = WTF::nullopt;
4054     m_isStrictRawResourceValidationPolicyDisabledForTesting = false;
4055 }
4056 
4057 bool FrameLoader::isAlwaysOnLoggingAllowed() const
4058 {
4059     return frame().isAlwaysOnLoggingAllowed();
4060 }
4061 
4062 bool FrameLoaderClient::hasHTMLView() const
4063 {
4064     return true;
4065 }
4066 
4067 RefPtr&lt;Frame&gt; createWindow(Frame&amp; openerFrame, Frame&amp; lookupFrame, FrameLoadRequest&amp;&amp; request, const WindowFeatures&amp; features, bool&amp; created)
4068 {
4069     ASSERT(!features.dialog || request.frameName().isEmpty());
4070 
4071     created = false;
4072 
4073     // FIXME: Provide line number information with respect to the opener&#39;s document.
4074     if (WTF::protocolIsJavaScript(request.resourceRequest().url()) &amp;&amp; !openerFrame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(openerFrame.document()-&gt;url(), { }))
4075         return nullptr;
4076 
4077     if (!request.frameName().isEmpty() &amp;&amp; !equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;)) {
4078         if (RefPtr&lt;Frame&gt; frame = lookupFrame.loader().findFrameForNavigation(request.frameName(), openerFrame.document())) {
4079             if (!equalIgnoringASCIICase(request.frameName(), &quot;_self&quot;)) {
4080                 if (Page* page = frame-&gt;page())
4081                     page-&gt;chrome().focus();
4082             }
4083             return frame;
4084         }
4085     }
4086 
4087     // Sandboxed frames cannot open new auxiliary browsing contexts.
4088     if (isDocumentSandboxed(openerFrame, SandboxPopups)) {
4089         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
4090         openerFrame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked opening &#39;&quot; + request.resourceRequest().url().stringCenterEllipsizedToLength() + &quot;&#39; in a new window because the request was made in a sandboxed frame whose &#39;allow-popups&#39; permission is not set.&quot;);
4091         return nullptr;
4092     }
4093 
4094     // FIXME: Setting the referrer should be the caller&#39;s responsibility.
4095     String referrer = SecurityPolicy::generateReferrerHeader(openerFrame.document()-&gt;referrerPolicy(), request.resourceRequest().url(), openerFrame.loader().outgoingReferrer());
4096     if (!referrer.isEmpty())
4097         request.resourceRequest().setHTTPReferrer(referrer);
4098     FrameLoader::addHTTPOriginIfNeeded(request.resourceRequest(), openerFrame.loader().outgoingOrigin());
4099     FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(request.resourceRequest());
4100     FrameLoader::addSameSiteInfoToRequestIfNeeded(request.resourceRequest(), openerFrame.document());
4101 
4102     Page* oldPage = openerFrame.page();
4103     if (!oldPage)
4104         return nullptr;
4105 
4106     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(openerFrame, request);
4107     NavigationAction action { request.requester(), request.resourceRequest(), request.initiatedByMainFrame(), NavigationType::Other, shouldOpenExternalURLsPolicy };
4108     Page* page = oldPage-&gt;chrome().createWindow(openerFrame, request, features, action);
4109     if (!page)
4110         return nullptr;
4111 
4112     RefPtr&lt;Frame&gt; frame = &amp;page-&gt;mainFrame();
4113 
4114     if (isDocumentSandboxed(openerFrame, SandboxPropagatesToAuxiliaryBrowsingContexts))
4115         frame-&gt;loader().forceSandboxFlags(openerFrame.document()-&gt;sandboxFlags());
4116 
4117     if (!equalIgnoringASCIICase(request.frameName(), &quot;_blank&quot;))
4118         frame-&gt;tree().setName(request.frameName());
4119 
4120     page-&gt;chrome().setToolbarsVisible(features.toolBarVisible || features.locationBarVisible);
4121 
4122     if (!frame-&gt;page())
4123         return nullptr;
4124     page-&gt;chrome().setStatusbarVisible(features.statusBarVisible);
4125 
4126     if (!frame-&gt;page())
4127         return nullptr;
4128     page-&gt;chrome().setScrollbarsVisible(features.scrollbarsVisible);
4129 
4130     if (!frame-&gt;page())
4131         return nullptr;
4132     page-&gt;chrome().setMenubarVisible(features.menuBarVisible);
4133 
4134     if (!frame-&gt;page())
4135         return nullptr;
4136     page-&gt;chrome().setResizable(features.resizable);
4137 
4138     // &#39;x&#39; and &#39;y&#39; specify the location of the window, while &#39;width&#39; and &#39;height&#39;
4139     // specify the size of the viewport. We can only resize the window, so adjust
4140     // for the difference between the window size and the viewport size.
4141 
4142     // FIXME: We should reconcile the initialization of viewport arguments between iOS and non-IOS.
4143 #if !PLATFORM(IOS_FAMILY)
4144     FloatSize viewportSize = page-&gt;chrome().pageRect().size();
4145     FloatRect windowRect = page-&gt;chrome().windowRect();
4146     if (features.x)
4147         windowRect.setX(*features.x);
4148     if (features.y)
4149         windowRect.setY(*features.y);
4150     // Zero width and height mean using default size, not minumum one.
4151     if (features.width &amp;&amp; *features.width)
4152         windowRect.setWidth(*features.width + (windowRect.width() - viewportSize.width()));
4153     if (features.height &amp;&amp; *features.height)
4154         windowRect.setHeight(*features.height + (windowRect.height() - viewportSize.height()));
4155 
4156     // Ensure non-NaN values, minimum size as well as being within valid screen area.
4157     FloatRect newWindowRect = DOMWindow::adjustWindowRect(*page, windowRect);
4158 
4159     if (!frame-&gt;page())
4160         return nullptr;
4161     page-&gt;chrome().setWindowRect(newWindowRect);
4162 #else
4163     // On iOS, width and height refer to the viewport dimensions.
4164     ViewportArguments arguments;
4165     // Zero width and height mean using default size, not minimum one.
4166     if (features.width &amp;&amp; *features.width)
4167         arguments.width = *features.width;
4168     if (features.height &amp;&amp; *features.height)
4169         arguments.height = *features.height;
4170     frame-&gt;setViewportArguments(arguments);
4171 #endif
4172 
4173     if (!frame-&gt;page())
4174         return nullptr;
4175     page-&gt;chrome().show();
4176 
4177     created = true;
4178     return frame;
4179 }
4180 
4181 bool FrameLoader::shouldSuppressTextInputFromEditing() const
4182 {
4183     return m_frame.settings().shouldSuppressTextInputFromEditingDuringProvisionalNavigation() &amp;&amp; m_state == FrameStateProvisional;
4184 }
4185 
4186 } // namespace WebCore
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>