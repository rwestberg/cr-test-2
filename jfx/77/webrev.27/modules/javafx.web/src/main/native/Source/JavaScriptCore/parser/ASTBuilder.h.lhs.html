<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2010, 2013, 2016 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BuiltinNames.h&quot;
  29 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  30 #include &quot;MathCommon.h&quot;
  31 #include &quot;NodeConstructors.h&quot;
  32 #include &quot;SyntaxChecker.h&quot;
  33 #include &quot;VariableEnvironment.h&quot;
  34 #include &lt;utility&gt;
  35 
  36 namespace JSC {
  37 
  38 class ASTBuilder {
  39     struct BinaryOpInfo {
  40         BinaryOpInfo() {}
  41         BinaryOpInfo(const JSTextPosition&amp; otherStart, const JSTextPosition&amp; otherDivot, const JSTextPosition&amp; otherEnd, bool rhsHasAssignment)
  42             : start(otherStart)
  43             , divot(otherDivot)
  44             , end(otherEnd)
  45             , hasAssignment(rhsHasAssignment)
  46         {
  47         }
  48         BinaryOpInfo(const BinaryOpInfo&amp; lhs, const BinaryOpInfo&amp; rhs)
  49             : start(lhs.start)
  50             , divot(rhs.start)
  51             , end(rhs.end)
  52             , hasAssignment(lhs.hasAssignment || rhs.hasAssignment)
  53         {
  54         }
  55         JSTextPosition start;
  56         JSTextPosition divot;
  57         JSTextPosition end;
  58         bool hasAssignment;
  59     };
  60 
  61 
  62     struct AssignmentInfo {
  63         AssignmentInfo() {}
  64         AssignmentInfo(ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int initAssignments, Operator op)
  65             : m_node(node)
  66             , m_start(start)
  67             , m_divot(divot)
  68             , m_initAssignments(initAssignments)
  69             , m_op(op)
  70         {
  71             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
  72             ASSERT(m_start.offset &gt;= m_start.lineStartOffset);
  73         }
  74         ExpressionNode* m_node;
  75         JSTextPosition m_start;
  76         JSTextPosition m_divot;
  77         int m_initAssignments;
  78         Operator m_op;
  79     };
  80 public:
<a name="2" id="anc2"></a><span class="line-modified">  81     ASTBuilder(VM* vm, ParserArena&amp; parserArena, SourceCode* sourceCode)</span>
  82         : m_vm(vm)
  83         , m_parserArena(parserArena)
  84         , m_sourceCode(sourceCode)
  85         , m_evalCount(0)
  86     {
  87     }
  88 
  89     struct BinaryExprContext {
  90         BinaryExprContext(ASTBuilder&amp;) {}
  91     };
  92     struct UnaryExprContext {
  93         UnaryExprContext(ASTBuilder&amp;) {}
  94     };
  95 
  96     typedef ExpressionNode* Expression;
  97     typedef JSC::SourceElements* SourceElements;
  98     typedef ArgumentsNode* Arguments;
  99     typedef CommaNode* Comma;
 100     typedef PropertyNode* Property;
 101     typedef PropertyListNode* PropertyList;
 102     typedef ElementNode* ElementList;
 103     typedef ArgumentListNode* ArgumentsList;
 104     typedef TemplateExpressionListNode* TemplateExpressionList;
 105     typedef TemplateStringNode* TemplateString;
 106     typedef TemplateStringListNode* TemplateStringList;
 107     typedef TemplateLiteralNode* TemplateLiteral;
 108     typedef FunctionParameters* FormalParameterList;
 109     typedef FunctionMetadataNode* FunctionBody;
 110     typedef ClassExprNode* ClassExpression;
 111     typedef ModuleNameNode* ModuleName;
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
 125     static const bool CreatesAST = true;
 126     static const bool NeedsFreeVariableInfo = true;
 127     static const bool CanUseFunctionCache = true;
 128     static const int  DontBuildKeywords = 0;
 129     static const int  DontBuildStrings = 0;
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
<a name="3" id="anc3"></a><span class="line-modified"> 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth);</span>
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 150     ExpressionNode* makeAddNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 151     ExpressionNode* makeSubNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 152     ExpressionNode* makeBitXOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 153     ExpressionNode* makeBitAndNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 154     ExpressionNode* makeBitOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
<a name="4" id="anc4"></a>
 155     ExpressionNode* makeLeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 156     ExpressionNode* makeRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 157     ExpressionNode* makeURightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 158 
 159     ExpressionNode* createLogicalNot(const JSTokenLocation&amp; location, ExpressionNode* expr)
 160     {
 161         if (expr-&gt;isNumber())
 162             return createBoolean(location, isZeroOrUnordered(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
 163 
 164         return new (m_parserArena) LogicalNotNode(location, expr);
 165     }
 166     ExpressionNode* createUnaryPlus(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) UnaryPlusNode(location, expr); }
 167     ExpressionNode* createVoid(const JSTokenLocation&amp; location, ExpressionNode* expr)
 168     {
 169         incConstants();
 170         return new (m_parserArena) VoidNode(location, expr);
 171     }
 172     ExpressionNode* createThisExpr(const JSTokenLocation&amp; location)
 173     {
 174         usesThis();
 175         return new (m_parserArena) ThisNode(location);
 176     }
 177     ExpressionNode* createSuperExpr(const JSTokenLocation&amp; location)
 178     {
 179         return new (m_parserArena) SuperNode(location);
 180     }
 181     ExpressionNode* createImportExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 182     {
 183         auto* node = new (m_parserArena) ImportNode(location, expr);
 184         setExceptionLocation(node, start, divot, end);
 185         return node;
 186     }
 187     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 188     {
 189         usesNewTarget();
 190         return new (m_parserArena) NewTargetNode(location);
 191     }
 192     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 193     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 194     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 195     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 196     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 197     {
<a name="5" id="anc5"></a><span class="line-modified"> 198         if (m_vm-&gt;propertyNames-&gt;arguments == ident)</span>
 199             usesArguments();
 200 
 201         if (ident.isSymbol()) {
<a name="6" id="anc6"></a><span class="line-modified"> 202             if (BytecodeIntrinsicNode::EmitterType emitter = m_vm-&gt;bytecodeIntrinsicRegistry().lookup(ident))</span>
 203                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);
 204         }
 205 
 206         return new (m_parserArena) ResolveNode(location, ident, start);
 207     }
 208     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 209     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 210 
 211     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 212     {
 213         if (elisions)
 214             incConstants();
 215         return new (m_parserArena) ArrayNode(location, elisions);
 216     }
 217 
 218     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 219     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 220     {
 221         if (elisions)
 222             incConstants();
 223         return new (m_parserArena) ArrayNode(location, elisions, elems);
 224     }
 225     ExpressionNode* createDoubleExpr(const JSTokenLocation&amp; location, double d)
 226     {
 227         incConstants();
 228         return new (m_parserArena) DoubleNode(location, d);
 229     }
 230     ExpressionNode* createIntegerExpr(const JSTokenLocation&amp; location, double d)
 231     {
 232         incConstants();
 233         return new (m_parserArena) IntegerNode(location, d);
 234     }
 235 
 236     ExpressionNode* createBigInt(const JSTokenLocation&amp; location, const Identifier* bigInt, uint8_t radix)
 237     {
 238         incConstants();
 239         return new (m_parserArena) BigIntNode(location, *bigInt, radix);
 240     }
 241 
 242     ExpressionNode* createString(const JSTokenLocation&amp; location, const Identifier* string)
 243     {
 244         ASSERT(string);
 245         incConstants();
 246         return new (m_parserArena) StringNode(location, *string);
 247     }
 248 
 249     ExpressionNode* createBoolean(const JSTokenLocation&amp; location, bool b)
 250     {
 251         incConstants();
 252         return new (m_parserArena) BooleanNode(location, b);
 253     }
 254 
 255     ExpressionNode* createNull(const JSTokenLocation&amp; location)
 256     {
 257         incConstants();
 258         return new (m_parserArena) NullNode(location);
 259     }
 260 
 261     ExpressionNode* createBracketAccess(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* property, bool propertyHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 262     {
 263         if (base-&gt;isSuperNode())
 264             usesSuperProperty();
 265 
 266         BracketAccessorNode* node = new (m_parserArena) BracketAccessorNode(location, base, property, propertyHasAssignments);
 267         setExceptionLocation(node, start, divot, end);
 268         return node;
 269     }
 270 
 271     ExpressionNode* createDotAccess(const JSTokenLocation&amp; location, ExpressionNode* base, const Identifier* property, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 272     {
 273         if (base-&gt;isSuperNode())
 274             usesSuperProperty();
 275 
 276         DotAccessorNode* node = new (m_parserArena) DotAccessorNode(location, base, *property);
 277         setExceptionLocation(node, start, divot, end);
 278         return node;
 279     }
 280 
 281     ExpressionNode* createSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 282     {
 283         auto node = new (m_parserArena) SpreadExpressionNode(location, expression);
 284         setExceptionLocation(node, start, divot, end);
 285         return node;
 286     }
 287 
 288     ExpressionNode* createObjectSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 289     {
 290         auto node = new (m_parserArena) ObjectSpreadExpressionNode(location, expression);
 291         setExceptionLocation(node, start, divot, end);
 292         return node;
 293     }
 294 
 295     TemplateStringNode* createTemplateString(const JSTokenLocation&amp; location, const Identifier* cooked, const Identifier* raw)
 296     {
 297         return new (m_parserArena) TemplateStringNode(location, cooked, raw);
 298     }
 299 
 300     TemplateStringListNode* createTemplateStringList(TemplateStringNode* templateString)
 301     {
 302         return new (m_parserArena) TemplateStringListNode(templateString);
 303     }
 304 
 305     TemplateStringListNode* createTemplateStringList(TemplateStringListNode* templateStringList, TemplateStringNode* templateString)
 306     {
 307         return new (m_parserArena) TemplateStringListNode(templateStringList, templateString);
 308     }
 309 
 310     TemplateExpressionListNode* createTemplateExpressionList(ExpressionNode* expression)
 311     {
 312         return new (m_parserArena) TemplateExpressionListNode(expression);
 313     }
 314 
 315     TemplateExpressionListNode* createTemplateExpressionList(TemplateExpressionListNode* templateExpressionListNode, ExpressionNode* expression)
 316     {
 317         return new (m_parserArena) TemplateExpressionListNode(templateExpressionListNode, expression);
 318     }
 319 
 320     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList)
 321     {
 322         return new (m_parserArena) TemplateLiteralNode(location, templateStringList);
 323     }
 324 
 325     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList, TemplateExpressionListNode* templateExpressionList)
 326     {
 327         return new (m_parserArena) TemplateLiteralNode(location, templateStringList, templateExpressionList);
 328     }
 329 
 330     ExpressionNode* createTaggedTemplate(const JSTokenLocation&amp; location, ExpressionNode* base, TemplateLiteralNode* templateLiteral, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 331     {
 332         auto node = new (m_parserArena) TaggedTemplateNode(location, base, templateLiteral);
 333         setExceptionLocation(node, start, divot, end);
<a name="7" id="anc7"></a>
 334         return node;
 335     }
 336 
 337     ExpressionNode* createRegExp(const JSTokenLocation&amp; location, const Identifier&amp; pattern, const Identifier&amp; flags, const JSTextPosition&amp; start)
 338     {
 339         if (Yarr::hasError(Yarr::checkSyntax(pattern.string(), flags.string())))
 340             return 0;
 341         RegExpNode* node = new (m_parserArena) RegExpNode(location, pattern, flags);
 342         int size = pattern.length() + 2; // + 2 for the two /&#39;s
 343         JSTextPosition end = start + size;
 344         setExceptionLocation(node, start, end, end);
 345         return node;
 346     }
 347 
 348     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, ArgumentsNode* arguments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 349     {
 350         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr, arguments);
 351         setExceptionLocation(node, start, divot, end);
 352         return node;
 353     }
 354 
 355     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 356     {
 357         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr);
 358         setExceptionLocation(node, start, end, end);
 359         return node;
 360     }
 361 
<a name="8" id="anc8"></a>





 362     ExpressionNode* createConditionalExpr(const JSTokenLocation&amp; location, ExpressionNode* condition, ExpressionNode* lhs, ExpressionNode* rhs)
 363     {
 364         return new (m_parserArena) ConditionalNode(location, condition, lhs, rhs);
 365     }
 366 
 367     ExpressionNode* createAssignResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, ExpressionNode* rhs, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end, AssignmentContext assignmentContext)
 368     {
 369         if (rhs-&gt;isBaseFuncExprNode()) {
 370             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(rhs)-&gt;metadata();
 371             metadata-&gt;setEcmaName(ident);
<a name="9" id="anc9"></a><span class="line-removed"> 372             metadata-&gt;setInferredName(ident);</span>
 373         } else if (rhs-&gt;isClassExprNode())
 374             static_cast&lt;ClassExprNode*&gt;(rhs)-&gt;setEcmaName(ident);
 375         AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, ident, rhs, assignmentContext);
 376         setExceptionLocation(node, start, divot, end);
 377         return node;
 378     }
 379 
 380     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 381     {
 382         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 383     }
 384 
 385     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 386     {
 387         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 388         setExceptionLocation(node, start, divot, end);
 389         return node;
 390     }
 391 
 392     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 393     {
 394         ASSERT(argument);
 395         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
 396         setExceptionLocation(node, start, divot, end);
 397         return node;
 398     }
 399 
 400     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 401         ExpressionNode* parentClass, PropertyListNode* classElements)
 402     {
 403         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 404         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 405     }
 406 
 407     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 408     {
 409         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 410             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 411         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 412         return result;
 413     }
 414 
 415     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 416     {
 417         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 418         if (!name.isNull())
<a name="10" id="anc10"></a><span class="line-modified"> 419             result-&gt;metadata()-&gt;setInferredName(name);</span>
 420         return result;
 421     }
 422 
 423     ExpressionNode* createAsyncFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, SourceParseMode parseMode)
 424     {
 425         if (parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 426             SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 427             FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 428             functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 429             return result;
 430         }
 431         return createFunctionExpr(location, functionInfo);
 432     }
 433 
 434     ExpressionNode* createMethodDefinition(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 435     {
 436         MethodDefinitionNode* result = new (m_parserArena) MethodDefinitionNode(location, *functionInfo.name, functionInfo.body,
 437             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 438         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 439         return result;
 440     }
 441 
 442     FunctionMetadataNode* createFunctionMetadata(
 443         const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation,
 444         unsigned startColumn, unsigned endColumn, int functionKeywordStart,
 445         int functionNameStart, int parametersStart, bool inStrictContext,
 446         ConstructorKind constructorKind, SuperBinding superBinding,
 447         unsigned parameterCount,
 448         SourceParseMode mode, bool isArrowFunctionBodyExpression)
 449     {
 450         return new (m_parserArena) FunctionMetadataNode(
 451             m_parserArena, startLocation, endLocation, startColumn, endColumn,
 452             functionKeywordStart, functionNameStart, parametersStart,
 453             inStrictContext, constructorKind, superBinding,
 454             parameterCount, mode, isArrowFunctionBodyExpression);
 455     }
 456 
 457     ExpressionNode* createArrowFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 458     {
 459         usesArrowFunction();
 460         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 461         ArrowFuncExprNode* result = new (m_parserArena) ArrowFuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 462         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 463         return result;
 464     }
 465 
 466     ArgumentsNode* createArguments() { return new (m_parserArena) ArgumentsNode(); }
 467     ArgumentsNode* createArguments(ArgumentListNode* args) { return new (m_parserArena) ArgumentsNode(args); }
 468     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, arg); }
 469     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ArgumentListNode* args, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, args, arg); }
 470 
 471     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 472         const Identifier* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 473     {
 474         ASSERT(name);
 475         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 476         functionInfo.body-&gt;setEcmaName(*name);
<a name="11" id="anc11"></a><span class="line-removed"> 477         functionInfo.body-&gt;setInferredName(*name);</span>
 478         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<a name="12" id="anc12"></a><span class="line-modified"> 479         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 480         return new (m_parserArena) PropertyNode(*name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 481     }
 482 
 483     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 484         ExpressionNode* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 485     {
 486         ASSERT(name);
 487         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 488         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<a name="13" id="anc13"></a><span class="line-modified"> 489         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 490         return new (m_parserArena) PropertyNode(name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 491     }
 492 
<a name="14" id="anc14"></a><span class="line-modified"> 493     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(VM* vm, ParserArena&amp; parserArena, const JSTokenLocation&amp; location, PropertyNode::Type type, bool,</span>
 494         double name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 495     {
 496         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 497         const Identifier&amp; ident = parserArena.identifierArena().makeNumericIdentifier(vm, name);
 498         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<a name="15" id="anc15"></a><span class="line-modified"> 499         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 500         return new (m_parserArena) PropertyNode(ident, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 501     }
 502 
 503     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 504     {
 505         if (inferName == InferName::Allowed) {
 506             if (node-&gt;isBaseFuncExprNode()) {
 507                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 508                 metadata-&gt;setEcmaName(*propertyName);
<a name="16" id="anc16"></a><span class="line-removed"> 509                 metadata-&gt;setInferredName(*propertyName);</span>
 510             } else if (node-&gt;isClassExprNode())
 511                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 512         }
 513         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 514     }
 515     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 516     {
 517         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 518     }
<a name="17" id="anc17"></a><span class="line-modified"> 519     PropertyNode* createProperty(VM* vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)</span>
 520     {
 521         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 522     }
 523     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
 524     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 525     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 526 
 527     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 528     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 529     ElementNode* createElementList(ArgumentListNode* elems)
 530     {
 531         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 532         ElementNode* tail = head;
 533         elems = elems-&gt;m_next;
 534         while (elems) {
 535             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 536             elems = elems-&gt;m_next;
 537         }
 538         return head;
 539     }
 540 
 541     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 542     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 543     {
 544         list-&gt;append(pattern, defaultValue);
 545         tryInferNameInPattern(pattern, defaultValue);
 546     }
 547 
 548     CaseClauseNode* createClause(ExpressionNode* expr, JSC::SourceElements* statements) { return new (m_parserArena) CaseClauseNode(expr, statements); }
 549     ClauseListNode* createClauseList(CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(clause); }
 550     ClauseListNode* createClauseList(ClauseListNode* tail, CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(tail, clause); }
 551 
 552     StatementNode* createFuncDeclStatement(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 553     {
 554         FuncDeclNode* decl = new (m_parserArena) FuncDeclNode(location, *functionInfo.name, functionInfo.body,
 555             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
<a name="18" id="anc18"></a><span class="line-modified"> 556         if (*functionInfo.name == m_vm-&gt;propertyNames-&gt;arguments)</span>
 557             usesArguments();
 558         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 559         return decl;
 560     }
 561 
 562     StatementNode* createClassDeclStatement(const JSTokenLocation&amp; location, ClassExprNode* classExpression,
 563         const JSTextPosition&amp; classStart, const JSTextPosition&amp; classEnd, unsigned startLine, unsigned endLine)
 564     {
 565         ExpressionNode* assign = createAssignResolve(location, classExpression-&gt;name(), classExpression, classStart, classStart + 1, classEnd, AssignmentContext::DeclarationStatement);
 566         ClassDeclNode* decl = new (m_parserArena) ClassDeclNode(location, assign);
 567         decl-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 568         return decl;
 569     }
 570 
 571     StatementNode* createBlockStatement(const JSTokenLocation&amp; location, JSC::SourceElements* elements, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 572     {
 573         BlockNode* block = new (m_parserArena) BlockNode(location, elements, lexicalVariables, WTFMove(functionStack));
 574         block-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 575         return block;
 576     }
 577 
 578     StatementNode* createExprStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, int end)
 579     {
 580         ExprStatementNode* result = new (m_parserArena) ExprStatementNode(location, expr);
 581         result-&gt;setLoc(start.line, end, start.offset, start.lineStartOffset);
 582         return result;
 583     }
 584 
 585     StatementNode* createIfStatement(const JSTokenLocation&amp; location, ExpressionNode* condition, StatementNode* trueBlock, StatementNode* falseBlock, int start, int end)
 586     {
 587         IfElseNode* result = new (m_parserArena) IfElseNode(location, condition, trueBlock, falseBlock);
 588         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 589         return result;
 590     }
 591 
 592     StatementNode* createForLoop(const JSTokenLocation&amp; location, ExpressionNode* initializer, ExpressionNode* condition, ExpressionNode* iter, StatementNode* statements, int start, int end, VariableEnvironment&amp; lexicalVariables)
 593     {
 594         ForNode* result = new (m_parserArena) ForNode(location, initializer, condition, iter, statements, lexicalVariables);
 595         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 596         return result;
 597     }
 598 
 599     StatementNode* createForInLoop(const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 600     {
 601         ForInNode* result = new (m_parserArena) ForInNode(location, lhs, iter, statements, lexicalVariables);
 602         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 603         setExceptionLocation(result, eStart, eDivot, eEnd);
 604         return result;
 605     }
 606 
 607     StatementNode* createForInLoop(const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 608     {
 609         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 610         return createForInLoop(location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 611     }
 612 
 613     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 614     {
 615         ForOfNode* result = new (m_parserArena) ForOfNode(isForAwait, location, lhs, iter, statements, lexicalVariables);
 616         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 617         setExceptionLocation(result, eStart, eDivot, eEnd);
 618         return result;
 619     }
 620 
 621     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 622     {
 623         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 624         return createForOfLoop(isForAwait, location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 625     }
 626 
 627     bool isBindingNode(const DestructuringPattern&amp; pattern)
 628     {
 629         return pattern-&gt;isBindingNode();
 630     }
 631 
<a name="19" id="anc19"></a><span class="line-modified"> 632     bool isAssignmentLocation(const Expression&amp; pattern)</span>
 633     {
<a name="20" id="anc20"></a><span class="line-modified"> 634         return pattern-&gt;isAssignmentLocation();</span>





 635     }
 636 
 637     bool isObjectLiteral(const Expression&amp; node)
 638     {
 639         return node-&gt;isObjectLiteral();
 640     }
 641 
 642     bool isArrayLiteral(const Expression&amp; node)
 643     {
 644         return node-&gt;isArrayLiteral();
 645     }
 646 
 647     bool isObjectOrArrayLiteral(const Expression&amp; node)
 648     {
 649         return isObjectLiteral(node) || isArrayLiteral(node);
 650     }
 651 
<a name="21" id="anc21"></a>




 652     bool shouldSkipPauseLocation(StatementNode* statement) const
 653     {
 654         return !statement || statement-&gt;isLabel();
 655     }
 656 
 657     StatementNode* createEmptyStatement(const JSTokenLocation&amp; location) { return new (m_parserArena) EmptyStatementNode(location); }
 658 
 659     StatementNode* createDeclarationStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, int start, int end)
 660     {
 661         StatementNode* result;
 662         result = new (m_parserArena) DeclarationStatement(location, expr);
 663         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 664         return result;
 665     }
 666 
 667     ExpressionNode* createEmptyVarExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 668     {
 669         return new (m_parserArena) EmptyVarExpression(location, identifier);
 670     }
 671 
 672     ExpressionNode* createEmptyLetExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 673     {
 674         return new (m_parserArena) EmptyLetExpression(location, identifier);
 675     }
 676 
 677     StatementNode* createReturnStatement(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 678     {
 679         ReturnNode* result = new (m_parserArena) ReturnNode(location, expression);
 680         setExceptionLocation(result, start, end, end);
 681         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 682         return result;
 683     }
 684 
 685     StatementNode* createBreakStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 686     {
 687         BreakNode* result = new (m_parserArena) BreakNode(location, *ident);
 688         setExceptionLocation(result, start, end, end);
 689         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 690         return result;
 691     }
 692 
 693     StatementNode* createContinueStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 694     {
 695         ContinueNode* result = new (m_parserArena) ContinueNode(location, *ident);
 696         setExceptionLocation(result, start, end, end);
 697         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 698         return result;
 699     }
 700 
 701     StatementNode* createTryStatement(const JSTokenLocation&amp; location, StatementNode* tryBlock, DestructuringPatternNode* catchPattern, StatementNode* catchBlock, StatementNode* finallyBlock, int startLine, int endLine, VariableEnvironment&amp; catchEnvironment)
 702     {
 703         TryNode* result = new (m_parserArena) TryNode(location, tryBlock, catchPattern, catchBlock, catchEnvironment, finallyBlock);
 704         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 705         return result;
 706     }
 707 
 708     StatementNode* createSwitchStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, ClauseListNode* firstClauses, CaseClauseNode* defaultClause, ClauseListNode* secondClauses, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 709     {
 710         CaseBlockNode* cases = new (m_parserArena) CaseBlockNode(firstClauses, defaultClause, secondClauses);
 711         SwitchNode* result = new (m_parserArena) SwitchNode(location, expr, cases, lexicalVariables, WTFMove(functionStack));
 712         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 713         return result;
 714     }
 715 
 716     StatementNode* createWhileStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, int startLine, int endLine)
 717     {
 718         WhileNode* result = new (m_parserArena) WhileNode(location, expr, statement);
 719         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 720         return result;
 721     }
 722 
 723     StatementNode* createDoWhileStatement(const JSTokenLocation&amp; location, StatementNode* statement, ExpressionNode* expr, int startLine, int endLine)
 724     {
 725         DoWhileNode* result = new (m_parserArena) DoWhileNode(location, statement, expr);
 726         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 727         return result;
 728     }
 729 
 730     StatementNode* createLabelStatement(const JSTokenLocation&amp; location, const Identifier* ident, StatementNode* statement, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 731     {
 732         LabelNode* result = new (m_parserArena) LabelNode(location, *ident, statement);
 733         setExceptionLocation(result, start, end, end);
 734         return result;
 735     }
 736 
 737     StatementNode* createWithStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, unsigned start, const JSTextPosition&amp; end, unsigned startLine, unsigned endLine)
 738     {
 739         usesWith();
 740         WithNode* result = new (m_parserArena) WithNode(location, expr, statement, end, end - start);
 741         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 742         return result;
 743     }
 744 
 745     StatementNode* createThrowStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 746     {
 747         ThrowNode* result = new (m_parserArena) ThrowNode(location, expr);
 748         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 749         setExceptionLocation(result, start, end, end);
 750         return result;
 751     }
 752 
 753     StatementNode* createDebugger(const JSTokenLocation&amp; location, int startLine, int endLine)
 754     {
 755         DebuggerStatementNode* result = new (m_parserArena) DebuggerStatementNode(location);
 756         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 757         return result;
 758     }
 759 
 760     ModuleNameNode* createModuleName(const JSTokenLocation&amp; location, const Identifier&amp; moduleName)
 761     {
 762         return new (m_parserArena) ModuleNameNode(location, moduleName);
 763     }
 764 
 765     ImportSpecifierNode* createImportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; importedName, const Identifier&amp; localName)
 766     {
 767         return new (m_parserArena) ImportSpecifierNode(location, importedName, localName);
 768     }
 769 
 770     ImportSpecifierListNode* createImportSpecifierList()
 771     {
 772         return new (m_parserArena) ImportSpecifierListNode();
 773     }
 774 
 775     void appendImportSpecifier(ImportSpecifierListNode* specifierList, ImportSpecifierNode* specifier)
 776     {
 777         specifierList-&gt;append(specifier);
 778     }
 779 
 780     StatementNode* createImportDeclaration(const JSTokenLocation&amp; location, ImportSpecifierListNode* importSpecifierList, ModuleNameNode* moduleName)
 781     {
 782         return new (m_parserArena) ImportDeclarationNode(location, importSpecifierList, moduleName);
 783     }
 784 
 785     StatementNode* createExportAllDeclaration(const JSTokenLocation&amp; location, ModuleNameNode* moduleName)
 786     {
 787         return new (m_parserArena) ExportAllDeclarationNode(location, moduleName);
 788     }
 789 
 790     StatementNode* createExportDefaultDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration, const Identifier&amp; localName)
 791     {
 792         return new (m_parserArena) ExportDefaultDeclarationNode(location, declaration, localName);
 793     }
 794 
 795     StatementNode* createExportLocalDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration)
 796     {
 797         return new (m_parserArena) ExportLocalDeclarationNode(location, declaration);
 798     }
 799 
 800     StatementNode* createExportNamedDeclaration(const JSTokenLocation&amp; location, ExportSpecifierListNode* exportSpecifierList, ModuleNameNode* moduleName)
 801     {
 802         return new (m_parserArena) ExportNamedDeclarationNode(location, exportSpecifierList, moduleName);
 803     }
 804 
 805     ExportSpecifierNode* createExportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; localName, const Identifier&amp; exportedName)
 806     {
 807         return new (m_parserArena) ExportSpecifierNode(location, localName, exportedName);
 808     }
 809 
 810     ExportSpecifierListNode* createExportSpecifierList()
 811     {
 812         return new (m_parserArena) ExportSpecifierListNode();
 813     }
 814 
 815     void appendExportSpecifier(ExportSpecifierListNode* specifierList, ExportSpecifierNode* specifier)
 816     {
 817         specifierList-&gt;append(specifier);
 818     }
 819 
 820     void appendStatement(JSC::SourceElements* elements, JSC::StatementNode* statement)
 821     {
 822         elements-&gt;append(statement);
 823     }
 824 
 825     CommaNode* createCommaExpr(const JSTokenLocation&amp; location, ExpressionNode* node)
 826     {
 827         return new (m_parserArena) CommaNode(location, node);
 828     }
 829 
 830     CommaNode* appendToCommaExpr(const JSTokenLocation&amp; location, ExpressionNode*, ExpressionNode* tail, ExpressionNode* next)
 831     {
 832         ASSERT(tail-&gt;isCommaNode());
 833         ASSERT(next);
 834         CommaNode* newTail = new (m_parserArena) CommaNode(location, next);
 835         static_cast&lt;CommaNode*&gt;(tail)-&gt;setNext(newTail);
 836         return newTail;
 837     }
 838 
 839     int evalCount() const { return m_evalCount; }
 840 
 841     void appendBinaryExpressionInfo(int&amp; operandStackDepth, ExpressionNode* current, const JSTextPosition&amp; exprStart, const JSTextPosition&amp; lhs, const JSTextPosition&amp; rhs, bool hasAssignments)
 842     {
 843         operandStackDepth++;
 844         m_binaryOperandStack.append(std::make_pair(current, BinaryOpInfo(exprStart, lhs, rhs, hasAssignments)));
 845     }
 846 
 847     // Logic to handle datastructures used during parsing of binary expressions
 848     void operatorStackPop(int&amp; operatorStackDepth)
 849     {
 850         operatorStackDepth--;
 851         m_binaryOperatorStack.removeLast();
 852     }
 853     bool operatorStackShouldReduce(int precedence)
 854     {
 855         // If the current precedence of the operator stack is the same to the one of the given operator,
 856         // it depends on the associative whether we reduce the stack.
 857         // If the operator is right associative, we should not reduce the stack right now.
 858         if (precedence == m_binaryOperatorStack.last().second)
 859             return !(m_binaryOperatorStack.last().first &amp; RightAssociativeBinaryOpTokenFlag);
 860         return precedence &lt; m_binaryOperatorStack.last().second;
 861     }
 862     const BinaryOperand&amp; getFromOperandStack(int i) { return m_binaryOperandStack[m_binaryOperandStack.size() + i]; }
 863     void shrinkOperandStackBy(int&amp; operandStackDepth, int amount)
 864     {
 865         operandStackDepth -= amount;
 866         ASSERT(operandStackDepth &gt;= 0);
 867         m_binaryOperandStack.shrink(m_binaryOperandStack.size() - amount);
 868     }
 869     void appendBinaryOperation(const JSTokenLocation&amp; location, int&amp; operandStackDepth, int&amp;, const BinaryOperand&amp; lhs, const BinaryOperand&amp; rhs)
 870     {
 871         operandStackDepth++;
 872         m_binaryOperandStack.append(std::make_pair(makeBinaryNode(location, m_binaryOperatorStack.last().first, lhs, rhs), BinaryOpInfo(lhs.second, rhs.second)));
 873     }
 874     void operatorStackAppend(int&amp; operatorStackDepth, int op, int precedence)
 875     {
 876         operatorStackDepth++;
 877         m_binaryOperatorStack.append(std::make_pair(op, precedence));
 878     }
 879     ExpressionNode* popOperandStack(int&amp;)
 880     {
 881         ExpressionNode* result = m_binaryOperandStack.last().first;
 882         m_binaryOperandStack.removeLast();
 883         return result;
 884     }
 885 
 886     void appendUnaryToken(int&amp; tokenStackDepth, int type, const JSTextPosition&amp; start)
 887     {
 888         tokenStackDepth++;
 889         m_unaryTokenStack.append(std::make_pair(type, start));
 890     }
 891 
 892     int unaryTokenStackLastType(int&amp;)
 893     {
 894         return m_unaryTokenStack.last().first;
 895     }
 896 
 897     const JSTextPosition&amp; unaryTokenStackLastStart(int&amp;)
 898     {
 899         return m_unaryTokenStack.last().second;
 900     }
 901 
 902     void unaryTokenStackRemoveLast(int&amp; tokenStackDepth)
 903     {
 904         tokenStackDepth--;
 905         m_unaryTokenStack.removeLast();
 906     }
 907 
 908     void assignmentStackAppend(int&amp; assignmentStackDepth, ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int assignmentCount, Operator op)
 909     {
 910         assignmentStackDepth++;
 911         ASSERT(start.offset &gt;= start.lineStartOffset);
 912         ASSERT(divot.offset &gt;= divot.lineStartOffset);
 913         m_assignmentInfoStack.append(AssignmentInfo(node, start, divot, assignmentCount, op));
 914     }
 915 
 916     ExpressionNode* createAssignment(const JSTokenLocation&amp; location, int&amp; assignmentStackDepth, ExpressionNode* rhs, int initialAssignmentCount, int currentAssignmentCount, const JSTextPosition&amp; lastTokenEnd)
 917     {
 918         AssignmentInfo&amp; info = m_assignmentInfoStack.last();
 919         ExpressionNode* result = makeAssignNode(location, info.m_node, info.m_op, rhs, info.m_initAssignments != initialAssignmentCount, info.m_initAssignments != currentAssignmentCount, info.m_start, info.m_divot + 1, lastTokenEnd);
 920         m_assignmentInfoStack.removeLast();
 921         assignmentStackDepth--;
 922         return result;
 923     }
 924 
 925     const Identifier* getName(const Property&amp; property) const { return property-&gt;name(); }
 926     PropertyNode::Type getType(const Property&amp; property) const { return property-&gt;type(); }
 927 
 928     bool isResolve(ExpressionNode* expr) const { return expr-&gt;isResolveNode(); }
 929 
 930     ExpressionNode* createDestructuringAssignment(const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* initializer)
 931     {
 932         return new (m_parserArena) DestructuringAssignmentNode(location, pattern, initializer);
 933     }
 934 
 935     ArrayPattern createArrayPattern(const JSTokenLocation&amp;)
 936     {
 937         return new (m_parserArena) ArrayPatternNode();
 938     }
 939 
 940     void appendArrayPatternSkipEntry(ArrayPattern node, const JSTokenLocation&amp; location)
 941     {
 942         node-&gt;appendIndex(ArrayPatternNode::BindingType::Elision, location, 0, nullptr);
 943     }
 944 
 945     void appendArrayPatternEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* defaultValue)
 946     {
 947         node-&gt;appendIndex(ArrayPatternNode::BindingType::Element, location, pattern, defaultValue);
 948         tryInferNameInPattern(pattern, defaultValue);
 949     }
 950 
 951     void appendArrayPatternRestEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
 952     {
 953         node-&gt;appendIndex(ArrayPatternNode::BindingType::RestElement, location, pattern, nullptr);
 954     }
 955 
 956     void finishArrayPattern(ArrayPattern node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
 957     {
 958         setExceptionLocation(node, divotStart, divot, divotEnd);
 959     }
 960 
 961     ObjectPattern createObjectPattern(const JSTokenLocation&amp;)
 962     {
 963         return new (m_parserArena) ObjectPatternNode();
 964     }
 965 
 966     void appendObjectPatternEntry(ObjectPattern node, const JSTokenLocation&amp; location, bool wasString, const Identifier&amp; identifier, DestructuringPattern pattern, ExpressionNode* defaultValue)
 967     {
 968         node-&gt;appendEntry(location, identifier, wasString, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
 969         tryInferNameInPattern(pattern, defaultValue);
 970     }
 971 
 972     void appendObjectPatternEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, ExpressionNode* propertyExpression, DestructuringPattern pattern, ExpressionNode* defaultValue)
 973     {
 974         node-&gt;appendEntry(vm, location, propertyExpression, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
 975         tryInferNameInPattern(pattern, defaultValue);
 976     }
 977 
 978     void appendObjectPatternRestEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
 979     {
 980         node-&gt;appendEntry(vm, location, nullptr, pattern, nullptr, ObjectPatternNode::BindingType::RestElement);
 981     }
 982 
 983     void setContainsObjectRestElement(ObjectPattern node, bool containsRestElement)
 984     {
 985         node-&gt;setContainsRestElement(containsRestElement);
 986     }
 987 
 988     void setContainsComputedProperty(ObjectPattern node, bool containsComputedProperty)
 989     {
 990         node-&gt;setContainsComputedProperty(containsComputedProperty);
 991     }
 992 
 993     BindingPattern createBindingLocation(const JSTokenLocation&amp;, const Identifier&amp; boundProperty, const JSTextPosition&amp; start, const JSTextPosition&amp; end, AssignmentContext context)
 994     {
 995         return new (m_parserArena) BindingNode(boundProperty, start, end, context);
 996     }
 997 
 998     RestParameterNode* createRestParameter(DestructuringPatternNode* pattern, size_t numParametersToSkip)
 999     {
1000         return new (m_parserArena) RestParameterNode(pattern, numParametersToSkip);
1001     }
1002 
1003     AssignmentElement createAssignmentElement(const Expression&amp; assignmentTarget, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
1004     {
1005         return new (m_parserArena) AssignmentElementNode(assignmentTarget, start, end);
1006     }
1007 
1008     void setEndOffset(Node* node, int offset)
1009     {
1010         node-&gt;setEndOffset(offset);
1011     }
1012 
1013     int endOffset(Node* node)
1014     {
1015         return node-&gt;endOffset();
1016     }
1017 
1018     void setStartOffset(CaseClauseNode* node, int offset)
1019     {
1020         node-&gt;setStartOffset(offset);
1021     }
1022 
1023     void setStartOffset(Node* node, int offset)
1024     {
1025         node-&gt;setStartOffset(offset);
1026     }
1027 
1028     JSTextPosition breakpointLocation(Node* node)
1029     {
1030         node-&gt;setNeedsDebugHook();
1031         return node-&gt;position();
1032     }
1033 
1034     void propagateArgumentsUse() { usesArguments(); }
1035 
1036 private:
1037     struct Scope {
1038         Scope()
1039             : m_features(0)
1040             , m_numConstants(0)
1041         {
1042         }
1043         int m_features;
1044         int m_numConstants;
1045     };
1046 
1047     static void setExceptionLocation(ThrowableExpressionData* node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
1048     {
1049         ASSERT(divot.offset &gt;= divot.lineStartOffset);
1050         node-&gt;setExceptionSourceCode(divot, divotStart, divotEnd);
1051     }
1052 
1053     void incConstants() { m_scope.m_numConstants++; }
1054     void usesThis() { m_scope.m_features |= ThisFeature; }
1055     void usesArrowFunction() { m_scope.m_features |= ArrowFunctionFeature; }
1056     void usesArguments() { m_scope.m_features |= ArgumentsFeature; }
1057     void usesWith() { m_scope.m_features |= WithFeature; }
1058     void usesSuperCall() { m_scope.m_features |= SuperCallFeature; }
1059     void usesSuperProperty() { m_scope.m_features |= SuperPropertyFeature; }
1060     void usesEval()
1061     {
1062         m_evalCount++;
1063         m_scope.m_features |= EvalFeature;
1064     }
1065     void usesNewTarget() { m_scope.m_features |= NewTargetFeature; }
1066     ExpressionNode* createIntegerLikeNumber(const JSTokenLocation&amp; location, double d)
1067     {
1068         return new (m_parserArena) IntegerNode(location, d);
1069     }
1070     ExpressionNode* createDoubleLikeNumber(const JSTokenLocation&amp; location, double d)
1071     {
1072         return new (m_parserArena) DoubleNode(location, d);
1073     }
1074     ExpressionNode* createBigIntWithSign(const JSTokenLocation&amp; location, const Identifier&amp; bigInt, uint8_t radix, bool sign)
1075     {
1076         return new (m_parserArena) BigIntNode(location, bigInt, radix, sign);
1077     }
1078     ExpressionNode* createNumberFromBinaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNodeA, const NumberNode&amp; originalNodeB)
1079     {
1080         if (originalNodeA.isIntegerNode() &amp;&amp; originalNodeB.isIntegerNode())
1081             return createIntegerLikeNumber(location, value);
1082         return createDoubleLikeNumber(location, value);
1083     }
1084     ExpressionNode* createNumberFromUnaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNode)
1085     {
1086         if (originalNode.isIntegerNode())
1087             return createIntegerLikeNumber(location, value);
1088         return createDoubleLikeNumber(location, value);
1089     }
1090     ExpressionNode* createBigIntFromUnaryOperation(const JSTokenLocation&amp; location, bool sign, const BigIntNode&amp; originalNode)
1091     {
1092         return createBigIntWithSign(location, originalNode.identifier(), originalNode.radix(), sign);
1093     }
1094 
1095     void tryInferNameInPattern(DestructuringPattern pattern, ExpressionNode* defaultValue)
1096     {
1097         if (!defaultValue)
1098             return;
1099 
1100         if (pattern-&gt;isBindingNode()) {
1101             const Identifier&amp; ident = static_cast&lt;BindingNode*&gt;(pattern)-&gt;boundProperty();
1102             tryInferNameInPatternWithIdentifier(ident, defaultValue);
1103         } else if (pattern-&gt;isAssignmentElementNode()) {
1104             const ExpressionNode* assignmentTarget = static_cast&lt;AssignmentElementNode*&gt;(pattern)-&gt;assignmentTarget();
1105             if (assignmentTarget-&gt;isResolveNode()) {
1106                 const Identifier&amp; ident = static_cast&lt;const ResolveNode*&gt;(assignmentTarget)-&gt;identifier();
1107                 tryInferNameInPatternWithIdentifier(ident, defaultValue);
1108             }
1109         }
1110     }
1111 
1112     void tryInferNameInPatternWithIdentifier(const Identifier&amp; ident, ExpressionNode* defaultValue)
1113     {
1114         if (defaultValue-&gt;isBaseFuncExprNode()) {
1115             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(defaultValue)-&gt;metadata();
1116             metadata-&gt;setEcmaName(ident);
<a name="22" id="anc22"></a><span class="line-removed">1117             metadata-&gt;setInferredName(ident);</span>
1118         } else if (defaultValue-&gt;isClassExprNode())
1119             static_cast&lt;ClassExprNode*&gt;(defaultValue)-&gt;setEcmaName(ident);
1120     }
1121 
<a name="23" id="anc23"></a><span class="line-modified">1122     VM* m_vm;</span>
1123     ParserArena&amp; m_parserArena;
1124     SourceCode* m_sourceCode;
1125     Scope m_scope;
1126     Vector&lt;BinaryOperand, 10, UnsafeVectorOverflow&gt; m_binaryOperandStack;
1127     Vector&lt;AssignmentInfo, 10, UnsafeVectorOverflow&gt; m_assignmentInfoStack;
1128     Vector&lt;std::pair&lt;int, int&gt;, 10, UnsafeVectorOverflow&gt; m_binaryOperatorStack;
1129     Vector&lt;std::pair&lt;int, JSTextPosition&gt;, 10, UnsafeVectorOverflow&gt; m_unaryTokenStack;
1130     int m_evalCount;
1131 };
1132 
1133 ExpressionNode* ASTBuilder::makeTypeOfNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1134 {
1135     if (expr-&gt;isResolveNode()) {
1136         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1137         return new (m_parserArena) TypeOfResolveNode(location, resolve-&gt;identifier());
1138     }
1139     return new (m_parserArena) TypeOfValueNode(location, expr);
1140 }
1141 
1142 ExpressionNode* ASTBuilder::makeDeleteNode(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1143 {
<a name="24" id="anc24"></a>








1144     if (!expr-&gt;isLocation())
1145         return new (m_parserArena) DeleteValueNode(location, expr);
1146     if (expr-&gt;isResolveNode()) {
1147         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1148         return new (m_parserArena) DeleteResolveNode(location, resolve-&gt;identifier(), divot, start, end);
1149     }
1150     if (expr-&gt;isBracketAccessorNode()) {
1151         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(expr);
1152         return new (m_parserArena) DeleteBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), divot, start, end);
1153     }
1154     ASSERT(expr-&gt;isDotAccessorNode());
1155     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expr);
1156     return new (m_parserArena) DeleteDotNode(location, dot-&gt;base(), dot-&gt;identifier(), divot, start, end);
1157 }
1158 
1159 ExpressionNode* ASTBuilder::makeNegateNode(const JSTokenLocation&amp; location, ExpressionNode* n)
1160 {
1161     if (n-&gt;isNumber()) {
1162         const NumberNode&amp; numberNode = static_cast&lt;const NumberNode&amp;&gt;(*n);
1163         return createNumberFromUnaryOperation(location, -numberNode.value(), numberNode);
1164     }
1165 
1166     if (n-&gt;isBigInt()) {
1167         const BigIntNode&amp; bigIntNode = static_cast&lt;const BigIntNode&amp;&gt;(*n);
1168         return createBigIntFromUnaryOperation(location, !bigIntNode.sign(), bigIntNode);
1169     }
1170 
1171     return new (m_parserArena) NegateNode(location, n);
1172 }
1173 
1174 ExpressionNode* ASTBuilder::makeBitwiseNotNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1175 {
1176     if (expr-&gt;isNumber())
1177         return createIntegerLikeNumber(location, ~toInt32(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
1178     return new (m_parserArena) BitwiseNotNode(location, expr);
1179 }
1180 
1181 ExpressionNode* ASTBuilder::makePowNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1182 {
1183     auto* strippedExpr1 = expr1-&gt;stripUnaryPlus();
1184     auto* strippedExpr2 = expr2-&gt;stripUnaryPlus();
1185 
1186     if (strippedExpr1-&gt;isNumber() &amp;&amp; strippedExpr2-&gt;isNumber()) {
1187         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr1);
1188         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr2);
1189         return createNumberFromBinaryOperation(location, operationMathPow(numberExpr1.value(), numberExpr2.value()), numberExpr1, numberExpr2);
1190     }
1191 
1192     if (strippedExpr1-&gt;isNumber())
1193         expr1 = strippedExpr1;
1194     if (strippedExpr2-&gt;isNumber())
1195         expr2 = strippedExpr2;
1196 
1197     return new (m_parserArena) PowNode(location, expr1, expr2, rightHasAssignments);
1198 }
1199 
1200 ExpressionNode* ASTBuilder::makeMultNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1201 {
1202     // FIXME: Unary + change the evaluation order.
1203     // https://bugs.webkit.org/show_bug.cgi?id=159968
1204     expr1 = expr1-&gt;stripUnaryPlus();
1205     expr2 = expr2-&gt;stripUnaryPlus();
1206 
1207     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1208         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1209         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1210         return createNumberFromBinaryOperation(location, numberExpr1.value() * numberExpr2.value(), numberExpr1, numberExpr2);
1211     }
1212 
1213     if (expr1-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr1)-&gt;value() == 1)
1214         return new (m_parserArena) UnaryPlusNode(location, expr2);
1215 
1216     if (expr2-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr2)-&gt;value() == 1)
1217         return new (m_parserArena) UnaryPlusNode(location, expr1);
1218 
1219     return new (m_parserArena) MultNode(location, expr1, expr2, rightHasAssignments);
1220 }
1221 
1222 ExpressionNode* ASTBuilder::makeDivNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1223 {
1224     // FIXME: Unary + change the evaluation order.
1225     // https://bugs.webkit.org/show_bug.cgi?id=159968
1226     expr1 = expr1-&gt;stripUnaryPlus();
1227     expr2 = expr2-&gt;stripUnaryPlus();
1228 
1229     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1230         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1231         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1232         double result = numberExpr1.value() / numberExpr2.value();
1233         if (static_cast&lt;int64_t&gt;(result) == result)
1234             return createNumberFromBinaryOperation(location, result, numberExpr1, numberExpr2);
1235         return createDoubleLikeNumber(location, result);
1236     }
1237     return new (m_parserArena) DivNode(location, expr1, expr2, rightHasAssignments);
1238 }
1239 
1240 ExpressionNode* ASTBuilder::makeModNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1241 {
1242     // FIXME: Unary + change the evaluation order.
1243     // https://bugs.webkit.org/show_bug.cgi?id=159968
1244     expr1 = expr1-&gt;stripUnaryPlus();
1245     expr2 = expr2-&gt;stripUnaryPlus();
1246 
1247     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1248         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1249         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1250         return createIntegerLikeNumber(location, fmod(numberExpr1.value(), numberExpr2.value()));
1251     }
1252     return new (m_parserArena) ModNode(location, expr1, expr2, rightHasAssignments);
1253 }
1254 
1255 ExpressionNode* ASTBuilder::makeAddNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1256 {
1257 
1258     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1259         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1260         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1261         return createNumberFromBinaryOperation(location, numberExpr1.value() + numberExpr2.value(), numberExpr1, numberExpr2);
1262     }
1263     return new (m_parserArena) AddNode(location, expr1, expr2, rightHasAssignments);
1264 }
1265 
1266 ExpressionNode* ASTBuilder::makeSubNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1267 {
1268     // FIXME: Unary + change the evaluation order.
1269     // https://bugs.webkit.org/show_bug.cgi?id=159968
1270     expr1 = expr1-&gt;stripUnaryPlus();
1271     expr2 = expr2-&gt;stripUnaryPlus();
1272 
1273     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1274         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1275         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1276         return createNumberFromBinaryOperation(location, numberExpr1.value() - numberExpr2.value(), numberExpr1, numberExpr2);
1277     }
1278     return new (m_parserArena) SubNode(location, expr1, expr2, rightHasAssignments);
1279 }
1280 
1281 ExpressionNode* ASTBuilder::makeLeftShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1282 {
1283     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1284         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1285         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1286         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &lt;&lt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1287     }
1288     return new (m_parserArena) LeftShiftNode(location, expr1, expr2, rightHasAssignments);
1289 }
1290 
1291 ExpressionNode* ASTBuilder::makeRightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1292 {
1293     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1294         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1295         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1296         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1297     }
1298     return new (m_parserArena) RightShiftNode(location, expr1, expr2, rightHasAssignments);
1299 }
1300 
1301 ExpressionNode* ASTBuilder::makeURightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1302 {
1303     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1304         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1305         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1306         return createIntegerLikeNumber(location, toUInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1307     }
1308     return new (m_parserArena) UnsignedRightShiftNode(location, expr1, expr2, rightHasAssignments);
1309 }
1310 
1311 ExpressionNode* ASTBuilder::makeBitOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1312 {
1313     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1314         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1315         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1316         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) | toInt32(numberExpr2.value()));
1317     }
1318     return new (m_parserArena) BitOrNode(location, expr1, expr2, rightHasAssignments);
1319 }
1320 
1321 ExpressionNode* ASTBuilder::makeBitAndNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1322 {
1323     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1324         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1325         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1326         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &amp; toInt32(numberExpr2.value()));
1327     }
1328     return new (m_parserArena) BitAndNode(location, expr1, expr2, rightHasAssignments);
1329 }
1330 
1331 ExpressionNode* ASTBuilder::makeBitXOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1332 {
1333     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1334         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1335         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1336         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) ^ toInt32(numberExpr2.value()));
1337     }
1338     return new (m_parserArena) BitXOrNode(location, expr1, expr2, rightHasAssignments);
1339 }
1340 
<a name="25" id="anc25"></a><span class="line-modified">1341 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth)</span>














1342 {
1343     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1344     if (func-&gt;isSuperNode())
1345         usesSuperCall();
1346 
1347     if (func-&gt;isBytecodeIntrinsicNode()) {
<a name="26" id="anc26"></a>
1348         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
1349         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant)
1350             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;emitter(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);
1351     }
<a name="27" id="anc27"></a>












1352     if (!func-&gt;isLocation())
1353         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1354     if (func-&gt;isResolveNode()) {
1355         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1356         const Identifier&amp; identifier = resolve-&gt;identifier();
<a name="28" id="anc28"></a><span class="line-modified">1357         if (identifier == m_vm-&gt;propertyNames-&gt;eval) {</span>
1358             usesEval();
1359             return new (m_parserArena) EvalFunctionCallNode(location, args, divot, divotStart, divotEnd);
1360         }
1361         return new (m_parserArena) FunctionCallResolveNode(location, identifier, args, divot, divotStart, divotEnd);
1362     }
1363     if (func-&gt;isBracketAccessorNode()) {
1364         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(func);
1365         FunctionCallBracketNode* node = new (m_parserArena) FunctionCallBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), bracket-&gt;subscriptHasAssignments(), args, divot, divotStart, divotEnd);
1366         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1367         return node;
1368     }
1369     ASSERT(func-&gt;isDotAccessorNode());
1370     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(func);
1371     FunctionCallDotNode* node = nullptr;
<a name="29" id="anc29"></a><span class="line-modified">1372     if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().callPrivateName()))</span>
1373         node = new (m_parserArena) CallFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
<a name="30" id="anc30"></a><span class="line-modified">1374     else if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().applyPublicName() || dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().applyPrivateName())) {</span>
1375         // FIXME: This check is only needed because we haven&#39;t taught the bytecode generator to inline
1376         // Reflect.apply yet. See https://bugs.webkit.org/show_bug.cgi?id=190668.
1377         if (!dot-&gt;base()-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(dot-&gt;base())-&gt;identifier() != &quot;Reflect&quot;)
1378             node = new (m_parserArena) ApplyFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1379     }
1380     if (!node)
1381         node = new (m_parserArena) FunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd);
1382     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1383     return node;
1384 }
1385 
1386 ExpressionNode* ASTBuilder::makeBinaryNode(const JSTokenLocation&amp; location, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; lhs, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; rhs)
1387 {
1388     switch (token) {
<a name="31" id="anc31"></a>


1389     case OR:
1390         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalOr);
1391 
1392     case AND:
1393         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalAnd);
1394 
1395     case BITOR:
1396         return makeBitOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1397 
1398     case BITXOR:
1399         return makeBitXOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1400 
1401     case BITAND:
1402         return makeBitAndNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1403 
1404     case EQEQ:
1405         return new (m_parserArena) EqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1406 
1407     case NE:
1408         return new (m_parserArena) NotEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1409 
1410     case STREQ:
1411         return new (m_parserArena) StrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1412 
1413     case STRNEQ:
1414         return new (m_parserArena) NotStrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1415 
1416     case LT:
1417         return new (m_parserArena) LessNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1418 
1419     case GT:
1420         return new (m_parserArena) GreaterNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1421 
1422     case LE:
1423         return new (m_parserArena) LessEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1424 
1425     case GE:
1426         return new (m_parserArena) GreaterEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1427 
1428     case INSTANCEOF: {
1429         InstanceOfNode* node = new (m_parserArena) InstanceOfNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1430         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1431         return node;
1432     }
1433 
1434     case INTOKEN: {
1435         InNode* node = new (m_parserArena) InNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1436         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1437         return node;
1438     }
1439 
1440     case LSHIFT:
1441         return makeLeftShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1442 
1443     case RSHIFT:
1444         return makeRightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1445 
1446     case URSHIFT:
1447         return makeURightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1448 
1449     case PLUS:
1450         return makeAddNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1451 
1452     case MINUS:
1453         return makeSubNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1454 
1455     case TIMES:
1456         return makeMultNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1457 
1458     case DIVIDE:
1459         return makeDivNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1460 
1461     case MOD:
1462         return makeModNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1463 
1464     case POW:
1465         return makePowNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1466     }
1467     CRASH();
1468     return 0;
1469 }
1470 
1471 ExpressionNode* ASTBuilder::makeAssignNode(const JSTokenLocation&amp; location, ExpressionNode* loc, Operator op, ExpressionNode* expr, bool locHasAssignments, bool exprHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1472 {
<a name="32" id="anc32"></a><span class="line-modified">1473     if (!loc-&gt;isLocation())</span>

1474         return new (m_parserArena) AssignErrorNode(location, divot, start, end);
<a name="33" id="anc33"></a>
1475 
1476     if (loc-&gt;isResolveNode()) {
1477         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(loc);
1478         if (op == OpEqual) {
1479             if (expr-&gt;isBaseFuncExprNode()) {
1480                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata();
1481                 metadata-&gt;setEcmaName(resolve-&gt;identifier());
<a name="34" id="anc34"></a><span class="line-removed">1482                 metadata-&gt;setInferredName(resolve-&gt;identifier());</span>
1483             } else if (expr-&gt;isClassExprNode())
1484                 static_cast&lt;ClassExprNode*&gt;(expr)-&gt;setEcmaName(resolve-&gt;identifier());
1485             AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, resolve-&gt;identifier(), expr, AssignmentContext::AssignmentExpression);
1486             setExceptionLocation(node, start, divot, end);
1487             return node;
1488         }
1489         return new (m_parserArena) ReadModifyResolveNode(location, resolve-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1490     }
1491     if (loc-&gt;isBracketAccessorNode()) {
1492         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(loc);
1493         if (op == OpEqual)
1494             return new (m_parserArena) AssignBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), expr, locHasAssignments, exprHasAssignments, bracket-&gt;divot(), start, end);
1495         ReadModifyBracketNode* node = new (m_parserArena) ReadModifyBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), op, expr, locHasAssignments, exprHasAssignments, divot, start, end);
1496         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1497         return node;
1498     }
1499     ASSERT(loc-&gt;isDotAccessorNode());
1500     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(loc);
<a name="35" id="anc35"></a><span class="line-modified">1501     if (op == OpEqual) {</span>
<span class="line-removed">1502         if (expr-&gt;isBaseFuncExprNode()) {</span>
<span class="line-removed">1503             // We don&#39;t also set the ecma name here because ES6 specifies that the</span>
<span class="line-removed">1504             // function should not pick up the name of the dot-&gt;identifier().</span>
<span class="line-removed">1505             static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata()-&gt;setInferredName(dot-&gt;identifier());</span>
<span class="line-removed">1506         }</span>
1507         return new (m_parserArena) AssignDotNode(location, dot-&gt;base(), dot-&gt;identifier(), expr, exprHasAssignments, dot-&gt;divot(), start, end);
<a name="36" id="anc36"></a><span class="line-removed">1508     }</span>
1509 
1510     ReadModifyDotNode* node = new (m_parserArena) ReadModifyDotNode(location, dot-&gt;base(), dot-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1511     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1512     return node;
1513 }
1514 
1515 ExpressionNode* ASTBuilder::makePrefixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1516 {
1517     return new (m_parserArena) PrefixNode(location, expr, op, divot, start, end);
1518 }
1519 
1520 ExpressionNode* ASTBuilder::makePostfixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1521 {
1522     return new (m_parserArena) PostfixNode(location, expr, op, divot, start, end);
1523 }
1524 
1525 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>