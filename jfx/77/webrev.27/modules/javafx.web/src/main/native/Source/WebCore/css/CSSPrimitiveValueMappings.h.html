<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@nypop.com&gt;.
   3  * Copyright (C) 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   4  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2009 Jeff Schiller &lt;codedread@gmail.com&gt;
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * Redistribution and use in source and binary forms, with or without
   9  * modification, are permitted provided that the following conditions
  10  * are met:
  11  *
  12  * 1. Redistributions of source code must retain the above copyright
  13  *    notice, this list of conditions and the following disclaimer.
  14  * 2. Redistributions in binary form must reproduce the above copyright
  15  *    notice, this list of conditions and the following disclaimer in the
  16  *    documentation and/or other materials provided with the distribution.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR
  19  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  20  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  21  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  22  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  23  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  24  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  25  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;CSSCalculationValue.h&quot;
  33 #include &quot;CSSFontFamily.h&quot;
  34 #include &quot;CSSPrimitiveValue.h&quot;
  35 #include &quot;CSSReflectionDirection.h&quot;
  36 #include &quot;CSSToLengthConversionData.h&quot;
  37 #include &quot;CSSValueKeywords.h&quot;
  38 #include &quot;GraphicsTypes.h&quot;
  39 #include &quot;Length.h&quot;
  40 #include &quot;LineClampValue.h&quot;
  41 #include &quot;RenderStyleConstants.h&quot;
  42 #include &quot;SVGRenderStyleDefs.h&quot;
  43 #include &quot;TextFlags.h&quot;
  44 #include &quot;ThemeTypes.h&quot;
  45 #include &quot;TouchAction.h&quot;
  46 #include &quot;UnicodeBidi.h&quot;
  47 #include &quot;WritingMode.h&quot;
  48 #include &lt;wtf/MathExtras.h&gt;
  49 #include &lt;wtf/OptionSet.h&gt;
  50 
  51 #if ENABLE(CSS_IMAGE_ORIENTATION)
  52 #include &quot;ImageOrientation.h&quot;
  53 #endif
  54 
  55 namespace WebCore {
  56 
  57 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(short i)
  58     : CSSValue(PrimitiveClass)
  59 {
  60     m_primitiveUnitType = CSS_NUMBER;
  61     m_value.num = static_cast&lt;double&gt;(i);
  62 }
  63 
  64 template&lt;&gt; inline CSSPrimitiveValue::operator short() const
  65 {
  66     if (m_primitiveUnitType == CSS_NUMBER)
  67         return clampTo&lt;short&gt;(m_value.num);
  68 
  69     ASSERT_NOT_REACHED();
  70     return 0;
  71 }
  72 
  73 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(unsigned short i)
  74     : CSSValue(PrimitiveClass)
  75 {
  76     m_primitiveUnitType = CSS_NUMBER;
  77     m_value.num = static_cast&lt;double&gt;(i);
  78 }
  79 
  80 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned short() const
  81 {
  82     if (primitiveType() == CSS_NUMBER)
  83         return value&lt;unsigned short&gt;();
  84 
  85     ASSERT_NOT_REACHED();
  86     return 0;
  87 }
  88 
  89 template&lt;&gt; inline CSSPrimitiveValue::operator int() const
  90 {
  91     if (primitiveType() == CSS_NUMBER)
  92         return value&lt;int&gt;();
  93 
  94     ASSERT_NOT_REACHED();
  95     return 0;
  96 }
  97 
  98 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned() const
  99 {
 100     if (primitiveType() == CSS_NUMBER)
 101         return value&lt;unsigned&gt;();
 102 
 103     ASSERT_NOT_REACHED();
 104     return 0;
 105 }
 106 
 107 
 108 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(float i)
 109     : CSSValue(PrimitiveClass)
 110 {
 111     m_primitiveUnitType = CSS_NUMBER;
 112     m_value.num = static_cast&lt;double&gt;(i);
 113 }
 114 
 115 template&lt;&gt; inline CSSPrimitiveValue::operator float() const
 116 {
 117     if (primitiveType() == CSS_NUMBER)
 118         return value&lt;float&gt;();
 119 
 120     ASSERT_NOT_REACHED();
 121     return 0.0f;
 122 }
 123 
 124 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineClampValue i)
 125     : CSSValue(PrimitiveClass)
 126 {
 127     m_primitiveUnitType = i.isPercentage() ? CSS_PERCENTAGE : CSS_NUMBER;
 128     m_value.num = static_cast&lt;double&gt;(i.value());
 129 }
 130 
 131 template&lt;&gt; inline CSSPrimitiveValue::operator LineClampValue() const
 132 {
 133     if (primitiveType() == CSS_NUMBER)
 134         return LineClampValue(value&lt;int&gt;(), LineClamp::LineCount);
 135 
 136     if (primitiveType() == CSS_PERCENTAGE)
 137         return LineClampValue(value&lt;int&gt;(), LineClamp::Percentage);
 138 
 139     ASSERT_NOT_REACHED();
 140     return LineClampValue();
 141 }
 142 
 143 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSReflectionDirection e)
 144     : CSSValue(PrimitiveClass)
 145 {
 146     m_primitiveUnitType = CSS_VALUE_ID;
 147     switch (e) {
 148     case ReflectionAbove:
 149         m_value.valueID = CSSValueAbove;
 150         break;
 151     case ReflectionBelow:
 152         m_value.valueID = CSSValueBelow;
 153         break;
 154     case ReflectionLeft:
 155         m_value.valueID = CSSValueLeft;
 156         break;
 157     case ReflectionRight:
 158         m_value.valueID = CSSValueRight;
 159     }
 160 }
 161 
 162 template&lt;&gt; inline CSSPrimitiveValue::operator CSSReflectionDirection() const
 163 {
 164     ASSERT(isValueID());
 165 
 166     switch (m_value.valueID) {
 167     case CSSValueAbove:
 168         return ReflectionAbove;
 169     case CSSValueBelow:
 170         return ReflectionBelow;
 171     case CSSValueLeft:
 172         return ReflectionLeft;
 173     case CSSValueRight:
 174         return ReflectionRight;
 175     default:
 176         break;
 177     }
 178 
 179     ASSERT_NOT_REACHED();
 180     return ReflectionBelow;
 181 }
 182 
 183 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnFill columnFill)
 184     : CSSValue(PrimitiveClass)
 185 {
 186     m_primitiveUnitType = CSS_VALUE_ID;
 187     switch (columnFill) {
 188     case ColumnFill::Auto:
 189         m_value.valueID = CSSValueAuto;
 190         break;
 191     case ColumnFill::Balance:
 192         m_value.valueID = CSSValueBalance;
 193         break;
 194     }
 195 }
 196 
 197 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnFill() const
 198 {
 199     if (m_primitiveUnitType == CSS_VALUE_ID) {
 200         if (m_value.valueID == CSSValueBalance)
 201             return ColumnFill::Balance;
 202         if (m_value.valueID == CSSValueAuto)
 203             return ColumnFill::Auto;
 204     }
 205     ASSERT_NOT_REACHED();
 206     return ColumnFill::Balance;
 207 }
 208 
 209 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnSpan columnSpan)
 210     : CSSValue(PrimitiveClass)
 211 {
 212     m_primitiveUnitType = CSS_VALUE_ID;
 213     switch (columnSpan) {
 214     case ColumnSpan::All:
 215         m_value.valueID = CSSValueAll;
 216         break;
 217     case ColumnSpan::None:
 218         m_value.valueID = CSSValueNone;
 219         break;
 220     }
 221 }
 222 
 223 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnSpan() const
 224 {
 225     // Map 1 to none for compatibility reasons.
 226     if (m_primitiveUnitType == CSS_NUMBER &amp;&amp; m_value.num == 1)
 227         return ColumnSpan::None;
 228 
 229     ASSERT(isValueID());
 230 
 231     switch (m_value.valueID) {
 232     case CSSValueAll:
 233         return ColumnSpan::All;
 234     case CSSValueNone:
 235         return ColumnSpan::None;
 236     default:
 237         break;
 238     }
 239 
 240     ASSERT_NOT_REACHED();
 241     return ColumnSpan::None;
 242 }
 243 
 244 
 245 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PrintColorAdjust value)
 246     : CSSValue(PrimitiveClass)
 247 {
 248     m_primitiveUnitType = CSS_VALUE_ID;
 249     switch (value) {
 250     case PrintColorAdjust::Exact:
 251         m_value.valueID = CSSValueExact;
 252         break;
 253     case PrintColorAdjust::Economy:
 254         m_value.valueID = CSSValueEconomy;
 255         break;
 256     }
 257 }
 258 
 259 template&lt;&gt; inline CSSPrimitiveValue::operator PrintColorAdjust() const
 260 {
 261     ASSERT(isValueID());
 262 
 263     switch (m_value.valueID) {
 264     case CSSValueEconomy:
 265         return PrintColorAdjust::Economy;
 266     case CSSValueExact:
 267         return PrintColorAdjust::Exact;
 268     default:
 269         break;
 270     }
 271 
 272     ASSERT_NOT_REACHED();
 273     return PrintColorAdjust::Economy;
 274 }
 275 
 276 
 277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderStyle e)
 278     : CSSValue(PrimitiveClass)
 279 {
 280     m_primitiveUnitType = CSS_VALUE_ID;
 281     switch (e) {
 282     case BorderStyle::None:
 283         m_value.valueID = CSSValueNone;
 284         break;
 285     case BorderStyle::Hidden:
 286         m_value.valueID = CSSValueHidden;
 287         break;
 288     case BorderStyle::Inset:
 289         m_value.valueID = CSSValueInset;
 290         break;
 291     case BorderStyle::Groove:
 292         m_value.valueID = CSSValueGroove;
 293         break;
 294     case BorderStyle::Ridge:
 295         m_value.valueID = CSSValueRidge;
 296         break;
 297     case BorderStyle::Outset:
 298         m_value.valueID = CSSValueOutset;
 299         break;
 300     case BorderStyle::Dotted:
 301         m_value.valueID = CSSValueDotted;
 302         break;
 303     case BorderStyle::Dashed:
 304         m_value.valueID = CSSValueDashed;
 305         break;
 306     case BorderStyle::Solid:
 307         m_value.valueID = CSSValueSolid;
 308         break;
 309     case BorderStyle::Double:
 310         m_value.valueID = CSSValueDouble;
 311         break;
 312     }
 313 }
 314 
 315 template&lt;&gt; inline CSSPrimitiveValue::operator BorderStyle() const
 316 {
 317     ASSERT(isValueID());
 318 
 319     if (m_value.valueID == CSSValueAuto) // Valid for CSS outline-style
 320         return BorderStyle::Dotted;
 321     return static_cast&lt;BorderStyle&gt;(m_value.valueID - CSSValueNone);
 322 }
 323 
 324 template&lt;&gt; inline CSSPrimitiveValue::operator OutlineIsAuto() const
 325 {
 326     ASSERT(isValueID());
 327 
 328     if (m_value.valueID == CSSValueAuto)
 329         return OutlineIsAuto::On;
 330     return OutlineIsAuto::Off;
 331 }
 332 
 333 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CompositeOperator e)
 334     : CSSValue(PrimitiveClass)
 335 {
 336     m_primitiveUnitType = CSS_VALUE_ID;
 337     switch (e) {
 338     case CompositeClear:
 339         m_value.valueID = CSSValueClear;
 340         break;
 341     case CompositeCopy:
 342         m_value.valueID = CSSValueCopy;
 343         break;
 344     case CompositeSourceOver:
 345         m_value.valueID = CSSValueSourceOver;
 346         break;
 347     case CompositeSourceIn:
 348         m_value.valueID = CSSValueSourceIn;
 349         break;
 350     case CompositeSourceOut:
 351         m_value.valueID = CSSValueSourceOut;
 352         break;
 353     case CompositeSourceAtop:
 354         m_value.valueID = CSSValueSourceAtop;
 355         break;
 356     case CompositeDestinationOver:
 357         m_value.valueID = CSSValueDestinationOver;
 358         break;
 359     case CompositeDestinationIn:
 360         m_value.valueID = CSSValueDestinationIn;
 361         break;
 362     case CompositeDestinationOut:
 363         m_value.valueID = CSSValueDestinationOut;
 364         break;
 365     case CompositeDestinationAtop:
 366         m_value.valueID = CSSValueDestinationAtop;
 367         break;
 368     case CompositeXOR:
 369         m_value.valueID = CSSValueXor;
 370         break;
 371     case CompositePlusDarker:
 372         m_value.valueID = CSSValuePlusDarker;
 373         break;
 374     case CompositePlusLighter:
 375         m_value.valueID = CSSValuePlusLighter;
 376         break;
 377     case CompositeDifference:
 378         ASSERT_NOT_REACHED();
 379         break;
 380     }
 381 }
 382 
 383 template&lt;&gt; inline CSSPrimitiveValue::operator CompositeOperator() const
 384 {
 385     ASSERT(isValueID());
 386 
 387     switch (m_value.valueID) {
 388     case CSSValueClear:
 389         return CompositeClear;
 390     case CSSValueCopy:
 391         return CompositeCopy;
 392     case CSSValueSourceOver:
 393         return CompositeSourceOver;
 394     case CSSValueSourceIn:
 395         return CompositeSourceIn;
 396     case CSSValueSourceOut:
 397         return CompositeSourceOut;
 398     case CSSValueSourceAtop:
 399         return CompositeSourceAtop;
 400     case CSSValueDestinationOver:
 401         return CompositeDestinationOver;
 402     case CSSValueDestinationIn:
 403         return CompositeDestinationIn;
 404     case CSSValueDestinationOut:
 405         return CompositeDestinationOut;
 406     case CSSValueDestinationAtop:
 407         return CompositeDestinationAtop;
 408     case CSSValueXor:
 409         return CompositeXOR;
 410     case CSSValuePlusDarker:
 411         return CompositePlusDarker;
 412     case CSSValuePlusLighter:
 413         return CompositePlusLighter;
 414     default:
 415         break;
 416     }
 417 
 418     ASSERT_NOT_REACHED();
 419     return CompositeClear;
 420 }
 421 
 422 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ControlPart e)
 423     : CSSValue(PrimitiveClass)
 424 {
 425     m_primitiveUnitType = CSS_VALUE_ID;
 426     switch (e) {
 427     case NoControlPart:
 428         m_value.valueID = CSSValueNone;
 429         break;
 430     case CheckboxPart:
 431         m_value.valueID = CSSValueCheckbox;
 432         break;
 433     case RadioPart:
 434         m_value.valueID = CSSValueRadio;
 435         break;
 436     case PushButtonPart:
 437         m_value.valueID = CSSValuePushButton;
 438         break;
 439     case SquareButtonPart:
 440         m_value.valueID = CSSValueSquareButton;
 441         break;
 442     case ButtonPart:
 443         m_value.valueID = CSSValueButton;
 444         break;
 445     case ButtonBevelPart:
 446         m_value.valueID = CSSValueButtonBevel;
 447         break;
 448     case DefaultButtonPart:
 449         m_value.valueID = CSSValueDefaultButton;
 450         break;
 451     case InnerSpinButtonPart:
 452         m_value.valueID = CSSValueInnerSpinButton;
 453         break;
 454     case ListboxPart:
 455         m_value.valueID = CSSValueListbox;
 456         break;
 457     case ListItemPart:
 458         m_value.valueID = CSSValueListitem;
 459         break;
 460     case MediaEnterFullscreenButtonPart:
 461         m_value.valueID = CSSValueMediaEnterFullscreenButton;
 462         break;
 463     case MediaExitFullscreenButtonPart:
 464         m_value.valueID = CSSValueMediaExitFullscreenButton;
 465         break;
 466     case MediaPlayButtonPart:
 467         m_value.valueID = CSSValueMediaPlayButton;
 468         break;
 469     case MediaOverlayPlayButtonPart:
 470         m_value.valueID = CSSValueMediaOverlayPlayButton;
 471         break;
 472     case MediaMuteButtonPart:
 473         m_value.valueID = CSSValueMediaMuteButton;
 474         break;
 475     case MediaSeekBackButtonPart:
 476         m_value.valueID = CSSValueMediaSeekBackButton;
 477         break;
 478     case MediaSeekForwardButtonPart:
 479         m_value.valueID = CSSValueMediaSeekForwardButton;
 480         break;
 481     case MediaRewindButtonPart:
 482         m_value.valueID = CSSValueMediaRewindButton;
 483         break;
 484     case MediaReturnToRealtimeButtonPart:
 485         m_value.valueID = CSSValueMediaReturnToRealtimeButton;
 486         break;
 487     case MediaToggleClosedCaptionsButtonPart:
 488         m_value.valueID = CSSValueMediaToggleClosedCaptionsButton;
 489         break;
 490     case MediaSliderPart:
 491         m_value.valueID = CSSValueMediaSlider;
 492         break;
 493     case MediaSliderThumbPart:
 494         m_value.valueID = CSSValueMediaSliderthumb;
 495         break;
 496     case MediaVolumeSliderContainerPart:
 497         m_value.valueID = CSSValueMediaVolumeSliderContainer;
 498         break;
 499     case MediaVolumeSliderPart:
 500         m_value.valueID = CSSValueMediaVolumeSlider;
 501         break;
 502     case MediaVolumeSliderMuteButtonPart:
 503         m_value.valueID = CSSValueMediaVolumeSliderMuteButton;
 504         break;
 505     case MediaVolumeSliderThumbPart:
 506         m_value.valueID = CSSValueMediaVolumeSliderthumb;
 507         break;
 508     case MediaControlsBackgroundPart:
 509         m_value.valueID = CSSValueMediaControlsBackground;
 510         break;
 511     case MediaControlsFullscreenBackgroundPart:
 512         m_value.valueID = CSSValueMediaControlsFullscreenBackground;
 513         break;
 514     case MediaFullScreenVolumeSliderPart:
 515         m_value.valueID = CSSValueMediaFullscreenVolumeSlider;
 516         break;
 517     case MediaFullScreenVolumeSliderThumbPart:
 518         m_value.valueID = CSSValueMediaFullscreenVolumeSliderThumb;
 519         break;
 520     case MediaCurrentTimePart:
 521         m_value.valueID = CSSValueMediaCurrentTimeDisplay;
 522         break;
 523     case MediaTimeRemainingPart:
 524         m_value.valueID = CSSValueMediaTimeRemainingDisplay;
 525         break;
 526     case MediaControlsLightBarBackgroundPart:
 527         m_value.valueID = CSSValueMediaControlsLightBarBackground;
 528         break;
 529     case MediaControlsDarkBarBackgroundPart:
 530         m_value.valueID = CSSValueMediaControlsDarkBarBackground;
 531         break;
 532     case MenulistPart:
 533         m_value.valueID = CSSValueMenulist;
 534         break;
 535     case MenulistButtonPart:
 536         m_value.valueID = CSSValueMenulistButton;
 537         break;
 538     case MenulistTextPart:
 539         m_value.valueID = CSSValueMenulistText;
 540         break;
 541     case MenulistTextFieldPart:
 542         m_value.valueID = CSSValueMenulistTextfield;
 543         break;
 544     case MeterPart:
 545         m_value.valueID = CSSValueMeter;
 546         break;
 547     case RelevancyLevelIndicatorPart:
 548         m_value.valueID = CSSValueRelevancyLevelIndicator;
 549         break;
 550     case ContinuousCapacityLevelIndicatorPart:
 551         m_value.valueID = CSSValueContinuousCapacityLevelIndicator;
 552         break;
 553     case DiscreteCapacityLevelIndicatorPart:
 554         m_value.valueID = CSSValueDiscreteCapacityLevelIndicator;
 555         break;
 556     case RatingLevelIndicatorPart:
 557         m_value.valueID = CSSValueRatingLevelIndicator;
 558         break;
 559     case ProgressBarPart:
 560         m_value.valueID = CSSValueProgressBar;
 561         break;
 562     case ProgressBarValuePart:
 563         m_value.valueID = CSSValueProgressBarValue;
 564         break;
 565     case SliderHorizontalPart:
 566         m_value.valueID = CSSValueSliderHorizontal;
 567         break;
 568     case SliderVerticalPart:
 569         m_value.valueID = CSSValueSliderVertical;
 570         break;
 571     case SliderThumbHorizontalPart:
 572         m_value.valueID = CSSValueSliderthumbHorizontal;
 573         break;
 574     case SliderThumbVerticalPart:
 575         m_value.valueID = CSSValueSliderthumbVertical;
 576         break;
 577     case CaretPart:
 578         m_value.valueID = CSSValueCaret;
 579         break;
 580     case SearchFieldPart:
 581         m_value.valueID = CSSValueSearchfield;
 582         break;
 583     case SearchFieldDecorationPart:
 584         m_value.valueID = CSSValueSearchfieldDecoration;
 585         break;
 586     case SearchFieldResultsDecorationPart:
 587         m_value.valueID = CSSValueSearchfieldResultsDecoration;
 588         break;
 589     case SearchFieldResultsButtonPart:
 590         m_value.valueID = CSSValueSearchfieldResultsButton;
 591         break;
 592     case SearchFieldCancelButtonPart:
 593         m_value.valueID = CSSValueSearchfieldCancelButton;
 594         break;
 595     case SnapshottedPluginOverlayPart:
 596         m_value.valueID = CSSValueSnapshottedPluginOverlay;
 597         break;
 598     case TextFieldPart:
 599         m_value.valueID = CSSValueTextfield;
 600         break;
 601     case TextAreaPart:
 602         m_value.valueID = CSSValueTextarea;
 603         break;
 604     case CapsLockIndicatorPart:
 605         m_value.valueID = CSSValueCapsLockIndicator;
 606         break;
 607 #if ENABLE(ATTACHMENT_ELEMENT)
 608     case AttachmentPart:
 609         m_value.valueID = CSSValueAttachment;
 610         break;
 611     case BorderlessAttachmentPart:
 612         m_value.valueID = CSSValueBorderlessAttachment;
 613         break;
 614 #endif
 615 #if ENABLE(SERVICE_CONTROLS)
 616     case ImageControlsButtonPart:
 617         m_value.valueID = CSSValueImageControlsButton;
 618         break;
 619 #endif
 620 #if ENABLE(APPLE_PAY)
 621     case ApplePayButtonPart:
 622         m_value.valueID = CSSValueApplePayButton;
 623         break;
 624 #endif
 625 #if ENABLE(INPUT_TYPE_COLOR)
 626     case ColorWellPart:
 627         m_value.valueID = CSSValueColorWell;
 628         break;
 629 #endif
 630 #if ENABLE(DATALIST_ELEMENT)
 631     case ListButtonPart:
 632         m_value.valueID = CSSValueListButton;
 633         break;
 634 #endif
 635     }
 636 }
 637 
 638 template&lt;&gt; inline CSSPrimitiveValue::operator ControlPart() const
 639 {
 640     ASSERT(isValueID());
 641 
 642     if (m_value.valueID == CSSValueNone)
 643         return NoControlPart;
 644     return ControlPart(m_value.valueID - CSSValueCheckbox + 1);
 645 }
 646 
 647 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BackfaceVisibility e)
 648     : CSSValue(PrimitiveClass)
 649 {
 650     m_primitiveUnitType = CSS_VALUE_ID;
 651     switch (e) {
 652     case BackfaceVisibility::Visible:
 653         m_value.valueID = CSSValueVisible;
 654         break;
 655     case BackfaceVisibility::Hidden:
 656         m_value.valueID = CSSValueHidden;
 657         break;
 658     }
 659 }
 660 
 661 template&lt;&gt; inline CSSPrimitiveValue::operator BackfaceVisibility() const
 662 {
 663     ASSERT(isValueID());
 664 
 665     switch (m_value.valueID) {
 666     case CSSValueVisible:
 667         return BackfaceVisibility::Visible;
 668     case CSSValueHidden:
 669         return BackfaceVisibility::Hidden;
 670     default:
 671         break;
 672     }
 673 
 674     ASSERT_NOT_REACHED();
 675     return BackfaceVisibility::Hidden;
 676 }
 677 
 678 
 679 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillAttachment e)
 680     : CSSValue(PrimitiveClass)
 681 {
 682     m_primitiveUnitType = CSS_VALUE_ID;
 683     switch (e) {
 684     case FillAttachment::ScrollBackground:
 685         m_value.valueID = CSSValueScroll;
 686         break;
 687     case FillAttachment::LocalBackground:
 688         m_value.valueID = CSSValueLocal;
 689         break;
 690     case FillAttachment::FixedBackground:
 691         m_value.valueID = CSSValueFixed;
 692         break;
 693     }
 694 }
 695 
 696 template&lt;&gt; inline CSSPrimitiveValue::operator FillAttachment() const
 697 {
 698     ASSERT(isValueID());
 699 
 700     switch (m_value.valueID) {
 701     case CSSValueScroll:
 702         return FillAttachment::ScrollBackground;
 703     case CSSValueLocal:
 704         return FillAttachment::LocalBackground;
 705     case CSSValueFixed:
 706         return FillAttachment::FixedBackground;
 707     default:
 708         break;
 709     }
 710 
 711     ASSERT_NOT_REACHED();
 712     return FillAttachment::ScrollBackground;
 713 }
 714 
 715 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillBox e)
 716     : CSSValue(PrimitiveClass)
 717 {
 718     m_primitiveUnitType = CSS_VALUE_ID;
 719     switch (e) {
 720     case FillBox::Border:
 721         m_value.valueID = CSSValueBorderBox;
 722         break;
 723     case FillBox::Padding:
 724         m_value.valueID = CSSValuePaddingBox;
 725         break;
 726     case FillBox::Content:
 727         m_value.valueID = CSSValueContentBox;
 728         break;
 729     case FillBox::Text:
 730         m_value.valueID = CSSValueText;
 731         break;
 732     }
 733 }
 734 
 735 template&lt;&gt; inline CSSPrimitiveValue::operator FillBox() const
 736 {
 737     ASSERT(isValueID());
 738 
 739     switch (m_value.valueID) {
 740     case CSSValueBorder:
 741     case CSSValueBorderBox:
 742         return FillBox::Border;
 743     case CSSValuePadding:
 744     case CSSValuePaddingBox:
 745         return FillBox::Padding;
 746     case CSSValueContent:
 747     case CSSValueContentBox:
 748         return FillBox::Content;
 749     case CSSValueText:
 750     case CSSValueWebkitText:
 751         return FillBox::Text;
 752     default:
 753         break;
 754     }
 755 
 756     ASSERT_NOT_REACHED();
 757     return FillBox::Border;
 758 }
 759 
 760 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillRepeat e)
 761     : CSSValue(PrimitiveClass)
 762 {
 763     m_primitiveUnitType = CSS_VALUE_ID;
 764     switch (e) {
 765     case FillRepeat::Repeat:
 766         m_value.valueID = CSSValueRepeat;
 767         break;
 768     case FillRepeat::NoRepeat:
 769         m_value.valueID = CSSValueNoRepeat;
 770         break;
 771     case FillRepeat::Round:
 772         m_value.valueID = CSSValueRound;
 773         break;
 774     case FillRepeat::Space:
 775         m_value.valueID = CSSValueSpace;
 776         break;
 777     }
 778 }
 779 
 780 template&lt;&gt; inline CSSPrimitiveValue::operator FillRepeat() const
 781 {
 782     ASSERT(isValueID());
 783 
 784     switch (m_value.valueID) {
 785     case CSSValueRepeat:
 786         return FillRepeat::Repeat;
 787     case CSSValueNoRepeat:
 788         return FillRepeat::NoRepeat;
 789     case CSSValueRound:
 790         return FillRepeat::Round;
 791     case CSSValueSpace:
 792         return FillRepeat::Space;
 793     default:
 794         break;
 795     }
 796 
 797     ASSERT_NOT_REACHED();
 798     return FillRepeat::Repeat;
 799 }
 800 
 801 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxPack e)
 802     : CSSValue(PrimitiveClass)
 803 {
 804     m_primitiveUnitType = CSS_VALUE_ID;
 805     switch (e) {
 806     case BoxPack::Start:
 807         m_value.valueID = CSSValueStart;
 808         break;
 809     case BoxPack::Center:
 810         m_value.valueID = CSSValueCenter;
 811         break;
 812     case BoxPack::End:
 813         m_value.valueID = CSSValueEnd;
 814         break;
 815     case BoxPack::Justify:
 816         m_value.valueID = CSSValueJustify;
 817         break;
 818     }
 819 }
 820 
 821 template&lt;&gt; inline CSSPrimitiveValue::operator BoxPack() const
 822 {
 823     ASSERT(isValueID());
 824 
 825     switch (m_value.valueID) {
 826     case CSSValueStart:
 827         return BoxPack::Start;
 828     case CSSValueEnd:
 829         return BoxPack::End;
 830     case CSSValueCenter:
 831         return BoxPack::Center;
 832     case CSSValueJustify:
 833         return BoxPack::Justify;
 834     default:
 835         break;
 836     }
 837 
 838     ASSERT_NOT_REACHED();
 839     return BoxPack::Justify;
 840 }
 841 
 842 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxAlignment e)
 843     : CSSValue(PrimitiveClass)
 844 {
 845     m_primitiveUnitType = CSS_VALUE_ID;
 846     switch (e) {
 847     case BoxAlignment::Stretch:
 848         m_value.valueID = CSSValueStretch;
 849         break;
 850     case BoxAlignment::Start:
 851         m_value.valueID = CSSValueStart;
 852         break;
 853     case BoxAlignment::Center:
 854         m_value.valueID = CSSValueCenter;
 855         break;
 856     case BoxAlignment::End:
 857         m_value.valueID = CSSValueEnd;
 858         break;
 859     case BoxAlignment::Baseline:
 860         m_value.valueID = CSSValueBaseline;
 861         break;
 862     }
 863 }
 864 
 865 template&lt;&gt; inline CSSPrimitiveValue::operator BoxAlignment() const
 866 {
 867     ASSERT(isValueID());
 868 
 869     switch (m_value.valueID) {
 870     case CSSValueStretch:
 871         return BoxAlignment::Stretch;
 872     case CSSValueStart:
 873         return BoxAlignment::Start;
 874     case CSSValueEnd:
 875         return BoxAlignment::End;
 876     case CSSValueCenter:
 877         return BoxAlignment::Center;
 878     case CSSValueBaseline:
 879         return BoxAlignment::Baseline;
 880     default:
 881         break;
 882     }
 883 
 884     ASSERT_NOT_REACHED();
 885     return BoxAlignment::Stretch;
 886 }
 887 
 888 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 889 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDecorationBreak e)
 890     : CSSValue(PrimitiveClass)
 891 {
 892     m_primitiveUnitType = CSS_VALUE_ID;
 893     switch (e) {
 894     case BoxDecorationBreak::Slice:
 895         m_value.valueID = CSSValueSlice;
 896         break;
 897     case BoxDecorationBreak::Clone:
 898         m_value.valueID = CSSValueClone;
 899         break;
 900     }
 901 }
 902 
 903 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDecorationBreak() const
 904 {
 905     ASSERT(isValueID());
 906 
 907     switch (m_value.valueID) {
 908     case CSSValueSlice:
 909         return BoxDecorationBreak::Slice;
 910     case CSSValueClone:
 911         return BoxDecorationBreak::Clone;
 912     default:
 913         break;
 914     }
 915 
 916     ASSERT_NOT_REACHED();
 917     return BoxDecorationBreak::Slice;
 918 }
 919 #endif
 920 
 921 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Edge e)
 922     : CSSValue(PrimitiveClass)
 923 {
 924     m_primitiveUnitType = CSS_VALUE_ID;
 925     switch (e) {
 926     case Edge::Top:
 927         m_value.valueID = CSSValueTop;
 928         break;
 929     case Edge::Right:
 930         m_value.valueID = CSSValueRight;
 931         break;
 932     case Edge::Bottom:
 933         m_value.valueID = CSSValueBottom;
 934         break;
 935     case Edge::Left:
 936         m_value.valueID = CSSValueLeft;
 937         break;
 938     }
 939 }
 940 
 941 template&lt;&gt; inline CSSPrimitiveValue::operator Edge() const
 942 {
 943     ASSERT(isValueID());
 944 
 945     switch (m_value.valueID) {
 946     case CSSValueTop:
 947         return Edge::Top;
 948     case CSSValueRight:
 949         return Edge::Right;
 950     case CSSValueBottom:
 951         return Edge::Bottom;
 952     case CSSValueLeft:
 953         return Edge::Left;
 954     default:
 955         break;
 956     }
 957 
 958     ASSERT_NOT_REACHED();
 959     return Edge::Top;
 960 }
 961 
 962 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxSizing e)
 963     : CSSValue(PrimitiveClass)
 964 {
 965     m_primitiveUnitType = CSS_VALUE_ID;
 966     switch (e) {
 967     case BoxSizing::BorderBox:
 968         m_value.valueID = CSSValueBorderBox;
 969         break;
 970     case BoxSizing::ContentBox:
 971         m_value.valueID = CSSValueContentBox;
 972         break;
 973     }
 974 }
 975 
 976 template&lt;&gt; inline CSSPrimitiveValue::operator BoxSizing() const
 977 {
 978     ASSERT(isValueID());
 979 
 980     switch (m_value.valueID) {
 981     case CSSValueBorderBox:
 982         return BoxSizing::BorderBox;
 983     case CSSValueContentBox:
 984         return BoxSizing::ContentBox;
 985     default:
 986         break;
 987     }
 988 
 989     ASSERT_NOT_REACHED();
 990     return BoxSizing::BorderBox;
 991 }
 992 
 993 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDirection e)
 994     : CSSValue(PrimitiveClass)
 995 {
 996     m_primitiveUnitType = CSS_VALUE_ID;
 997     switch (e) {
 998     case BoxDirection::Normal:
 999         m_value.valueID = CSSValueNormal;
1000         break;
1001     case BoxDirection::Reverse:
1002         m_value.valueID = CSSValueReverse;
1003         break;
1004     }
1005 }
1006 
1007 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDirection() const
1008 {
1009     ASSERT(isValueID());
1010 
1011     switch (m_value.valueID) {
1012     case CSSValueNormal:
1013         return BoxDirection::Normal;
1014     case CSSValueReverse:
1015         return BoxDirection::Reverse;
1016     default:
1017         break;
1018     }
1019 
1020     ASSERT_NOT_REACHED();
1021     return BoxDirection::Normal;
1022 }
1023 
1024 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxLines e)
1025     : CSSValue(PrimitiveClass)
1026 {
1027     m_primitiveUnitType = CSS_VALUE_ID;
1028     switch (e) {
1029     case BoxLines::Single:
1030         m_value.valueID = CSSValueSingle;
1031         break;
1032     case BoxLines::Multiple:
1033         m_value.valueID = CSSValueMultiple;
1034         break;
1035     }
1036 }
1037 
1038 template&lt;&gt; inline CSSPrimitiveValue::operator BoxLines() const
1039 {
1040     ASSERT(isValueID());
1041 
1042     switch (m_value.valueID) {
1043     case CSSValueSingle:
1044         return BoxLines::Single;
1045     case CSSValueMultiple:
1046         return BoxLines::Multiple;
1047     default:
1048         break;
1049     }
1050 
1051     ASSERT_NOT_REACHED();
1052     return BoxLines::Single;
1053 }
1054 
1055 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxOrient e)
1056     : CSSValue(PrimitiveClass)
1057 {
1058     m_primitiveUnitType = CSS_VALUE_ID;
1059     switch (e) {
1060     case BoxOrient::Horizontal:
1061         m_value.valueID = CSSValueHorizontal;
1062         break;
1063     case BoxOrient::Vertical:
1064         m_value.valueID = CSSValueVertical;
1065         break;
1066     }
1067 }
1068 
1069 template&lt;&gt; inline CSSPrimitiveValue::operator BoxOrient() const
1070 {
1071     ASSERT(isValueID());
1072 
1073     switch (m_value.valueID) {
1074     case CSSValueHorizontal:
1075     case CSSValueInlineAxis:
1076         return BoxOrient::Horizontal;
1077     case CSSValueVertical:
1078     case CSSValueBlockAxis:
1079         return BoxOrient::Vertical;
1080     default:
1081         break;
1082     }
1083 
1084     ASSERT_NOT_REACHED();
1085     return BoxOrient::Horizontal;
1086 }
1087 
1088 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CaptionSide e)
1089     : CSSValue(PrimitiveClass)
1090 {
1091     m_primitiveUnitType = CSS_VALUE_ID;
1092     switch (e) {
1093     case CaptionSide::Left:
1094         m_value.valueID = CSSValueLeft;
1095         break;
1096     case CaptionSide::Right:
1097         m_value.valueID = CSSValueRight;
1098         break;
1099     case CaptionSide::Top:
1100         m_value.valueID = CSSValueTop;
1101         break;
1102     case CaptionSide::Bottom:
1103         m_value.valueID = CSSValueBottom;
1104         break;
1105     }
1106 }
1107 
1108 template&lt;&gt; inline CSSPrimitiveValue::operator CaptionSide() const
1109 {
1110     ASSERT(isValueID());
1111 
1112     switch (m_value.valueID) {
1113     case CSSValueLeft:
1114         return CaptionSide::Left;
1115     case CSSValueRight:
1116         return CaptionSide::Right;
1117     case CSSValueTop:
1118         return CaptionSide::Top;
1119     case CSSValueBottom:
1120         return CaptionSide::Bottom;
1121     default:
1122         break;
1123     }
1124 
1125     ASSERT_NOT_REACHED();
1126     return CaptionSide::Top;
1127 }
1128 
1129 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Clear e)
1130     : CSSValue(PrimitiveClass)
1131 {
1132     m_primitiveUnitType = CSS_VALUE_ID;
1133     switch (e) {
1134     case Clear::None:
1135         m_value.valueID = CSSValueNone;
1136         break;
1137     case Clear::Left:
1138         m_value.valueID = CSSValueLeft;
1139         break;
1140     case Clear::Right:
1141         m_value.valueID = CSSValueRight;
1142         break;
1143     case Clear::Both:
1144         m_value.valueID = CSSValueBoth;
1145         break;
1146     }
1147 }
1148 
1149 template&lt;&gt; inline CSSPrimitiveValue::operator Clear() const
1150 {
1151     ASSERT(isValueID());
1152 
1153     switch (m_value.valueID) {
1154     case CSSValueNone:
1155         return Clear::None;
1156     case CSSValueLeft:
1157         return Clear::Left;
1158     case CSSValueRight:
1159         return Clear::Right;
1160     case CSSValueBoth:
1161         return Clear::Both;
1162     default:
1163         break;
1164     }
1165 
1166     ASSERT_NOT_REACHED();
1167     return Clear::None;
1168 }
1169 
1170 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorType e)
1171     : CSSValue(PrimitiveClass)
1172 {
1173     m_primitiveUnitType = CSS_VALUE_ID;
1174     switch (e) {
1175     case CursorType::Auto:
1176         m_value.valueID = CSSValueAuto;
1177         break;
1178     case CursorType::Default:
1179         m_value.valueID = CSSValueDefault;
1180         break;
1181     case CursorType::None:
1182         m_value.valueID = CSSValueNone;
1183         break;
1184     case CursorType::ContextMenu:
1185         m_value.valueID = CSSValueContextMenu;
1186         break;
1187     case CursorType::Help:
1188         m_value.valueID = CSSValueHelp;
1189         break;
1190     case CursorType::Pointer:
1191         m_value.valueID = CSSValuePointer;
1192         break;
1193     case CursorType::Progress:
1194         m_value.valueID = CSSValueProgress;
1195         break;
1196     case CursorType::Wait:
1197         m_value.valueID = CSSValueWait;
1198         break;
1199     case CursorType::Cell:
1200         m_value.valueID = CSSValueCell;
1201         break;
1202     case CursorType::Crosshair:
1203         m_value.valueID = CSSValueCrosshair;
1204         break;
1205     case CursorType::Text:
1206         m_value.valueID = CSSValueText;
1207         break;
1208     case CursorType::VerticalText:
1209         m_value.valueID = CSSValueVerticalText;
1210         break;
1211     case CursorType::Alias:
1212         m_value.valueID = CSSValueAlias;
1213         break;
1214     case CursorType::Copy:
1215         m_value.valueID = CSSValueCopy;
1216         break;
1217     case CursorType::Move:
1218         m_value.valueID = CSSValueMove;
1219         break;
1220     case CursorType::NoDrop:
1221         m_value.valueID = CSSValueNoDrop;
1222         break;
1223     case CursorType::NotAllowed:
1224         m_value.valueID = CSSValueNotAllowed;
1225         break;
1226     case CursorType::Grab:
1227         m_value.valueID = CSSValueGrab;
1228         break;
1229     case CursorType::Grabbing:
1230         m_value.valueID = CSSValueGrabbing;
1231         break;
1232     case CursorType::EResize:
1233         m_value.valueID = CSSValueEResize;
1234         break;
1235     case CursorType::NResize:
1236         m_value.valueID = CSSValueNResize;
1237         break;
1238     case CursorType::NEResize:
1239         m_value.valueID = CSSValueNeResize;
1240         break;
1241     case CursorType::NWResize:
1242         m_value.valueID = CSSValueNwResize;
1243         break;
1244     case CursorType::SResize:
1245         m_value.valueID = CSSValueSResize;
1246         break;
1247     case CursorType::SEResize:
1248         m_value.valueID = CSSValueSeResize;
1249         break;
1250     case CursorType::SWResize:
1251         m_value.valueID = CSSValueSwResize;
1252         break;
1253     case CursorType::WResize:
1254         m_value.valueID = CSSValueWResize;
1255         break;
1256     case CursorType::EWResize:
1257         m_value.valueID = CSSValueEwResize;
1258         break;
1259     case CursorType::NSResize:
1260         m_value.valueID = CSSValueNsResize;
1261         break;
1262     case CursorType::NESWResize:
1263         m_value.valueID = CSSValueNeswResize;
1264         break;
1265     case CursorType::NWSEResize:
1266         m_value.valueID = CSSValueNwseResize;
1267         break;
1268     case CursorType::ColumnResize:
1269         m_value.valueID = CSSValueColResize;
1270         break;
1271     case CursorType::RowResize:
1272         m_value.valueID = CSSValueRowResize;
1273         break;
1274     case CursorType::AllScroll:
1275         m_value.valueID = CSSValueAllScroll;
1276         break;
1277     case CursorType::ZoomIn:
1278         m_value.valueID = CSSValueZoomIn;
1279         break;
1280     case CursorType::ZoomOut:
1281         m_value.valueID = CSSValueZoomOut;
1282         break;
1283     }
1284 }
1285 
1286 template&lt;&gt; inline CSSPrimitiveValue::operator CursorType() const
1287 {
1288     ASSERT(isValueID());
1289     switch (m_value.valueID) {
1290     case CSSValueCopy:
1291         return CursorType::Copy;
1292     case CSSValueWebkitGrab:
1293         return CursorType::Grab;
1294     case CSSValueWebkitGrabbing:
1295         return CursorType::Grabbing;
1296     case CSSValueWebkitZoomIn:
1297         return CursorType::ZoomIn;
1298     case CSSValueWebkitZoomOut:
1299         return CursorType::ZoomOut;
1300     case CSSValueNone:
1301         return CursorType::None;
1302     default:
1303         return static_cast&lt;CursorType&gt;(m_value.valueID - CSSValueAuto);
1304     }
1305 }
1306 
1307 #if ENABLE(CURSOR_VISIBILITY)
1308 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorVisibility e)
1309     : CSSValue(PrimitiveClass)
1310 {
1311     m_primitiveUnitType = CSS_VALUE_ID;
1312     switch (e) {
1313     case CursorVisibility::Auto:
1314         m_value.valueID = CSSValueAuto;
1315         break;
1316     case CursorVisibility::AutoHide:
1317         m_value.valueID = CSSValueAutoHide;
1318         break;
1319     }
1320 }
1321 
1322 template&lt;&gt; inline CSSPrimitiveValue::operator CursorVisibility() const
1323 {
1324     ASSERT(isValueID());
1325 
1326     if (m_value.valueID == CSSValueAuto)
1327         return CursorVisibility::Auto;
1328     if (m_value.valueID == CSSValueAutoHide)
1329         return CursorVisibility::AutoHide;
1330 
1331     ASSERT_NOT_REACHED();
1332     return CursorVisibility::Auto;
1333 }
1334 #endif
1335 
1336 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DisplayType e)
1337     : CSSValue(PrimitiveClass)
1338 {
1339     m_primitiveUnitType = CSS_VALUE_ID;
1340     switch (e) {
1341     case DisplayType::Inline:
1342         m_value.valueID = CSSValueInline;
1343         break;
1344     case DisplayType::Block:
1345         m_value.valueID = CSSValueBlock;
1346         break;
1347     case DisplayType::ListItem:
1348         m_value.valueID = CSSValueListItem;
1349         break;
1350     case DisplayType::Compact:
1351         m_value.valueID = CSSValueCompact;
1352         break;
1353     case DisplayType::InlineBlock:
1354         m_value.valueID = CSSValueInlineBlock;
1355         break;
1356     case DisplayType::Table:
1357         m_value.valueID = CSSValueTable;
1358         break;
1359     case DisplayType::InlineTable:
1360         m_value.valueID = CSSValueInlineTable;
1361         break;
1362     case DisplayType::TableRowGroup:
1363         m_value.valueID = CSSValueTableRowGroup;
1364         break;
1365     case DisplayType::TableHeaderGroup:
1366         m_value.valueID = CSSValueTableHeaderGroup;
1367         break;
1368     case DisplayType::TableFooterGroup:
1369         m_value.valueID = CSSValueTableFooterGroup;
1370         break;
1371     case DisplayType::TableRow:
1372         m_value.valueID = CSSValueTableRow;
1373         break;
1374     case DisplayType::TableColumnGroup:
1375         m_value.valueID = CSSValueTableColumnGroup;
1376         break;
1377     case DisplayType::TableColumn:
1378         m_value.valueID = CSSValueTableColumn;
1379         break;
1380     case DisplayType::TableCell:
1381         m_value.valueID = CSSValueTableCell;
1382         break;
1383     case DisplayType::TableCaption:
1384         m_value.valueID = CSSValueTableCaption;
1385         break;
1386     case DisplayType::Box:
1387         m_value.valueID = CSSValueWebkitBox;
1388         break;
1389     case DisplayType::InlineBox:
1390         m_value.valueID = CSSValueWebkitInlineBox;
1391         break;
1392     case DisplayType::Flex:
1393     case DisplayType::WebKitFlex:
1394         m_value.valueID = CSSValueFlex;
1395         break;
1396     case DisplayType::InlineFlex:
1397     case DisplayType::WebKitInlineFlex:
1398         m_value.valueID = CSSValueInlineFlex;
1399         break;
1400     case DisplayType::Grid:
1401         m_value.valueID = CSSValueGrid;
1402         break;
1403     case DisplayType::InlineGrid:
1404         m_value.valueID = CSSValueInlineGrid;
1405         break;
1406     case DisplayType::None:
1407         m_value.valueID = CSSValueNone;
1408         break;
1409     case DisplayType::Contents:
1410         m_value.valueID = CSSValueContents;
1411         break;
1412     case DisplayType::FlowRoot:
1413         m_value.valueID = CSSValueFlowRoot;
1414         break;
1415     }
1416 }
1417 
1418 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1419 {
1420     ASSERT(isValueID());
1421 
1422     if (m_value.valueID == CSSValueNone)
1423         return DisplayType::None;
1424 
1425     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1426     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1427     if (display == DisplayType::WebKitFlex)
1428         return DisplayType::Flex;
1429     if (display == DisplayType::WebKitInlineFlex)
1430         return DisplayType::InlineFlex;
1431     return display;
1432 }
1433 
1434 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
1435     : CSSValue(PrimitiveClass)
1436 {
1437     m_primitiveUnitType = CSS_VALUE_ID;
1438     switch (e) {
1439     case EmptyCell::Show:
1440         m_value.valueID = CSSValueShow;
1441         break;
1442     case EmptyCell::Hide:
1443         m_value.valueID = CSSValueHide;
1444         break;
1445     }
1446 }
1447 
1448 template&lt;&gt; inline CSSPrimitiveValue::operator EmptyCell() const
1449 {
1450     ASSERT(isValueID());
1451 
1452     switch (m_value.valueID) {
1453     case CSSValueShow:
1454         return EmptyCell::Show;
1455     case CSSValueHide:
1456         return EmptyCell::Hide;
1457     default:
1458         break;
1459     }
1460 
1461     ASSERT_NOT_REACHED();
1462     return EmptyCell::Show;
1463 }
1464 
1465 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexDirection e)
1466     : CSSValue(PrimitiveClass)
1467 {
1468     m_primitiveUnitType = CSS_VALUE_ID;
1469     switch (e) {
1470     case FlexDirection::Row:
1471         m_value.valueID = CSSValueRow;
1472         break;
1473     case FlexDirection::RowReverse:
1474         m_value.valueID = CSSValueRowReverse;
1475         break;
1476     case FlexDirection::Column:
1477         m_value.valueID = CSSValueColumn;
1478         break;
1479     case FlexDirection::ColumnReverse:
1480         m_value.valueID = CSSValueColumnReverse;
1481         break;
1482     }
1483 }
1484 
1485 template&lt;&gt; inline CSSPrimitiveValue::operator FlexDirection() const
1486 {
1487     ASSERT(isValueID());
1488 
1489     switch (m_value.valueID) {
1490     case CSSValueRow:
1491         return FlexDirection::Row;
1492     case CSSValueRowReverse:
1493         return FlexDirection::RowReverse;
1494     case CSSValueColumn:
1495         return FlexDirection::Column;
1496     case CSSValueColumnReverse:
1497         return FlexDirection::ColumnReverse;
1498     default:
1499         break;
1500     }
1501 
1502     ASSERT_NOT_REACHED();
1503     return FlexDirection::Row;
1504 }
1505 
1506 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignContent e)
1507     : CSSValue(PrimitiveClass)
1508 {
1509     m_primitiveUnitType = CSS_VALUE_ID;
1510     switch (e) {
1511     case AlignContent::FlexStart:
1512         m_value.valueID = CSSValueFlexStart;
1513         break;
1514     case AlignContent::FlexEnd:
1515         m_value.valueID = CSSValueFlexEnd;
1516         break;
1517     case AlignContent::Center:
1518         m_value.valueID = CSSValueCenter;
1519         break;
1520     case AlignContent::SpaceBetween:
1521         m_value.valueID = CSSValueSpaceBetween;
1522         break;
1523     case AlignContent::SpaceAround:
1524         m_value.valueID = CSSValueSpaceAround;
1525         break;
1526     case AlignContent::Stretch:
1527         m_value.valueID = CSSValueStretch;
1528         break;
1529     }
1530 }
1531 
1532 template&lt;&gt; inline CSSPrimitiveValue::operator AlignContent() const
1533 {
1534     ASSERT(isValueID());
1535 
1536     switch (m_value.valueID) {
1537     case CSSValueFlexStart:
1538         return AlignContent::FlexStart;
1539     case CSSValueFlexEnd:
1540         return AlignContent::FlexEnd;
1541     case CSSValueCenter:
1542         return AlignContent::Center;
1543     case CSSValueSpaceBetween:
1544         return AlignContent::SpaceBetween;
1545     case CSSValueSpaceAround:
1546         return AlignContent::SpaceAround;
1547     case CSSValueStretch:
1548         return AlignContent::Stretch;
1549     default:
1550         break;
1551     }
1552 
1553     ASSERT_NOT_REACHED();
1554     return AlignContent::Stretch;
1555 }
1556 
1557 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexWrap e)
1558     : CSSValue(PrimitiveClass)
1559 {
1560     m_primitiveUnitType = CSS_VALUE_ID;
1561     switch (e) {
1562     case FlexWrap::NoWrap:
1563         m_value.valueID = CSSValueNowrap;
1564         break;
1565     case FlexWrap::Wrap:
1566         m_value.valueID = CSSValueWrap;
1567         break;
1568     case FlexWrap::Reverse:
1569         m_value.valueID = CSSValueWrapReverse;
1570         break;
1571     }
1572 }
1573 
1574 template&lt;&gt; inline CSSPrimitiveValue::operator FlexWrap() const
1575 {
1576     ASSERT(isValueID());
1577 
1578     switch (m_value.valueID) {
1579     case CSSValueNowrap:
1580         return FlexWrap::NoWrap;
1581     case CSSValueWrap:
1582         return FlexWrap::Wrap;
1583     case CSSValueWrapReverse:
1584         return FlexWrap::Reverse;
1585     default:
1586         break;
1587     }
1588 
1589     ASSERT_NOT_REACHED();
1590     return FlexWrap::NoWrap;
1591 }
1592 
1593 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Float e)
1594     : CSSValue(PrimitiveClass)
1595 {
1596     m_primitiveUnitType = CSS_VALUE_ID;
1597     switch (e) {
1598     case Float::No:
1599         m_value.valueID = CSSValueNone;
1600         break;
1601     case Float::Left:
1602         m_value.valueID = CSSValueLeft;
1603         break;
1604     case Float::Right:
1605         m_value.valueID = CSSValueRight;
1606         break;
1607     }
1608 }
1609 
1610 template&lt;&gt; inline CSSPrimitiveValue::operator Float() const
1611 {
1612     ASSERT(isValueID());
1613 
1614     switch (m_value.valueID) {
1615     case CSSValueLeft:
1616         return Float::Left;
1617     case CSSValueRight:
1618         return Float::Right;
1619     case CSSValueNone:
1620     case CSSValueCenter: // Non-standard CSS value.
1621         return Float::No;
1622     default:
1623         break;
1624     }
1625 
1626     ASSERT_NOT_REACHED();
1627     return Float::No;
1628 }
1629 
1630 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1631     : CSSValue(PrimitiveClass)
1632 {
1633     m_primitiveUnitType = CSS_VALUE_ID;
1634     switch (e) {
1635     case LineBreak::Auto:
1636         m_value.valueID = CSSValueAuto;
1637         break;
1638     case LineBreak::Loose:
1639         m_value.valueID = CSSValueLoose;
1640         break;
1641     case LineBreak::Normal:
1642         m_value.valueID = CSSValueNormal;
1643         break;
1644     case LineBreak::Strict:
1645         m_value.valueID = CSSValueStrict;
1646         break;
1647     case LineBreak::AfterWhiteSpace:
1648         m_value.valueID = CSSValueAfterWhiteSpace;
1649         break;
1650     case LineBreak::Anywhere:
1651         m_value.valueID = CSSValueAnywhere;
1652         break;
1653     }
1654 }
1655 
1656 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;HangingPunctuation&gt;() const
1657 {
1658     ASSERT(isValueID());
1659 
1660     switch (m_value.valueID) {
1661     case CSSValueNone:
1662         return OptionSet&lt;HangingPunctuation&gt; { };
1663     case CSSValueFirst:
1664         return HangingPunctuation::First;
1665     case CSSValueLast:
1666         return HangingPunctuation::Last;
1667     case CSSValueAllowEnd:
1668         return HangingPunctuation::AllowEnd;
1669     case CSSValueForceEnd:
1670         return HangingPunctuation::ForceEnd;
1671     default:
1672         break;
1673     }
1674 
1675     ASSERT_NOT_REACHED();
1676     return OptionSet&lt;HangingPunctuation&gt; { };
1677 }
1678 
1679 template&lt;&gt; inline CSSPrimitiveValue::operator LineBreak() const
1680 {
1681     ASSERT(isValueID());
1682 
1683     switch (m_value.valueID) {
1684     case CSSValueAuto:
1685         return LineBreak::Auto;
1686     case CSSValueLoose:
1687         return LineBreak::Loose;
1688     case CSSValueNormal:
1689         return LineBreak::Normal;
1690     case CSSValueStrict:
1691         return LineBreak::Strict;
1692     case CSSValueAfterWhiteSpace:
1693         return LineBreak::AfterWhiteSpace;
1694     case CSSValueAnywhere:
1695         return LineBreak::Anywhere;
1696     default:
1697         break;
1698     }
1699 
1700     ASSERT_NOT_REACHED();
1701     return LineBreak::Auto;
1702 }
1703 
1704 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1705     : CSSValue(PrimitiveClass)
1706 {
1707     m_primitiveUnitType = CSS_VALUE_ID;
1708     switch (e) {
1709     case ListStylePosition::Outside:
1710         m_value.valueID = CSSValueOutside;
1711         break;
1712     case ListStylePosition::Inside:
1713         m_value.valueID = CSSValueInside;
1714         break;
1715     }
1716 }
1717 
1718 template&lt;&gt; inline CSSPrimitiveValue::operator ListStylePosition() const
1719 {
1720     ASSERT(isValueID());
1721 
1722     switch (m_value.valueID) {
1723     case CSSValueOutside:
1724         return ListStylePosition::Outside;
1725     case CSSValueInside:
1726         return ListStylePosition::Inside;
1727     default:
1728         break;
1729     }
1730 
1731     ASSERT_NOT_REACHED();
1732     return ListStylePosition::Outside;
1733 }
1734 
1735 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStyleType e)
1736     : CSSValue(PrimitiveClass)
1737 {
1738     m_primitiveUnitType = CSS_VALUE_ID;
1739     switch (e) {
1740     case ListStyleType::Afar:
1741         m_value.valueID = CSSValueAfar;
1742         break;
1743     case ListStyleType::Amharic:
1744         m_value.valueID = CSSValueAmharic;
1745         break;
1746     case ListStyleType::AmharicAbegede:
1747         m_value.valueID = CSSValueAmharicAbegede;
1748         break;
1749     case ListStyleType::ArabicIndic:
1750         m_value.valueID = CSSValueArabicIndic;
1751         break;
1752     case ListStyleType::Armenian:
1753         m_value.valueID = CSSValueArmenian;
1754         break;
1755     case ListStyleType::Asterisks:
1756         m_value.valueID = CSSValueAsterisks;
1757         break;
1758     case ListStyleType::Binary:
1759         m_value.valueID = CSSValueBinary;
1760         break;
1761     case ListStyleType::Bengali:
1762         m_value.valueID = CSSValueBengali;
1763         break;
1764     case ListStyleType::Cambodian:
1765         m_value.valueID = CSSValueCambodian;
1766         break;
1767     case ListStyleType::Circle:
1768         m_value.valueID = CSSValueCircle;
1769         break;
1770     case ListStyleType::CjkEarthlyBranch:
1771         m_value.valueID = CSSValueCjkEarthlyBranch;
1772         break;
1773     case ListStyleType::CjkHeavenlyStem:
1774         m_value.valueID = CSSValueCjkHeavenlyStem;
1775         break;
1776     case ListStyleType::CJKIdeographic:
1777         m_value.valueID = CSSValueCjkIdeographic;
1778         break;
1779     case ListStyleType::DecimalLeadingZero:
1780         m_value.valueID = CSSValueDecimalLeadingZero;
1781         break;
1782     case ListStyleType::Decimal:
1783         m_value.valueID = CSSValueDecimal;
1784         break;
1785     case ListStyleType::Devanagari:
1786         m_value.valueID = CSSValueDevanagari;
1787         break;
1788     case ListStyleType::Disc:
1789         m_value.valueID = CSSValueDisc;
1790         break;
1791     case ListStyleType::Ethiopic:
1792         m_value.valueID = CSSValueEthiopic;
1793         break;
1794     case ListStyleType::EthiopicAbegede:
1795         m_value.valueID = CSSValueEthiopicAbegede;
1796         break;
1797     case ListStyleType::EthiopicAbegedeAmEt:
1798         m_value.valueID = CSSValueEthiopicAbegedeAmEt;
1799         break;
1800     case ListStyleType::EthiopicAbegedeGez:
1801         m_value.valueID = CSSValueEthiopicAbegedeGez;
1802         break;
1803     case ListStyleType::EthiopicAbegedeTiEr:
1804         m_value.valueID = CSSValueEthiopicAbegedeTiEr;
1805         break;
1806     case ListStyleType::EthiopicAbegedeTiEt:
1807         m_value.valueID = CSSValueEthiopicAbegedeTiEt;
1808         break;
1809     case ListStyleType::EthiopicHalehameAaEr:
1810         m_value.valueID = CSSValueEthiopicHalehameAaEr;
1811         break;
1812     case ListStyleType::EthiopicHalehameAaEt:
1813         m_value.valueID = CSSValueEthiopicHalehameAaEt;
1814         break;
1815     case ListStyleType::EthiopicHalehameAmEt:
1816         m_value.valueID = CSSValueEthiopicHalehameAmEt;
1817         break;
1818     case ListStyleType::EthiopicHalehameGez:
1819         m_value.valueID = CSSValueEthiopicHalehameGez;
1820         break;
1821     case ListStyleType::EthiopicHalehameOmEt:
1822         m_value.valueID = CSSValueEthiopicHalehameOmEt;
1823         break;
1824     case ListStyleType::EthiopicHalehameSidEt:
1825         m_value.valueID = CSSValueEthiopicHalehameSidEt;
1826         break;
1827     case ListStyleType::EthiopicHalehameSoEt:
1828         m_value.valueID = CSSValueEthiopicHalehameSoEt;
1829         break;
1830     case ListStyleType::EthiopicHalehameTiEr:
1831         m_value.valueID = CSSValueEthiopicHalehameTiEr;
1832         break;
1833     case ListStyleType::EthiopicHalehameTiEt:
1834         m_value.valueID = CSSValueEthiopicHalehameTiEt;
1835         break;
1836     case ListStyleType::EthiopicHalehameTig:
1837         m_value.valueID = CSSValueEthiopicHalehameTig;
1838         break;
1839     case ListStyleType::Footnotes:
1840         m_value.valueID = CSSValueFootnotes;
1841         break;
1842     case ListStyleType::Georgian:
1843         m_value.valueID = CSSValueGeorgian;
1844         break;
1845     case ListStyleType::Gujarati:
1846         m_value.valueID = CSSValueGujarati;
1847         break;
1848     case ListStyleType::Gurmukhi:
1849         m_value.valueID = CSSValueGurmukhi;
1850         break;
1851     case ListStyleType::Hangul:
1852         m_value.valueID = CSSValueHangul;
1853         break;
1854     case ListStyleType::HangulConsonant:
1855         m_value.valueID = CSSValueHangulConsonant;
1856         break;
1857     case ListStyleType::Hebrew:
1858         m_value.valueID = CSSValueHebrew;
1859         break;
1860     case ListStyleType::Hiragana:
1861         m_value.valueID = CSSValueHiragana;
1862         break;
1863     case ListStyleType::HiraganaIroha:
1864         m_value.valueID = CSSValueHiraganaIroha;
1865         break;
1866     case ListStyleType::Kannada:
1867         m_value.valueID = CSSValueKannada;
1868         break;
1869     case ListStyleType::Katakana:
1870         m_value.valueID = CSSValueKatakana;
1871         break;
1872     case ListStyleType::KatakanaIroha:
1873         m_value.valueID = CSSValueKatakanaIroha;
1874         break;
1875     case ListStyleType::Khmer:
1876         m_value.valueID = CSSValueKhmer;
1877         break;
1878     case ListStyleType::Lao:
1879         m_value.valueID = CSSValueLao;
1880         break;
1881     case ListStyleType::LowerAlpha:
1882         m_value.valueID = CSSValueLowerAlpha;
1883         break;
1884     case ListStyleType::LowerArmenian:
1885         m_value.valueID = CSSValueLowerArmenian;
1886         break;
1887     case ListStyleType::LowerGreek:
1888         m_value.valueID = CSSValueLowerGreek;
1889         break;
1890     case ListStyleType::LowerHexadecimal:
1891         m_value.valueID = CSSValueLowerHexadecimal;
1892         break;
1893     case ListStyleType::LowerLatin:
1894         m_value.valueID = CSSValueLowerLatin;
1895         break;
1896     case ListStyleType::LowerNorwegian:
1897         m_value.valueID = CSSValueLowerNorwegian;
1898         break;
1899     case ListStyleType::LowerRoman:
1900         m_value.valueID = CSSValueLowerRoman;
1901         break;
1902     case ListStyleType::Malayalam:
1903         m_value.valueID = CSSValueMalayalam;
1904         break;
1905     case ListStyleType::Mongolian:
1906         m_value.valueID = CSSValueMongolian;
1907         break;
1908     case ListStyleType::Myanmar:
1909         m_value.valueID = CSSValueMyanmar;
1910         break;
1911     case ListStyleType::None:
1912         m_value.valueID = CSSValueNone;
1913         break;
1914     case ListStyleType::Octal:
1915         m_value.valueID = CSSValueOctal;
1916         break;
1917     case ListStyleType::Oriya:
1918         m_value.valueID = CSSValueOriya;
1919         break;
1920     case ListStyleType::Oromo:
1921         m_value.valueID = CSSValueOromo;
1922         break;
1923     case ListStyleType::Persian:
1924         m_value.valueID = CSSValuePersian;
1925         break;
1926     case ListStyleType::Sidama:
1927         m_value.valueID = CSSValueSidama;
1928         break;
1929     case ListStyleType::Somali:
1930         m_value.valueID = CSSValueSomali;
1931         break;
1932     case ListStyleType::Square:
1933         m_value.valueID = CSSValueSquare;
1934         break;
1935     case ListStyleType::Telugu:
1936         m_value.valueID = CSSValueTelugu;
1937         break;
1938     case ListStyleType::Thai:
1939         m_value.valueID = CSSValueThai;
1940         break;
1941     case ListStyleType::Tibetan:
1942         m_value.valueID = CSSValueTibetan;
1943         break;
1944     case ListStyleType::Tigre:
1945         m_value.valueID = CSSValueTigre;
1946         break;
1947     case ListStyleType::TigrinyaEr:
1948         m_value.valueID = CSSValueTigrinyaEr;
1949         break;
1950     case ListStyleType::TigrinyaErAbegede:
1951         m_value.valueID = CSSValueTigrinyaErAbegede;
1952         break;
1953     case ListStyleType::TigrinyaEt:
1954         m_value.valueID = CSSValueTigrinyaEt;
1955         break;
1956     case ListStyleType::TigrinyaEtAbegede:
1957         m_value.valueID = CSSValueTigrinyaEtAbegede;
1958         break;
1959     case ListStyleType::UpperAlpha:
1960         m_value.valueID = CSSValueUpperAlpha;
1961         break;
1962     case ListStyleType::UpperArmenian:
1963         m_value.valueID = CSSValueUpperArmenian;
1964         break;
1965     case ListStyleType::UpperGreek:
1966         m_value.valueID = CSSValueUpperGreek;
1967         break;
1968     case ListStyleType::UpperHexadecimal:
1969         m_value.valueID = CSSValueUpperHexadecimal;
1970         break;
1971     case ListStyleType::UpperLatin:
1972         m_value.valueID = CSSValueUpperLatin;
1973         break;
1974     case ListStyleType::UpperNorwegian:
1975         m_value.valueID = CSSValueUpperNorwegian;
1976         break;
1977     case ListStyleType::UpperRoman:
1978         m_value.valueID = CSSValueUpperRoman;
1979         break;
1980     case ListStyleType::Urdu:
1981         m_value.valueID = CSSValueUrdu;
1982         break;
1983     }
1984 }
1985 
1986 template&lt;&gt; inline CSSPrimitiveValue::operator ListStyleType() const
1987 {
1988     ASSERT(isValueID());
1989 
1990     switch (m_value.valueID) {
1991     case CSSValueNone:
1992         return ListStyleType::None;
1993     default:
1994         return static_cast&lt;ListStyleType&gt;(m_value.valueID - CSSValueDisc);
1995     }
1996 }
1997 
1998 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarginCollapse e)
1999     : CSSValue(PrimitiveClass)
2000 {
2001     m_primitiveUnitType = CSS_VALUE_ID;
2002     switch (e) {
2003     case MarginCollapse::Collapse:
2004         m_value.valueID = CSSValueCollapse;
2005         break;
2006     case MarginCollapse::Separate:
2007         m_value.valueID = CSSValueSeparate;
2008         break;
2009     case MarginCollapse::Discard:
2010         m_value.valueID = CSSValueDiscard;
2011         break;
2012     }
2013 }
2014 
2015 template&lt;&gt; inline CSSPrimitiveValue::operator MarginCollapse() const
2016 {
2017     ASSERT(isValueID());
2018 
2019     switch (m_value.valueID) {
2020     case CSSValueCollapse:
2021         return MarginCollapse::Collapse;
2022     case CSSValueSeparate:
2023         return MarginCollapse::Separate;
2024     case CSSValueDiscard:
2025         return MarginCollapse::Discard;
2026     default:
2027         break;
2028     }
2029 
2030     ASSERT_NOT_REACHED();
2031     return MarginCollapse::Collapse;
2032 }
2033 
2034 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeBehavior e)
2035     : CSSValue(PrimitiveClass)
2036 {
2037     m_primitiveUnitType = CSS_VALUE_ID;
2038     switch (e) {
2039     case MarqueeBehavior::None:
2040         m_value.valueID = CSSValueNone;
2041         break;
2042     case MarqueeBehavior::Scroll:
2043         m_value.valueID = CSSValueScroll;
2044         break;
2045     case MarqueeBehavior::Slide:
2046         m_value.valueID = CSSValueSlide;
2047         break;
2048     case MarqueeBehavior::Alternate:
2049         m_value.valueID = CSSValueAlternate;
2050         break;
2051     }
2052 }
2053 
2054 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeBehavior() const
2055 {
2056     ASSERT(isValueID());
2057 
2058     switch (m_value.valueID) {
2059     case CSSValueNone:
2060         return MarqueeBehavior::None;
2061     case CSSValueScroll:
2062         return MarqueeBehavior::Scroll;
2063     case CSSValueSlide:
2064         return MarqueeBehavior::Slide;
2065     case CSSValueAlternate:
2066         return MarqueeBehavior::Alternate;
2067     default:
2068         break;
2069     }
2070 
2071     ASSERT_NOT_REACHED();
2072     return MarqueeBehavior::None;
2073 }
2074 
2075 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeDirection direction)
2076     : CSSValue(PrimitiveClass)
2077 {
2078     m_primitiveUnitType = CSS_VALUE_ID;
2079     switch (direction) {
2080     case MarqueeDirection::Forward:
2081         m_value.valueID = CSSValueForwards;
2082         break;
2083     case MarqueeDirection::Backward:
2084         m_value.valueID = CSSValueBackwards;
2085         break;
2086     case MarqueeDirection::Auto:
2087         m_value.valueID = CSSValueAuto;
2088         break;
2089     case MarqueeDirection::Up:
2090         m_value.valueID = CSSValueUp;
2091         break;
2092     case MarqueeDirection::Down:
2093         m_value.valueID = CSSValueDown;
2094         break;
2095     case MarqueeDirection::Left:
2096         m_value.valueID = CSSValueLeft;
2097         break;
2098     case MarqueeDirection::Right:
2099         m_value.valueID = CSSValueRight;
2100         break;
2101     }
2102 }
2103 
2104 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeDirection() const
2105 {
2106     ASSERT(isValueID());
2107 
2108     switch (m_value.valueID) {
2109     case CSSValueForwards:
2110         return MarqueeDirection::Forward;
2111     case CSSValueBackwards:
2112         return MarqueeDirection::Backward;
2113     case CSSValueAuto:
2114         return MarqueeDirection::Auto;
2115     case CSSValueAhead:
2116     case CSSValueUp: // We don&#39;t support vertical languages, so AHEAD just maps to UP.
2117         return MarqueeDirection::Up;
2118     case CSSValueReverse:
2119     case CSSValueDown: // REVERSE just maps to DOWN, since we don&#39;t do vertical text.
2120         return MarqueeDirection::Down;
2121     case CSSValueLeft:
2122         return MarqueeDirection::Left;
2123     case CSSValueRight:
2124         return MarqueeDirection::Right;
2125     default:
2126         break;
2127     }
2128 
2129     ASSERT_NOT_REACHED();
2130     return MarqueeDirection::Auto;
2131 }
2132 
2133 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(NBSPMode e)
2134     : CSSValue(PrimitiveClass)
2135 {
2136     m_primitiveUnitType = CSS_VALUE_ID;
2137     switch (e) {
2138     case NBSPMode::Normal:
2139         m_value.valueID = CSSValueNormal;
2140         break;
2141     case NBSPMode::Space:
2142         m_value.valueID = CSSValueSpace;
2143         break;
2144     }
2145 }
2146 
2147 template&lt;&gt; inline CSSPrimitiveValue::operator NBSPMode() const
2148 {
2149     ASSERT(isValueID());
2150 
2151     switch (m_value.valueID) {
2152     case CSSValueSpace:
2153         return NBSPMode::Space;
2154     case CSSValueNormal:
2155         return NBSPMode::Normal;
2156     default:
2157         break;
2158     }
2159 
2160     ASSERT_NOT_REACHED();
2161     return NBSPMode::Normal;
2162 }
2163 
2164 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Overflow e)
2165     : CSSValue(PrimitiveClass)
2166 {
2167     m_primitiveUnitType = CSS_VALUE_ID;
2168     switch (e) {
2169     case Overflow::Visible:
2170         m_value.valueID = CSSValueVisible;
2171         break;
2172     case Overflow::Hidden:
2173         m_value.valueID = CSSValueHidden;
2174         break;
2175     case Overflow::Scroll:
2176         m_value.valueID = CSSValueScroll;
2177         break;
2178     case Overflow::Auto:
2179         m_value.valueID = CSSValueAuto;
2180         break;
2181     case Overflow::PagedX:
2182         m_value.valueID = CSSValueWebkitPagedX;
2183         break;
2184     case Overflow::PagedY:
2185         m_value.valueID = CSSValueWebkitPagedY;
2186         break;
2187     }
2188 }
2189 
2190 template&lt;&gt; inline CSSPrimitiveValue::operator Overflow() const
2191 {
2192     ASSERT(isValueID());
2193 
2194     switch (m_value.valueID) {
2195     case CSSValueVisible:
2196         return Overflow::Visible;
2197     case CSSValueHidden:
2198         return Overflow::Hidden;
2199     case CSSValueScroll:
2200         return Overflow::Scroll;
2201     case CSSValueOverlay:
2202     case CSSValueAuto:
2203         return Overflow::Auto;
2204     case CSSValueWebkitPagedX:
2205         return Overflow::PagedX;
2206     case CSSValueWebkitPagedY:
2207         return Overflow::PagedY;
2208     default:
2209         break;
2210     }
2211 
2212     ASSERT_NOT_REACHED();
2213     return Overflow::Visible;
2214 }
2215 
2216 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakBetween e)
2217     : CSSValue(PrimitiveClass)
2218 {
2219     m_primitiveUnitType = CSS_VALUE_ID;
2220     switch (e) {
2221     case BreakBetween::Auto:
2222         m_value.valueID = CSSValueAuto;
2223         break;
2224     case BreakBetween::Avoid:
2225         m_value.valueID = CSSValueAvoid;
2226         break;
2227     case BreakBetween::AvoidColumn:
2228         m_value.valueID = CSSValueAvoidColumn;
2229         break;
2230     case BreakBetween::AvoidPage:
2231         m_value.valueID = CSSValueAvoidPage;
2232         break;
2233     case BreakBetween::Column:
2234         m_value.valueID = CSSValueColumn;
2235         break;
2236     case BreakBetween::Page:
2237         m_value.valueID = CSSValuePage;
2238         break;
2239     case BreakBetween::LeftPage:
2240         m_value.valueID = CSSValueLeft;
2241         break;
2242     case BreakBetween::RightPage:
2243         m_value.valueID = CSSValueRight;
2244         break;
2245     case BreakBetween::RectoPage:
2246         m_value.valueID = CSSValueRecto;
2247         break;
2248     case BreakBetween::VersoPage:
2249         m_value.valueID = CSSValueVerso;
2250         break;
2251     }
2252 }
2253 
2254 template&lt;&gt; inline CSSPrimitiveValue::operator BreakBetween() const
2255 {
2256     ASSERT(isValueID());
2257 
2258     switch (m_value.valueID) {
2259     case CSSValueAuto:
2260         return BreakBetween::Auto;
2261     case CSSValueAvoid:
2262         return BreakBetween::Avoid;
2263     case CSSValueAvoidColumn:
2264         return BreakBetween::AvoidColumn;
2265     case CSSValueAvoidPage:
2266         return BreakBetween::AvoidPage;
2267     case CSSValueColumn:
2268         return BreakBetween::Column;
2269     case CSSValuePage:
2270         return BreakBetween::Page;
2271     case CSSValueLeft:
2272         return BreakBetween::LeftPage;
2273     case CSSValueRight:
2274         return BreakBetween::RightPage;
2275     case CSSValueRecto:
2276         return BreakBetween::RectoPage;
2277     case CSSValueVerso:
2278         return BreakBetween::VersoPage;
2279     default:
2280         break;
2281     }
2282 
2283     ASSERT_NOT_REACHED();
2284     return BreakBetween::Auto;
2285 }
2286 
2287 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakInside e)
2288     : CSSValue(PrimitiveClass)
2289 {
2290     m_primitiveUnitType = CSS_VALUE_ID;
2291     switch (e) {
2292     case BreakInside::Auto:
2293         m_value.valueID = CSSValueAuto;
2294         break;
2295     case BreakInside::Avoid:
2296         m_value.valueID = CSSValueAvoid;
2297         break;
2298     case BreakInside::AvoidColumn:
2299         m_value.valueID = CSSValueAvoidColumn;
2300         break;
2301     case BreakInside::AvoidPage:
2302         m_value.valueID = CSSValueAvoidPage;
2303         break;
2304     }
2305 }
2306 
2307 template&lt;&gt; inline CSSPrimitiveValue::operator BreakInside() const
2308 {
2309     ASSERT(isValueID());
2310 
2311     switch (m_value.valueID) {
2312     case CSSValueAuto:
2313         return BreakInside::Auto;
2314     case CSSValueAvoid:
2315         return BreakInside::Avoid;
2316     case CSSValueAvoidColumn:
2317         return BreakInside::AvoidColumn;
2318     case CSSValueAvoidPage:
2319         return BreakInside::AvoidPage;
2320     default:
2321         break;
2322     }
2323 
2324     ASSERT_NOT_REACHED();
2325     return BreakInside::Auto;
2326 }
2327 
2328 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2329     : CSSValue(PrimitiveClass)
2330 {
2331     m_primitiveUnitType = CSS_VALUE_ID;
2332     switch (e) {
2333     case PositionType::Static:
2334         m_value.valueID = CSSValueStatic;
2335         break;
2336     case PositionType::Relative:
2337         m_value.valueID = CSSValueRelative;
2338         break;
2339     case PositionType::Absolute:
2340         m_value.valueID = CSSValueAbsolute;
2341         break;
2342     case PositionType::Fixed:
2343         m_value.valueID = CSSValueFixed;
2344         break;
2345     case PositionType::Sticky:
2346         m_value.valueID = CSSValueSticky;
2347         break;
2348     }
2349 }
2350 
2351 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
2352 {
2353     ASSERT(isValueID());
2354 
2355     switch (m_value.valueID) {
2356     case CSSValueStatic:
2357         return PositionType::Static;
2358     case CSSValueRelative:
2359         return PositionType::Relative;
2360     case CSSValueAbsolute:
2361         return PositionType::Absolute;
2362     case CSSValueFixed:
2363         return PositionType::Fixed;
2364     case CSSValueSticky:
2365     case CSSValueWebkitSticky:
2366         return PositionType::Sticky;
2367     default:
2368         break;
2369     }
2370 
2371     ASSERT_NOT_REACHED();
2372     return PositionType::Static;
2373 }
2374 
2375 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2376     : CSSValue(PrimitiveClass)
2377 {
2378     m_primitiveUnitType = CSS_VALUE_ID;
2379     switch (e) {
2380     case Resize::Both:
2381         m_value.valueID = CSSValueBoth;
2382         break;
2383     case Resize::Horizontal:
2384         m_value.valueID = CSSValueHorizontal;
2385         break;
2386     case Resize::Vertical:
2387         m_value.valueID = CSSValueVertical;
2388         break;
2389     case Resize::None:
2390         m_value.valueID = CSSValueNone;
2391         break;
2392     }
2393 }
2394 
2395 template&lt;&gt; inline CSSPrimitiveValue::operator Resize() const
2396 {
2397     ASSERT(isValueID());
2398 
2399     switch (m_value.valueID) {
2400     case CSSValueBoth:
2401         return Resize::Both;
2402     case CSSValueHorizontal:
2403         return Resize::Horizontal;
2404     case CSSValueVertical:
2405         return Resize::Vertical;
2406     case CSSValueAuto:
2407         ASSERT_NOT_REACHED(); // Depends on settings, thus should be handled by the caller.
2408         return Resize::None;
2409     case CSSValueNone:
2410         return Resize::None;
2411     default:
2412         break;
2413     }
2414 
2415     ASSERT_NOT_REACHED();
2416     return Resize::None;
2417 }
2418 
2419 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TableLayoutType e)
2420     : CSSValue(PrimitiveClass)
2421 {
2422     m_primitiveUnitType = CSS_VALUE_ID;
2423     switch (e) {
2424     case TableLayoutType::Auto:
2425         m_value.valueID = CSSValueAuto;
2426         break;
2427     case TableLayoutType::Fixed:
2428         m_value.valueID = CSSValueFixed;
2429         break;
2430     }
2431 }
2432 
2433 template&lt;&gt; inline CSSPrimitiveValue::operator TableLayoutType() const
2434 {
2435     ASSERT(isValueID());
2436 
2437     switch (m_value.valueID) {
2438     case CSSValueFixed:
2439         return TableLayoutType::Fixed;
2440     case CSSValueAuto:
2441         return TableLayoutType::Auto;
2442     default:
2443         break;
2444     }
2445 
2446     ASSERT_NOT_REACHED();
2447     return TableLayoutType::Auto;
2448 }
2449 
2450 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignMode e)
2451     : CSSValue(PrimitiveClass)
2452 {
2453     m_primitiveUnitType = CSS_VALUE_ID;
2454     switch (e) {
2455     case TextAlignMode::Start:
2456         m_value.valueID = CSSValueStart;
2457         break;
2458     case TextAlignMode::End:
2459         m_value.valueID = CSSValueEnd;
2460         break;
2461     case TextAlignMode::Left:
2462         m_value.valueID = CSSValueLeft;
2463         break;
2464     case TextAlignMode::Right:
2465         m_value.valueID = CSSValueRight;
2466         break;
2467     case TextAlignMode::Center:
2468         m_value.valueID = CSSValueCenter;
2469         break;
2470     case TextAlignMode::Justify:
2471         m_value.valueID = CSSValueJustify;
2472         break;
2473     case TextAlignMode::WebKitLeft:
2474         m_value.valueID = CSSValueWebkitLeft;
2475         break;
2476     case TextAlignMode::WebKitRight:
2477         m_value.valueID = CSSValueWebkitRight;
2478         break;
2479     case TextAlignMode::WebKitCenter:
2480         m_value.valueID = CSSValueWebkitCenter;
2481         break;
2482     }
2483 }
2484 
2485 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignMode() const
2486 {
2487     ASSERT(isValueID());
2488 
2489     switch (m_value.valueID) {
2490     case CSSValueWebkitAuto: // Legacy -webkit-auto. Eqiuvalent to start.
2491     case CSSValueStart:
2492         return TextAlignMode::Start;
2493     case CSSValueEnd:
2494         return TextAlignMode::End;
2495     default:
2496         return static_cast&lt;TextAlignMode&gt;(m_value.valueID - CSSValueLeft);
2497     }
2498 }
2499 
2500 #if ENABLE(CSS3_TEXT)
2501 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignLast e)
2502     : CSSValue(PrimitiveClass)
2503 {
2504     m_primitiveUnitType = CSS_VALUE_ID;
2505     switch (e) {
2506     case TextAlignLast::Start:
2507         m_value.valueID = CSSValueStart;
2508         break;
2509     case TextAlignLast::End:
2510         m_value.valueID = CSSValueEnd;
2511         break;
2512     case TextAlignLast::Left:
2513         m_value.valueID = CSSValueLeft;
2514         break;
2515     case TextAlignLast::Right:
2516         m_value.valueID = CSSValueRight;
2517         break;
2518     case TextAlignLast::Center:
2519         m_value.valueID = CSSValueCenter;
2520         break;
2521     case TextAlignLast::Justify:
2522         m_value.valueID = CSSValueJustify;
2523         break;
2524     case TextAlignLast::Auto:
2525         m_value.valueID = CSSValueAuto;
2526         break;
2527     }
2528 }
2529 
2530 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignLast() const
2531 {
2532     ASSERT(isValueID());
2533 
2534     switch (m_value.valueID) {
2535     case CSSValueAuto:
2536         return TextAlignLast::Auto;
2537     case CSSValueStart:
2538         return TextAlignLast::Start;
2539     case CSSValueEnd:
2540         return TextAlignLast::End;
2541     case CSSValueLeft:
2542         return TextAlignLast::Left;
2543     case CSSValueRight:
2544         return TextAlignLast::Right;
2545     case CSSValueCenter:
2546         return TextAlignLast::Center;
2547     case CSSValueJustify:
2548         return TextAlignLast::Justify;
2549     default:
2550         break;
2551     }
2552 
2553     ASSERT_NOT_REACHED();
2554     return TextAlignLast::Auto;
2555 }
2556 
2557 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextJustify e)
2558     : CSSValue(PrimitiveClass)
2559 {
2560     m_primitiveUnitType = CSS_VALUE_ID;
2561     switch (e) {
2562     case TextJustify::Auto:
2563         m_value.valueID = CSSValueAuto;
2564         break;
2565     case TextJustify::None:
2566         m_value.valueID = CSSValueNone;
2567         break;
2568     case TextJustify::InterWord:
2569         m_value.valueID = CSSValueInterWord;
2570         break;
2571     case TextJustify::Distribute:
2572         m_value.valueID = CSSValueDistribute;
2573         break;
2574     }
2575 }
2576 
2577 template&lt;&gt; inline CSSPrimitiveValue::operator TextJustify() const
2578 {
2579     ASSERT(isValueID());
2580 
2581     switch (m_value.valueID) {
2582     case CSSValueAuto:
2583         return TextJustify::Auto;
2584     case CSSValueNone:
2585         return TextJustify::None;
2586     case CSSValueInterWord:
2587         return TextJustify::InterWord;
2588     case CSSValueDistribute:
2589         return TextJustify::Distribute;
2590     default:
2591         break;
2592     }
2593 
2594     ASSERT_NOT_REACHED();
2595     return TextJustify::Auto;
2596 }
2597 #endif // CSS3_TEXT
2598 
2599 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;TextDecoration&gt;() const
2600 {
2601     ASSERT(isValueID());
2602 
2603     switch (m_value.valueID) {
2604     case CSSValueNone:
2605         return OptionSet&lt;TextDecoration&gt; { };
2606     case CSSValueUnderline:
2607         return TextDecoration::Underline;
2608     case CSSValueOverline:
2609         return TextDecoration::Overline;
2610     case CSSValueLineThrough:
2611         return TextDecoration::LineThrough;
2612     case CSSValueBlink:
2613         return TextDecoration::Blink;
2614 #if ENABLE(LETTERPRESS)
2615     case CSSValueWebkitLetterpress:
2616         return TextDecoration::Letterpress;
2617 #endif
2618     default:
2619         break;
2620     }
2621 
2622     ASSERT_NOT_REACHED();
2623     return OptionSet&lt;TextDecoration&gt; { };
2624 }
2625 
2626 template&lt;&gt; inline CSSPrimitiveValue::operator TextDecorationStyle() const
2627 {
2628     ASSERT(isValueID());
2629 
2630     switch (m_value.valueID) {
2631     case CSSValueSolid:
2632         return TextDecorationStyle::Solid;
2633     case CSSValueDouble:
2634         return TextDecorationStyle::Double;
2635     case CSSValueDotted:
2636         return TextDecorationStyle::Dotted;
2637     case CSSValueDashed:
2638         return TextDecorationStyle::Dashed;
2639     case CSSValueWavy:
2640         return TextDecorationStyle::Wavy;
2641     default:
2642         break;
2643     }
2644 
2645     ASSERT_NOT_REACHED();
2646     return TextDecorationStyle::Solid;
2647 }
2648 
2649 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextUnderlinePosition position)
2650     : CSSValue(PrimitiveClass)
2651 {
2652     m_primitiveUnitType = CSS_VALUE_ID;
2653     switch (position) {
2654     case TextUnderlinePosition::Auto:
2655         m_value.valueID = CSSValueAuto;
2656         break;
2657     case TextUnderlinePosition::Under:
2658         m_value.valueID = CSSValueUnder;
2659         break;
2660     case TextUnderlinePosition::FromFont:
2661         m_value.valueID = CSSValueFromFont;
2662         break;
2663     }
2664 
2665     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2666 }
2667 
2668 template&lt;&gt; inline CSSPrimitiveValue::operator TextUnderlinePosition() const
2669 {
2670     ASSERT(isValueID());
2671 
2672     switch (m_value.valueID) {
2673     case CSSValueAuto:
2674         return TextUnderlinePosition::Auto;
2675     case CSSValueUnder:
2676         return TextUnderlinePosition::Under;
2677     case CSSValueFromFont:
2678         return TextUnderlinePosition::FromFont;
2679     default:
2680         break;
2681     }
2682 
2683     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2684     ASSERT_NOT_REACHED();
2685     return TextUnderlinePosition::Auto;
2686 }
2687 
2688 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextSecurity e)
2689     : CSSValue(PrimitiveClass)
2690 {
2691     m_primitiveUnitType = CSS_VALUE_ID;
2692     switch (e) {
2693     case TextSecurity::None:
2694         m_value.valueID = CSSValueNone;
2695         break;
2696     case TextSecurity::Disc:
2697         m_value.valueID = CSSValueDisc;
2698         break;
2699     case TextSecurity::Circle:
2700         m_value.valueID = CSSValueCircle;
2701         break;
2702     case TextSecurity::Square:
2703         m_value.valueID = CSSValueSquare;
2704         break;
2705     }
2706 }
2707 
2708 template&lt;&gt; inline CSSPrimitiveValue::operator TextSecurity() const
2709 {
2710     ASSERT(isValueID());
2711 
2712     switch (m_value.valueID) {
2713     case CSSValueNone:
2714         return TextSecurity::None;
2715     case CSSValueDisc:
2716         return TextSecurity::Disc;
2717     case CSSValueCircle:
2718         return TextSecurity::Circle;
2719     case CSSValueSquare:
2720         return TextSecurity::Square;
2721     default:
2722         break;
2723     }
2724 
2725     ASSERT_NOT_REACHED();
2726     return TextSecurity::None;
2727 }
2728 
2729 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextTransform e)
2730     : CSSValue(PrimitiveClass)
2731 {
2732     m_primitiveUnitType = CSS_VALUE_ID;
2733     switch (e) {
2734     case TextTransform::Capitalize:
2735         m_value.valueID = CSSValueCapitalize;
2736         break;
2737     case TextTransform::Uppercase:
2738         m_value.valueID = CSSValueUppercase;
2739         break;
2740     case TextTransform::Lowercase:
2741         m_value.valueID = CSSValueLowercase;
2742         break;
2743     case TextTransform::None:
2744         m_value.valueID = CSSValueNone;
2745         break;
2746     }
2747 }
2748 
2749 template&lt;&gt; inline CSSPrimitiveValue::operator TextTransform() const
2750 {
2751     ASSERT(isValueID());
2752 
2753     switch (m_value.valueID) {
2754     case CSSValueCapitalize:
2755         return TextTransform::Capitalize;
2756     case CSSValueUppercase:
2757         return TextTransform::Uppercase;
2758     case CSSValueLowercase:
2759         return TextTransform::Lowercase;
2760     case CSSValueNone:
2761         return TextTransform::None;
2762     default:
2763         break;
2764     }
2765 
2766     ASSERT_NOT_REACHED();
2767     return TextTransform::None;
2768 }
2769 
2770 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EUnicodeBidi e)
2771     : CSSValue(PrimitiveClass)
2772 {
2773     m_primitiveUnitType = CSS_VALUE_ID;
2774     switch (e) {
2775     case UBNormal:
2776         m_value.valueID = CSSValueNormal;
2777         break;
2778     case Embed:
2779         m_value.valueID = CSSValueEmbed;
2780         break;
2781     case Override:
2782         m_value.valueID = CSSValueBidiOverride;
2783         break;
2784     case Isolate:
2785         m_value.valueID = CSSValueIsolate;
2786         break;
2787     case IsolateOverride:
2788         m_value.valueID = CSSValueIsolateOverride;
2789         break;
2790     case Plaintext:
2791         m_value.valueID = CSSValuePlaintext;
2792         break;
2793     }
2794 }
2795 
2796 template&lt;&gt; inline CSSPrimitiveValue::operator EUnicodeBidi() const
2797 {
2798     ASSERT(isValueID());
2799 
2800     switch (m_value.valueID) {
2801     case CSSValueNormal:
2802         return UBNormal;
2803     case CSSValueEmbed:
2804         return Embed;
2805     case CSSValueBidiOverride:
2806         return Override;
2807     case CSSValueIsolate:
2808     case CSSValueWebkitIsolate:
2809         return Isolate;
2810     case CSSValueIsolateOverride:
2811     case CSSValueWebkitIsolateOverride:
2812         return IsolateOverride;
2813     case CSSValuePlaintext:
2814     case CSSValueWebkitPlaintext:
2815         return Plaintext;
2816     default:
2817         break;
2818     }
2819 
2820     ASSERT_NOT_REACHED();
2821     return UBNormal;
2822 }
2823 
2824 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserDrag e)
2825     : CSSValue(PrimitiveClass)
2826 {
2827     m_primitiveUnitType = CSS_VALUE_ID;
2828     switch (e) {
2829     case UserDrag::Auto:
2830         m_value.valueID = CSSValueAuto;
2831         break;
2832     case UserDrag::None:
2833         m_value.valueID = CSSValueNone;
2834         break;
2835     case UserDrag::Element:
2836         m_value.valueID = CSSValueElement;
2837         break;
2838     default:
2839         break;
2840     }
2841 }
2842 
2843 template&lt;&gt; inline CSSPrimitiveValue::operator UserDrag() const
2844 {
2845     ASSERT(isValueID());
2846 
2847     switch (m_value.valueID) {
2848     case CSSValueAuto:
2849         return UserDrag::Auto;
2850     case CSSValueNone:
2851         return UserDrag::None;
2852     case CSSValueElement:
2853         return UserDrag::Element;
2854     default:
2855         break;
2856     }
2857 
2858     ASSERT_NOT_REACHED();
2859     return UserDrag::Auto;
2860 }
2861 
2862 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserModify e)
2863     : CSSValue(PrimitiveClass)
2864 {
2865     m_primitiveUnitType = CSS_VALUE_ID;
2866     switch (e) {
2867     case UserModify::ReadOnly:
2868         m_value.valueID = CSSValueReadOnly;
2869         break;
2870     case UserModify::ReadWrite:
2871         m_value.valueID = CSSValueReadWrite;
2872         break;
2873     case UserModify::ReadWritePlaintextOnly:
2874         m_value.valueID = CSSValueReadWritePlaintextOnly;
2875         break;
2876     }
2877 }
2878 
2879 template&lt;&gt; inline CSSPrimitiveValue::operator UserModify() const
2880 {
2881     ASSERT(isValueID());
2882 
2883     switch (m_value.valueID) {
2884     case CSSValueReadOnly:
2885         return UserModify::ReadOnly;
2886     case CSSValueReadWrite:
2887         return UserModify::ReadWrite;
2888     case CSSValueReadWritePlaintextOnly:
2889         return UserModify::ReadWritePlaintextOnly;
2890     default:
2891         break;
2892     }
2893 
2894     ASSERT_NOT_REACHED();
2895     return UserModify::ReadOnly;
2896 }
2897 
2898 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserSelect e)
2899     : CSSValue(PrimitiveClass)
2900 {
2901     m_primitiveUnitType = CSS_VALUE_ID;
2902     switch (e) {
2903     case UserSelect::None:
2904         m_value.valueID = CSSValueNone;
2905         break;
2906     case UserSelect::Text:
2907         m_value.valueID = CSSValueText;
2908         break;
2909     case UserSelect::All:
2910         m_value.valueID = CSSValueAll;
2911         break;
2912     }
2913 }
2914 
2915 template&lt;&gt; inline CSSPrimitiveValue::operator UserSelect() const
2916 {
2917     ASSERT(isValueID());
2918 
2919     switch (m_value.valueID) {
2920     case CSSValueAuto:
2921         return UserSelect::Text;
2922     case CSSValueNone:
2923         return UserSelect::None;
2924     case CSSValueText:
2925         return UserSelect::Text;
2926     case CSSValueAll:
2927         return UserSelect::All;
2928     default:
2929         break;
2930     }
2931 
2932     ASSERT_NOT_REACHED();
2933     return UserSelect::Text;
2934 }
2935 
2936 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VerticalAlign a)
2937     : CSSValue(PrimitiveClass)
2938 {
2939     m_primitiveUnitType = CSS_VALUE_ID;
2940     switch (a) {
2941     case VerticalAlign::Top:
2942         m_value.valueID = CSSValueTop;
2943         break;
2944     case VerticalAlign::Bottom:
2945         m_value.valueID = CSSValueBottom;
2946         break;
2947     case VerticalAlign::Middle:
2948         m_value.valueID = CSSValueMiddle;
2949         break;
2950     case VerticalAlign::Baseline:
2951         m_value.valueID = CSSValueBaseline;
2952         break;
2953     case VerticalAlign::TextBottom:
2954         m_value.valueID = CSSValueTextBottom;
2955         break;
2956     case VerticalAlign::TextTop:
2957         m_value.valueID = CSSValueTextTop;
2958         break;
2959     case VerticalAlign::Sub:
2960         m_value.valueID = CSSValueSub;
2961         break;
2962     case VerticalAlign::Super:
2963         m_value.valueID = CSSValueSuper;
2964         break;
2965     case VerticalAlign::BaselineMiddle:
2966         m_value.valueID = CSSValueWebkitBaselineMiddle;
2967         break;
2968     case VerticalAlign::Length:
2969         m_value.valueID = CSSValueInvalid;
2970     }
2971 }
2972 
2973 template&lt;&gt; inline CSSPrimitiveValue::operator VerticalAlign() const
2974 {
2975     ASSERT(isValueID());
2976 
2977     switch (m_value.valueID) {
2978     case CSSValueTop:
2979         return VerticalAlign::Top;
2980     case CSSValueBottom:
2981         return VerticalAlign::Bottom;
2982     case CSSValueMiddle:
2983         return VerticalAlign::Middle;
2984     case CSSValueBaseline:
2985         return VerticalAlign::Baseline;
2986     case CSSValueTextBottom:
2987         return VerticalAlign::TextBottom;
2988     case CSSValueTextTop:
2989         return VerticalAlign::TextTop;
2990     case CSSValueSub:
2991         return VerticalAlign::Sub;
2992     case CSSValueSuper:
2993         return VerticalAlign::Super;
2994     case CSSValueWebkitBaselineMiddle:
2995         return VerticalAlign::BaselineMiddle;
2996     default:
2997         break;
2998     }
2999 
3000     ASSERT_NOT_REACHED();
3001     return VerticalAlign::Top;
3002 }
3003 
3004 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Visibility e)
3005     : CSSValue(PrimitiveClass)
3006 {
3007     m_primitiveUnitType = CSS_VALUE_ID;
3008     switch (e) {
3009     case Visibility::Visible:
3010         m_value.valueID = CSSValueVisible;
3011         break;
3012     case Visibility::Hidden:
3013         m_value.valueID = CSSValueHidden;
3014         break;
3015     case Visibility::Collapse:
3016         m_value.valueID = CSSValueCollapse;
3017         break;
3018     }
3019 }
3020 
3021 template&lt;&gt; inline CSSPrimitiveValue::operator Visibility() const
3022 {
3023     ASSERT(isValueID());
3024 
3025     switch (m_value.valueID) {
3026     case CSSValueHidden:
3027         return Visibility::Hidden;
3028     case CSSValueVisible:
3029         return Visibility::Visible;
3030     case CSSValueCollapse:
3031         return Visibility::Collapse;
3032     default:
3033         break;
3034     }
3035 
3036     ASSERT_NOT_REACHED();
3037     return Visibility::Visible;
3038 }
3039 
3040 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WhiteSpace e)
3041     : CSSValue(PrimitiveClass)
3042 {
3043     m_primitiveUnitType = CSS_VALUE_ID;
3044     switch (e) {
3045     case WhiteSpace::Normal:
3046         m_value.valueID = CSSValueNormal;
3047         break;
3048     case WhiteSpace::Pre:
3049         m_value.valueID = CSSValuePre;
3050         break;
3051     case WhiteSpace::PreWrap:
3052         m_value.valueID = CSSValuePreWrap;
3053         break;
3054     case WhiteSpace::PreLine:
3055         m_value.valueID = CSSValuePreLine;
3056         break;
3057     case WhiteSpace::NoWrap:
3058         m_value.valueID = CSSValueNowrap;
3059         break;
3060     case WhiteSpace::KHTMLNoWrap:
3061         m_value.valueID = CSSValueWebkitNowrap;
3062         break;
3063     case WhiteSpace::BreakSpaces:
3064         m_value.valueID = CSSValueBreakSpaces;
3065         break;
3066     }
3067 }
3068 
3069 template&lt;&gt; inline CSSPrimitiveValue::operator WhiteSpace() const
3070 {
3071     ASSERT(isValueID());
3072 
3073     switch (m_value.valueID) {
3074     case CSSValueWebkitNowrap:
3075         return WhiteSpace::KHTMLNoWrap;
3076     case CSSValueNowrap:
3077         return WhiteSpace::NoWrap;
3078     case CSSValuePre:
3079         return WhiteSpace::Pre;
3080     case CSSValuePreWrap:
3081         return WhiteSpace::PreWrap;
3082     case CSSValuePreLine:
3083         return WhiteSpace::PreLine;
3084     case CSSValueNormal:
3085         return WhiteSpace::Normal;
3086     case CSSValueBreakSpaces:
3087         return WhiteSpace::BreakSpaces;
3088     default:
3089         break;
3090     }
3091 
3092     ASSERT_NOT_REACHED();
3093     return WhiteSpace::Normal;
3094 }
3095 
3096 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3097     : CSSValue(PrimitiveClass)
3098 {
3099     m_primitiveUnitType = CSS_VALUE_ID;
3100     switch (e) {
3101     case WordBreak::Normal:
3102         m_value.valueID = CSSValueNormal;
3103         break;
3104     case WordBreak::BreakAll:
3105         m_value.valueID = CSSValueBreakAll;
3106         break;
3107     case WordBreak::KeepAll:
3108         m_value.valueID = CSSValueKeepAll;
3109         break;
3110     case WordBreak::BreakWord:
3111         m_value.valueID = CSSValueBreakWord;
3112         break;
3113     }
3114 }
3115 
3116 template&lt;&gt; inline CSSPrimitiveValue::operator WordBreak() const
3117 {
3118     ASSERT(isValueID());
3119 
3120     switch (m_value.valueID) {
3121     case CSSValueBreakAll:
3122         return WordBreak::BreakAll;
3123     case CSSValueKeepAll:
3124         return WordBreak::KeepAll;
3125     case CSSValueBreakWord:
3126         return WordBreak::BreakWord;
3127     case CSSValueNormal:
3128         return WordBreak::Normal;
3129     default:
3130         break;
3131     }
3132 
3133     ASSERT_NOT_REACHED();
3134     return WordBreak::Normal;
3135 }
3136 
3137 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowWrap e)
3138     : CSSValue(PrimitiveClass)
3139 {
3140     m_primitiveUnitType = CSS_VALUE_ID;
3141     switch (e) {
3142     case OverflowWrap::Normal:
3143         m_value.valueID = CSSValueNormal;
3144         break;
3145     case OverflowWrap::Break:
3146         m_value.valueID = CSSValueBreakWord;
3147         break;
3148     }
3149 }
3150 
3151 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowWrap() const
3152 {
3153     ASSERT(isValueID());
3154 
3155     switch (m_value.valueID) {
3156     case CSSValueBreakWord:
3157         return OverflowWrap::Break;
3158     case CSSValueNormal:
3159         return OverflowWrap::Normal;
3160     default:
3161         break;
3162     }
3163 
3164     ASSERT_NOT_REACHED();
3165     return OverflowWrap::Normal;
3166 }
3167 
3168 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextDirection e)
3169     : CSSValue(PrimitiveClass)
3170 {
3171     m_primitiveUnitType = CSS_VALUE_ID;
3172     switch (e) {
3173     case TextDirection::LTR:
3174         m_value.valueID = CSSValueLtr;
3175         break;
3176     case TextDirection::RTL:
3177         m_value.valueID = CSSValueRtl;
3178         break;
3179     }
3180 }
3181 
3182 template&lt;&gt; inline CSSPrimitiveValue::operator TextDirection() const
3183 {
3184     ASSERT(isValueID());
3185 
3186     switch (m_value.valueID) {
3187     case CSSValueLtr:
3188         return TextDirection::LTR;
3189     case CSSValueRtl:
3190         return TextDirection::RTL;
3191     default:
3192         break;
3193     }
3194 
3195     ASSERT_NOT_REACHED();
3196     return TextDirection::LTR;
3197 }
3198 
3199 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WritingMode e)
3200     : CSSValue(PrimitiveClass)
3201 {
3202     m_primitiveUnitType = CSS_VALUE_ID;
3203     switch (e) {
3204     case TopToBottomWritingMode:
3205         m_value.valueID = CSSValueHorizontalTb;
3206         break;
3207     case RightToLeftWritingMode:
3208         m_value.valueID = CSSValueVerticalRl;
3209         break;
3210     case LeftToRightWritingMode:
3211         m_value.valueID = CSSValueVerticalLr;
3212         break;
3213     case BottomToTopWritingMode:
3214         m_value.valueID = CSSValueHorizontalBt;
3215         break;
3216     }
3217 }
3218 
3219 template&lt;&gt; inline CSSPrimitiveValue::operator WritingMode() const
3220 {
3221     ASSERT(isValueID());
3222 
3223     switch (m_value.valueID) {
3224     case CSSValueHorizontalTb:
3225     case CSSValueLr:
3226     case CSSValueLrTb:
3227     case CSSValueRl:
3228     case CSSValueRlTb:
3229         return TopToBottomWritingMode;
3230     case CSSValueVerticalRl:
3231     case CSSValueTb:
3232     case CSSValueTbRl:
3233         return RightToLeftWritingMode;
3234     case CSSValueVerticalLr:
3235         return LeftToRightWritingMode;
3236     case CSSValueHorizontalBt:
3237         return BottomToTopWritingMode;
3238     default:
3239         break;
3240     }
3241 
3242     ASSERT_NOT_REACHED();
3243     return TopToBottomWritingMode;
3244 }
3245 
3246 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextCombine e)
3247     : CSSValue(PrimitiveClass)
3248 {
3249     m_primitiveUnitType = CSS_VALUE_ID;
3250     switch (e) {
3251     case TextCombine::None:
3252         m_value.valueID = CSSValueNone;
3253         break;
3254     case TextCombine::Horizontal:
3255         m_value.valueID = CSSValueHorizontal;
3256         break;
3257     }
3258 }
3259 
3260 template&lt;&gt; inline CSSPrimitiveValue::operator TextCombine() const
3261 {
3262     ASSERT(isValueID());
3263 
3264     switch (m_value.valueID) {
3265     case CSSValueNone:
3266         return TextCombine::None;
3267     case CSSValueHorizontal:
3268         return TextCombine::Horizontal;
3269     default:
3270         break;
3271     }
3272 
3273     ASSERT_NOT_REACHED();
3274     return TextCombine::None;
3275 }
3276 
3277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(RubyPosition position)
3278     : CSSValue(PrimitiveClass)
3279 {
3280     m_primitiveUnitType = CSS_VALUE_ID;
3281     switch (position) {
3282     case RubyPosition::Before:
3283         m_value.valueID = CSSValueBefore;
3284         break;
3285     case RubyPosition::After:
3286         m_value.valueID = CSSValueAfter;
3287         break;
3288     case RubyPosition::InterCharacter:
3289         m_value.valueID = CSSValueInterCharacter;
3290         break;
3291     }
3292 }
3293 
3294 template&lt;&gt; inline CSSPrimitiveValue::operator RubyPosition() const
3295 {
3296     ASSERT(isValueID());
3297 
3298     switch (m_value.valueID) {
3299     case CSSValueBefore:
3300         return RubyPosition::Before;
3301     case CSSValueAfter:
3302         return RubyPosition::After;
3303     case CSSValueInterCharacter:
3304         return RubyPosition::InterCharacter;
3305     default:
3306         break;
3307     }
3308 
3309     ASSERT_NOT_REACHED();
3310     return RubyPosition::Before;
3311 }
3312 
3313 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOverflow overflow)
3314     : CSSValue(PrimitiveClass)
3315 {
3316     m_primitiveUnitType = CSS_VALUE_ID;
3317     switch (overflow) {
3318     case TextOverflow::Clip:
3319         m_value.valueID = CSSValueClip;
3320         break;
3321     case TextOverflow::Ellipsis:
3322         m_value.valueID = CSSValueEllipsis;
3323         break;
3324     }
3325 }
3326 
3327 template&lt;&gt; inline CSSPrimitiveValue::operator TextOverflow() const
3328 {
3329     ASSERT(isValueID());
3330 
3331     switch (m_value.valueID) {
3332     case CSSValueClip:
3333         return TextOverflow::Clip;
3334     case CSSValueEllipsis:
3335         return TextOverflow::Ellipsis;
3336     default:
3337         break;
3338     }
3339 
3340     ASSERT_NOT_REACHED();
3341     return TextOverflow::Clip;
3342 }
3343 
3344 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisFill fill)
3345     : CSSValue(PrimitiveClass)
3346 {
3347     m_primitiveUnitType = CSS_VALUE_ID;
3348     switch (fill) {
3349     case TextEmphasisFill::Filled:
3350         m_value.valueID = CSSValueFilled;
3351         break;
3352     case TextEmphasisFill::Open:
3353         m_value.valueID = CSSValueOpen;
3354         break;
3355     }
3356 }
3357 
3358 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisFill() const
3359 {
3360     ASSERT(isValueID());
3361 
3362     switch (m_value.valueID) {
3363     case CSSValueFilled:
3364         return TextEmphasisFill::Filled;
3365     case CSSValueOpen:
3366         return TextEmphasisFill::Open;
3367     default:
3368         break;
3369     }
3370 
3371     ASSERT_NOT_REACHED();
3372     return TextEmphasisFill::Filled;
3373 }
3374 
3375 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisMark mark)
3376     : CSSValue(PrimitiveClass)
3377 {
3378     m_primitiveUnitType = CSS_VALUE_ID;
3379     switch (mark) {
3380     case TextEmphasisMark::Dot:
3381         m_value.valueID = CSSValueDot;
3382         break;
3383     case TextEmphasisMark::Circle:
3384         m_value.valueID = CSSValueCircle;
3385         break;
3386     case TextEmphasisMark::DoubleCircle:
3387         m_value.valueID = CSSValueDoubleCircle;
3388         break;
3389     case TextEmphasisMark::Triangle:
3390         m_value.valueID = CSSValueTriangle;
3391         break;
3392     case TextEmphasisMark::Sesame:
3393         m_value.valueID = CSSValueSesame;
3394         break;
3395     case TextEmphasisMark::None:
3396     case TextEmphasisMark::Auto:
3397     case TextEmphasisMark::Custom:
3398         ASSERT_NOT_REACHED();
3399         m_value.valueID = CSSValueNone;
3400         break;
3401     }
3402 }
3403 
3404 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisMark() const
3405 {
3406     ASSERT(isValueID());
3407 
3408     switch (m_value.valueID) {
3409     case CSSValueNone:
3410         return TextEmphasisMark::None;
3411     case CSSValueDot:
3412         return TextEmphasisMark::Dot;
3413     case CSSValueCircle:
3414         return TextEmphasisMark::Circle;
3415     case CSSValueDoubleCircle:
3416         return TextEmphasisMark::DoubleCircle;
3417     case CSSValueTriangle:
3418         return TextEmphasisMark::Triangle;
3419     case CSSValueSesame:
3420         return TextEmphasisMark::Sesame;
3421     default:
3422         break;
3423     }
3424 
3425     ASSERT_NOT_REACHED();
3426     return TextEmphasisMark::None;
3427 }
3428 
3429 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOrientation e)
3430     : CSSValue(PrimitiveClass)
3431 {
3432     m_primitiveUnitType = CSS_VALUE_ID;
3433     switch (e) {
3434     case TextOrientation::Sideways:
3435         m_value.valueID = CSSValueSideways;
3436         break;
3437     case TextOrientation::Mixed:
3438         m_value.valueID = CSSValueMixed;
3439         break;
3440     case TextOrientation::Upright:
3441         m_value.valueID = CSSValueUpright;
3442         break;
3443     }
3444 }
3445 
3446 template&lt;&gt; inline CSSPrimitiveValue::operator TextOrientation() const
3447 {
3448     ASSERT(isValueID());
3449 
3450     switch (m_value.valueID) {
3451     case CSSValueSideways:
3452         return TextOrientation::Sideways;
3453     case CSSValueSidewaysRight:
3454         return TextOrientation::Sideways;
3455     case CSSValueVerticalRight:
3456         return TextOrientation::Mixed;
3457     case CSSValueMixed:
3458         return TextOrientation::Mixed;
3459     case CSSValueUpright:
3460         return TextOrientation::Upright;
3461     default:
3462         break;
3463     }
3464 
3465     ASSERT_NOT_REACHED();
3466     return TextOrientation::Mixed;
3467 }
3468 
3469 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PointerEvents e)
3470     : CSSValue(PrimitiveClass)
3471 {
3472     m_primitiveUnitType = CSS_VALUE_ID;
3473     switch (e) {
3474     case PointerEvents::None:
3475         m_value.valueID = CSSValueNone;
3476         break;
3477     case PointerEvents::Stroke:
3478         m_value.valueID = CSSValueStroke;
3479         break;
3480     case PointerEvents::Fill:
3481         m_value.valueID = CSSValueFill;
3482         break;
3483     case PointerEvents::Painted:
3484         m_value.valueID = CSSValuePainted;
3485         break;
3486     case PointerEvents::Visible:
3487         m_value.valueID = CSSValueVisible;
3488         break;
3489     case PointerEvents::VisibleStroke:
3490         m_value.valueID = CSSValueVisibleStroke;
3491         break;
3492     case PointerEvents::VisibleFill:
3493         m_value.valueID = CSSValueVisibleFill;
3494         break;
3495     case PointerEvents::VisiblePainted:
3496         m_value.valueID = CSSValueVisiblePainted;
3497         break;
3498     case PointerEvents::Auto:
3499         m_value.valueID = CSSValueAuto;
3500         break;
3501     case PointerEvents::All:
3502         m_value.valueID = CSSValueAll;
3503         break;
3504     }
3505 }
3506 
3507 template&lt;&gt; inline CSSPrimitiveValue::operator PointerEvents() const
3508 {
3509     ASSERT(isValueID());
3510 
3511     switch (m_value.valueID) {
3512     case CSSValueAll:
3513         return PointerEvents::All;
3514     case CSSValueAuto:
3515         return PointerEvents::Auto;
3516     case CSSValueNone:
3517         return PointerEvents::None;
3518     case CSSValueVisiblePainted:
3519         return PointerEvents::VisiblePainted;
3520     case CSSValueVisibleFill:
3521         return PointerEvents::VisibleFill;
3522     case CSSValueVisibleStroke:
3523         return PointerEvents::VisibleStroke;
3524     case CSSValueVisible:
3525         return PointerEvents::Visible;
3526     case CSSValuePainted:
3527         return PointerEvents::Painted;
3528     case CSSValueFill:
3529         return PointerEvents::Fill;
3530     case CSSValueStroke:
3531         return PointerEvents::Stroke;
3532     default:
3533         break;
3534     }
3535 
3536     ASSERT_NOT_REACHED();
3537     return PointerEvents::All;
3538 }
3539 
3540 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Kerning kerning)
3541     : CSSValue(PrimitiveClass)
3542 {
3543     m_primitiveUnitType = CSS_VALUE_ID;
3544     switch (kerning) {
3545     case Kerning::Auto:
3546         m_value.valueID = CSSValueAuto;
3547         return;
3548     case Kerning::Normal:
3549         m_value.valueID = CSSValueNormal;
3550         return;
3551     case Kerning::NoShift:
3552         m_value.valueID = CSSValueNone;
3553         return;
3554     }
3555 
3556     ASSERT_NOT_REACHED();
3557     m_value.valueID = CSSValueAuto;
3558 }
3559 
3560 template&lt;&gt; inline CSSPrimitiveValue::operator Kerning() const
3561 {
3562     ASSERT(isValueID());
3563 
3564     switch (m_value.valueID) {
3565     case CSSValueAuto:
3566         return Kerning::Auto;
3567     case CSSValueNormal:
3568         return Kerning::Normal;
3569     case CSSValueNone:
3570         return Kerning::NoShift;
3571     default:
3572         break;
3573     }
3574 
3575     ASSERT_NOT_REACHED();
3576     return Kerning::Auto;
3577 }
3578 
3579 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ObjectFit fit)
3580     : CSSValue(PrimitiveClass)
3581 {
3582     m_primitiveUnitType = CSS_VALUE_ID;
3583     switch (fit) {
3584     case ObjectFit::Fill:
3585         m_value.valueID = CSSValueFill;
3586         break;
3587     case ObjectFit::Contain:
3588         m_value.valueID = CSSValueContain;
3589         break;
3590     case ObjectFit::Cover:
3591         m_value.valueID = CSSValueCover;
3592         break;
3593     case ObjectFit::None:
3594         m_value.valueID = CSSValueNone;
3595         break;
3596     case ObjectFit::ScaleDown:
3597         m_value.valueID = CSSValueScaleDown;
3598         break;
3599     }
3600 }
3601 
3602 template&lt;&gt; inline CSSPrimitiveValue::operator ObjectFit() const
3603 {
3604     ASSERT(isValueID());
3605 
3606     switch (m_value.valueID) {
3607     case CSSValueFill:
3608         return ObjectFit::Fill;
3609     case CSSValueContain:
3610         return ObjectFit::Contain;
3611     case CSSValueCover:
3612         return ObjectFit::Cover;
3613     case CSSValueNone:
3614         return ObjectFit::None;
3615     case CSSValueScaleDown:
3616         return ObjectFit::ScaleDown;
3617     default:
3618         ASSERT_NOT_REACHED();
3619         return ObjectFit::Fill;
3620     }
3621 }
3622 
3623 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmoothingMode smoothing)
3624     : CSSValue(PrimitiveClass)
3625 {
3626     m_primitiveUnitType = CSS_VALUE_ID;
3627     switch (smoothing) {
3628     case FontSmoothingMode::AutoSmoothing:
3629         m_value.valueID = CSSValueAuto;
3630         return;
3631     case FontSmoothingMode::NoSmoothing:
3632         m_value.valueID = CSSValueNone;
3633         return;
3634     case FontSmoothingMode::Antialiased:
3635         m_value.valueID = CSSValueAntialiased;
3636         return;
3637     case FontSmoothingMode::SubpixelAntialiased:
3638         m_value.valueID = CSSValueSubpixelAntialiased;
3639         return;
3640     }
3641 
3642     ASSERT_NOT_REACHED();
3643     m_value.valueID = CSSValueAuto;
3644 }
3645 
3646 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmoothingMode() const
3647 {
3648     ASSERT(isValueID());
3649 
3650     switch (m_value.valueID) {
3651     case CSSValueAuto:
3652         return FontSmoothingMode::AutoSmoothing;
3653     case CSSValueNone:
3654         return FontSmoothingMode::NoSmoothing;
3655     case CSSValueAntialiased:
3656         return FontSmoothingMode::Antialiased;
3657     case CSSValueSubpixelAntialiased:
3658         return FontSmoothingMode::SubpixelAntialiased;
3659     default:
3660         break;
3661     }
3662 
3663     ASSERT_NOT_REACHED();
3664     return FontSmoothingMode::AutoSmoothing;
3665 }
3666 
3667 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmallCaps smallCaps)
3668     : CSSValue(PrimitiveClass)
3669 {
3670     m_primitiveUnitType = CSS_VALUE_ID;
3671     switch (smallCaps) {
3672     case FontSmallCaps::Off:
3673         m_value.valueID = CSSValueNormal;
3674         return;
3675     case FontSmallCaps::On:
3676         m_value.valueID = CSSValueSmallCaps;
3677         return;
3678     }
3679 
3680     ASSERT_NOT_REACHED();
3681     m_value.valueID = CSSValueNormal;
3682 }
3683 
3684 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmallCaps() const
3685 {
3686     ASSERT(isValueID());
3687 
3688     switch (m_value.valueID) {
3689     case CSSValueSmallCaps:
3690         return FontSmallCaps::On;
3691     case CSSValueNormal:
3692         return FontSmallCaps::Off;
3693     default:
3694         break;
3695     }
3696     ASSERT_NOT_REACHED();
3697     return FontSmallCaps::Off;
3698 }
3699 
3700 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextRenderingMode e)
3701     : CSSValue(PrimitiveClass)
3702 {
3703     m_primitiveUnitType = CSS_VALUE_ID;
3704     switch (e) {
3705     case TextRenderingMode::AutoTextRendering:
3706         m_value.valueID = CSSValueAuto;
3707         break;
3708     case TextRenderingMode::OptimizeSpeed:
3709         m_value.valueID = CSSValueOptimizeSpeed;
3710         break;
3711     case TextRenderingMode::OptimizeLegibility:
3712         m_value.valueID = CSSValueOptimizeLegibility;
3713         break;
3714     case TextRenderingMode::GeometricPrecision:
3715         m_value.valueID = CSSValueGeometricPrecision;
3716         break;
3717     }
3718 }
3719 
3720 template&lt;&gt; inline CSSPrimitiveValue::operator TextRenderingMode() const
3721 {
3722     ASSERT(isValueID());
3723 
3724     switch (m_value.valueID) {
3725     case CSSValueAuto:
3726         return TextRenderingMode::AutoTextRendering;
3727     case CSSValueOptimizeSpeed:
3728         return TextRenderingMode::OptimizeSpeed;
3729     case CSSValueOptimizeLegibility:
3730         return TextRenderingMode::OptimizeLegibility;
3731     case CSSValueGeometricPrecision:
3732         return TextRenderingMode::GeometricPrecision;
3733     default:
3734         break;
3735     }
3736 
3737     ASSERT_NOT_REACHED();
3738     return TextRenderingMode::AutoTextRendering;
3739 }
3740 
3741 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Hyphens hyphens)
3742     : CSSValue(PrimitiveClass)
3743 {
3744     m_primitiveUnitType = CSS_VALUE_ID;
3745     switch (hyphens) {
3746     case Hyphens::None:
3747         m_value.valueID = CSSValueNone;
3748         break;
3749     case Hyphens::Manual:
3750         m_value.valueID = CSSValueManual;
3751         break;
3752     case Hyphens::Auto:
3753         m_value.valueID = CSSValueAuto;
3754         break;
3755     }
3756 }
3757 
3758 template&lt;&gt; inline CSSPrimitiveValue::operator Hyphens() const
3759 {
3760     ASSERT(isValueID());
3761 
3762     switch (m_value.valueID) {
3763     case CSSValueNone:
3764         return Hyphens::None;
3765     case CSSValueManual:
3766         return Hyphens::Manual;
3767     case CSSValueAuto:
3768         return Hyphens::Auto;
3769     default:
3770         break;
3771     }
3772 
3773     ASSERT_NOT_REACHED();
3774     return Hyphens::Auto;
3775 }
3776 
3777 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineSnap gridSnap)
3778     : CSSValue(PrimitiveClass)
3779 {
3780     m_primitiveUnitType = CSS_VALUE_ID;
3781     switch (gridSnap) {
3782     case LineSnap::None:
3783         m_value.valueID = CSSValueNone;
3784         break;
3785     case LineSnap::Baseline:
3786         m_value.valueID = CSSValueBaseline;
3787         break;
3788     case LineSnap::Contain:
3789         m_value.valueID = CSSValueContain;
3790         break;
3791     }
3792 }
3793 
3794 template&lt;&gt; inline CSSPrimitiveValue::operator LineSnap() const
3795 {
3796     ASSERT(isValueID());
3797 
3798     switch (m_value.valueID) {
3799     case CSSValueNone:
3800         return LineSnap::None;
3801     case CSSValueBaseline:
3802         return LineSnap::Baseline;
3803     case CSSValueContain:
3804         return LineSnap::Contain;
3805     default:
3806         break;
3807     }
3808 
3809     ASSERT_NOT_REACHED();
3810     return LineSnap::None;
3811 }
3812 
3813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineAlign lineAlign)
3814     : CSSValue(PrimitiveClass)
3815 {
3816     m_primitiveUnitType = CSS_VALUE_ID;
3817     switch (lineAlign) {
3818     case LineAlign::None:
3819         m_value.valueID = CSSValueNone;
3820         break;
3821     case LineAlign::Edges:
3822         m_value.valueID = CSSValueEdges;
3823         break;
3824     }
3825 }
3826 
3827 template&lt;&gt; inline CSSPrimitiveValue::operator LineAlign() const
3828 {
3829     ASSERT(isValueID());
3830 
3831     switch (m_value.valueID) {
3832     case CSSValueNone:
3833         return LineAlign::None;
3834     case CSSValueEdges:
3835         return LineAlign::Edges;
3836     default:
3837         break;
3838     }
3839 
3840     ASSERT_NOT_REACHED();
3841     return LineAlign::None;
3842 }
3843 
3844 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(SpeakAs e)
3845     : CSSValue(PrimitiveClass)
3846 {
3847     m_primitiveUnitType = CSS_VALUE_ID;
3848     switch (e) {
3849     case SpeakAs::Normal:
3850         m_value.valueID = CSSValueNormal;
3851         break;
3852     case SpeakAs::SpellOut:
3853         m_value.valueID = CSSValueSpellOut;
3854         break;
3855     case SpeakAs::Digits:
3856         m_value.valueID = CSSValueDigits;
3857         break;
3858     case SpeakAs::LiteralPunctuation:
3859         m_value.valueID = CSSValueLiteralPunctuation;
3860         break;
3861     case SpeakAs::NoPunctuation:
3862         m_value.valueID = CSSValueNoPunctuation;
3863         break;
3864     }
3865 }
3866 
3867 template&lt;&gt; inline CSSPrimitiveValue::operator Order() const
3868 {
3869     ASSERT(isValueID());
3870 
3871     switch (m_value.valueID) {
3872     case CSSValueLogical:
3873         return Order::Logical;
3874     case CSSValueVisual:
3875         return Order::Visual;
3876     default:
3877         break;
3878     }
3879 
3880     ASSERT_NOT_REACHED();
3881     return Order::Logical;
3882 }
3883 
3884 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Order e)
3885     : CSSValue(PrimitiveClass)
3886 {
3887     m_primitiveUnitType = CSS_VALUE_ID;
3888     switch (e) {
3889     case Order::Logical:
3890         m_value.valueID = CSSValueLogical;
3891         break;
3892     case Order::Visual:
3893         m_value.valueID = CSSValueVisual;
3894         break;
3895     }
3896 }
3897 
3898 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;SpeakAs&gt;() const
3899 {
3900     ASSERT(isValueID());
3901 
3902     switch (m_value.valueID) {
3903     case CSSValueNormal:
3904         return OptionSet&lt;SpeakAs&gt; { };
3905     case CSSValueSpellOut:
3906         return SpeakAs::SpellOut;
3907     case CSSValueDigits:
3908         return SpeakAs::Digits;
3909     case CSSValueLiteralPunctuation:
3910         return SpeakAs::LiteralPunctuation;
3911     case CSSValueNoPunctuation:
3912         return SpeakAs::NoPunctuation;
3913     default:
3914         break;
3915     }
3916 
3917     ASSERT_NOT_REACHED();
3918     return OptionSet&lt;SpeakAs&gt; { };
3919 }
3920 
3921 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BlendMode blendMode)
3922     : CSSValue(PrimitiveClass)
3923 {
3924     m_primitiveUnitType = CSS_VALUE_ID;
3925     switch (blendMode) {
3926     case BlendMode::Normal:
3927         m_value.valueID = CSSValueNormal;
3928         break;
3929     case BlendMode::Multiply:
3930         m_value.valueID = CSSValueMultiply;
3931         break;
3932     case BlendMode::Screen:
3933         m_value.valueID = CSSValueScreen;
3934         break;
3935     case BlendMode::Overlay:
3936         m_value.valueID = CSSValueOverlay;
3937         break;
3938     case BlendMode::Darken:
3939         m_value.valueID = CSSValueDarken;
3940         break;
3941     case BlendMode::Lighten:
3942         m_value.valueID = CSSValueLighten;
3943         break;
3944     case BlendMode::ColorDodge:
3945         m_value.valueID = CSSValueColorDodge;
3946         break;
3947     case BlendMode::ColorBurn:
3948         m_value.valueID = CSSValueColorBurn;
3949         break;
3950     case BlendMode::HardLight:
3951         m_value.valueID = CSSValueHardLight;
3952         break;
3953     case BlendMode::SoftLight:
3954         m_value.valueID = CSSValueSoftLight;
3955         break;
3956     case BlendMode::Difference:
3957         m_value.valueID = CSSValueDifference;
3958         break;
3959     case BlendMode::Exclusion:
3960         m_value.valueID = CSSValueExclusion;
3961         break;
3962     case BlendMode::Hue:
3963         m_value.valueID = CSSValueHue;
3964         break;
3965     case BlendMode::Saturation:
3966         m_value.valueID = CSSValueSaturation;
3967         break;
3968     case BlendMode::Color:
3969         m_value.valueID = CSSValueColor;
3970         break;
3971     case BlendMode::Luminosity:
3972         m_value.valueID = CSSValueLuminosity;
3973         break;
3974     case BlendMode::PlusDarker:
3975         m_value.valueID = CSSValuePlusDarker;
3976         break;
3977     case BlendMode::PlusLighter:
3978         m_value.valueID = CSSValuePlusLighter;
3979         break;
3980     }
3981 }
3982 
3983 template&lt;&gt; inline CSSPrimitiveValue::operator BlendMode() const
3984 {
3985     ASSERT(isValueID());
3986 
3987     switch (m_value.valueID) {
3988     case CSSValueNormal:
3989         return BlendMode::Normal;
3990     case CSSValueMultiply:
3991         return BlendMode::Multiply;
3992     case CSSValueScreen:
3993         return BlendMode::Screen;
3994     case CSSValueOverlay:
3995         return BlendMode::Overlay;
3996     case CSSValueDarken:
3997         return BlendMode::Darken;
3998     case CSSValueLighten:
3999         return BlendMode::Lighten;
4000     case CSSValueColorDodge:
4001         return BlendMode::ColorDodge;
4002     case CSSValueColorBurn:
4003         return BlendMode::ColorBurn;
4004     case CSSValueHardLight:
4005         return BlendMode::HardLight;
4006     case CSSValueSoftLight:
4007         return BlendMode::SoftLight;
4008     case CSSValueDifference:
4009         return BlendMode::Difference;
4010     case CSSValueExclusion:
4011         return BlendMode::Exclusion;
4012     case CSSValueHue:
4013         return BlendMode::Hue;
4014     case CSSValueSaturation:
4015         return BlendMode::Saturation;
4016     case CSSValueColor:
4017         return BlendMode::Color;
4018     case CSSValueLuminosity:
4019         return BlendMode::Luminosity;
4020     case CSSValuePlusDarker:
4021         return BlendMode::PlusDarker;
4022     case CSSValuePlusLighter:
4023         return BlendMode::PlusLighter;
4024     default:
4025         break;
4026     }
4027 
4028     ASSERT_NOT_REACHED();
4029     return BlendMode::Normal;
4030 }
4031 
4032 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Isolation isolation)
4033     : CSSValue(PrimitiveClass)
4034 {
4035     m_primitiveUnitType = CSS_VALUE_ID;
4036     switch (isolation) {
4037     case Isolation::Auto:
4038         m_value.valueID = CSSValueAuto;
4039         break;
4040     case Isolation::Isolate:
4041         m_value.valueID = CSSValueIsolate;
4042         break;
4043     default:
4044         ASSERT_NOT_REACHED();
4045     }
4046 }
4047 
4048 template&lt;&gt; inline CSSPrimitiveValue::operator Isolation() const
4049 {
4050     ASSERT(isValueID());
4051     switch (m_value.valueID) {
4052     case CSSValueAuto:
4053         return Isolation::Auto;
4054     case CSSValueIsolate:
4055         return Isolation::Isolate;
4056     default:
4057         break;
4058     }
4059 
4060     ASSERT_NOT_REACHED();
4061     return Isolation::Auto;
4062 }
4063 
4064 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineCap e)
4065     : CSSValue(PrimitiveClass)
4066 {
4067     m_primitiveUnitType = CSS_VALUE_ID;
4068     switch (e) {
4069     case ButtCap:
4070         m_value.valueID = CSSValueButt;
4071         break;
4072     case RoundCap:
4073         m_value.valueID = CSSValueRound;
4074         break;
4075     case SquareCap:
4076         m_value.valueID = CSSValueSquare;
4077         break;
4078     }
4079 }
4080 
4081 template&lt;&gt; inline CSSPrimitiveValue::operator LineCap() const
4082 {
4083     ASSERT(isValueID());
4084 
4085     switch (m_value.valueID) {
4086     case CSSValueButt:
4087         return ButtCap;
4088     case CSSValueRound:
4089         return RoundCap;
4090     case CSSValueSquare:
4091         return SquareCap;
4092     default:
4093         break;
4094     }
4095 
4096     ASSERT_NOT_REACHED();
4097     return ButtCap;
4098 }
4099 
4100 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineJoin e)
4101     : CSSValue(PrimitiveClass)
4102 {
4103     m_primitiveUnitType = CSS_VALUE_ID;
4104     switch (e) {
4105     case MiterJoin:
4106         m_value.valueID = CSSValueMiter;
4107         break;
4108     case RoundJoin:
4109         m_value.valueID = CSSValueRound;
4110         break;
4111     case BevelJoin:
4112         m_value.valueID = CSSValueBevel;
4113         break;
4114     }
4115 }
4116 
4117 template&lt;&gt; inline CSSPrimitiveValue::operator LineJoin() const
4118 {
4119     ASSERT(isValueID());
4120 
4121     switch (m_value.valueID) {
4122     case CSSValueMiter:
4123         return MiterJoin;
4124     case CSSValueRound:
4125         return RoundJoin;
4126     case CSSValueBevel:
4127         return BevelJoin;
4128     default:
4129         break;
4130     }
4131 
4132     ASSERT_NOT_REACHED();
4133     return MiterJoin;
4134 }
4135 
4136 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WindRule e)
4137     : CSSValue(PrimitiveClass)
4138 {
4139     m_primitiveUnitType = CSS_VALUE_ID;
4140     switch (e) {
4141     case WindRule::NonZero:
4142         m_value.valueID = CSSValueNonzero;
4143         break;
4144     case WindRule::EvenOdd:
4145         m_value.valueID = CSSValueEvenodd;
4146         break;
4147     }
4148 }
4149 
4150 template&lt;&gt; inline CSSPrimitiveValue::operator WindRule() const
4151 {
4152     ASSERT(isValueID());
4153 
4154     switch (m_value.valueID) {
4155     case CSSValueNonzero:
4156         return WindRule::NonZero;
4157     case CSSValueEvenodd:
4158         return WindRule::EvenOdd;
4159     default:
4160         break;
4161     }
4162 
4163     ASSERT_NOT_REACHED();
4164     return WindRule::NonZero;
4165 }
4166 
4167 
4168 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignmentBaseline e)
4169     : CSSValue(PrimitiveClass)
4170 {
4171     m_primitiveUnitType = CSS_VALUE_ID;
4172     switch (e) {
4173     case AlignmentBaseline::Auto:
4174         m_value.valueID = CSSValueAuto;
4175         break;
4176     case AlignmentBaseline::Baseline:
4177         m_value.valueID = CSSValueBaseline;
4178         break;
4179     case AlignmentBaseline::BeforeEdge:
4180         m_value.valueID = CSSValueBeforeEdge;
4181         break;
4182     case AlignmentBaseline::TextBeforeEdge:
4183         m_value.valueID = CSSValueTextBeforeEdge;
4184         break;
4185     case AlignmentBaseline::Middle:
4186         m_value.valueID = CSSValueMiddle;
4187         break;
4188     case AlignmentBaseline::Central:
4189         m_value.valueID = CSSValueCentral;
4190         break;
4191     case AlignmentBaseline::AfterEdge:
4192         m_value.valueID = CSSValueAfterEdge;
4193         break;
4194     case AlignmentBaseline::TextAfterEdge:
4195         m_value.valueID = CSSValueTextAfterEdge;
4196         break;
4197     case AlignmentBaseline::Ideographic:
4198         m_value.valueID = CSSValueIdeographic;
4199         break;
4200     case AlignmentBaseline::Alphabetic:
4201         m_value.valueID = CSSValueAlphabetic;
4202         break;
4203     case AlignmentBaseline::Hanging:
4204         m_value.valueID = CSSValueHanging;
4205         break;
4206     case AlignmentBaseline::Mathematical:
4207         m_value.valueID = CSSValueMathematical;
4208         break;
4209     }
4210 }
4211 
4212 template&lt;&gt; inline CSSPrimitiveValue::operator AlignmentBaseline() const
4213 {
4214     ASSERT(isValueID());
4215 
4216     switch (m_value.valueID) {
4217     case CSSValueAuto:
4218         return AlignmentBaseline::Auto;
4219     case CSSValueBaseline:
4220         return AlignmentBaseline::Baseline;
4221     case CSSValueBeforeEdge:
4222         return AlignmentBaseline::BeforeEdge;
4223     case CSSValueTextBeforeEdge:
4224         return AlignmentBaseline::TextBeforeEdge;
4225     case CSSValueMiddle:
4226         return AlignmentBaseline::Middle;
4227     case CSSValueCentral:
4228         return AlignmentBaseline::Central;
4229     case CSSValueAfterEdge:
4230         return AlignmentBaseline::AfterEdge;
4231     case CSSValueTextAfterEdge:
4232         return AlignmentBaseline::TextAfterEdge;
4233     case CSSValueIdeographic:
4234         return AlignmentBaseline::Ideographic;
4235     case CSSValueAlphabetic:
4236         return AlignmentBaseline::Alphabetic;
4237     case CSSValueHanging:
4238         return AlignmentBaseline::Hanging;
4239     case CSSValueMathematical:
4240         return AlignmentBaseline::Mathematical;
4241     default:
4242         break;
4243     }
4244 
4245     ASSERT_NOT_REACHED();
4246     return AlignmentBaseline::Auto;
4247 }
4248 
4249 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderCollapse e)
4250     : CSSValue(PrimitiveClass)
4251 {
4252     m_primitiveUnitType = CSS_VALUE_ID;
4253     switch (e) {
4254     case BorderCollapse::Separate:
4255         m_value.valueID = CSSValueSeparate;
4256         break;
4257     case BorderCollapse::Collapse:
4258         m_value.valueID = CSSValueCollapse;
4259         break;
4260     }
4261 }
4262 
4263 template&lt;&gt; inline CSSPrimitiveValue::operator BorderCollapse() const
4264 {
4265     ASSERT(isValueID());
4266 
4267     switch (m_value.valueID) {
4268     case CSSValueSeparate:
4269         return BorderCollapse::Separate;
4270     case CSSValueCollapse:
4271         return BorderCollapse::Collapse;
4272     default:
4273         break;
4274     }
4275 
4276     ASSERT_NOT_REACHED();
4277     return BorderCollapse::Separate;
4278 }
4279 
4280 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderFit e)
4281     : CSSValue(PrimitiveClass)
4282 {
4283     m_primitiveUnitType = CSS_VALUE_ID;
4284     switch (e) {
4285     case BorderFit::Border:
4286         m_value.valueID = CSSValueBorder;
4287         break;
4288     case BorderFit::Lines:
4289         m_value.valueID = CSSValueLines;
4290         break;
4291     }
4292 }
4293 
4294 template&lt;&gt; inline CSSPrimitiveValue::operator BorderFit() const
4295 {
4296     ASSERT(isValueID());
4297 
4298     switch (m_value.valueID) {
4299     case CSSValueBorder:
4300         return BorderFit::Border;
4301     case CSSValueLines:
4302         return BorderFit::Lines;
4303     default:
4304         break;
4305     }
4306 
4307     ASSERT_NOT_REACHED();
4308     return BorderFit::Lines;
4309 }
4310 
4311 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageRendering imageRendering)
4312     : CSSValue(PrimitiveClass)
4313 {
4314     m_primitiveUnitType = CSS_VALUE_ID;
4315     switch (imageRendering) {
4316     case ImageRendering::Auto:
4317         m_value.valueID = CSSValueAuto;
4318         break;
4319     case ImageRendering::CrispEdges:
4320         m_value.valueID = CSSValueCrispEdges;
4321         break;
4322     case ImageRendering::Pixelated:
4323         m_value.valueID = CSSValuePixelated;
4324         break;
4325     case ImageRendering::OptimizeSpeed:
4326         m_value.valueID = CSSValueOptimizeSpeed;
4327         break;
4328     case ImageRendering::OptimizeQuality:
4329         m_value.valueID = CSSValueOptimizeQuality;
4330         break;
4331     }
4332 }
4333 
4334 template&lt;&gt; inline CSSPrimitiveValue::operator ImageRendering() const
4335 {
4336     ASSERT(isValueID());
4337 
4338     switch (m_value.valueID) {
4339     case CSSValueAuto:
4340         return ImageRendering::Auto;
4341     case CSSValueWebkitOptimizeContrast:
4342     case CSSValueCrispEdges:
4343     case CSSValueWebkitCrispEdges:
4344         return ImageRendering::CrispEdges;
4345     case CSSValuePixelated:
4346         return ImageRendering::Pixelated;
4347     case CSSValueOptimizeSpeed:
4348         return ImageRendering::OptimizeSpeed;
4349     case CSSValueOptimizeQuality:
4350         return ImageRendering::OptimizeQuality;
4351     default:
4352         break;
4353     }
4354 
4355     ASSERT_NOT_REACHED();
4356     return ImageRendering::Auto;
4357 }
4358 
4359 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformStyle3D e)
4360     : CSSValue(PrimitiveClass)
4361 {
4362     m_primitiveUnitType = CSS_VALUE_ID;
4363     switch (e) {
4364     case TransformStyle3D::Flat:
4365         m_value.valueID = CSSValueFlat;
4366         break;
4367     case TransformStyle3D::Preserve3D:
4368         m_value.valueID = CSSValuePreserve3d;
4369         break;
4370     }
4371 }
4372 
4373 template&lt;&gt; inline CSSPrimitiveValue::operator TransformStyle3D() const
4374 {
4375     ASSERT(isValueID());
4376 
4377     switch (m_value.valueID) {
4378     case CSSValueFlat:
4379         return TransformStyle3D::Flat;
4380     case CSSValuePreserve3d:
4381         return TransformStyle3D::Preserve3D;
4382     default:
4383         break;
4384     }
4385 
4386     ASSERT_NOT_REACHED();
4387     return TransformStyle3D::Flat;
4388 }
4389 
4390 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformBox box)
4391     : CSSValue(PrimitiveClass)
4392 {
4393     m_primitiveUnitType = CSS_VALUE_ID;
4394     switch (box) {
4395     case TransformBox::BorderBox:
4396         m_value.valueID = CSSValueBorderBox;
4397         break;
4398     case TransformBox::FillBox:
4399         m_value.valueID = CSSValueFillBox;
4400         break;
4401     case TransformBox::ViewBox:
4402         m_value.valueID = CSSValueViewBox;
4403         break;
4404     }
4405 }
4406 
4407 template&lt;&gt; inline CSSPrimitiveValue::operator TransformBox() const
4408 {
4409     ASSERT(isValueID());
4410 
4411     switch (m_value.valueID) {
4412     case CSSValueBorderBox:
4413         return TransformBox::BorderBox;
4414     case CSSValueFillBox:
4415         return TransformBox::FillBox;
4416     case CSSValueViewBox:
4417         return TransformBox::ViewBox;
4418     default:
4419         break;
4420     }
4421 
4422     ASSERT_NOT_REACHED();
4423     return TransformBox::BorderBox;
4424 }
4425 
4426 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnAxis e)
4427     : CSSValue(PrimitiveClass)
4428 {
4429     m_primitiveUnitType = CSS_VALUE_ID;
4430     switch (e) {
4431     case ColumnAxis::Horizontal:
4432         m_value.valueID = CSSValueHorizontal;
4433         break;
4434     case ColumnAxis::Vertical:
4435         m_value.valueID = CSSValueVertical;
4436         break;
4437     case ColumnAxis::Auto:
4438         m_value.valueID = CSSValueAuto;
4439         break;
4440     }
4441 }
4442 
4443 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnAxis() const
4444 {
4445     ASSERT(isValueID());
4446 
4447     switch (m_value.valueID) {
4448     case CSSValueHorizontal:
4449         return ColumnAxis::Horizontal;
4450     case CSSValueVertical:
4451         return ColumnAxis::Vertical;
4452     case CSSValueAuto:
4453         return ColumnAxis::Auto;
4454     default:
4455         break;
4456     }
4457 
4458     ASSERT_NOT_REACHED();
4459     return ColumnAxis::Auto;
4460 }
4461 
4462 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnProgression e)
4463     : CSSValue(PrimitiveClass)
4464 {
4465     m_primitiveUnitType = CSS_VALUE_ID;
4466     switch (e) {
4467     case ColumnProgression::Normal:
4468         m_value.valueID = CSSValueNormal;
4469         break;
4470     case ColumnProgression::Reverse:
4471         m_value.valueID = CSSValueReverse;
4472         break;
4473     }
4474 }
4475 
4476 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnProgression() const
4477 {
4478     ASSERT(isValueID());
4479 
4480     switch (m_value.valueID) {
4481     case CSSValueNormal:
4482         return ColumnProgression::Normal;
4483     case CSSValueReverse:
4484         return ColumnProgression::Reverse;
4485     default:
4486         break;
4487     }
4488 
4489     ASSERT_NOT_REACHED();
4490     return ColumnProgression::Normal;
4491 }
4492 
4493 enum LengthConversion {
4494     AnyConversion = ~0,
4495     FixedIntegerConversion = 1 &lt;&lt; 0,
4496     FixedFloatConversion = 1 &lt;&lt; 1,
4497     AutoConversion = 1 &lt;&lt; 2,
4498     PercentConversion = 1 &lt;&lt; 3,
4499     CalculatedConversion = 1 &lt;&lt; 4
4500 };
4501 
4502 inline bool CSSPrimitiveValue::convertingToLengthRequiresNonNullStyle(int lengthConversion) const
4503 {
4504     ASSERT(isFontRelativeLength());
4505     // This matches the implementation in CSSPrimitiveValue::computeLengthDouble().
4506     switch (m_primitiveUnitType) {
4507     case CSS_EMS:
4508     case CSS_EXS:
4509     case CSS_CHS:
4510         return lengthConversion &amp; (FixedIntegerConversion | FixedFloatConversion);
4511     default:
4512         return false;
4513     }
4514 }
4515 
4516 template&lt;int supported&gt; Length CSSPrimitiveValue::convertToLength(const CSSToLengthConversionData&amp; conversionData) const
4517 {
4518     if (isFontRelativeLength() &amp;&amp; convertingToLengthRequiresNonNullStyle(supported) &amp;&amp; !conversionData.style())
4519         return Length(Undefined);
4520     if ((supported &amp; FixedIntegerConversion) &amp;&amp; isLength())
4521         return computeLength&lt;Length&gt;(conversionData);
4522     if ((supported &amp; FixedFloatConversion) &amp;&amp; isLength())
4523         return Length(computeLength&lt;double&gt;(conversionData), Fixed);
4524     if ((supported &amp; PercentConversion) &amp;&amp; isPercentage())
4525         return Length(doubleValue(), Percent);
4526     if ((supported &amp; AutoConversion) &amp;&amp; valueID() == CSSValueAuto)
4527         return Length(Auto);
4528     if ((supported &amp; CalculatedConversion) &amp;&amp; isCalculated())
4529         return Length(cssCalcValue()-&gt;createCalculationValue(conversionData));
4530     return Length(Undefined);
4531 }
4532 
4533 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BufferedRendering e)
4534     : CSSValue(PrimitiveClass)
4535 {
4536     m_primitiveUnitType = CSS_VALUE_ID;
4537     switch (e) {
4538     case BufferedRendering::Auto:
4539         m_value.valueID = CSSValueAuto;
4540         break;
4541     case BufferedRendering::Dynamic:
4542         m_value.valueID = CSSValueDynamic;
4543         break;
4544     case BufferedRendering::Static:
4545         m_value.valueID = CSSValueStatic;
4546         break;
4547     }
4548 }
4549 
4550 template&lt;&gt; inline CSSPrimitiveValue::operator BufferedRendering() const
4551 {
4552     ASSERT(isValueID());
4553 
4554     switch (m_value.valueID) {
4555     case CSSValueAuto:
4556         return BufferedRendering::Auto;
4557     case CSSValueDynamic:
4558         return BufferedRendering::Dynamic;
4559     case CSSValueStatic:
4560         return BufferedRendering::Static;
4561     default:
4562         break;
4563     }
4564 
4565     ASSERT_NOT_REACHED();
4566     return BufferedRendering::Auto;
4567 }
4568 
4569 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorInterpolation e)
4570     : CSSValue(PrimitiveClass)
4571 {
4572     m_primitiveUnitType = CSS_VALUE_ID;
4573     switch (e) {
4574     case ColorInterpolation::Auto:
4575         m_value.valueID = CSSValueAuto;
4576         break;
4577     case ColorInterpolation::SRGB:
4578         m_value.valueID = CSSValueSRGB;
4579         break;
4580     case ColorInterpolation::LinearRGB:
4581         m_value.valueID = CSSValueLinearRGB;
4582         break;
4583     }
4584 }
4585 
4586 template&lt;&gt; inline CSSPrimitiveValue::operator ColorInterpolation() const
4587 {
4588     ASSERT(isValueID());
4589 
4590     switch (m_value.valueID) {
4591     case CSSValueSRGB:
4592         return ColorInterpolation::SRGB;
4593     case CSSValueLinearRGB:
4594         return ColorInterpolation::LinearRGB;
4595     case CSSValueAuto:
4596         return ColorInterpolation::Auto;
4597     default:
4598         break;
4599     }
4600 
4601     ASSERT_NOT_REACHED();
4602     return ColorInterpolation::Auto;
4603 }
4604 
4605 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorRendering e)
4606     : CSSValue(PrimitiveClass)
4607 {
4608     m_primitiveUnitType = CSS_VALUE_ID;
4609     switch (e) {
4610     case ColorRendering::Auto:
4611         m_value.valueID = CSSValueAuto;
4612         break;
4613     case ColorRendering::OptimizeSpeed:
4614         m_value.valueID = CSSValueOptimizeSpeed;
4615         break;
4616     case ColorRendering::OptimizeQuality:
4617         m_value.valueID = CSSValueOptimizeQuality;
4618         break;
4619     }
4620 }
4621 
4622 template&lt;&gt; inline CSSPrimitiveValue::operator ColorRendering() const
4623 {
4624     ASSERT(isValueID());
4625 
4626     switch (m_value.valueID) {
4627     case CSSValueOptimizeSpeed:
4628         return ColorRendering::OptimizeSpeed;
4629     case CSSValueOptimizeQuality:
4630         return ColorRendering::OptimizeQuality;
4631     case CSSValueAuto:
4632         return ColorRendering::Auto;
4633     default:
4634         break;
4635     }
4636 
4637     ASSERT_NOT_REACHED();
4638     return ColorRendering::Auto;
4639 }
4640 
4641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DominantBaseline e)
4642     : CSSValue(PrimitiveClass)
4643 {
4644     m_primitiveUnitType = CSS_VALUE_ID;
4645     switch (e) {
4646     case DominantBaseline::Auto:
4647         m_value.valueID = CSSValueAuto;
4648         break;
4649     case DominantBaseline::UseScript:
4650         m_value.valueID = CSSValueUseScript;
4651         break;
4652     case DominantBaseline::NoChange:
4653         m_value.valueID = CSSValueNoChange;
4654         break;
4655     case DominantBaseline::ResetSize:
4656         m_value.valueID = CSSValueResetSize;
4657         break;
4658     case DominantBaseline::Central:
4659         m_value.valueID = CSSValueCentral;
4660         break;
4661     case DominantBaseline::Middle:
4662         m_value.valueID = CSSValueMiddle;
4663         break;
4664     case DominantBaseline::TextBeforeEdge:
4665         m_value.valueID = CSSValueTextBeforeEdge;
4666         break;
4667     case DominantBaseline::TextAfterEdge:
4668         m_value.valueID = CSSValueTextAfterEdge;
4669         break;
4670     case DominantBaseline::Ideographic:
4671         m_value.valueID = CSSValueIdeographic;
4672         break;
4673     case DominantBaseline::Alphabetic:
4674         m_value.valueID = CSSValueAlphabetic;
4675         break;
4676     case DominantBaseline::Hanging:
4677         m_value.valueID = CSSValueHanging;
4678         break;
4679     case DominantBaseline::Mathematical:
4680         m_value.valueID = CSSValueMathematical;
4681         break;
4682     }
4683 }
4684 
4685 template&lt;&gt; inline CSSPrimitiveValue::operator DominantBaseline() const
4686 {
4687     ASSERT(isValueID());
4688 
4689     switch (m_value.valueID) {
4690     case CSSValueAuto:
4691         return DominantBaseline::Auto;
4692     case CSSValueUseScript:
4693         return DominantBaseline::UseScript;
4694     case CSSValueNoChange:
4695         return DominantBaseline::NoChange;
4696     case CSSValueResetSize:
4697         return DominantBaseline::ResetSize;
4698     case CSSValueIdeographic:
4699         return DominantBaseline::Ideographic;
4700     case CSSValueAlphabetic:
4701         return DominantBaseline::Alphabetic;
4702     case CSSValueHanging:
4703         return DominantBaseline::Hanging;
4704     case CSSValueMathematical:
4705         return DominantBaseline::Mathematical;
4706     case CSSValueCentral:
4707         return DominantBaseline::Central;
4708     case CSSValueMiddle:
4709         return DominantBaseline::Middle;
4710     case CSSValueTextAfterEdge:
4711         return DominantBaseline::TextAfterEdge;
4712     case CSSValueTextBeforeEdge:
4713         return DominantBaseline::TextBeforeEdge;
4714     default:
4715         break;
4716     }
4717 
4718     ASSERT_NOT_REACHED();
4719     return DominantBaseline::Auto;
4720 }
4721 
4722 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ShapeRendering e)
4723     : CSSValue(PrimitiveClass)
4724 {
4725     m_primitiveUnitType = CSS_VALUE_ID;
4726     switch (e) {
4727     case ShapeRendering::Auto:
4728         m_value.valueID = CSSValueAuto;
4729         break;
4730     case ShapeRendering::OptimizeSpeed:
4731         m_value.valueID = CSSValueOptimizeSpeed;
4732         break;
4733     case ShapeRendering::CrispEdges:
4734         m_value.valueID = CSSValueCrispedges;
4735         break;
4736     case ShapeRendering::GeometricPrecision:
4737         m_value.valueID = CSSValueGeometricPrecision;
4738         break;
4739     }
4740 }
4741 
4742 template&lt;&gt; inline CSSPrimitiveValue::operator ShapeRendering() const
4743 {
4744     ASSERT(isValueID());
4745 
4746     switch (m_value.valueID) {
4747     case CSSValueAuto:
4748         return ShapeRendering::Auto;
4749     case CSSValueOptimizeSpeed:
4750         return ShapeRendering::OptimizeSpeed;
4751     case CSSValueCrispedges:
4752         return ShapeRendering::CrispEdges;
4753     case CSSValueGeometricPrecision:
4754         return ShapeRendering::GeometricPrecision;
4755     default:
4756         break;
4757     }
4758 
4759     ASSERT_NOT_REACHED();
4760     return ShapeRendering::Auto;
4761 }
4762 
4763 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAnchor e)
4764     : CSSValue(PrimitiveClass)
4765 {
4766     m_primitiveUnitType = CSS_VALUE_ID;
4767     switch (e) {
4768     case TextAnchor::Start:
4769         m_value.valueID = CSSValueStart;
4770         break;
4771     case TextAnchor::Middle:
4772         m_value.valueID = CSSValueMiddle;
4773         break;
4774     case TextAnchor::End:
4775         m_value.valueID = CSSValueEnd;
4776         break;
4777     }
4778 }
4779 
4780 template&lt;&gt; inline CSSPrimitiveValue::operator TextAnchor() const
4781 {
4782     ASSERT(isValueID());
4783 
4784     switch (m_value.valueID) {
4785     case CSSValueStart:
4786         return TextAnchor::Start;
4787     case CSSValueMiddle:
4788         return TextAnchor::Middle;
4789     case CSSValueEnd:
4790         return TextAnchor::End;
4791     default:
4792         break;
4793     }
4794 
4795     ASSERT_NOT_REACHED();
4796     return TextAnchor::Start;
4797 }
4798 
4799 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(const Color&amp; color)
4800     : CSSValue(PrimitiveClass)
4801 {
4802     m_primitiveUnitType = CSS_RGBCOLOR;
4803     m_value.color = new Color(color);
4804 }
4805 
4806 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSFontFamily fontFamily)
4807     : CSSValue(PrimitiveClass)
4808 {
4809     m_primitiveUnitType = CSS_FONT_FAMILY;
4810     m_value.fontFamily = new CSSFontFamily(WTFMove(fontFamily));
4811 }
4812 
4813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VectorEffect e)
4814     : CSSValue(PrimitiveClass)
4815 {
4816     m_primitiveUnitType = CSS_VALUE_ID;
4817     switch (e) {
4818     case VectorEffect::None:
4819         m_value.valueID = CSSValueNone;
4820         break;
4821     case VectorEffect::NonScalingStroke:
4822         m_value.valueID = CSSValueNonScalingStroke;
4823         break;
4824     }
4825 }
4826 
4827 template&lt;&gt; inline CSSPrimitiveValue::operator VectorEffect() const
4828 {
4829     ASSERT(isValueID());
4830 
4831     switch (m_value.valueID) {
4832     case CSSValueNone:
4833         return VectorEffect::None;
4834     case CSSValueNonScalingStroke:
4835         return VectorEffect::NonScalingStroke;
4836     default:
4837         break;
4838     }
4839 
4840     ASSERT_NOT_REACHED();
4841     return VectorEffect::None;
4842 }
4843 
4844 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MaskType e)
4845     : CSSValue(PrimitiveClass)
4846 {
4847     m_primitiveUnitType = CSS_VALUE_ID;
4848     switch (e) {
4849     case MaskType::Luminance:
4850         m_value.valueID = CSSValueLuminance;
4851         break;
4852     case MaskType::Alpha:
4853         m_value.valueID = CSSValueAlpha;
4854         break;
4855     }
4856 }
4857 
4858 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4859 {
4860     ASSERT(isValueID());
4861 
4862     switch (m_value.valueID) {
4863     case CSSValueLuminance:
4864         return MaskType::Luminance;
4865     case CSSValueAlpha:
4866         return MaskType::Alpha;
4867     default:
4868         break;
4869     }
4870 
4871     ASSERT_NOT_REACHED();
4872     return MaskType::Luminance;
4873 }
4874 
4875 #if ENABLE(CSS_IMAGE_ORIENTATION)
4876 
4877 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientation e)
4878     : CSSValue(PrimitiveClass)
4879 {
4880     m_primitiveUnitType = CSS_DEG;
4881     switch (e) {
4882     case ImageOrientation::OriginTopLeft:
4883         m_value.num = 0;
4884         break;
4885     case ImageOrientation::OriginRightTop:
4886         m_value.num = 90;
4887         break;
4888     case ImageOrientation::OriginBottomRight:
4889         m_value.num = 180;
4890         break;
4891     case ImageOrientation::OriginLeftBottom:
4892         m_value.num = 270;
4893         break;
4894     case ImageOrientation::FromImage:
4895     case ImageOrientation::OriginTopRight:
4896     case ImageOrientation::OriginLeftTop:
4897     case ImageOrientation::OriginBottomLeft:
4898     case ImageOrientation::OriginRightBottom:
4899         ASSERT_NOT_REACHED();
4900     }
4901 }
4902 
4903 template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientation() const
4904 {
4905     ASSERT(isAngle());
4906     double quarters = 4 * doubleValue(CSS_TURN);
4907     int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));
4908     switch (orientation) {
4909     case 0:
4910         return ImageOrientation::OriginTopLeft;
4911     case 1:
4912         return ImageOrientation::OriginRightTop;
4913     case 2:
4914         return ImageOrientation::OriginBottomRight;
4915     case 3:
4916         return ImageOrientation::OriginLeftBottom;
4917     }
4918 
4919     ASSERT_NOT_REACHED();
4920     return ImageOrientation::None;
4921 }
4922 
4923 #endif // ENABLE(CSS_IMAGE_ORIENTATION)
4924 
4925 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4926     : CSSValue(PrimitiveClass)
4927 {
4928     m_primitiveUnitType = CSS_VALUE_ID;
4929     switch (cssBox) {
4930     case CSSBoxType::MarginBox:
4931         m_value.valueID = CSSValueMarginBox;
4932         break;
4933     case CSSBoxType::BorderBox:
4934         m_value.valueID = CSSValueBorderBox;
4935         break;
4936     case CSSBoxType::PaddingBox:
4937         m_value.valueID = CSSValuePaddingBox;
4938         break;
4939     case CSSBoxType::ContentBox:
4940         m_value.valueID = CSSValueContentBox;
4941         break;
4942     case CSSBoxType::FillBox:
4943         m_value.valueID = CSSValueFillBox;
4944         break;
4945     case CSSBoxType::StrokeBox:
4946         m_value.valueID = CSSValueStrokeBox;
4947         break;
4948     case CSSBoxType::ViewBox:
4949         m_value.valueID = CSSValueViewBox;
4950         break;
4951     case CSSBoxType::BoxMissing:
4952         ASSERT_NOT_REACHED();
4953         m_value.valueID = CSSValueNone;
4954         break;
4955     }
4956 }
4957 
4958 template&lt;&gt; inline CSSPrimitiveValue::operator CSSBoxType() const
4959 {
4960     switch (valueID()) {
4961     case CSSValueMarginBox:
4962         return CSSBoxType::MarginBox;
4963     case CSSValueBorderBox:
4964         return CSSBoxType::BorderBox;
4965     case CSSValuePaddingBox:
4966         return CSSBoxType::PaddingBox;
4967     case CSSValueContentBox:
4968         return CSSBoxType::ContentBox;
4969     // The following are used in an SVG context.
4970     case CSSValueFillBox:
4971         return CSSBoxType::FillBox;
4972     case CSSValueStrokeBox:
4973         return CSSBoxType::StrokeBox;
4974     case CSSValueViewBox:
4975         return CSSBoxType::ViewBox;
4976     default:
4977         break;
4978     }
4979     ASSERT_NOT_REACHED();
4980     return CSSBoxType::BoxMissing;
4981 }
4982 
4983 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ItemPosition itemPosition)
4984     : CSSValue(PrimitiveClass)
4985 {
4986     m_primitiveUnitType = CSS_VALUE_ID;
4987     switch (itemPosition) {
4988     case ItemPosition::Legacy:
4989         m_value.valueID = CSSValueLegacy;
4990         break;
4991     case ItemPosition::Auto:
4992         m_value.valueID = CSSValueAuto;
4993         break;
4994     case ItemPosition::Normal:
4995         m_value.valueID = CSSValueNormal;
4996         break;
4997     case ItemPosition::Stretch:
4998         m_value.valueID = CSSValueStretch;
4999         break;
5000     case ItemPosition::Baseline:
5001         m_value.valueID = CSSValueBaseline;
5002         break;
5003     case ItemPosition::LastBaseline:
5004         m_value.valueID = CSSValueLastBaseline;
5005         break;
5006     case ItemPosition::Center:
5007         m_value.valueID = CSSValueCenter;
5008         break;
5009     case ItemPosition::Start:
5010         m_value.valueID = CSSValueStart;
5011         break;
5012     case ItemPosition::End:
5013         m_value.valueID = CSSValueEnd;
5014         break;
5015     case ItemPosition::SelfStart:
5016         m_value.valueID = CSSValueSelfStart;
5017         break;
5018     case ItemPosition::SelfEnd:
5019         m_value.valueID = CSSValueSelfEnd;
5020         break;
5021     case ItemPosition::FlexStart:
5022         m_value.valueID = CSSValueFlexStart;
5023         break;
5024     case ItemPosition::FlexEnd:
5025         m_value.valueID = CSSValueFlexEnd;
5026         break;
5027     case ItemPosition::Left:
5028         m_value.valueID = CSSValueLeft;
5029         break;
5030     case ItemPosition::Right:
5031         m_value.valueID = CSSValueRight;
5032         break;
5033     }
5034 }
5035 
5036 template&lt;&gt; inline CSSPrimitiveValue::operator ItemPosition() const
5037 {
5038     switch (m_value.valueID) {
5039     case CSSValueLegacy:
5040         return ItemPosition::Legacy;
5041     case CSSValueAuto:
5042         return ItemPosition::Auto;
5043     case CSSValueNormal:
5044         return ItemPosition::Normal;
5045     case CSSValueStretch:
5046         return ItemPosition::Stretch;
5047     case CSSValueBaseline:
5048         return ItemPosition::Baseline;
5049     case CSSValueFirstBaseline:
5050         return ItemPosition::Baseline;
5051     case CSSValueLastBaseline:
5052         return ItemPosition::LastBaseline;
5053     case CSSValueCenter:
5054         return ItemPosition::Center;
5055     case CSSValueStart:
5056         return ItemPosition::Start;
5057     case CSSValueEnd:
5058         return ItemPosition::End;
5059     case CSSValueSelfStart:
5060         return ItemPosition::SelfStart;
5061     case CSSValueSelfEnd:
5062         return ItemPosition::SelfEnd;
5063     case CSSValueFlexStart:
5064         return ItemPosition::FlexStart;
5065     case CSSValueFlexEnd:
5066         return ItemPosition::FlexEnd;
5067     case CSSValueLeft:
5068         return ItemPosition::Left;
5069     case CSSValueRight:
5070         return ItemPosition::Right;
5071     default:
5072         break;
5073     }
5074     ASSERT_NOT_REACHED();
5075     return ItemPosition::Auto;
5076 }
5077 
5078 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowAlignment overflowAlignment)
5079     : CSSValue(PrimitiveClass)
5080 {
5081     m_primitiveUnitType = CSS_VALUE_ID;
5082     switch (overflowAlignment) {
5083     case OverflowAlignment::Default:
5084         m_value.valueID = CSSValueDefault;
5085         break;
5086     case OverflowAlignment::Unsafe:
5087         m_value.valueID = CSSValueUnsafe;
5088         break;
5089     case OverflowAlignment::Safe:
5090         m_value.valueID = CSSValueSafe;
5091         break;
5092     }
5093 }
5094 
5095 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowAlignment() const
5096 {
5097     switch (m_value.valueID) {
5098     case CSSValueUnsafe:
5099         return OverflowAlignment::Unsafe;
5100     case CSSValueSafe:
5101         return OverflowAlignment::Safe;
5102     default:
5103         break;
5104     }
5105     ASSERT_NOT_REACHED();
5106     return OverflowAlignment::Unsafe;
5107 }
5108 
5109 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentPosition contentPosition)
5110     : CSSValue(PrimitiveClass)
5111 {
5112     m_primitiveUnitType = CSS_VALUE_ID;
5113     switch (contentPosition) {
5114     case ContentPosition::Normal:
5115         m_value.valueID = CSSValueNormal;
5116         break;
5117     case ContentPosition::Baseline:
5118         m_value.valueID = CSSValueBaseline;
5119         break;
5120     case ContentPosition::LastBaseline:
5121         m_value.valueID = CSSValueLastBaseline;
5122         break;
5123     case ContentPosition::Center:
5124         m_value.valueID = CSSValueCenter;
5125         break;
5126     case ContentPosition::Start:
5127         m_value.valueID = CSSValueStart;
5128         break;
5129     case ContentPosition::End:
5130         m_value.valueID = CSSValueEnd;
5131         break;
5132     case ContentPosition::FlexStart:
5133         m_value.valueID = CSSValueFlexStart;
5134         break;
5135     case ContentPosition::FlexEnd:
5136         m_value.valueID = CSSValueFlexEnd;
5137         break;
5138     case ContentPosition::Left:
5139         m_value.valueID = CSSValueLeft;
5140         break;
5141     case ContentPosition::Right:
5142         m_value.valueID = CSSValueRight;
5143         break;
5144     }
5145 }
5146 
5147 template&lt;&gt; inline CSSPrimitiveValue::operator ContentPosition() const
5148 {
5149     switch (m_value.valueID) {
5150     case CSSValueNormal:
5151         return ContentPosition::Normal;
5152     case CSSValueBaseline:
5153         return ContentPosition::Baseline;
5154     case CSSValueFirstBaseline:
5155         return ContentPosition::Baseline;
5156     case CSSValueLastBaseline:
5157         return ContentPosition::LastBaseline;
5158     case CSSValueCenter:
5159         return ContentPosition::Center;
5160     case CSSValueStart:
5161         return ContentPosition::Start;
5162     case CSSValueEnd:
5163         return ContentPosition::End;
5164     case CSSValueFlexStart:
5165         return ContentPosition::FlexStart;
5166     case CSSValueFlexEnd:
5167         return ContentPosition::FlexEnd;
5168     case CSSValueLeft:
5169         return ContentPosition::Left;
5170     case CSSValueRight:
5171         return ContentPosition::Right;
5172     default:
5173         break;
5174     }
5175     ASSERT_NOT_REACHED();
5176     return ContentPosition::Normal;
5177 }
5178 
5179 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentDistribution contentDistribution)
5180     : CSSValue(PrimitiveClass)
5181 {
5182     m_primitiveUnitType = CSS_VALUE_ID;
5183     switch (contentDistribution) {
5184     case ContentDistribution::Default:
5185         m_value.valueID = CSSValueDefault;
5186         break;
5187     case ContentDistribution::SpaceBetween:
5188         m_value.valueID = CSSValueSpaceBetween;
5189         break;
5190     case ContentDistribution::SpaceAround:
5191         m_value.valueID = CSSValueSpaceAround;
5192         break;
5193     case ContentDistribution::SpaceEvenly:
5194         m_value.valueID = CSSValueSpaceEvenly;
5195         break;
5196     case ContentDistribution::Stretch:
5197         m_value.valueID = CSSValueStretch;
5198         break;
5199     }
5200 }
5201 
5202 template&lt;&gt; inline CSSPrimitiveValue::operator ContentDistribution() const
5203 {
5204     switch (m_value.valueID) {
5205     case CSSValueSpaceBetween:
5206         return ContentDistribution::SpaceBetween;
5207     case CSSValueSpaceAround:
5208         return ContentDistribution::SpaceAround;
5209     case CSSValueSpaceEvenly:
5210         return ContentDistribution::SpaceEvenly;
5211     case CSSValueStretch:
5212         return ContentDistribution::Stretch;
5213     default:
5214         break;
5215     }
5216     ASSERT_NOT_REACHED();
5217     return ContentDistribution::Stretch;
5218 }
5219 
5220 template&lt;&gt; inline CSSPrimitiveValue::operator TextZoom() const
5221 {
5222     ASSERT(isValueID());
5223 
5224     switch (m_value.valueID) {
5225     case CSSValueNormal:
5226         return TextZoom::Normal;
5227     case CSSValueReset:
5228         return TextZoom::Reset;
5229     default:
5230         break;
5231     }
5232 
5233     ASSERT_NOT_REACHED();
5234     return TextZoom::Normal;
5235 }
5236 
5237 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextZoom textZoom)
5238     : CSSValue(PrimitiveClass)
5239 {
5240     m_primitiveUnitType = CSS_VALUE_ID;
5241     switch (textZoom) {
5242     case TextZoom::Normal:
5243         m_value.valueID = CSSValueNormal;
5244         return;
5245     case TextZoom::Reset:
5246         m_value.valueID = CSSValueReset;
5247         return;
5248     }
5249 
5250     ASSERT_NOT_REACHED();
5251     m_value.valueID = CSSValueNormal;
5252 }
5253 
5254 #if ENABLE(POINTER_EVENTS)
5255 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TouchAction touchAction)
5256     : CSSValue(PrimitiveClass)
5257 {
5258     m_primitiveUnitType = CSS_VALUE_ID;
5259     switch (touchAction) {
5260     case TouchAction::Auto:
5261         m_value.valueID = CSSValueAuto;
5262         break;
5263     case TouchAction::Manipulation:
5264         m_value.valueID = CSSValueManipulation;
5265         break;
5266     case TouchAction::None:
5267         m_value.valueID = CSSValueNone;
5268         break;
5269     case TouchAction::PanX:
5270         m_value.valueID = CSSValuePanX;
5271         break;
5272     case TouchAction::PanY:
5273         m_value.valueID = CSSValuePanY;
5274         break;
5275     case TouchAction::PinchZoom:
5276         m_value.valueID = CSSValuePinchZoom;
5277         break;
5278     }
5279 }
5280 
5281 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;TouchAction&gt;() const
5282 {
5283     ASSERT(isValueID());
5284     switch (m_value.valueID) {
5285     case CSSValueAuto:
5286         return TouchAction::Auto;
5287     case CSSValueManipulation:
5288         return TouchAction::Manipulation;
5289     case CSSValueNone:
5290         return TouchAction::None;
5291     case CSSValuePanX:
5292         return TouchAction::PanX;
5293     case CSSValuePanY:
5294         return TouchAction::PanY;
5295     case CSSValuePinchZoom:
5296         return TouchAction::PinchZoom;
5297     default:
5298         break;
5299     }
5300     ASSERT_NOT_REACHED();
5301     return TouchAction::Auto;
5302 }
5303 #endif
5304 
5305 #if ENABLE(CSS_SCROLL_SNAP)
5306 
5307 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapStrictness strictness)
5308     : CSSValue(PrimitiveClass)
5309 {
5310     m_primitiveUnitType = CSS_VALUE_ID;
5311     switch (strictness) {
5312     case ScrollSnapStrictness::None:
5313         m_value.valueID = CSSValueNone;
5314         break;
5315     case ScrollSnapStrictness::Proximity:
5316         m_value.valueID = CSSValueProximity;
5317         break;
5318     case ScrollSnapStrictness::Mandatory:
5319         m_value.valueID = CSSValueMandatory;
5320         break;
5321     }
5322 }
5323 
5324 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapStrictness() const
5325 {
5326     ASSERT(isValueID());
5327     switch (m_value.valueID) {
5328     case CSSValueNone:
5329         return ScrollSnapStrictness::None;
5330     case CSSValueProximity:
5331         return ScrollSnapStrictness::Proximity;
5332     case CSSValueMandatory:
5333         return ScrollSnapStrictness::Mandatory;
5334     default:
5335         ASSERT_NOT_REACHED();
5336         return ScrollSnapStrictness::None;
5337     }
5338 }
5339 
5340 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxis axis)
5341     : CSSValue(PrimitiveClass)
5342 {
5343     m_primitiveUnitType = CSS_VALUE_ID;
5344     switch (axis) {
5345     case ScrollSnapAxis::XAxis:
5346         m_value.valueID = CSSValueX;
5347         break;
5348     case ScrollSnapAxis::YAxis:
5349         m_value.valueID = CSSValueY;
5350         break;
5351     case ScrollSnapAxis::Block:
5352         m_value.valueID = CSSValueBlock;
5353         break;
5354     case ScrollSnapAxis::Inline:
5355         m_value.valueID = CSSValueInline;
5356         break;
5357     case ScrollSnapAxis::Both:
5358         m_value.valueID = CSSValueBoth;
5359         break;
5360     }
5361 }
5362 
5363 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxis() const
5364 {
5365     ASSERT(isValueID());
5366     switch (m_value.valueID) {
5367     case CSSValueX:
5368         return ScrollSnapAxis::XAxis;
5369     case CSSValueY:
5370         return ScrollSnapAxis::YAxis;
5371     case CSSValueBlock:
5372         return ScrollSnapAxis::Block;
5373     case CSSValueInline:
5374         return ScrollSnapAxis::Inline;
5375     case CSSValueBoth:
5376         return ScrollSnapAxis::Both;
5377     default:
5378         ASSERT_NOT_REACHED();
5379         return ScrollSnapAxis::Both;
5380     }
5381 }
5382 
5383 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxisAlignType type)
5384     : CSSValue(PrimitiveClass)
5385 {
5386     m_primitiveUnitType = CSS_VALUE_ID;
5387     switch (type) {
5388     case ScrollSnapAxisAlignType::None:
5389         m_value.valueID = CSSValueNone;
5390         break;
5391     case ScrollSnapAxisAlignType::Start:
5392         m_value.valueID = CSSValueStart;
5393         break;
5394     case ScrollSnapAxisAlignType::Center:
5395         m_value.valueID = CSSValueCenter;
5396         break;
5397     case ScrollSnapAxisAlignType::End:
5398         m_value.valueID = CSSValueEnd;
5399         break;
5400     }
5401 }
5402 
5403 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxisAlignType() const
5404 {
5405     ASSERT(isValueID());
5406     switch (m_value.valueID) {
5407     case CSSValueNone:
5408         return ScrollSnapAxisAlignType::None;
5409     case CSSValueStart:
5410         return ScrollSnapAxisAlignType::Start;
5411     case CSSValueCenter:
5412         return ScrollSnapAxisAlignType::Center;
5413     case CSSValueEnd:
5414         return ScrollSnapAxisAlignType::End;
5415     default:
5416         ASSERT_NOT_REACHED();
5417         return ScrollSnapAxisAlignType::None;
5418     }
5419 }
5420 
5421 #endif
5422 
5423 #if ENABLE(CSS_TRAILING_WORD)
5424 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TrailingWord e)
5425     : CSSValue(PrimitiveClass)
5426 {
5427     m_primitiveUnitType = CSS_VALUE_ID;
5428     switch (e) {
5429     case TrailingWord::Auto:
5430         m_value.valueID = CSSValueAuto;
5431         break;
5432     case TrailingWord::PartiallyBalanced:
5433         m_value.valueID = CSSValueWebkitPartiallyBalanced;
5434         break;
5435     default:
5436         ASSERT_NOT_REACHED();
5437         break;
5438     }
5439 }
5440 
5441 template&lt;&gt; inline CSSPrimitiveValue::operator TrailingWord() const
5442 {
5443     ASSERT(isValueID());
5444     switch (m_value.valueID) {
5445     case CSSValueAuto:
5446         return TrailingWord::Auto;
5447     case CSSValueWebkitPartiallyBalanced:
5448         return TrailingWord::PartiallyBalanced;
5449     default:
5450         break;
5451     }
5452     ASSERT_NOT_REACHED();
5453     return TrailingWord::Auto;
5454 }
5455 #endif
5456 
5457 #if ENABLE(APPLE_PAY)
5458 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonStyle e)
5459     : CSSValue(PrimitiveClass)
5460 {
5461     m_primitiveUnitType = CSS_VALUE_ID;
5462     switch (e) {
5463     case ApplePayButtonStyle::White:
5464         m_value.valueID = CSSValueWhite;
5465         break;
5466     case ApplePayButtonStyle::WhiteOutline:
5467         m_value.valueID = CSSValueWhiteOutline;
5468         break;
5469     case ApplePayButtonStyle::Black:
5470         m_value.valueID = CSSValueBlack;
5471         break;
5472     default:
5473         ASSERT_NOT_REACHED();
5474         break;
5475     }
5476 }
5477 
5478 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonStyle() const
5479 {
5480     ASSERT(isValueID());
5481     switch (m_value.valueID) {
5482     case CSSValueWhite:
5483         return ApplePayButtonStyle::White;
5484     case CSSValueWhiteOutline:
5485         return ApplePayButtonStyle::WhiteOutline;
5486     case CSSValueBlack:
5487         return ApplePayButtonStyle::Black;
5488     default:
5489         break;
5490     }
5491     ASSERT_NOT_REACHED();
5492     return ApplePayButtonStyle::Black;
5493 }
5494 
5495 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonType e)
5496     : CSSValue(PrimitiveClass)
5497 {
5498     m_primitiveUnitType = CSS_VALUE_ID;
5499     switch (e) {
5500     case ApplePayButtonType::Plain:
5501         m_value.valueID = CSSValuePlain;
5502         break;
5503     case ApplePayButtonType::Buy:
5504         m_value.valueID = CSSValueBuy;
5505         break;
5506     case ApplePayButtonType::SetUp:
5507         m_value.valueID = CSSValueSetUp;
5508         break;
5509     case ApplePayButtonType::Donate:
5510         m_value.valueID = CSSValueDonate;
5511         break;
5512 #if ENABLE(APPLE_PAY_SESSION_V4)
5513     case ApplePayButtonType::CheckOut:
5514         m_value.valueID = CSSValueCheckOut;
5515         break;
5516     case ApplePayButtonType::Book:
5517         m_value.valueID = CSSValueBook;
5518         break;
5519     case ApplePayButtonType::Subscribe:
5520         m_value.valueID = CSSValueSubscribe;
5521         break;
5522 #endif
5523 
5524     default:
5525         ASSERT_NOT_REACHED();
5526         break;
5527     }
5528 }
5529 
5530 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonType() const
5531 {
5532     ASSERT(isValueID());
5533     switch (m_value.valueID) {
5534     case CSSValuePlain:
5535         return ApplePayButtonType::Plain;
5536     case CSSValueBuy:
5537         return ApplePayButtonType::Buy;
5538     case CSSValueSetUp:
5539         return ApplePayButtonType::SetUp;
5540     case CSSValueDonate:
5541         return ApplePayButtonType::Donate;
5542 #if ENABLE(APPLE_PAY_SESSION_V4)
5543     case CSSValueCheckOut:
5544         return ApplePayButtonType::CheckOut;
5545     case CSSValueBook:
5546         return ApplePayButtonType::Book;
5547     case CSSValueSubscribe:
5548         return ApplePayButtonType::Subscribe;
5549 #endif
5550     default:
5551         break;
5552     }
5553     ASSERT_NOT_REACHED();
5554     return ApplePayButtonType::Plain;
5555 }
5556 #endif
5557 
5558 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantPosition position)
5559     : CSSValue(PrimitiveClass)
5560 {
5561     m_primitiveUnitType = CSS_VALUE_ID;
5562     switch (position) {
5563     case FontVariantPosition::Normal:
5564         m_value.valueID = CSSValueNormal;
5565         break;
5566     case FontVariantPosition::Subscript:
5567         m_value.valueID = CSSValueSub;
5568         break;
5569     case FontVariantPosition::Superscript:
5570         m_value.valueID = CSSValueSuper;
5571         break;
5572     default:
5573         ASSERT_NOT_REACHED();
5574         break;
5575     }
5576 }
5577 
5578 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantPosition() const
5579 {
5580     ASSERT(isValueID());
5581     switch (m_value.valueID) {
5582     case CSSValueNormal:
5583         return FontVariantPosition::Normal;
5584     case CSSValueSub:
5585         return FontVariantPosition::Subscript;
5586     case CSSValueSuper:
5587         return FontVariantPosition::Superscript;
5588     default:
5589         break;
5590     }
5591     ASSERT_NOT_REACHED();
5592     return FontVariantPosition::Normal;
5593 }
5594 
5595 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantCaps caps)
5596     : CSSValue(PrimitiveClass)
5597 {
5598     m_primitiveUnitType = CSS_VALUE_ID;
5599     switch (caps) {
5600     case FontVariantCaps::Normal:
5601         m_value.valueID = CSSValueNormal;
5602         break;
5603     case FontVariantCaps::Small:
5604         m_value.valueID = CSSValueSmallCaps;
5605         break;
5606     case FontVariantCaps::AllSmall:
5607         m_value.valueID = CSSValueAllSmallCaps;
5608         break;
5609     case FontVariantCaps::Petite:
5610         m_value.valueID = CSSValuePetiteCaps;
5611         break;
5612     case FontVariantCaps::AllPetite:
5613         m_value.valueID = CSSValueAllPetiteCaps;
5614         break;
5615     case FontVariantCaps::Unicase:
5616         m_value.valueID = CSSValueUnicase;
5617         break;
5618     case FontVariantCaps::Titling:
5619         m_value.valueID = CSSValueTitlingCaps;
5620         break;
5621     default:
5622         ASSERT_NOT_REACHED();
5623         break;
5624     }
5625 }
5626 
5627 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantCaps() const
5628 {
5629     ASSERT(isValueID());
5630     switch (m_value.valueID) {
5631     case CSSValueNormal:
5632         return FontVariantCaps::Normal;
5633     case CSSValueSmallCaps:
5634         return FontVariantCaps::Small;
5635     case CSSValueAllSmallCaps:
5636         return FontVariantCaps::AllSmall;
5637     case CSSValuePetiteCaps:
5638         return FontVariantCaps::Petite;
5639     case CSSValueAllPetiteCaps:
5640         return FontVariantCaps::AllPetite;
5641     case CSSValueUnicase:
5642         return FontVariantCaps::Unicase;
5643     case CSSValueTitlingCaps:
5644         return FontVariantCaps::Titling;
5645     default:
5646         break;
5647     }
5648     ASSERT_NOT_REACHED();
5649     return FontVariantCaps::Normal;
5650 }
5651 
5652 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantAlternates alternates)
5653     : CSSValue(PrimitiveClass)
5654 {
5655     m_primitiveUnitType = CSS_VALUE_ID;
5656     switch (alternates) {
5657     case FontVariantAlternates::Normal:
5658         m_value.valueID = CSSValueNormal;
5659         break;
5660     case FontVariantAlternates::HistoricalForms:
5661         m_value.valueID = CSSValueHistoricalForms;
5662         break;
5663     default:
5664         ASSERT_NOT_REACHED();
5665         break;
5666     }
5667 }
5668 
5669 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantAlternates() const
5670 {
5671     ASSERT(isValueID());
5672     switch (m_value.valueID) {
5673     case CSSValueNormal:
5674         return FontVariantAlternates::Normal;
5675     case CSSValueHistoricalForms:
5676         return FontVariantAlternates::HistoricalForms;
5677     default:
5678         break;
5679     }
5680     ASSERT_NOT_REACHED();
5681     return FontVariantAlternates::Normal;
5682 }
5683 
5684 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontOpticalSizing sizing)
5685     : CSSValue(PrimitiveClass)
5686 {
5687     m_primitiveUnitType = CSS_VALUE_ID;
5688     switch (sizing) {
5689     case FontOpticalSizing::Enabled:
5690         m_value.valueID = CSSValueAuto;
5691         break;
5692     case FontOpticalSizing::Disabled:
5693         m_value.valueID = CSSValueNone;
5694         break;
5695     default:
5696         ASSERT_NOT_REACHED();
5697         break;
5698     }
5699 }
5700 
5701 template&lt;&gt; inline CSSPrimitiveValue::operator FontOpticalSizing() const
5702 {
5703     ASSERT(isValueID());
5704     switch (m_value.valueID) {
5705     case CSSValueAuto:
5706         return FontOpticalSizing::Enabled;
5707     case CSSValueNone:
5708         return FontOpticalSizing::Disabled;
5709     default:
5710         break;
5711     }
5712     ASSERT_NOT_REACHED();
5713     return FontOpticalSizing::Enabled;
5714 }
5715 
5716 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontLoadingBehavior behavior)
5717     : CSSValue(PrimitiveClass)
5718 {
5719     m_primitiveUnitType = CSS_VALUE_ID;
5720     switch (behavior) {
5721     case FontLoadingBehavior::Auto:
5722         m_value.valueID = CSSValueAuto;
5723         break;
5724     case FontLoadingBehavior::Block:
5725         m_value.valueID = CSSValueBlock;
5726         break;
5727     case FontLoadingBehavior::Swap:
5728         m_value.valueID = CSSValueSwap;
5729         break;
5730     case FontLoadingBehavior::Fallback:
5731         m_value.valueID = CSSValueFallback;
5732         break;
5733     case FontLoadingBehavior::Optional:
5734         m_value.valueID = CSSValueOptional;
5735         break;
5736     default:
5737         ASSERT_NOT_REACHED();
5738         break;
5739     }
5740 }
5741 
5742 template&lt;&gt; inline CSSPrimitiveValue::operator FontLoadingBehavior() const
5743 {
5744     ASSERT(isValueID());
5745     switch (m_value.valueID) {
5746     case CSSValueAuto:
5747         return FontLoadingBehavior::Auto;
5748     case CSSValueBlock:
5749         return FontLoadingBehavior::Block;
5750     case CSSValueSwap:
5751         return FontLoadingBehavior::Swap;
5752     case CSSValueFallback:
5753         return FontLoadingBehavior::Fallback;
5754     case CSSValueOptional:
5755         return FontLoadingBehavior::Optional;
5756     default:
5757         break;
5758     }
5759     ASSERT_NOT_REACHED();
5760     return FontLoadingBehavior::Auto;
5761 }
5762 
5763 }
    </pre>
  </body>
</html>