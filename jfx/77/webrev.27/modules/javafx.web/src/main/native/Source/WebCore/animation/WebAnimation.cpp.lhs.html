<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebAnimation.h&quot;
  28 
  29 #include &quot;AnimationEffect.h&quot;
  30 #include &quot;AnimationPlaybackEvent.h&quot;
  31 #include &quot;AnimationTimeline.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;DocumentTimeline.h&quot;
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;JSWebAnimation.h&quot;
  36 #include &quot;KeyframeEffect.h&quot;
  37 #include &quot;Microtasks.h&quot;
  38 #include &quot;WebAnimationUtilities.h&quot;
<a name="1" id="anc1"></a>

  39 #include &lt;wtf/text/WTFString.h&gt;
  40 
  41 namespace WebCore {
  42 
<a name="2" id="anc2"></a>

  43 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  44 {
  45     auto result = adoptRef(*new WebAnimation(document));
  46     result-&gt;setEffect(effect);
  47     result-&gt;setTimeline(&amp;document.timeline());
  48     return result;
  49 }
  50 
  51 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  52 {
  53     auto result = adoptRef(*new WebAnimation(document));
  54     result-&gt;setEffect(effect);
  55     if (timeline)
  56         result-&gt;setTimeline(timeline);
  57     return result;
  58 }
  59 
  60 WebAnimation::WebAnimation(Document&amp; document)
  61     : ActiveDOMObject(document)
  62     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
  63     , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
  64 {
  65     m_readyPromise-&gt;resolve(*this);
  66     suspendIfNeeded();
  67 }
  68 
  69 WebAnimation::~WebAnimation()
  70 {
  71     if (m_timeline)
  72         m_timeline-&gt;forgetAnimation(this);
  73 }
  74 
  75 void WebAnimation::remove()
  76 {
  77     // This object could be deleted after either clearing the effect or timeline relationship.
  78     auto protectedThis = makeRef(*this);
  79     setEffectInternal(nullptr);
  80     setTimelineInternal(nullptr);
  81 }
  82 
  83 void WebAnimation::suspendEffectInvalidation()
  84 {
  85     ++m_suspendCount;
  86 }
  87 
  88 void WebAnimation::unsuspendEffectInvalidation()
  89 {
  90     ASSERT(m_suspendCount &gt; 0);
  91     --m_suspendCount;
  92 }
  93 
  94 void WebAnimation::effectTimingDidChange()
  95 {
  96     timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
  97 }
  98 
  99 void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
 100 {
 101     // 3.4.3. Setting the target effect of an animation
 102     // https://drafts.csswg.org/web-animations-1/#setting-the-target-effect
 103 
 104     // 1. Let old effect be the current target effect of animation, if any.
 105     auto oldEffect = m_effect;
 106 
 107     // 2. If new effect is the same object as old effect, abort this procedure.
 108     if (newEffect == oldEffect)
 109         return;
 110 
 111     // 3. If animation has a pending pause task, reschedule that task to run as soon as animation is ready.
 112     if (hasPendingPauseTask())
 113         m_timeToRunPendingPauseTask = TimeToRunPendingTask::WhenReady;
 114 
 115     // 4. If animation has a pending play task, reschedule that task to run as soon as animation is ready to play new effect.
 116     if (hasPendingPlayTask())
 117         m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 118 
 119     // 5. If new effect is not null and if new effect is the target effect of another animation, previous animation, run the
 120     // procedure to set the target effect of an animation (this procedure) on previous animation passing null as new effect.
 121     if (newEffect &amp;&amp; newEffect-&gt;animation())
 122         newEffect-&gt;animation()-&gt;setEffect(nullptr);
 123 
 124     // 6. Let the target effect of animation be new effect.
 125     // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 126     // while the effect was set via the API, the element still has a transition or animation set up and we must
 127     // not break the timeline-to-animation relationship.
 128 
 129     invalidateEffect();
 130 
 131     // This object could be deleted after clearing the effect relationship.
 132     auto protectedThis = makeRef(*this);
 133     setEffectInternal(WTFMove(newEffect), isDeclarativeAnimation());
 134 
 135     // 7. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 136     // and the synchronously notify flag set to false.
 137     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 138 
 139     invalidateEffect();
 140 }
 141 
 142 void WebAnimation::setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect, bool doNotRemoveFromTimeline)
 143 {
 144     if (m_effect == newEffect)
 145         return;
 146 
 147     auto oldEffect = std::exchange(m_effect, WTFMove(newEffect));
 148 
 149     Element* previousTarget = nullptr;
 150     if (is&lt;KeyframeEffect&gt;(oldEffect))
 151         previousTarget = downcast&lt;KeyframeEffect&gt;(oldEffect.get())-&gt;target();
 152 
 153     Element* newTarget = nullptr;
 154     if (is&lt;KeyframeEffect&gt;(m_effect))
 155         newTarget = downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target();
 156 
 157     // Update the effect-to-animation relationships and the timeline&#39;s animation map.
 158     if (oldEffect) {
 159         oldEffect-&gt;setAnimation(nullptr);
 160         if (!doNotRemoveFromTimeline &amp;&amp; m_timeline &amp;&amp; previousTarget &amp;&amp; previousTarget != newTarget)
 161             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 162         updateRelevance();
 163     }
 164 
 165     if (m_effect) {
 166         m_effect-&gt;setAnimation(this);
 167         if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
 168             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 169     }
 170 }
 171 
 172 void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 173 {
 174     // 3.4.1. Setting the timeline of an animation
 175     // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
 176 
 177     // 2. If new timeline is the same object as old timeline, abort this procedure.
 178     if (timeline == m_timeline)
 179         return;
 180 
 181     // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
 182     if (m_startTime)
 183         m_holdTime = WTF::nullopt;
 184 
 185     if (is&lt;KeyframeEffect&gt;(m_effect)) {
 186         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(m_effect.get());
 187         auto* target = keyframeEffect-&gt;target();
 188         if (target) {
 189             // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 190             // while the timeline was set via the API, the element still has a transition or animation set up and we must
 191             // not break the relationship.
 192             if (m_timeline &amp;&amp; !isDeclarativeAnimation())
 193                 m_timeline-&gt;animationWasRemovedFromElement(*this, *target);
 194             if (timeline)
 195                 timeline-&gt;animationWasAddedToElement(*this, *target);
 196         }
 197     }
 198 
 199     // This object could be deleted after clearing the timeline relationship.
 200     auto protectedThis = makeRef(*this);
 201     setTimelineInternal(WTFMove(timeline));
 202 
 203     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());
 204 
 205     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 206     // and the synchronously notify flag set to false.
 207     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 208 
 209     invalidateEffect();
 210 }
 211 
 212 void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 213 {
 214     if (m_timeline == timeline)
 215         return;
 216 
 217     if (m_timeline)
 218         m_timeline-&gt;removeAnimation(*this);
 219 
 220     m_timeline = WTFMove(timeline);
 221 }
 222 
 223 void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
 224 {
 225     if (!m_timeline)
 226         return;
 227 
 228     if (previousTarget)
 229         m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 230 
 231     if (newTarget)
 232         m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 233 }
 234 
 235 Optional&lt;double&gt; WebAnimation::startTime() const
 236 {
 237     if (!m_startTime)
 238         return WTF::nullopt;
 239     return secondsToWebAnimationsAPITime(m_startTime.value());
 240 }
 241 
 242 void WebAnimation::setStartTime(Optional&lt;double&gt; startTime)
 243 {
 244     // 3.4.6 The procedure to set the start time of animation, animation, to new start time, is as follows:
 245     // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation
 246 
 247     Optional&lt;Seconds&gt; newStartTime;
 248     if (!startTime)
 249         newStartTime = WTF::nullopt;
 250     else
 251         newStartTime = Seconds::fromMilliseconds(startTime.value());
 252 
 253     // 1. Let timeline time be the current time value of the timeline that animation is associated with. If
 254     //    there is no timeline associated with animation or the associated timeline is inactive, let the timeline
 255     //    time be unresolved.
 256     auto timelineTime = m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt;
 257 
 258     // 2. If timeline time is unresolved and new start time is resolved, make animation&#39;s hold time unresolved.
 259     if (!timelineTime &amp;&amp; newStartTime)
 260         m_holdTime = WTF::nullopt;
 261 
 262     // 3. Let previous current time be animation&#39;s current time.
 263     auto previousCurrentTime = currentTime();
 264 
 265     // 4. Apply any pending playback rate on animation.
 266     applyPendingPlaybackRate();
 267 
 268     // 5. Set animation&#39;s start time to new start time.
 269     m_startTime = newStartTime;
 270 
 271     // 6. Update animation&#39;s hold time based on the first matching condition from the following,
 272     if (newStartTime) {
 273         // If new start time is resolved,
 274         // If animation&#39;s playback rate is not zero, make animation&#39;s hold time unresolved.
 275         if (m_playbackRate)
 276             m_holdTime = WTF::nullopt;
 277     } else {
 278         // Otherwise (new start time is unresolved),
 279         // Set animation&#39;s hold time to previous current time even if previous current time is unresolved.
 280         m_holdTime = previousCurrentTime;
 281     }
 282 
 283     // 7. If animation has a pending play task or a pending pause task, cancel that task and resolve animation&#39;s current ready promise with animation.
 284     if (pending()) {
 285         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 286         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 287         m_readyPromise-&gt;resolve(*this);
 288     }
 289 
 290     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
 291     timingDidChange(DidSeek::Yes, SynchronouslyNotify::No);
 292 
 293     invalidateEffect();
 294 }
 295 
 296 Optional&lt;double&gt; WebAnimation::bindingsCurrentTime() const
 297 {
 298     auto time = currentTime();
 299     if (!time)
 300         return WTF::nullopt;
 301     return secondsToWebAnimationsAPITime(time.value());
 302 }
 303 
 304 ExceptionOr&lt;void&gt; WebAnimation::setBindingsCurrentTime(Optional&lt;double&gt; currentTime)
 305 {
 306     if (!currentTime)
 307         return setCurrentTime(WTF::nullopt);
 308     return setCurrentTime(Seconds::fromMilliseconds(currentTime.value()));
 309 }
 310 
 311 Optional&lt;Seconds&gt; WebAnimation::currentTime() const
 312 {
 313     return currentTime(RespectHoldTime::Yes);
 314 }
 315 
 316 Optional&lt;Seconds&gt; WebAnimation::currentTime(RespectHoldTime respectHoldTime) const
 317 {
 318     // 3.4.4. The current time of an animation
 319     // https://drafts.csswg.org/web-animations-1/#the-current-time-of-an-animation
 320 
 321     // The current time is calculated from the first matching condition from below:
 322 
 323     // If the animation&#39;s hold time is resolved, the current time is the animation&#39;s hold time.
 324     if (respectHoldTime == RespectHoldTime::Yes &amp;&amp; m_holdTime)
 325         return m_holdTime;
 326 
 327     // If any of the following are true:
 328     //     1. the animation has no associated timeline, or
 329     //     2. the associated timeline is inactive, or
 330     //     3. the animation&#39;s start time is unresolved.
 331     // The current time is an unresolved time value.
 332     if (!m_timeline || !m_timeline-&gt;currentTime() || !m_startTime)
 333         return WTF::nullopt;
 334 
 335     // Otherwise, current time = (timeline time - start time) * playback rate
 336     return (m_timeline-&gt;currentTime().value() - m_startTime.value()) * m_playbackRate;
 337 }
 338 
 339 ExceptionOr&lt;void&gt; WebAnimation::silentlySetCurrentTime(Optional&lt;Seconds&gt; seekTime)
 340 {
 341     // 3.4.5. Setting the current time of an animation
 342     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 343 
 344     // 1. If seek time is an unresolved time value, then perform the following steps.
 345     if (!seekTime) {
 346         // 1. If the current time is resolved, then throw a TypeError.
 347         if (currentTime())
 348             return Exception { TypeError };
 349         // 2. Abort these steps.
 350         return { };
 351     }
 352 
 353     // 2. Update either animation&#39;s hold time or start time as follows:
 354     // If any of the following conditions are true:
 355     //     - animation&#39;s hold time is resolved, or
 356     //     - animation&#39;s start time is unresolved, or
 357     //     - animation has no associated timeline or the associated timeline is inactive, or
 358     //     - animation&#39;s playback rate is 0,
 359     // Set animation&#39;s hold time to seek time.
 360     // Otherwise, set animation&#39;s start time to the result of evaluating timeline time - (seek time / playback rate)
 361     // where timeline time is the current time value of timeline associated with animation.
 362     if (m_holdTime || !m_startTime || !m_timeline || !m_timeline-&gt;currentTime() || !m_playbackRate)
 363         m_holdTime = seekTime;
 364     else
 365         m_startTime = m_timeline-&gt;currentTime().value() - (seekTime.value() / m_playbackRate);
 366 
 367     // 3. If animation has no associated timeline or the associated timeline is inactive, make animation&#39;s start time unresolved.
 368     if (!m_timeline || !m_timeline-&gt;currentTime())
 369         m_startTime = WTF::nullopt;
 370 
 371     // 4. Make animation&#39;s previous current time unresolved.
 372     m_previousCurrentTime = WTF::nullopt;
 373 
 374     return { };
 375 }
 376 
 377 ExceptionOr&lt;void&gt; WebAnimation::setCurrentTime(Optional&lt;Seconds&gt; seekTime)
 378 {
 379     // 3.4.5. Setting the current time of an animation
 380     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 381 
 382     // 1. Run the steps to silently set the current time of animation to seek time.
 383     auto silentResult = silentlySetCurrentTime(seekTime);
 384     if (silentResult.hasException())
 385         return silentResult.releaseException();
 386 
 387     // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:
 388     if (hasPendingPauseTask()) {
 389         // 1. Set animation&#39;s hold time to seek time.
 390         m_holdTime = seekTime;
 391         // 2. Apply any pending playback rate to animation.
 392         applyPendingPlaybackRate();
 393         // 3. Make animation&#39;s start time unresolved.
 394         m_startTime = WTF::nullopt;
 395         // 4. Cancel the pending pause task.
 396         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 397         // 5. Resolve animation&#39;s current ready promise with animation.
 398         m_readyPromise-&gt;resolve(*this);
 399     }
 400 
 401     // 3. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
 402     timingDidChange(DidSeek::Yes, SynchronouslyNotify::No);
 403 
 404     if (m_effect)
 405         m_effect-&gt;animationDidSeek();
 406 
 407     invalidateEffect();
 408 
 409     return { };
 410 }
 411 
 412 double WebAnimation::effectivePlaybackRate() const
 413 {
 414     // https://drafts.csswg.org/web-animations/#effective-playback-rate
 415     // The effective playback rate of an animation is its pending playback rate, if set, otherwise it is the animation&#39;s playback rate.
 416     return (m_pendingPlaybackRate ? m_pendingPlaybackRate.value() : m_playbackRate);
 417 }
 418 
 419 void WebAnimation::setPlaybackRate(double newPlaybackRate)
 420 {
 421     // 3.4.17.1. Updating the playback rate of an animation
 422     // https://drafts.csswg.org/web-animations-1/#updating-the-playback-rate-of-an-animation
 423 
 424     // 1. Clear any pending playback rate on animation.
 425     m_pendingPlaybackRate = WTF::nullopt;
 426 
 427     // 2. Let previous time be the value of the current time of animation before changing the playback rate.
 428     auto previousTime = currentTime();
 429 
 430     // 3. Set the playback rate to new playback rate.
 431     m_playbackRate = newPlaybackRate;
 432 
 433     // 4. If previous time is resolved, set the current time of animation to previous time.
 434     if (previousTime)
 435         setCurrentTime(previousTime);
 436 }
 437 
 438 void WebAnimation::updatePlaybackRate(double newPlaybackRate)
 439 {
 440     // https://drafts.csswg.org/web-animations/#seamlessly-update-the-playback-rate
 441 
 442     // The procedure to seamlessly update the playback rate an animation, animation, to new playback rate preserving its current time is as follows:
 443 
 444     // 1. Let previous play state be animation&#39;s play state.
 445     //    Note: It is necessary to record the play state before updating animation&#39;s effective playback rate since, in the following logic,
 446     //    we want to immediately apply the pending playback rate of animation if it is currently finished regardless of whether or not it will
 447     //    still be finished after we apply the pending playback rate.
 448     auto previousPlayState = playState();
 449 
 450     // 2. Let animation&#39;s pending playback rate be new playback rate.
 451     m_pendingPlaybackRate = newPlaybackRate;
 452 
 453     // 3. Perform the steps corresponding to the first matching condition from below:
 454     if (pending()) {
 455         // If animation has a pending play task or a pending pause task,
 456         // Abort these steps.
 457         // Note: The different types of pending tasks will apply the pending playback rate when they run so there is no further action required in this case.
 458         return;
 459     }
 460 
 461     if (previousPlayState == PlayState::Idle || previousPlayState == PlayState::Paused) {
 462         // If previous play state is idle or paused,
 463         // Apply any pending playback rate on animation.
 464         applyPendingPlaybackRate();
 465     } else if (previousPlayState == PlayState::Finished) {
 466         // If previous play state is finished,
 467         // 1. Let the unconstrained current time be the result of calculating the current time of animation substituting an unresolved time value for the hold time.
 468         auto unconstrainedCurrentTime = currentTime(RespectHoldTime::No);
 469         // 2. Let animation&#39;s start time be the result of evaluating the following expression:
 470         // timeline time - (unconstrained current time / pending playback rate)
 471         // Where timeline time is the current time value of the timeline associated with animation.
 472         // If pending playback rate is zero, let animation&#39;s start time be timeline time.
 473         auto newStartTime = m_timeline-&gt;currentTime().value();
 474         if (m_pendingPlaybackRate)
 475             newStartTime -= (unconstrainedCurrentTime.value() / m_pendingPlaybackRate.value());
 476         m_startTime = newStartTime;
 477         // 3. Apply any pending playback rate on animation.
 478         applyPendingPlaybackRate();
 479         // 4. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 480         timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 481 
 482         invalidateEffect();
 483     } else {
 484         // Otherwise,
 485         // Run the procedure to play an animation for animation with the auto-rewind flag set to false.
 486         play(AutoRewind::No);
 487     }
 488 }
 489 
 490 void WebAnimation::applyPendingPlaybackRate()
 491 {
 492     // https://drafts.csswg.org/web-animations/#apply-any-pending-playback-rate
 493 
 494     // 1. If animation does not have a pending playback rate, abort these steps.
 495     if (!m_pendingPlaybackRate)
 496         return;
 497 
 498     // 2. Set animation&#39;s playback rate to its pending playback rate.
 499     m_playbackRate = m_pendingPlaybackRate.value();
 500 
 501     // 3. Clear animation&#39;s pending playback rate.
 502     m_pendingPlaybackRate = WTF::nullopt;
 503 }
 504 
 505 auto WebAnimation::playState() const -&gt; PlayState
 506 {
 507     // 3.5.19 Play states
 508     // https://drafts.csswg.org/web-animations/#play-states
 509 
 510     // The play state of animation, animation, at a given moment is the state corresponding to the
 511     // first matching condition from the following:
 512 
 513     // The current time of animation is unresolved, and animation does not have either a pending
 514     // play task or a pending pause task,
 515     // → idle
 516     auto animationCurrentTime = currentTime();
 517     if (!animationCurrentTime &amp;&amp; !pending())
 518         return PlayState::Idle;
 519 
 520     // Animation has a pending pause task, or both the start time of animation is unresolved and it does not
 521     // have a pending play task,
 522     // → paused
 523     if (hasPendingPauseTask() || (!m_startTime &amp;&amp; !hasPendingPlayTask()))
 524         return PlayState::Paused;
 525 
 526     // For animation, current time is resolved and either of the following conditions are true:
 527     // animation&#39;s effective playback rate &gt; 0 and current time ≥ target effect end; or
 528     // animation&#39;s effective playback rate &lt; 0 and current time ≤ 0,
 529     // → finished
<a name="3" id="anc3"></a><span class="line-modified"> 530     if (animationCurrentTime &amp;&amp; ((effectivePlaybackRate() &gt; 0 &amp;&amp; animationCurrentTime.value() &gt;= effectEndTime()) || (effectivePlaybackRate() &lt; 0 &amp;&amp; animationCurrentTime.value() &lt;= 0_s)))</span>
 531         return PlayState::Finished;
 532 
 533     // Otherwise → running
 534     return PlayState::Running;
 535 }
 536 
 537 Seconds WebAnimation::effectEndTime() const
 538 {
 539     // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
 540     // If the animation has no target effect, the target effect end is zero.
 541     return m_effect ? m_effect-&gt;getBasicTiming().endTime : 0_s;
 542 }
 543 
 544 void WebAnimation::cancel()
 545 {
 546     cancel(Silently::No);
 547     invalidateEffect();
 548 }
 549 
 550 void WebAnimation::cancel(Silently silently)
 551 {
 552     // 3.4.16. Canceling an animation
 553     // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
 554     //
 555     // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
 556     //
 557     // The procedure to cancel an animation for animation is as follows:
 558     //
 559     // 1. If animation&#39;s play state is not idle, perform the following steps:
 560     if (playState() != PlayState::Idle) {
 561         // 1. Run the procedure to reset an animation&#39;s pending tasks on animation.
 562         resetPendingTasks(silently);
 563 
 564         // 2. Reject the current finished promise with a DOMException named &quot;AbortError&quot;.
 565         if (silently == Silently::No &amp;&amp; !m_finishedPromise-&gt;isFulfilled())
 566             m_finishedPromise-&gt;reject(Exception { AbortError });
 567 
 568         // 3. Let current finished promise be a new (pending) Promise object.
 569         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 570 
 571         // 4. Create an AnimationPlaybackEvent, cancelEvent.
 572         // 5. Set cancelEvent&#39;s type attribute to cancel.
 573         // 6. Set cancelEvent&#39;s currentTime to null.
 574         // 7. Let timeline time be the current time of the timeline with which animation is associated. If animation is not associated with an
 575         //    active timeline, let timeline time be n unresolved time value.
 576         // 8. Set cancelEvent&#39;s timelineTime to timeline time. If timeline time is unresolved, set it to null.
 577         // 9. If animation has a document for timing, then append cancelEvent to its document for timing&#39;s pending animation event queue along
 578         //    with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 579         //    to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 580         //    scheduled event time is an unresolved time value.
 581         // Otherwise, queue a task to dispatch cancelEvent at animation. The task source for this task is the DOM manipulation task source.
 582         if (silently == Silently::No)
 583             enqueueAnimationPlaybackEvent(eventNames().cancelEvent, WTF::nullopt, m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 584     }
 585 
 586     // 2. Make animation&#39;s hold time unresolved.
 587     m_holdTime = WTF::nullopt;
 588 
 589     // 3. Make animation&#39;s start time unresolved.
 590     m_startTime = WTF::nullopt;
 591 
 592     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 593 
 594     invalidateEffect();
 595 }
 596 
<a name="4" id="anc4"></a><span class="line-modified"> 597 void WebAnimation::enqueueAnimationPlaybackEvent(const AtomicString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)</span>
 598 {
 599     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime);
 600     event-&gt;setTarget(this);
 601 
 602     if (is&lt;DocumentTimeline&gt;(m_timeline)) {
 603         // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
 604         // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 605         // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 606         // scheduled event time is an unresolved time value.
 607         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationPlaybackEvent(WTFMove(event));
 608     } else {
 609         // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
 610         callOnMainThread([this, pendingActivity = makePendingActivity(*this), event = WTFMove(event)]() {
 611             if (!m_isStopped)
 612                 this-&gt;dispatchEvent(event);
 613         });
 614     }
 615 }
 616 
 617 void WebAnimation::resetPendingTasks(Silently silently)
 618 {
 619     // The procedure to reset an animation&#39;s pending tasks for animation is as follows:
 620     // https://drafts.csswg.org/web-animations-1/#reset-an-animations-pending-tasks
 621     //
 622     // 1. If animation does not have a pending play task or a pending pause task, abort this procedure.
 623     if (!pending())
 624         return;
 625 
 626     // 2. If animation has a pending play task, cancel that task.
 627     if (hasPendingPlayTask())
 628         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 629 
 630     // 3. If animation has a pending pause task, cancel that task.
 631     if (hasPendingPauseTask())
 632         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 633 
 634     // 4. Apply any pending playback rate on animation.
 635     applyPendingPlaybackRate();
 636 
 637     // 5. Reject animation&#39;s current ready promise with a DOMException named &quot;AbortError&quot;.
 638     if (silently == Silently::No)
 639         m_readyPromise-&gt;reject(Exception { AbortError });
 640 
 641     // 6. Let animation&#39;s current ready promise be the result of creating a new resolved Promise object.
 642     m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 643     m_readyPromise-&gt;resolve(*this);
 644 }
 645 
 646 ExceptionOr&lt;void&gt; WebAnimation::finish()
 647 {
 648     // 3.4.15. Finishing an animation
 649     // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
 650 
 651     // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
 652     //
 653     // 1. If animation&#39;s effective playback rate is zero, or if animation&#39;s effective playback rate &gt; 0 and target effect end is infinity, throw an InvalidStateError and abort these steps.
 654     if (!effectivePlaybackRate() || (effectivePlaybackRate() &gt; 0 &amp;&amp; effectEndTime() == Seconds::infinity()))
 655         return Exception { InvalidStateError };
 656 
 657     // 2. Apply any pending playback rate to animation.
 658     applyPendingPlaybackRate();
 659 
 660     // 3. Set limit as follows:
 661     // If animation playback rate &gt; 0, let limit be target effect end.
 662     // Otherwise, let limit be zero.
 663     auto limit = m_playbackRate &gt; 0 ? effectEndTime() : 0_s;
 664 
 665     // 4. Silently set the current time to limit.
 666     silentlySetCurrentTime(limit);
 667 
 668     // 5. If animation&#39;s start time is unresolved and animation has an associated active timeline, let the start time be the result of
 669     //    evaluating timeline time - (limit / playback rate) where timeline time is the current time value of the associated timeline.
 670     if (!m_startTime &amp;&amp; m_timeline &amp;&amp; m_timeline-&gt;currentTime())
 671         m_startTime = m_timeline-&gt;currentTime().value() - (limit / m_playbackRate);
 672 
 673     // 6. If there is a pending pause task and start time is resolved,
 674     if (hasPendingPauseTask() &amp;&amp; m_startTime) {
 675         // 1. Let the hold time be unresolved.
 676         m_holdTime = WTF::nullopt;
 677         // 2. Cancel the pending pause task.
 678         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 679         // 3. Resolve the current ready promise of animation with animation.
 680         m_readyPromise-&gt;resolve(*this);
 681     }
 682 
 683     // 7. If there is a pending play task and start time is resolved, cancel that task and resolve the current ready promise of animation with animation.
 684     if (hasPendingPlayTask() &amp;&amp; m_startTime) {
 685         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 686         m_readyPromise-&gt;resolve(*this);
 687     }
 688 
 689     // 8. Run the procedure to update an animation&#39;s finished state animation with the did seek flag set to true, and the synchronously notify flag set to true.
 690     timingDidChange(DidSeek::Yes, SynchronouslyNotify::Yes);
 691 
 692     invalidateEffect();
 693 
 694     return { };
 695 }
 696 
 697 void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
 698 {
 699     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
 700     updateFinishedState(didSeek, synchronouslyNotify);
 701     if (m_timeline)
 702         m_timeline-&gt;animationTimingDidChange(*this);
 703 };
 704 
 705 void WebAnimation::invalidateEffect()
 706 {
 707     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)
 708         m_effect-&gt;invalidate();
 709 }
 710 
 711 void WebAnimation::updateFinishedState(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
 712 {
 713     // 3.4.14. Updating the finished state
 714     // https://drafts.csswg.org/web-animations-1/#updating-the-finished-state
 715 
 716     // 1. Let the unconstrained current time be the result of calculating the current time substituting an unresolved time value
 717     // for the hold time if did seek is false. If did seek is true, the unconstrained current time is equal to the current time.
 718     auto unconstrainedCurrentTime = currentTime(didSeek == DidSeek::Yes ? RespectHoldTime::Yes : RespectHoldTime::No);
 719     auto endTime = effectEndTime();
 720 
 721     // 2. If all three of the following conditions are true,
 722     //    - the unconstrained current time is resolved, and
 723     //    - animation&#39;s start time is resolved, and
 724     //    - animation does not have a pending play task or a pending pause task,
 725     if (unconstrainedCurrentTime &amp;&amp; m_startTime &amp;&amp; !pending()) {
 726         // then update animation&#39;s hold time based on the first matching condition for animation from below, if any:
 727         if (m_playbackRate &gt; 0 &amp;&amp; unconstrainedCurrentTime &gt;= endTime) {
 728             // If animation playback rate &gt; 0 and unconstrained current time is greater than or equal to target effect end,
 729             // If did seek is true, let the hold time be the value of unconstrained current time.
 730             if (didSeek == DidSeek::Yes)
 731                 m_holdTime = unconstrainedCurrentTime;
 732             // If did seek is false, let the hold time be the maximum value of previous current time and target effect end. If the previous current time is unresolved, let the hold time be target effect end.
 733             else if (!m_previousCurrentTime)
 734                 m_holdTime = endTime;
 735             else
 736                 m_holdTime = std::max(m_previousCurrentTime.value(), endTime);
 737         } else if (m_playbackRate &lt; 0 &amp;&amp; unconstrainedCurrentTime &lt;= 0_s) {
 738             // If animation playback rate &lt; 0 and unconstrained current time is less than or equal to 0,
 739             // If did seek is true, let the hold time be the value of unconstrained current time.
 740             if (didSeek == DidSeek::Yes)
 741                 m_holdTime = unconstrainedCurrentTime;
 742             // If did seek is false, let the hold time be the minimum value of previous current time and zero. If the previous current time is unresolved, let the hold time be zero.
 743             else if (!m_previousCurrentTime)
 744                 m_holdTime = 0_s;
 745             else
 746                 m_holdTime = std::min(m_previousCurrentTime.value(), 0_s);
 747         } else if (m_playbackRate &amp;&amp; m_timeline &amp;&amp; m_timeline-&gt;currentTime()) {
 748             // If animation playback rate ≠ 0, and animation is associated with an active timeline,
 749             // Perform the following steps:
 750             // 1. If did seek is true and the hold time is resolved, let animation&#39;s start time be equal to the result of evaluating timeline time - (hold time / playback rate)
 751             //    where timeline time is the current time value of timeline associated with animation.
 752             if (didSeek == DidSeek::Yes &amp;&amp; m_holdTime)
 753                 m_startTime = m_timeline-&gt;currentTime().value() - (m_holdTime.value() / m_playbackRate);
 754             // 2. Let the hold time be unresolved.
 755             m_holdTime = WTF::nullopt;
 756         }
 757     }
 758 
 759     // 3. Set the previous current time of animation be the result of calculating its current time.
 760     m_previousCurrentTime = currentTime();
 761 
 762     // 4. Let current finished state be true if the play state of animation is finished. Otherwise, let it be false.
 763     auto currentFinishedState = playState() == PlayState::Finished;
 764 
 765     // 5. If current finished state is true and the current finished promise is not yet resolved, perform the following steps:
 766     if (currentFinishedState &amp;&amp; !m_finishedPromise-&gt;isFulfilled()) {
 767         if (synchronouslyNotify == SynchronouslyNotify::Yes) {
 768             // If synchronously notify is true, cancel any queued microtask to run the finish notification steps for this animation,
 769             // and run the finish notification steps immediately.
 770             m_finishNotificationStepsMicrotaskPending = false;
 771             finishNotificationSteps();
 772         } else if (!m_finishNotificationStepsMicrotaskPending) {
 773             // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
 774             // is already a microtask queued to run those steps for animation.
 775             m_finishNotificationStepsMicrotaskPending = true;
<a name="5" id="anc5"></a><span class="line-modified"> 776             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([this, protectedThis = makeRef(*this)] () {</span>
 777                 if (m_finishNotificationStepsMicrotaskPending) {
 778                     m_finishNotificationStepsMicrotaskPending = false;
 779                     finishNotificationSteps();
 780                 }
 781             }));
 782         }
 783     }
 784 
 785     // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
 786     // finished promise to a new (pending) Promise object.
 787     if (!currentFinishedState &amp;&amp; m_finishedPromise-&gt;isFulfilled())
 788         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 789 
 790     updateRelevance();
 791 }
 792 
 793 void WebAnimation::finishNotificationSteps()
 794 {
 795     // 3.4.14. Updating the finished state
 796     // https://drafts.csswg.org/web-animations-1/#finish-notification-steps
 797 
 798     // Let finish notification steps refer to the following procedure:
 799     // 1. If animation&#39;s play state is not equal to finished, abort these steps.
 800     if (playState() != PlayState::Finished)
 801         return;
 802 
 803     // 2. Resolve animation&#39;s current finished promise object with animation.
 804     m_finishedPromise-&gt;resolve(*this);
 805 
 806     // 3. Create an AnimationPlaybackEvent, finishEvent.
 807     // 4. Set finishEvent&#39;s type attribute to finish.
 808     // 5. Set finishEvent&#39;s currentTime attribute to the current time of animation.
 809     // 6. Set finishEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.
 810     //    If animation is not associated with a timeline, or the timeline is inactive, let timelineTime be null.
 811     // 7. If animation has a document for timing, then append finishEvent to its document for timing&#39;s pending animation event
 812     //    queue along with its target, animation. For the scheduled event time, use the result of converting animation&#39;s target
 813     //    effect end to an origin-relative time.
 814     //    Otherwise, queue a task to dispatch finishEvent at animation. The task source for this task is the DOM manipulation task source.
 815     enqueueAnimationPlaybackEvent(eventNames().finishEvent, currentTime(), m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 816 }
 817 
 818 ExceptionOr&lt;void&gt; WebAnimation::play()
 819 {
 820     return play(AutoRewind::Yes);
 821 }
 822 
 823 ExceptionOr&lt;void&gt; WebAnimation::play(AutoRewind autoRewind)
 824 {
 825     // 3.4.10. Playing an animation
 826     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 827 
 828     auto localTime = currentTime();
 829     auto endTime = effectEndTime();
 830 
 831     // 1. Let aborted pause be a boolean flag that is true if animation has a pending pause task, and false otherwise.
 832     bool abortedPause = hasPendingPauseTask();
 833 
 834     // 2. Let has pending ready promise be a boolean flag that is initially false.
 835     bool hasPendingReadyPromise = false;
 836 
 837     // 3. Perform the steps corresponding to the first matching condition from the following, if any:
 838     if (effectivePlaybackRate() &gt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt; 0_s || localTime.value() &gt;= endTime)) {
 839         // If animation&#39;s effective playback rate &gt; 0, the auto-rewind flag is true and either animation&#39;s:
 840         //     - current time is unresolved, or
 841         //     - current time &lt; zero, or
 842         //     - current time ≥ target effect end,
 843         // Set animation&#39;s hold time to zero.
 844         m_holdTime = 0_s;
 845     } else if (effectivePlaybackRate() &lt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt;= 0_s || localTime.value() &gt; endTime)) {
 846         // If animation&#39;s effective playback rate &lt; 0, the auto-rewind flag is true and either animation&#39;s:
 847         //     - current time is unresolved, or
 848         //     - current time ≤ zero, or
 849         //     - current time &gt; target effect end
 850         // If target effect end is positive infinity, throw an InvalidStateError and abort these steps.
 851         if (endTime == Seconds::infinity())
 852             return Exception { InvalidStateError };
 853         m_holdTime = endTime;
 854     } else if (!effectivePlaybackRate() &amp;&amp; !localTime) {
 855         // If animation&#39;s effective playback rate = 0 and animation&#39;s current time is unresolved,
 856         // Set animation&#39;s hold time to zero.
 857         m_holdTime = 0_s;
 858     }
 859 
 860     // 4. If animation has a pending play task or a pending pause task,
 861     if (pending()) {
 862         // 1. Cancel that task.
 863         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 864         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 865         // 2. Set has pending ready promise to true.
 866         hasPendingReadyPromise = true;
 867     }
 868 
 869     // 5. If the following three conditions are all satisfied:
 870     //    - animation&#39;s hold time is unresolved, and
 871     //    - aborted pause is false, and
 872     //    - animation does not have a pending playback rate,
 873     // abort this procedure.
 874     if (!m_holdTime &amp;&amp; !abortedPause &amp;&amp; !m_pendingPlaybackRate)
 875         return { };
 876 
 877     // 6. If animation&#39;s hold time is resolved, let its start time be unresolved.
 878     if (m_holdTime)
 879         m_startTime = WTF::nullopt;
 880 
 881     // 7. If has pending ready promise is false, let animation&#39;s current ready promise be a new (pending) Promise object.
 882     if (!hasPendingReadyPromise)
 883         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 884 
 885     // 8. Schedule a task to run as soon as animation is ready.
 886     m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 887 
 888     // 9. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 889     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 890 
 891     invalidateEffect();
 892 
 893     return { };
 894 }
 895 
 896 void WebAnimation::runPendingPlayTask()
 897 {
 898     // 3.4.10. Playing an animation, step 8.
 899     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 900 
 901     m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 902 
 903     // 1. Assert that at least one of animation&#39;s start time or hold time is resolved.
 904     ASSERT(m_startTime || m_holdTime);
 905 
 906     // 2. Let ready time be the time value of the timeline associated with animation at the moment when animation became ready.
 907     auto readyTime = m_timeline-&gt;currentTime();
 908 
 909     // 3. Perform the steps corresponding to the first matching condition below, if any:
 910     if (m_holdTime) {
 911         // If animation&#39;s hold time is resolved,
 912         // 1. Apply any pending playback rate on animation.
 913         applyPendingPlaybackRate();
 914         // 2. Let new start time be the result of evaluating ready time - hold time / animation playback rate for animation.
 915         // If the animation playback rate is zero, let new start time be simply ready time.
 916         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
 917         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
 918         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
 919         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
 920         auto newStartTime = readyTime.valueOr(0_s);
 921         if (m_playbackRate)
 922             newStartTime -= m_holdTime.value() / m_playbackRate;
 923         // 3. Set the start time of animation to new start time.
 924         m_startTime = newStartTime;
 925         // 4. If animation&#39;s playback rate is not 0, make animation&#39;s hold time unresolved.
 926         if (m_playbackRate)
 927             m_holdTime = WTF::nullopt;
 928     } else if (m_startTime &amp;&amp; m_pendingPlaybackRate) {
 929         // If animation&#39;s start time is resolved and animation has a pending playback rate,
 930         // 1. Let current time to match be the result of evaluating (ready time - start time) × playback rate for animation.
 931         auto currentTimeToMatch = (readyTime.valueOr(0_s) - m_startTime.value()) * m_playbackRate;
 932         // 2. Apply any pending playback rate on animation.
 933         applyPendingPlaybackRate();
 934         // 3. If animation&#39;s playback rate is zero, let animation&#39;s hold time be current time to match.
 935         if (m_playbackRate)
 936             m_holdTime = currentTimeToMatch;
 937         // 4. Let new start time be the result of evaluating ready time - current time to match / playback rate for animation.
 938         // If the playback rate is zero, let new start time be simply ready time.
 939         auto newStartTime = readyTime.valueOr(0_s);
 940         if (m_playbackRate)
 941             newStartTime -= currentTimeToMatch / m_playbackRate;
 942         // 5. Set the start time of animation to new start time.
 943         m_startTime = newStartTime;
 944     }
 945 
 946     // 4. Resolve animation&#39;s current ready promise with animation.
 947     if (!m_readyPromise-&gt;isFulfilled())
 948         m_readyPromise-&gt;resolve(*this);
 949 
 950     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 951     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 952 
 953     invalidateEffect();
 954 }
 955 
 956 ExceptionOr&lt;void&gt; WebAnimation::pause()
 957 {
 958     // 3.4.11. Pausing an animation
 959     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
 960 
 961     // 1. If animation has a pending pause task, abort these steps.
 962     if (hasPendingPauseTask())
 963         return { };
 964 
 965     // 2. If the play state of animation is paused, abort these steps.
 966     if (playState() == PlayState::Paused)
 967         return { };
 968 
 969     auto localTime = currentTime();
 970 
 971     // 3. If the animation&#39;s current time is unresolved, perform the steps according to the first matching condition from below:
 972     if (!localTime) {
 973         if (m_playbackRate &gt;= 0) {
 974             // If animation&#39;s playback rate is ≥ 0, let animation&#39;s hold time be zero.
 975             m_holdTime = 0_s;
 976         } else if (effectEndTime() == Seconds::infinity()) {
 977             // Otherwise, if target effect end for animation is positive infinity, throw an InvalidStateError and abort these steps.
 978             return Exception { InvalidStateError };
 979         } else {
 980             // Otherwise, let animation&#39;s hold time be target effect end.
 981             m_holdTime = effectEndTime();
 982         }
 983     }
 984 
 985     // 4. Let has pending ready promise be a boolean flag that is initially false.
 986     bool hasPendingReadyPromise = false;
 987 
 988     // 5. If animation has a pending play task, cancel that task and let has pending ready promise be true.
 989     if (hasPendingPlayTask()) {
 990         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 991         hasPendingReadyPromise = true;
 992     }
 993 
 994     // 6. If has pending ready promise is false, set animation&#39;s current ready promise to a new (pending) Promise object.
 995     if (!hasPendingReadyPromise)
 996         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 997 
 998     // 7. Schedule a task to be executed at the first possible moment after the user agent has performed any processing necessary
 999     //    to suspend the playback of animation&#39;s target effect, if any.
1000     m_timeToRunPendingPauseTask = TimeToRunPendingTask::ASAP;
1001 
1002     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
1003     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
1004 
1005     invalidateEffect();
1006 
1007     return { };
1008 }
1009 
1010 ExceptionOr&lt;void&gt; WebAnimation::reverse()
1011 {
1012     // 3.4.18. Reversing an animation
1013     // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
1014 
1015     // The procedure to reverse an animation of animation animation is as follows:
1016 
1017     // 1. If there is no timeline associated with animation, or the associated timeline is inactive
1018     //    throw an InvalidStateError and abort these steps.
1019     if (!m_timeline || !m_timeline-&gt;currentTime())
1020         return Exception { InvalidStateError };
1021 
1022     // 2. Let original pending playback rate be animation&#39;s pending playback rate.
1023     auto originalPendingPlaybackRate = m_pendingPlaybackRate;
1024 
1025     // 3. Let animation&#39;s pending playback rate be the additive inverse of its effective playback rate (i.e. -effective playback rate).
1026     m_pendingPlaybackRate = -effectivePlaybackRate();
1027 
1028     // 4. Run the steps to play an animation for animation with the auto-rewind flag set to true.
1029     auto playResult = play(AutoRewind::Yes);
1030 
1031     // If the steps to play an animation throw an exception, set animation&#39;s pending playback rate to original
1032     // pending playback rate and propagate the exception.
1033     if (playResult.hasException()) {
1034         m_pendingPlaybackRate = originalPendingPlaybackRate;
1035         return playResult.releaseException();
1036     }
1037 
1038     return { };
1039 }
1040 
1041 void WebAnimation::runPendingPauseTask()
1042 {
1043     // 3.4.11. Pausing an animation, step 7.
1044     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1045 
1046     m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
1047 
1048     // 1. Let ready time be the time value of the timeline associated with animation at the moment when the user agent
1049     //    completed processing necessary to suspend playback of animation&#39;s target effect.
1050     auto readyTime = m_timeline-&gt;currentTime();
1051     auto animationStartTime = m_startTime;
1052 
1053     // 2. If animation&#39;s start time is resolved and its hold time is not resolved, let animation&#39;s hold time be the result of
1054     //    evaluating (ready time - start time) × playback rate.
1055     //    Note: The hold time might be already set if the animation is finished, or if the animation is pending, waiting to begin
1056     //    playback. In either case we want to preserve the hold time as we enter the paused state.
1057     if (animationStartTime &amp;&amp; !m_holdTime) {
1058         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1059         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
1060         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
1061         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
1062         m_holdTime = (readyTime.valueOr(0_s) - animationStartTime.value()) * m_playbackRate;
1063     }
1064 
1065     // 3. Apply any pending playback rate on animation.
1066     applyPendingPlaybackRate();
1067 
1068     // 4. Make animation&#39;s start time unresolved.
1069     m_startTime = WTF::nullopt;
1070 
1071     // 5. Resolve animation&#39;s current ready promise with animation.
1072     if (!m_readyPromise-&gt;isFulfilled())
1073         m_readyPromise-&gt;resolve(*this);
1074 
1075     // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
1076     //    synchronously notify flag set to false.
1077     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
1078 
1079     invalidateEffect();
1080 }
1081 
1082 bool WebAnimation::isRunningAccelerated() const
1083 {
1084     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
1085 }
1086 
1087 bool WebAnimation::needsTick() const
1088 {
1089     return pending() || playState() == PlayState::Running;
1090 }
1091 
1092 void WebAnimation::tick()
1093 {
1094     updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1095     m_shouldSkipUpdatingFinishedStateWhenResolving = true;
1096 
1097     // Run pending tasks, if any.
1098     if (hasPendingPauseTask())
1099         runPendingPauseTask();
1100     if (hasPendingPlayTask())
1101         runPendingPlayTask();
1102 
1103     invalidateEffect();
1104 }
1105 
1106 void WebAnimation::resolve(RenderStyle&amp; targetStyle)
1107 {
1108     if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
1109         updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1110     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
1111 
1112     if (m_effect)
1113         m_effect-&gt;apply(targetStyle);
1114 }
1115 
1116 void WebAnimation::setSuspended(bool isSuspended)
1117 {
1118     if (m_isSuspended == isSuspended)
1119         return;
1120 
1121     m_isSuspended = isSuspended;
1122 
1123     if (m_effect &amp;&amp; playState() == PlayState::Running)
1124         m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
1125 }
1126 
1127 void WebAnimation::acceleratedStateDidChange()
1128 {
1129     if (is&lt;DocumentTimeline&gt;(m_timeline))
1130         downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
1131 }
1132 
1133 void WebAnimation::applyPendingAcceleratedActions()
1134 {
1135     if (is&lt;KeyframeEffect&gt;(m_effect))
1136         downcast&lt;KeyframeEffect&gt;(*m_effect).applyPendingAcceleratedActions();
1137 }
1138 
1139 WebAnimation&amp; WebAnimation::readyPromiseResolve()
1140 {
1141     return *this;
1142 }
1143 
1144 WebAnimation&amp; WebAnimation::finishedPromiseResolve()
1145 {
1146     return *this;
1147 }
1148 
1149 const char* WebAnimation::activeDOMObjectName() const
1150 {
1151     return &quot;Animation&quot;;
1152 }
1153 
1154 bool WebAnimation::canSuspendForDocumentSuspension() const
1155 {
<a name="6" id="anc6"></a><span class="line-modified">1156     return !hasPendingActivity();</span>



1157 }
1158 
1159 void WebAnimation::stop()
1160 {
<a name="7" id="anc7"></a>
1161     m_isStopped = true;
1162     removeAllEventListeners();
1163 }
1164 
<a name="8" id="anc8"></a>





1165 void WebAnimation::updateRelevance()
1166 {
1167     m_isRelevant = computeRelevance();
1168 }
1169 
1170 bool WebAnimation::computeRelevance()
1171 {
1172     // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
1173     if (!m_effect)
1174         return false;
1175 
1176     auto timing = m_effect-&gt;getBasicTiming();
1177 
1178     // An animation effect is in effect if its active time is not unresolved.
1179     if (timing.activeTime)
1180         return true;
1181 
1182     // An animation effect is current if either of the following conditions is true:
1183     // - the animation effect is in the before phase, or
1184     // - the animation effect is in play.
1185 
1186     // An animation effect is in play if all of the following conditions are met:
1187     // - the animation effect is in the active phase, and
1188     // - the animation effect is associated with an animation that is not finished.
1189     return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
1190 }
1191 
1192 Seconds WebAnimation::timeToNextTick() const
1193 {
1194     ASSERT(isRunningAccelerated());
1195 
1196     if (pending())
1197         return 0_s;
1198 
1199     // If we&#39;re not running, there&#39;s no telling when we&#39;ll end.
1200     if (playState() != PlayState::Running)
1201         return Seconds::infinity();
1202 
1203     // CSS Animations dispatch events for each iteration, so compute the time until
1204     // the end of this iteration. Any other animation only cares about remaning total time.
1205     if (isCSSAnimation()) {
1206         auto* animationEffect = effect();
1207         auto timing = animationEffect-&gt;getComputedTiming();
1208         // If we&#39;re actively running, we need the time until the next iteration.
1209         if (auto iterationProgress = timing.simpleIterationProgress)
1210             return animationEffect-&gt;iterationDuration() * (1 - *iterationProgress);
1211 
1212         // Otherwise we&#39;re probably in the before phase waiting to reach our start time.
1213         if (auto animationCurrentTime = currentTime()) {
1214             // If our current time is negative, we need to be scheduled to be resolved at the inverse
1215             // of our current time, unless we fill backwards, in which case we want to invalidate as
1216             // soon as possible.
1217             auto localTime = animationCurrentTime.value();
1218             if (localTime &lt; 0_s)
1219                 return -localTime;
1220             if (localTime &lt; animationEffect-&gt;delay())
1221                 return animationEffect-&gt;delay() - localTime;
1222         }
1223     } else if (auto animationCurrentTime = currentTime())
1224         return effect()-&gt;getBasicTiming().endTime - *animationCurrentTime;
1225 
1226     ASSERT_NOT_REACHED();
1227     return Seconds::infinity();
1228 }
1229 
1230 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>