<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SpeculatedType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56 static const SpeculatedType SpecTypedArrayView                    = SpecInt8Array | SpecInt16Array | SpecInt32Array | SpecUint8Array | SpecUint8ClampedArray | SpecUint16Array | SpecUint32Array | SpecFloat32Array | SpecFloat64Array;
 57 static const SpeculatedType SpecDirectArguments                   = 1ull &lt;&lt; 13; // It&#39;s definitely a DirectArguments object.
 58 static const SpeculatedType SpecScopedArguments                   = 1ull &lt;&lt; 14; // It&#39;s definitely a ScopedArguments object.
 59 static const SpeculatedType SpecStringObject                      = 1ull &lt;&lt; 15; // It&#39;s definitely a StringObject.
 60 static const SpeculatedType SpecRegExpObject                      = 1ull &lt;&lt; 16; // It&#39;s definitely a RegExpObject (and not any subclass of RegExpObject).
 61 static const SpeculatedType SpecMapObject                         = 1ull &lt;&lt; 17; // It&#39;s definitely a Map object or one of its subclasses.
 62 static const SpeculatedType SpecSetObject                         = 1ull &lt;&lt; 18; // It&#39;s definitely a Set object or one of its subclasses.
 63 static const SpeculatedType SpecWeakMapObject                     = 1ull &lt;&lt; 19; // It&#39;s definitely a WeakMap object or one of its subclasses.
 64 static const SpeculatedType SpecWeakSetObject                     = 1ull &lt;&lt; 20; // It&#39;s definitely a WeakSet object or one of its subclasses.
 65 static const SpeculatedType SpecProxyObject                       = 1ull &lt;&lt; 21; // It&#39;s definitely a Proxy object or one of its subclasses.
 66 static const SpeculatedType SpecDerivedArray                      = 1ull &lt;&lt; 22; // It&#39;s definitely a DerivedArray object.
 67 static const SpeculatedType SpecObjectOther                       = 1ull &lt;&lt; 23; // It&#39;s definitely an object but not JSFinalObject, JSArray, or JSFunction.
 68 static const SpeculatedType SpecStringIdent                       = 1ull &lt;&lt; 24; // It&#39;s definitely a JSString, and it&#39;s an identifier.
 69 static const SpeculatedType SpecStringVar                         = 1ull &lt;&lt; 25; // It&#39;s definitely a JSString, and it&#39;s not an identifier.
 70 static const SpeculatedType SpecString                            = SpecStringIdent | SpecStringVar; // It&#39;s definitely a JSString.
 71 static const SpeculatedType SpecSymbol                            = 1ull &lt;&lt; 26; // It&#39;s definitely a Symbol.
 72 static const SpeculatedType SpecCellOther                         = 1ull &lt;&lt; 27; // It&#39;s definitely a JSCell but not a subclass of JSObject and definitely not a JSString, BigInt, or Symbol.
 73 static const SpeculatedType SpecBoolInt32                         = 1ull &lt;&lt; 28; // It&#39;s definitely an Int32 with value 0 or 1.
 74 static const SpeculatedType SpecNonBoolInt32                      = 1ull &lt;&lt; 29; // It&#39;s definitely an Int32 with value other than 0 or 1.
 75 static const SpeculatedType SpecInt32Only                         = SpecBoolInt32 | SpecNonBoolInt32; // It&#39;s definitely an Int32.
<span class="line-modified"> 76 static const SpeculatedType SpecInt52Only                         = 1ull &lt;&lt; 30; // It&#39;s definitely an Int52 and we intend it to unbox it. It&#39;s also definitely not an Int32.</span>
<span class="line-modified"> 77 static const SpeculatedType SpecAnyInt                            = SpecInt32Only | SpecInt52Only; // It&#39;s something that we can do machine int arithmetic on.</span>
<span class="line-modified"> 78 static const SpeculatedType SpecAnyIntAsDouble                    = 1ull &lt;&lt; 31; // It&#39;s definitely an Int52 and it&#39;s inside a double.</span>
<span class="line-modified"> 79 static const SpeculatedType SpecNonIntAsDouble                    = 1ull &lt;&lt; 32; // It&#39;s definitely not an Int52 but it&#39;s a real number and it&#39;s a double.</span>



 80 static const SpeculatedType SpecDoubleReal                        = SpecNonIntAsDouble | SpecAnyIntAsDouble; // It&#39;s definitely a non-NaN double.
<span class="line-modified"> 81 static const SpeculatedType SpecDoublePureNaN                     = 1ull &lt;&lt; 33; // It&#39;s definitely a NaN that is safe to tag (i.e. pure).</span>
<span class="line-modified"> 82 static const SpeculatedType SpecDoubleImpureNaN                   = 1ull &lt;&lt; 34; // It&#39;s definitely a NaN that is unsafe to tag (i.e. impure).</span>
 83 static const SpeculatedType SpecDoubleNaN                         = SpecDoublePureNaN | SpecDoubleImpureNaN; // It&#39;s definitely some kind of NaN.
 84 static const SpeculatedType SpecBytecodeDouble                    = SpecDoubleReal | SpecDoublePureNaN; // It&#39;s either a non-NaN or a NaN double, but it&#39;s definitely not impure NaN.
 85 static const SpeculatedType SpecFullDouble                        = SpecDoubleReal | SpecDoubleNaN; // It&#39;s either a non-NaN or a NaN double.
 86 static const SpeculatedType SpecBytecodeRealNumber                = SpecInt32Only | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal.
<span class="line-modified"> 87 static const SpeculatedType SpecFullRealNumber                    = SpecAnyInt | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal, or a Int52.</span>
 88 static const SpeculatedType SpecBytecodeNumber                    = SpecInt32Only | SpecBytecodeDouble; // It&#39;s either an Int32 or a Double, and the Double cannot be an impure NaN.
<span class="line-modified"> 89 static const SpeculatedType SpecFullNumber                        = SpecAnyInt | SpecFullDouble; // It&#39;s either an Int32, Int52, or a Double, and the Double can be impure NaN.</span>
<span class="line-modified"> 90 static const SpeculatedType SpecBoolean                           = 1ull &lt;&lt; 35; // It&#39;s definitely a Boolean.</span>
<span class="line-modified"> 91 static const SpeculatedType SpecOther                             = 1ull &lt;&lt; 36; // It&#39;s definitely either Null or Undefined.</span>


 92 static const SpeculatedType SpecMisc                              = SpecBoolean | SpecOther; // It&#39;s definitely either a boolean, Null, or Undefined.
<span class="line-modified"> 93 static const SpeculatedType SpecEmpty                             = 1ull &lt;&lt; 37; // It&#39;s definitely an empty value marker.</span>
<span class="line-modified"> 94 static const SpeculatedType SpecBigInt                            = 1ull &lt;&lt; 38; // It&#39;s definitely a BigInt.</span>
<span class="line-modified"> 95 static const SpeculatedType SpecDataViewObject                    = 1ull &lt;&lt; 39; // It&#39;s definitely a JSDataView.</span>
 96 static const SpeculatedType SpecPrimitive                         = SpecString | SpecSymbol | SpecBytecodeNumber | SpecMisc | SpecBigInt; // It&#39;s any non-Object JSValue.
 97 static const SpeculatedType SpecObject                            = SpecFinalObject | SpecArray | SpecFunction | SpecTypedArrayView | SpecDirectArguments | SpecScopedArguments | SpecStringObject | SpecRegExpObject | SpecMapObject | SpecSetObject | SpecWeakMapObject | SpecWeakSetObject | SpecProxyObject | SpecDerivedArray | SpecObjectOther | SpecDataViewObject; // Bitmask used for testing for any kind of object prediction.
 98 static const SpeculatedType SpecCell                              = SpecObject | SpecString | SpecSymbol | SpecCellOther | SpecBigInt; // It&#39;s definitely a JSCell.
 99 static const SpeculatedType SpecHeapTop                           = SpecCell | SpecBytecodeNumber | SpecMisc; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN.
100 static const SpeculatedType SpecBytecodeTop                       = SpecHeapTop | SpecEmpty; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN. Corresponds to what could be found in a bytecode local.
101 static const SpeculatedType SpecFullTop                           = SpecBytecodeTop | SpecFullNumber; // It can be anything that bytecode could see plus exotic encodings of numbers.
102 
103 // SpecCellCheck is the type set representing the values that can flow through a cell check.
104 // On 64-bit platforms, the empty value passes a cell check. Also, ~SpecCellCheck is the type
105 // set that representing the values that flow through when testing that something is not a cell.
106 static const SpeculatedType SpecCellCheck          = is64Bit() ? (SpecCell | SpecEmpty) : SpecCell;
107 
108 typedef bool (*SpeculatedTypeChecker)(SpeculatedType);
109 
110 // Dummy prediction checker, only useful if someone insists on requiring a prediction checker.
111 inline bool isAnySpeculation(SpeculatedType)
112 {
113     return true;
114 }
115 
</pre>
<hr />
<pre>
320     return value == SpecBoolInt32;
321 }
322 
323 inline bool isInt32Speculation(SpeculatedType value)
324 {
325     return value &amp;&amp; !(value &amp; ~SpecInt32Only);
326 }
327 
328 inline bool isNotInt32Speculation(SpeculatedType value)
329 {
330     return value &amp;&amp; !(value &amp; SpecInt32Only);
331 }
332 
333 inline bool isInt32OrBooleanSpeculation(SpeculatedType value)
334 {
335     return value &amp;&amp; !(value &amp; ~(SpecBoolean | SpecInt32Only));
336 }
337 
338 inline bool isInt32SpeculationForArithmetic(SpeculatedType value)
339 {
<span class="line-modified">340     return !(value &amp; (SpecFullDouble | SpecInt52Only));</span>
341 }
342 
343 inline bool isInt32OrBooleanSpeculationForArithmetic(SpeculatedType value)
344 {
<span class="line-modified">345     return !(value &amp; (SpecFullDouble | SpecInt52Only));</span>
346 }
347 
348 inline bool isInt32OrBooleanSpeculationExpectingDefined(SpeculatedType value)
349 {
350     return isInt32OrBooleanSpeculation(value &amp; ~SpecOther);
351 }
352 
<span class="line-modified">353 inline bool isInt52Speculation(SpeculatedType value)</span>





354 {
<span class="line-modified">355     return value == SpecInt52Only;</span>
356 }
357 
<span class="line-modified">358 inline bool isAnyIntSpeculation(SpeculatedType value)</span>
359 {
<span class="line-modified">360     return !!value &amp;&amp; (value &amp; SpecAnyInt) == value;</span>
361 }
362 
363 inline bool isAnyIntAsDoubleSpeculation(SpeculatedType value)
364 {
365     return value == SpecAnyIntAsDouble;
366 }
367 
368 inline bool isDoubleRealSpeculation(SpeculatedType value)
369 {
370     return !!value &amp;&amp; (value &amp; SpecDoubleReal) == value;
371 }
372 
373 inline bool isDoubleSpeculation(SpeculatedType value)
374 {
375     return !!value &amp;&amp; (value &amp; SpecFullDouble) == value;
376 }
377 
378 inline bool isDoubleSpeculationForArithmetic(SpeculatedType value)
379 {
380     return !!(value &amp; SpecFullDouble);
</pre>
<hr />
<pre>
465     return left | right;
466 }
467 
468 template&lt;typename T&gt;
469 inline bool mergeSpeculation(T&amp; left, SpeculatedType right)
470 {
471     SpeculatedType newSpeculation = static_cast&lt;T&gt;(mergeSpeculations(static_cast&lt;SpeculatedType&gt;(left), right));
472     bool result = newSpeculation != static_cast&lt;SpeculatedType&gt;(left);
473     left = newSpeculation;
474     return result;
475 }
476 
477 inline bool speculationChecked(SpeculatedType actual, SpeculatedType desired)
478 {
479     return (actual | desired) == desired;
480 }
481 
482 SpeculatedType speculationFromClassInfo(const ClassInfo*);
483 SpeculatedType speculationFromStructure(Structure*);
484 SpeculatedType speculationFromCell(JSCell*);
<span class="line-modified">485 SpeculatedType speculationFromValue(JSValue);</span>



486 SpeculatedType speculationFromJSType(JSType);
487 
488 SpeculatedType speculationFromTypedArrayType(TypedArrayType); // only valid for typed views.
489 TypedArrayType typedArrayTypeFromSpeculation(SpeculatedType);
490 
491 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType);
492 
493 bool valuesCouldBeEqual(SpeculatedType, SpeculatedType);
494 
495 // Precise computation of the type of the result of a double computation after we
496 // already know that the inputs are doubles and that the result must be a double. Use
497 // the closest one of these that applies.
498 SpeculatedType typeOfDoubleSum(SpeculatedType, SpeculatedType);
499 SpeculatedType typeOfDoubleDifference(SpeculatedType, SpeculatedType);
500 SpeculatedType typeOfDoubleProduct(SpeculatedType, SpeculatedType);
501 SpeculatedType typeOfDoubleQuotient(SpeculatedType, SpeculatedType);
502 SpeculatedType typeOfDoubleMinMax(SpeculatedType, SpeculatedType);
503 SpeculatedType typeOfDoubleNegation(SpeculatedType);
504 SpeculatedType typeOfDoubleAbs(SpeculatedType);
505 SpeculatedType typeOfDoubleRounding(SpeculatedType);
</pre>
</td>
<td>
<hr />
<pre>
 56 static const SpeculatedType SpecTypedArrayView                    = SpecInt8Array | SpecInt16Array | SpecInt32Array | SpecUint8Array | SpecUint8ClampedArray | SpecUint16Array | SpecUint32Array | SpecFloat32Array | SpecFloat64Array;
 57 static const SpeculatedType SpecDirectArguments                   = 1ull &lt;&lt; 13; // It&#39;s definitely a DirectArguments object.
 58 static const SpeculatedType SpecScopedArguments                   = 1ull &lt;&lt; 14; // It&#39;s definitely a ScopedArguments object.
 59 static const SpeculatedType SpecStringObject                      = 1ull &lt;&lt; 15; // It&#39;s definitely a StringObject.
 60 static const SpeculatedType SpecRegExpObject                      = 1ull &lt;&lt; 16; // It&#39;s definitely a RegExpObject (and not any subclass of RegExpObject).
 61 static const SpeculatedType SpecMapObject                         = 1ull &lt;&lt; 17; // It&#39;s definitely a Map object or one of its subclasses.
 62 static const SpeculatedType SpecSetObject                         = 1ull &lt;&lt; 18; // It&#39;s definitely a Set object or one of its subclasses.
 63 static const SpeculatedType SpecWeakMapObject                     = 1ull &lt;&lt; 19; // It&#39;s definitely a WeakMap object or one of its subclasses.
 64 static const SpeculatedType SpecWeakSetObject                     = 1ull &lt;&lt; 20; // It&#39;s definitely a WeakSet object or one of its subclasses.
 65 static const SpeculatedType SpecProxyObject                       = 1ull &lt;&lt; 21; // It&#39;s definitely a Proxy object or one of its subclasses.
 66 static const SpeculatedType SpecDerivedArray                      = 1ull &lt;&lt; 22; // It&#39;s definitely a DerivedArray object.
 67 static const SpeculatedType SpecObjectOther                       = 1ull &lt;&lt; 23; // It&#39;s definitely an object but not JSFinalObject, JSArray, or JSFunction.
 68 static const SpeculatedType SpecStringIdent                       = 1ull &lt;&lt; 24; // It&#39;s definitely a JSString, and it&#39;s an identifier.
 69 static const SpeculatedType SpecStringVar                         = 1ull &lt;&lt; 25; // It&#39;s definitely a JSString, and it&#39;s not an identifier.
 70 static const SpeculatedType SpecString                            = SpecStringIdent | SpecStringVar; // It&#39;s definitely a JSString.
 71 static const SpeculatedType SpecSymbol                            = 1ull &lt;&lt; 26; // It&#39;s definitely a Symbol.
 72 static const SpeculatedType SpecCellOther                         = 1ull &lt;&lt; 27; // It&#39;s definitely a JSCell but not a subclass of JSObject and definitely not a JSString, BigInt, or Symbol.
 73 static const SpeculatedType SpecBoolInt32                         = 1ull &lt;&lt; 28; // It&#39;s definitely an Int32 with value 0 or 1.
 74 static const SpeculatedType SpecNonBoolInt32                      = 1ull &lt;&lt; 29; // It&#39;s definitely an Int32 with value other than 0 or 1.
 75 static const SpeculatedType SpecInt32Only                         = SpecBoolInt32 | SpecNonBoolInt32; // It&#39;s definitely an Int32.
<span class="line-modified"> 76 </span>
<span class="line-modified"> 77 static const SpeculatedType SpecInt32AsInt52                      = 1ull &lt;&lt; 30; // It&#39;s an Int52 and it can fit in an int32.</span>
<span class="line-modified"> 78 static const SpeculatedType SpecNonInt32AsInt52                   = 1ull &lt;&lt; 31; // It&#39;s an Int52 and it can&#39;t fit in an int32.</span>
<span class="line-modified"> 79 static const SpeculatedType SpecInt52Any                          = SpecInt32AsInt52 | SpecNonInt32AsInt52; // It&#39;s any kind of Int52.</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 static const SpeculatedType SpecAnyIntAsDouble                    = 1ull &lt;&lt; 32; // It&#39;s definitely an Int52 and it&#39;s inside a double.</span>
<span class="line-added"> 82 static const SpeculatedType SpecNonIntAsDouble                    = 1ull &lt;&lt; 33; // It&#39;s definitely not an Int52 but it&#39;s a real number and it&#39;s a double.</span>
 83 static const SpeculatedType SpecDoubleReal                        = SpecNonIntAsDouble | SpecAnyIntAsDouble; // It&#39;s definitely a non-NaN double.
<span class="line-modified"> 84 static const SpeculatedType SpecDoublePureNaN                     = 1ull &lt;&lt; 34; // It&#39;s definitely a NaN that is safe to tag (i.e. pure).</span>
<span class="line-modified"> 85 static const SpeculatedType SpecDoubleImpureNaN                   = 1ull &lt;&lt; 35; // It&#39;s definitely a NaN that is unsafe to tag (i.e. impure).</span>
 86 static const SpeculatedType SpecDoubleNaN                         = SpecDoublePureNaN | SpecDoubleImpureNaN; // It&#39;s definitely some kind of NaN.
 87 static const SpeculatedType SpecBytecodeDouble                    = SpecDoubleReal | SpecDoublePureNaN; // It&#39;s either a non-NaN or a NaN double, but it&#39;s definitely not impure NaN.
 88 static const SpeculatedType SpecFullDouble                        = SpecDoubleReal | SpecDoubleNaN; // It&#39;s either a non-NaN or a NaN double.
 89 static const SpeculatedType SpecBytecodeRealNumber                = SpecInt32Only | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal.
<span class="line-modified"> 90 static const SpeculatedType SpecFullRealNumber                    = SpecInt32Only | SpecInt52Any | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal, or an Int52.</span>
 91 static const SpeculatedType SpecBytecodeNumber                    = SpecInt32Only | SpecBytecodeDouble; // It&#39;s either an Int32 or a Double, and the Double cannot be an impure NaN.
<span class="line-modified"> 92 static const SpeculatedType SpecIntAnyFormat                      = SpecInt52Any | SpecInt32Only | SpecAnyIntAsDouble;</span>
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94 static const SpeculatedType SpecFullNumber                        = SpecIntAnyFormat | SpecFullDouble; // It&#39;s either an Int32, Int52, or a Double, and the Double can be impure NaN.</span>
<span class="line-added"> 95 static const SpeculatedType SpecBoolean                           = 1ull &lt;&lt; 36; // It&#39;s definitely a Boolean.</span>
<span class="line-added"> 96 static const SpeculatedType SpecOther                             = 1ull &lt;&lt; 37; // It&#39;s definitely either Null or Undefined.</span>
 97 static const SpeculatedType SpecMisc                              = SpecBoolean | SpecOther; // It&#39;s definitely either a boolean, Null, or Undefined.
<span class="line-modified"> 98 static const SpeculatedType SpecEmpty                             = 1ull &lt;&lt; 38; // It&#39;s definitely an empty value marker.</span>
<span class="line-modified"> 99 static const SpeculatedType SpecBigInt                            = 1ull &lt;&lt; 39; // It&#39;s definitely a BigInt.</span>
<span class="line-modified">100 static const SpeculatedType SpecDataViewObject                    = 1ull &lt;&lt; 40; // It&#39;s definitely a JSDataView.</span>
101 static const SpeculatedType SpecPrimitive                         = SpecString | SpecSymbol | SpecBytecodeNumber | SpecMisc | SpecBigInt; // It&#39;s any non-Object JSValue.
102 static const SpeculatedType SpecObject                            = SpecFinalObject | SpecArray | SpecFunction | SpecTypedArrayView | SpecDirectArguments | SpecScopedArguments | SpecStringObject | SpecRegExpObject | SpecMapObject | SpecSetObject | SpecWeakMapObject | SpecWeakSetObject | SpecProxyObject | SpecDerivedArray | SpecObjectOther | SpecDataViewObject; // Bitmask used for testing for any kind of object prediction.
103 static const SpeculatedType SpecCell                              = SpecObject | SpecString | SpecSymbol | SpecCellOther | SpecBigInt; // It&#39;s definitely a JSCell.
104 static const SpeculatedType SpecHeapTop                           = SpecCell | SpecBytecodeNumber | SpecMisc; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN.
105 static const SpeculatedType SpecBytecodeTop                       = SpecHeapTop | SpecEmpty; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN. Corresponds to what could be found in a bytecode local.
106 static const SpeculatedType SpecFullTop                           = SpecBytecodeTop | SpecFullNumber; // It can be anything that bytecode could see plus exotic encodings of numbers.
107 
108 // SpecCellCheck is the type set representing the values that can flow through a cell check.
109 // On 64-bit platforms, the empty value passes a cell check. Also, ~SpecCellCheck is the type
110 // set that representing the values that flow through when testing that something is not a cell.
111 static const SpeculatedType SpecCellCheck          = is64Bit() ? (SpecCell | SpecEmpty) : SpecCell;
112 
113 typedef bool (*SpeculatedTypeChecker)(SpeculatedType);
114 
115 // Dummy prediction checker, only useful if someone insists on requiring a prediction checker.
116 inline bool isAnySpeculation(SpeculatedType)
117 {
118     return true;
119 }
120 
</pre>
<hr />
<pre>
325     return value == SpecBoolInt32;
326 }
327 
328 inline bool isInt32Speculation(SpeculatedType value)
329 {
330     return value &amp;&amp; !(value &amp; ~SpecInt32Only);
331 }
332 
333 inline bool isNotInt32Speculation(SpeculatedType value)
334 {
335     return value &amp;&amp; !(value &amp; SpecInt32Only);
336 }
337 
338 inline bool isInt32OrBooleanSpeculation(SpeculatedType value)
339 {
340     return value &amp;&amp; !(value &amp; ~(SpecBoolean | SpecInt32Only));
341 }
342 
343 inline bool isInt32SpeculationForArithmetic(SpeculatedType value)
344 {
<span class="line-modified">345     return !(value &amp; (SpecFullDouble | SpecNonInt32AsInt52));</span>
346 }
347 
348 inline bool isInt32OrBooleanSpeculationForArithmetic(SpeculatedType value)
349 {
<span class="line-modified">350     return !(value &amp; (SpecFullDouble | SpecNonInt32AsInt52));</span>
351 }
352 
353 inline bool isInt32OrBooleanSpeculationExpectingDefined(SpeculatedType value)
354 {
355     return isInt32OrBooleanSpeculation(value &amp; ~SpecOther);
356 }
357 
<span class="line-modified">358 inline bool isAnyInt52Speculation(SpeculatedType value)</span>
<span class="line-added">359 {</span>
<span class="line-added">360     return !!value &amp;&amp; (value &amp; SpecInt52Any) == value;</span>
<span class="line-added">361 }</span>
<span class="line-added">362 </span>
<span class="line-added">363 inline bool isInt32OrInt52Speculation(SpeculatedType value)</span>
364 {
<span class="line-modified">365     return !!value &amp;&amp; (value &amp; (SpecInt32Only | SpecInt52Any)) == value;</span>
366 }
367 
<span class="line-modified">368 inline bool isIntAnyFormat(SpeculatedType value)</span>
369 {
<span class="line-modified">370     return !!value &amp;&amp; (value &amp; SpecIntAnyFormat) == value;</span>
371 }
372 
373 inline bool isAnyIntAsDoubleSpeculation(SpeculatedType value)
374 {
375     return value == SpecAnyIntAsDouble;
376 }
377 
378 inline bool isDoubleRealSpeculation(SpeculatedType value)
379 {
380     return !!value &amp;&amp; (value &amp; SpecDoubleReal) == value;
381 }
382 
383 inline bool isDoubleSpeculation(SpeculatedType value)
384 {
385     return !!value &amp;&amp; (value &amp; SpecFullDouble) == value;
386 }
387 
388 inline bool isDoubleSpeculationForArithmetic(SpeculatedType value)
389 {
390     return !!(value &amp; SpecFullDouble);
</pre>
<hr />
<pre>
475     return left | right;
476 }
477 
478 template&lt;typename T&gt;
479 inline bool mergeSpeculation(T&amp; left, SpeculatedType right)
480 {
481     SpeculatedType newSpeculation = static_cast&lt;T&gt;(mergeSpeculations(static_cast&lt;SpeculatedType&gt;(left), right));
482     bool result = newSpeculation != static_cast&lt;SpeculatedType&gt;(left);
483     left = newSpeculation;
484     return result;
485 }
486 
487 inline bool speculationChecked(SpeculatedType actual, SpeculatedType desired)
488 {
489     return (actual | desired) == desired;
490 }
491 
492 SpeculatedType speculationFromClassInfo(const ClassInfo*);
493 SpeculatedType speculationFromStructure(Structure*);
494 SpeculatedType speculationFromCell(JSCell*);
<span class="line-modified">495 JS_EXPORT_PRIVATE SpeculatedType speculationFromValue(JSValue);</span>
<span class="line-added">496 // If it&#39;s an anyInt(), it&#39;ll return speculated types from the Int52 lattice.</span>
<span class="line-added">497 // Otherwise, it&#39;ll return types from the JSValue lattice.</span>
<span class="line-added">498 JS_EXPORT_PRIVATE SpeculatedType int52AwareSpeculationFromValue(JSValue);</span>
499 SpeculatedType speculationFromJSType(JSType);
500 
501 SpeculatedType speculationFromTypedArrayType(TypedArrayType); // only valid for typed views.
502 TypedArrayType typedArrayTypeFromSpeculation(SpeculatedType);
503 
504 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType);
505 
506 bool valuesCouldBeEqual(SpeculatedType, SpeculatedType);
507 
508 // Precise computation of the type of the result of a double computation after we
509 // already know that the inputs are doubles and that the result must be a double. Use
510 // the closest one of these that applies.
511 SpeculatedType typeOfDoubleSum(SpeculatedType, SpeculatedType);
512 SpeculatedType typeOfDoubleDifference(SpeculatedType, SpeculatedType);
513 SpeculatedType typeOfDoubleProduct(SpeculatedType, SpeculatedType);
514 SpeculatedType typeOfDoubleQuotient(SpeculatedType, SpeculatedType);
515 SpeculatedType typeOfDoubleMinMax(SpeculatedType, SpeculatedType);
516 SpeculatedType typeOfDoubleNegation(SpeculatedType);
517 SpeculatedType typeOfDoubleAbs(SpeculatedType);
518 SpeculatedType typeOfDoubleRounding(SpeculatedType);
</pre>
</td>
</tr>
</table>
<center><a href="SpeculatedType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>