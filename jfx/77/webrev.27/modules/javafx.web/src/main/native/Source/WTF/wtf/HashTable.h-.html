<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2005, 2006, 2007, 2008, 2011, 2012, 2015 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &lt;atomic&gt;
  25 #include &lt;iterator&gt;
  26 #include &lt;mutex&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;type_traits&gt;
  29 #include &lt;utility&gt;
  30 #include &lt;wtf/Assertions.h&gt;
  31 #include &lt;wtf/FastMalloc.h&gt;
  32 #include &lt;wtf/HashTraits.h&gt;
  33 #include &lt;wtf/Lock.h&gt;
  34 #include &lt;wtf/MathExtras.h&gt;
  35 #include &lt;wtf/RandomNumber.h&gt;
  36 #include &lt;wtf/StdLibExtras.h&gt;
  37 #include &lt;wtf/ValueCheck.h&gt;
  38 
  39 #define DUMP_HASHTABLE_STATS 0
  40 #define DUMP_HASHTABLE_STATS_PER_TABLE 0
  41 
  42 #if DUMP_HASHTABLE_STATS_PER_TABLE
  43 #include &lt;wtf/DataLog.h&gt;
  44 #endif
  45 
  46 namespace WTF {
  47 
  48 // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  49 #define CHECK_HASHTABLE_CONSISTENCY 0
  50 
  51 #ifdef NDEBUG
  52 #define CHECK_HASHTABLE_ITERATORS 0
  53 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
  54 #else
  55 #define CHECK_HASHTABLE_ITERATORS 1
  56 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 1
  57 #endif
  58 
  59 #if DUMP_HASHTABLE_STATS
  60 
  61     struct HashTableStats {
  62         // The following variables are all atomically incremented when modified.
  63         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numAccesses;
  64         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRehashes;
  65         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRemoves;
  66         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numReinserts;
  67 
  68         // The following variables are only modified in the recordCollisionAtCount method within a mutex.
  69         WTF_EXPORT_PRIVATE static unsigned maxCollisions;
  70         WTF_EXPORT_PRIVATE static unsigned numCollisions;
  71         WTF_EXPORT_PRIVATE static unsigned collisionGraph[4096];
  72 
  73         WTF_EXPORT_PRIVATE static void recordCollisionAtCount(unsigned count);
  74         WTF_EXPORT_PRIVATE static void dumpStats();
  75     };
  76 
  77 #endif
  78 
  79     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  80     class HashTable;
  81     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  82     class HashTableIterator;
  83     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  84     class HashTableConstIterator;
  85 
  86     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  87     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  88         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  89 
  90     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  91     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  92 
  93 #if !CHECK_HASHTABLE_ITERATORS
  94 
  95     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  96     inline void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  97         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
  98 
  99     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 100     inline void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 101 
 102 #endif
 103 
 104     typedef enum { HashItemKnownGood } HashItemKnownGoodTag;
 105 
 106     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 107     class HashTableConstIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, const Value*, const Value&amp;&gt; {
 108     private:
 109         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 110         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 111         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 112         typedef Value ValueType;
 113         typedef const ValueType&amp; ReferenceType;
 114         typedef const ValueType* PointerType;
 115 
 116         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 117         friend class HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 118 
 119         void skipEmptyBuckets()
 120         {
 121             while (m_position != m_endPosition &amp;&amp; HashTableType::isEmptyOrDeletedBucket(*m_position))
 122                 ++m_position;
 123         }
 124 
 125         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
 126             : m_position(position), m_endPosition(endPosition)
 127         {
 128             addIterator(table, this);
 129             skipEmptyBuckets();
 130         }
 131 
 132         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
 133             : m_position(position), m_endPosition(endPosition)
 134         {
 135             addIterator(table, this);
 136         }
 137 
 138     public:
 139         HashTableConstIterator()
 140         {
 141             addIterator(static_cast&lt;const HashTableType*&gt;(0), this);
 142         }
 143 
 144         // default copy, assignment and destructor are OK if CHECK_HASHTABLE_ITERATORS is 0
 145 
 146 #if CHECK_HASHTABLE_ITERATORS
 147         ~HashTableConstIterator()
 148         {
 149             removeIterator(this);
 150         }
 151 
 152         HashTableConstIterator(const const_iterator&amp; other)
 153             : m_position(other.m_position), m_endPosition(other.m_endPosition)
 154         {
 155             addIterator(other.m_table, this);
 156         }
 157 
 158         const_iterator&amp; operator=(const const_iterator&amp; other)
 159         {
 160             m_position = other.m_position;
 161             m_endPosition = other.m_endPosition;
 162 
 163             removeIterator(this);
 164             addIterator(other.m_table, this);
 165 
 166             return *this;
 167         }
 168 #endif
 169 
 170         PointerType get() const
 171         {
 172             checkValidity();
 173             return m_position;
 174         }
 175         ReferenceType operator*() const { return *get(); }
 176         PointerType operator-&gt;() const { return get(); }
 177 
 178         const_iterator&amp; operator++()
 179         {
 180             checkValidity();
 181             ASSERT(m_position != m_endPosition);
 182             ++m_position;
 183             skipEmptyBuckets();
 184             return *this;
 185         }
 186 
 187         // postfix ++ intentionally omitted
 188 
 189         // Comparison.
 190         bool operator==(const const_iterator&amp; other) const
 191         {
 192             checkValidity(other);
 193             return m_position == other.m_position;
 194         }
 195         bool operator!=(const const_iterator&amp; other) const
 196         {
 197             checkValidity(other);
 198             return m_position != other.m_position;
 199         }
 200         bool operator==(const iterator&amp; other) const
 201         {
 202             return *this == static_cast&lt;const_iterator&gt;(other);
 203         }
 204         bool operator!=(const iterator&amp; other) const
 205         {
 206             return *this != static_cast&lt;const_iterator&gt;(other);
 207         }
 208 
 209     private:
 210         void checkValidity() const
 211         {
 212 #if CHECK_HASHTABLE_ITERATORS
 213             ASSERT(m_table);
 214 #endif
 215         }
 216 
 217 
 218 #if CHECK_HASHTABLE_ITERATORS
 219         void checkValidity(const const_iterator&amp; other) const
 220         {
 221             ASSERT(m_table);
 222             ASSERT_UNUSED(other, other.m_table);
 223             ASSERT(m_table == other.m_table);
 224         }
 225 #else
 226         void checkValidity(const const_iterator&amp;) const { }
 227 #endif
 228 
 229         PointerType m_position { nullptr };
 230         PointerType m_endPosition { nullptr };
 231 
 232 #if CHECK_HASHTABLE_ITERATORS
 233     public:
 234         // Any modifications of the m_next or m_previous of an iterator that is in a linked list of a HashTable::m_iterator,
 235         // should be guarded with m_table-&gt;m_mutex.
 236         mutable const HashTableType* m_table;
 237         mutable const_iterator* m_next;
 238         mutable const_iterator* m_previous;
 239 #endif
 240     };
 241 
 242     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 243     class HashTableIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, Value*, Value&amp;&gt; {
 244     private:
 245         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 246         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 247         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 248         typedef Value ValueType;
 249         typedef ValueType&amp; ReferenceType;
 250         typedef ValueType* PointerType;
 251 
 252         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 253 
 254         HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
 255         HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }
 256 
 257     public:
 258         HashTableIterator() { }
 259 
 260         // default copy, assignment and destructor are OK
 261 
 262         PointerType get() const { return const_cast&lt;PointerType&gt;(m_iterator.get()); }
 263         ReferenceType operator*() const { return *get(); }
 264         PointerType operator-&gt;() const { return get(); }
 265 
 266         iterator&amp; operator++() { ++m_iterator; return *this; }
 267 
 268         // postfix ++ intentionally omitted
 269 
 270         // Comparison.
 271         bool operator==(const iterator&amp; other) const { return m_iterator == other.m_iterator; }
 272         bool operator!=(const iterator&amp; other) const { return m_iterator != other.m_iterator; }
 273         bool operator==(const const_iterator&amp; other) const { return m_iterator == other; }
 274         bool operator!=(const const_iterator&amp; other) const { return m_iterator != other; }
 275 
 276         operator const_iterator() const { return m_iterator; }
 277 
 278     private:
 279         const_iterator m_iterator;
 280     };
 281 
 282     template&lt;typename ValueTraits, typename HashFunctions&gt; class IdentityHashTranslator {
 283     public:
 284         template&lt;typename T&gt; static unsigned hash(const T&amp; key) { return HashFunctions::hash(key); }
 285         template&lt;typename T, typename U&gt; static bool equal(const T&amp; a, const U&amp; b) { return HashFunctions::equal(a, b); }
 286         template&lt;typename T, typename U, typename V&gt; static void translate(T&amp; location, const U&amp;, V&amp;&amp; value)
 287         {
 288             ValueTraits::assignToEmpty(location, std::forward&lt;V&gt;(value));
 289         }
 290     };
 291 
 292     template&lt;typename IteratorType&gt; struct HashTableAddResult {
 293         HashTableAddResult() : isNewEntry(false) { }
 294         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 295         IteratorType iterator;
 296         bool isNewEntry;
 297 
 298         explicit operator bool() const { return isNewEntry; }
 299     };
 300 
 301     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 302     class HashTable {
 303     public:
 304         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 305         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 306         typedef Traits ValueTraits;
 307         typedef Key KeyType;
 308         typedef Value ValueType;
 309         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 310         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 311 
 312 #if DUMP_HASHTABLE_STATS_PER_TABLE
 313         struct Stats {
 314             Stats()
 315                 : numAccesses(0)
 316                 , numRehashes(0)
 317                 , numRemoves(0)
 318                 , numReinserts(0)
 319                 , maxCollisions(0)
 320                 , numCollisions(0)
 321                 , collisionGraph()
 322             {
 323             }
 324 
 325             unsigned numAccesses;
 326             unsigned numRehashes;
 327             unsigned numRemoves;
 328             unsigned numReinserts;
 329 
 330             unsigned maxCollisions;
 331             unsigned numCollisions;
 332             unsigned collisionGraph[4096];
 333 
 334             void recordCollisionAtCount(unsigned count)
 335             {
 336                 if (count &gt; maxCollisions)
 337                     maxCollisions = count;
 338                 numCollisions++;
 339                 collisionGraph[count]++;
 340             }
 341 
 342             void dumpStats()
 343             {
 344                 dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);
 345                 dataLogF(&quot;%d accesses\n&quot;, numAccesses);
 346                 dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses);
 347                 dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);
 348                 for (unsigned i = 1; i &lt;= maxCollisions; i++) {
 349                     dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses);
 350                 }
 351                 dataLogF(&quot;%d rehashes\n&quot;, numRehashes);
 352                 dataLogF(&quot;%d reinserts\n&quot;, numReinserts);
 353             }
 354         };
 355 #endif
 356 
 357         HashTable();
 358         ~HashTable()
 359         {
 360 
 361 #if PLATFORM(JAVA)
 362 #if CHECK_HASHTABLE_ITERATORS
 363             // does the same as invalidateIterators() but without
 364             // taking a lock since the destructor may be invoked
 365             // during atexit() handler which may lead to crash
 366             const_iterator* next;
 367             for (const_iterator* p = m_iterators; p; p = next) {
 368                 next = p-&gt;m_next;
 369                 p-&gt;m_table = 0;
 370                 p-&gt;m_next = 0;
 371                 p-&gt;m_previous = 0;
 372             }
 373             m_iterators = 0;
 374 #endif
 375 #else
 376             invalidateIterators();
 377 #endif
 378 
 379             if (m_table)
 380                 deallocateTable(m_table, m_tableSize);
 381 #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 382             m_table = (ValueType*)(uintptr_t)0xbbadbeef;
 383 #endif
 384         }
 385 
 386         HashTable(const HashTable&amp;);
 387         void swap(HashTable&amp;);
 388         HashTable&amp; operator=(const HashTable&amp;);
 389 
 390         HashTable(HashTable&amp;&amp;);
 391         HashTable&amp; operator=(HashTable&amp;&amp;);
 392 
 393         // When the hash table is empty, just return the same iterator for end as for begin.
 394         // This is more efficient because we don&#39;t have to skip all the empty and deleted
 395         // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
 396         iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
 397         iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }
 398         const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
 399         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }
 400 
 401         iterator random()
 402         {
 403             if (isEmpty())
 404                 return end();
 405 
 406             while (1) {
 407                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];
 408                 if (!isEmptyOrDeletedBucket(bucket))
 409                     return makeKnownGoodIterator(&amp;bucket);
 410             };
 411         }
 412 
 413         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 414 
 415         unsigned size() const { return m_keyCount; }
 416         unsigned capacity() const { return m_tableSize; }
 417         bool isEmpty() const { return !m_keyCount; }
 418 
 419         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 420         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 421 
 422         // A special version of add() that finds the object by hashing and comparing
 423         // with some other type, to avoid the cost of type conversion if the object is already
 424         // in the table.
 425         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 426         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 427 
 428         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 429         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 430         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 431 
 432         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 433         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 434         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 435 
 436         void remove(const KeyType&amp;);
 437         void remove(iterator);
 438         void removeWithoutEntryConsistencyCheck(iterator);
 439         void removeWithoutEntryConsistencyCheck(const_iterator);
 440         template&lt;typename Functor&gt;
 441         bool removeIf(const Functor&amp;);
 442         void clear();
 443 
 444         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 445         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 446         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 447 
 448         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 449         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 450         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 451 
 452 #if !ASSERT_DISABLED
 453         void checkTableConsistency() const;
 454 #else
 455         static void checkTableConsistency() { }
 456 #endif
 457 #if CHECK_HASHTABLE_CONSISTENCY
 458         void internalCheckTableConsistency() const { checkTableConsistency(); }
 459         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 460 #else
 461         static void internalCheckTableConsistencyExceptSize() { }
 462         static void internalCheckTableConsistency() { }
 463 #endif
 464 
 465     private:
 466         static ValueType* allocateTable(unsigned size);
 467         static void deallocateTable(ValueType* table, unsigned size);
 468 
 469         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 470         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 471 
 472         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 473         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 474         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 475 
 476         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 477 
 478         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 479 
 480         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 481         void removeAndInvalidate(ValueType*);
 482         void remove(ValueType*);
 483 
 484         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }
 485         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }
 486         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }
 487         ValueType* expand(ValueType* entry = nullptr);
 488         void shrink() { rehash(m_tableSize / 2, nullptr); }
 489 
 490         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 491         ValueType* reinsert(ValueType&amp;&amp;);
 492 
 493         static void initializeBucket(ValueType&amp; bucket);
 494         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 495 
 496         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 497             { return FullLookupType(LookupType(position, found), hash); }
 498 
 499         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }
 500         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }
 501         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 502         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 503 
 504 #if !ASSERT_DISABLED
 505         void checkTableConsistencyExceptSize() const;
 506 #else
 507         static void checkTableConsistencyExceptSize() { }
 508 #endif
 509 
 510 #if CHECK_HASHTABLE_ITERATORS
 511         void invalidateIterators();
 512 #else
 513         static void invalidateIterators() { }
 514 #endif
 515 
 516         static const unsigned m_maxLoad = 2;
 517         static const unsigned m_minLoad = 6;
 518 
 519         ValueType* m_table;
 520         unsigned m_tableSize;
 521         unsigned m_tableSizeMask;
 522         unsigned m_keyCount;
 523         unsigned m_deletedCount;
 524 
 525 #if CHECK_HASHTABLE_ITERATORS
 526     public:
 527         // All access to m_iterators should be guarded with m_mutex.
 528         mutable const_iterator* m_iterators;
 529         // Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
 530         mutable std::unique_ptr&lt;Lock&gt; m_mutex;
 531 #endif
 532 
 533 #if DUMP_HASHTABLE_STATS_PER_TABLE
 534     public:
 535         mutable std::unique_ptr&lt;Stats&gt; m_stats;
 536 #endif
 537     };
 538 
 539     // Set all the bits to one after the most significant bit: 00110101010 -&gt; 00111111111.
 540     template&lt;unsigned size&gt; struct OneifyLowBits;
 541     template&lt;&gt;
 542     struct OneifyLowBits&lt;0&gt; {
 543         static const unsigned value = 0;
 544     };
 545     template&lt;unsigned number&gt;
 546     struct OneifyLowBits {
 547         static const unsigned value = number | OneifyLowBits&lt;(number &gt;&gt; 1)&gt;::value;
 548     };
 549     // Compute the first power of two integer that is an upper bound of the parameter &#39;number&#39;.
 550     template&lt;unsigned number&gt;
 551     struct UpperPowerOfTwoBound {
 552         static const unsigned value = (OneifyLowBits&lt;number - 1&gt;::value + 1) * 2;
 553     };
 554 
 555     // Because power of two numbers are the limit of maxLoad, their capacity is twice the
 556     // UpperPowerOfTwoBound, or 4 times their values.
 557     template&lt;unsigned size, bool isPowerOfTwo&gt; struct HashTableCapacityForSizeSplitter;
 558     template&lt;unsigned size&gt;
 559     struct HashTableCapacityForSizeSplitter&lt;size, true&gt; {
 560         static const unsigned value = size * 4;
 561     };
 562     template&lt;unsigned size&gt;
 563     struct HashTableCapacityForSizeSplitter&lt;size, false&gt; {
 564         static const unsigned value = UpperPowerOfTwoBound&lt;size&gt;::value;
 565     };
 566 
 567     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.
 568     // This is done at compile time to initialize the HashTraits.
 569     template&lt;unsigned size&gt;
 570     struct HashTableCapacityForSize {
 571         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;
 572         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);
 573         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);
 574         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);
 575     };
 576 
 577     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 578     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
 579         : m_table(0)
 580         , m_tableSize(0)
 581         , m_tableSizeMask(0)
 582         , m_keyCount(0)
 583         , m_deletedCount(0)
 584 #if CHECK_HASHTABLE_ITERATORS
 585         , m_iterators(0)
 586         , m_mutex(std::make_unique&lt;Lock&gt;())
 587 #endif
 588 #if DUMP_HASHTABLE_STATS_PER_TABLE
 589         , m_stats(std::make_unique&lt;Stats&gt;())
 590 #endif
 591     {
 592     }
 593 
 594     inline unsigned doubleHash(unsigned key)
 595     {
 596         key = ~key + (key &gt;&gt; 23);
 597         key ^= (key &lt;&lt; 12);
 598         key ^= (key &gt;&gt; 7);
 599         key ^= (key &lt;&lt; 2);
 600         key ^= (key &gt;&gt; 20);
 601         return key;
 602     }
 603 
 604 #if ASSERT_DISABLED
 605 
 606     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 607     template&lt;typename HashTranslator, typename T&gt;
 608     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 609     {
 610     }
 611 
 612 #else
 613 
 614     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 615     template&lt;typename HashTranslator, typename T&gt;
 616     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
 617     {
 618         if (!HashFunctions::safeToCompareToEmptyOrDeleted)
 619             return;
 620         ASSERT(!HashTranslator::equal(KeyTraits::emptyValue(), key));
 621         typename std::aligned_storage&lt;sizeof(ValueType), std::alignment_of&lt;ValueType&gt;::value&gt;::type deletedValueBuffer;
 622         ValueType* deletedValuePtr = reinterpret_cast_ptr&lt;ValueType*&gt;(&amp;deletedValueBuffer);
 623         ValueType&amp; deletedValue = *deletedValuePtr;
 624         Traits::constructDeletedValue(deletedValue);
 625         ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
 626     }
 627 
 628 #endif
 629 
 630     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 631     template&lt;typename HashTranslator, typename T&gt;
 632     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
 633     {
 634         return inlineLookup&lt;HashTranslator&gt;(key);
 635     }
 636 
 637     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 638     template&lt;typename HashTranslator, typename T&gt;
 639     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
 640     {
 641         checkKey&lt;HashTranslator&gt;(key);
 642 
 643         unsigned k = 0;
 644         unsigned sizeMask = m_tableSizeMask;
 645         ValueType* table = m_table;
 646         unsigned h = HashTranslator::hash(key);
 647         unsigned i = h &amp; sizeMask;
 648 
 649         if (!table)
 650             return 0;
 651 
 652 #if DUMP_HASHTABLE_STATS
 653         ++HashTableStats::numAccesses;
 654         unsigned probeCount = 0;
 655 #endif
 656 
 657 #if DUMP_HASHTABLE_STATS_PER_TABLE
 658         ++m_stats-&gt;numAccesses;
 659 #endif
 660 
 661         while (1) {
 662             ValueType* entry = table + i;
 663 
 664             // we count on the compiler to optimize out this branch
 665             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 666                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 667                     return entry;
 668 
 669                 if (isEmptyBucket(*entry))
 670                     return 0;
 671             } else {
 672                 if (isEmptyBucket(*entry))
 673                     return 0;
 674 
 675                 if (!isDeletedBucket(*entry) &amp;&amp; HashTranslator::equal(Extractor::extract(*entry), key))
 676                     return entry;
 677             }
 678 #if DUMP_HASHTABLE_STATS
 679             ++probeCount;
 680             HashTableStats::recordCollisionAtCount(probeCount);
 681 #endif
 682 
 683 #if DUMP_HASHTABLE_STATS_PER_TABLE
 684             m_stats-&gt;recordCollisionAtCount(probeCount);
 685 #endif
 686 
 687             if (k == 0)
 688                 k = 1 | doubleHash(h);
 689             i = (i + k) &amp; sizeMask;
 690         }
 691     }
 692 
 693     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 694     template&lt;typename HashTranslator, typename T&gt;
 695     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookupForWriting(const T&amp; key) -&gt; LookupType
 696     {
 697         ASSERT(m_table);
 698         checkKey&lt;HashTranslator&gt;(key);
 699 
 700         unsigned k = 0;
 701         ValueType* table = m_table;
 702         unsigned sizeMask = m_tableSizeMask;
 703         unsigned h = HashTranslator::hash(key);
 704         unsigned i = h &amp; sizeMask;
 705 
 706 #if DUMP_HASHTABLE_STATS
 707         ++HashTableStats::numAccesses;
 708         unsigned probeCount = 0;
 709 #endif
 710 
 711 #if DUMP_HASHTABLE_STATS_PER_TABLE
 712         ++m_stats-&gt;numAccesses;
 713 #endif
 714 
 715         ValueType* deletedEntry = 0;
 716 
 717         while (1) {
 718             ValueType* entry = table + i;
 719 
 720             // we count on the compiler to optimize out this branch
 721             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 722                 if (isEmptyBucket(*entry))
 723                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 724 
 725                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 726                     return LookupType(entry, true);
 727 
 728                 if (isDeletedBucket(*entry))
 729                     deletedEntry = entry;
 730             } else {
 731                 if (isEmptyBucket(*entry))
 732                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 733 
 734                 if (isDeletedBucket(*entry))
 735                     deletedEntry = entry;
 736                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 737                     return LookupType(entry, true);
 738             }
 739 #if DUMP_HASHTABLE_STATS
 740             ++probeCount;
 741             HashTableStats::recordCollisionAtCount(probeCount);
 742 #endif
 743 
 744 #if DUMP_HASHTABLE_STATS_PER_TABLE
 745             m_stats-&gt;recordCollisionAtCount(probeCount);
 746 #endif
 747 
 748             if (k == 0)
 749                 k = 1 | doubleHash(h);
 750             i = (i + k) &amp; sizeMask;
 751         }
 752     }
 753 
 754     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 755     template&lt;typename HashTranslator, typename T&gt;
 756     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::fullLookupForWriting(const T&amp; key) -&gt; FullLookupType
 757     {
 758         ASSERT(m_table);
 759         checkKey&lt;HashTranslator&gt;(key);
 760 
 761         unsigned k = 0;
 762         ValueType* table = m_table;
 763         unsigned sizeMask = m_tableSizeMask;
 764         unsigned h = HashTranslator::hash(key);
 765         unsigned i = h &amp; sizeMask;
 766 
 767 #if DUMP_HASHTABLE_STATS
 768         ++HashTableStats::numAccesses;
 769         unsigned probeCount = 0;
 770 #endif
 771 
 772 #if DUMP_HASHTABLE_STATS_PER_TABLE
 773         ++m_stats-&gt;numAccesses;
 774 #endif
 775 
 776         ValueType* deletedEntry = 0;
 777 
 778         while (1) {
 779             ValueType* entry = table + i;
 780 
 781             // we count on the compiler to optimize out this branch
 782             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 783                 if (isEmptyBucket(*entry))
 784                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 785 
 786                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 787                     return makeLookupResult(entry, true, h);
 788 
 789                 if (isDeletedBucket(*entry))
 790                     deletedEntry = entry;
 791             } else {
 792                 if (isEmptyBucket(*entry))
 793                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 794 
 795                 if (isDeletedBucket(*entry))
 796                     deletedEntry = entry;
 797                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 798                     return makeLookupResult(entry, true, h);
 799             }
 800 #if DUMP_HASHTABLE_STATS
 801             ++probeCount;
 802             HashTableStats::recordCollisionAtCount(probeCount);
 803 #endif
 804 
 805 #if DUMP_HASHTABLE_STATS_PER_TABLE
 806             m_stats-&gt;recordCollisionAtCount(probeCount);
 807 #endif
 808 
 809             if (k == 0)
 810                 k = 1 | doubleHash(h);
 811             i = (i + k) &amp; sizeMask;
 812         }
 813     }
 814 
 815     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 816     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 817     ALWAYS_INLINE void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp; extra)
 818     {
 819         ASSERT(m_table);
 820 
 821         checkKey&lt;HashTranslator&gt;(key);
 822 
 823         invalidateIterators();
 824 
 825         internalCheckTableConsistency();
 826 
 827         unsigned k = 0;
 828         ValueType* table = m_table;
 829         unsigned sizeMask = m_tableSizeMask;
 830         unsigned h = HashTranslator::hash(key);
 831         unsigned i = h &amp; sizeMask;
 832 
 833 #if DUMP_HASHTABLE_STATS
 834         ++HashTableStats::numAccesses;
 835         unsigned probeCount = 0;
 836 #endif
 837 
 838 #if DUMP_HASHTABLE_STATS_PER_TABLE
 839         ++m_stats-&gt;numAccesses;
 840 #endif
 841 
 842         ValueType* entry;
 843         while (1) {
 844             entry = table + i;
 845 
 846             if (isEmptyBucket(*entry))
 847                 break;
 848 
 849 #if DUMP_HASHTABLE_STATS
 850             ++probeCount;
 851             HashTableStats::recordCollisionAtCount(probeCount);
 852 #endif
 853 
 854 #if DUMP_HASHTABLE_STATS_PER_TABLE
 855             m_stats-&gt;recordCollisionAtCount(probeCount);
 856 #endif
 857 
 858             if (k == 0)
 859                 k = 1 | doubleHash(h);
 860             i = (i + k) &amp; sizeMask;
 861         }
 862 
 863         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
 864 
 865         internalCheckTableConsistency();
 866     }
 867 
 868     template&lt;bool emptyValueIsZero&gt; struct HashTableBucketInitializer;
 869 
 870     template&lt;&gt; struct HashTableBucketInitializer&lt;false&gt; {
 871         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 872         {
 873             Traits::template constructEmptyValue&lt;Traits&gt;(bucket);
 874         }
 875     };
 876 
 877     template&lt;&gt; struct HashTableBucketInitializer&lt;true&gt; {
 878         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 879         {
 880             // This initializes the bucket without copying the empty value.
 881             // That makes it possible to use this with types that don&#39;t support copying.
 882             // The memset to 0 looks like a slow operation but is optimized by the compilers.
 883             memset(static_cast&lt;void*&gt;(std::addressof(bucket)), 0, sizeof(bucket));
 884         }
 885     };
 886 
 887     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 888     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::initializeBucket(ValueType&amp; bucket)
 889     {
 890         HashTableBucketInitializer&lt;Traits::emptyValueIsZero&gt;::template initialize&lt;Traits&gt;(bucket);
 891     }
 892 
 893     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 894     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 895     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::add(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 896     {
 897         checkKey&lt;HashTranslator&gt;(key);
 898 
 899         invalidateIterators();
 900 
 901         if (!m_table)
 902             expand(nullptr);
 903 
 904         internalCheckTableConsistency();
 905 
 906         ASSERT(m_table);
 907 
 908         unsigned k = 0;
 909         ValueType* table = m_table;
 910         unsigned sizeMask = m_tableSizeMask;
 911         unsigned h = HashTranslator::hash(key);
 912         unsigned i = h &amp; sizeMask;
 913 
 914 #if DUMP_HASHTABLE_STATS
 915         ++HashTableStats::numAccesses;
 916         unsigned probeCount = 0;
 917 #endif
 918 
 919 #if DUMP_HASHTABLE_STATS_PER_TABLE
 920         ++m_stats-&gt;numAccesses;
 921 #endif
 922 
 923         ValueType* deletedEntry = 0;
 924         ValueType* entry;
 925         while (1) {
 926             entry = table + i;
 927 
 928             // we count on the compiler to optimize out this branch
 929             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 930                 if (isEmptyBucket(*entry))
 931                     break;
 932 
 933                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 934                     return AddResult(makeKnownGoodIterator(entry), false);
 935 
 936                 if (isDeletedBucket(*entry))
 937                     deletedEntry = entry;
 938             } else {
 939                 if (isEmptyBucket(*entry))
 940                     break;
 941 
 942                 if (isDeletedBucket(*entry))
 943                     deletedEntry = entry;
 944                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 945                     return AddResult(makeKnownGoodIterator(entry), false);
 946             }
 947 #if DUMP_HASHTABLE_STATS
 948             ++probeCount;
 949             HashTableStats::recordCollisionAtCount(probeCount);
 950 #endif
 951 
 952 #if DUMP_HASHTABLE_STATS_PER_TABLE
 953             m_stats-&gt;recordCollisionAtCount(probeCount);
 954 #endif
 955 
 956             if (k == 0)
 957                 k = 1 | doubleHash(h);
 958             i = (i + k) &amp; sizeMask;
 959         }
 960 
 961         if (deletedEntry) {
 962             initializeBucket(*deletedEntry);
 963             entry = deletedEntry;
 964             --m_deletedCount;
 965         }
 966 
 967         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
 968         ++m_keyCount;
 969 
 970         if (shouldExpand())
 971             entry = expand(entry);
 972 
 973         internalCheckTableConsistency();
 974 
 975         return AddResult(makeKnownGoodIterator(entry), true);
 976     }
 977 
 978     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 979     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 980     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 981     {
 982         checkKey&lt;HashTranslator&gt;(key);
 983 
 984         invalidateIterators();
 985 
 986         if (!m_table)
 987             expand();
 988 
 989         internalCheckTableConsistency();
 990 
 991         FullLookupType lookupResult = fullLookupForWriting&lt;HashTranslator&gt;(key);
 992 
 993         ValueType* entry = lookupResult.first.first;
 994         bool found = lookupResult.first.second;
 995         unsigned h = lookupResult.second;
 996 
 997         if (found)
 998             return AddResult(makeKnownGoodIterator(entry), false);
 999 
1000         if (isDeletedBucket(*entry)) {
1001             initializeBucket(*entry);
1002             --m_deletedCount;
1003         }
1004 
1005         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
1006         ++m_keyCount;
1007 
1008         if (shouldExpand())
1009             entry = expand(entry);
1010 
1011         internalCheckTableConsistency();
1012 
1013         return AddResult(makeKnownGoodIterator(entry), true);
1014     }
1015 
1016     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1017     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::reinsert(ValueType&amp;&amp; entry) -&gt; ValueType*
1018     {
1019         ASSERT(m_table);
1020         ASSERT(!lookupForWriting(Extractor::extract(entry)).second);
1021         ASSERT(!isDeletedBucket(*(lookupForWriting(Extractor::extract(entry)).first)));
1022 #if DUMP_HASHTABLE_STATS
1023         ++HashTableStats::numReinserts;
1024 #endif
1025 #if DUMP_HASHTABLE_STATS_PER_TABLE
1026         ++m_stats-&gt;numReinserts;
1027 #endif
1028 
1029         Value* newEntry = lookupForWriting(Extractor::extract(entry)).first;
1030         newEntry-&gt;~Value();
1031         new (NotNull, newEntry) ValueType(WTFMove(entry));
1032 
1033         return newEntry;
1034     }
1035 
1036     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1037     template &lt;typename HashTranslator, typename T&gt;
1038     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) -&gt; iterator
1039     {
1040         if (!m_table)
1041             return end();
1042 
1043         ValueType* entry = lookup&lt;HashTranslator&gt;(key);
1044         if (!entry)
1045             return end();
1046 
1047         return makeKnownGoodIterator(entry);
1048     }
1049 
1050     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1051     template &lt;typename HashTranslator, typename T&gt;
1052     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) const -&gt; const_iterator
1053     {
1054         if (!m_table)
1055             return end();
1056 
1057         ValueType* entry = const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1058         if (!entry)
1059             return end();
1060 
1061         return makeKnownGoodConstIterator(entry);
1062     }
1063 
1064     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1065     template &lt;typename HashTranslator, typename T&gt;
1066     bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::contains(const T&amp; key) const
1067     {
1068         if (!m_table)
1069             return false;
1070 
1071         return const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1072     }
1073 
1074     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1075     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)
1076     {
1077         invalidateIterators();
1078         remove(pos);
1079     }
1080 
1081     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1082     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidate(ValueType* pos)
1083     {
1084         invalidateIterators();
1085         internalCheckTableConsistency();
1086         remove(pos);
1087     }
1088 
1089     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1090     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(ValueType* pos)
1091     {
1092 #if DUMP_HASHTABLE_STATS
1093         ++HashTableStats::numRemoves;
1094 #endif
1095 #if DUMP_HASHTABLE_STATS_PER_TABLE
1096         ++m_stats-&gt;numRemoves;
1097 #endif
1098 
1099         deleteBucket(*pos);
1100         ++m_deletedCount;
1101         --m_keyCount;
1102 
1103         if (shouldShrink())
1104             shrink();
1105 
1106         internalCheckTableConsistency();
1107     }
1108 
1109     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1110     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(iterator it)
1111     {
1112         if (it == end())
1113             return;
1114 
1115         removeAndInvalidate(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1116     }
1117 
1118     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1119     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(iterator it)
1120     {
1121         if (it == end())
1122             return;
1123 
1124         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1125     }
1126 
1127     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1128     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(const_iterator it)
1129     {
1130         if (it == end())
1131             return;
1132 
1133         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_position));
1134     }
1135 
1136     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1137     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(const KeyType&amp; key)
1138     {
1139         remove(find(key));
1140     }
1141 
1142     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1143     template&lt;typename Functor&gt;
1144     inline bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeIf(const Functor&amp; functor)
1145     {
1146         // We must use local copies in case &quot;functor&quot; or &quot;deleteBucket&quot;
1147         // make a function call, which prevents the compiler from keeping
1148         // the values in register.
1149         unsigned removedBucketCount = 0;
1150         ValueType* table = m_table;
1151 
1152         for (unsigned i = m_tableSize; i--;) {
1153             ValueType&amp; bucket = table[i];
1154             if (isEmptyOrDeletedBucket(bucket))
1155                 continue;
1156 
1157             if (!functor(bucket))
1158                 continue;
1159 
1160             deleteBucket(bucket);
1161             ++removedBucketCount;
1162         }
1163         m_deletedCount += removedBucketCount;
1164         m_keyCount -= removedBucketCount;
1165 
1166         if (shouldShrink())
1167             shrink();
1168 
1169         internalCheckTableConsistency();
1170         return removedBucketCount;
1171     }
1172 
1173     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1174     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1175     {
1176         // would use a template member function with explicit specializations here, but
1177         // gcc doesn&#39;t appear to support that
1178         if (Traits::emptyValueIsZero)
1179             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));
1180         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));
1181         for (unsigned i = 0; i &lt; size; i++)
1182             initializeBucket(result[i]);
1183         return result;
1184     }
1185 
1186     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1187     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)
1188     {
1189         for (unsigned i = 0; i &lt; size; ++i) {
1190             if (!isDeletedBucket(table[i]))
1191                 table[i].~ValueType();
1192         }
1193         fastFree(table);
1194     }
1195 
1196     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1197     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1198     {
1199         unsigned newSize;
1200         if (m_tableSize == 0)
1201             newSize = KeyTraits::minimumTableSize;
1202         else if (mustRehashInPlace())
1203             newSize = m_tableSize;
1204         else
1205             newSize = m_tableSize * 2;
1206 
1207         return rehash(newSize, entry);
1208     }
1209 
1210     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1211     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1212     {
1213         internalCheckTableConsistencyExceptSize();
1214 
1215         unsigned oldTableSize = m_tableSize;
1216         ValueType* oldTable = m_table;
1217 
1218 #if DUMP_HASHTABLE_STATS
1219         if (oldTableSize != 0)
1220             ++HashTableStats::numRehashes;
1221 #endif
1222 
1223 #if DUMP_HASHTABLE_STATS_PER_TABLE
1224         if (oldTableSize != 0)
1225             ++m_stats-&gt;numRehashes;
1226 #endif
1227 
1228         m_tableSize = newTableSize;
1229         m_tableSizeMask = newTableSize - 1;
1230         m_table = allocateTable(newTableSize);
1231 
1232         Value* newEntry = nullptr;
1233         for (unsigned i = 0; i != oldTableSize; ++i) {
1234             if (isDeletedBucket(oldTable[i])) {
1235                 ASSERT(std::addressof(oldTable[i]) != entry);
1236                 continue;
1237             }
1238 
1239             if (isEmptyBucket(oldTable[i])) {
1240                 ASSERT(std::addressof(oldTable[i]) != entry);
1241                 oldTable[i].~ValueType();
1242                 continue;
1243             }
1244 
1245             Value* reinsertedEntry = reinsert(WTFMove(oldTable[i]));
1246             oldTable[i].~ValueType();
1247             if (std::addressof(oldTable[i]) == entry) {
1248                 ASSERT(!newEntry);
1249                 newEntry = reinsertedEntry;
1250             }
1251         }
1252 
1253         m_deletedCount = 0;
1254 
1255         fastFree(oldTable);
1256 
1257         internalCheckTableConsistency();
1258         return newEntry;
1259     }
1260 
1261     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1262     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1263     {
1264         invalidateIterators();
1265         if (!m_table)
1266             return;
1267 
1268         deallocateTable(m_table, m_tableSize);
1269         m_table = 0;
1270         m_tableSize = 0;
1271         m_tableSizeMask = 0;
1272         m_keyCount = 0;
1273         m_deletedCount = 0;
1274     }
1275 
1276     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1277     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1278         : m_table(nullptr)
1279         , m_tableSize(0)
1280         , m_tableSizeMask(0)
1281         , m_keyCount(0)
1282         , m_deletedCount(0)
1283 #if CHECK_HASHTABLE_ITERATORS
1284         , m_iterators(nullptr)
1285         , m_mutex(std::make_unique&lt;Lock&gt;())
1286 #endif
1287 #if DUMP_HASHTABLE_STATS_PER_TABLE
1288         , m_stats(std::make_unique&lt;Stats&gt;(*other.m_stats))
1289 #endif
1290     {
1291         unsigned otherKeyCount = other.size();
1292         if (!otherKeyCount)
1293             return;
1294 
1295         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(otherKeyCount) * 2;
1296 
1297         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.
1298         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to
1299         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).
1300         bool aboveThreeQuarterLoad = otherKeyCount * 12 &gt;= bestTableSize * 5;
1301         if (aboveThreeQuarterLoad)
1302             bestTableSize *= 2;
1303 
1304         unsigned minimumTableSize = KeyTraits::minimumTableSize;
1305         m_tableSize = std::max&lt;unsigned&gt;(bestTableSize, minimumTableSize);
1306         m_tableSizeMask = m_tableSize - 1;
1307         m_keyCount = otherKeyCount;
1308         m_table = allocateTable(m_tableSize);
1309 
1310         for (const auto&amp; otherValue : other)
1311             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1312     }
1313 
1314     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1315     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1316     {
1317         invalidateIterators();
1318         other.invalidateIterators();
1319 
1320         std::swap(m_table, other.m_table);
1321         std::swap(m_tableSize, other.m_tableSize);
1322         std::swap(m_tableSizeMask, other.m_tableSizeMask);
1323         std::swap(m_keyCount, other.m_keyCount);
1324         std::swap(m_deletedCount, other.m_deletedCount);
1325 
1326 #if DUMP_HASHTABLE_STATS_PER_TABLE
1327         m_stats.swap(other.m_stats);
1328 #endif
1329     }
1330 
1331     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1332     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1333     {
1334         HashTable tmp(other);
1335         swap(tmp);
1336         return *this;
1337     }
1338 
1339     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1340     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1341 #if CHECK_HASHTABLE_ITERATORS
1342         : m_iterators(nullptr)
1343         , m_mutex(std::make_unique&lt;Lock&gt;())
1344 #endif
1345     {
1346         other.invalidateIterators();
1347 
1348         m_table = other.m_table;
1349         m_tableSize = other.m_tableSize;
1350         m_tableSizeMask = other.m_tableSizeMask;
1351         m_keyCount = other.m_keyCount;
1352         m_deletedCount = other.m_deletedCount;
1353 
1354         other.m_table = nullptr;
1355         other.m_tableSize = 0;
1356         other.m_tableSizeMask = 0;
1357         other.m_keyCount = 0;
1358         other.m_deletedCount = 0;
1359 
1360 #if DUMP_HASHTABLE_STATS_PER_TABLE
1361         m_stats = WTFMove(other.m_stats);
1362         other.m_stats = nullptr;
1363 #endif
1364     }
1365 
1366     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1367     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(HashTable&amp;&amp; other) -&gt; HashTable&amp;
1368     {
1369         HashTable temp = WTFMove(other);
1370         swap(temp);
1371         return *this;
1372     }
1373 
1374 #if !ASSERT_DISABLED
1375 
1376     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1377     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
1378     {
1379         checkTableConsistencyExceptSize();
1380         ASSERT(!m_table || !shouldExpand());
1381         ASSERT(!shouldShrink());
1382     }
1383 
1384     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1385     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1386     {
1387         if (!m_table)
1388             return;
1389 
1390         unsigned count = 0;
1391         unsigned deletedCount = 0;
1392         for (unsigned j = 0; j &lt; m_tableSize; ++j) {
1393             ValueType* entry = m_table + j;
1394             if (isEmptyBucket(*entry))
1395                 continue;
1396 
1397             if (isDeletedBucket(*entry)) {
1398                 ++deletedCount;
1399                 continue;
1400             }
1401 
1402             const_iterator it = find(Extractor::extract(*entry));
1403             ASSERT(entry == it.m_position);
1404             ++count;
1405 
1406             ValueCheck&lt;Key&gt;::checkConsistency(it-&gt;key);
1407         }
1408 
1409         ASSERT(count == m_keyCount);
1410         ASSERT(deletedCount == m_deletedCount);
1411         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);
1412         ASSERT(m_tableSizeMask);
1413         ASSERT(m_tableSize == m_tableSizeMask + 1);
1414     }
1415 
1416 #endif // ASSERT_DISABLED
1417 
1418 #if CHECK_HASHTABLE_ITERATORS
1419 
1420     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1421     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1422     {
1423         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1424         const_iterator* next;
1425         for (const_iterator* p = m_iterators; p; p = next) {
1426             next = p-&gt;m_next;
1427             p-&gt;m_table = 0;
1428             p-&gt;m_next = 0;
1429             p-&gt;m_previous = 0;
1430         }
1431         m_iterators = 0;
1432     }
1433 
1434     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1435     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* table,
1436         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1437     {
1438         it-&gt;m_table = table;
1439         it-&gt;m_previous = 0;
1440 
1441         // Insert iterator at head of doubly-linked list of iterators.
1442         if (!table) {
1443             it-&gt;m_next = 0;
1444         } else {
1445             std::lock_guard&lt;Lock&gt; lock(*table-&gt;m_mutex);
1446             ASSERT(table-&gt;m_iterators != it);
1447             it-&gt;m_next = table-&gt;m_iterators;
1448             table-&gt;m_iterators = it;
1449             if (it-&gt;m_next) {
1450                 ASSERT(!it-&gt;m_next-&gt;m_previous);
1451                 it-&gt;m_next-&gt;m_previous = it;
1452             }
1453         }
1454     }
1455 
1456     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1457     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1458     {
1459         // Delete iterator from doubly-linked list of iterators.
1460         if (!it-&gt;m_table) {
1461             ASSERT(!it-&gt;m_next);
1462             ASSERT(!it-&gt;m_previous);
1463         } else {
1464             std::lock_guard&lt;Lock&gt; lock(*it-&gt;m_table-&gt;m_mutex);
1465             if (it-&gt;m_next) {
1466                 ASSERT(it-&gt;m_next-&gt;m_previous == it);
1467                 it-&gt;m_next-&gt;m_previous = it-&gt;m_previous;
1468             }
1469             if (it-&gt;m_previous) {
1470                 ASSERT(it-&gt;m_table-&gt;m_iterators != it);
1471                 ASSERT(it-&gt;m_previous-&gt;m_next == it);
1472                 it-&gt;m_previous-&gt;m_next = it-&gt;m_next;
1473             } else {
1474                 ASSERT(it-&gt;m_table-&gt;m_iterators == it);
1475                 it-&gt;m_table-&gt;m_iterators = it-&gt;m_next;
1476             }
1477         }
1478 
1479         it-&gt;m_table = 0;
1480         it-&gt;m_next = 0;
1481         it-&gt;m_previous = 0;
1482     }
1483 
1484 #endif // CHECK_HASHTABLE_ITERATORS
1485 
1486     // iterator adapters
1487 
1488     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableConstIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, const ValueType*, const ValueType&amp;&gt; {
1489         HashTableConstIteratorAdapter() {}
1490         HashTableConstIteratorAdapter(const typename HashTableType::const_iterator&amp; impl) : m_impl(impl) {}
1491 
1492         const ValueType* get() const { return (const ValueType*)m_impl.get(); }
1493         const ValueType&amp; operator*() const { return *get(); }
1494         const ValueType* operator-&gt;() const { return get(); }
1495 
1496         HashTableConstIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1497         // postfix ++ intentionally omitted
1498 
1499         typename HashTableType::const_iterator m_impl;
1500     };
1501 
1502     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, ValueType*, ValueType&amp;&gt; {
1503         HashTableIteratorAdapter() {}
1504         HashTableIteratorAdapter(const typename HashTableType::iterator&amp; impl) : m_impl(impl) {}
1505 
1506         ValueType* get() const { return (ValueType*)m_impl.get(); }
1507         ValueType&amp; operator*() const { return *get(); }
1508         ValueType* operator-&gt;() const { return get(); }
1509 
1510         HashTableIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1511         // postfix ++ intentionally omitted
1512 
1513         operator HashTableConstIteratorAdapter&lt;HashTableType, ValueType&gt;() {
1514             typename HashTableType::const_iterator i = m_impl;
1515             return i;
1516         }
1517 
1518         typename HashTableType::iterator m_impl;
1519     };
1520 
1521     template&lt;typename T, typename U&gt;
1522     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1523     {
1524         return a.m_impl == b.m_impl;
1525     }
1526 
1527     template&lt;typename T, typename U&gt;
1528     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1529     {
1530         return a.m_impl != b.m_impl;
1531     }
1532 
1533     template&lt;typename T, typename U&gt;
1534     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1535     {
1536         return a.m_impl == b.m_impl;
1537     }
1538 
1539     template&lt;typename T, typename U&gt;
1540     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1541     {
1542         return a.m_impl != b.m_impl;
1543     }
1544 
1545     // All 4 combinations of ==, != and Const,non const.
1546     template&lt;typename T, typename U&gt;
1547     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1548     {
1549         return a.m_impl == b.m_impl;
1550     }
1551 
1552     template&lt;typename T, typename U&gt;
1553     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1554     {
1555         return a.m_impl != b.m_impl;
1556     }
1557 
1558     template&lt;typename T, typename U&gt;
1559     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1560     {
1561         return a.m_impl == b.m_impl;
1562     }
1563 
1564     template&lt;typename T, typename U&gt;
1565     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1566     {
1567         return a.m_impl != b.m_impl;
1568     }
1569 
1570 } // namespace WTF
1571 
1572 #include &lt;wtf/HashIterators.h&gt;
    </pre>
  </body>
</html>