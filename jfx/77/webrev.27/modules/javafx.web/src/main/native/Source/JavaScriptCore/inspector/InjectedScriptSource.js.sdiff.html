<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InjectedScriptModule.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorBackendDispatcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28  */
  29 
  30 //# sourceURL=__InjectedScript_InjectedScriptSource.js
  31 
  32 (function (InjectedScriptHost, inspectedGlobalObject, injectedScriptId) {
  33 
  34 // FIXME: &lt;https://webkit.org/b/152294&gt; Web Inspector: Parse InjectedScriptSource as a built-in to get guaranteed non-user-overridden built-ins
  35 
  36 var Object = {}.constructor;
  37 
  38 function toString(obj)
  39 {
  40     return String(obj);
  41 }
  42 
  43 function toStringDescription(obj)
  44 {
  45     if (obj === 0 &amp;&amp; 1 / obj &lt; 0)
  46         return &quot;-0&quot;;
  47 



  48     return toString(obj);
  49 }
  50 
  51 function isUInt32(obj)
  52 {
  53     if (typeof obj === &quot;number&quot;)
  54         return obj &gt;&gt;&gt; 0 === obj &amp;&amp; (obj &gt; 0 || 1 / obj &gt; 0);
  55     return &quot;&quot; + (obj &gt;&gt;&gt; 0) === obj;
  56 }
  57 
<span class="line-modified">  58 function isSymbol(obj)</span>





  59 {
<span class="line-modified">  60     return typeof obj === &quot;symbol&quot;;</span>
  61 }
  62 
  63 function isEmptyObject(object)
  64 {
  65     for (let key in object)
  66         return false;
  67     return true;
  68 }
  69 
  70 function isDefined(value)
  71 {
  72     return !!value || InjectedScriptHost.isHTMLAllCollection(value);
  73 }
  74 
  75 function isPrimitiveValue(value)
  76 {
  77     switch (typeof value) {
  78     case &quot;boolean&quot;:
  79     case &quot;number&quot;:
  80     case &quot;string&quot;:
</pre>
<hr />
<pre>
 273         if (typeof object !== &quot;object&quot;)
 274             return;
 275 
 276         let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);
 277         return entries.map(function(entry) {
 278             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 279             if (&quot;key&quot; in entry)
 280                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 281             return entry;
 282         });
 283     }
 284 
 285     saveResult(callArgumentJSON)
 286     {
 287         this._savedResultIndex = 0;
 288 
 289         try {
 290             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 291             let value = this._resolveCallArgument(callArgument);
 292             this._saveResult(value);
<span class="line-modified"> 293         } catch (e) {}</span>
 294 
 295         return this._savedResultIndex;
 296     }
 297 
 298     wrapCallFrames(callFrame)
 299     {
 300         if (!callFrame)
 301             return false;
 302 
 303         let result = [];
 304         let depth = 0;
 305         do {
 306             result.push(new InjectedScript.CallFrameProxy(depth++, callFrame));
 307             callFrame = callFrame.caller;
 308         } while (callFrame);
 309         return result;
 310     }
 311 
 312     wrapObject(object, groupName, canAccessInspectedGlobalObject, generatePreview)
 313     {
</pre>
<hr />
<pre>
 336         // We could filter here to avoid sending very large preview objects.
 337 
 338         let columnNames = null;
 339         if (typeof columns === &quot;string&quot;)
 340             columns = [columns];
 341 
 342         if (InjectedScriptHost.subtype(columns) === &quot;array&quot;) {
 343             columnNames = [];
 344             for (let i = 0; i &lt; columns.length; ++i)
 345                 columnNames.push(toString(columns[i]));
 346         }
 347 
 348         return RemoteObject.create(table, &quot;console&quot;, false, true, columnNames);
 349     }
 350 
 351     previewValue(value)
 352     {
 353         return RemoteObject.createObjectPreviewForValue(value, true);
 354     }
 355 










 356     setExceptionValue(value)
 357     {
 358         this._exceptionValue = value;
 359     }
 360 
 361     clearExceptionValue()
 362     {
 363         delete this._exceptionValue;
 364     }
 365 
 366     findObjectById(objectId)
 367     {
 368         let parsedObjectId = this._parseObjectId(objectId);
 369         return this._objectForId(parsedObjectId);
 370     }
 371 
<span class="line-removed"> 372     inspectObject(object)</span>
<span class="line-removed"> 373     {</span>
<span class="line-removed"> 374         if (this._commandLineAPIImpl)</span>
<span class="line-removed"> 375             this._commandLineAPIImpl.inspect(object);</span>
<span class="line-removed"> 376     }</span>
<span class="line-removed"> 377 </span>
 378     releaseObject(objectId)
 379     {
 380         let parsedObjectId = this._parseObjectId(objectId);
 381         this._releaseObject(parsedObjectId.id);
 382     }
 383 
 384     releaseObjectGroup(objectGroupName)
 385     {
 386         if (objectGroupName === &quot;console&quot;) {
 387             delete this._lastResult;
 388             this._nextSavedResultIndex = 1;
 389             this._savedResults = [];
 390         }
 391 
 392         let group = this._objectGroups[objectGroupName];
 393         if (!group)
 394             return;
 395 
 396         for (let i = 0; i &lt; group.length; i++)
 397             this._releaseObject(group[i]);
 398 
 399         delete this._objectGroups[objectGroupName];
 400     }
 401 








 402     // InjectedScriptModule C++ API
 403 
<span class="line-modified"> 404     module(name)</span>
 405     {
 406         return this._modules[name];
 407     }
 408 
 409     injectModule(name, source, host)
 410     {
<span class="line-modified"> 411         delete this._modules[name];</span>
 412 
 413         let moduleFunction = InjectedScriptHost.evaluate(&quot;(&quot; + source + &quot;)&quot;);
<span class="line-modified"> 414         if (typeof moduleFunction !== &quot;function&quot;) {</span>
<span class="line-modified"> 415             if (inspectedGlobalObject.console)</span>
<span class="line-modified"> 416                 inspectedGlobalObject.console.error(&quot;Web Inspector error: A function was expected for module %s evaluation&quot;, name);</span>
<span class="line-removed"> 417             return null;</span>
<span class="line-removed"> 418         }</span>
 419 
<span class="line-modified"> 420         let module = moduleFunction.call(inspectedGlobalObject, InjectedScriptHost, inspectedGlobalObject, injectedScriptId, this, RemoteObject, host);</span>
<span class="line-removed"> 421         this._modules[name] = module;</span>
<span class="line-removed"> 422         return module;</span>
 423     }
 424 
 425     // InjectedScriptModule JavaScript API
 426 
 427     isPrimitiveValue(value)
 428     {
 429         return isPrimitiveValue(value);
 430     }
 431 
 432     // Private
 433 
 434     _parseObjectId(objectId)
 435     {
 436         return InjectedScriptHost.evaluate(&quot;(&quot; + objectId + &quot;)&quot;);
 437     }
 438 
 439     _objectForId(objectId)
 440     {
 441         return this._idToWrappedObject[objectId.id];
 442     }
</pre>
<hr />
<pre>
 457             group.push(id);
 458             this._idToObjectGroupName[id] = objectGroupName;
 459         }
 460 
 461         return objectId;
 462     }
 463 
 464     _releaseObject(id)
 465     {
 466         delete this._idToWrappedObject[id];
 467         delete this._idToObjectGroupName[id];
 468     }
 469 
 470     _fallbackWrapper(object)
 471     {
 472         let result = {};
 473         result.type = typeof object;
 474         if (isPrimitiveValue(object))
 475             result.value = object;
 476         else
<span class="line-modified"> 477             result.description = toString(object);</span>
 478         return result;
 479     }
 480 
 481     _resolveCallArgument(callArgumentJSON)
 482     {
 483         if (&quot;value&quot; in callArgumentJSON)
 484             return callArgumentJSON.value;
 485 
 486         let objectId = callArgumentJSON.objectId;
 487         if (objectId) {
 488             let parsedArgId = this._parseObjectId(objectId);
 489             if (!parsedArgId || parsedArgId[&quot;injectedScriptId&quot;] !== injectedScriptId)
 490                 throw &quot;Arguments should belong to the same JavaScript world as the target object.&quot;;
 491 
 492             let resolvedArg = this._objectForId(parsedArgId);
 493             if (!isDefined(resolvedArg))
 494                 throw &quot;Could not find object with given id&quot;;
 495 
 496             return resolvedArg;
 497         }
 498 
 499         return undefined;
 500     }
 501 
 502     _createThrownValue(value, objectGroup)
 503     {
 504         let remoteObject = RemoteObject.create(value, objectGroup);
 505         try {
 506             remoteObject.description = toStringDescription(value);
<span class="line-modified"> 507         } catch (e) {}</span>
 508         return {
 509             wasThrown: true,
 510             result: remoteObject
 511         };
 512     }
 513 
 514     _evaluateAndWrap(evalFunction, object, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 515     {
 516         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 517             return this._evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI);
 518         });
 519     }
 520 
 521     _wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 522     {
 523         return this._wrapCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 524             let result = func();
 525             if (saveResult)
 526                 this._saveResult(result);
 527             return result;
</pre>
<hr />
<pre>
 533         try {
 534             this._savedResultIndex = 0;
 535 
 536             let returnObject = {
 537                 wasThrown: false,
 538                 result: RemoteObject.create(func(), objectGroup, returnByValue, generatePreview)
 539             };
 540 
 541             if (saveResult &amp;&amp; this._savedResultIndex)
 542                 returnObject.savedResultIndex = this._savedResultIndex;
 543 
 544             return returnObject;
 545         } catch (e) {
 546             return this._createThrownValue(e, objectGroup);
 547         }
 548     }
 549 
 550     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 551     {
 552         let commandLineAPI = null;
<span class="line-modified"> 553         if (includeCommandLineAPI) {</span>
<span class="line-modified"> 554             if (this.CommandLineAPI)</span>
<span class="line-removed"> 555                 commandLineAPI = new this.CommandLineAPI(this._commandLineAPIImpl, isEvalOnCallFrame ? object : null);</span>
<span class="line-removed"> 556             else</span>
<span class="line-removed"> 557                 commandLineAPI = new BasicCommandLineAPI(isEvalOnCallFrame ? object : null);</span>
<span class="line-removed"> 558         }</span>
<span class="line-removed"> 559 </span>
 560         return evalFunction.call(object, expression, commandLineAPI);
 561     }
 562 
 563     _callFrameForId(topCallFrame, callFrameId)
 564     {
 565         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 566         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 567         let callFrame = topCallFrame;
 568         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 569             callFrame = callFrame.caller;
 570         return callFrame;
 571     }
 572 
 573     _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)
 574     {
 575         let parsedObjectId = this._parseObjectId(objectId);
 576         let object = this._objectForId(parsedObjectId);
 577         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 578 
 579         if (!isDefined(object))
</pre>
<hr />
<pre>
 626 
 627     _propertyDescriptors(object, collectionMode, nativeGettersAsValues)
 628     {
 629         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
 630             return [];
 631 
 632         let descriptors = [];
 633         let nameProcessed = new Set;
 634 
 635         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 636         {
 637             try {
 638                 let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};
 639                 if (possibleNativeBindingGetter)
 640                     fakeDescriptor.nativeGetter = true;
 641                 if (isOwnProperty)
 642                     fakeDescriptor.isOwn = true;
 643                 if (symbol)
 644                     fakeDescriptor.symbol = symbol;
 645                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
<span class="line-modified"> 646                 if (fakeDescriptor.value instanceof Promise)</span>
 647                     fakeDescriptor.value.catch(function(){});
 648                 return fakeDescriptor;
 649             } catch (e) {
 650                 let errorDescriptor = {name, value: e, wasThrown: true};
 651                 if (isOwnProperty)
 652                     errorDescriptor.isOwn = true;
 653                 if (symbol)
 654                     errorDescriptor.symbol = symbol;
 655                 return errorDescriptor;
 656             }
 657         }
 658 
 659         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 660         {
 661             // All properties.
 662             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties) {
 663                 descriptors.push(descriptor);
 664                 return;
 665             }
 666 
</pre>
<hr />
<pre>
 717                     descriptor.symbol = symbol;
 718                 processDescriptor(descriptor, isOwnProperty);
 719             }
 720         }
 721 
 722         function arrayIndexPropertyNames(o, length)
 723         {
 724             let array = [];
 725             for (let i = 0; i &lt; length; ++i) {
 726                 if (i in o)
 727                     array.push(&quot;&quot; + i);
 728             }
 729             return array;
 730         }
 731 
 732         // FIXME: &lt;https://webkit.org/b/143589&gt; Web Inspector: Better handling for large collections in Object Trees
 733         // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.
 734         let isArrayLike = false;
 735         try {
 736             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
<span class="line-modified"> 737         } catch(e) {}</span>
 738 
 739         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 740             let isOwnProperty = o === object;
 741 
 742             if (isArrayLike &amp;&amp; isOwnProperty)
 743                 processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);
 744             else {
 745                 processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);
 746                 if (Object.getOwnPropertySymbols)
 747                     processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);
 748             }
 749 
 750             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 751                 break;
 752         }
 753 
 754         // Always include __proto__ at the end.
 755         try {
 756             if (object.__proto__)
 757                 descriptors.push({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});
<span class="line-modified"> 758         } catch (e) {}</span>
 759 
 760         return descriptors;
 761     }
 762 
 763     _getSetEntries(object, skip, numberToFetch)
 764     {
 765         let entries = [];
 766 
 767         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 768         for (let value of object) {
 769             if (skip &gt; 0) {
 770                 skip--;
 771                 continue;
 772             }
 773 
 774             entries.push({value});
 775 
 776             if (numberToFetch &amp;&amp; entries.length === numberToFetch)
 777                 break;
 778         }
</pre>
<hr />
<pre>
 834     _saveResult(result)
 835     {
 836         this._lastResult = result;
 837 
 838         if (result === undefined || result === null)
 839             return;
 840 
 841         let existingIndex = this._savedResults.indexOf(result);
 842         if (existingIndex !== -1) {
 843             this._savedResultIndex = existingIndex;
 844             return;
 845         }
 846 
 847         this._savedResultIndex = this._nextSavedResultIndex;
 848         this._savedResults[this._nextSavedResultIndex++] = result;
 849 
 850         // $n is limited from $1-$99. $0 is special.
 851         if (this._nextSavedResultIndex &gt;= 100)
 852             this._nextSavedResultIndex = 1;
 853     }
<span class="line-modified"> 854 </span>
<span class="line-removed"> 855     _savedResult(index)</span>
<span class="line-removed"> 856     {</span>
<span class="line-removed"> 857         return this._savedResults[index];</span>
<span class="line-removed"> 858     }</span>
<span class="line-removed"> 859 }</span>
 860 
 861 InjectedScript.CollectionMode = {
 862     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 863     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 864     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 865 };
 866 
 867 var injectedScript = new InjectedScript;
 868 
 869 // -------
 870 
 871 let RemoteObject = class RemoteObject
 872 {
 873     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 874     {
 875         this.type = typeof object;
 876 
 877         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 878             this.type = &quot;object&quot;;
 879 
<span class="line-modified"> 880         if (isPrimitiveValue(object) || object === null || forceValueType) {</span>
 881             // We don&#39;t send undefined values over JSON.
<span class="line-modified"> 882             if (this.type !== &quot;undefined&quot;)</span>

 883                 this.value = object;
 884 
 885             // Null object is object with &#39;null&#39; subtype.
 886             if (object === null)
 887                 this.subtype = &quot;null&quot;;
 888 
 889             // Provide user-friendly number values.
<span class="line-modified"> 890             if (this.type === &quot;number&quot;)</span>
 891                 this.description = toStringDescription(object);

 892             return;
 893         }
 894 
 895         this.objectId = injectedScript._bind(object, objectGroupName);
 896 
 897         let subtype = RemoteObject.subtype(object);
 898         if (subtype)
 899             this.subtype = subtype;
 900 
 901         this.className = InjectedScriptHost.internalConstructorName(object);
 902         this.description = RemoteObject.describe(object);
 903 
 904         if (subtype === &quot;array&quot;)
 905             this.size = typeof object.length === &quot;number&quot; ? object.length : 0;
 906         else if (subtype === &quot;set&quot; || subtype === &quot;map&quot;)
 907             this.size = object.size;
 908         else if (subtype === &quot;weakmap&quot;)
 909             this.size = InjectedScriptHost.weakMapSize(object);
 910         else if (subtype === &quot;weakset&quot;)
 911             this.size = InjectedScriptHost.weakSetSize(object);
</pre>
<hr />
<pre>
 939             }
 940             return new RemoteObject(description);
 941         }
 942     }
 943 
 944     static createObjectPreviewForValue(value, generatePreview, columnNames)
 945     {
 946         let remoteObject = new RemoteObject(value, undefined, false, generatePreview, columnNames);
 947         if (remoteObject.objectId)
 948             injectedScript.releaseObject(remoteObject.objectId);
 949         if (remoteObject.classPrototype &amp;&amp; remoteObject.classPrototype.objectId)
 950             injectedScript.releaseObject(remoteObject.classPrototype.objectId);
 951         return remoteObject.preview || remoteObject._emptyPreview();
 952     }
 953 
 954     static subtype(value)
 955     {
 956         if (value === null)
 957             return &quot;null&quot;;
 958 
<span class="line-modified"> 959         if (isPrimitiveValue(value) || isSymbol(value))</span>
 960             return null;
 961 
 962         if (InjectedScriptHost.isHTMLAllCollection(value))
 963             return &quot;array&quot;;
 964 
 965         let preciseType = InjectedScriptHost.subtype(value);
 966         if (preciseType)
 967             return preciseType;
 968 
 969         // FireBug&#39;s array detection.
 970         try {
 971             if (typeof value.splice === &quot;function&quot; &amp;&amp; isFinite(value.length))
 972                 return &quot;array&quot;;
<span class="line-modified"> 973         } catch (e) {}</span>
 974 
 975         return null;
 976     }
 977 
 978     static describe(value)
 979     {
 980         if (isPrimitiveValue(value))
 981             return null;
 982 



 983         if (isSymbol(value))
 984             return toString(value);
 985 
 986         let subtype = RemoteObject.subtype(value);
 987 
 988         if (subtype === &quot;regexp&quot;)
 989             return toString(value);
 990 
 991         if (subtype === &quot;date&quot;)
 992             return toString(value);
 993 
 994         if (subtype === &quot;error&quot;)
 995             return toString(value);
 996 
 997         if (subtype === &quot;proxy&quot;)
 998             return &quot;Proxy&quot;;
 999 
1000         if (subtype === &quot;node&quot;)
1001             return RemoteObject.nodePreview(value);
1002 
</pre>
<hr />
<pre>
1107 
1108             preview.properties = [];
1109 
1110             // Internal Properties.
1111             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1112             if (internalPropertyDescriptors) {
1113                 this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1114                 if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1115                     return preview;
1116             }
1117 
1118             if (preview.entries)
1119                 return preview;
1120 
1121             // Properties.
1122             let nativeGettersAsValues = true;
1123             let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);
1124             this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1125             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1126                 return preview;
<span class="line-modified">1127         } catch (e) {</span>
1128             preview.lossless = false;
1129         }
1130 
1131         return preview;
1132     }
1133 
1134     _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)
1135     {
1136         for (let i = 0; i &lt; descriptors.length; ++i) {
1137             let descriptor = descriptors[i];
1138 
1139             // Seen enough.
1140             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1141                 break;
1142 
1143             // Error in descriptor.
1144             if (descriptor.wasThrown) {
1145                 preview.lossless = false;
1146                 continue;
1147             }
</pre>
<hr />
<pre>
1181             }
1182 
1183             // Null value.
1184             let value = descriptor.value;
1185             if (value === null) {
1186                 this._appendPropertyPreview(preview, internal, {name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;}, propertiesThreshold);
1187                 continue;
1188             }
1189 
1190             // Ignore non-enumerable functions.
1191             let type = typeof value;
1192             if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)
1193                 continue;
1194 
1195             // Fix type of document.all.
1196             if (InjectedScriptHost.isHTMLAllCollection(value))
1197                 type = &quot;object&quot;;
1198 
1199             // Primitive.
1200             const maxLength = 100;
<span class="line-modified">1201             if (isPrimitiveValue(value)) {</span>
1202                 if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {
1203                     value = this._abbreviateString(value, maxLength, true);
1204                     preview.lossless = false;
1205                 }
1206                 this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);
1207                 continue;
1208             }
1209 
1210             // Symbol.
1211             if (isSymbol(value)) {
1212                 let symbolString = toString(value);
1213                 if (symbolString.length &gt; maxLength) {
1214                     symbolString = this._abbreviateString(symbolString, maxLength, true);
1215                     preview.lossless = false;
1216                 }
1217                 this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);
1218                 continue;
1219             }
1220 
1221             // Object.
</pre>
<hr />
<pre>
1299             }
1300             return entry;
1301         });
1302     }
1303 
1304     _isPreviewableObject(value, object)
1305     {
1306         let set = new Set;
1307         set.add(object);
1308 
1309         return this._isPreviewableObjectInternal(value, set, 1);
1310     }
1311 
1312     _isPreviewableObjectInternal(object, knownObjects, depth)
1313     {
1314         // Deep object.
1315         if (depth &gt; 3)
1316             return false;
1317 
1318         // Primitive.
<span class="line-modified">1319         if (isPrimitiveValue(object) || isSymbol(object))</span>
1320             return true;
1321 
1322         // Null.
1323         if (object === null)
1324             return true;
1325 
1326         // Cyclic objects.
1327         if (knownObjects.has(object))
1328             return false;
1329 
1330         ++depth;
1331         knownObjects.add(object);
1332 
1333         // Arrays are simple if they have 5 or less simple objects.
1334         let subtype = RemoteObject.subtype(object);
1335         if (subtype === &quot;array&quot;) {
1336             let length = object.length;
1337             if (length &gt; 5)
1338                 return false;
1339             for (let i = 0; i &lt; length; ++i) {
</pre>
<hr />
<pre>
1359             if (!this._isPreviewableObjectInternal(object[propertyName], knownObjects, depth))
1360                 return false;
1361         }
1362 
1363         return true;
1364     }
1365 
1366     _abbreviateString(string, maxLength, middle)
1367     {
1368         if (string.length &lt;= maxLength)
1369             return string;
1370 
1371         if (middle) {
1372             let leftHalf = maxLength &gt;&gt; 1;
1373             let rightHalf = maxLength - leftHalf - 1;
1374             return string.substr(0, leftHalf) + &quot;\u2026&quot; + string.substr(string.length - rightHalf, rightHalf);
1375         }
1376 
1377         return string.substr(0, maxLength) + &quot;\u2026&quot;;
1378     }
<span class="line-modified">1379 }</span>
1380 
1381 // -------
1382 
1383 InjectedScript.CallFrameProxy = function(ordinal, callFrame)
1384 {
1385     this.callFrameId = `{&quot;ordinal&quot;:${ordinal},&quot;injectedScriptId&quot;:${injectedScriptId}}`;
1386     this.functionName = callFrame.functionName;
1387     this.location = {scriptId: String(callFrame.sourceID), lineNumber: callFrame.line, columnNumber: callFrame.column};
1388     this.scopeChain = this._wrapScopeChain(callFrame);
1389     this.this = RemoteObject.create(callFrame.thisObject, &quot;backtrace&quot;);
1390     this.isTailDeleted = callFrame.isTailDeleted;
<span class="line-modified">1391 }</span>
1392 
1393 InjectedScript.CallFrameProxy.prototype = {
1394     _wrapScopeChain(callFrame)
1395     {
1396         let scopeChain = callFrame.scopeChain;
1397         let scopeDescriptions = callFrame.scopeDescriptions();
1398 
1399         let scopeChainProxy = [];
1400         for (let i = 0; i &lt; scopeChain.length; i++)
1401             scopeChainProxy[i] = InjectedScript.CallFrameProxy._createScopeJson(scopeChain[i], scopeDescriptions[i], &quot;backtrace&quot;);
1402         return scopeChainProxy;
1403     }
<span class="line-modified">1404 }</span>
1405 
1406 InjectedScript.CallFrameProxy._scopeTypeNames = {
1407     0: &quot;global&quot;, // GLOBAL_SCOPE
1408     1: &quot;with&quot;, // WITH_SCOPE
1409     2: &quot;closure&quot;, // CLOSURE_SCOPE
1410     3: &quot;catch&quot;, // CATCH_SCOPE
1411     4: &quot;functionName&quot;, // FUNCTION_NAME_SCOPE
1412     5: &quot;globalLexicalEnvironment&quot;, // GLOBAL_LEXICAL_ENVIRONMENT_SCOPE
1413     6: &quot;nestedLexical&quot;, // NESTED_LEXICAL_SCOPE
1414 };
1415 
1416 InjectedScript.CallFrameProxy._createScopeJson = function(object, {name, type, location}, groupId)
1417 {
1418     let scope = {
1419         object: RemoteObject.create(object, groupId),
1420         type: InjectedScript.CallFrameProxy._scopeTypeNames[type],
1421     };
1422 
1423     if (name)
1424         scope.name = name;
1425 
1426     if (location)
1427         scope.location = location;
1428 
1429     if (isEmptyObject(object))
1430         scope.empty = true;
1431 
1432     return scope;
1433 }
1434 
1435 // -------
1436 
<span class="line-modified">1437 function bind(func, thisObject, ...outerArgs)</span>
1438 {
<span class="line-modified">1439     return function(...innerArgs) {</span>
<span class="line-removed">1440         return func.apply(thisObject, outerArgs.concat(innerArgs));</span>
<span class="line-removed">1441     };</span>
<span class="line-removed">1442 }</span>
1443 
<span class="line-modified">1444 function BasicCommandLineAPI(callFrame)</span>
<span class="line-modified">1445 {</span>
<span class="line-modified">1446     this.$_ = injectedScript._lastResult;</span>
<span class="line-modified">1447     this.$exception = injectedScript._exceptionValue;</span>

1448 
<span class="line-modified">1449     // $1-$99</span>
<span class="line-modified">1450     for (let i = 1; i &lt;= injectedScript._savedResults.length; ++i)</span>
<span class="line-modified">1451         this.__defineGetter__(&quot;$&quot; + i, bind(injectedScript._savedResult, injectedScript, i));</span>

1452 
<span class="line-modified">1453     // Command Line API methods.</span>
<span class="line-modified">1454     for (let i = 0; i &lt; BasicCommandLineAPI.methods.length; ++i) {</span>
<span class="line-removed">1455         let method = BasicCommandLineAPI.methods[i];</span>
<span class="line-removed">1456         this[method.name] = method;</span>
<span class="line-removed">1457     }</span>
<span class="line-removed">1458 }</span>
1459 
<span class="line-modified">1460 BasicCommandLineAPI.methods = [</span>
<span class="line-modified">1461     function dir() { return inspectedGlobalObject.console.dir(...arguments); },</span>
<span class="line-removed">1462     function clear() { return inspectedGlobalObject.console.clear(...arguments); },</span>
<span class="line-removed">1463     function table() { return inspectedGlobalObject.console.table(...arguments); },</span>
<span class="line-removed">1464     function profile() { return inspectedGlobalObject.console.profile(...arguments); },</span>
<span class="line-removed">1465     function profileEnd() { return inspectedGlobalObject.console.profileEnd(...arguments); },</span>
1466 
<span class="line-modified">1467     function keys(object) { return Object.keys(object); },</span>
<span class="line-modified">1468     function values(object) {</span>
<span class="line-removed">1469         let result = [];</span>
<span class="line-removed">1470         for (let key in object)</span>
<span class="line-removed">1471             result.push(object[key]);</span>
<span class="line-removed">1472         return result;</span>
<span class="line-removed">1473     },</span>
1474 
<span class="line-modified">1475     function queryObjects() {</span>
<span class="line-modified">1476         return InjectedScriptHost.queryObjects(...arguments);</span>
<span class="line-modified">1477     },</span>
<span class="line-modified">1478 ];</span>


1479 
<span class="line-modified">1480 for (let i = 0; i &lt; BasicCommandLineAPI.methods.length; ++i) {</span>
<span class="line-modified">1481     let method = BasicCommandLineAPI.methods[i];</span>
<span class="line-removed">1482     method.toString = function() { return &quot;function &quot; + method.name + &quot;() { [Command Line API] }&quot;; };</span>
1483 }
1484 











































1485 return injectedScript;
1486 })
</pre>
</td>
<td>
<hr />
<pre>
  28  */
  29 
  30 //# sourceURL=__InjectedScript_InjectedScriptSource.js
  31 
  32 (function (InjectedScriptHost, inspectedGlobalObject, injectedScriptId) {
  33 
  34 // FIXME: &lt;https://webkit.org/b/152294&gt; Web Inspector: Parse InjectedScriptSource as a built-in to get guaranteed non-user-overridden built-ins
  35 
  36 var Object = {}.constructor;
  37 
  38 function toString(obj)
  39 {
  40     return String(obj);
  41 }
  42 
  43 function toStringDescription(obj)
  44 {
  45     if (obj === 0 &amp;&amp; 1 / obj &lt; 0)
  46         return &quot;-0&quot;;
  47 
<span class="line-added">  48     if (isBigInt(obj))</span>
<span class="line-added">  49         return toString(obj) + &quot;n&quot;;</span>
<span class="line-added">  50 </span>
  51     return toString(obj);
  52 }
  53 
  54 function isUInt32(obj)
  55 {
  56     if (typeof obj === &quot;number&quot;)
  57         return obj &gt;&gt;&gt; 0 === obj &amp;&amp; (obj &gt; 0 || 1 / obj &gt; 0);
  58     return &quot;&quot; + (obj &gt;&gt;&gt; 0) === obj;
  59 }
  60 
<span class="line-modified">  61 function isSymbol(value)</span>
<span class="line-added">  62 {</span>
<span class="line-added">  63     return typeof value === &quot;symbol&quot;;</span>
<span class="line-added">  64 }</span>
<span class="line-added">  65 </span>
<span class="line-added">  66 function isBigInt(value)</span>
  67 {
<span class="line-modified">  68     return typeof value === &quot;bigint&quot;;</span>
  69 }
  70 
  71 function isEmptyObject(object)
  72 {
  73     for (let key in object)
  74         return false;
  75     return true;
  76 }
  77 
  78 function isDefined(value)
  79 {
  80     return !!value || InjectedScriptHost.isHTMLAllCollection(value);
  81 }
  82 
  83 function isPrimitiveValue(value)
  84 {
  85     switch (typeof value) {
  86     case &quot;boolean&quot;:
  87     case &quot;number&quot;:
  88     case &quot;string&quot;:
</pre>
<hr />
<pre>
 281         if (typeof object !== &quot;object&quot;)
 282             return;
 283 
 284         let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);
 285         return entries.map(function(entry) {
 286             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 287             if (&quot;key&quot; in entry)
 288                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 289             return entry;
 290         });
 291     }
 292 
 293     saveResult(callArgumentJSON)
 294     {
 295         this._savedResultIndex = 0;
 296 
 297         try {
 298             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 299             let value = this._resolveCallArgument(callArgument);
 300             this._saveResult(value);
<span class="line-modified"> 301         } catch { }</span>
 302 
 303         return this._savedResultIndex;
 304     }
 305 
 306     wrapCallFrames(callFrame)
 307     {
 308         if (!callFrame)
 309             return false;
 310 
 311         let result = [];
 312         let depth = 0;
 313         do {
 314             result.push(new InjectedScript.CallFrameProxy(depth++, callFrame));
 315             callFrame = callFrame.caller;
 316         } while (callFrame);
 317         return result;
 318     }
 319 
 320     wrapObject(object, groupName, canAccessInspectedGlobalObject, generatePreview)
 321     {
</pre>
<hr />
<pre>
 344         // We could filter here to avoid sending very large preview objects.
 345 
 346         let columnNames = null;
 347         if (typeof columns === &quot;string&quot;)
 348             columns = [columns];
 349 
 350         if (InjectedScriptHost.subtype(columns) === &quot;array&quot;) {
 351             columnNames = [];
 352             for (let i = 0; i &lt; columns.length; ++i)
 353                 columnNames.push(toString(columns[i]));
 354         }
 355 
 356         return RemoteObject.create(table, &quot;console&quot;, false, true, columnNames);
 357     }
 358 
 359     previewValue(value)
 360     {
 361         return RemoteObject.createObjectPreviewForValue(value, true);
 362     }
 363 
<span class="line-added"> 364     setEventValue(value)</span>
<span class="line-added"> 365     {</span>
<span class="line-added"> 366         this._eventValue = value;</span>
<span class="line-added"> 367     }</span>
<span class="line-added"> 368 </span>
<span class="line-added"> 369     clearEventValue()</span>
<span class="line-added"> 370     {</span>
<span class="line-added"> 371         delete this._eventValue;</span>
<span class="line-added"> 372     }</span>
<span class="line-added"> 373 </span>
 374     setExceptionValue(value)
 375     {
 376         this._exceptionValue = value;
 377     }
 378 
 379     clearExceptionValue()
 380     {
 381         delete this._exceptionValue;
 382     }
 383 
 384     findObjectById(objectId)
 385     {
 386         let parsedObjectId = this._parseObjectId(objectId);
 387         return this._objectForId(parsedObjectId);
 388     }
 389 






 390     releaseObject(objectId)
 391     {
 392         let parsedObjectId = this._parseObjectId(objectId);
 393         this._releaseObject(parsedObjectId.id);
 394     }
 395 
 396     releaseObjectGroup(objectGroupName)
 397     {
 398         if (objectGroupName === &quot;console&quot;) {
 399             delete this._lastResult;
 400             this._nextSavedResultIndex = 1;
 401             this._savedResults = [];
 402         }
 403 
 404         let group = this._objectGroups[objectGroupName];
 405         if (!group)
 406             return;
 407 
 408         for (let i = 0; i &lt; group.length; i++)
 409             this._releaseObject(group[i]);
 410 
 411         delete this._objectGroups[objectGroupName];
 412     }
 413 
<span class="line-added"> 414     // CommandLineAPI</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416     inspectObject(object)</span>
<span class="line-added"> 417     {</span>
<span class="line-added"> 418         if (this._inspectObject)</span>
<span class="line-added"> 419             this._inspectObject(object);</span>
<span class="line-added"> 420     }</span>
<span class="line-added"> 421 </span>
 422     // InjectedScriptModule C++ API
 423 
<span class="line-modified"> 424     hasInjectedModule(name)</span>
 425     {
 426         return this._modules[name];
 427     }
 428 
 429     injectModule(name, source, host)
 430     {
<span class="line-modified"> 431         this._modules[name] = false;</span>
 432 
 433         let moduleFunction = InjectedScriptHost.evaluate(&quot;(&quot; + source + &quot;)&quot;);
<span class="line-modified"> 434         if (typeof moduleFunction !== &quot;function&quot;)</span>
<span class="line-modified"> 435             throw &quot;Error: Web Inspector: a function was expected for injectModule&quot;;</span>
<span class="line-modified"> 436         moduleFunction(InjectedScriptHost, inspectedGlobalObject, injectedScriptId, this, {RemoteObject, CommandLineAPI}, host);</span>


 437 
<span class="line-modified"> 438         this._modules[name] = true;</span>


 439     }
 440 
 441     // InjectedScriptModule JavaScript API
 442 
 443     isPrimitiveValue(value)
 444     {
 445         return isPrimitiveValue(value);
 446     }
 447 
 448     // Private
 449 
 450     _parseObjectId(objectId)
 451     {
 452         return InjectedScriptHost.evaluate(&quot;(&quot; + objectId + &quot;)&quot;);
 453     }
 454 
 455     _objectForId(objectId)
 456     {
 457         return this._idToWrappedObject[objectId.id];
 458     }
</pre>
<hr />
<pre>
 473             group.push(id);
 474             this._idToObjectGroupName[id] = objectGroupName;
 475         }
 476 
 477         return objectId;
 478     }
 479 
 480     _releaseObject(id)
 481     {
 482         delete this._idToWrappedObject[id];
 483         delete this._idToObjectGroupName[id];
 484     }
 485 
 486     _fallbackWrapper(object)
 487     {
 488         let result = {};
 489         result.type = typeof object;
 490         if (isPrimitiveValue(object))
 491             result.value = object;
 492         else
<span class="line-modified"> 493             result.description = toStringDescription(object);</span>
 494         return result;
 495     }
 496 
 497     _resolveCallArgument(callArgumentJSON)
 498     {
 499         if (&quot;value&quot; in callArgumentJSON)
 500             return callArgumentJSON.value;
 501 
 502         let objectId = callArgumentJSON.objectId;
 503         if (objectId) {
 504             let parsedArgId = this._parseObjectId(objectId);
 505             if (!parsedArgId || parsedArgId[&quot;injectedScriptId&quot;] !== injectedScriptId)
 506                 throw &quot;Arguments should belong to the same JavaScript world as the target object.&quot;;
 507 
 508             let resolvedArg = this._objectForId(parsedArgId);
 509             if (!isDefined(resolvedArg))
 510                 throw &quot;Could not find object with given id&quot;;
 511 
 512             return resolvedArg;
 513         }
 514 
 515         return undefined;
 516     }
 517 
 518     _createThrownValue(value, objectGroup)
 519     {
 520         let remoteObject = RemoteObject.create(value, objectGroup);
 521         try {
 522             remoteObject.description = toStringDescription(value);
<span class="line-modified"> 523         } catch { }</span>
 524         return {
 525             wasThrown: true,
 526             result: remoteObject
 527         };
 528     }
 529 
 530     _evaluateAndWrap(evalFunction, object, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 531     {
 532         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 533             return this._evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI);
 534         });
 535     }
 536 
 537     _wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 538     {
 539         return this._wrapCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 540             let result = func();
 541             if (saveResult)
 542                 this._saveResult(result);
 543             return result;
</pre>
<hr />
<pre>
 549         try {
 550             this._savedResultIndex = 0;
 551 
 552             let returnObject = {
 553                 wasThrown: false,
 554                 result: RemoteObject.create(func(), objectGroup, returnByValue, generatePreview)
 555             };
 556 
 557             if (saveResult &amp;&amp; this._savedResultIndex)
 558                 returnObject.savedResultIndex = this._savedResultIndex;
 559 
 560             return returnObject;
 561         } catch (e) {
 562             return this._createThrownValue(e, objectGroup);
 563         }
 564     }
 565 
 566     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 567     {
 568         let commandLineAPI = null;
<span class="line-modified"> 569         if (includeCommandLineAPI)</span>
<span class="line-modified"> 570             commandLineAPI = new CommandLineAPI(isEvalOnCallFrame ? object : null);</span>





 571         return evalFunction.call(object, expression, commandLineAPI);
 572     }
 573 
 574     _callFrameForId(topCallFrame, callFrameId)
 575     {
 576         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 577         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 578         let callFrame = topCallFrame;
 579         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 580             callFrame = callFrame.caller;
 581         return callFrame;
 582     }
 583 
 584     _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)
 585     {
 586         let parsedObjectId = this._parseObjectId(objectId);
 587         let object = this._objectForId(parsedObjectId);
 588         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 589 
 590         if (!isDefined(object))
</pre>
<hr />
<pre>
 637 
 638     _propertyDescriptors(object, collectionMode, nativeGettersAsValues)
 639     {
 640         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
 641             return [];
 642 
 643         let descriptors = [];
 644         let nameProcessed = new Set;
 645 
 646         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 647         {
 648             try {
 649                 let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};
 650                 if (possibleNativeBindingGetter)
 651                     fakeDescriptor.nativeGetter = true;
 652                 if (isOwnProperty)
 653                     fakeDescriptor.isOwn = true;
 654                 if (symbol)
 655                     fakeDescriptor.symbol = symbol;
 656                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
<span class="line-modified"> 657                 if (fakeDescriptor.value instanceof Promise &amp;&amp; InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError(fakeDescriptor.value))</span>
 658                     fakeDescriptor.value.catch(function(){});
 659                 return fakeDescriptor;
 660             } catch (e) {
 661                 let errorDescriptor = {name, value: e, wasThrown: true};
 662                 if (isOwnProperty)
 663                     errorDescriptor.isOwn = true;
 664                 if (symbol)
 665                     errorDescriptor.symbol = symbol;
 666                 return errorDescriptor;
 667             }
 668         }
 669 
 670         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 671         {
 672             // All properties.
 673             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties) {
 674                 descriptors.push(descriptor);
 675                 return;
 676             }
 677 
</pre>
<hr />
<pre>
 728                     descriptor.symbol = symbol;
 729                 processDescriptor(descriptor, isOwnProperty);
 730             }
 731         }
 732 
 733         function arrayIndexPropertyNames(o, length)
 734         {
 735             let array = [];
 736             for (let i = 0; i &lt; length; ++i) {
 737                 if (i in o)
 738                     array.push(&quot;&quot; + i);
 739             }
 740             return array;
 741         }
 742 
 743         // FIXME: &lt;https://webkit.org/b/143589&gt; Web Inspector: Better handling for large collections in Object Trees
 744         // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.
 745         let isArrayLike = false;
 746         try {
 747             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
<span class="line-modified"> 748         } catch { }</span>
 749 
 750         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 751             let isOwnProperty = o === object;
 752 
 753             if (isArrayLike &amp;&amp; isOwnProperty)
 754                 processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);
 755             else {
 756                 processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);
 757                 if (Object.getOwnPropertySymbols)
 758                     processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);
 759             }
 760 
 761             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 762                 break;
 763         }
 764 
 765         // Always include __proto__ at the end.
 766         try {
 767             if (object.__proto__)
 768                 descriptors.push({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});
<span class="line-modified"> 769         } catch { }</span>
 770 
 771         return descriptors;
 772     }
 773 
 774     _getSetEntries(object, skip, numberToFetch)
 775     {
 776         let entries = [];
 777 
 778         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 779         for (let value of object) {
 780             if (skip &gt; 0) {
 781                 skip--;
 782                 continue;
 783             }
 784 
 785             entries.push({value});
 786 
 787             if (numberToFetch &amp;&amp; entries.length === numberToFetch)
 788                 break;
 789         }
</pre>
<hr />
<pre>
 845     _saveResult(result)
 846     {
 847         this._lastResult = result;
 848 
 849         if (result === undefined || result === null)
 850             return;
 851 
 852         let existingIndex = this._savedResults.indexOf(result);
 853         if (existingIndex !== -1) {
 854             this._savedResultIndex = existingIndex;
 855             return;
 856         }
 857 
 858         this._savedResultIndex = this._nextSavedResultIndex;
 859         this._savedResults[this._nextSavedResultIndex++] = result;
 860 
 861         // $n is limited from $1-$99. $0 is special.
 862         if (this._nextSavedResultIndex &gt;= 100)
 863             this._nextSavedResultIndex = 1;
 864     }
<span class="line-modified"> 865 };</span>





 866 
 867 InjectedScript.CollectionMode = {
 868     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 869     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 870     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 871 };
 872 
 873 var injectedScript = new InjectedScript;
 874 
 875 // -------
 876 
 877 let RemoteObject = class RemoteObject
 878 {
 879     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 880     {
 881         this.type = typeof object;
 882 
 883         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 884             this.type = &quot;object&quot;;
 885 
<span class="line-modified"> 886         if (isPrimitiveValue(object) || isBigInt(object) || object === null || forceValueType) {</span>
 887             // We don&#39;t send undefined values over JSON.
<span class="line-modified"> 888             // BigInt values are not JSON serializable.</span>
<span class="line-added"> 889             if (this.type !== &quot;undefined&quot; &amp;&amp; this.type !== &quot;bigint&quot;)</span>
 890                 this.value = object;
 891 
 892             // Null object is object with &#39;null&#39; subtype.
 893             if (object === null)
 894                 this.subtype = &quot;null&quot;;
 895 
 896             // Provide user-friendly number values.
<span class="line-modified"> 897             if (this.type === &quot;number&quot; || this.type === &quot;bigint&quot;)</span>
 898                 this.description = toStringDescription(object);
<span class="line-added"> 899 </span>
 900             return;
 901         }
 902 
 903         this.objectId = injectedScript._bind(object, objectGroupName);
 904 
 905         let subtype = RemoteObject.subtype(object);
 906         if (subtype)
 907             this.subtype = subtype;
 908 
 909         this.className = InjectedScriptHost.internalConstructorName(object);
 910         this.description = RemoteObject.describe(object);
 911 
 912         if (subtype === &quot;array&quot;)
 913             this.size = typeof object.length === &quot;number&quot; ? object.length : 0;
 914         else if (subtype === &quot;set&quot; || subtype === &quot;map&quot;)
 915             this.size = object.size;
 916         else if (subtype === &quot;weakmap&quot;)
 917             this.size = InjectedScriptHost.weakMapSize(object);
 918         else if (subtype === &quot;weakset&quot;)
 919             this.size = InjectedScriptHost.weakSetSize(object);
</pre>
<hr />
<pre>
 947             }
 948             return new RemoteObject(description);
 949         }
 950     }
 951 
 952     static createObjectPreviewForValue(value, generatePreview, columnNames)
 953     {
 954         let remoteObject = new RemoteObject(value, undefined, false, generatePreview, columnNames);
 955         if (remoteObject.objectId)
 956             injectedScript.releaseObject(remoteObject.objectId);
 957         if (remoteObject.classPrototype &amp;&amp; remoteObject.classPrototype.objectId)
 958             injectedScript.releaseObject(remoteObject.classPrototype.objectId);
 959         return remoteObject.preview || remoteObject._emptyPreview();
 960     }
 961 
 962     static subtype(value)
 963     {
 964         if (value === null)
 965             return &quot;null&quot;;
 966 
<span class="line-modified"> 967         if (isPrimitiveValue(value) || isBigInt(value) || isSymbol(value))</span>
 968             return null;
 969 
 970         if (InjectedScriptHost.isHTMLAllCollection(value))
 971             return &quot;array&quot;;
 972 
 973         let preciseType = InjectedScriptHost.subtype(value);
 974         if (preciseType)
 975             return preciseType;
 976 
 977         // FireBug&#39;s array detection.
 978         try {
 979             if (typeof value.splice === &quot;function&quot; &amp;&amp; isFinite(value.length))
 980                 return &quot;array&quot;;
<span class="line-modified"> 981         } catch { }</span>
 982 
 983         return null;
 984     }
 985 
 986     static describe(value)
 987     {
 988         if (isPrimitiveValue(value))
 989             return null;
 990 
<span class="line-added"> 991         if (isBigInt(value))</span>
<span class="line-added"> 992             return null;</span>
<span class="line-added"> 993 </span>
 994         if (isSymbol(value))
 995             return toString(value);
 996 
 997         let subtype = RemoteObject.subtype(value);
 998 
 999         if (subtype === &quot;regexp&quot;)
1000             return toString(value);
1001 
1002         if (subtype === &quot;date&quot;)
1003             return toString(value);
1004 
1005         if (subtype === &quot;error&quot;)
1006             return toString(value);
1007 
1008         if (subtype === &quot;proxy&quot;)
1009             return &quot;Proxy&quot;;
1010 
1011         if (subtype === &quot;node&quot;)
1012             return RemoteObject.nodePreview(value);
1013 
</pre>
<hr />
<pre>
1118 
1119             preview.properties = [];
1120 
1121             // Internal Properties.
1122             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1123             if (internalPropertyDescriptors) {
1124                 this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1125                 if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1126                     return preview;
1127             }
1128 
1129             if (preview.entries)
1130                 return preview;
1131 
1132             // Properties.
1133             let nativeGettersAsValues = true;
1134             let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);
1135             this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1136             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1137                 return preview;
<span class="line-modified">1138         } catch {</span>
1139             preview.lossless = false;
1140         }
1141 
1142         return preview;
1143     }
1144 
1145     _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)
1146     {
1147         for (let i = 0; i &lt; descriptors.length; ++i) {
1148             let descriptor = descriptors[i];
1149 
1150             // Seen enough.
1151             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)
1152                 break;
1153 
1154             // Error in descriptor.
1155             if (descriptor.wasThrown) {
1156                 preview.lossless = false;
1157                 continue;
1158             }
</pre>
<hr />
<pre>
1192             }
1193 
1194             // Null value.
1195             let value = descriptor.value;
1196             if (value === null) {
1197                 this._appendPropertyPreview(preview, internal, {name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;}, propertiesThreshold);
1198                 continue;
1199             }
1200 
1201             // Ignore non-enumerable functions.
1202             let type = typeof value;
1203             if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)
1204                 continue;
1205 
1206             // Fix type of document.all.
1207             if (InjectedScriptHost.isHTMLAllCollection(value))
1208                 type = &quot;object&quot;;
1209 
1210             // Primitive.
1211             const maxLength = 100;
<span class="line-modified">1212             if (isPrimitiveValue(value) || isBigInt(value)) {</span>
1213                 if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {
1214                     value = this._abbreviateString(value, maxLength, true);
1215                     preview.lossless = false;
1216                 }
1217                 this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);
1218                 continue;
1219             }
1220 
1221             // Symbol.
1222             if (isSymbol(value)) {
1223                 let symbolString = toString(value);
1224                 if (symbolString.length &gt; maxLength) {
1225                     symbolString = this._abbreviateString(symbolString, maxLength, true);
1226                     preview.lossless = false;
1227                 }
1228                 this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);
1229                 continue;
1230             }
1231 
1232             // Object.
</pre>
<hr />
<pre>
1310             }
1311             return entry;
1312         });
1313     }
1314 
1315     _isPreviewableObject(value, object)
1316     {
1317         let set = new Set;
1318         set.add(object);
1319 
1320         return this._isPreviewableObjectInternal(value, set, 1);
1321     }
1322 
1323     _isPreviewableObjectInternal(object, knownObjects, depth)
1324     {
1325         // Deep object.
1326         if (depth &gt; 3)
1327             return false;
1328 
1329         // Primitive.
<span class="line-modified">1330         if (isPrimitiveValue(object) || isBigInt(object) || isSymbol(object))</span>
1331             return true;
1332 
1333         // Null.
1334         if (object === null)
1335             return true;
1336 
1337         // Cyclic objects.
1338         if (knownObjects.has(object))
1339             return false;
1340 
1341         ++depth;
1342         knownObjects.add(object);
1343 
1344         // Arrays are simple if they have 5 or less simple objects.
1345         let subtype = RemoteObject.subtype(object);
1346         if (subtype === &quot;array&quot;) {
1347             let length = object.length;
1348             if (length &gt; 5)
1349                 return false;
1350             for (let i = 0; i &lt; length; ++i) {
</pre>
<hr />
<pre>
1370             if (!this._isPreviewableObjectInternal(object[propertyName], knownObjects, depth))
1371                 return false;
1372         }
1373 
1374         return true;
1375     }
1376 
1377     _abbreviateString(string, maxLength, middle)
1378     {
1379         if (string.length &lt;= maxLength)
1380             return string;
1381 
1382         if (middle) {
1383             let leftHalf = maxLength &gt;&gt; 1;
1384             let rightHalf = maxLength - leftHalf - 1;
1385             return string.substr(0, leftHalf) + &quot;\u2026&quot; + string.substr(string.length - rightHalf, rightHalf);
1386         }
1387 
1388         return string.substr(0, maxLength) + &quot;\u2026&quot;;
1389     }
<span class="line-modified">1390 };</span>
1391 
1392 // -------
1393 
1394 InjectedScript.CallFrameProxy = function(ordinal, callFrame)
1395 {
1396     this.callFrameId = `{&quot;ordinal&quot;:${ordinal},&quot;injectedScriptId&quot;:${injectedScriptId}}`;
1397     this.functionName = callFrame.functionName;
1398     this.location = {scriptId: String(callFrame.sourceID), lineNumber: callFrame.line, columnNumber: callFrame.column};
1399     this.scopeChain = this._wrapScopeChain(callFrame);
1400     this.this = RemoteObject.create(callFrame.thisObject, &quot;backtrace&quot;);
1401     this.isTailDeleted = callFrame.isTailDeleted;
<span class="line-modified">1402 };</span>
1403 
1404 InjectedScript.CallFrameProxy.prototype = {
1405     _wrapScopeChain(callFrame)
1406     {
1407         let scopeChain = callFrame.scopeChain;
1408         let scopeDescriptions = callFrame.scopeDescriptions();
1409 
1410         let scopeChainProxy = [];
1411         for (let i = 0; i &lt; scopeChain.length; i++)
1412             scopeChainProxy[i] = InjectedScript.CallFrameProxy._createScopeJson(scopeChain[i], scopeDescriptions[i], &quot;backtrace&quot;);
1413         return scopeChainProxy;
1414     }
<span class="line-modified">1415 };</span>
1416 
1417 InjectedScript.CallFrameProxy._scopeTypeNames = {
1418     0: &quot;global&quot;, // GLOBAL_SCOPE
1419     1: &quot;with&quot;, // WITH_SCOPE
1420     2: &quot;closure&quot;, // CLOSURE_SCOPE
1421     3: &quot;catch&quot;, // CATCH_SCOPE
1422     4: &quot;functionName&quot;, // FUNCTION_NAME_SCOPE
1423     5: &quot;globalLexicalEnvironment&quot;, // GLOBAL_LEXICAL_ENVIRONMENT_SCOPE
1424     6: &quot;nestedLexical&quot;, // NESTED_LEXICAL_SCOPE
1425 };
1426 
1427 InjectedScript.CallFrameProxy._createScopeJson = function(object, {name, type, location}, groupId)
1428 {
1429     let scope = {
1430         object: RemoteObject.create(object, groupId),
1431         type: InjectedScript.CallFrameProxy._scopeTypeNames[type],
1432     };
1433 
1434     if (name)
1435         scope.name = name;
1436 
1437     if (location)
1438         scope.location = location;
1439 
1440     if (isEmptyObject(object))
1441         scope.empty = true;
1442 
1443     return scope;
1444 }
1445 
1446 // -------
1447 
<span class="line-modified">1448 function CommandLineAPI(callFrame)</span>
1449 {
<span class="line-modified">1450     let savedResultAlias = InjectedScriptHost.savedResultAlias;</span>



1451 
<span class="line-modified">1452     let defineGetter = (key, value) =&gt; {</span>
<span class="line-modified">1453         if (typeof value !== &quot;function&quot;) {</span>
<span class="line-modified">1454             let originalValue = value;</span>
<span class="line-modified">1455             value = function() { return originalValue; };</span>
<span class="line-added">1456         }</span>
1457 
<span class="line-modified">1458         this.__defineGetter__(&quot;$&quot; + key, value);</span>
<span class="line-modified">1459         if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)</span>
<span class="line-modified">1460             this.__defineGetter__(savedResultAlias + key, value);</span>
<span class="line-added">1461     };</span>
1462 
<span class="line-modified">1463     if (&quot;_lastResult&quot; in injectedScript)</span>
<span class="line-modified">1464         defineGetter(&quot;_&quot;, injectedScript._lastResult);</span>




1465 
<span class="line-modified">1466     if (&quot;_exceptionValue&quot; in injectedScript)</span>
<span class="line-modified">1467         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue);</span>




1468 
<span class="line-modified">1469     if (&quot;_eventValue&quot; in injectedScript)</span>
<span class="line-modified">1470         defineGetter(&quot;event&quot;, injectedScript._eventValue);</span>





1471 
<span class="line-modified">1472     // $1-$99</span>
<span class="line-modified">1473     for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)</span>
<span class="line-modified">1474         defineGetter(i, injectedScript._savedResults[i]);</span>
<span class="line-modified">1475 </span>
<span class="line-added">1476     for (let name in CommandLineAPI.getters)</span>
<span class="line-added">1477         defineGetter(name, CommandLineAPI.getters[name]);</span>
1478 
<span class="line-modified">1479     for (let name in CommandLineAPI.methods)</span>
<span class="line-modified">1480         this[name] = CommandLineAPI.methods[name];</span>

1481 }
1482 
<span class="line-added">1483 CommandLineAPI.getters = {};</span>
<span class="line-added">1484 </span>
<span class="line-added">1485 CommandLineAPI.methods = {};</span>
<span class="line-added">1486 </span>
<span class="line-added">1487 CommandLineAPI.methods[&quot;keys&quot;] = function(object) { return Object.keys(object); };</span>
<span class="line-added">1488 CommandLineAPI.methods[&quot;values&quot;] = function(object) { return Object.values(object); };</span>
<span class="line-added">1489 </span>
<span class="line-added">1490 CommandLineAPI.methods[&quot;queryInstances&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };</span>
<span class="line-added">1491 CommandLineAPI.methods[&quot;queryObjects&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };</span>
<span class="line-added">1492 CommandLineAPI.methods[&quot;queryHolders&quot;] = function() { return InjectedScriptHost.queryHolders(...arguments); };</span>
<span class="line-added">1493 </span>
<span class="line-added">1494 CommandLineAPI.methods[&quot;inspect&quot;] = function(object) { return injectedScript.inspectObject(object); };</span>
<span class="line-added">1495 </span>
<span class="line-added">1496 CommandLineAPI.methods[&quot;assert&quot;] = function() { return inspectedGlobalObject.console.assert(...arguments); };</span>
<span class="line-added">1497 CommandLineAPI.methods[&quot;clear&quot;] = function() { return inspectedGlobalObject.console.clear(...arguments); };</span>
<span class="line-added">1498 CommandLineAPI.methods[&quot;count&quot;] = function() { return inspectedGlobalObject.console.count(...arguments); };</span>
<span class="line-added">1499 CommandLineAPI.methods[&quot;countReset&quot;] = function() { return inspectedGlobalObject.console.countReset(...arguments); };</span>
<span class="line-added">1500 CommandLineAPI.methods[&quot;debug&quot;] = function() { return inspectedGlobalObject.console.debug(...arguments); };</span>
<span class="line-added">1501 CommandLineAPI.methods[&quot;dir&quot;] = function() { return inspectedGlobalObject.console.dir(...arguments); };</span>
<span class="line-added">1502 CommandLineAPI.methods[&quot;dirxml&quot;] = function() { return inspectedGlobalObject.console.dirxml(...arguments); };</span>
<span class="line-added">1503 CommandLineAPI.methods[&quot;error&quot;] = function() { return inspectedGlobalObject.console.error(...arguments); };</span>
<span class="line-added">1504 CommandLineAPI.methods[&quot;group&quot;] = function() { return inspectedGlobalObject.console.group(...arguments); };</span>
<span class="line-added">1505 CommandLineAPI.methods[&quot;groupCollapsed&quot;] = function() { return inspectedGlobalObject.console.groupCollapsed(...arguments); };</span>
<span class="line-added">1506 CommandLineAPI.methods[&quot;groupEnd&quot;] = function() { return inspectedGlobalObject.console.groupEnd(...arguments); };</span>
<span class="line-added">1507 CommandLineAPI.methods[&quot;info&quot;] = function() { return inspectedGlobalObject.console.info(...arguments); };</span>
<span class="line-added">1508 CommandLineAPI.methods[&quot;log&quot;] = function() { return inspectedGlobalObject.console.log(...arguments); };</span>
<span class="line-added">1509 CommandLineAPI.methods[&quot;profile&quot;] = function() { return inspectedGlobalObject.console.profile(...arguments); };</span>
<span class="line-added">1510 CommandLineAPI.methods[&quot;profileEnd&quot;] = function() { return inspectedGlobalObject.console.profileEnd(...arguments); };</span>
<span class="line-added">1511 CommandLineAPI.methods[&quot;record&quot;] = function() { return inspectedGlobalObject.console.record(...arguments); };</span>
<span class="line-added">1512 CommandLineAPI.methods[&quot;recordEnd&quot;] = function() { return inspectedGlobalObject.console.recordEnd(...arguments); };</span>
<span class="line-added">1513 CommandLineAPI.methods[&quot;screenshot&quot;] = function() { return inspectedGlobalObject.console.screenshot(...arguments); };</span>
<span class="line-added">1514 CommandLineAPI.methods[&quot;table&quot;] = function() { return inspectedGlobalObject.console.table(...arguments); };</span>
<span class="line-added">1515 CommandLineAPI.methods[&quot;takeHeapSnapshot&quot;] = function() { return inspectedGlobalObject.console.takeHeapSnapshot(...arguments); };</span>
<span class="line-added">1516 CommandLineAPI.methods[&quot;time&quot;] = function() { return inspectedGlobalObject.console.time(...arguments); };</span>
<span class="line-added">1517 CommandLineAPI.methods[&quot;timeEnd&quot;] = function() { return inspectedGlobalObject.console.timeEnd(...arguments); };</span>
<span class="line-added">1518 CommandLineAPI.methods[&quot;timeLog&quot;] = function() { return inspectedGlobalObject.console.timeLog(...arguments); };</span>
<span class="line-added">1519 CommandLineAPI.methods[&quot;timeStamp&quot;] = function() { return inspectedGlobalObject.console.timeStamp(...arguments); };</span>
<span class="line-added">1520 CommandLineAPI.methods[&quot;trace&quot;] = function() { return inspectedGlobalObject.console.trace(...arguments); };</span>
<span class="line-added">1521 CommandLineAPI.methods[&quot;warn&quot;] = function() { return inspectedGlobalObject.console.warn(...arguments); };</span>
<span class="line-added">1522 </span>
<span class="line-added">1523 for (let name in CommandLineAPI.methods)</span>
<span class="line-added">1524     CommandLineAPI.methods[name].toString = function() { return &quot;function &quot; + name + &quot;() { [Command Line API] }&quot;; };</span>
<span class="line-added">1525 </span>
1526 return injectedScript;
1527 })
</pre>
</td>
</tr>
</table>
<center><a href="InjectedScriptModule.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorBackendDispatcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>