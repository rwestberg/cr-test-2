<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLButtonElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &lt;math.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/RAMSize.h&gt;
  62 #include &lt;wtf/text/StringBuilder.h&gt;
  63 
  64 #if ENABLE(MEDIA_STREAM)
  65 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
  66 #include &quot;MediaStream.h&quot;
  67 #endif
  68 
  69 #if ENABLE(WEBGL)
  70 #include &quot;WebGLContextAttributes.h&quot;
  71 #include &quot;WebGLRenderingContext.h&quot;
  72 #endif
  73 
  74 #if ENABLE(WEBGL2)
  75 #include &quot;WebGL2RenderingContext.h&quot;
  76 #endif
  77 
  78 #if ENABLE(WEBGPU)
<span class="line-modified">  79 #include &quot;WebGPURenderingContext.h&quot;</span>
<span class="line-removed">  80 #endif</span>
<span class="line-removed">  81 </span>
<span class="line-removed">  82 #if ENABLE(WEBMETAL)</span>
<span class="line-removed">  83 #include &quot;WebMetalRenderingContext.h&quot;</span>
  84 #endif
  85 
  86 #if PLATFORM(COCOA)
  87 #include &quot;MediaSampleAVFObjC.h&quot;
  88 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  89 #endif
  90 
  91 namespace WebCore {
  92 
  93 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  94 
  95 using namespace PAL;
  96 using namespace HTMLNames;
  97 
  98 // These values come from the WhatWG/W3C HTML spec.
  99 const int defaultWidth = 300;
 100 const int defaultHeight = 150;
 101 
 102 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
 103 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
</pre>
<hr />
<pre>
 138 static void removeFromActivePixelMemory(size_t pixelsReleased)
 139 {
 140     if (!pixelsReleased)
 141         return;
 142 
 143     if (pixelsReleased &lt; activePixelMemory)
 144         activePixelMemory -= pixelsReleased;
 145     else
 146         activePixelMemory = 0;
 147 }
 148 
 149 HTMLCanvasElement::~HTMLCanvasElement()
 150 {
 151     notifyObserversCanvasDestroyed();
 152 
 153     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
 154 
 155     releaseImageBufferAndContext();
 156 }
 157 
<span class="line-modified"> 158 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 159 {
 160     if (name == widthAttr || name == heightAttr)
 161         reset();
 162     HTMLElement::parseAttribute(name, value);
 163 }
 164 
 165 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 166 {
 167     RefPtr&lt;Frame&gt; frame = document().frame();
 168     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 169         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
 170     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 171 }
 172 
 173 bool HTMLCanvasElement::canContainRangeEndPoint() const
 174 {
 175     return false;
 176 }
 177 
 178 bool HTMLCanvasElement::canStartSelection() const
 179 {
 180     return false;
 181 }
 182 
 183 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
 184 {
 185     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 186         return Exception { InvalidStateError };
<span class="line-modified"> 187     setAttributeWithoutSynchronization(heightAttr, AtomicString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));</span>
 188     return { };
 189 }
 190 
 191 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
 192 {
 193     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 194         return Exception { InvalidStateError };
<span class="line-modified"> 195     setAttributeWithoutSynchronization(widthAttr, AtomicString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));</span>
 196     return { };
 197 }
 198 
 199 static inline size_t maxActivePixelMemory()
 200 {
 201     static size_t maxPixelMemory;
 202     static std::once_flag onceFlag;
 203     std::call_once(onceFlag, [] {
 204 #if PLATFORM(IOS_FAMILY)
 205         maxPixelMemory = ramSize() / 4;
 206 #else
 207         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
 208 #endif
 209     });
 210     return maxPixelMemory;
 211 }
 212 
 213 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::ExecState&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
 214 {
 215     if (m_context) {
</pre>
<hr />
<pre>
 228             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
 229         }
 230 
 231 #if ENABLE(WEBGL)
 232         if (m_context-&gt;isWebGL()) {
 233             if (!isWebGLType(contextId))
 234                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 235             if (is&lt;WebGLRenderingContext&gt;(*m_context))
 236                 return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
 237 #if ENABLE(WEBGL2)
 238             ASSERT(is&lt;WebGL2RenderingContext&gt;(*m_context));
 239             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*m_context) } };
 240 #endif
 241         }
 242 #endif
 243 
 244 #if ENABLE(WEBGPU)
 245         if (m_context-&gt;isWebGPU()) {
 246             if (!isWebGPUType(contextId))
 247                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<span class="line-modified"> 248             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGPURenderingContext&gt; { &amp;downcast&lt;WebGPURenderingContext&gt;(*m_context) } };</span>
<span class="line-removed"> 249         }</span>
<span class="line-removed"> 250 #endif</span>
<span class="line-removed"> 251 </span>
<span class="line-removed"> 252 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 253         if (m_context-&gt;isWebMetal()) {</span>
<span class="line-removed"> 254             if (!isWebMetalType(contextId))</span>
<span class="line-removed"> 255                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };</span>
<span class="line-removed"> 256             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebMetalRenderingContext&gt; { &amp;downcast&lt;WebMetalRenderingContext&gt;(*m_context) } };</span>
 257         }
 258 #endif
 259 
 260         ASSERT_NOT_REACHED();
 261         return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 262     }
 263 
 264     if (is2dType(contextId)) {
 265         auto context = createContext2d(contextId);
 266         if (!context)
 267             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 268         return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { context } };
 269     }
 270 
 271     if (isBitmapRendererType(contextId)) {
 272         auto scope = DECLARE_THROW_SCOPE(state.vm());
 273         auto attributes = convert&lt;IDLDictionary&lt;ImageBitmapRenderingContextSettings&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
 274         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 275 
 276         auto context = createContextBitmapRenderer(contextId, WTFMove(attributes));
</pre>
<hr />
<pre>
 286         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 287 
 288         auto context = createContextWebGL(contextId, WTFMove(attributes));
 289         if (!context)
 290             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 291 
 292         if (is&lt;WebGLRenderingContext&gt;(*context))
 293             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
 294 #if ENABLE(WEBGL2)
 295         ASSERT(is&lt;WebGL2RenderingContext&gt;(*context));
 296         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
 297 #endif
 298     }
 299 #endif
 300 
 301 #if ENABLE(WEBGPU)
 302     if (isWebGPUType(contextId)) {
 303         auto context = createContextWebGPU(contextId);
 304         if (!context)
 305             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<span class="line-modified"> 306         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGPURenderingContext&gt; { context } };</span>
<span class="line-removed"> 307     }</span>
<span class="line-removed"> 308 #endif</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 311     if (isWebMetalType(contextId)) {</span>
<span class="line-removed"> 312         auto context = createContextWebMetal(contextId);</span>
<span class="line-removed"> 313         if (!context)</span>
<span class="line-removed"> 314             return Optional&lt;RenderingContext&gt; { WTF::nullopt };</span>
<span class="line-removed"> 315         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebMetalRenderingContext&gt; { context } };</span>
 316     }
 317 #endif
 318 
 319     return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 320 }
 321 
 322 CanvasRenderingContext* HTMLCanvasElement::getContext(const String&amp; type)
 323 {
 324     if (HTMLCanvasElement::is2dType(type))
 325         return getContext2d(type);
 326 
 327     if (HTMLCanvasElement::isBitmapRendererType(type))
 328         return getContextBitmapRenderer(type);
 329 
<span class="line-removed"> 330 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 331     if (HTMLCanvasElement::isWebMetalType(type) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 332         return getContextWebMetal(type);</span>
<span class="line-removed"> 333 #endif</span>
<span class="line-removed"> 334 </span>
 335 #if ENABLE(WEBGL)
 336     if (HTMLCanvasElement::isWebGLType(type))
 337         return getContextWebGL(type);
 338 #endif
 339 
 340 #if ENABLE(WEBGPU)
 341     if (HTMLCanvasElement::isWebGPUType(type))
 342         return getContextWebGPU(type);
 343 #endif
 344 
 345     return nullptr;
 346 }
 347 
 348 bool HTMLCanvasElement::is2dType(const String&amp; type)
 349 {
 350     return type == &quot;2d&quot;;
 351 }
 352 
 353 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
 354 {
 355     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 356     ASSERT(!m_context);
 357 
<span class="line-removed"> 358     bool usesDashboardCompatibilityMode = false;</span>
<span class="line-removed"> 359 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 360     usesDashboardCompatibilityMode = document().settings().usesDashboardBackwardCompatibilityMode();</span>
<span class="line-removed"> 361 #endif</span>
<span class="line-removed"> 362 </span>
 363     // Make sure we don&#39;t use more pixel memory than the system can support.
 364     size_t requestedPixelMemory = 4 * width() * height();
 365     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {
 366         StringBuilder stringBuilder;
 367         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 368         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 369         stringBuilder.appendLiteral(&quot; MB).&quot;);
 370         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 371         return nullptr;
 372     }
 373 
<span class="line-modified"> 374     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode(), usesDashboardCompatibilityMode);</span>
 375 
 376     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 377     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 378 
 379 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 380     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 381     invalidateStyleAndLayerComposition();
 382 #endif
 383 
 384     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 385 }
 386 
 387 CanvasRenderingContext2D* HTMLCanvasElement::getContext2d(const String&amp; type)
 388 {
 389     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 390 
 391     if (m_context &amp;&amp; !m_context-&gt;is2d())
 392         return nullptr;
 393 
 394     if (!m_context)
</pre>
<hr />
<pre>
 449 {
 450     ASSERT(HTMLCanvasElement::isWebGLType(type));
 451 
 452     if (!shouldEnableWebGL(document().settings()))
 453         return nullptr;
 454 
 455     if (m_context &amp;&amp; !m_context-&gt;isWebGL())
 456         return nullptr;
 457 
 458     if (!m_context)
 459         return createContextWebGL(type, WTFMove(attrs));
 460     return &amp;downcast&lt;WebGLRenderingContextBase&gt;(*m_context);
 461 }
 462 
 463 #endif // ENABLE(WEBGL)
 464 
 465 #if ENABLE(WEBGPU)
 466 
 467 bool HTMLCanvasElement::isWebGPUType(const String&amp; type)
 468 {
<span class="line-modified"> 469     return type == &quot;webgpu&quot;;</span>
 470 }
 471 
<span class="line-modified"> 472 WebGPURenderingContext* HTMLCanvasElement::createContextWebGPU(const String&amp; type)</span>
 473 {
 474     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 475     ASSERT(!m_context);
 476 
 477     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 478         return nullptr;
 479 
<span class="line-modified"> 480     m_context = WebGPURenderingContext::create(*this);</span>
 481     if (m_context) {
 482         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 483         invalidateStyleAndLayerComposition();
 484     }
 485 
<span class="line-modified"> 486     return static_cast&lt;WebGPURenderingContext*&gt;(m_context.get());</span>
 487 }
 488 
<span class="line-modified"> 489 WebGPURenderingContext* HTMLCanvasElement::getContextWebGPU(const String&amp; type)</span>
 490 {
 491     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 492 
 493     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 494         return nullptr;
 495 
 496     if (m_context &amp;&amp; !m_context-&gt;isWebGPU())
 497         return nullptr;
 498 
 499     if (!m_context)
 500         return createContextWebGPU(type);
<span class="line-modified"> 501     return static_cast&lt;WebGPURenderingContext*&gt;(m_context.get());</span>
 502 }
 503 
 504 #endif // ENABLE(WEBGPU)
 505 
<span class="line-removed"> 506 #if ENABLE(WEBMETAL)</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508 bool HTMLCanvasElement::isWebMetalType(const String&amp; type)</span>
<span class="line-removed"> 509 {</span>
<span class="line-removed"> 510     return type == &quot;webmetal&quot;;</span>
<span class="line-removed"> 511 }</span>
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513 WebMetalRenderingContext* HTMLCanvasElement::createContextWebMetal(const String&amp; type)</span>
<span class="line-removed"> 514 {</span>
<span class="line-removed"> 515     ASSERT_UNUSED(type, HTMLCanvasElement::isWebMetalType(type));</span>
<span class="line-removed"> 516     ASSERT(!m_context);</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518     if (!RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 519         return nullptr;</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521     m_context = WebMetalRenderingContext::create(*this);</span>
<span class="line-removed"> 522     if (m_context) {</span>
<span class="line-removed"> 523         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.</span>
<span class="line-removed"> 524         invalidateStyleAndLayerComposition();</span>
<span class="line-removed"> 525     }</span>
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527     return static_cast&lt;WebMetalRenderingContext*&gt;(m_context.get());</span>
<span class="line-removed"> 528 }</span>
<span class="line-removed"> 529 </span>
<span class="line-removed"> 530 WebMetalRenderingContext* HTMLCanvasElement::getContextWebMetal(const String&amp; type)</span>
<span class="line-removed"> 531 {</span>
<span class="line-removed"> 532     ASSERT_UNUSED(type, HTMLCanvasElement::isWebMetalType(type));</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534     if (!RuntimeEnabledFeatures::sharedFeatures().webMetalEnabled())</span>
<span class="line-removed"> 535         return nullptr;</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537     if (m_context &amp;&amp; !m_context-&gt;isWebMetal())</span>
<span class="line-removed"> 538         return nullptr;</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540     if (!m_context)</span>
<span class="line-removed"> 541         return createContextWebMetal(type);</span>
<span class="line-removed"> 542     return static_cast&lt;WebMetalRenderingContext*&gt;(m_context.get());</span>
<span class="line-removed"> 543 }</span>
<span class="line-removed"> 544 #endif</span>
<span class="line-removed"> 545 </span>
 546 bool HTMLCanvasElement::isBitmapRendererType(const String&amp; type)
 547 {
 548     return type == &quot;bitmaprenderer&quot;;
 549 }
 550 
 551 ImageBitmapRenderingContext* HTMLCanvasElement::createContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
 552 {
 553     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
 554     ASSERT(!m_context);
 555 
 556     m_context = ImageBitmapRenderingContext::create(*this, WTFMove(settings));
 557 
 558 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 559     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 560     invalidateStyleAndLayerComposition();
 561 #endif
 562 
 563     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
 564 }
 565 
</pre>
<hr />
<pre>
 650 bool HTMLCanvasElement::paintsIntoCanvasBuffer() const
 651 {
 652     ASSERT(m_context);
 653 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 654     if (m_context-&gt;is2d() || m_context-&gt;isBitmapRenderer())
 655         return true;
 656 #endif
 657 
 658     if (!m_context-&gt;isAccelerated())
 659         return true;
 660 
 661     if (renderBox() &amp;&amp; renderBox()-&gt;hasAcceleratedCompositing())
 662         return false;
 663 
 664     return true;
 665 }
 666 
 667 
 668 void HTMLCanvasElement::paint(GraphicsContext&amp; context, const LayoutRect&amp; r)
 669 {
<span class="line-removed"> 670     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))</span>
<span class="line-removed"> 671         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);</span>
<span class="line-removed"> 672 </span>
 673     // Clear the dirty rect
 674     m_dirtyRect = FloatRect();
 675 
<span class="line-modified"> 676     if (context.paintingDisabled())</span>
<span class="line-modified"> 677         return;</span>
 678 
<span class="line-modified"> 679     if (m_context) {</span>
<span class="line-modified"> 680         if (!paintsIntoCanvasBuffer() &amp;&amp; !document().printing())</span>
<span class="line-modified"> 681             return;</span>


 682 
<span class="line-modified"> 683         m_context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-modified"> 684     }</span>





 685 
<span class="line-modified"> 686     if (hasCreatedImageBuffer()) {</span>
<span class="line-modified"> 687         ImageBuffer* imageBuffer = buffer();</span>
<span class="line-removed"> 688         if (imageBuffer) {</span>
<span class="line-removed"> 689             if (m_presentedImage) {</span>
<span class="line-removed"> 690                 ImageOrientationDescription orientationDescription;</span>
<span class="line-removed"> 691 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed"> 692                 orientationDescription.setImageOrientationEnum(renderer()-&gt;style().imageOrientation());</span>
<span class="line-removed"> 693 #endif</span>
<span class="line-removed"> 694                 context.drawImage(*m_presentedImage, snappedIntRect(r), ImagePaintingOptions(orientationDescription));</span>
<span class="line-removed"> 695             } else</span>
<span class="line-removed"> 696                 context.drawImageBuffer(*imageBuffer, snappedIntRect(r));</span>
 697         }
 698     }
 699 
<span class="line-modified"> 700     if (isGPUBased())</span>
<span class="line-modified"> 701         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();</span>
 702 }
 703 
 704 bool HTMLCanvasElement::isGPUBased() const
 705 {
 706     return m_context &amp;&amp; m_context-&gt;isGPUBased();
 707 }
 708 
 709 void HTMLCanvasElement::makeRenderingResultsAvailable()
 710 {
 711     if (m_context)
 712         m_context-&gt;paintRenderingResultsToCanvas();
 713 }
 714 
 715 void HTMLCanvasElement::makePresentationCopy()
 716 {
 717     if (!m_presentedImage) {
 718         // The buffer contains the last presented data, so save a copy of it.
 719         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 720     }
 721 }
</pre>
<hr />
<pre>
 791 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
 792 {
 793     if (!originClean())
 794         return Exception { SecurityError };
 795 
 796     if (m_size.isEmpty() || !buffer()) {
 797         callback-&gt;scheduleCallback(context, nullptr);
 798         return { };
 799     }
 800     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 801         ResourceLoadObserver::shared().logCanvasRead(document());
 802 
 803     auto encodingMIMEType = toEncodingMimeType(mimeType);
 804     auto quality = qualityFromJSValue(qualityValue);
 805 
 806 #if USE(CG)
 807     if (auto imageData = getImageData()) {
 808         RefPtr&lt;Blob&gt; blob;
 809         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
 810         if (!blobData.isEmpty())
<span class="line-modified"> 811             blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 812         callback-&gt;scheduleCallback(context, WTFMove(blob));
 813         return { };
 814     }
 815 #endif
 816 
 817     makeRenderingResultsAvailable();
 818 
 819     RefPtr&lt;Blob&gt; blob;
 820     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
 821     if (!blobData.isEmpty())
<span class="line-modified"> 822         blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 823     callback-&gt;scheduleCallback(context, WTFMove(blob));
 824     return { };
 825 }
 826 
 827 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
 828 {
 829 #if ENABLE(WEBGL)
 830     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
 831         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 832             ResourceLoadObserver::shared().logCanvasRead(document());
 833         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
 834     }
 835 #endif
 836     return nullptr;
 837 }
 838 
 839 #if ENABLE(MEDIA_STREAM)
 840 
 841 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
 842 {
 843     auto* imageBuffer = buffer();
 844     if (!imageBuffer)
 845         return nullptr;
 846     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 847         ResourceLoadObserver::shared().logCanvasRead(document());
 848 
 849 #if PLATFORM(COCOA)
 850     makeRenderingResultsAvailable();
 851     return MediaSampleAVFObjC::createImageSample(imageBuffer-&gt;toBGRAData(), width(), height());
 852 #else
 853     return nullptr;
 854 #endif
 855 }
 856 
<span class="line-modified"> 857 ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; HTMLCanvasElement::captureStream(ScriptExecutionContext&amp; context, Optional&lt;double&gt;&amp;&amp; frameRequestRate)</span>
 858 {
 859     if (!originClean())
 860         return Exception(SecurityError, &quot;Canvas is tainted&quot;_s);
 861     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
<span class="line-modified"> 862         ResourceLoadObserver::shared().logCanvasRead(document());</span>
 863 
 864     if (frameRequestRate &amp;&amp; frameRequestRate.value() &lt; 0)
 865         return Exception(NotSupportedError, &quot;frameRequestRate is negative&quot;_s);
 866 
<span class="line-modified"> 867     auto track = CanvasCaptureMediaStreamTrack::create(context, *this, WTFMove(frameRequestRate));</span>
<span class="line-modified"> 868     auto stream =  MediaStream::create(context);</span>
 869     stream-&gt;addTrack(track);
<span class="line-modified"> 870     return WTFMove(stream);</span>
 871 }
 872 #endif
 873 
 874 SecurityOrigin* HTMLCanvasElement::securityOrigin() const
 875 {
 876     return &amp;document().securityOrigin();
 877 }
 878 
 879 bool HTMLCanvasElement::shouldAccelerate(const IntSize&amp; size) const
 880 {
 881     auto&amp; settings = document().settings();
 882 
 883     auto area = size.area&lt;RecordOverflow&gt;();
 884     if (area.hasOverflowed())
 885         return false;
 886 
 887     if (area &gt; settings.maximumAccelerated2dCanvasSize())
 888         return false;
 889 
 890 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
</pre>
<hr />
<pre>
1011     {
1012         auto locker = holdLock(m_imageBufferAssignmentLock);
1013         m_contextStateSaver = nullptr;
1014         m_imageBuffer = WTFMove(buffer);
1015     }
1016 
1017     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())
1018         m_size = m_imageBuffer-&gt;internalSize();
1019 
1020     size_t currentMemoryCost = memoryCost();
1021     activePixelMemory += currentMemoryCost;
1022 
1023     if (m_context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != currentMemoryCost)
1024         InspectorInstrumentation::didChangeCanvasMemory(*m_context);
1025 
1026     if (!m_imageBuffer)
1027         return;
1028     m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);
1029     m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);
1030     m_imageBuffer-&gt;context().setStrokeThickness(1);
<span class="line-modified">1031     m_contextStateSaver = std::make_unique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
1032 
1033     JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()-&gt;vm());
1034     HTMLElement::scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());
1035 
1036 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
1037     if (m_context &amp;&amp; m_context-&gt;is2d()) {
1038         // Recalculate compositing requirements if acceleration state changed.
1039         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
1040     }
1041 #endif
1042 }
1043 
1044 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
1045 {
1046     m_hasCreatedImageBuffer = true;
1047     setImageBuffer(WTFMove(buffer));
1048     didDraw(FloatRect(FloatPoint(), m_size));
1049 }
1050 
1051 GraphicsContext* HTMLCanvasElement::drawingContext() const
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &lt;math.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/RAMSize.h&gt;
  62 #include &lt;wtf/text/StringBuilder.h&gt;
  63 
  64 #if ENABLE(MEDIA_STREAM)
  65 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
  66 #include &quot;MediaStream.h&quot;
  67 #endif
  68 
  69 #if ENABLE(WEBGL)
  70 #include &quot;WebGLContextAttributes.h&quot;
  71 #include &quot;WebGLRenderingContext.h&quot;
  72 #endif
  73 
  74 #if ENABLE(WEBGL2)
  75 #include &quot;WebGL2RenderingContext.h&quot;
  76 #endif
  77 
  78 #if ENABLE(WEBGPU)
<span class="line-modified">  79 #include &quot;GPUCanvasContext.h&quot;</span>




  80 #endif
  81 
  82 #if PLATFORM(COCOA)
  83 #include &quot;MediaSampleAVFObjC.h&quot;
  84 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  85 #endif
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  90 
  91 using namespace PAL;
  92 using namespace HTMLNames;
  93 
  94 // These values come from the WhatWG/W3C HTML spec.
  95 const int defaultWidth = 300;
  96 const int defaultHeight = 150;
  97 
  98 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
  99 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
</pre>
<hr />
<pre>
 134 static void removeFromActivePixelMemory(size_t pixelsReleased)
 135 {
 136     if (!pixelsReleased)
 137         return;
 138 
 139     if (pixelsReleased &lt; activePixelMemory)
 140         activePixelMemory -= pixelsReleased;
 141     else
 142         activePixelMemory = 0;
 143 }
 144 
 145 HTMLCanvasElement::~HTMLCanvasElement()
 146 {
 147     notifyObserversCanvasDestroyed();
 148 
 149     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
 150 
 151     releaseImageBufferAndContext();
 152 }
 153 
<span class="line-modified"> 154 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 155 {
 156     if (name == widthAttr || name == heightAttr)
 157         reset();
 158     HTMLElement::parseAttribute(name, value);
 159 }
 160 
 161 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 162 {
 163     RefPtr&lt;Frame&gt; frame = document().frame();
 164     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 165         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
 166     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 167 }
 168 
 169 bool HTMLCanvasElement::canContainRangeEndPoint() const
 170 {
 171     return false;
 172 }
 173 
 174 bool HTMLCanvasElement::canStartSelection() const
 175 {
 176     return false;
 177 }
 178 
 179 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
 180 {
 181     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 182         return Exception { InvalidStateError };
<span class="line-modified"> 183     setAttributeWithoutSynchronization(heightAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));</span>
 184     return { };
 185 }
 186 
 187 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
 188 {
 189     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 190         return Exception { InvalidStateError };
<span class="line-modified"> 191     setAttributeWithoutSynchronization(widthAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));</span>
 192     return { };
 193 }
 194 
 195 static inline size_t maxActivePixelMemory()
 196 {
 197     static size_t maxPixelMemory;
 198     static std::once_flag onceFlag;
 199     std::call_once(onceFlag, [] {
 200 #if PLATFORM(IOS_FAMILY)
 201         maxPixelMemory = ramSize() / 4;
 202 #else
 203         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
 204 #endif
 205     });
 206     return maxPixelMemory;
 207 }
 208 
 209 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::ExecState&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
 210 {
 211     if (m_context) {
</pre>
<hr />
<pre>
 224             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
 225         }
 226 
 227 #if ENABLE(WEBGL)
 228         if (m_context-&gt;isWebGL()) {
 229             if (!isWebGLType(contextId))
 230                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 231             if (is&lt;WebGLRenderingContext&gt;(*m_context))
 232                 return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
 233 #if ENABLE(WEBGL2)
 234             ASSERT(is&lt;WebGL2RenderingContext&gt;(*m_context));
 235             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*m_context) } };
 236 #endif
 237         }
 238 #endif
 239 
 240 #if ENABLE(WEBGPU)
 241         if (m_context-&gt;isWebGPU()) {
 242             if (!isWebGPUType(contextId))
 243                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<span class="line-modified"> 244             return Optional&lt;RenderingContext&gt; { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*m_context) } };</span>








 245         }
 246 #endif
 247 
 248         ASSERT_NOT_REACHED();
 249         return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 250     }
 251 
 252     if (is2dType(contextId)) {
 253         auto context = createContext2d(contextId);
 254         if (!context)
 255             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 256         return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { context } };
 257     }
 258 
 259     if (isBitmapRendererType(contextId)) {
 260         auto scope = DECLARE_THROW_SCOPE(state.vm());
 261         auto attributes = convert&lt;IDLDictionary&lt;ImageBitmapRenderingContextSettings&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
 262         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 263 
 264         auto context = createContextBitmapRenderer(contextId, WTFMove(attributes));
</pre>
<hr />
<pre>
 274         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 275 
 276         auto context = createContextWebGL(contextId, WTFMove(attributes));
 277         if (!context)
 278             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 279 
 280         if (is&lt;WebGLRenderingContext&gt;(*context))
 281             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
 282 #if ENABLE(WEBGL2)
 283         ASSERT(is&lt;WebGL2RenderingContext&gt;(*context));
 284         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
 285 #endif
 286     }
 287 #endif
 288 
 289 #if ENABLE(WEBGPU)
 290     if (isWebGPUType(contextId)) {
 291         auto context = createContextWebGPU(contextId);
 292         if (!context)
 293             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
<span class="line-modified"> 294         return Optional&lt;RenderingContext&gt; { RefPtr&lt;GPUCanvasContext&gt; { context } };</span>









 295     }
 296 #endif
 297 
 298     return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 299 }
 300 
 301 CanvasRenderingContext* HTMLCanvasElement::getContext(const String&amp; type)
 302 {
 303     if (HTMLCanvasElement::is2dType(type))
 304         return getContext2d(type);
 305 
 306     if (HTMLCanvasElement::isBitmapRendererType(type))
 307         return getContextBitmapRenderer(type);
 308 





 309 #if ENABLE(WEBGL)
 310     if (HTMLCanvasElement::isWebGLType(type))
 311         return getContextWebGL(type);
 312 #endif
 313 
 314 #if ENABLE(WEBGPU)
 315     if (HTMLCanvasElement::isWebGPUType(type))
 316         return getContextWebGPU(type);
 317 #endif
 318 
 319     return nullptr;
 320 }
 321 
 322 bool HTMLCanvasElement::is2dType(const String&amp; type)
 323 {
 324     return type == &quot;2d&quot;;
 325 }
 326 
 327 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
 328 {
 329     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 330     ASSERT(!m_context);
 331 





 332     // Make sure we don&#39;t use more pixel memory than the system can support.
 333     size_t requestedPixelMemory = 4 * width() * height();
 334     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {
 335         StringBuilder stringBuilder;
 336         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 337         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 338         stringBuilder.appendLiteral(&quot; MB).&quot;);
 339         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 340         return nullptr;
 341     }
 342 
<span class="line-modified"> 343     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode());</span>
 344 
 345     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 346     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 347 
 348 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 349     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 350     invalidateStyleAndLayerComposition();
 351 #endif
 352 
 353     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 354 }
 355 
 356 CanvasRenderingContext2D* HTMLCanvasElement::getContext2d(const String&amp; type)
 357 {
 358     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 359 
 360     if (m_context &amp;&amp; !m_context-&gt;is2d())
 361         return nullptr;
 362 
 363     if (!m_context)
</pre>
<hr />
<pre>
 418 {
 419     ASSERT(HTMLCanvasElement::isWebGLType(type));
 420 
 421     if (!shouldEnableWebGL(document().settings()))
 422         return nullptr;
 423 
 424     if (m_context &amp;&amp; !m_context-&gt;isWebGL())
 425         return nullptr;
 426 
 427     if (!m_context)
 428         return createContextWebGL(type, WTFMove(attrs));
 429     return &amp;downcast&lt;WebGLRenderingContextBase&gt;(*m_context);
 430 }
 431 
 432 #endif // ENABLE(WEBGL)
 433 
 434 #if ENABLE(WEBGPU)
 435 
 436 bool HTMLCanvasElement::isWebGPUType(const String&amp; type)
 437 {
<span class="line-modified"> 438     return type == &quot;gpu&quot;;</span>
 439 }
 440 
<span class="line-modified"> 441 GPUCanvasContext* HTMLCanvasElement::createContextWebGPU(const String&amp; type)</span>
 442 {
 443     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 444     ASSERT(!m_context);
 445 
 446     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 447         return nullptr;
 448 
<span class="line-modified"> 449     m_context = GPUCanvasContext::create(*this);</span>
 450     if (m_context) {
 451         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 452         invalidateStyleAndLayerComposition();
 453     }
 454 
<span class="line-modified"> 455     return static_cast&lt;GPUCanvasContext*&gt;(m_context.get());</span>
 456 }
 457 
<span class="line-modified"> 458 GPUCanvasContext* HTMLCanvasElement::getContextWebGPU(const String&amp; type)</span>
 459 {
 460     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
 461 
 462     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
 463         return nullptr;
 464 
 465     if (m_context &amp;&amp; !m_context-&gt;isWebGPU())
 466         return nullptr;
 467 
 468     if (!m_context)
 469         return createContextWebGPU(type);
<span class="line-modified"> 470     return static_cast&lt;GPUCanvasContext*&gt;(m_context.get());</span>
 471 }
 472 
 473 #endif // ENABLE(WEBGPU)
 474 








































 475 bool HTMLCanvasElement::isBitmapRendererType(const String&amp; type)
 476 {
 477     return type == &quot;bitmaprenderer&quot;;
 478 }
 479 
 480 ImageBitmapRenderingContext* HTMLCanvasElement::createContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
 481 {
 482     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
 483     ASSERT(!m_context);
 484 
 485     m_context = ImageBitmapRenderingContext::create(*this, WTFMove(settings));
 486 
 487 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 488     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 489     invalidateStyleAndLayerComposition();
 490 #endif
 491 
 492     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
 493 }
 494 
</pre>
<hr />
<pre>
 579 bool HTMLCanvasElement::paintsIntoCanvasBuffer() const
 580 {
 581     ASSERT(m_context);
 582 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 583     if (m_context-&gt;is2d() || m_context-&gt;isBitmapRenderer())
 584         return true;
 585 #endif
 586 
 587     if (!m_context-&gt;isAccelerated())
 588         return true;
 589 
 590     if (renderBox() &amp;&amp; renderBox()-&gt;hasAcceleratedCompositing())
 591         return false;
 592 
 593     return true;
 594 }
 595 
 596 
 597 void HTMLCanvasElement::paint(GraphicsContext&amp; context, const LayoutRect&amp; r)
 598 {



 599     // Clear the dirty rect
 600     m_dirtyRect = FloatRect();
 601 
<span class="line-modified"> 602     if (!context.paintingDisabled()) {</span>
<span class="line-modified"> 603         bool shouldPaint = true;</span>
 604 
<span class="line-modified"> 605         if (m_context) {</span>
<span class="line-modified"> 606             shouldPaint = paintsIntoCanvasBuffer() || document().printing();</span>
<span class="line-modified"> 607             if (shouldPaint)</span>
<span class="line-added"> 608                 m_context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-added"> 609         }</span>
 610 
<span class="line-modified"> 611         if (shouldPaint) {</span>
<span class="line-modified"> 612             if (hasCreatedImageBuffer()) {</span>
<span class="line-added"> 613                 if (m_presentedImage)</span>
<span class="line-added"> 614                     context.drawImage(*m_presentedImage, snappedIntRect(r), renderer()-&gt;imageOrientation());</span>
<span class="line-added"> 615                 else if (ImageBuffer* imageBuffer = buffer())</span>
<span class="line-added"> 616                     context.drawImageBuffer(*imageBuffer, snappedIntRect(r));</span>
<span class="line-added"> 617             }</span>
 618 
<span class="line-modified"> 619             if (isGPUBased())</span>
<span class="line-modified"> 620                 downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();</span>









 621         }
 622     }
 623 
<span class="line-modified"> 624     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))</span>
<span class="line-modified"> 625         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);</span>
 626 }
 627 
 628 bool HTMLCanvasElement::isGPUBased() const
 629 {
 630     return m_context &amp;&amp; m_context-&gt;isGPUBased();
 631 }
 632 
 633 void HTMLCanvasElement::makeRenderingResultsAvailable()
 634 {
 635     if (m_context)
 636         m_context-&gt;paintRenderingResultsToCanvas();
 637 }
 638 
 639 void HTMLCanvasElement::makePresentationCopy()
 640 {
 641     if (!m_presentedImage) {
 642         // The buffer contains the last presented data, so save a copy of it.
 643         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 644     }
 645 }
</pre>
<hr />
<pre>
 715 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
 716 {
 717     if (!originClean())
 718         return Exception { SecurityError };
 719 
 720     if (m_size.isEmpty() || !buffer()) {
 721         callback-&gt;scheduleCallback(context, nullptr);
 722         return { };
 723     }
 724     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 725         ResourceLoadObserver::shared().logCanvasRead(document());
 726 
 727     auto encodingMIMEType = toEncodingMimeType(mimeType);
 728     auto quality = qualityFromJSValue(qualityValue);
 729 
 730 #if USE(CG)
 731     if (auto imageData = getImageData()) {
 732         RefPtr&lt;Blob&gt; blob;
 733         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
 734         if (!blobData.isEmpty())
<span class="line-modified"> 735             blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
 736         callback-&gt;scheduleCallback(context, WTFMove(blob));
 737         return { };
 738     }
 739 #endif
 740 
 741     makeRenderingResultsAvailable();
 742 
 743     RefPtr&lt;Blob&gt; blob;
 744     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
 745     if (!blobData.isEmpty())
<span class="line-modified"> 746         blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
 747     callback-&gt;scheduleCallback(context, WTFMove(blob));
 748     return { };
 749 }
 750 
 751 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
 752 {
 753 #if ENABLE(WEBGL)
 754     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
 755         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 756             ResourceLoadObserver::shared().logCanvasRead(document());
 757         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
 758     }
 759 #endif
 760     return nullptr;
 761 }
 762 
 763 #if ENABLE(MEDIA_STREAM)
 764 
 765 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
 766 {
 767     auto* imageBuffer = buffer();
 768     if (!imageBuffer)
 769         return nullptr;
 770     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 771         ResourceLoadObserver::shared().logCanvasRead(document());
 772 
 773 #if PLATFORM(COCOA)
 774     makeRenderingResultsAvailable();
 775     return MediaSampleAVFObjC::createImageSample(imageBuffer-&gt;toBGRAData(), width(), height());
 776 #else
 777     return nullptr;
 778 #endif
 779 }
 780 
<span class="line-modified"> 781 ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; HTMLCanvasElement::captureStream(Document&amp; document, Optional&lt;double&gt;&amp;&amp; frameRequestRate)</span>
 782 {
 783     if (!originClean())
 784         return Exception(SecurityError, &quot;Canvas is tainted&quot;_s);
 785     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
<span class="line-modified"> 786         ResourceLoadObserver::shared().logCanvasRead(this-&gt;document());</span>
 787 
 788     if (frameRequestRate &amp;&amp; frameRequestRate.value() &lt; 0)
 789         return Exception(NotSupportedError, &quot;frameRequestRate is negative&quot;_s);
 790 
<span class="line-modified"> 791     auto track = CanvasCaptureMediaStreamTrack::create(document, *this, WTFMove(frameRequestRate));</span>
<span class="line-modified"> 792     auto stream =  MediaStream::create(document);</span>
 793     stream-&gt;addTrack(track);
<span class="line-modified"> 794     return stream;</span>
 795 }
 796 #endif
 797 
 798 SecurityOrigin* HTMLCanvasElement::securityOrigin() const
 799 {
 800     return &amp;document().securityOrigin();
 801 }
 802 
 803 bool HTMLCanvasElement::shouldAccelerate(const IntSize&amp; size) const
 804 {
 805     auto&amp; settings = document().settings();
 806 
 807     auto area = size.area&lt;RecordOverflow&gt;();
 808     if (area.hasOverflowed())
 809         return false;
 810 
 811     if (area &gt; settings.maximumAccelerated2dCanvasSize())
 812         return false;
 813 
 814 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
</pre>
<hr />
<pre>
 935     {
 936         auto locker = holdLock(m_imageBufferAssignmentLock);
 937         m_contextStateSaver = nullptr;
 938         m_imageBuffer = WTFMove(buffer);
 939     }
 940 
 941     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())
 942         m_size = m_imageBuffer-&gt;internalSize();
 943 
 944     size_t currentMemoryCost = memoryCost();
 945     activePixelMemory += currentMemoryCost;
 946 
 947     if (m_context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != currentMemoryCost)
 948         InspectorInstrumentation::didChangeCanvasMemory(*m_context);
 949 
 950     if (!m_imageBuffer)
 951         return;
 952     m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);
 953     m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);
 954     m_imageBuffer-&gt;context().setStrokeThickness(1);
<span class="line-modified"> 955     m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
 956 
 957     JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()-&gt;vm());
 958     HTMLElement::scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());
 959 
 960 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 961     if (m_context &amp;&amp; m_context-&gt;is2d()) {
 962         // Recalculate compositing requirements if acceleration state changed.
 963         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
 964     }
 965 #endif
 966 }
 967 
 968 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 969 {
 970     m_hasCreatedImageBuffer = true;
 971     setImageBuffer(WTFMove(buffer));
 972     didDraw(FloatRect(FloatPoint(), m_size));
 973 }
 974 
 975 GraphicsContext* HTMLCanvasElement::drawingContext() const
</pre>
</td>
</tr>
</table>
<center><a href="HTMLButtonElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>