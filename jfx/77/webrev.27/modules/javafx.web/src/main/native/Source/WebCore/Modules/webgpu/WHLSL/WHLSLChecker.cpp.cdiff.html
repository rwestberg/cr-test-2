<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLCheckDuplicateFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLChecker.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,19 ***</span>
<span class="line-new-header">--- 34,21 ---</span>
  #include &quot;WHLSLCallExpression.h&quot;
  #include &quot;WHLSLCommaExpression.h&quot;
  #include &quot;WHLSLDereferenceExpression.h&quot;
  #include &quot;WHLSLDoWhileLoop.h&quot;
  #include &quot;WHLSLDotExpression.h&quot;
<span class="line-added">+ #include &quot;WHLSLEntryPointType.h&quot;</span>
  #include &quot;WHLSLForLoop.h&quot;
  #include &quot;WHLSLGatherEntryPointItems.h&quot;
  #include &quot;WHLSLIfStatement.h&quot;
  #include &quot;WHLSLIndexExpression.h&quot;
  #include &quot;WHLSLInferTypes.h&quot;
  #include &quot;WHLSLLogicalExpression.h&quot;
  #include &quot;WHLSLLogicalNotExpression.h&quot;
  #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  #include &quot;WHLSLMakePointerExpression.h&quot;
<span class="line-added">+ #include &quot;WHLSLNameContext.h&quot;</span>
  #include &quot;WHLSLPointerType.h&quot;
  #include &quot;WHLSLProgram.h&quot;
  #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  #include &quot;WHLSLResolvableType.h&quot;
  #include &quot;WHLSLResolveOverloadImpl.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,11 ***</span>
      void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
      {
          if (!nativeTypeDeclaration.isNumber()
              &amp;&amp; !nativeTypeDeclaration.isVector()
              &amp;&amp; !nativeTypeDeclaration.isMatrix())
<span class="line-modified">!             setError();</span>
      }
  
      void visit(AST::StructureDefinition&amp; structureDefinition) override
      {
          Visitor::visit(structureDefinition);
<span class="line-new-header">--- 82,11 ---</span>
      void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
      {
          if (!nativeTypeDeclaration.isNumber()
              &amp;&amp; !nativeTypeDeclaration.isVector()
              &amp;&amp; !nativeTypeDeclaration.isMatrix())
<span class="line-modified">!             setError(Error(&quot;Use of native type is not a POD in entrypoint semantic.&quot;, nativeTypeDeclaration.codeLocation()));</span>
      }
  
      void visit(AST::StructureDefinition&amp; structureDefinition) override
      {
          Visitor::visit(structureDefinition);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,105 ***</span>
      void visit(AST::ArrayType&amp; arrayType) override
      {
          Visitor::visit(arrayType);
      }
  
<span class="line-modified">!     void visit(AST::PointerType&amp;) override</span>
      {
<span class="line-modified">!         setError();</span>
      }
  
<span class="line-modified">!     void visit(AST::ArrayReferenceType&amp;) override</span>
      {
<span class="line-modified">!         setError();</span>
      }
  
      void visit(AST::TypeReference&amp; typeReference) override
      {
<span class="line-modified">!         ASSERT(typeReference.resolvedType());</span>
<span class="line-removed">-         checkErrorAndVisit(*typeReference.resolvedType());</span>
      }
  };
  
<span class="line-modified">! static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(AST::CallExpression&amp; callExpression, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(callExpression.origin()), firstArgument.addressSpace(), firstArgument.elementType().clone());</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified">!     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType()) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
  }
  
<span class="line-modified">! static AST::NativeFunctionDeclaration resolveWithOperatorLength(AST::CallExpression&amp; callExpression, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.uintType());</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { firstArgument.clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
  }
  
<span class="line-modified">! static AST::NativeFunctionDeclaration resolveWithReferenceComparator(AST::CallExpression&amp; callExpression, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.boolType());</span>
<span class="line-modified">!     auto argumentType = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return unnamedType-&gt;clone();</span>
<span class="line-modified">!     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!             return unnamedType-&gt;clone();</span>
<span class="line-modified">!         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
              // We encountered &quot;null == null&quot;.
<span class="line-modified">!             // The type isn&#39;t observable, so we can pick whatever we want.</span>
<span class="line-modified">!             // FIXME: This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified">!             return AST::TypeReference::wrap(Lexer::Token(callExpression.origin()), intrinsics.intType());</span>
<span class="line-modified">!         }), secondArgument);</span>
<span class="line-modified">!     }), firstArgument);</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { argumentType-&gt;clone() }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified">!     parameters.append(AST::VariableDeclaration(Lexer::Token(callExpression.origin()), AST::Qualifiers(), { WTFMove(argumentType) }, String(), WTF::nullopt, WTF::nullopt));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(Lexer::Token(callExpression.origin()), AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), WTF::nullopt, isOperator));</span>
  }
  
<span class="line-modified">! static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(AST::CallExpression&amp; callExpression, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>
  {
<span class="line-modified">!     if (callExpression.name() == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified">!         auto* firstArgumentArrayRef = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
              if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
                  return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
              return nullptr;
<span class="line-modified">!         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
              return nullptr;
<span class="line-modified">!         }), types[0].get());</span>
<span class="line-modified">!         bool secondArgumentIsUint = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
              return matches(unnamedType, intrinsics.uintType());
<span class="line-modified">!         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
              return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<span class="line-modified">!         }), types[1].get());</span>
          if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<span class="line-modified">!             return resolveWithOperatorAnderIndexer(callExpression, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified">!     } else if (callExpression.name() == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified">!         auto* firstArgumentReference = WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
              if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<span class="line-modified">!                 return &amp;unnamedType;</span>
              return nullptr;
<span class="line-modified">!         }, [](Ref&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
              return nullptr;
<span class="line-modified">!         }), types[0].get());</span>
          if (firstArgumentReference)
<span class="line-modified">!             return resolveWithOperatorLength(callExpression, *firstArgumentReference, intrinsics);</span>
<span class="line-modified">!     } else if (callExpression.name() == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified">!         auto isAcceptable = [](ResolvingType&amp; resolvingType) -&gt; bool {</span>
<span class="line-modified">!             return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified">!                 return is&lt;AST::ReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="line-modified">!             }, [](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified">!                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified">!             }), resolvingType);</span>
          };
<span class="line-modified">!         if (isAcceptable(types[0].get()) &amp;&amp; isAcceptable(types[1].get()))</span>
<span class="line-modified">!             return resolveWithReferenceComparator(callExpression, types[0].get(), types[1].get(), intrinsics);</span>
      }
      return WTF::nullopt;
  }
  
  static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
<span class="line-new-header">--- 100,253 ---</span>
      void visit(AST::ArrayType&amp; arrayType) override
      {
          Visitor::visit(arrayType);
      }
  
<span class="line-modified">!     void visit(AST::PointerType&amp; pointerType) override</span>
      {
<span class="line-modified">!         setError(Error(&quot;Illegal use of pointer in entrypoint semantic.&quot;, pointerType.codeLocation()));</span>
      }
  
<span class="line-modified">!     void visit(AST::ArrayReferenceType&amp; arrayReferenceType) override</span>
      {
<span class="line-modified">!         setError(Error(&quot;Illegal use of array reference in entrypoint semantic.&quot;, arrayReferenceType.codeLocation()));</span>
      }
  
      void visit(AST::TypeReference&amp; typeReference) override
      {
<span class="line-modified">!         checkErrorAndVisit(typeReference.resolvedType());</span>
      }
  };
  
<span class="line-modified">! class FunctionKey {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     FunctionKey() = default;</span>
<span class="line-added">+     FunctionKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_castReturnType = bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     FunctionKey(String name, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types, AST::NamedType* castReturnType = nullptr)</span>
<span class="line-added">+         : m_name(WTFMove(name))</span>
<span class="line-added">+         , m_types(WTFMove(types))</span>
<span class="line-added">+         , m_castReturnType(castReturnType)</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isEmptyValue() const { return m_name.isNull(); }</span>
<span class="line-added">+     bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned hash() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         unsigned hash = IntHash&lt;size_t&gt;::hash(m_types.size());</span>
<span class="line-added">+         hash ^= m_name.hash();</span>
<span class="line-added">+         for (size_t i = 0; i &lt; m_types.size(); ++i)</span>
<span class="line-added">+             hash ^= m_types[i].get().hash() + i;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_castReturnType)</span>
<span class="line-added">+             hash ^= WTF::PtrHash&lt;AST::Type*&gt;::hash(&amp;m_castReturnType-&gt;unifyNode());</span>
<span class="line-added">+ </span>
<span class="line-added">+         return hash;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool operator==(const FunctionKey&amp; other) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_types.size() != other.m_types.size())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_name != other.m_name)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (size_t i = 0; i &lt; m_types.size(); ++i) {</span>
<span class="line-added">+             if (!matches(m_types[i].get(), other.m_types[i].get()))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (static_cast&lt;bool&gt;(m_castReturnType) != static_cast&lt;bool&gt;(other.m_castReturnType))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!m_castReturnType)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (&amp;m_castReturnType-&gt;unifyNode() == &amp;other.m_castReturnType-&gt;unifyNode())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct Hash {</span>
<span class="line-added">+         static unsigned hash(const FunctionKey&amp; key)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return key.hash();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return a == b;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added">+         static const bool emptyValueIsZero = false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {</span>
<span class="line-added">+         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added">+         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     String m_name;</span>
<span class="line-added">+     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;</span>
<span class="line-added">+     AST::NamedType* m_castReturnType;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class AndOverloadTypeKey {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     AndOverloadTypeKey() = default;</span>
<span class="line-added">+     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="line-added">+         : m_type(&amp;type)</span>
<span class="line-added">+         , m_addressSpace(addressSpace)</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isEmptyValue() const { return !m_type; }</span>
<span class="line-added">+     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned hash() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return m_addressSpace == other.m_addressSpace</span>
<span class="line-added">+             &amp;&amp; *m_type == *other.m_type;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct Hash {</span>
<span class="line-added">+         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return key.hash();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return a == b;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="line-added">+         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-added">+         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     AST::UnnamedType* m_type { nullptr };</span>
<span class="line-added">+     AST::AddressSpace m_addressSpace;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
  }
  
<span class="line-modified">! static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
  }
  
<span class="line-modified">! static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)</span>
  {
      const bool isOperator = true;
<span class="line-modified">!     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());</span>
<span class="line-modified">!     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return unnamedType.copyRef();</span>
<span class="line-modified">!     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!             return unnamedType.copyRef();</span>
<span class="line-modified">!         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
              // We encountered &quot;null == null&quot;.
<span class="line-modified">!             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals</span>
<span class="line-modified">!             ASSERT_NOT_REACHED();</span>
<span class="line-modified">!             return AST::TypeReference::wrap(location, intrinsics.intType());</span>
<span class="line-modified">!         }));</span>
<span class="line-modified">!     }));</span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));</span>
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));</span>
<span class="line-modified">!     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
  }
  
<span class="line-modified">! enum class Acceptability {</span>
<span class="line-added">+     Yes,</span>
<span class="line-added">+     Maybe,</span>
<span class="line-added">+     No</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)</span>
  {
<span class="line-modified">!     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified">!         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
              if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
                  return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));
              return nullptr;
<span class="line-modified">!         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
              return nullptr;
<span class="line-modified">!         }));</span>
<span class="line-modified">!         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
              return matches(unnamedType, intrinsics.uintType());
<span class="line-modified">!         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
              return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());
<span class="line-modified">!         }));</span>
          if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)
<span class="line-modified">!             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-modified">!     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-modified">!         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
              if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))
<span class="line-modified">!                 return unnamedType.ptr();</span>
              return nullptr;
<span class="line-modified">!         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
              return nullptr;
<span class="line-modified">!         }));</span>
          if (firstArgumentReference)
<span class="line-modified">!             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="line-modified">!     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-modified">!         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {</span>
<span class="line-modified">!             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {</span>
<span class="line-modified">!                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();</span>
<span class="line-modified">!                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;</span>
<span class="line-modified">!             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="line-modified">!                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
<span class="line-added">+             }));</span>
          };
<span class="line-modified">!         auto leftAcceptability = acceptability(types[0].get());</span>
<span class="line-modified">!         auto rightAcceptability = acceptability(types[1].get());</span>
<span class="line-added">+         bool success = false;</span>
<span class="line-added">+         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {</span>
<span class="line-added">+             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();</span>
<span class="line-added">+             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();</span>
<span class="line-added">+             success = matches(unnamedType1, unnamedType2);</span>
<span class="line-added">+         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="line-added">+             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="line-added">+             success = true;</span>
<span class="line-added">+         if (success)</span>
<span class="line-added">+             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);</span>
      }
      return WTF::nullopt;
  }
  
  static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,11 ***</span>
                      podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
                  else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
                      podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
                  else
                      continue;
<span class="line-modified">!                 if (podChecker.error())</span>
                      return false;
              }
              return true;
          };
          if (!checkPODData(inputItems))
<span class="line-new-header">--- 411,11 ---</span>
                      podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
                  else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
                      podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
                  else
                      continue;
<span class="line-modified">!                 if (podChecker.hasError())</span>
                      return false;
              }
              return true;
          };
          if (!checkPODData(inputItems))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,29 ***</span>
      }
  
      return true;
  }
  
<span class="line-modified">! static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, const Intrinsics&amp; intrinsics, NameContext&amp; nameContext)</span>
  {
      enum class CheckKind {
          Index,
          Dot
      };
  
      auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
          size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
          if (functionDefinition.parameters().size() != numExpectedParameters)
              return false;
<span class="line-modified">!         auto&amp; firstParameterUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
          if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
              if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
                  return false;
          }
          if (kind == CheckKind::Index) {
<span class="line-modified">!             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
              if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
                  return false;
              auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
              if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
                  return false;
<span class="line-new-header">--- 425,29 ---</span>
      }
  
      return true;
  }
  
<span class="line-modified">! static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
  {
      enum class CheckKind {
          Index,
          Dot
      };
  
      auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {
          size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;
          if (functionDefinition.parameters().size() != numExpectedParameters)
              return false;
<span class="line-modified">!         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
          if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);
              if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
                  return false;
          }
          if (kind == CheckKind::Index) {
<span class="line-modified">!             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
              if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
                  return false;
              auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
              if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
                  return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,42 ***</span>
  
      auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
          size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
          if (functionDefinition.parameters().size() != numExpectedParameters)
              return false;
<span class="line-modified">!         auto&amp; firstArgumentUnifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
          if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
              if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
                  return false;
          }
          if (kind == CheckKind::Index) {
<span class="line-modified">!             auto&amp; secondParameterUnifyNode = (*functionDefinition.parameters()[1].type())-&gt;unifyNode();</span>
              if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
                  return false;
              auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
              if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
                  return false;
              auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
              if (!nativeTypeDeclaration.isInt())
                  return false;
          }
<span class="line-modified">!         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0].type()))</span>
              return false;
<span class="line-modified">!         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1].type();</span>
          auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<span class="line-modified">!         auto* getterFuncs = nameContext.getFunctions(getterName);</span>
<span class="line-removed">-         if (!getterFuncs)</span>
<span class="line-removed">-             return false;</span>
          Vector&lt;ResolvingType&gt; argumentTypes;
          Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
          for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<span class="line-modified">!             argumentTypes.append((*functionDefinition.parameters()[0].type())-&gt;clone());</span>
          for (auto&amp; argumentType : argumentTypes)
              argumentTypeReferences.append(argumentType);
<span class="line-modified">!         Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-removed">-         auto* overload = resolveFunctionOverloadImpl(*getterFuncs, argumentTypeReferences, castReturnType);</span>
          if (!overload)
              return false;
          auto&amp; resultType = overload-&gt;type();
          return matches(resultType, valueType);
      };
<span class="line-new-header">--- 460,39 ---</span>
  
      auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {
          size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;
          if (functionDefinition.parameters().size() != numExpectedParameters)
              return false;
<span class="line-modified">!         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
          if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);
              if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))
                  return false;
          }
          if (kind == CheckKind::Index) {
<span class="line-modified">!             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
              if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))
                  return false;
              auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);
              if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
                  return false;
              auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
              if (!nativeTypeDeclaration.isInt())
                  return false;
          }
<span class="line-modified">!         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
              return false;
<span class="line-modified">!         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
          auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);
<span class="line-modified">!         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>
          Vector&lt;ResolvingType&gt; argumentTypes;
          Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;
          for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)
<span class="line-modified">!             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
          for (auto&amp; argumentType : argumentTypes)
              argumentTypeReferences.append(argumentType);
<span class="line-modified">!         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>
          if (!overload)
              return false;
          auto&amp; resultType = overload-&gt;type();
          return matches(resultType, valueType);
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
              if (!is&lt;AST::PointerType&gt;(unnamedType))
                  return false;
          }
          {
<span class="line-modified">!             auto&amp; unifyNode = (*functionDefinition.parameters()[0].type())-&gt;unifyNode();</span>
              if (!is&lt;AST::UnnamedType&gt;(unifyNode))
                  return false;
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
              return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
          }
<span class="line-new-header">--- 508,11 ---</span>
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
              if (!is&lt;AST::PointerType&gt;(unnamedType))
                  return false;
          }
          {
<span class="line-modified">!             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
              if (!is&lt;AST::UnnamedType&gt;(unifyNode))
                  return false;
              auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
              return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,33 ***</span>
          return true;
      if (functionDefinition.isCast())
          return true;
      if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
          return functionDefinition.parameters().size() == 1
<span class="line-modified">!             &amp;&amp; matches(*functionDefinition.parameters()[0].type(), functionDefinition.type());</span>
      }
      if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
          return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
      if (functionDefinition.name() == &quot;operator*&quot;
          || functionDefinition.name() == &quot;operator/&quot;
          || functionDefinition.name() == &quot;operator%&quot;
          || functionDefinition.name() == &quot;operator&amp;&quot;
          || functionDefinition.name() == &quot;operator|&quot;
          || functionDefinition.name() == &quot;operator^&quot;
          || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<span class="line-modified">!         || functionDefinition.name() == &quot;opreator&gt;&gt;&quot;)</span>
          return functionDefinition.parameters().size() == 2;
      if (functionDefinition.name() == &quot;operator~&quot;)
          return functionDefinition.parameters().size() == 1;
<span class="line-removed">-     if (functionDefinition.name() == &quot;operator==&quot;</span>
<span class="line-removed">-         || functionDefinition.name() == &quot;operator&lt;&quot;</span>
<span class="line-removed">-         || functionDefinition.name() == &quot;operator&lt;=&quot;</span>
<span class="line-removed">-         || functionDefinition.name() == &quot;operator&gt;&quot;</span>
<span class="line-removed">-         || functionDefinition.name() == &quot;operator&gt;=&quot;) {</span>
<span class="line-removed">-         return functionDefinition.parameters().size() == 2</span>
<span class="line-removed">-             &amp;&amp; matches(functionDefinition.type(), intrinsics.boolType());</span>
<span class="line-removed">-     }</span>
      if (functionDefinition.name() == &quot;operator[]&quot;)
          return checkGetter(CheckKind::Index);
      if (functionDefinition.name() == &quot;operator[]=&quot;)
          return checkSetter(CheckKind::Index);
      if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
<span class="line-new-header">--- 522,25 ---</span>
          return true;
      if (functionDefinition.isCast())
          return true;
      if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
          return functionDefinition.parameters().size() == 1
<span class="line-modified">!             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());</span>
      }
      if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
          return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
      if (functionDefinition.name() == &quot;operator*&quot;
          || functionDefinition.name() == &quot;operator/&quot;
          || functionDefinition.name() == &quot;operator%&quot;
          || functionDefinition.name() == &quot;operator&amp;&quot;
          || functionDefinition.name() == &quot;operator|&quot;
          || functionDefinition.name() == &quot;operator^&quot;
          || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
<span class="line-modified">!         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)</span>
          return functionDefinition.parameters().size() == 2;
      if (functionDefinition.name() == &quot;operator~&quot;)
          return functionDefinition.parameters().size() == 1;
      if (functionDefinition.name() == &quot;operator[]&quot;)
          return checkGetter(CheckKind::Index);
      if (functionDefinition.name() == &quot;operator[]=&quot;)
          return checkSetter(CheckKind::Index);
      if (functionDefinition.name() == &quot;operator&amp;[]&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,33 ***</span>
  public:
      Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
          : m_intrinsics(intrinsics)
          , m_program(program)
      {
      }
  
<span class="line-modified">!     ~Checker() = default;</span>
  
      void visit(Program&amp;) override;
  
<span class="line-modified">!     bool assignTypes();</span>
  
  private:
      bool checkShaderType(const AST::FunctionDefinition&amp;);
<span class="line-removed">-     void finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp;, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType = nullptr);</span>
      bool isBoolType(ResolvingType&amp;);
      struct RecurseInfo {
          ResolvingType&amp; resolvingType;
<span class="line-modified">!         Optional&lt;AST::AddressSpace&gt;&amp; addressSpace;</span>
      };
<span class="line-modified">!     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified">!     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLValue = false);</span>
<span class="line-modified">!     Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
      bool recurseAndRequireBoolType(AST::Expression&amp;);
<span class="line-modified">!     void assignType(AST::Expression&amp;, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified">!     void assignType(AST::Expression&amp;, Ref&lt;ResolvableTypeReference&gt;&amp;&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
<span class="line-modified">!     void forwardType(AST::Expression&amp;, ResolvingType&amp;, Optional&lt;AST::AddressSpace&gt; = WTF::nullopt);</span>
  
      void visit(AST::FunctionDefinition&amp;) override;
      void visit(AST::EnumerationDefinition&amp;) override;
      void visit(AST::TypeReference&amp;) override;
      void visit(AST::VariableDeclaration&amp;) override;
<span class="line-new-header">--- 559,51 ---</span>
  public:
      Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
          : m_intrinsics(intrinsics)
          , m_program(program)
      {
<span class="line-added">+         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {</span>
<span class="line-added">+             AST::NamedType* castReturnType = nullptr;</span>
<span class="line-added">+             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))</span>
<span class="line-added">+                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());</span>
<span class="line-added">+ </span>
<span class="line-added">+             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;</span>
<span class="line-added">+             types.reserveInitialCapacity(function.parameters().size());</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (auto&amp; param : function.parameters())</span>
<span class="line-added">+                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;());</span>
<span class="line-added">+             addResult.iterator-&gt;value.append(function);</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (auto&amp; function : m_program.functionDefinitions())</span>
<span class="line-added">+             addFunction(function.get());</span>
<span class="line-added">+         for (auto&amp; function : m_program.nativeFunctionDeclarations())</span>
<span class="line-added">+             addFunction(function.get());</span>
      }
  
<span class="line-modified">!     virtual ~Checker() = default;</span>
  
      void visit(Program&amp;) override;
  
<span class="line-modified">!     Expected&lt;void, Error&gt; assignTypes();</span>
  
  private:
      bool checkShaderType(const AST::FunctionDefinition&amp;);
      bool isBoolType(ResolvingType&amp;);
      struct RecurseInfo {
          ResolvingType&amp; resolvingType;
<span class="line-modified">!         const AST::TypeAnnotation typeAnnotation;</span>
      };
<span class="line-modified">!     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified">!     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);</span>
<span class="line-modified">!     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);</span>
      bool recurseAndRequireBoolType(AST::Expression&amp;);
<span class="line-modified">!     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);</span>
<span class="line-modified">!     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);</span>
<span class="line-modified">!     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);</span>
  
      void visit(AST::FunctionDefinition&amp;) override;
      void visit(AST::EnumerationDefinition&amp;) override;
      void visit(AST::TypeReference&amp;) override;
      void visit(AST::VariableDeclaration&amp;) override;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,17 ***</span>
      void visit(AST::SwitchStatement&amp;) override;
      void visit(AST::CommaExpression&amp;) override;
      void visit(AST::TernaryExpression&amp;) override;
      void visit(AST::CallExpression&amp;) override;
  
<span class="line-modified">!     HashMap&lt;AST::Expression*, ResolvingType&gt; m_typeMap;</span>
<span class="line-modified">!     HashMap&lt;AST::Expression*, Optional&lt;AST::AddressSpace&gt;&gt; m_addressSpaceMap;</span>
<span class="line-modified">!     HashSet&lt;String&gt; m_vertexEntryPoints;</span>
<span class="line-modified">!     HashSet&lt;String&gt; m_fragmentEntryPoints;</span>
<span class="line-modified">!     HashSet&lt;String&gt; m_computeEntryPoints;</span>
      const Intrinsics&amp; m_intrinsics;
      Program&amp; m_program;
  };
  
  void Checker::visit(Program&amp; program)
  {
      // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
<span class="line-new-header">--- 633,54 ---</span>
      void visit(AST::SwitchStatement&amp;) override;
      void visit(AST::CommaExpression&amp;) override;
      void visit(AST::TernaryExpression&amp;) override;
      void visit(AST::CallExpression&amp;) override;
  
<span class="line-modified">!     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="line-added">+ </span>
<span class="line-added">+     AST::UnnamedType&amp; wrappedFloatType()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!m_wrappedFloatType)</span>
<span class="line-added">+             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());</span>
<span class="line-added">+         return *m_wrappedFloatType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     AST::UnnamedType&amp; genericPointerType()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!m_genericPointerType)</span>
<span class="line-added">+             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="line-added">+         return *m_genericPointerType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto* unifyNode = &amp;type.unifyNode();</span>
<span class="line-added">+         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())</span>
<span class="line-added">+             return wrappedFloatType();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="line-added">+             return genericPointerType();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return type;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;</span>
<span class="line-added">+     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
<span class="line-added">+     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;</span>
<span class="line-added">+     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added">+     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];</span>
<span class="line-added">+     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];</span>
      const Intrinsics&amp; m_intrinsics;
      Program&amp; m_program;
<span class="line-added">+     AST::FunctionDefinition* m_currentFunction { nullptr };</span>
<span class="line-added">+     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;</span>
<span class="line-added">+     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
<span class="line-added">+     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };</span>
  };
  
  void Checker::visit(Program&amp; program)
  {
      // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,114 ***</span>
          checkErrorAndVisit(program.functionDefinitions()[i]);
      for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
          checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
  }
  
<span class="line-modified">! bool Checker::assignTypes()</span>
  {
      for (auto&amp; keyValuePair : m_typeMap) {
<span class="line-modified">!         auto success = WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified">!             keyValuePair.key-&gt;setType(unnamedType-&gt;clone());</span>
              return true;
<span class="line-modified">!         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified">!             if (!resolvableTypeReference-&gt;resolvableType().resolvedType()) {</span>
<span class="line-removed">-                 // FIXME: Instead of trying to commit, it might be better to just return an error instead.</span>
                  if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
                      return false;
              }
<span class="line-modified">!             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType()-&gt;clone());</span>
              return true;
<span class="line-modified">!         }), keyValuePair.value);</span>
          if (!success)
<span class="line-modified">!             return false;</span>
      }
  
<span class="line-modified">!     for (auto&amp; keyValuePair : m_addressSpaceMap)</span>
<span class="line-removed">-         keyValuePair.key-&gt;setAddressSpace(keyValuePair.value);</span>
<span class="line-removed">-     return true;</span>
  }
  
  bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
  {
      switch (*functionDefinition.entryPointType()) {
      case AST::EntryPointType::Vertex:
<span class="line-modified">!         return !m_vertexEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
      case AST::EntryPointType::Fragment:
<span class="line-modified">!         return !m_fragmentEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
      case AST::EntryPointType::Compute:
<span class="line-modified">!         return !m_computeEntryPoints.add(functionDefinition.name()).isNewEntry;</span>
      }
  }
  
  void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
  {
      if (functionDefinition.entryPointType()) {
          if (!checkShaderType(functionDefinition)) {
<span class="line-modified">!             setError();</span>
              return;
          }
          auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
          if (!entryPointItems) {
<span class="line-modified">!             setError();</span>
              return;
          }
          if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<span class="line-modified">!             setError();</span>
              return;
          }
      }
<span class="line-modified">!     if (!checkOperatorOverload(functionDefinition, m_intrinsics, m_program.nameContext())) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     checkErrorAndVisit(functionDefinition);</span>
  }
  
<span class="line-modified">! static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
  {
<span class="line-modified">!     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified">!         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
              if (matches(left, right))
<span class="line-modified">!                 return left-&gt;clone();</span>
<span class="line-modified">!             return WTF::nullopt;</span>
<span class="line-modified">!         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
              return matchAndCommit(left, right-&gt;resolvableType());
<span class="line-modified">!         }), right);</span>
<span class="line-modified">!     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified">!         return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
              return matchAndCommit(right, left-&gt;resolvableType());
<span class="line-modified">!         }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; right) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
              return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<span class="line-modified">!         }), right);</span>
<span class="line-modified">!     }), left);</span>
  }
  
<span class="line-modified">! static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
          if (matches(unnamedType, resolvingType))
<span class="line-modified">!             return unnamedType.clone();</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
          return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<span class="line-modified">!     }), resolvingType);</span>
  }
  
<span class="line-modified">! static Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)</span>
  {
<span class="line-modified">!     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified">!         if (matches(resolvingType, namedType))</span>
<span class="line-modified">!             return resolvingType-&gt;clone();</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; {</span>
<span class="line-modified">!         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());</span>
<span class="line-modified">!     }), resolvingType);</span>
  }
  
  void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
  {
      auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
          checkErrorAndVisit(enumerationDefinition.type());
          auto&amp; baseType = enumerationDefinition.type().unifyNode();
          if (!is&lt;AST::NamedType&gt;(baseType))
              return nullptr;
<span class="line-new-header">--- 697,162 ---</span>
          checkErrorAndVisit(program.functionDefinitions()[i]);
      for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
          checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
  }
  
<span class="line-modified">! Expected&lt;void, Error&gt; Checker::assignTypes()</span>
  {
      for (auto&amp; keyValuePair : m_typeMap) {
<span class="line-modified">!         auto success = keyValuePair.value-&gt;visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-modified">!             keyValuePair.key-&gt;setType(unnamedType.copyRef());</span>
              return true;
<span class="line-modified">!         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-modified">!             if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType()) {</span>
                  if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
                      return false;
              }
<span class="line-modified">!             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType());</span>
              return true;
<span class="line-modified">!         }));</span>
          if (!success)
<span class="line-modified">!             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
      }
  
<span class="line-modified">!     return { };</span>
  }
  
  bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
  {
<span class="line-added">+     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);</span>
      switch (*functionDefinition.entryPointType()) {
      case AST::EntryPointType::Vertex:
<span class="line-modified">!         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));</span>
      case AST::EntryPointType::Fragment:
<span class="line-modified">!         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));</span>
      case AST::EntryPointType::Compute:
<span class="line-modified">!         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));</span>
      }
  }
  
  void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
  {
<span class="line-added">+     m_currentNameSpace = functionDefinition.nameSpace();</span>
<span class="line-added">+     m_currentFunction = &amp;functionDefinition;</span>
      if (functionDefinition.entryPointType()) {
          if (!checkShaderType(functionDefinition)) {
<span class="line-modified">!             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));</span>
              return;
          }
          auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
          if (!entryPointItems) {
<span class="line-modified">!             setError(entryPointItems.error());</span>
              return;
          }
          if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
<span class="line-modified">!             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));</span>
              return;
          }
      }
<span class="line-modified">!     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
<span class="line-modified">!         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     Visitor::visit(functionDefinition);</span>
  }
  
<span class="line-modified">! static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)</span>
  {
<span class="line-modified">!     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
              if (matches(left, right))
<span class="line-modified">!                 return left.copyRef();</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-modified">!         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
              return matchAndCommit(left, right-&gt;resolvableType());
<span class="line-modified">!         }));</span>
<span class="line-modified">!     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
              return matchAndCommit(right, left-&gt;resolvableType());
<span class="line-modified">!         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
              return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
<span class="line-modified">!         }));</span>
<span class="line-modified">!     }));</span>
  }
  
<span class="line-modified">! static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)</span>
  {
<span class="line-modified">!     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
          if (matches(unnamedType, resolvingType))
<span class="line-modified">!             return &amp;unnamedType;</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
          return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
<span class="line-modified">!     }));</span>
  }
  
<span class="line-modified">! static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)</span>
  {
<span class="line-modified">!     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         return unnamedType.copyRef();</span>
<span class="line-modified">!     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-modified">!             return commit(resolvableTypeReference-&gt;resolvableType());</span>
<span class="line-modified">!         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-modified">!     }));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;</span>
<span class="line-added">+     unnamedTypes.reserveInitialCapacity(types.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto resolvingType : types) {</span>
<span class="line-added">+         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-added">+             return unnamedType.ptr();</span>
<span class="line-added">+         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {</span>
<span class="line-added">+             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())</span>
<span class="line-added">+                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()</span>
<span class="line-added">+                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()</span>
<span class="line-added">+                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())</span>
<span class="line-added">+                 return &amp;wrappedFloatType();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="line-added">+                 return &amp;genericPointerType();</span>
<span class="line-added">+ </span>
<span class="line-added">+             return commit(resolvableTypeReference-&gt;resolvableType()).get();</span>
<span class="line-added">+         }));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!type) {</span>
<span class="line-added">+             setError(Error(&quot;Could not resolve the type of a constant.&quot;));</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });</span>
<span class="line-added">+         if (iter != m_functions.end()) {</span>
<span class="line-added">+             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))</span>
<span class="line-added">+                 return function;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {</span>
<span class="line-added">+         m_program.append(WTFMove(*newFunction));</span>
<span class="line-added">+         return &amp;m_program.nativeFunctionDeclarations().last();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
  }
  
  void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
  {
<span class="line-added">+     bool isSigned;</span>
      auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
          checkErrorAndVisit(enumerationDefinition.type());
          auto&amp; baseType = enumerationDefinition.type().unifyNode();
          if (!is&lt;AST::NamedType&gt;(baseType))
              return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,156 ***</span>
          if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
              return nullptr;
          auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
          if (!nativeTypeDeclaration.isInt())
              return nullptr;
          return &amp;nativeTypeDeclaration;
      })();
      if (!baseType) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
      auto enumerationMembers = enumerationDefinition.enumerationMembers();
  
      for (auto&amp; member : enumerationMembers) {
<span class="line-modified">!         if (!member.get().value())</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         bool success = false;</span>
<span class="line-removed">-         member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::Expression&amp; value) {</span>
<span class="line-removed">-             auto valueInfo = recurseAndGetInfo(value);</span>
<span class="line-removed">-             if (!valueInfo)</span>
                  return;
<span class="line-modified">!             success = static_cast&lt;bool&gt;(matchAndCommit(valueInfo-&gt;resolvingType, *baseType));</span>
<span class="line-removed">-         }));</span>
<span class="line-removed">-         if (!success) {</span>
<span class="line-removed">-             setError();</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int64_t nextValue = 0;</span>
<span class="line-removed">-     for (auto&amp; member : enumerationMembers) {</span>
<span class="line-removed">-         if (member.get().value()) {</span>
<span class="line-removed">-             int64_t value;</span>
<span class="line-removed">-             member.get().value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed">-                 value = integerLiteral.valueForSelectedType();</span>
<span class="line-removed">-             }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed">-                 value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed">-             }, [&amp;](auto&amp;) {</span>
<span class="line-removed">-                 ASSERT_NOT_REACHED();</span>
<span class="line-removed">-             }));</span>
<span class="line-removed">-             nextValue = baseType-&gt;successor()(value);</span>
          } else {
<span class="line-modified">!             if (nextValue &gt; std::numeric_limits&lt;int&gt;::max()) {</span>
<span class="line-modified">!                 ASSERT(nextValue &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified">!                 member.get().setValue(AST::ConstantExpression(AST::UnsignedIntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;unsigned&gt;(nextValue))));</span>
              }
<span class="line-removed">-             ASSERT(nextValue &gt;= std::numeric_limits&lt;int&gt;::min());</span>
<span class="line-removed">-             member.get().setValue(AST::ConstantExpression(AST::IntegerLiteral(Lexer::Token(member.get().origin()), static_cast&lt;int&gt;(nextValue))));</span>
<span class="line-removed">-             nextValue = baseType-&gt;successor()(nextValue);</span>
          }
      }
  
<span class="line-removed">-     auto getValue = [&amp;](AST::EnumerationMember&amp; member) -&gt; int64_t {</span>
<span class="line-removed">-         int64_t value;</span>
<span class="line-removed">-         ASSERT(member.value());</span>
<span class="line-removed">-         member.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-removed">-             value = integerLiteral.value();</span>
<span class="line-removed">-         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-removed">-             value = unsignedIntegerLiteral.value();</span>
<span class="line-removed">-         }, [&amp;](auto&amp;) {</span>
<span class="line-removed">-             ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }));</span>
<span class="line-removed">-         return value;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<span class="line-modified">!         auto value = getValue(enumerationMembers[i].get());</span>
          for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<span class="line-modified">!             auto otherValue = getValue(enumerationMembers[j].get());</span>
              if (value == otherValue) {
<span class="line-modified">!                 setError();</span>
                  return;
              }
          }
      }
  
      bool foundZero = false;
      for (auto&amp; member : enumerationMembers) {
<span class="line-modified">!         if (!getValue(member.get())) {</span>
              foundZero = true;
              break;
          }
      }
      if (!foundZero) {
<span class="line-modified">!         setError();</span>
          return;
      }
  }
  
  void Checker::visit(AST::TypeReference&amp; typeReference)
  {
<span class="line-modified">!     ASSERT(typeReference.resolvedType());</span>
  
<span class="line-modified">!     checkErrorAndVisit(typeReference);</span>
  }
  
<span class="line-modified">! auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
  {
<span class="line-modified">!     checkErrorAndVisit(expression);</span>
<span class="line-modified">!     if (!error())</span>
          return WTF::nullopt;
<span class="line-modified">!     return getInfo(expression, requiresLValue);</span>
  }
  
<span class="line-modified">! auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
  {
      auto typeIterator = m_typeMap.find(&amp;expression);
      ASSERT(typeIterator != m_typeMap.end());
  
<span class="line-modified">!     auto addressSpaceIterator = m_addressSpaceMap.find(&amp;expression);</span>
<span class="line-modified">!     ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified">!     if (requiresLValue &amp;&amp; !addressSpaceIterator-&gt;value) {</span>
<span class="line-removed">-         setError();</span>
          return WTF::nullopt;
      }
<span class="line-modified">!     return {{ typeIterator-&gt;value, addressSpaceIterator-&gt;value }};</span>
  }
  
  void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
  {
      // ReadModifyWriteExpressions are the only place where anonymous variables exist,
      // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
      checkErrorAndVisit(*variableDeclaration.type());
      if (variableDeclaration.initializer()) {
          auto&amp; lhsType = *variableDeclaration.type();
          auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
          if (!initializerInfo)
              return;
          if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<span class="line-modified">!             setError();</span>
              return;
          }
      }
  }
  
<span class="line-modified">! void Checker::assignType(AST::Expression&amp; expression, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; unnamedType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
  {
<span class="line-modified">!     auto addResult = m_typeMap.add(&amp;expression, WTFMove(unnamedType));</span>
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed">-     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
  }
  
<span class="line-modified">! void Checker::assignType(AST::Expression&amp; expression, Ref&lt;ResolvableTypeReference&gt;&amp;&amp; resolvableTypeReference, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
  {
<span class="line-modified">!     auto addResult = m_typeMap.add(&amp;expression, WTFMove(resolvableTypeReference));</span>
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-modified">!     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
  }
  
  void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
  {
      auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
<span class="line-new-header">--- 860,133 ---</span>
          if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
              return nullptr;
          auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
          if (!nativeTypeDeclaration.isInt())
              return nullptr;
<span class="line-added">+         isSigned = nativeTypeDeclaration.isSigned();</span>
          return &amp;nativeTypeDeclaration;
      })();
      if (!baseType) {
<span class="line-modified">!         setError(Error(&quot;Invalid base type for enum.&quot;, enumerationDefinition.codeLocation()));</span>
          return;
      }
  
      auto enumerationMembers = enumerationDefinition.enumerationMembers();
  
      for (auto&amp; member : enumerationMembers) {
<span class="line-modified">!         int64_t value = member.get().value();</span>
<span class="line-modified">!         if (isSigned) {</span>
<span class="line-modified">!             if (static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(value)) != value) {</span>
<span class="line-modified">!                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>
                  return;
<span class="line-modified">!             }</span>
          } else {
<span class="line-modified">!             if (static_cast&lt;int64_t&gt;(static_cast&lt;uint32_t&gt;(value)) != value) {</span>
<span class="line-modified">!                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));</span>
<span class="line-modified">!                 return;</span>
              }
          }
      }
  
      for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
<span class="line-modified">!         auto value = enumerationMembers[i].get().value();</span>
          for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
<span class="line-modified">!             auto otherValue = enumerationMembers[j].get().value();</span>
              if (value == otherValue) {
<span class="line-modified">!                 setError(Error(&quot;Cannot declare duplicate enumeration values.&quot;, enumerationMembers[j].get().codeLocation()));</span>
                  return;
              }
          }
      }
  
      bool foundZero = false;
      for (auto&amp; member : enumerationMembers) {
<span class="line-modified">!         if (!member.get().value()) {</span>
              foundZero = true;
              break;
          }
      }
      if (!foundZero) {
<span class="line-modified">!         setError(Error(&quot;enum definition must contain a zero value.&quot;, enumerationDefinition.codeLocation()));</span>
          return;
      }
  }
  
  void Checker::visit(AST::TypeReference&amp; typeReference)
  {
<span class="line-modified">!     ASSERT(typeReference.maybeResolvedType());</span>
  
<span class="line-modified">!     for (auto&amp; typeArgument : typeReference.typeArguments())</span>
<span class="line-added">+         checkErrorAndVisit(typeArgument);</span>
  }
  
<span class="line-modified">! auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
  {
<span class="line-modified">!     Visitor::visit(expression);</span>
<span class="line-modified">!     if (hasError())</span>
          return WTF::nullopt;
<span class="line-modified">!     return getInfo(expression, requiresLeftValue);</span>
  }
  
<span class="line-modified">! auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;</span>
  {
      auto typeIterator = m_typeMap.find(&amp;expression);
      ASSERT(typeIterator != m_typeMap.end());
  
<span class="line-modified">!     const auto&amp; typeAnnotation = expression.typeAnnotation();</span>
<span class="line-modified">!     if (requiresLeftValue &amp;&amp; typeAnnotation.isRightValue()) {</span>
<span class="line-modified">!         setError(Error(&quot;Unexpected rvalue.&quot;, expression.codeLocation()));</span>
          return WTF::nullopt;
      }
<span class="line-modified">!     return {{ *typeIterator-&gt;value, typeAnnotation }};</span>
  }
  
  void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
  {
      // ReadModifyWriteExpressions are the only place where anonymous variables exist,
      // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
      checkErrorAndVisit(*variableDeclaration.type());
<span class="line-added">+     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {</span>
<span class="line-added">+         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (variableDeclaration.initializer()) {
          auto&amp; lhsType = *variableDeclaration.type();
          auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
          if (!initializerInfo)
              return;
          if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
<span class="line-modified">!             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));</span>
              return;
          }
      }
  }
  
<span class="line-modified">! void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
  {
<span class="line-modified">!     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));</span>
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
  }
  
<span class="line-modified">! void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
  {
<span class="line-modified">!     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));</span>
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
<span class="line-modified">!     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())</span>
<span class="line-added">+ {</span>
<span class="line-added">+     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-added">+         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added">+         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">+     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-added">+         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));</span>
<span class="line-added">+         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">+     }));</span>
<span class="line-added">+     expression.setTypeAnnotation(WTFMove(typeAnnotation));</span>
  }
  
  void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
  {
      auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 778,62 ***</span>
      if (!rightInfo)
          return;
  
      auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
      if (!resultType) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     assignType(assignmentExpression, WTFMove(*resultType));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, Optional&lt;AST::AddressSpace&gt; addressSpace)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; result) {</span>
<span class="line-removed">-         auto addResult = m_typeMap.add(&amp;expression, result-&gt;clone());</span>
<span class="line-removed">-         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed">-     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; result) {</span>
<span class="line-removed">-         auto addResult = m_typeMap.add(&amp;expression, result.copyRef());</span>
<span class="line-removed">-         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-removed">-     }), resolvingType);</span>
<span class="line-removed">-     auto addressSpaceAddResult = m_addressSpaceMap.add(&amp;expression, addressSpace);</span>
<span class="line-removed">-     ASSERT_UNUSED(addressSpaceAddResult, addressSpaceAddResult.isNewEntry);</span>
  }
  
  void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
  {
<span class="line-modified">!     auto lValueInfo = recurseAndGetInfo(readModifyWriteExpression.lValue(), true);</span>
<span class="line-modified">!     if (!lValueInfo)</span>
          return;
  
<span class="line-modified">!     // FIXME: Figure out what to do with the ReadModifyWriteExpression&#39;s AnonymousVariables.</span>
  
<span class="line-modified">!     auto newValueInfo = recurseAndGetInfo(*readModifyWriteExpression.newValueExpression());</span>
      if (!newValueInfo)
          return;
  
<span class="line-modified">!     if (!matchAndCommit(lValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType)) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     auto resultInfo = recurseAndGetInfo(*readModifyWriteExpression.resultExpression());</span>
      if (!resultInfo)
          return;
  
      forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
  }
  
  static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
  {
<span class="line-modified">!     return WTF::visit(WTF::makeVisitor([](UniqueRef&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified">!         return &amp;type;</span>
<span class="line-modified">!     }, [](Ref&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
          // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<span class="line-modified">!         return type-&gt;resolvableType().resolvedType();</span>
<span class="line-modified">!     }), resolvingType);</span>
  }
  
  void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
  {
      auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
<span class="line-new-header">--- 997,51 ---</span>
      if (!rightInfo)
          return;
  
      auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
      if (!resultType) {
<span class="line-modified">!         setError(Error(&quot;Left hand side of assignment does not match the type of the right hand side.&quot;, assignmentExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     assignConcreteType(assignmentExpression, *resultType);</span>
  }
  
  void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
  {
<span class="line-modified">!     auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);</span>
<span class="line-modified">!     if (!leftValueInfo)</span>
          return;
  
<span class="line-modified">!     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());</span>
  
<span class="line-modified">!     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());</span>
      if (!newValueInfo)
          return;
  
<span class="line-modified">!     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))</span>
<span class="line-modified">!         readModifyWriteExpression.newValue().setType(*matchedType);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());</span>
      if (!resultInfo)
          return;
  
      forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);
  }
  
  static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
  {
<span class="line-modified">!     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
<span class="line-modified">!         return type.ptr();</span>
<span class="line-modified">!     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {</span>
          // FIXME: If the type isn&#39;t committed, should we just commit() it now?
<span class="line-modified">!         return type-&gt;resolvableType().maybeResolvedType();</span>
<span class="line-modified">!     }));</span>
  }
  
  void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
  {
      auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,267 ***</span>
          if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
              return nullptr;
          return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
      })(unnamedType);
      if (!pointerType) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     assignType(dereferenceExpression, pointerType-&gt;clone(), pointerType-&gt;addressSpace());</span>
  }
  
  void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
  {
<span class="line-modified">!     auto lValueInfo = recurseAndGetInfo(makePointerExpression.lValue(), true);</span>
<span class="line-modified">!     if (!lValueInfo)</span>
          return;
  
<span class="line-modified">!     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified">!     if (!lValueType) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     assignType(makePointerExpression, makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(makePointerExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>
  }
  
  void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
  {
<span class="line-modified">!     auto lValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.lValue());</span>
<span class="line-modified">!     if (!lValueInfo)</span>
          return;
  
<span class="line-modified">!     auto* lValueType = getUnnamedType(lValueInfo-&gt;resolvingType);</span>
<span class="line-modified">!     if (!lValueType) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     auto&amp; unifyNode = lValueType-&gt;unifyNode();</span>
      if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
          auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
          if (is&lt;AST::PointerType&gt;(unnamedType)) {
              auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="line-modified">!             // FIXME: Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified">!             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), pointerType.addressSpace(), pointerType.elementType().clone()));</span>
              return;
          }
  
<span class="line-modified">!         if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified">!             setError();</span>
              return;
          }
  
          if (is&lt;AST::ArrayType&gt;(unnamedType)) {
              auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<span class="line-modified">!             // FIXME: Save the number of elements.</span>
<span class="line-modified">!             assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, arrayType.type().clone()));</span>
              return;
          }
      }
  
<span class="line-modified">!     if (!lValueInfo-&gt;addressSpace) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     assignType(makeArrayReferenceExpression, makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(makeArrayReferenceExpression.origin()), *lValueInfo-&gt;addressSpace, lValueType-&gt;clone()));</span>
  }
  
<span class="line-modified">! void Checker::finishVisitingPropertyAccess(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::UnnamedType&amp; wrappedBaseType, AST::UnnamedType* extraArgumentType)</span>
  {
<span class="line-modified">!     Optional&lt;std::reference_wrapper&lt;AST::NamedType&gt;&gt; castReturnType;</span>
<span class="line-modified">!     using OverloadResolution = std::tuple&lt;AST::FunctionDeclaration*, AST::UnnamedType*&gt;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     AST::FunctionDeclaration* getFunction;</span>
<span class="line-modified">!     AST::UnnamedType* getReturnType;</span>
<span class="line-modified">!     std::tie(getFunction, getReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-removed">-         ResolvingType getArgumentType1(wrappedBaseType.clone());</span>
<span class="line-removed">-         Optional&lt;ResolvingType&gt; getArgumentType2;</span>
<span class="line-removed">-         if (extraArgumentType)</span>
<span class="line-removed">-             getArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getArgumentTypes;</span>
<span class="line-removed">-         getArgumentTypes.append(getArgumentType1);</span>
<span class="line-removed">-         if (getArgumentType2)</span>
<span class="line-removed">-             getArgumentTypes.append(*getArgumentType2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* getFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleGetOverloads(), getArgumentTypes, castReturnType);</span>
<span class="line-removed">-         if (!getFunction)</span>
<span class="line-removed">-             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">-         return std::make_pair(getFunction, &amp;getFunction-&gt;type());</span>
<span class="line-removed">-     })();</span>
  
<span class="line-modified">!     AST::FunctionDeclaration* andFunction;</span>
<span class="line-modified">!     AST::UnnamedType* andReturnType;</span>
<span class="line-modified">!     std::tie(andFunction, andReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified">!         auto computeAndArgumentType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; Optional&lt;ResolvingType&gt; {</span>
<span class="line-modified">!             if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">!                 return { unnamedType.clone() };</span>
<span class="line-modified">!             if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">!                 return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified">!             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified">!                 return WTF::nullopt;</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(propertyAccessExpression.origin()), AST::AddressSpace::Thread, downcast&lt;AST::ArrayType&gt;(unnamedType).type().clone()) };</span>
<span class="line-modified">!         };</span>
<span class="line-modified">!         auto computeAndReturnType = [&amp;](AST::UnnamedType&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-modified">!             if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-modified">!                 return &amp;downcast&lt;AST::PointerType&gt;(unnamedType).elementType();</span>
              return nullptr;
<span class="line-removed">-         };</span>
  
<span class="line-modified">!         auto andArgumentType1 = computeAndArgumentType(wrappedBaseType);</span>
<span class="line-modified">!         if (!andArgumentType1)</span>
<span class="line-removed">-             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">-         Optional&lt;ResolvingType&gt; andArgumentType2;</span>
<span class="line-removed">-         if (extraArgumentType)</span>
<span class="line-removed">-             andArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; andArgumentTypes;</span>
<span class="line-removed">-         andArgumentTypes.append(*andArgumentType1);</span>
<span class="line-removed">-         if (andArgumentType2)</span>
<span class="line-removed">-             andArgumentTypes.append(*andArgumentType2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* andFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleAndOverloads(), andArgumentTypes, castReturnType);</span>
<span class="line-removed">-         if (!andFunction)</span>
<span class="line-removed">-             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">-         return std::make_pair(andFunction, computeAndReturnType(andFunction-&gt;type()));</span>
<span class="line-removed">-     })();</span>
  
<span class="line-modified">!     if (!getReturnType &amp;&amp; !andReturnType) {</span>
<span class="line-modified">!         setError();</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (getReturnType &amp;&amp; andReturnType &amp;&amp; !matches(*getReturnType, *andReturnType)) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     AST::FunctionDeclaration* setFunction;</span>
<span class="line-modified">!     AST::UnnamedType* setReturnType;</span>
<span class="line-modified">!     std::tie(setFunction, setReturnType) = ([&amp;]() -&gt; OverloadResolution {</span>
<span class="line-modified">!         ResolvingType setArgument1Type(wrappedBaseType.clone());</span>
<span class="line-modified">!         Optional&lt;ResolvingType&gt; setArgumentType2;</span>
<span class="line-modified">!         if (extraArgumentType)</span>
<span class="line-modified">!             setArgumentType2 = ResolvingType(extraArgumentType-&gt;clone());</span>
<span class="line-modified">!         ResolvingType setArgument3Type(getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone());</span>
<span class="line-modified">! </span>
<span class="line-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setArgumentTypes;</span>
<span class="line-removed">-         setArgumentTypes.append(setArgument1Type);</span>
<span class="line-removed">-         if (setArgumentType2)</span>
<span class="line-removed">-             setArgumentTypes.append(*setArgumentType2);</span>
<span class="line-removed">-         setArgumentTypes.append(setArgument3Type);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* setFunction = resolveFunctionOverloadImpl(propertyAccessExpression.possibleSetOverloads(), setArgumentTypes, castReturnType);</span>
<span class="line-removed">-         if (!setFunction)</span>
<span class="line-removed">-             return std::make_pair(nullptr, nullptr);</span>
<span class="line-removed">-         return std::make_pair(setFunction, &amp;setFunction-&gt;type());</span>
<span class="line-removed">-     })();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (setFunction) {</span>
<span class="line-removed">-         if (!matches(setFunction-&gt;type(), wrappedBaseType)) {</span>
<span class="line-removed">-             setError();</span>
              return;
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-modified">!     if (getReturnType || andReturnType) {</span>
<span class="line-modified">!         // FIXME: The reference compiler has &quot;else if (!node.base.isLValue &amp;&amp; !baseType.isArrayRef)&quot;,</span>
<span class="line-modified">!         // but I don&#39;t understand why it exists. I haven&#39;t written it here, and I&#39;ll investigate</span>
<span class="line-modified">!         // if we can remove it from the reference compiler.</span>
<span class="line-modified">!         if (is&lt;AST::ReferenceType&gt;(wrappedBaseType))</span>
<span class="line-modified">!             addressSpace = downcast&lt;AST::ReferenceType&gt;(wrappedBaseType).addressSpace();</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             auto addressSpaceIterator = m_addressSpaceMap.find(&amp;propertyAccessExpression.base());</span>
<span class="line-modified">!             ASSERT(addressSpaceIterator != m_addressSpaceMap.end());</span>
<span class="line-modified">!             if (addressSpaceIterator-&gt;value)</span>
<span class="line-modified">!                 addressSpace = *addressSpaceIterator-&gt;value;</span>
<span class="line-removed">-             else {</span>
<span class="line-removed">-                 setError();</span>
                  return;
<span class="line-modified">!             }</span>
          }
      }
  
<span class="line-modified">!     // FIXME: Generate the call expressions</span>
<span class="line-modified">! </span>
<span class="line-modified">!     assignType(propertyAccessExpression, getReturnType ? getReturnType-&gt;clone() : andReturnType-&gt;clone(), addressSpace);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt; Checker::recurseAndWrapBaseType(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-modified">!     if (!baseInfo)</span>
<span class="line-removed">-         return WTF::nullopt;</span>
  
<span class="line-modified">!     auto* baseType = getUnnamedType(baseInfo-&gt;resolvingType);</span>
<span class="line-modified">!     if (!baseType) {</span>
<span class="line-modified">!         setError();</span>
<span class="line-removed">-         return WTF::nullopt;</span>
      }
<span class="line-removed">-     auto&amp; baseUnifyNode = baseType-&gt;unifyNode();</span>
<span class="line-removed">-     if (is&lt;AST::UnnamedType&gt;(baseUnifyNode))</span>
<span class="line-removed">-         return downcast&lt;AST::UnnamedType&gt;(baseUnifyNode).clone();</span>
<span class="line-removed">-     ASSERT(is&lt;AST::NamedType&gt;(baseUnifyNode));</span>
<span class="line-removed">-     return { AST::TypeReference::wrap(Lexer::Token(propertyAccessExpression.origin()), downcast&lt;AST::NamedType&gt;(baseUnifyNode)) };</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     auto baseType = recurseAndWrapBaseType(dotExpression);</span>
<span class="line-removed">-     if (!baseType)</span>
          return;
  
<span class="line-modified">!     finishVisitingPropertyAccess(dotExpression, *baseType);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     auto baseType = recurseAndWrapBaseType(indexExpression);</span>
<span class="line-removed">-     if (!baseType)</span>
          return;
  
<span class="line-modified">!     auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-modified">!     if (!indexInfo)</span>
          return;
<span class="line-modified">!     auto indexExpressionType = getUnnamedType(indexInfo-&gt;resolvingType);</span>
<span class="line-modified">!     if (!indexExpressionType) {</span>
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     finishVisitingPropertyAccess(indexExpression, WTFMove(*baseType), indexExpressionType);</span>
  }
  
  void Checker::visit(AST::VariableReference&amp; variableReference)
  {
      ASSERT(variableReference.variable());
      ASSERT(variableReference.variable()-&gt;type());
  
<span class="line-modified">!     Optional&lt;AST::AddressSpace&gt; addressSpace;</span>
<span class="line-removed">-     if (!variableReference.variable()-&gt;isAnonymous())</span>
<span class="line-removed">-         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed">-     assignType(variableReference, variableReference.variable()-&gt;type()-&gt;clone(), addressSpace);</span>
  }
  
  void Checker::visit(AST::Return&amp; returnStatement)
  {
<span class="line-removed">-     ASSERT(returnStatement.function());</span>
      if (returnStatement.value()) {
          auto valueInfo = recurseAndGetInfo(*returnStatement.value());
          if (!valueInfo)
              return;
<span class="line-modified">!         if (!matchAndCommit(valueInfo-&gt;resolvingType, returnStatement.function()-&gt;type()))</span>
<span class="line-modified">!             setError();</span>
          return;
      }
  
<span class="line-modified">!     if (!matches(returnStatement.function()-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">!         setError();</span>
  }
  
  void Checker::visit(AST::PointerType&amp;)
  {
      // Following pointer types can cause infinite loops because of data structures
<span class="line-new-header">--- 1060,279 ---</span>
          if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
              return nullptr;
          return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
      })(unnamedType);
      if (!pointerType) {
<span class="line-modified">!         setError(Error(&quot;Cannot dereference a non-pointer type.&quot;, dereferenceExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     assignConcreteType(dereferenceExpression, pointerType-&gt;elementType(), AST::LeftValue { pointerType-&gt;addressSpace() });</span>
  }
  
  void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
  {
<span class="line-modified">!     auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);</span>
<span class="line-modified">!     if (!leftValueInfo)</span>
          return;
  
<span class="line-modified">!     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">!     if (!leftAddressSpace) {</span>
<span class="line-modified">!         setError(Error(&quot;Cannot take the address of a non lvalue.&quot;, makePointerExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-added">+     if (!leftValueType) {</span>
<span class="line-added">+         setError(Error(&quot;Cannot take the address of a value without a type.&quot;, makePointerExpression.codeLocation()));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
  }
  
  void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
  {
<span class="line-modified">!     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());</span>
<span class="line-modified">!     if (!leftValueInfo)</span>
          return;
  
<span class="line-modified">!     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);</span>
<span class="line-modified">!     if (!leftValueType) {</span>
<span class="line-modified">!         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     auto&amp; unifyNode = leftValueType-&gt;unifyNode();</span>
      if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
          auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
          if (is&lt;AST::PointerType&gt;(unnamedType)) {
              auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="line-modified">!             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
<span class="line-modified">!             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));</span>
              return;
          }
  
<span class="line-modified">!         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">!         if (!leftAddressSpace) {</span>
<span class="line-added">+             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
              return;
          }
  
          if (is&lt;AST::ArrayType&gt;(unnamedType)) {
              auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
<span class="line-modified">!             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.</span>
<span class="line-modified">!             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));</span>
              return;
          }
      }
  
<span class="line-modified">!     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">!     if (!leftAddressSpace) {</span>
<span class="line-added">+         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));</span>
  }
  
<span class="line-modified">! RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
  {
<span class="line-modified">!     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="line-modified">!         if (iter != m_andOverloadTypeMap.end())</span>
<span class="line-modified">!             return iter-&gt;value;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="line-modified">!         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-modified">!             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-modified">!             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-modified">!             return &amp;unnamedType;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-modified">!             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="line-modified">! </span>
<span class="line-added">+         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
              return nullptr;
  
<span class="line-modified">!         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto result = createArgumentType();</span>
<span class="line-modified">!     m_andOverloadTypeMap.add(key, result);</span>
<span class="line-modified">!     return result;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="line-added">+     if (!baseInfo)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);</span>
<span class="line-added">+     if (!baseUnnamedType) {</span>
<span class="line-added">+         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="line-modified">!     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">!         if (additionalArgumentType)</span>
<span class="line-modified">!             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">!         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="line-modified">!         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">!         if (hasError())</span>
              return;
<span class="line-modified">!         if (getterFunction)</span>
<span class="line-added">+             getterReturnType = &amp;getterFunction-&gt;type();</span>
      }
  
<span class="line-modified">!     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="line-modified">!     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="line-modified">!     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-modified">!     if (leftAddressSpace) {</span>
<span class="line-modified">!         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="line-modified">!             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="line-modified">!             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="line-modified">!             if (additionalArgumentType)</span>
<span class="line-modified">!                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">!             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-modified">!             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">!             if (hasError())</span>
                  return;
<span class="line-modified">!             if (anderFunction)</span>
<span class="line-added">+                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
          }
      }
  
<span class="line-modified">!     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="line-modified">!     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="line-modified">!     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="line-modified">!         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="line-added">+         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="line-added">+         if (additionalArgumentType)</span>
<span class="line-added">+             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">+         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-added">+         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">+         if (hasError())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         if (threadAnderFunction)</span>
<span class="line-added">+             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">!         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">!         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">!         return;</span>
      }
  
<span class="line-modified">!     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="line-modified">!         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
          return;
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">!         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="line-modified">!         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
          return;
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">!         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
          return;
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="line-added">+ </span>
<span class="line-added">+     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="line-added">+     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="line-added">+         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-added">+         if (additionalArgumentType)</span>
<span class="line-added">+             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-added">+         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="line-added">+         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="line-added">+         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="line-added">+         if (hasError())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         if (setterFunction)</span>
<span class="line-added">+             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="line-added">+         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="line-added">+     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="line-added">+     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="line-added">+     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="line-added">+ </span>
<span class="line-added">+     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="line-added">+     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="line-added">+         if (anderFunction)</span>
<span class="line-added">+             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="line-added">+         else if (setterFunction)</span>
<span class="line-added">+             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">+     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="line-added">+         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-added">+     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     finishVisiting(dotExpression);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-added">+     if (!baseInfo)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
  }
  
  void Checker::visit(AST::VariableReference&amp; variableReference)
  {
      ASSERT(variableReference.variable());
      ASSERT(variableReference.variable()-&gt;type());
  
<span class="line-modified">!     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });</span>
  }
  
  void Checker::visit(AST::Return&amp; returnStatement)
  {
      if (returnStatement.value()) {
          auto valueInfo = recurseAndGetInfo(*returnStatement.value());
          if (!valueInfo)
              return;
<span class="line-modified">!         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))</span>
<span class="line-modified">!             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     if (!matches(m_currentFunction-&gt;type(), m_intrinsics.voidType()))</span>
<span class="line-modified">!         setError(Error(&quot;Cannot return a value from a void function.&quot;, returnStatement.codeLocation()));</span>
  }
  
  void Checker::visit(AST::PointerType&amp;)
  {
      // Following pointer types can cause infinite loops because of data structures
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1147,55 ***</span>
      assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
  }
  
  void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
  {
<span class="line-modified">!     assignType(booleanLiteral, AST::TypeReference::wrap(Lexer::Token(booleanLiteral.origin()), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
  {
      ASSERT(enumerationMemberLiteral.enumerationDefinition());
      auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<span class="line-modified">!     assignType(enumerationMemberLiteral, AST::TypeReference::wrap(Lexer::Token(enumerationMemberLiteral.origin()), enumerationDefinition));</span>
  }
  
  bool Checker::isBoolType(ResolvingType&amp; resolvingType)
  {
<span class="line-modified">!     return WTF::visit(WTF::makeVisitor([&amp;](UniqueRef&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
          return matches(left, m_intrinsics.boolType());
<span class="line-modified">!     }, [&amp;](Ref&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
          return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<span class="line-modified">!     }), resolvingType);</span>
  }
  
  bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
  {
      auto expressionInfo = recurseAndGetInfo(expression);
      if (!expressionInfo)
          return false;
      if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<span class="line-modified">!         setError();</span>
          return false;
      }
      return true;
  }
  
  void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
  {
      if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
          return;
<span class="line-modified">!     assignType(logicalNotExpression, AST::TypeReference::wrap(Lexer::Token(logicalNotExpression.origin()), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
  {
      if (!recurseAndRequireBoolType(logicalExpression.left()))
          return;
      if (!recurseAndRequireBoolType(logicalExpression.right()))
          return;
<span class="line-modified">!     assignType(logicalExpression, AST::TypeReference::wrap(Lexer::Token(logicalExpression.origin()), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::IfStatement&amp; ifStatement)
  {
      if (!recurseAndRequireBoolType(ifStatement.conditional()))
<span class="line-new-header">--- 1367,55 ---</span>
      assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));
  }
  
  void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
  {
<span class="line-modified">!     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
  {
      ASSERT(enumerationMemberLiteral.enumerationDefinition());
      auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
<span class="line-modified">!     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));</span>
  }
  
  bool Checker::isBoolType(ResolvingType&amp; resolvingType)
  {
<span class="line-modified">!     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {</span>
          return matches(left, m_intrinsics.boolType());
<span class="line-modified">!     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {</span>
          return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
<span class="line-modified">!     }));</span>
  }
  
  bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
  {
      auto expressionInfo = recurseAndGetInfo(expression);
      if (!expressionInfo)
          return false;
      if (!isBoolType(expressionInfo-&gt;resolvingType)) {
<span class="line-modified">!         setError(Error(&quot;Expected bool type from expression.&quot;, expression.codeLocation()));</span>
          return false;
      }
      return true;
  }
  
  void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
  {
      if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
          return;
<span class="line-modified">!     assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
  {
      if (!recurseAndRequireBoolType(logicalExpression.left()))
          return;
      if (!recurseAndRequireBoolType(logicalExpression.right()))
          return;
<span class="line-modified">!     assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));</span>
  }
  
  void Checker::visit(AST::IfStatement&amp; ifStatement)
  {
      if (!recurseAndRequireBoolType(ifStatement.conditional()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1218,16 ***</span>
      recurseAndRequireBoolType(doWhileLoop.conditional());
  }
  
  void Checker::visit(AST::ForLoop&amp; forLoop)
  {
<span class="line-modified">!     WTF::visit(WTF::makeVisitor([&amp;](AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement) {</span>
<span class="line-modified">!         checkErrorAndVisit(variableDeclarationsStatement);</span>
<span class="line-removed">-     }, [&amp;](UniqueRef&lt;AST::Expression&gt;&amp; expression) {</span>
<span class="line-removed">-         checkErrorAndVisit(expression);</span>
<span class="line-removed">-     }), forLoop.initialization());</span>
<span class="line-removed">-     if (error())</span>
          return;
      if (forLoop.condition()) {
          if (!recurseAndRequireBoolType(*forLoop.condition()))
              return;
      }
<span class="line-new-header">--- 1438,12 ---</span>
      recurseAndRequireBoolType(doWhileLoop.conditional());
  }
  
  void Checker::visit(AST::ForLoop&amp; forLoop)
  {
<span class="line-modified">!     checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-modified">!     if (hasError())</span>
          return;
      if (forLoop.condition()) {
          if (!recurseAndRequireBoolType(*forLoop.condition()))
              return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1253,38 ***</span>
              &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
              return nullptr;
          return &amp;valueNamedUnifyNode;
      })();
      if (!valueType) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
      bool hasDefault = false;
      for (auto&amp; switchCase : switchStatement.switchCases()) {
          checkErrorAndVisit(switchCase.block());
          if (!switchCase.value()) {
              hasDefault = true;
              continue;
          }
<span class="line-modified">!         bool success;</span>
<span class="line-modified">!         switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">!             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">!             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-modified">!             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::NullLiteral&amp; nullLiteral) {</span>
<span class="line-modified">!             success = static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-modified">!             success = matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-removed">-         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
              ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="line-modified">!             success = matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
          }));
          if (!success) {
<span class="line-modified">!             setError();</span>
              return;
          }
      }
  
      for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
<span class="line-new-header">--- 1469,37 ---</span>
              &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
              return nullptr;
          return &amp;valueNamedUnifyNode;
      })();
      if (!valueType) {
<span class="line-modified">!         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));</span>
          return;
      }
  
      bool hasDefault = false;
      for (auto&amp; switchCase : switchStatement.switchCases()) {
          checkErrorAndVisit(switchCase.block());
          if (!switchCase.value()) {
              hasDefault = true;
              continue;
          }
<span class="line-modified">!         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {</span>
<span class="line-modified">!             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {</span>
<span class="line-modified">!             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="line-modified">!             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
<span class="line-modified">!         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {</span>
<span class="line-modified">!             return matches(*valueType, m_intrinsics.boolType());</span>
<span class="line-modified">!         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {</span>
              ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="line-modified">!             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());</span>
          }));
          if (!success) {
<span class="line-modified">!             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));</span>
              return;
          }
      }
  
      for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1294,54 ***</span>
  
              if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
                  continue;
  
              if (!static_cast&lt;bool&gt;(firstCase.value())) {
<span class="line-modified">!                 setError();</span>
                  return;
              }
  
<span class="line-modified">!             bool success = true;</span>
<span class="line-modified">!             firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) {</span>
<span class="line-modified">!                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">!                     success = firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">!                     success = static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">!                 }, [](auto&amp;) {</span>
                  }));
<span class="line-modified">!             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) {</span>
<span class="line-modified">!                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) {</span>
<span class="line-modified">!                     success = static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) {</span>
<span class="line-modified">!                     success = firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">!                 }, [](auto&amp;) {</span>
                  }));
<span class="line-modified">!             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) {</span>
<span class="line-modified">!                 secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp;) {</span>
<span class="line-removed">-                 }, [&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) {</span>
                      ASSERT(firstEnumerationMemberLiteral.enumerationMember());
                      ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<span class="line-modified">!                     success = firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">!                 }, [](auto&amp;) {</span>
                  }));
<span class="line-modified">!             }, [](auto&amp;) {</span>
              }));
          }
      }
  
      if (!hasDefault) {
          if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
              HashSet&lt;int64_t&gt; values;
              bool zeroValueExists;
              for (auto&amp; switchCase : switchStatement.switchCases()) {
<span class="line-modified">!                 int64_t value;</span>
<span class="line-modified">!                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">!                     value = integerLiteral.valueForSelectedType();</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">!                     value = unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-removed">-                 }, [](auto&amp;) {</span>
                      ASSERT_NOT_REACHED();
                  }));
                  if (!value)
                      zeroValueExists = true;
                  else
                      values.add(value);
<span class="line-new-header">--- 1509,60 ---</span>
  
              if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
                  continue;
  
              if (!static_cast&lt;bool&gt;(firstCase.value())) {
<span class="line-modified">!                 setError(Error(&quot;Cannot define multiple default cases in switch statement.&quot;, secondCase.codeLocation()));</span>
                  return;
              }
  
<span class="line-modified">!             auto success = firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                     return firstIntegerLiteral.value() != secondIntegerLiteral.value();</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                     return static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());</span>
<span class="line-modified">!                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-modified">!                     return true;</span>
                  }));
<span class="line-modified">!             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                     return static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {</span>
<span class="line-modified">!                     return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();</span>
<span class="line-modified">!                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">+                     return true;</span>
                  }));
<span class="line-modified">!             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) -&gt; bool {</span>
<span class="line-modified">!                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) -&gt; bool {</span>
                      ASSERT(firstEnumerationMemberLiteral.enumerationMember());
                      ASSERT(secondEnumerationMemberLiteral.enumerationMember());
<span class="line-modified">!                     return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();</span>
<span class="line-modified">!                 }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">+                     return true;</span>
                  }));
<span class="line-modified">!             }, [](auto&amp;) -&gt; bool {</span>
<span class="line-added">+                 return true;</span>
              }));
<span class="line-added">+             if (!success) {</span>
<span class="line-added">+                 setError(Error(&quot;Cannot define duplicate case statements in a switch.&quot;, secondCase.codeLocation()));</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
          }
      }
  
      if (!hasDefault) {
          if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
              HashSet&lt;int64_t&gt; values;
              bool zeroValueExists;
              for (auto&amp; switchCase : switchStatement.switchCases()) {
<span class="line-modified">!                 auto value = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; int64_t {</span>
<span class="line-modified">!                     return integerLiteral.valueForSelectedType();</span>
<span class="line-modified">!                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; int64_t {</span>
<span class="line-modified">!                     return unsignedIntegerLiteral.valueForSelectedType();</span>
<span class="line-modified">!                 }, [](auto&amp;) -&gt; int64_t {</span>
                      ASSERT_NOT_REACHED();
<span class="line-added">+                     return 0;</span>
                  }));
                  if (!value)
                      zeroValueExists = true;
                  else
                      values.add(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1360,15 ***</span>
                      return true;
                  }
                  return false;
              });
              if (!success) {
<span class="line-modified">!                 setError();</span>
                  return;
              }
          } else {
<span class="line-removed">-             ASSERT(is&lt;AST::EnumerationDefinition&gt;(*valueType));</span>
              HashSet&lt;AST::EnumerationMember*&gt; values;
              for (auto&amp; switchCase : switchStatement.switchCases()) {
                  switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
                      ASSERT(enumerationMemberLiteral.enumerationMember());
                      values.add(enumerationMemberLiteral.enumerationMember());
<span class="line-new-header">--- 1581,14 ---</span>
                      return true;
                  }
                  return false;
              });
              if (!success) {
<span class="line-modified">!                 setError(Error(&quot;Switch cases must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
                  return;
              }
          } else {
              HashSet&lt;AST::EnumerationMember*&gt; values;
              for (auto&amp; switchCase : switchStatement.switchCases()) {
                  switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
                      ASSERT(enumerationMemberLiteral.enumerationMember());
                      values.add(enumerationMemberLiteral.enumerationMember());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,11 ***</span>
                      ASSERT_NOT_REACHED();
                  }));
              }
              for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
                  if (!values.contains(&amp;enumerationMember.get())) {
<span class="line-modified">!                     setError();</span>
                      return;
                  }
              }
          }
      }
<span class="line-new-header">--- 1596,11 ---</span>
                      ASSERT_NOT_REACHED();
                  }));
              }
              for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
                  if (!values.contains(&amp;enumerationMember.get())) {
<span class="line-modified">!                     setError(Error(&quot;Switch cases over an enum must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));</span>
                      return;
                  }
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1388,11 ***</span>
  
  void Checker::visit(AST::CommaExpression&amp; commaExpression)
  {
      ASSERT(commaExpression.list().size() &gt; 0);
      Visitor::visit(commaExpression);
<span class="line-modified">!     if (error())</span>
          return;
      auto lastInfo = getInfo(commaExpression.list().last());
      forwardType(commaExpression, lastInfo-&gt;resolvingType);
  }
  
<span class="line-new-header">--- 1608,11 ---</span>
  
  void Checker::visit(AST::CommaExpression&amp; commaExpression)
  {
      ASSERT(commaExpression.list().size() &gt; 0);
      Visitor::visit(commaExpression);
<span class="line-modified">!     if (hasError())</span>
          return;
      auto lastInfo = getInfo(commaExpression.list().last());
      forwardType(commaExpression, lastInfo-&gt;resolvingType);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1405,15 ***</span>
      auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
      auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
  
      auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
      if (!resultType) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
<span class="line-modified">!     assignType(ternaryExpression, WTFMove(*resultType));</span>
  }
  
  void Checker::visit(AST::CallExpression&amp; callExpression)
  {
      Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
<span class="line-new-header">--- 1625,15 ---</span>
      auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
      auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
  
      auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
      if (!resultType) {
<span class="line-modified">!         setError(Error(&quot;lhs and rhs of a ternary expression must match.&quot;, ternaryExpression.codeLocation()));</span>
          return;
      }
  
<span class="line-modified">!     assignConcreteType(ternaryExpression, *resultType);</span>
  }
  
  void Checker::visit(AST::CallExpression&amp; callExpression)
  {
      Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1422,48 ***</span>
          auto argumentInfo = recurseAndGetInfo(argument);
          if (!argumentInfo)
              return;
          types.uncheckedAppend(argumentInfo-&gt;resolvingType);
      }
<span class="line-modified">!     if (callExpression.castReturnType()) {</span>
<span class="line-modified">!         checkErrorAndVisit(callExpression.castReturnType()-&gt;get());</span>
<span class="line-modified">!         if (error())</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-removed">-     ASSERT(callExpression.hasOverloads());</span>
<span class="line-removed">-     auto* function = resolveFunctionOverloadImpl(*callExpression.overloads(), types, callExpression.castReturnType());</span>
      if (!function) {
<span class="line-modified">!         if (auto newFunction = resolveByInstantiation(callExpression, types, m_intrinsics)) {</span>
<span class="line-modified">!             m_program.append(WTFMove(*newFunction));</span>
<span class="line-modified">!             function = &amp;m_program.nativeFunctionDeclarations().last();</span>
          }
      }
  
      if (!function) {
<span class="line-modified">!         setError();</span>
          return;
      }
  
      for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<span class="line-modified">!         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i].type())) {</span>
<span class="line-modified">!             setError();</span>
              return;
          }
      }
  
      callExpression.setFunction(*function);
  
<span class="line-modified">!     assignType(callExpression, function-&gt;type().clone());</span>
  }
  
<span class="line-modified">! bool check(Program&amp; program)</span>
  {
      Checker checker(program.intrinsics(), program);
      checker.checkErrorAndVisit(program);
<span class="line-modified">!     if (checker.error())</span>
<span class="line-modified">!         return false;</span>
      return checker.assignTypes();
  }
  
  } // namespace WHLSL
  
<span class="line-new-header">--- 1642,55 ---</span>
          auto argumentInfo = recurseAndGetInfo(argument);
          if (!argumentInfo)
              return;
          types.uncheckedAppend(argumentInfo-&gt;resolvingType);
      }
<span class="line-modified">!     // Don&#39;t recurse on the castReturnType, because it&#39;s guaranteed to be a NamedType, which will get visited later.</span>
<span class="line-modified">!     // We don&#39;t want to recurse to the same node twice.</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());</span>
<span class="line-modified">!     if (hasError())</span>
<span class="line-added">+         return;</span>
  
      if (!function) {
<span class="line-modified">!         NameContext&amp; nameContext = m_program.nameContext();</span>
<span class="line-modified">!         auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);</span>
<span class="line-modified">!         if (castTypes.size() == 1) {</span>
<span class="line-added">+             AST::NamedType&amp; castType = castTypes[0].get();</span>
<span class="line-added">+             function = resolveFunction(types, &quot;operator cast&quot;_str, callExpression.codeLocation(), &amp;castType);</span>
<span class="line-added">+             if (hasError())</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             if (function)</span>
<span class="line-added">+                 callExpression.setCastData(castType);</span>
          }
      }
  
      if (!function) {
<span class="line-modified">!         // FIXME: Add better error messages for why we can&#39;t resolve to one of the overrides.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=200133</span>
<span class="line-added">+         setError(Error(&quot;Cannot resolve function call to a concrete callee. Make sure you are using compatible types.&quot;, callExpression.codeLocation()));</span>
          return;
      }
  
      for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
<span class="line-modified">!         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i]-&gt;type())) {</span>
<span class="line-modified">!             setError(Error(makeString(&quot;Invalid type for parameter number &quot;, i + 1, &quot; in function call.&quot;), callExpression.codeLocation()));</span>
              return;
          }
      }
  
      callExpression.setFunction(*function);
  
<span class="line-modified">!     assignConcreteType(callExpression, function-&gt;type());</span>
  }
  
<span class="line-modified">! Expected&lt;void, Error&gt; check(Program&amp; program)</span>
  {
      Checker checker(program.intrinsics(), program);
      checker.checkErrorAndVisit(program);
<span class="line-modified">!     if (checker.hasError())</span>
<span class="line-modified">!         return checker.result();</span>
      return checker.assignTypes();
  }
  
  } // namespace WHLSL
  
</pre>
<center><a href="WHLSLCheckDuplicateFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLChecker.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>