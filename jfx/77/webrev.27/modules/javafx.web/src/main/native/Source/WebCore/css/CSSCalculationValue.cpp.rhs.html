<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSCalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
  3  * Copyright (C) 2014 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;CSSCalculationValue.h&quot;
 34 
 35 #include &quot;CSSParser.h&quot;
 36 #include &quot;CSSParserTokenRange.h&quot;
 37 #include &quot;CSSPrimitiveValueMappings.h&quot;
 38 #include &quot;StyleResolver.h&quot;
 39 #include &lt;wtf/MathExtras.h&gt;
 40 #include &lt;wtf/text/StringBuilder.h&gt;
 41 
 42 static const int maxExpressionDepth = 100;
 43 
 44 enum ParseState {
 45     OK,
 46     TooDeep,
 47     NoMoreTokens
 48 };
 49 
 50 namespace WebCore {
 51 
 52 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp;, const RenderStyle&amp;);
 53 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp;, const RenderStyle&amp;);
 54 
 55 static CalculationCategory unitCategory(CSSPrimitiveValue::UnitType type)
 56 {
 57     switch (type) {
 58     case CSSPrimitiveValue::CSS_NUMBER:
 59         return CalculationCategory::Number;
 60     case CSSPrimitiveValue::CSS_EMS:
 61     case CSSPrimitiveValue::CSS_EXS:
 62     case CSSPrimitiveValue::CSS_PX:
 63     case CSSPrimitiveValue::CSS_CM:
 64     case CSSPrimitiveValue::CSS_MM:
 65     case CSSPrimitiveValue::CSS_IN:
 66     case CSSPrimitiveValue::CSS_PT:
 67     case CSSPrimitiveValue::CSS_PC:
 68     case CSSPrimitiveValue::CSS_REMS:
 69     case CSSPrimitiveValue::CSS_CHS:
 70     case CSSPrimitiveValue::CSS_VW:
 71     case CSSPrimitiveValue::CSS_VH:
 72     case CSSPrimitiveValue::CSS_VMIN:
 73     case CSSPrimitiveValue::CSS_VMAX:
 74         return CalculationCategory::Length;
 75     case CSSPrimitiveValue::CSS_PERCENTAGE:
 76         return CalculationCategory::Percent;
 77     case CSSPrimitiveValue::CSS_DEG:
 78     case CSSPrimitiveValue::CSS_RAD:
 79     case CSSPrimitiveValue::CSS_GRAD:
 80     case CSSPrimitiveValue::CSS_TURN:
 81         return CalculationCategory::Angle;
 82     case CSSPrimitiveValue::CSS_MS:
 83     case CSSPrimitiveValue::CSS_S:
 84         return CalculationCategory::Time;
 85     case CSSPrimitiveValue::CSS_HZ:
 86     case CSSPrimitiveValue::CSS_KHZ:
 87         return CalculationCategory::Frequency;
 88     default:
 89         return CalculationCategory::Other;
 90     }
 91 }
 92 
 93 static bool hasDoubleValue(CSSPrimitiveValue::UnitType type)
 94 {
 95     switch (type) {
 96     case CSSPrimitiveValue::CSS_FR:
 97     case CSSPrimitiveValue::CSS_NUMBER:
 98     case CSSPrimitiveValue::CSS_PERCENTAGE:
 99     case CSSPrimitiveValue::CSS_EMS:
100     case CSSPrimitiveValue::CSS_EXS:
101     case CSSPrimitiveValue::CSS_CHS:
102     case CSSPrimitiveValue::CSS_REMS:
103     case CSSPrimitiveValue::CSS_PX:
104     case CSSPrimitiveValue::CSS_CM:
105     case CSSPrimitiveValue::CSS_MM:
106     case CSSPrimitiveValue::CSS_IN:
107     case CSSPrimitiveValue::CSS_PT:
108     case CSSPrimitiveValue::CSS_PC:
109     case CSSPrimitiveValue::CSS_DEG:
110     case CSSPrimitiveValue::CSS_RAD:
111     case CSSPrimitiveValue::CSS_GRAD:
112     case CSSPrimitiveValue::CSS_TURN:
113     case CSSPrimitiveValue::CSS_MS:
114     case CSSPrimitiveValue::CSS_S:
115     case CSSPrimitiveValue::CSS_HZ:
116     case CSSPrimitiveValue::CSS_KHZ:
117     case CSSPrimitiveValue::CSS_DIMENSION:
118     case CSSPrimitiveValue::CSS_VW:
119     case CSSPrimitiveValue::CSS_VH:
120     case CSSPrimitiveValue::CSS_VMIN:
121     case CSSPrimitiveValue::CSS_VMAX:
122     case CSSPrimitiveValue::CSS_DPPX:
123     case CSSPrimitiveValue::CSS_DPI:
124     case CSSPrimitiveValue::CSS_DPCM:
125         return true;
126     case CSSPrimitiveValue::CSS_UNKNOWN:
127     case CSSPrimitiveValue::CSS_STRING:
128     case CSSPrimitiveValue::CSS_FONT_FAMILY:
129     case CSSPrimitiveValue::CSS_URI:
130     case CSSPrimitiveValue::CSS_IDENT:
131     case CSSPrimitiveValue::CSS_ATTR:
132     case CSSPrimitiveValue::CSS_COUNTER:
133     case CSSPrimitiveValue::CSS_RECT:
134     case CSSPrimitiveValue::CSS_RGBCOLOR:
135     case CSSPrimitiveValue::CSS_PAIR:
136     case CSSPrimitiveValue::CSS_UNICODE_RANGE:
137     case CSSPrimitiveValue::CSS_COUNTER_NAME:
138     case CSSPrimitiveValue::CSS_SHAPE:
139     case CSSPrimitiveValue::CSS_QUAD:
140     case CSSPrimitiveValue::CSS_QUIRKY_EMS:
141     case CSSPrimitiveValue::CSS_CALC:
142     case CSSPrimitiveValue::CSS_CALC_PERCENTAGE_WITH_NUMBER:
143     case CSSPrimitiveValue::CSS_CALC_PERCENTAGE_WITH_LENGTH:
144     case CSSPrimitiveValue::CSS_PROPERTY_ID:
145     case CSSPrimitiveValue::CSS_VALUE_ID:
<a name="1" id="anc1"></a>


146         return false;
147     };
148     ASSERT_NOT_REACHED();
149     return false;
150 }
151 
<a name="2" id="anc2"></a>












152 String CSSCalcValue::customCSSText() const
153 {
<a name="3" id="anc3"></a><span class="line-modified">154     auto expression = m_expression-&gt;customCSSText();</span>
<span class="line-added">155     if (expression[0] == &#39;(&#39;)</span>
<span class="line-added">156         return makeString(&quot;calc&quot;, expression);</span>
<span class="line-added">157     return makeString(&quot;calc(&quot;, expression, &#39;)&#39;);</span>
158 }
159 
160 bool CSSCalcValue::equals(const CSSCalcValue&amp; other) const
161 {
162     return compareCSSValue(m_expression, other.m_expression);
163 }
164 
165 inline double CSSCalcValue::clampToPermittedRange(double value) const
166 {
167     return m_shouldClampToNonNegative &amp;&amp; value &lt; 0 ? 0 : value;
168 }
169 
170 double CSSCalcValue::doubleValue() const
171 {
172     return clampToPermittedRange(m_expression-&gt;doubleValue());
173 }
174 
175 double CSSCalcValue::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const
176 {
177     return clampToPermittedRange(m_expression-&gt;computeLengthPx(conversionData));
178 }
179 
180 class CSSCalcPrimitiveValue final : public CSSCalcExpressionNode {
181     WTF_MAKE_FAST_ALLOCATED;
182 public:
183     static Ref&lt;CSSCalcPrimitiveValue&gt; create(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value, bool isInteger)
184     {
185         return adoptRef(*new CSSCalcPrimitiveValue(WTFMove(value), isInteger));
186     }
187 
188     static RefPtr&lt;CSSCalcPrimitiveValue&gt; create(double value, CSSPrimitiveValue::UnitType type, bool isInteger)
189     {
190         if (!std::isfinite(value))
191             return nullptr;
192         return adoptRef(new CSSCalcPrimitiveValue(CSSPrimitiveValue::create(value, type), isInteger));
193     }
194 
195 private:
196     bool isZero() const final
197     {
198         return !m_value-&gt;doubleValue();
199     }
200 
201     String customCSSText() const final
202     {
203         return m_value-&gt;cssText();
204     }
205 
206     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const final
207     {
208         switch (category()) {
209         case CalculationCategory::Number:
<a name="4" id="anc4"></a><span class="line-modified">210             return makeUnique&lt;CalcExpressionNumber&gt;(m_value-&gt;floatValue());</span>
211         case CalculationCategory::Length:
<a name="5" id="anc5"></a><span class="line-modified">212             return makeUnique&lt;CalcExpressionLength&gt;(Length(m_value-&gt;computeLength&lt;float&gt;(conversionData), WebCore::Fixed));</span>
213         case CalculationCategory::Percent:
214         case CalculationCategory::PercentLength: {
<a name="6" id="anc6"></a><span class="line-modified">215             return makeUnique&lt;CalcExpressionLength&gt;(m_value-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion&gt;(conversionData));</span>
216         }
217         // Only types that could be part of a Length expression can be converted
218         // to a CalcExpressionNode. CalculationCategory::PercentNumber makes no sense as a Length.
219         case CalculationCategory::PercentNumber:
220         case CalculationCategory::Angle:
221         case CalculationCategory::Time:
222         case CalculationCategory::Frequency:
223         case CalculationCategory::Other:
224             ASSERT_NOT_REACHED();
225         }
226         ASSERT_NOT_REACHED();
227         return nullptr;
228     }
229 
230     double doubleValue() const final
231     {
232         if (hasDoubleValue(primitiveType()))
233             return m_value-&gt;doubleValue();
234         ASSERT_NOT_REACHED();
235         return 0;
236     }
237 
238     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final
239     {
240         switch (category()) {
241         case CalculationCategory::Length:
242             return m_value-&gt;computeLength&lt;double&gt;(conversionData);
243         case CalculationCategory::Percent:
244         case CalculationCategory::Number:
245             return m_value-&gt;doubleValue();
246         case CalculationCategory::PercentLength:
247         case CalculationCategory::PercentNumber:
248         case CalculationCategory::Angle:
249         case CalculationCategory::Time:
250         case CalculationCategory::Frequency:
251         case CalculationCategory::Other:
252             ASSERT_NOT_REACHED();
253             break;
254         }
255         ASSERT_NOT_REACHED();
256         return 0;
257     }
258 
259     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final
260     {
261         m_value-&gt;collectDirectComputationalDependencies(values);
262     }
263 
264     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final
265     {
266         m_value-&gt;collectDirectRootComputationalDependencies(values);
267     }
268 
269     bool equals(const CSSCalcExpressionNode&amp; other) const final
270     {
271         if (type() != other.type())
272             return false;
273 
274         return compareCSSValue(m_value, static_cast&lt;const CSSCalcPrimitiveValue&amp;&gt;(other).m_value);
275     }
276 
277     Type type() const final { return CssCalcPrimitiveValue; }
278     CSSPrimitiveValue::UnitType primitiveType() const final
279     {
280         return CSSPrimitiveValue::UnitType(m_value-&gt;primitiveType());
281     }
282 
283 private:
284     explicit CSSCalcPrimitiveValue(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value, bool isInteger)
285         : CSSCalcExpressionNode(unitCategory((CSSPrimitiveValue::UnitType)value-&gt;primitiveType()), isInteger)
286         , m_value(WTFMove(value))
287     {
288     }
289 
290     Ref&lt;CSSPrimitiveValue&gt; m_value;
291 };
292 
293 static const CalculationCategory addSubtractResult[static_cast&lt;unsigned&gt;(CalculationCategory::Angle)][static_cast&lt;unsigned&gt;(CalculationCategory::Angle)] = {
294 //    CalculationCategory::Number         CalculationCategory::Length         CalculationCategory::Percent        CalculationCategory::PercentNumber  CalculationCategory::PercentLength
295     { CalculationCategory::Number,        CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::Number
296     { CalculationCategory::Other,         CalculationCategory::Length,        CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::Length
297     { CalculationCategory::PercentNumber, CalculationCategory::PercentLength, CalculationCategory::Percent,       CalculationCategory::PercentNumber, CalculationCategory::PercentLength }, // CalculationCategory::Percent
298     { CalculationCategory::PercentNumber, CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::PercentNumber
299     { CalculationCategory::Other,         CalculationCategory::PercentLength, CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::PercentLength
300 };
301 
302 static CalculationCategory determineCategory(const CSSCalcExpressionNode&amp; leftSide, const CSSCalcExpressionNode&amp; rightSide, CalcOperator op)
303 {
304     CalculationCategory leftCategory = leftSide.category();
305     CalculationCategory rightCategory = rightSide.category();
306     ASSERT(leftCategory &lt; CalculationCategory::Other);
307     ASSERT(rightCategory &lt; CalculationCategory::Other);
308 
309     switch (op) {
310     case CalcOperator::Add:
311     case CalcOperator::Subtract:
312         if (leftCategory &lt; CalculationCategory::Angle &amp;&amp; rightCategory &lt; CalculationCategory::Angle)
313             return addSubtractResult[static_cast&lt;unsigned&gt;(leftCategory)][static_cast&lt;unsigned&gt;(rightCategory)];
314         if (leftCategory == rightCategory)
315             return leftCategory;
316         return CalculationCategory::Other;
317     case CalcOperator::Multiply:
318         if (leftCategory != CalculationCategory::Number &amp;&amp; rightCategory != CalculationCategory::Number)
319             return CalculationCategory::Other;
320         return leftCategory == CalculationCategory::Number ? rightCategory : leftCategory;
321     case CalcOperator::Divide:
322         if (rightCategory != CalculationCategory::Number || rightSide.isZero())
323             return CalculationCategory::Other;
324         return leftCategory;
325     case CalcOperator::Min:
326     case CalcOperator::Max:
327         ASSERT_NOT_REACHED();
328         return CalculationCategory::Other;
329     }
330 
331     ASSERT_NOT_REACHED();
332     return CalculationCategory::Other;
333 }
334 
335 static CalculationCategory resolvedTypeForMinOrMax(CalculationCategory category, CalculationCategory destinationCategory)
336 {
337     switch (category) {
338     case CalculationCategory::Number:
339     case CalculationCategory::Length:
340     case CalculationCategory::PercentNumber:
341     case CalculationCategory::PercentLength:
342     case CalculationCategory::Angle:
343     case CalculationCategory::Time:
344     case CalculationCategory::Frequency:
345     case CalculationCategory::Other:
346         return category;
347 
348     case CalculationCategory::Percent:
349         if (destinationCategory == CalculationCategory::Length)
350             return CalculationCategory::PercentLength;
351         if (destinationCategory == CalculationCategory::Number)
352             return CalculationCategory::PercentNumber;
353         return category;
354     }
355 
356     return CalculationCategory::Other;
357 }
358 
359 static inline bool isIntegerResult(CalcOperator op, const CSSCalcExpressionNode&amp; leftSide, const CSSCalcExpressionNode&amp; rightSide)
360 {
361     // Performs W3C spec&#39;s type checking for calc integers.
362     // http://www.w3.org/TR/css3-values/#calc-type-checking
363     return op != CalcOperator::Divide &amp;&amp; leftSide.isInteger() &amp;&amp; rightSide.isInteger();
364 }
365 
366 static inline bool isIntegerResult(CalcOperator op, const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes)
367 {
368     // Performs W3C spec&#39;s type checking for calc integers.
369     // http://www.w3.org/TR/css3-values/#calc-type-checking
370     if (op == CalcOperator::Divide)
371         return false;
372 
373     for (auto&amp; node : nodes) {
374         if (!node-&gt;isInteger())
375             return false;
376     }
377 
378     return true;
379 }
380 
381 static bool isSamePair(CalculationCategory a, CalculationCategory b, CalculationCategory x, CalculationCategory y)
382 {
383     return (a == x &amp;&amp; b == y) || (a == y &amp;&amp; b == x);
384 }
385 
386 class CSSCalcOperation final : public CSSCalcExpressionNode {
387     WTF_MAKE_FAST_ALLOCATED;
388 public:
389     static RefPtr&lt;CSSCalcOperation&gt; create(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)
390     {
391         if (!leftSide || !rightSide)
392             return nullptr;
393 
394         ASSERT(leftSide-&gt;category() &lt; CalculationCategory::Other);
395         ASSERT(rightSide-&gt;category() &lt; CalculationCategory::Other);
396 
397         auto newCategory = determineCategory(*leftSide, *rightSide, op);
398         if (newCategory == CalculationCategory::Other)
399             return nullptr;
400 
401         return adoptRef(new CSSCalcOperation(newCategory, op, leftSide.releaseNonNull(), rightSide.releaseNonNull()));
402     }
403 
404     static RefPtr&lt;CSSCalcOperation&gt; createMinOrMax(CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory)
405     {
406         ASSERT(op == CalcOperator::Min || op == CalcOperator::Max);
407 
408         Optional&lt;CalculationCategory&gt; category = WTF::nullopt;
409         for (auto&amp; value : values) {
410             auto valueCategory = resolvedTypeForMinOrMax(value-&gt;category(), destinationCategory);
411 
412             ASSERT(valueCategory &lt; CalculationCategory::Other);
413             if (!category) {
414                 if (valueCategory == CalculationCategory::Other)
415                     return nullptr;
416                 category = valueCategory;
417             }
418 
419             if (category != valueCategory) {
420                 if (isSamePair(category.value(), valueCategory, CalculationCategory::Length, CalculationCategory::PercentLength)) {
421                     category = CalculationCategory::PercentLength;
422                     continue;
423                 }
424                 if (isSamePair(category.value(), valueCategory, CalculationCategory::Number, CalculationCategory::PercentNumber)) {
425                     category = CalculationCategory::PercentNumber;
426                     continue;
427                 }
428                 return nullptr;
429             }
430         }
431 
432         return adoptRef(new CSSCalcOperation(category.value(), op, WTFMove(values)));
433     }
434 
435     static RefPtr&lt;CSSCalcExpressionNode&gt; createSimplified(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)
436     {
437         if (!leftSide || !rightSide)
438             return nullptr;
439 
440         auto leftCategory = leftSide-&gt;category();
441         auto rightCategory = rightSide-&gt;category();
442         ASSERT(leftCategory &lt; CalculationCategory::Other);
443         ASSERT(rightCategory &lt; CalculationCategory::Other);
444 
445         bool isInteger = isIntegerResult(op, *leftSide, *rightSide);
446 
447         // Simplify numbers.
448         if (leftCategory == CalculationCategory::Number &amp;&amp; rightCategory == CalculationCategory::Number) {
449             CSSPrimitiveValue::UnitType evaluationType = CSSPrimitiveValue::CSS_NUMBER;
450             return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftSide-&gt;doubleValue(), rightSide-&gt;doubleValue() }), evaluationType, isInteger);
451         }
452 
453         // Simplify addition and subtraction between same types.
454         if (op == CalcOperator::Add || op == CalcOperator::Subtract) {
455             if (leftCategory == rightSide-&gt;category()) {
456                 CSSPrimitiveValue::UnitType leftType = leftSide-&gt;primitiveType();
457                 if (hasDoubleValue(leftType)) {
458                     CSSPrimitiveValue::UnitType rightType = rightSide-&gt;primitiveType();
459                     if (leftType == rightType)
460                         return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftSide-&gt;doubleValue(), rightSide-&gt;doubleValue() }), leftType, isInteger);
461                     CSSPrimitiveValue::UnitCategory leftUnitCategory = CSSPrimitiveValue::unitCategory(leftType);
462                     if (leftUnitCategory != CSSPrimitiveValue::UOther &amp;&amp; leftUnitCategory == CSSPrimitiveValue::unitCategory(rightType)) {
463                         CSSPrimitiveValue::UnitType canonicalType = CSSPrimitiveValue::canonicalUnitTypeForCategory(leftUnitCategory);
464                         if (canonicalType != CSSPrimitiveValue::CSS_UNKNOWN) {
465                             double leftValue = leftSide-&gt;doubleValue() * CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(leftType);
466                             double rightValue = rightSide-&gt;doubleValue() * CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(rightType);
467                             return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftValue, rightValue }), canonicalType, isInteger);
468                         }
469                     }
470                 }
471             }
472         } else {
473             // Simplify multiplying or dividing by a number for simplifiable types.
474             ASSERT(op == CalcOperator::Multiply || op == CalcOperator::Divide);
475             auto* numberSide = getNumberSide(*leftSide, *rightSide);
476             if (!numberSide)
477                 return create(op, leftSide.releaseNonNull(), rightSide.releaseNonNull());
478             if (numberSide == leftSide &amp;&amp; op == CalcOperator::Divide)
479                 return nullptr;
480             auto&amp; otherSide = leftSide == numberSide ? *rightSide : *leftSide;
481 
482             double number = numberSide-&gt;doubleValue();
483             if (!std::isfinite(number))
484                 return nullptr;
485             if (op == CalcOperator::Divide &amp;&amp; !number)
486                 return nullptr;
487 
488             auto otherType = otherSide.primitiveType();
489             if (hasDoubleValue(otherType))
490                 return CSSCalcPrimitiveValue::create(evaluateOperator(op, { otherSide.doubleValue(), number }), otherType, isInteger);
491         }
492 
493         return create(op, leftSide.releaseNonNull(), rightSide.releaseNonNull());
494     }
495 
496 private:
497     bool isZero() const final
498     {
499         return !doubleValue();
500     }
501 
502     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const final
503     {
504         Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; nodes;
505         nodes.reserveInitialCapacity(m_children.size());
506 
507         for (auto&amp; child : m_children) {
508             auto node = child-&gt;createCalcExpression(conversionData);
509             if (!node)
510                 return nullptr;
511             nodes.uncheckedAppend(WTFMove(node));
512         }
<a name="7" id="anc7"></a><span class="line-modified">513         return makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(nodes), m_operator);</span>
514     }
515 
516     double doubleValue() const final
517     {
518         Vector&lt;double&gt; doubleValues;
519         for (auto&amp; child : m_children)
520             doubleValues.append(child-&gt;doubleValue());
521         return evaluate(doubleValues);
522     }
523 
524     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final
525     {
526         Vector&lt;double&gt; doubleValues;
527         for (auto&amp; child : m_children)
528             doubleValues.append(child-&gt;computeLengthPx(conversionData));
529         return evaluate(doubleValues);
530     }
531 
532     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final
533     {
534         for (auto&amp; child : m_children)
535             child-&gt;collectDirectComputationalDependencies(values);
536     }
537 
538     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final
539     {
540         for (auto&amp; child : m_children)
541             child-&gt;collectDirectRootComputationalDependencies(values);
542     }
543 
544     static String buildCssText(Vector&lt;String&gt; childExpressions, CalcOperator op)
545     {
546         StringBuilder result;
547         result.append(&#39;(&#39;);
548         switch (op) {
549         case CalcOperator::Add:
550         case CalcOperator::Subtract:
551         case CalcOperator::Multiply:
552         case CalcOperator::Divide:
553             ASSERT(childExpressions.size() == 2);
554             result.append(childExpressions[0]);
555             result.append(&#39; &#39;);
556             result.append(static_cast&lt;char&gt;(op));
557             result.append(&#39; &#39;);
558             result.append(childExpressions[1]);
559             break;
560         case CalcOperator::Min:
561         case CalcOperator::Max:
562             ASSERT(!childExpressions.isEmpty());
563             const char* functionName = op == CalcOperator::Min ? &quot;min(&quot; : &quot;max(&quot;;
564             result.append(functionName);
565             result.append(childExpressions[0]);
566             for (size_t i = 1; i &lt; childExpressions.size(); ++i) {
567                 result.append(&#39;,&#39;);
568                 result.append(&#39; &#39;);
569                 result.append(childExpressions[i]);
570             }
571             result.append(&#39;)&#39;);
572         }
573         result.append(&#39;)&#39;);
574 
575         return result.toString();
576     }
577 
578     String customCSSText() const final
579     {
580         Vector&lt;String&gt; cssTexts;
581         for (auto&amp; child : m_children)
582             cssTexts.append(child-&gt;customCSSText());
583         return buildCssText(cssTexts, m_operator);
584     }
585 
586     bool equals(const CSSCalcExpressionNode&amp; exp) const final
587     {
588         if (type() != exp.type())
589             return false;
590 
591         const CSSCalcOperation&amp; other = static_cast&lt;const CSSCalcOperation&amp;&gt;(exp);
592 
593         if (m_children.size() != other.m_children.size() || m_operator != other.m_operator)
594             return false;
595 
596         for (size_t i = 0; i &lt; m_children.size(); ++i) {
597             if (!compareCSSValue(m_children[i], other.m_children[i]))
598                 return false;
599         }
600         return true;
601     }
602 
603     Type type() const final { return CssCalcOperation; }
604 
605     CSSPrimitiveValue::UnitType primitiveType() const final
606     {
607         switch (category()) {
608         case CalculationCategory::Number:
609 #if !ASSERT_DISABLED
610             for (auto&amp; child : m_children)
611                 ASSERT(child-&gt;category() == CalculationCategory::Number);
612 #endif
613             return CSSPrimitiveValue::CSS_NUMBER;
614         case CalculationCategory::Length:
615         case CalculationCategory::Percent: {
616             if (m_children.isEmpty())
617                 return CSSPrimitiveValue::CSS_UNKNOWN;
618             if (m_children.size() == 2) {
619                 if (m_children[0]-&gt;category() == CalculationCategory::Number)
620                     return m_children[1]-&gt;primitiveType();
621                 if (m_children[1]-&gt;category() == CalculationCategory::Number)
622                     return m_children[0]-&gt;primitiveType();
623             }
624             CSSPrimitiveValue::UnitType firstType = m_children[0]-&gt;primitiveType();
625             for (auto&amp; child : m_children) {
626                 if (firstType != child-&gt;primitiveType())
627                     return CSSPrimitiveValue::CSS_UNKNOWN;
628             }
629             return firstType;
630         }
631         case CalculationCategory::Angle:
632             return CSSPrimitiveValue::CSS_DEG;
633         case CalculationCategory::Time:
634             return CSSPrimitiveValue::CSS_MS;
635         case CalculationCategory::Frequency:
636             return CSSPrimitiveValue::CSS_HZ;
637         case CalculationCategory::PercentLength:
638         case CalculationCategory::PercentNumber:
639         case CalculationCategory::Other:
640             return CSSPrimitiveValue::CSS_UNKNOWN;
641         }
642         ASSERT_NOT_REACHED();
643         return CSSPrimitiveValue::CSS_UNKNOWN;
644     }
645 
646     CSSCalcOperation(CalculationCategory category, CalcOperator op, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)
647         : CSSCalcExpressionNode(category, isIntegerResult(op, leftSide.get(), rightSide.get()))
648         , m_operator(op)
649     {
650         m_children.reserveInitialCapacity(2);
651         m_children.uncheckedAppend(WTFMove(leftSide));
652         m_children.uncheckedAppend(WTFMove(rightSide));
653     }
654 
655     CSSCalcOperation(CalculationCategory category, CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; children)
656         : CSSCalcExpressionNode(category, isIntegerResult(op, children))
657         , m_operator(op)
658         , m_children(WTFMove(children))
659     {
660     }
661 
662     static CSSCalcExpressionNode* getNumberSide(CSSCalcExpressionNode&amp; leftSide, CSSCalcExpressionNode&amp; rightSide)
663     {
664         if (leftSide.category() == CalculationCategory::Number)
665             return &amp;leftSide;
666         if (rightSide.category() == CalculationCategory::Number)
667             return &amp;rightSide;
668         return nullptr;
669     }
670 
671     double evaluate(const Vector&lt;double&gt;&amp; children) const
672     {
673         return evaluateOperator(m_operator, children);
674     }
675 
676     static double evaluateOperator(CalcOperator op, const Vector&lt;double&gt;&amp; children)
677     {
678         switch (op) {
679         case CalcOperator::Add:
680             ASSERT(children.size() == 2);
681             return children[0] + children[1];
682         case CalcOperator::Subtract:
683             ASSERT(children.size() == 2);
684             return children[0] - children[1];
685         case CalcOperator::Multiply:
686             ASSERT(children.size() == 2);
687             return children[0] * children[1];
688         case CalcOperator::Divide:
689             ASSERT(children.size() == 1 || children.size() == 2);
690             if (children.size() == 1)
691                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
692             return children[0] / children[1];
693         case CalcOperator::Min: {
694             if (children.isEmpty())
695                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
696             double minimum = children[0];
697             for (auto child : children)
698                 minimum = std::min(minimum, child);
699             return minimum;
700         }
701         case CalcOperator::Max: {
702             if (children.isEmpty())
703                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
704             double maximum = children[0];
705             for (auto child : children)
706                 maximum = std::max(maximum, child);
707             return maximum;
708         }
709         }
710         ASSERT_NOT_REACHED();
711         return 0;
712     }
713 
714     const CalcOperator m_operator;
715     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; m_children;
716 };
717 
718 static ParseState checkDepthAndIndex(int* depth, CSSParserTokenRange tokens)
719 {
720     (*depth)++;
721     if (tokens.atEnd())
722         return NoMoreTokens;
723     if (*depth &gt; maxExpressionDepth)
724         return TooDeep;
725     return OK;
726 }
727 
728 class CSSCalcExpressionNodeParser {
729 public:
730     explicit CSSCalcExpressionNodeParser(CalculationCategory destinationCategory)
731         : m_destinationCategory(destinationCategory)
732     { }
733 
734     RefPtr&lt;CSSCalcExpressionNode&gt; parseCalc(CSSParserTokenRange tokens, CSSValueID function)
735     {
736         Value result;
737         tokens.consumeWhitespace();
738         bool ok = false;
739         if (function == CSSValueCalc || function == CSSValueWebkitCalc)
740             ok = parseValueExpression(tokens, 0, &amp;result);
741         else if (function == CSSValueMin || function == CSSValueMax)
742             ok = parseMinMaxExpression(tokens, function, 0, &amp;result);
743         if (!ok || !tokens.atEnd())
744             return nullptr;
745         return result.value;
746     }
747 
748 private:
749     struct Value {
750         RefPtr&lt;CSSCalcExpressionNode&gt; value;
751     };
752 
753     char operatorValue(const CSSParserToken&amp; token)
754     {
755         if (token.type() == DelimiterToken)
756             return token.delimiter();
757         return 0;
758     }
759 
760     bool parseValue(CSSParserTokenRange&amp; tokens, Value* result)
761     {
762         CSSParserToken token = tokens.consumeIncludingWhitespace();
763         if (!(token.type() == NumberToken || token.type() == PercentageToken || token.type() == DimensionToken))
764             return false;
765 
766         CSSPrimitiveValue::UnitType type = token.unitType();
767         if (unitCategory(type) == CalculationCategory::Other)
768             return false;
769 
770         bool isInteger = token.numericValueType() == IntegerValueType || (token.numericValueType() == NumberValueType &amp;&amp; token.numericValue() == trunc(token.numericValue()));
771         result-&gt;value = CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(token.numericValue(), type), isInteger);
772 
773         return true;
774     }
775 
776     bool parseValueTerm(CSSParserTokenRange&amp; tokens, int depth, Value* result)
777     {
778         if (checkDepthAndIndex(&amp;depth, tokens) != OK)
779             return false;
780 
781         auto functionId = tokens.peek().functionId();
782 
783         if (tokens.peek().type() == LeftParenthesisToken || functionId == CSSValueCalc) {
784             CSSParserTokenRange innerRange = tokens.consumeBlock();
785             tokens.consumeWhitespace();
786             innerRange.consumeWhitespace();
787             return parseValueExpression(innerRange, depth, result);
788         }
789 
790         if (functionId == CSSValueMax || functionId == CSSValueMin) {
791             CSSParserTokenRange innerRange = tokens.consumeBlock();
792             tokens.consumeWhitespace();
793             innerRange.consumeWhitespace();
794             return parseMinMaxExpression(innerRange, functionId, depth, result);
795         }
796 
797         return parseValue(tokens, result);
798     }
799 
800     bool parseValueMultiplicativeExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)
801     {
802         if (checkDepthAndIndex(&amp;depth, tokens) != OK)
803             return false;
804 
805         if (!parseValueTerm(tokens, depth, result))
806             return false;
807 
808         while (!tokens.atEnd()) {
809             char operatorCharacter = operatorValue(tokens.peek());
810             if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Multiply) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Divide))
811                 break;
812             tokens.consumeIncludingWhitespace();
813 
814             Value rhs;
815             if (!parseValueTerm(tokens, depth, &amp;rhs))
816                 return false;
817 
818             result-&gt;value = CSSCalcOperation::createSimplified(static_cast&lt;CalcOperator&gt;(operatorCharacter), WTFMove(result-&gt;value), WTFMove(rhs.value));
819 
820             if (!result-&gt;value)
821                 return false;
822         }
823 
824         return true;
825     }
826 
827     bool parseAdditiveValueExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)
828     {
829         if (checkDepthAndIndex(&amp;depth, tokens) != OK)
830             return false;
831 
832         if (!parseValueMultiplicativeExpression(tokens, depth, result))
833             return false;
834 
835         while (!tokens.atEnd()) {
836             char operatorCharacter = operatorValue(tokens.peek());
837             if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Add) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Subtract))
838                 break;
839             if ((&amp;tokens.peek() - 1)-&gt;type() != WhitespaceToken)
840                 return false; // calc(1px+ 2px) is invalid
841             tokens.consume();
842             if (tokens.peek().type() != WhitespaceToken)
843                 return false; // calc(1px +2px) is invalid
844             tokens.consumeIncludingWhitespace();
845 
846             Value rhs;
847             if (!parseValueMultiplicativeExpression(tokens, depth, &amp;rhs))
848                 return false;
849 
850             result-&gt;value = CSSCalcOperation::createSimplified(static_cast&lt;CalcOperator&gt;(operatorCharacter), WTFMove(result-&gt;value), WTFMove(rhs.value));
851             if (!result-&gt;value)
852                 return false;
853         }
854 
855         return true;
856     }
857 
858     bool parseMinMaxExpression(CSSParserTokenRange&amp; tokens, CSSValueID minMaxFunction, int depth, Value* result)
859     {
860         if (checkDepthAndIndex(&amp;depth, tokens) != OK)
861             return false;
862 
863         CalcOperator op = (minMaxFunction == CSSValueMin) ? CalcOperator::Min : CalcOperator::Max;
864 
865         Value value;
866         if (!parseValueExpression(tokens, depth, &amp;value))
867             return false;
868 
869         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;
870         nodes.append(value.value.releaseNonNull());
871 
872         while (!tokens.atEnd()) {
873             tokens.consumeWhitespace();
874             if (tokens.consume().type() != CommaToken)
875                 return false;
876             tokens.consumeWhitespace();
877 
878             if (!parseValueExpression(tokens, depth, &amp;value))
879                 return false;
880 
881             nodes.append(value.value.releaseNonNull());
882         }
883 
884         result-&gt;value = CSSCalcOperation::createMinOrMax(op, WTFMove(nodes), m_destinationCategory);
885         return result-&gt;value;
886     }
887 
888     bool parseValueExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)
889     {
890         return parseAdditiveValueExpression(tokens, depth, result);
891     }
892 
893     CalculationCategory m_destinationCategory;
894 };
895 
896 static inline RefPtr&lt;CSSCalcOperation&gt; createBlendHalf(const Length&amp; length, const RenderStyle&amp; style, float progress)
897 {
898     return CSSCalcOperation::create(CalcOperator::Multiply, createCSS(length, style),
899         CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(progress, CSSPrimitiveValue::CSS_NUMBER), !progress || progress == 1));
900 }
901 
902 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp; node, const RenderStyle&amp; style)
903 {
904     switch (node.type()) {
905     case CalcExpressionNodeType::Number: {
906         float value = toCalcExpressionNumber(node).value();
907         return CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(value, CSSPrimitiveValue::CSS_NUMBER), value == std::trunc(value));
908     }
909     case CalcExpressionNodeType::Length:
910         return createCSS(toCalcExpressionLength(node).length(), style);
911     case CalcExpressionNodeType::Operation: {
912         auto&amp; operationNode = toCalcExpressionOperation(node);
913         auto&amp; operationChildren = operationNode.children();
914         CalcOperator op = operationNode.getOperator();
915         if (op == CalcOperator::Min || op == CalcOperator::Max) {
916             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
917             values.reserveInitialCapacity(operationChildren.size());
918             for (auto&amp; child : operationChildren) {
919                 auto cssNode = createCSS(*child, style);
920                 if (!cssNode)
921                     return nullptr;
922                 values.uncheckedAppend(*cssNode);
923             }
924             return CSSCalcOperation::createMinOrMax(operationNode.getOperator(), WTFMove(values), CalculationCategory::Other);
925         }
926 
927         if (operationChildren.size() == 2)
928             return CSSCalcOperation::create(operationNode.getOperator(), createCSS(*operationChildren[0], style), createCSS(*operationChildren[1], style));
929 
930         return nullptr;
931     }
932     case CalcExpressionNodeType::BlendLength: {
933         // FIXME: (http://webkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.
934         auto&amp; blend = toCalcExpressionBlendLength(node);
935         float progress = blend.progress();
936         return CSSCalcOperation::create(CalcOperator::Add, createBlendHalf(blend.from(), style, 1 - progress), createBlendHalf(blend.to(), style, progress));
937     }
938     case CalcExpressionNodeType::Undefined:
939         ASSERT_NOT_REACHED();
940     }
941     return nullptr;
942 }
943 
944 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp; length, const RenderStyle&amp; style)
945 {
946     switch (length.type()) {
947     case Percent:
948     case Fixed:
949         return CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(length, style), length.value() == trunc(length.value()));
950     case Calculated:
951         return createCSS(length.calculationValue().expression(), style);
952     case Auto:
953     case Intrinsic:
954     case MinIntrinsic:
955     case MinContent:
956     case MaxContent:
957     case FillAvailable:
958     case FitContent:
959     case Relative:
960     case Undefined:
961         ASSERT_NOT_REACHED();
962     }
963     return nullptr;
964 }
965 
966 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(CSSValueID function, const CSSParserTokenRange&amp; tokens, CalculationCategory destinationCategory, ValueRange range)
967 {
968     CSSCalcExpressionNodeParser parser(destinationCategory);
969     auto expression = parser.parseCalc(tokens, function);
970     if (!expression)
971         return nullptr;
972     return adoptRef(new CSSCalcValue(expression.releaseNonNull(), range != ValueRangeAll));
973 }
974 
975 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(const CalculationValue&amp; value, const RenderStyle&amp; style)
976 {
977     auto expression = createCSS(value.expression(), style);
978     if (!expression)
979         return nullptr;
980     return adoptRef(new CSSCalcValue(expression.releaseNonNull(), value.shouldClampToNonNegative()));
981 }
982 
983 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>