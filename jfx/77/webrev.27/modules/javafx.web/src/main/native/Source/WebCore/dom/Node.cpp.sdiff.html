<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NamedNodeMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Node.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;Attr.h&quot;
  30 #include &quot;BeforeLoadEvent.h&quot;
  31 #include &quot;ChildListMutationScope.h&quot;
  32 #include &quot;CommonVM.h&quot;
  33 #include &quot;ComposedTreeAncestorIterator.h&quot;
  34 #include &quot;ContainerNodeAlgorithms.h&quot;



  35 #include &quot;ContextMenuController.h&quot;
  36 #include &quot;DOMWindow.h&quot;
  37 #include &quot;DataTransfer.h&quot;
  38 #include &quot;DocumentType.h&quot;
  39 #include &quot;ElementIterator.h&quot;
  40 #include &quot;ElementRareData.h&quot;
  41 #include &quot;ElementTraversal.h&quot;
  42 #include &quot;EventDispatcher.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;FrameView.h&quot;

  45 #include &quot;HTMLBodyElement.h&quot;
  46 #include &quot;HTMLCollection.h&quot;
  47 #include &quot;HTMLElement.h&quot;
  48 #include &quot;HTMLImageElement.h&quot;
  49 #include &quot;HTMLSlotElement.h&quot;
  50 #include &quot;HTMLStyleElement.h&quot;
  51 #include &quot;InputEvent.h&quot;
  52 #include &quot;InspectorController.h&quot;
  53 #include &quot;KeyboardEvent.h&quot;
  54 #include &quot;Logging.h&quot;
  55 #include &quot;MutationEvent.h&quot;
  56 #include &quot;NodeRenderStyle.h&quot;
  57 #include &quot;ProcessingInstruction.h&quot;
  58 #include &quot;ProgressEvent.h&quot;
  59 #include &quot;Range.h&quot;
  60 #include &quot;RenderBlock.h&quot;
  61 #include &quot;RenderBox.h&quot;
  62 #include &quot;RenderTextControl.h&quot;
  63 #include &quot;RenderView.h&quot;

  64 #include &quot;ScopedEventQueue.h&quot;
  65 #include &quot;ScriptDisallowedScope.h&quot;
  66 #include &quot;StorageEvent.h&quot;
  67 #include &quot;StyleResolver.h&quot;
  68 #include &quot;StyleSheetContents.h&quot;
  69 #include &quot;TemplateContentDocumentFragment.h&quot;
  70 #include &quot;TextEvent.h&quot;
  71 #include &quot;TouchEvent.h&quot;
  72 #include &quot;WheelEvent.h&quot;
  73 #include &quot;XMLNSNames.h&quot;
  74 #include &quot;XMLNames.h&quot;
  75 #include &lt;wtf/IsoMallocInlines.h&gt;
  76 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  77 #include &lt;wtf/SHA1.h&gt;
  78 #include &lt;wtf/Variant.h&gt;
  79 #include &lt;wtf/text/CString.h&gt;
  80 #include &lt;wtf/text/StringBuilder.h&gt;
  81 
  82 namespace WebCore {
  83 
</pre>
<hr />
<pre>
  86 using namespace HTMLNames;
  87 
  88 #if DUMP_NODE_STATISTICS
  89 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  90 {
  91     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  92     return liveNodes;
  93 }
  94 
  95 static const char* stringForRareDataUseType(NodeRareData::UseType useType)
  96 {
  97     switch (useType) {
  98     case NodeRareData::UseType::ConnectedFrameCount:
  99         return &quot;ConnectedFrameCount&quot;;
 100     case NodeRareData::UseType::NodeList:
 101         return &quot;NodeList&quot;;
 102     case NodeRareData::UseType::MutationObserver:
 103         return &quot;MutationObserver&quot;;
 104     case NodeRareData::UseType::TabIndex:
 105         return &quot;TabIndex&quot;;
<span class="line-removed"> 106     case NodeRareData::UseType::StyleFlags:</span>
<span class="line-removed"> 107         return &quot;StyleFlags&quot;;</span>
 108     case NodeRareData::UseType::MinimumSize:
 109         return &quot;MinimumSize&quot;;
 110     case NodeRareData::UseType::ScrollingPosition:
 111         return &quot;ScrollingPosition&quot;;
 112     case NodeRareData::UseType::ComputedStyle:
 113         return &quot;ComputedStyle&quot;;
 114     case NodeRareData::UseType::Dataset:
 115         return &quot;Dataset&quot;;
 116     case NodeRareData::UseType::ClassList:
 117         return &quot;ClassList&quot;;
 118     case NodeRareData::UseType::ShadowRoot:
 119         return &quot;ShadowRoot&quot;;
 120     case NodeRareData::UseType::CustomElementQueue:
 121         return &quot;CustomElementQueue&quot;;
 122     case NodeRareData::UseType::AttributeMap:
 123         return &quot;AttributeMap&quot;;
 124     case NodeRareData::UseType::InteractionObserver:
 125         return &quot;InteractionObserver&quot;;
 126     case NodeRareData::UseType::PseudoElements:
 127         return &quot;PseudoElements&quot;;
</pre>
<hr />
<pre>
 299 #ifndef NDEBUG
 300     shouldIgnoreLeaks = false;
 301 #endif
 302 }
 303 
 304 void Node::trackForDebugging()
 305 {
 306 #ifndef NDEBUG
 307     if (shouldIgnoreLeaks)
 308         ignoreSet().add(this);
 309     else
 310         nodeCounter.increment();
 311 #endif
 312 
 313 #if DUMP_NODE_STATISTICS
 314     liveNodeSet().add(this);
 315 #endif
 316 }
 317 
 318 Node::Node(Document&amp; document, ConstructionType type)
<span class="line-modified"> 319     : m_refCount(1)</span>
<span class="line-removed"> 320     , m_nodeFlags(type)</span>
 321     , m_treeScope(&amp;document)
 322 {
 323     ASSERT(isMainThread());
 324 
 325     document.incrementReferencingNodeCount();
 326 
 327 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS)
 328     trackForDebugging();
 329 #endif
 330 }
 331 
 332 Node::~Node()
 333 {
 334     ASSERT(isMainThread());
<span class="line-modified"> 335     // We set m_refCount to 1 before calling delete to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.</span>
<span class="line-removed"> 336     // This is a security mitigation in case of programmer errorm (caught by a debug assertion).</span>
<span class="line-removed"> 337     ASSERT(m_refCount == 1);</span>
 338     ASSERT(m_deletionHasBegun);
 339     ASSERT(!m_adoptionIsRequired);
 340 
 341 #ifndef NDEBUG
 342     if (!ignoreSet().remove(this))
 343         nodeCounter.decrement();
 344 #endif
 345 
 346 #if DUMP_NODE_STATISTICS
 347     liveNodeSet().remove(this);
 348 #endif
 349 
 350     RELEASE_ASSERT(!renderer());
 351     ASSERT(!parentNode());
 352     ASSERT(!m_previous);
 353     ASSERT(!m_next);
 354 
 355     if (hasRareData())
 356         clearRareData();
 357 
</pre>
<hr />
<pre>
 377     if (hasEventTargetData()) {
 378         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 379 #if ENABLE(TOUCH_EVENTS)
 380 #if PLATFORM(IOS_FAMILY)
 381         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 382 #endif
 383         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 384 #endif
 385     }
 386 
 387 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
 388     document.removeTouchEventHandler(*this, EventHandlerRemoval::All);
 389 #endif
 390 
 391     if (auto* cache = document.existingAXObjectCache())
 392         cache-&gt;remove(*this);
 393 }
 394 
 395 void Node::materializeRareData()
 396 {
<span class="line-removed"> 397     NodeRareData* data;</span>
 398     if (is&lt;Element&gt;(*this))
<span class="line-modified"> 399         data = std::make_unique&lt;ElementRareData&gt;(downcast&lt;RenderElement&gt;(m_data.m_renderer)).release();</span>
 400     else
<span class="line-modified"> 401         data = std::make_unique&lt;NodeRareData&gt;(m_data.m_renderer).release();</span>
<span class="line-modified"> 402     ASSERT(data);</span>
 403 
<span class="line-modified"> 404     m_data.m_rareData = data;</span>
<span class="line-modified"> 405     setFlag(HasRareDataFlag);</span>




 406 }
 407 
 408 void Node::clearRareData()
 409 {
 410     ASSERT(hasRareData());
 411     ASSERT(!transientMutationObserverRegistry() || transientMutationObserverRegistry()-&gt;isEmpty());
 412 
<span class="line-modified"> 413     RenderObject* renderer = m_data.m_rareData-&gt;renderer();</span>
<span class="line-removed"> 414     if (isElementNode())</span>
<span class="line-removed"> 415         delete static_cast&lt;ElementRareData*&gt;(m_data.m_rareData);</span>
<span class="line-removed"> 416     else</span>
<span class="line-removed"> 417         delete static_cast&lt;NodeRareData*&gt;(m_data.m_rareData);</span>
<span class="line-removed"> 418     m_data.m_renderer = renderer;</span>
<span class="line-removed"> 419     clearFlag(HasRareDataFlag);</span>
 420 }
 421 
 422 bool Node::isNode() const
 423 {
 424     return true;
 425 }
 426 
 427 String Node::nodeValue() const
 428 {
 429     return String();
 430 }
 431 
 432 ExceptionOr&lt;void&gt; Node::setNodeValue(const String&amp;)
 433 {
 434     // By default, setting nodeValue has no effect.
 435     return { };
 436 }
 437 
 438 RefPtr&lt;NodeList&gt; Node::childNodes()
 439 {
</pre>
<hr />
<pre>
 671             }
 672 
 673             // Both non-empty text nodes. Merge them.
 674             unsigned offset = text-&gt;length();
 675             text-&gt;appendData(nextText-&gt;data());
 676             document().textNodesMerged(nextText, offset);
 677             nextText-&gt;remove();
 678         }
 679 
 680         node = NodeTraversal::nextPostOrder(*node);
 681     }
 682 }
 683 
 684 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 685 {
 686     if (UNLIKELY(isShadowRoot()))
 687         return Exception { NotSupportedError };
 688     return cloneNode(deep);
 689 }
 690 
<span class="line-modified"> 691 const AtomicString&amp; Node::prefix() const</span>
 692 {
 693     // For nodes other than elements and attributes, the prefix is always null
 694     return nullAtom();
 695 }
 696 
<span class="line-modified"> 697 ExceptionOr&lt;void&gt; Node::setPrefix(const AtomicString&amp;)</span>
 698 {
 699     // The spec says that for nodes other than elements and attributes, prefix is always null.
 700     // It does not say what to do when the user tries to set the prefix on another type of
 701     // node, however Mozilla throws a NamespaceError exception.
 702     return Exception { NamespaceError };
 703 }
 704 
<span class="line-modified"> 705 const AtomicString&amp; Node::localName() const</span>
 706 {
 707     return nullAtom();
 708 }
 709 
<span class="line-modified"> 710 const AtomicString&amp; Node::namespaceURI() const</span>
 711 {
 712     return nullAtom();
 713 }
 714 
 715 bool Node::isContentEditable()
 716 {
 717     return computeEditability(UserSelectAllDoesNotAffectEditability, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 718 }
 719 
 720 bool Node::isContentRichlyEditable()
 721 {
 722     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) == Editability::CanEditRichly;
 723 }
 724 
 725 void Node::inspect()
 726 {
 727     if (document().page())
 728         document().page()-&gt;inspectorController().inspect(this);
 729 }
 730 
</pre>
<hr />
<pre>
 779         document().updateStyleIfNeeded();
 780     }
 781     return computeEditabilityFromComputedStyle(*this, treatment);
 782 }
 783 
 784 RenderBox* Node::renderBox() const
 785 {
 786     RenderObject* renderer = this-&gt;renderer();
 787     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 788 }
 789 
 790 RenderBoxModelObject* Node::renderBoxModelObject() const
 791 {
 792     RenderObject* renderer = this-&gt;renderer();
 793     return is&lt;RenderBoxModelObject&gt;(renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;
 794 }
 795 
 796 LayoutRect Node::renderRect(bool* isReplaced)
 797 {
 798     RenderObject* hitRenderer = this-&gt;renderer();
<span class="line-modified"> 799     ASSERT(hitRenderer);</span>




 800     RenderObject* renderer = hitRenderer;
 801     while (renderer &amp;&amp; !renderer-&gt;isBody() &amp;&amp; !renderer-&gt;isDocumentElementRenderer()) {
 802         if (renderer-&gt;isRenderBlock() || renderer-&gt;isInlineBlockOrInlineTable() || renderer-&gt;isReplaced()) {
 803             *isReplaced = renderer-&gt;isReplaced();
 804             return renderer-&gt;absoluteBoundingBoxRect();
 805         }
 806         renderer = renderer-&gt;parent();
 807     }
 808     return LayoutRect();
 809 }
 810 
 811 void Node::refEventTarget()
 812 {
 813     ref();
 814 }
 815 
 816 void Node::derefEventTarget()
 817 {
 818     deref();
 819 }
</pre>
<hr />
<pre>
 956 
 957     for (auto* node = this; node; node = node-&gt;parentNode()) {
 958         if (!node-&gt;hasRareData())
 959             continue;
 960 
 961         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 962             lists-&gt;invalidateCachesForAttribute(attrName);
 963     }
 964 }
 965 
 966 NodeListsNodeData* Node::nodeLists()
 967 {
 968     return hasRareData() ? rareData()-&gt;nodeLists() : nullptr;
 969 }
 970 
 971 void Node::clearNodeLists()
 972 {
 973     rareData()-&gt;clearNodeLists();
 974 }
 975 
<span class="line-modified"> 976 ExceptionOr&lt;void&gt; Node::checkSetPrefix(const AtomicString&amp; prefix)</span>
 977 {
 978     // Perform error checking as required by spec for setting Node.prefix. Used by
 979     // Element::setPrefix() and Attr::setPrefix()
 980 
 981     if (!prefix.isEmpty() &amp;&amp; !Document::isValidName(prefix))
 982         return Exception { InvalidCharacterError };
 983 
 984     // FIXME: Raise NamespaceError if prefix is malformed per the Namespaces in XML specification.
 985 
 986     auto&amp; namespaceURI = this-&gt;namespaceURI();
 987     if (namespaceURI.isEmpty() &amp;&amp; !prefix.isEmpty())
 988         return Exception { NamespaceError };
 989     if (prefix == xmlAtom() &amp;&amp; namespaceURI != XMLNames::xmlNamespaceURI)
 990         return Exception { NamespaceError };
 991 
 992     // Attribute-specific checks are in Attr::setPrefix().
 993 
 994     return { };
 995 }
 996 
</pre>
<hr />
<pre>
1391     }
1392 
1393     Node* child = firstChild();
1394     Node* otherChild = other-&gt;firstChild();
1395 
1396     while (child) {
1397         if (!child-&gt;isEqualNode(otherChild))
1398             return false;
1399 
1400         child = child-&gt;nextSibling();
1401         otherChild = otherChild-&gt;nextSibling();
1402     }
1403 
1404     if (otherChild)
1405         return false;
1406 
1407     return true;
1408 }
1409 
1410 // https://dom.spec.whatwg.org/#locate-a-namespace
<span class="line-modified">1411 static const AtomicString&amp; locateDefaultNamespace(const Node&amp; node, const AtomicString&amp; prefix)</span>
1412 {
1413     switch (node.nodeType()) {
1414     case Node::ELEMENT_NODE: {
1415         auto&amp; element = downcast&lt;Element&gt;(node);
1416         auto&amp; namespaceURI = element.namespaceURI();
1417         if (!namespaceURI.isNull() &amp;&amp; element.prefix() == prefix)
1418             return namespaceURI;
1419 
1420         if (element.hasAttributes()) {
1421             for (auto&amp; attribute : element.attributesIterator()) {
1422                 if (attribute.namespaceURI() != XMLNSNames::xmlnsNamespaceURI)
1423                     continue;
1424 
1425                 if ((prefix.isNull() &amp;&amp; attribute.prefix().isNull() &amp;&amp; attribute.localName() == xmlnsAtom()) || (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.localName() == prefix)) {
1426                     auto&amp; result = attribute.value();
1427                     return result.isEmpty() ? nullAtom() : result;
1428                 }
1429             }
1430         }
1431         auto* parent = node.parentElement();
</pre>
<hr />
<pre>
1433     }
1434     case Node::DOCUMENT_NODE:
1435         if (auto* documentElement = downcast&lt;Document&gt;(node).documentElement())
1436             return locateDefaultNamespace(*documentElement, prefix);
1437         return nullAtom();
1438     case Node::DOCUMENT_TYPE_NODE:
1439     case Node::DOCUMENT_FRAGMENT_NODE:
1440         return nullAtom();
1441     case Node::ATTRIBUTE_NODE:
1442         if (auto* ownerElement = downcast&lt;Attr&gt;(node).ownerElement())
1443             return locateDefaultNamespace(*ownerElement, prefix);
1444         return nullAtom();
1445     default:
1446         if (auto* parent = node.parentElement())
1447             return locateDefaultNamespace(*parent, prefix);
1448         return nullAtom();
1449     }
1450 }
1451 
1452 // https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
<span class="line-modified">1453 bool Node::isDefaultNamespace(const AtomicString&amp; potentiallyEmptyNamespace) const</span>
1454 {
<span class="line-modified">1455     const AtomicString&amp; namespaceURI = potentiallyEmptyNamespace.isEmpty() ? nullAtom() : potentiallyEmptyNamespace;</span>
1456     return locateDefaultNamespace(*this, nullAtom()) == namespaceURI;
1457 }
1458 
1459 // https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
<span class="line-modified">1460 const AtomicString&amp; Node::lookupNamespaceURI(const AtomicString&amp; potentiallyEmptyPrefix) const</span>
1461 {
<span class="line-modified">1462     const AtomicString&amp; prefix = potentiallyEmptyPrefix.isEmpty() ? nullAtom() : potentiallyEmptyPrefix;</span>
1463     return locateDefaultNamespace(*this, prefix);
1464 }
1465 
1466 // https://dom.spec.whatwg.org/#locate-a-namespace-prefix
<span class="line-modified">1467 static const AtomicString&amp; locateNamespacePrefix(const Element&amp; element, const AtomicString&amp; namespaceURI)</span>
1468 {
1469     if (element.namespaceURI() == namespaceURI)
1470         return element.prefix();
1471 
1472     if (element.hasAttributes()) {
1473         for (auto&amp; attribute : element.attributesIterator()) {
1474             if (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.value() == namespaceURI)
1475                 return attribute.localName();
1476         }
1477     }
1478     auto* parent = element.parentElement();
1479     return parent ? locateNamespacePrefix(*parent, namespaceURI) : nullAtom();
1480 }
1481 
1482 // https://dom.spec.whatwg.org/#dom-node-lookupprefix
<span class="line-modified">1483 const AtomicString&amp; Node::lookupPrefix(const AtomicString&amp; namespaceURI) const</span>
1484 {
1485     if (namespaceURI.isEmpty())
1486         return nullAtom();
1487 
1488     switch (nodeType()) {
1489     case ELEMENT_NODE:
1490         return locateNamespacePrefix(downcast&lt;Element&gt;(*this), namespaceURI);
1491     case DOCUMENT_NODE:
1492         if (auto* documentElement = downcast&lt;Document&gt;(*this).documentElement())
1493             return locateNamespacePrefix(*documentElement, namespaceURI);
1494         return nullAtom();
1495     case DOCUMENT_FRAGMENT_NODE:
1496     case DOCUMENT_TYPE_NODE:
1497         return nullAtom();
1498     case ATTRIBUTE_NODE:
1499         if (auto* ownerElement = downcast&lt;Attr&gt;(*this).ownerElement())
1500             return locateNamespacePrefix(*ownerElement, namespaceURI);
1501         return nullAtom();
1502     default:
1503         if (auto* parent = parentElement())
</pre>
<hr />
<pre>
1721 {
1722     // If there is a renderer, just ask it to do the conversion
1723     if (renderer())
1724         return renderer()-&gt;absoluteToLocal(p, UseTransforms);
1725 
1726     // Otherwise go up the tree looking for a renderer
1727     if (auto* parent = parentElement())
1728         return parent-&gt;convertFromPage(p);
1729 
1730     // No parent - no conversion needed
1731     return p;
1732 }
1733 
1734 #if ENABLE(TREE_DEBUGGING)
1735 
1736 static void appendAttributeDesc(const Node* node, StringBuilder&amp; stringBuilder, const QualifiedName&amp; name, const char* attrDesc)
1737 {
1738     if (!is&lt;Element&gt;(*node))
1739         return;
1740 
<span class="line-modified">1741     const AtomicString&amp; attr = downcast&lt;Element&gt;(*node).getAttribute(name);</span>
1742     if (attr.isEmpty())
1743         return;
1744 
1745     stringBuilder.append(attrDesc);
1746     stringBuilder.append(attr);
1747 }
1748 
1749 void Node::showNode(const char* prefix) const
1750 {
1751     if (!prefix)
1752         prefix = &quot;&quot;;
1753     if (isTextNode()) {
1754         String value = nodeValue();
1755         value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1756         value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1757         fprintf(stderr, &quot;%s%s\t%p \&quot;%s\&quot;\n&quot;, prefix, nodeName().utf8().data(), this, value.utf8().data());
1758     } else {
1759         StringBuilder attrs;
1760         appendAttributeDesc(this, attrs, classAttr, &quot; CLASS=&quot;);
1761         appendAttributeDesc(this, attrs, styleAttr, &quot; STYLE=&quot;);
</pre>
<hr />
<pre>
1774     const Node* node = this;
1775     while (node-&gt;parentOrShadowHostNode()) {
1776         chain.append(node);
1777         node = node-&gt;parentOrShadowHostNode();
1778     }
1779     for (unsigned index = chain.size(); index &gt; 0; --index) {
1780         const Node* node = chain[index - 1];
1781         if (is&lt;ShadowRoot&gt;(*node)) {
1782             int count = 0;
1783             for (const ShadowRoot* shadowRoot = downcast&lt;ShadowRoot&gt;(node); shadowRoot &amp;&amp; shadowRoot != node; shadowRoot = shadowRoot-&gt;shadowRoot())
1784                 ++count;
1785             fprintf(stderr, &quot;/#shadow-root[%d]&quot;, count);
1786             continue;
1787         }
1788 
1789         switch (node-&gt;nodeType()) {
1790         case ELEMENT_NODE: {
1791             fprintf(stderr, &quot;/%s&quot;, node-&gt;nodeName().utf8().data());
1792 
1793             const Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1794             const AtomicString&amp; idattr = element.getIdAttribute();</span>
1795             bool hasIdAttr = !idattr.isNull() &amp;&amp; !idattr.isEmpty();
1796             if (node-&gt;previousSibling() || node-&gt;nextSibling()) {
1797                 int count = 0;
1798                 for (Node* previous = node-&gt;previousSibling(); previous; previous = previous-&gt;previousSibling())
1799                     if (previous-&gt;nodeName() == node-&gt;nodeName())
1800                         ++count;
1801                 if (hasIdAttr)
1802                     fprintf(stderr, &quot;[@id=\&quot;%s\&quot; and position()=%d]&quot;, idattr.string().utf8().data(), count);
1803                 else
1804                     fprintf(stderr, &quot;[%d]&quot;, count);
1805             } else if (hasIdAttr)
1806                 fprintf(stderr, &quot;[@id=\&quot;%s\&quot;]&quot;, idattr.string().utf8().data());
1807             break;
1808         }
1809         case TEXT_NODE:
1810             fprintf(stderr, &quot;/text()&quot;);
1811             break;
1812         case ATTRIBUTE_NODE:
1813             fprintf(stderr, &quot;/@%s&quot;, node-&gt;nodeName().utf8().data());
1814             break;
</pre>
<hr />
<pre>
2037     oldDocument.moveNodeIteratorsToNewDocument(*this, newDocument);
2038 
2039     if (AXObjectCache::accessibilityEnabled()) {
2040         if (auto* cache = oldDocument.existingAXObjectCache())
2041             cache-&gt;remove(*this);
2042     }
2043 
2044     if (auto* eventTargetData = this-&gt;eventTargetData()) {
2045         if (!eventTargetData-&gt;eventListenerMap.isEmpty()) {
2046             for (auto&amp; type : eventTargetData-&gt;eventListenerMap.eventTypes())
2047                 newDocument.addListenerTypeIfNeeded(type);
2048         }
2049 
2050         unsigned numWheelEventHandlers = eventListeners(eventNames().mousewheelEvent).size() + eventListeners(eventNames().wheelEvent).size();
2051         for (unsigned i = 0; i &lt; numWheelEventHandlers; ++i) {
2052             oldDocument.didRemoveWheelEventHandler(*this);
2053             newDocument.didAddWheelEventHandler(*this);
2054         }
2055 
2056         unsigned numTouchEventListeners = 0;
<span class="line-modified">2057         for (auto&amp; name : eventNames().touchAndPointerEventNames())</span>
<span class="line-modified">2058             numTouchEventListeners += eventListeners(name).size();</span>









2059 
2060         for (unsigned i = 0; i &lt; numTouchEventListeners; ++i) {
2061             oldDocument.didRemoveTouchEventHandler(*this);
2062             newDocument.didAddTouchEventHandler(*this);
2063 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2064             oldDocument.removeTouchEventListener(*this);
2065             newDocument.addTouchEventListener(*this);
2066 #endif
2067         }
2068 
2069 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2070         unsigned numGestureEventListeners = 0;
2071         for (auto&amp; name : eventNames().gestureEventNames())
2072             numGestureEventListeners += eventListeners(name).size();
2073 
2074         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2075             oldDocument.removeTouchEventHandler(*this);
2076             newDocument.addTouchEventHandler(*this);
2077         }
2078 #endif
2079     }
2080 
2081 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
2082 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2083     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2084     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2085 #endif
2086 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2087     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2088 #endif
2089 #endif
2090 
2091     if (is&lt;Element&gt;(*this))
2092         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2093 }
2094 
<span class="line-modified">2095 static inline bool tryAddEventListener(Node* targetNode, const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)</span>
2096 {
2097     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2098         return false;
2099 
2100     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2101     if (eventNames().isWheelEventType(eventType))
2102         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
<span class="line-modified">2103     else if (eventNames().isTouchEventType(eventType))</span>
2104         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2105 
2106 #if PLATFORM(IOS_FAMILY)
2107     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2108         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();
2109 
<span class="line-removed">2110     // FIXME: Would it be sufficient to special-case this code for &lt;body&gt; and &lt;frameset&gt;?</span>
<span class="line-removed">2111     //</span>
<span class="line-removed">2112     // This code was added to address &lt;rdar://problem/5846492&gt; Onorientationchange event not working for document.body.</span>
<span class="line-removed">2113     // Forward this call to addEventListener() to the window since these are window-only events.</span>
<span class="line-removed">2114     if (eventType == eventNames().orientationchangeEvent || eventType == eventNames().resizeEvent)</span>
<span class="line-removed">2115         targetNode-&gt;document().domWindow()-&gt;addEventListener(eventType, WTFMove(listener), options);</span>
<span class="line-removed">2116 </span>
2117 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified">2118     if (eventNames().isTouchEventType(eventType))</span>
2119         targetNode-&gt;document().addTouchEventListener(*targetNode);
2120 #endif
2121 #endif // PLATFORM(IOS_FAMILY)
2122 
2123 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2124     if (eventNames().isGestureEventType(eventType))
2125         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2126 #endif
2127 
2128     return true;
2129 }
2130 
<span class="line-modified">2131 bool Node::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
2132 {
2133     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2134 }
2135 
<span class="line-modified">2136 static inline bool tryRemoveEventListener(Node* targetNode, const AtomicString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)</span>
2137 {
2138     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2139         return false;
2140 
2141     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2142     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2143     if (eventNames().isWheelEventType(eventType))
2144         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
<span class="line-modified">2145     else if (eventNames().isTouchEventType(eventType))</span>
2146         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2147 
2148 #if PLATFORM(IOS_FAMILY)
2149     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2150         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();
2151 
<span class="line-removed">2152     // FIXME: Would it be sufficient to special-case this code for &lt;body&gt; and &lt;frameset&gt;? See &lt;rdar://problem/15647823&gt;.</span>
<span class="line-removed">2153     // This code was added to address &lt;rdar://problem/5846492&gt; Onorientationchange event not working for document.body.</span>
<span class="line-removed">2154     // Forward this call to removeEventListener() to the window since these are window-only events.</span>
<span class="line-removed">2155     if (eventType == eventNames().orientationchangeEvent || eventType == eventNames().resizeEvent)</span>
<span class="line-removed">2156         targetNode-&gt;document().domWindow()-&gt;removeEventListener(eventType, listener, options);</span>
<span class="line-removed">2157 </span>
2158 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified">2159     if (eventNames().isTouchEventType(eventType))</span>
2160         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2161 #endif
2162 #endif // PLATFORM(IOS_FAMILY)
2163 
2164 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2165     if (eventNames().isGestureEventType(eventType))
2166         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2167 #endif
2168 
2169     return true;
2170 }
2171 
<span class="line-modified">2172 bool Node::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
2173 {
2174     return tryRemoveEventListener(this, eventType, listener, options);
2175 }
2176 
2177 typedef HashMap&lt;Node*, std::unique_ptr&lt;EventTargetData&gt;&gt; EventTargetDataMap;
2178 
2179 static EventTargetDataMap&amp; eventTargetDataMap()
2180 {
2181     static NeverDestroyed&lt;EventTargetDataMap&gt; map;
2182 
2183     return map;
2184 }
2185 
2186 static Lock s_eventTargetDataMapLock;
2187 
2188 EventTargetData* Node::eventTargetData()
2189 {
2190     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2191 }
2192 
</pre>
<hr />
<pre>
2196     // calls this function from many threads. Parallel constraint solving can happen with the world
2197     // running or stopped, but if we do it with a running world, then we&#39;re usually mixing constraint
2198     // solving with other work. Therefore, the most likely time for contention on this lock is when the
2199     // world is stopped. We don&#39;t have to hold the lock when the world is stopped, because a stopped world
2200     // means that we will never mutate the event target data map.
2201     JSC::VM* vm = commonVMOrNull();
2202     auto locker = holdLockIf(s_eventTargetDataMapLock, vm &amp;&amp; vm-&gt;heap.worldIsRunning());
2203     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2204 }
2205 
2206 EventTargetData&amp; Node::ensureEventTargetData()
2207 {
2208     if (hasEventTargetData())
2209         return *eventTargetDataMap().get(this);
2210 
2211     JSC::VM* vm = commonVMOrNull();
2212     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2213 
2214     auto locker = holdLock(s_eventTargetDataMapLock);
2215     setHasEventTargetData(true);
<span class="line-modified">2216     return *eventTargetDataMap().add(this, std::make_unique&lt;EventTargetData&gt;()).iterator-&gt;value;</span>
2217 }
2218 
2219 void Node::clearEventTargetData()
2220 {
2221     JSC::VM* vm = commonVMOrNull();
2222     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2223     auto locker = holdLock(s_eventTargetDataMapLock);
2224     eventTargetDataMap().remove(this);
2225 }
2226 
2227 Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* Node::mutationObserverRegistry()
2228 {
2229     if (!hasRareData())
2230         return nullptr;
2231     auto* data = rareData()-&gt;mutationObserverData();
2232     if (!data)
2233         return nullptr;
2234     return &amp;data-&gt;registry;
2235 }
2236 
</pre>
<hr />
<pre>
2255             auto result = observers.add(registration-&gt;observer(), deliveryOptions);
2256             if (!result.isNewEntry)
2257                 result.iterator-&gt;value |= deliveryOptions;
2258         }
2259     }
2260 }
2261 
2262 HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; Node::registeredMutationObservers(MutationObserver::MutationType type, const QualifiedName* attributeName)
2263 {
2264     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; result;
2265     ASSERT((type == MutationObserver::Attributes &amp;&amp; attributeName) || !attributeName);
2266     collectMatchingObserversForMutation(result, mutationObserverRegistry(), *this, type, attributeName);
2267     collectMatchingObserversForMutation(result, transientMutationObserverRegistry(), *this, type, attributeName);
2268     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2269         collectMatchingObserversForMutation(result, node-&gt;mutationObserverRegistry(), *this, type, attributeName);
2270         collectMatchingObserversForMutation(result, node-&gt;transientMutationObserverRegistry(), *this, type, attributeName);
2271     }
2272     return result;
2273 }
2274 
<span class="line-modified">2275 void Node::registerMutationObserver(MutationObserver&amp; observer, MutationObserverOptions options, const HashSet&lt;AtomicString&gt;&amp; attributeFilter)</span>
2276 {
2277     MutationObserverRegistration* registration = nullptr;
2278     auto&amp; registry = ensureRareData().ensureMutationObserverData().registry;
2279 
2280     for (auto&amp; candidateRegistration : registry) {
2281         if (&amp;candidateRegistration-&gt;observer() == &amp;observer) {
2282             registration = candidateRegistration.get();
2283             registration-&gt;resetObservation(options, attributeFilter);
2284         }
2285     }
2286 
2287     if (!registration) {
<span class="line-modified">2288         registry.append(std::make_unique&lt;MutationObserverRegistration&gt;(observer, *this, options, attributeFilter));</span>
2289         registration = registry.last().get();
2290     }
2291 
2292     document().addMutationObserverTypes(registration-&gt;mutationTypes());
2293 }
2294 
2295 void Node::unregisterMutationObserver(MutationObserverRegistration&amp; registration)
2296 {
2297     auto* registry = mutationObserverRegistry();
2298     ASSERT(registry);
2299     if (!registry)
2300         return;
2301 
2302     registry-&gt;removeFirstMatching([&amp;registration] (auto&amp; current) {
2303         return current.get() == &amp;registration;
2304     });
2305 }
2306 
2307 void Node::registerTransientMutationObserver(MutationObserverRegistration&amp; registration)
2308 {
</pre>
<hr />
<pre>
2351 
2352 void Node::dispatchScopedEvent(Event&amp; event)
2353 {
2354     EventDispatcher::dispatchScopedEvent(*this, event);
2355 }
2356 
2357 void Node::dispatchEvent(Event&amp; event)
2358 {
2359     EventDispatcher::dispatchEvent(*this, event);
2360 }
2361 
2362 void Node::dispatchSubtreeModifiedEvent()
2363 {
2364     if (isInShadowTree())
2365         return;
2366 
2367     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(*this));
2368 
2369     if (!document().hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER))
2370         return;
<span class="line-modified">2371     const AtomicString&amp; subtreeModifiedEventName = eventNames().DOMSubtreeModifiedEvent;</span>
2372     if (!parentNode() &amp;&amp; !hasEventListeners(subtreeModifiedEventName))
2373         return;
2374 
2375     dispatchScopedEvent(MutationEvent::create(subtreeModifiedEventName, Event::CanBubble::Yes));
2376 }
2377 
2378 void Node::dispatchDOMActivateEvent(Event&amp; underlyingClickEvent)
2379 {
2380     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2381     int detail = is&lt;UIEvent&gt;(underlyingClickEvent) ? downcast&lt;UIEvent&gt;(underlyingClickEvent).detail() : 0;
2382     auto event = UIEvent::create(eventNames().DOMActivateEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes, document().windowProxy(), detail);
2383     event-&gt;setUnderlyingEvent(&amp;underlyingClickEvent);
2384     dispatchScopedEvent(event);
2385     if (event-&gt;defaultHandled())
2386         underlyingClickEvent.setDefaultHandled();
2387 }
2388 
2389 bool Node::dispatchBeforeLoadEvent(const String&amp; sourceURL)
2390 {
2391     if (!document().hasListenerType(Document::BEFORELOAD_LISTENER))
2392         return true;
2393 
2394     Ref&lt;Node&gt; protectedThis(*this);
2395     auto event = BeforeLoadEvent::create(sourceURL);
2396     dispatchEvent(event);
2397     return !event-&gt;defaultPrevented();
2398 }
2399 
2400 void Node::dispatchInputEvent()
2401 {
2402     dispatchScopedEvent(Event::create(eventNames().inputEvent, Event::CanBubble::Yes, Event::IsCancelable::No, Event::IsComposed::Yes));
2403 }
2404 
2405 void Node::defaultEventHandler(Event&amp; event)
2406 {
2407     if (event.target() != this)
2408         return;
<span class="line-modified">2409     const AtomicString&amp; eventType = event.type();</span>
2410     if (eventType == eventNames().keydownEvent || eventType == eventNames().keypressEvent) {
2411         if (is&lt;KeyboardEvent&gt;(event)) {
2412             if (Frame* frame = document().frame())
2413                 frame-&gt;eventHandler().defaultKeyboardEventHandler(downcast&lt;KeyboardEvent&gt;(event));
2414         }
2415     } else if (eventType == eventNames().clickEvent) {
2416         dispatchDOMActivateEvent(event);
2417 #if ENABLE(CONTEXT_MENUS)
2418     } else if (eventType == eventNames().contextmenuEvent) {
2419         if (Frame* frame = document().frame())
2420             if (Page* page = frame-&gt;page())
2421                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2422 #endif
2423     } else if (eventType == eventNames().textInputEvent) {
2424         if (is&lt;TextEvent&gt;(event)) {
2425             if (Frame* frame = document().frame())
2426                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2427         }
2428 #if ENABLE(PAN_SCROLLING)
2429     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2430         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2431             if (enclosingLinkEventParentOrSelf())
2432                 return;
2433 
<span class="line-removed">2434             // Avoid that canBeScrolledAndHasScrollableArea changes render tree</span>
<span class="line-removed">2435             // structure.</span>
<span class="line-removed">2436             // FIXME: We should avoid synchronous layout if possible. We can</span>
<span class="line-removed">2437             // remove this synchronous layout if we avoid synchronous layout in</span>
<span class="line-removed">2438             // RenderTextControlSingleLine::scrollHeight</span>
<span class="line-removed">2439             document().updateLayoutIgnorePendingStylesheets();</span>
2440             RenderObject* renderer = this-&gt;renderer();
2441             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2442                 renderer = renderer-&gt;parent();
2443 
2444             if (renderer) {
2445                 if (Frame* frame = document().frame())
2446                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2447             }
2448         }
2449 #endif
2450     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2451         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2452         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2453         Node* startNode = this;
2454         while (startNode &amp;&amp; !startNode-&gt;renderer())
2455             startNode = startNode-&gt;parentOrShadowHostNode();
2456 
2457         if (startNode &amp;&amp; startNode-&gt;renderer())
2458             if (Frame* frame = document().frame())
2459                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
2460 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<span class="line-modified">2461     } else if (is&lt;TouchEvent&gt;(event) &amp;&amp; eventNames().isTouchEventType(eventType)) {</span>









2462         RenderObject* renderer = this-&gt;renderer();
2463         while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2464             renderer = renderer-&gt;parent();
2465 
2466         if (renderer &amp;&amp; renderer-&gt;node()) {
2467             if (Frame* frame = document().frame())
2468                 frame-&gt;eventHandler().defaultTouchEventHandler(*renderer-&gt;node(), downcast&lt;TouchEvent&gt;(event));
2469         }
2470 #endif
2471     }
2472 }
2473 
2474 bool Node::willRespondToMouseMoveEvents()
2475 {
2476     // FIXME: Why is the iOS code path different from the non-iOS code path?
2477 #if !PLATFORM(IOS_FAMILY)
2478     if (!is&lt;Element&gt;(*this))
2479         return false;
2480     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2481         return false;
</pre>
<hr />
<pre>
2490     return isContentEditable() || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent);
2491 #else
2492     if (!is&lt;Element&gt;(*this))
2493         return false;
2494     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2495         return false;
2496     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly
2497         || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent) || hasEventListeners(eventNames().DOMActivateEvent);
2498 #endif
2499 }
2500 
2501 bool Node::willRespondToMouseWheelEvents()
2502 {
2503     return hasEventListeners(eventNames().mousewheelEvent);
2504 }
2505 
2506 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2507 // delete a Node at each deref call site.
2508 void Node::removedLastRef()
2509 {


2510     // An explicit check for Document here is better than a virtual function since it is
2511     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2512     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2513     if (is&lt;Document&gt;(*this)) {
2514         downcast&lt;Document&gt;(*this).removedLastRef();
2515         return;
2516     }
2517 






2518 #ifndef NDEBUG
2519     m_deletionHasBegun = true;
2520 #endif
<span class="line-removed">2521     m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
2522     delete this;
2523 }
2524 
2525 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2526 {
2527     auto range = Range::create(document());
2528     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2529     range-&gt;absoluteTextRects(rects);
2530 }
2531 
2532 unsigned Node::connectedSubframeCount() const
2533 {
2534     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2535 }
2536 
2537 void Node::incrementConnectedSubframeCount(unsigned amount)
2538 {
2539     ASSERT(isContainerNode());
2540     ensureRareData().incrementConnectedSubframeCount(amount);
2541 }
2542 
2543 void Node::decrementConnectedSubframeCount(unsigned amount)
2544 {



2545     rareData()-&gt;decrementConnectedSubframeCount(amount);
2546 }
2547 
2548 void Node::updateAncestorConnectedSubframeCountForRemoval() const
2549 {
2550     unsigned count = connectedSubframeCount();
2551 
2552     if (!count)
2553         return;
2554 
2555     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2556         node-&gt;decrementConnectedSubframeCount(count);
2557 }
2558 
2559 void Node::updateAncestorConnectedSubframeCountForInsertion() const
2560 {
2561     unsigned count = connectedSubframeCount();
2562 
2563     if (!count)
2564         return;
</pre>
</td>
<td>
<hr />
<pre>
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Node.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;Attr.h&quot;
  30 #include &quot;BeforeLoadEvent.h&quot;
  31 #include &quot;ChildListMutationScope.h&quot;
  32 #include &quot;CommonVM.h&quot;
  33 #include &quot;ComposedTreeAncestorIterator.h&quot;
  34 #include &quot;ContainerNodeAlgorithms.h&quot;
<span class="line-added">  35 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">  36 #include &quot;ContentChangeObserver.h&quot;</span>
<span class="line-added">  37 #endif</span>
  38 #include &quot;ContextMenuController.h&quot;
  39 #include &quot;DOMWindow.h&quot;
  40 #include &quot;DataTransfer.h&quot;
  41 #include &quot;DocumentType.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;ElementRareData.h&quot;
  44 #include &quot;ElementTraversal.h&quot;
  45 #include &quot;EventDispatcher.h&quot;
  46 #include &quot;EventHandler.h&quot;
  47 #include &quot;FrameView.h&quot;
<span class="line-added">  48 #include &quot;HTMLAreaElement.h&quot;</span>
  49 #include &quot;HTMLBodyElement.h&quot;
  50 #include &quot;HTMLCollection.h&quot;
  51 #include &quot;HTMLElement.h&quot;
  52 #include &quot;HTMLImageElement.h&quot;
  53 #include &quot;HTMLSlotElement.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;InputEvent.h&quot;
  56 #include &quot;InspectorController.h&quot;
  57 #include &quot;KeyboardEvent.h&quot;
  58 #include &quot;Logging.h&quot;
  59 #include &quot;MutationEvent.h&quot;
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;ProcessingInstruction.h&quot;
  62 #include &quot;ProgressEvent.h&quot;
  63 #include &quot;Range.h&quot;
  64 #include &quot;RenderBlock.h&quot;
  65 #include &quot;RenderBox.h&quot;
  66 #include &quot;RenderTextControl.h&quot;
  67 #include &quot;RenderView.h&quot;
<span class="line-added">  68 #include &quot;SVGElement.h&quot;</span>
  69 #include &quot;ScopedEventQueue.h&quot;
  70 #include &quot;ScriptDisallowedScope.h&quot;
  71 #include &quot;StorageEvent.h&quot;
  72 #include &quot;StyleResolver.h&quot;
  73 #include &quot;StyleSheetContents.h&quot;
  74 #include &quot;TemplateContentDocumentFragment.h&quot;
  75 #include &quot;TextEvent.h&quot;
  76 #include &quot;TouchEvent.h&quot;
  77 #include &quot;WheelEvent.h&quot;
  78 #include &quot;XMLNSNames.h&quot;
  79 #include &quot;XMLNames.h&quot;
  80 #include &lt;wtf/IsoMallocInlines.h&gt;
  81 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  82 #include &lt;wtf/SHA1.h&gt;
  83 #include &lt;wtf/Variant.h&gt;
  84 #include &lt;wtf/text/CString.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 
  87 namespace WebCore {
  88 
</pre>
<hr />
<pre>
  91 using namespace HTMLNames;
  92 
  93 #if DUMP_NODE_STATISTICS
  94 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  95 {
  96     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  97     return liveNodes;
  98 }
  99 
 100 static const char* stringForRareDataUseType(NodeRareData::UseType useType)
 101 {
 102     switch (useType) {
 103     case NodeRareData::UseType::ConnectedFrameCount:
 104         return &quot;ConnectedFrameCount&quot;;
 105     case NodeRareData::UseType::NodeList:
 106         return &quot;NodeList&quot;;
 107     case NodeRareData::UseType::MutationObserver:
 108         return &quot;MutationObserver&quot;;
 109     case NodeRareData::UseType::TabIndex:
 110         return &quot;TabIndex&quot;;


 111     case NodeRareData::UseType::MinimumSize:
 112         return &quot;MinimumSize&quot;;
 113     case NodeRareData::UseType::ScrollingPosition:
 114         return &quot;ScrollingPosition&quot;;
 115     case NodeRareData::UseType::ComputedStyle:
 116         return &quot;ComputedStyle&quot;;
 117     case NodeRareData::UseType::Dataset:
 118         return &quot;Dataset&quot;;
 119     case NodeRareData::UseType::ClassList:
 120         return &quot;ClassList&quot;;
 121     case NodeRareData::UseType::ShadowRoot:
 122         return &quot;ShadowRoot&quot;;
 123     case NodeRareData::UseType::CustomElementQueue:
 124         return &quot;CustomElementQueue&quot;;
 125     case NodeRareData::UseType::AttributeMap:
 126         return &quot;AttributeMap&quot;;
 127     case NodeRareData::UseType::InteractionObserver:
 128         return &quot;InteractionObserver&quot;;
 129     case NodeRareData::UseType::PseudoElements:
 130         return &quot;PseudoElements&quot;;
</pre>
<hr />
<pre>
 302 #ifndef NDEBUG
 303     shouldIgnoreLeaks = false;
 304 #endif
 305 }
 306 
 307 void Node::trackForDebugging()
 308 {
 309 #ifndef NDEBUG
 310     if (shouldIgnoreLeaks)
 311         ignoreSet().add(this);
 312     else
 313         nodeCounter.increment();
 314 #endif
 315 
 316 #if DUMP_NODE_STATISTICS
 317     liveNodeSet().add(this);
 318 #endif
 319 }
 320 
 321 Node::Node(Document&amp; document, ConstructionType type)
<span class="line-modified"> 322     : m_nodeFlags(type)</span>

 323     , m_treeScope(&amp;document)
 324 {
 325     ASSERT(isMainThread());
 326 
 327     document.incrementReferencingNodeCount();
 328 
 329 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS)
 330     trackForDebugging();
 331 #endif
 332 }
 333 
 334 Node::~Node()
 335 {
 336     ASSERT(isMainThread());
<span class="line-modified"> 337     ASSERT(m_refCountAndParentBit == s_refCountIncrement);</span>


 338     ASSERT(m_deletionHasBegun);
 339     ASSERT(!m_adoptionIsRequired);
 340 
 341 #ifndef NDEBUG
 342     if (!ignoreSet().remove(this))
 343         nodeCounter.decrement();
 344 #endif
 345 
 346 #if DUMP_NODE_STATISTICS
 347     liveNodeSet().remove(this);
 348 #endif
 349 
 350     RELEASE_ASSERT(!renderer());
 351     ASSERT(!parentNode());
 352     ASSERT(!m_previous);
 353     ASSERT(!m_next);
 354 
 355     if (hasRareData())
 356         clearRareData();
 357 
</pre>
<hr />
<pre>
 377     if (hasEventTargetData()) {
 378         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 379 #if ENABLE(TOUCH_EVENTS)
 380 #if PLATFORM(IOS_FAMILY)
 381         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 382 #endif
 383         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 384 #endif
 385     }
 386 
 387 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
 388     document.removeTouchEventHandler(*this, EventHandlerRemoval::All);
 389 #endif
 390 
 391     if (auto* cache = document.existingAXObjectCache())
 392         cache-&gt;remove(*this);
 393 }
 394 
 395 void Node::materializeRareData()
 396 {

 397     if (is&lt;Element&gt;(*this))
<span class="line-modified"> 398         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new ElementRareData);</span>
 399     else
<span class="line-modified"> 400         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new NodeRareData);</span>
<span class="line-modified"> 401 }</span>
 402 
<span class="line-modified"> 403 inline void Node::NodeRareDataDeleter::operator()(NodeRareData* rareData) const</span>
<span class="line-modified"> 404 {</span>
<span class="line-added"> 405     if (rareData-&gt;isElementRareData())</span>
<span class="line-added"> 406         delete static_cast&lt;ElementRareData*&gt;(rareData);</span>
<span class="line-added"> 407     else</span>
<span class="line-added"> 408         delete static_cast&lt;NodeRareData*&gt;(rareData);</span>
 409 }
 410 
 411 void Node::clearRareData()
 412 {
 413     ASSERT(hasRareData());
 414     ASSERT(!transientMutationObserverRegistry() || transientMutationObserverRegistry()-&gt;isEmpty());
 415 
<span class="line-modified"> 416     m_rareData = nullptr;</span>






 417 }
 418 
 419 bool Node::isNode() const
 420 {
 421     return true;
 422 }
 423 
 424 String Node::nodeValue() const
 425 {
 426     return String();
 427 }
 428 
 429 ExceptionOr&lt;void&gt; Node::setNodeValue(const String&amp;)
 430 {
 431     // By default, setting nodeValue has no effect.
 432     return { };
 433 }
 434 
 435 RefPtr&lt;NodeList&gt; Node::childNodes()
 436 {
</pre>
<hr />
<pre>
 668             }
 669 
 670             // Both non-empty text nodes. Merge them.
 671             unsigned offset = text-&gt;length();
 672             text-&gt;appendData(nextText-&gt;data());
 673             document().textNodesMerged(nextText, offset);
 674             nextText-&gt;remove();
 675         }
 676 
 677         node = NodeTraversal::nextPostOrder(*node);
 678     }
 679 }
 680 
 681 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 682 {
 683     if (UNLIKELY(isShadowRoot()))
 684         return Exception { NotSupportedError };
 685     return cloneNode(deep);
 686 }
 687 
<span class="line-modified"> 688 const AtomString&amp; Node::prefix() const</span>
 689 {
 690     // For nodes other than elements and attributes, the prefix is always null
 691     return nullAtom();
 692 }
 693 
<span class="line-modified"> 694 ExceptionOr&lt;void&gt; Node::setPrefix(const AtomString&amp;)</span>
 695 {
 696     // The spec says that for nodes other than elements and attributes, prefix is always null.
 697     // It does not say what to do when the user tries to set the prefix on another type of
 698     // node, however Mozilla throws a NamespaceError exception.
 699     return Exception { NamespaceError };
 700 }
 701 
<span class="line-modified"> 702 const AtomString&amp; Node::localName() const</span>
 703 {
 704     return nullAtom();
 705 }
 706 
<span class="line-modified"> 707 const AtomString&amp; Node::namespaceURI() const</span>
 708 {
 709     return nullAtom();
 710 }
 711 
 712 bool Node::isContentEditable()
 713 {
 714     return computeEditability(UserSelectAllDoesNotAffectEditability, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 715 }
 716 
 717 bool Node::isContentRichlyEditable()
 718 {
 719     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) == Editability::CanEditRichly;
 720 }
 721 
 722 void Node::inspect()
 723 {
 724     if (document().page())
 725         document().page()-&gt;inspectorController().inspect(this);
 726 }
 727 
</pre>
<hr />
<pre>
 776         document().updateStyleIfNeeded();
 777     }
 778     return computeEditabilityFromComputedStyle(*this, treatment);
 779 }
 780 
 781 RenderBox* Node::renderBox() const
 782 {
 783     RenderObject* renderer = this-&gt;renderer();
 784     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 785 }
 786 
 787 RenderBoxModelObject* Node::renderBoxModelObject() const
 788 {
 789     RenderObject* renderer = this-&gt;renderer();
 790     return is&lt;RenderBoxModelObject&gt;(renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;
 791 }
 792 
 793 LayoutRect Node::renderRect(bool* isReplaced)
 794 {
 795     RenderObject* hitRenderer = this-&gt;renderer();
<span class="line-modified"> 796     if (!hitRenderer &amp;&amp; is&lt;HTMLAreaElement&gt;(*this)) {</span>
<span class="line-added"> 797         auto&amp; area = downcast&lt;HTMLAreaElement&gt;(*this);</span>
<span class="line-added"> 798         if (auto* imageElement = area.imageElement())</span>
<span class="line-added"> 799             hitRenderer = imageElement-&gt;renderer();</span>
<span class="line-added"> 800     }</span>
 801     RenderObject* renderer = hitRenderer;
 802     while (renderer &amp;&amp; !renderer-&gt;isBody() &amp;&amp; !renderer-&gt;isDocumentElementRenderer()) {
 803         if (renderer-&gt;isRenderBlock() || renderer-&gt;isInlineBlockOrInlineTable() || renderer-&gt;isReplaced()) {
 804             *isReplaced = renderer-&gt;isReplaced();
 805             return renderer-&gt;absoluteBoundingBoxRect();
 806         }
 807         renderer = renderer-&gt;parent();
 808     }
 809     return LayoutRect();
 810 }
 811 
 812 void Node::refEventTarget()
 813 {
 814     ref();
 815 }
 816 
 817 void Node::derefEventTarget()
 818 {
 819     deref();
 820 }
</pre>
<hr />
<pre>
 957 
 958     for (auto* node = this; node; node = node-&gt;parentNode()) {
 959         if (!node-&gt;hasRareData())
 960             continue;
 961 
 962         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 963             lists-&gt;invalidateCachesForAttribute(attrName);
 964     }
 965 }
 966 
 967 NodeListsNodeData* Node::nodeLists()
 968 {
 969     return hasRareData() ? rareData()-&gt;nodeLists() : nullptr;
 970 }
 971 
 972 void Node::clearNodeLists()
 973 {
 974     rareData()-&gt;clearNodeLists();
 975 }
 976 
<span class="line-modified"> 977 ExceptionOr&lt;void&gt; Node::checkSetPrefix(const AtomString&amp; prefix)</span>
 978 {
 979     // Perform error checking as required by spec for setting Node.prefix. Used by
 980     // Element::setPrefix() and Attr::setPrefix()
 981 
 982     if (!prefix.isEmpty() &amp;&amp; !Document::isValidName(prefix))
 983         return Exception { InvalidCharacterError };
 984 
 985     // FIXME: Raise NamespaceError if prefix is malformed per the Namespaces in XML specification.
 986 
 987     auto&amp; namespaceURI = this-&gt;namespaceURI();
 988     if (namespaceURI.isEmpty() &amp;&amp; !prefix.isEmpty())
 989         return Exception { NamespaceError };
 990     if (prefix == xmlAtom() &amp;&amp; namespaceURI != XMLNames::xmlNamespaceURI)
 991         return Exception { NamespaceError };
 992 
 993     // Attribute-specific checks are in Attr::setPrefix().
 994 
 995     return { };
 996 }
 997 
</pre>
<hr />
<pre>
1392     }
1393 
1394     Node* child = firstChild();
1395     Node* otherChild = other-&gt;firstChild();
1396 
1397     while (child) {
1398         if (!child-&gt;isEqualNode(otherChild))
1399             return false;
1400 
1401         child = child-&gt;nextSibling();
1402         otherChild = otherChild-&gt;nextSibling();
1403     }
1404 
1405     if (otherChild)
1406         return false;
1407 
1408     return true;
1409 }
1410 
1411 // https://dom.spec.whatwg.org/#locate-a-namespace
<span class="line-modified">1412 static const AtomString&amp; locateDefaultNamespace(const Node&amp; node, const AtomString&amp; prefix)</span>
1413 {
1414     switch (node.nodeType()) {
1415     case Node::ELEMENT_NODE: {
1416         auto&amp; element = downcast&lt;Element&gt;(node);
1417         auto&amp; namespaceURI = element.namespaceURI();
1418         if (!namespaceURI.isNull() &amp;&amp; element.prefix() == prefix)
1419             return namespaceURI;
1420 
1421         if (element.hasAttributes()) {
1422             for (auto&amp; attribute : element.attributesIterator()) {
1423                 if (attribute.namespaceURI() != XMLNSNames::xmlnsNamespaceURI)
1424                     continue;
1425 
1426                 if ((prefix.isNull() &amp;&amp; attribute.prefix().isNull() &amp;&amp; attribute.localName() == xmlnsAtom()) || (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.localName() == prefix)) {
1427                     auto&amp; result = attribute.value();
1428                     return result.isEmpty() ? nullAtom() : result;
1429                 }
1430             }
1431         }
1432         auto* parent = node.parentElement();
</pre>
<hr />
<pre>
1434     }
1435     case Node::DOCUMENT_NODE:
1436         if (auto* documentElement = downcast&lt;Document&gt;(node).documentElement())
1437             return locateDefaultNamespace(*documentElement, prefix);
1438         return nullAtom();
1439     case Node::DOCUMENT_TYPE_NODE:
1440     case Node::DOCUMENT_FRAGMENT_NODE:
1441         return nullAtom();
1442     case Node::ATTRIBUTE_NODE:
1443         if (auto* ownerElement = downcast&lt;Attr&gt;(node).ownerElement())
1444             return locateDefaultNamespace(*ownerElement, prefix);
1445         return nullAtom();
1446     default:
1447         if (auto* parent = node.parentElement())
1448             return locateDefaultNamespace(*parent, prefix);
1449         return nullAtom();
1450     }
1451 }
1452 
1453 // https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
<span class="line-modified">1454 bool Node::isDefaultNamespace(const AtomString&amp; potentiallyEmptyNamespace) const</span>
1455 {
<span class="line-modified">1456     const AtomString&amp; namespaceURI = potentiallyEmptyNamespace.isEmpty() ? nullAtom() : potentiallyEmptyNamespace;</span>
1457     return locateDefaultNamespace(*this, nullAtom()) == namespaceURI;
1458 }
1459 
1460 // https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
<span class="line-modified">1461 const AtomString&amp; Node::lookupNamespaceURI(const AtomString&amp; potentiallyEmptyPrefix) const</span>
1462 {
<span class="line-modified">1463     const AtomString&amp; prefix = potentiallyEmptyPrefix.isEmpty() ? nullAtom() : potentiallyEmptyPrefix;</span>
1464     return locateDefaultNamespace(*this, prefix);
1465 }
1466 
1467 // https://dom.spec.whatwg.org/#locate-a-namespace-prefix
<span class="line-modified">1468 static const AtomString&amp; locateNamespacePrefix(const Element&amp; element, const AtomString&amp; namespaceURI)</span>
1469 {
1470     if (element.namespaceURI() == namespaceURI)
1471         return element.prefix();
1472 
1473     if (element.hasAttributes()) {
1474         for (auto&amp; attribute : element.attributesIterator()) {
1475             if (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.value() == namespaceURI)
1476                 return attribute.localName();
1477         }
1478     }
1479     auto* parent = element.parentElement();
1480     return parent ? locateNamespacePrefix(*parent, namespaceURI) : nullAtom();
1481 }
1482 
1483 // https://dom.spec.whatwg.org/#dom-node-lookupprefix
<span class="line-modified">1484 const AtomString&amp; Node::lookupPrefix(const AtomString&amp; namespaceURI) const</span>
1485 {
1486     if (namespaceURI.isEmpty())
1487         return nullAtom();
1488 
1489     switch (nodeType()) {
1490     case ELEMENT_NODE:
1491         return locateNamespacePrefix(downcast&lt;Element&gt;(*this), namespaceURI);
1492     case DOCUMENT_NODE:
1493         if (auto* documentElement = downcast&lt;Document&gt;(*this).documentElement())
1494             return locateNamespacePrefix(*documentElement, namespaceURI);
1495         return nullAtom();
1496     case DOCUMENT_FRAGMENT_NODE:
1497     case DOCUMENT_TYPE_NODE:
1498         return nullAtom();
1499     case ATTRIBUTE_NODE:
1500         if (auto* ownerElement = downcast&lt;Attr&gt;(*this).ownerElement())
1501             return locateNamespacePrefix(*ownerElement, namespaceURI);
1502         return nullAtom();
1503     default:
1504         if (auto* parent = parentElement())
</pre>
<hr />
<pre>
1722 {
1723     // If there is a renderer, just ask it to do the conversion
1724     if (renderer())
1725         return renderer()-&gt;absoluteToLocal(p, UseTransforms);
1726 
1727     // Otherwise go up the tree looking for a renderer
1728     if (auto* parent = parentElement())
1729         return parent-&gt;convertFromPage(p);
1730 
1731     // No parent - no conversion needed
1732     return p;
1733 }
1734 
1735 #if ENABLE(TREE_DEBUGGING)
1736 
1737 static void appendAttributeDesc(const Node* node, StringBuilder&amp; stringBuilder, const QualifiedName&amp; name, const char* attrDesc)
1738 {
1739     if (!is&lt;Element&gt;(*node))
1740         return;
1741 
<span class="line-modified">1742     const AtomString&amp; attr = downcast&lt;Element&gt;(*node).getAttribute(name);</span>
1743     if (attr.isEmpty())
1744         return;
1745 
1746     stringBuilder.append(attrDesc);
1747     stringBuilder.append(attr);
1748 }
1749 
1750 void Node::showNode(const char* prefix) const
1751 {
1752     if (!prefix)
1753         prefix = &quot;&quot;;
1754     if (isTextNode()) {
1755         String value = nodeValue();
1756         value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1757         value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1758         fprintf(stderr, &quot;%s%s\t%p \&quot;%s\&quot;\n&quot;, prefix, nodeName().utf8().data(), this, value.utf8().data());
1759     } else {
1760         StringBuilder attrs;
1761         appendAttributeDesc(this, attrs, classAttr, &quot; CLASS=&quot;);
1762         appendAttributeDesc(this, attrs, styleAttr, &quot; STYLE=&quot;);
</pre>
<hr />
<pre>
1775     const Node* node = this;
1776     while (node-&gt;parentOrShadowHostNode()) {
1777         chain.append(node);
1778         node = node-&gt;parentOrShadowHostNode();
1779     }
1780     for (unsigned index = chain.size(); index &gt; 0; --index) {
1781         const Node* node = chain[index - 1];
1782         if (is&lt;ShadowRoot&gt;(*node)) {
1783             int count = 0;
1784             for (const ShadowRoot* shadowRoot = downcast&lt;ShadowRoot&gt;(node); shadowRoot &amp;&amp; shadowRoot != node; shadowRoot = shadowRoot-&gt;shadowRoot())
1785                 ++count;
1786             fprintf(stderr, &quot;/#shadow-root[%d]&quot;, count);
1787             continue;
1788         }
1789 
1790         switch (node-&gt;nodeType()) {
1791         case ELEMENT_NODE: {
1792             fprintf(stderr, &quot;/%s&quot;, node-&gt;nodeName().utf8().data());
1793 
1794             const Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1795             const AtomString&amp; idattr = element.getIdAttribute();</span>
1796             bool hasIdAttr = !idattr.isNull() &amp;&amp; !idattr.isEmpty();
1797             if (node-&gt;previousSibling() || node-&gt;nextSibling()) {
1798                 int count = 0;
1799                 for (Node* previous = node-&gt;previousSibling(); previous; previous = previous-&gt;previousSibling())
1800                     if (previous-&gt;nodeName() == node-&gt;nodeName())
1801                         ++count;
1802                 if (hasIdAttr)
1803                     fprintf(stderr, &quot;[@id=\&quot;%s\&quot; and position()=%d]&quot;, idattr.string().utf8().data(), count);
1804                 else
1805                     fprintf(stderr, &quot;[%d]&quot;, count);
1806             } else if (hasIdAttr)
1807                 fprintf(stderr, &quot;[@id=\&quot;%s\&quot;]&quot;, idattr.string().utf8().data());
1808             break;
1809         }
1810         case TEXT_NODE:
1811             fprintf(stderr, &quot;/text()&quot;);
1812             break;
1813         case ATTRIBUTE_NODE:
1814             fprintf(stderr, &quot;/@%s&quot;, node-&gt;nodeName().utf8().data());
1815             break;
</pre>
<hr />
<pre>
2038     oldDocument.moveNodeIteratorsToNewDocument(*this, newDocument);
2039 
2040     if (AXObjectCache::accessibilityEnabled()) {
2041         if (auto* cache = oldDocument.existingAXObjectCache())
2042             cache-&gt;remove(*this);
2043     }
2044 
2045     if (auto* eventTargetData = this-&gt;eventTargetData()) {
2046         if (!eventTargetData-&gt;eventListenerMap.isEmpty()) {
2047             for (auto&amp; type : eventTargetData-&gt;eventListenerMap.eventTypes())
2048                 newDocument.addListenerTypeIfNeeded(type);
2049         }
2050 
2051         unsigned numWheelEventHandlers = eventListeners(eventNames().mousewheelEvent).size() + eventListeners(eventNames().wheelEvent).size();
2052         for (unsigned i = 0; i &lt; numWheelEventHandlers; ++i) {
2053             oldDocument.didRemoveWheelEventHandler(*this);
2054             newDocument.didAddWheelEventHandler(*this);
2055         }
2056 
2057         unsigned numTouchEventListeners = 0;
<span class="line-modified">2058 #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-modified">2059         if (newDocument.quirks().shouldDispatchSimulatedMouseEvents()) {</span>
<span class="line-added">2060             for (auto&amp; name : eventNames().extendedTouchRelatedEventNames())</span>
<span class="line-added">2061                 numTouchEventListeners += eventListeners(name).size();</span>
<span class="line-added">2062         } else {</span>
<span class="line-added">2063 #endif</span>
<span class="line-added">2064             for (auto&amp; name : eventNames().touchRelatedEventNames())</span>
<span class="line-added">2065                 numTouchEventListeners += eventListeners(name).size();</span>
<span class="line-added">2066 #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-added">2067         }</span>
<span class="line-added">2068 #endif</span>
2069 
2070         for (unsigned i = 0; i &lt; numTouchEventListeners; ++i) {
2071             oldDocument.didRemoveTouchEventHandler(*this);
2072             newDocument.didAddTouchEventHandler(*this);
2073 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2074             oldDocument.removeTouchEventListener(*this);
2075             newDocument.addTouchEventListener(*this);
2076 #endif
2077         }
2078 
2079 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2080         unsigned numGestureEventListeners = 0;
2081         for (auto&amp; name : eventNames().gestureEventNames())
2082             numGestureEventListeners += eventListeners(name).size();
2083 
2084         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2085             oldDocument.removeTouchEventHandler(*this);
2086             newDocument.addTouchEventHandler(*this);
2087         }
2088 #endif
2089     }
2090 
2091 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
2092 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2093     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2094     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2095 #endif
2096 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2097     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2098 #endif
2099 #endif
2100 
2101     if (is&lt;Element&gt;(*this))
2102         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2103 }
2104 
<span class="line-modified">2105 static inline bool tryAddEventListener(Node* targetNode, const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)</span>
2106 {
2107     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2108         return false;
2109 
2110     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2111     if (eventNames().isWheelEventType(eventType))
2112         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
<span class="line-modified">2113     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))</span>
2114         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2115 
2116 #if PLATFORM(IOS_FAMILY)
2117     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2118         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();
2119 







2120 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified">2121     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))</span>
2122         targetNode-&gt;document().addTouchEventListener(*targetNode);
2123 #endif
2124 #endif // PLATFORM(IOS_FAMILY)
2125 
2126 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2127     if (eventNames().isGestureEventType(eventType))
2128         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2129 #endif
2130 
2131     return true;
2132 }
2133 
<span class="line-modified">2134 bool Node::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
2135 {
2136     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2137 }
2138 
<span class="line-modified">2139 static inline bool tryRemoveEventListener(Node* targetNode, const AtomString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)</span>
2140 {
2141     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2142         return false;
2143 
2144     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2145     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2146     if (eventNames().isWheelEventType(eventType))
2147         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
<span class="line-modified">2148     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))</span>
2149         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2150 
2151 #if PLATFORM(IOS_FAMILY)
2152     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2153         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();
2154 






2155 #if ENABLE(TOUCH_EVENTS)
<span class="line-modified">2156     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))</span>
2157         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2158 #endif
2159 #endif // PLATFORM(IOS_FAMILY)
2160 
2161 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2162     if (eventNames().isGestureEventType(eventType))
2163         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2164 #endif
2165 
2166     return true;
2167 }
2168 
<span class="line-modified">2169 bool Node::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
2170 {
2171     return tryRemoveEventListener(this, eventType, listener, options);
2172 }
2173 
2174 typedef HashMap&lt;Node*, std::unique_ptr&lt;EventTargetData&gt;&gt; EventTargetDataMap;
2175 
2176 static EventTargetDataMap&amp; eventTargetDataMap()
2177 {
2178     static NeverDestroyed&lt;EventTargetDataMap&gt; map;
2179 
2180     return map;
2181 }
2182 
2183 static Lock s_eventTargetDataMapLock;
2184 
2185 EventTargetData* Node::eventTargetData()
2186 {
2187     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2188 }
2189 
</pre>
<hr />
<pre>
2193     // calls this function from many threads. Parallel constraint solving can happen with the world
2194     // running or stopped, but if we do it with a running world, then we&#39;re usually mixing constraint
2195     // solving with other work. Therefore, the most likely time for contention on this lock is when the
2196     // world is stopped. We don&#39;t have to hold the lock when the world is stopped, because a stopped world
2197     // means that we will never mutate the event target data map.
2198     JSC::VM* vm = commonVMOrNull();
2199     auto locker = holdLockIf(s_eventTargetDataMapLock, vm &amp;&amp; vm-&gt;heap.worldIsRunning());
2200     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2201 }
2202 
2203 EventTargetData&amp; Node::ensureEventTargetData()
2204 {
2205     if (hasEventTargetData())
2206         return *eventTargetDataMap().get(this);
2207 
2208     JSC::VM* vm = commonVMOrNull();
2209     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2210 
2211     auto locker = holdLock(s_eventTargetDataMapLock);
2212     setHasEventTargetData(true);
<span class="line-modified">2213     return *eventTargetDataMap().add(this, makeUnique&lt;EventTargetData&gt;()).iterator-&gt;value;</span>
2214 }
2215 
2216 void Node::clearEventTargetData()
2217 {
2218     JSC::VM* vm = commonVMOrNull();
2219     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2220     auto locker = holdLock(s_eventTargetDataMapLock);
2221     eventTargetDataMap().remove(this);
2222 }
2223 
2224 Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* Node::mutationObserverRegistry()
2225 {
2226     if (!hasRareData())
2227         return nullptr;
2228     auto* data = rareData()-&gt;mutationObserverData();
2229     if (!data)
2230         return nullptr;
2231     return &amp;data-&gt;registry;
2232 }
2233 
</pre>
<hr />
<pre>
2252             auto result = observers.add(registration-&gt;observer(), deliveryOptions);
2253             if (!result.isNewEntry)
2254                 result.iterator-&gt;value |= deliveryOptions;
2255         }
2256     }
2257 }
2258 
2259 HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; Node::registeredMutationObservers(MutationObserver::MutationType type, const QualifiedName* attributeName)
2260 {
2261     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; result;
2262     ASSERT((type == MutationObserver::Attributes &amp;&amp; attributeName) || !attributeName);
2263     collectMatchingObserversForMutation(result, mutationObserverRegistry(), *this, type, attributeName);
2264     collectMatchingObserversForMutation(result, transientMutationObserverRegistry(), *this, type, attributeName);
2265     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2266         collectMatchingObserversForMutation(result, node-&gt;mutationObserverRegistry(), *this, type, attributeName);
2267         collectMatchingObserversForMutation(result, node-&gt;transientMutationObserverRegistry(), *this, type, attributeName);
2268     }
2269     return result;
2270 }
2271 
<span class="line-modified">2272 void Node::registerMutationObserver(MutationObserver&amp; observer, MutationObserverOptions options, const HashSet&lt;AtomString&gt;&amp; attributeFilter)</span>
2273 {
2274     MutationObserverRegistration* registration = nullptr;
2275     auto&amp; registry = ensureRareData().ensureMutationObserverData().registry;
2276 
2277     for (auto&amp; candidateRegistration : registry) {
2278         if (&amp;candidateRegistration-&gt;observer() == &amp;observer) {
2279             registration = candidateRegistration.get();
2280             registration-&gt;resetObservation(options, attributeFilter);
2281         }
2282     }
2283 
2284     if (!registration) {
<span class="line-modified">2285         registry.append(makeUnique&lt;MutationObserverRegistration&gt;(observer, *this, options, attributeFilter));</span>
2286         registration = registry.last().get();
2287     }
2288 
2289     document().addMutationObserverTypes(registration-&gt;mutationTypes());
2290 }
2291 
2292 void Node::unregisterMutationObserver(MutationObserverRegistration&amp; registration)
2293 {
2294     auto* registry = mutationObserverRegistry();
2295     ASSERT(registry);
2296     if (!registry)
2297         return;
2298 
2299     registry-&gt;removeFirstMatching([&amp;registration] (auto&amp; current) {
2300         return current.get() == &amp;registration;
2301     });
2302 }
2303 
2304 void Node::registerTransientMutationObserver(MutationObserverRegistration&amp; registration)
2305 {
</pre>
<hr />
<pre>
2348 
2349 void Node::dispatchScopedEvent(Event&amp; event)
2350 {
2351     EventDispatcher::dispatchScopedEvent(*this, event);
2352 }
2353 
2354 void Node::dispatchEvent(Event&amp; event)
2355 {
2356     EventDispatcher::dispatchEvent(*this, event);
2357 }
2358 
2359 void Node::dispatchSubtreeModifiedEvent()
2360 {
2361     if (isInShadowTree())
2362         return;
2363 
2364     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(*this));
2365 
2366     if (!document().hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER))
2367         return;
<span class="line-modified">2368     const AtomString&amp; subtreeModifiedEventName = eventNames().DOMSubtreeModifiedEvent;</span>
2369     if (!parentNode() &amp;&amp; !hasEventListeners(subtreeModifiedEventName))
2370         return;
2371 
2372     dispatchScopedEvent(MutationEvent::create(subtreeModifiedEventName, Event::CanBubble::Yes));
2373 }
2374 
2375 void Node::dispatchDOMActivateEvent(Event&amp; underlyingClickEvent)
2376 {
2377     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2378     int detail = is&lt;UIEvent&gt;(underlyingClickEvent) ? downcast&lt;UIEvent&gt;(underlyingClickEvent).detail() : 0;
2379     auto event = UIEvent::create(eventNames().DOMActivateEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes, document().windowProxy(), detail);
2380     event-&gt;setUnderlyingEvent(&amp;underlyingClickEvent);
2381     dispatchScopedEvent(event);
2382     if (event-&gt;defaultHandled())
2383         underlyingClickEvent.setDefaultHandled();
2384 }
2385 
2386 bool Node::dispatchBeforeLoadEvent(const String&amp; sourceURL)
2387 {
2388     if (!document().hasListenerType(Document::BEFORELOAD_LISTENER))
2389         return true;
2390 
2391     Ref&lt;Node&gt; protectedThis(*this);
2392     auto event = BeforeLoadEvent::create(sourceURL);
2393     dispatchEvent(event);
2394     return !event-&gt;defaultPrevented();
2395 }
2396 
2397 void Node::dispatchInputEvent()
2398 {
2399     dispatchScopedEvent(Event::create(eventNames().inputEvent, Event::CanBubble::Yes, Event::IsCancelable::No, Event::IsComposed::Yes));
2400 }
2401 
2402 void Node::defaultEventHandler(Event&amp; event)
2403 {
2404     if (event.target() != this)
2405         return;
<span class="line-modified">2406     const AtomString&amp; eventType = event.type();</span>
2407     if (eventType == eventNames().keydownEvent || eventType == eventNames().keypressEvent) {
2408         if (is&lt;KeyboardEvent&gt;(event)) {
2409             if (Frame* frame = document().frame())
2410                 frame-&gt;eventHandler().defaultKeyboardEventHandler(downcast&lt;KeyboardEvent&gt;(event));
2411         }
2412     } else if (eventType == eventNames().clickEvent) {
2413         dispatchDOMActivateEvent(event);
2414 #if ENABLE(CONTEXT_MENUS)
2415     } else if (eventType == eventNames().contextmenuEvent) {
2416         if (Frame* frame = document().frame())
2417             if (Page* page = frame-&gt;page())
2418                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2419 #endif
2420     } else if (eventType == eventNames().textInputEvent) {
2421         if (is&lt;TextEvent&gt;(event)) {
2422             if (Frame* frame = document().frame())
2423                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2424         }
2425 #if ENABLE(PAN_SCROLLING)
2426     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2427         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2428             if (enclosingLinkEventParentOrSelf())
2429                 return;
2430 






2431             RenderObject* renderer = this-&gt;renderer();
2432             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2433                 renderer = renderer-&gt;parent();
2434 
2435             if (renderer) {
2436                 if (Frame* frame = document().frame())
2437                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2438             }
2439         }
2440 #endif
2441     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2442         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2443         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2444         Node* startNode = this;
2445         while (startNode &amp;&amp; !startNode-&gt;renderer())
2446             startNode = startNode-&gt;parentOrShadowHostNode();
2447 
2448         if (startNode &amp;&amp; startNode-&gt;renderer())
2449             if (Frame* frame = document().frame())
2450                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
2451 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<span class="line-modified">2452     } else if (is&lt;TouchEvent&gt;(event) &amp;&amp; eventNames().isTouchRelatedEventType(document(), eventType)) {</span>
<span class="line-added">2453         // Capture the target node&#39;s visibility state before dispatching touchStart.</span>
<span class="line-added">2454         if (is&lt;Element&gt;(*this) &amp;&amp; eventType == eventNames().touchstartEvent) {</span>
<span class="line-added">2455             auto&amp; contentChangeObserver = document().contentChangeObserver();</span>
<span class="line-added">2456             if (ContentChangeObserver::isVisuallyHidden(*this))</span>
<span class="line-added">2457                 contentChangeObserver.setHiddenTouchTarget(downcast&lt;Element&gt;(*this));</span>
<span class="line-added">2458             else</span>
<span class="line-added">2459                 contentChangeObserver.resetHiddenTouchTarget();</span>
<span class="line-added">2460         }</span>
<span class="line-added">2461 </span>
2462         RenderObject* renderer = this-&gt;renderer();
2463         while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2464             renderer = renderer-&gt;parent();
2465 
2466         if (renderer &amp;&amp; renderer-&gt;node()) {
2467             if (Frame* frame = document().frame())
2468                 frame-&gt;eventHandler().defaultTouchEventHandler(*renderer-&gt;node(), downcast&lt;TouchEvent&gt;(event));
2469         }
2470 #endif
2471     }
2472 }
2473 
2474 bool Node::willRespondToMouseMoveEvents()
2475 {
2476     // FIXME: Why is the iOS code path different from the non-iOS code path?
2477 #if !PLATFORM(IOS_FAMILY)
2478     if (!is&lt;Element&gt;(*this))
2479         return false;
2480     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2481         return false;
</pre>
<hr />
<pre>
2490     return isContentEditable() || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent);
2491 #else
2492     if (!is&lt;Element&gt;(*this))
2493         return false;
2494     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2495         return false;
2496     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly
2497         || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent) || hasEventListeners(eventNames().DOMActivateEvent);
2498 #endif
2499 }
2500 
2501 bool Node::willRespondToMouseWheelEvents()
2502 {
2503     return hasEventListeners(eventNames().mousewheelEvent);
2504 }
2505 
2506 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2507 // delete a Node at each deref call site.
2508 void Node::removedLastRef()
2509 {
<span class="line-added">2510     ASSERT(m_refCountAndParentBit == s_refCountIncrement);</span>
<span class="line-added">2511 </span>
2512     // An explicit check for Document here is better than a virtual function since it is
2513     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2514     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2515     if (is&lt;Document&gt;(*this)) {
2516         downcast&lt;Document&gt;(*this).removedLastRef();
2517         return;
2518     }
2519 
<span class="line-added">2520     // Now it is time to detach the SVGElement from all its properties. These properties</span>
<span class="line-added">2521     // may outlive the SVGElement. The only difference after the detach is no commit will</span>
<span class="line-added">2522     // be carried out unless these properties are attached to another owner.</span>
<span class="line-added">2523     if (is&lt;SVGElement&gt;(*this))</span>
<span class="line-added">2524         downcast&lt;SVGElement&gt;(*this).detachAllProperties();</span>
<span class="line-added">2525 </span>
2526 #ifndef NDEBUG
2527     m_deletionHasBegun = true;
2528 #endif

2529     delete this;
2530 }
2531 
2532 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2533 {
2534     auto range = Range::create(document());
2535     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2536     range-&gt;absoluteTextRects(rects);
2537 }
2538 
2539 unsigned Node::connectedSubframeCount() const
2540 {
2541     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2542 }
2543 
2544 void Node::incrementConnectedSubframeCount(unsigned amount)
2545 {
2546     ASSERT(isContainerNode());
2547     ensureRareData().incrementConnectedSubframeCount(amount);
2548 }
2549 
2550 void Node::decrementConnectedSubframeCount(unsigned amount)
2551 {
<span class="line-added">2552     ASSERT(rareData());</span>
<span class="line-added">2553     if (!hasRareData())</span>
<span class="line-added">2554         return; // Defend against type confusion when the above assertion fails. See webkit.org/b/200300.</span>
2555     rareData()-&gt;decrementConnectedSubframeCount(amount);
2556 }
2557 
2558 void Node::updateAncestorConnectedSubframeCountForRemoval() const
2559 {
2560     unsigned count = connectedSubframeCount();
2561 
2562     if (!count)
2563         return;
2564 
2565     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2566         node-&gt;decrementConnectedSubframeCount(count);
2567 }
2568 
2569 void Node::updateAncestorConnectedSubframeCountForInsertion() const
2570 {
2571     unsigned count = connectedSubframeCount();
2572 
2573     if (!count)
2574         return;
</pre>
</td>
</tr>
</table>
<center><a href="NamedNodeMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>