<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;Parser.h&quot;
  25 
  26 #include &quot;ASTBuilder.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;DebuggerParseData.h&quot;
  29 #include &quot;JSCInlines.h&quot;
  30 #include &quot;VM.h&quot;
  31 #include &lt;utility&gt;
  32 #include &lt;wtf/SetForScope.h&gt;
  33 #include &lt;wtf/StringPrintStream.h&gt;
  34 
  35 #define updateErrorMessage(shouldPrintToken, ...) do {\
  36     propagateError(); \
  37     logError(shouldPrintToken, __VA_ARGS__); \
  38 } while (0)
  39 
  40 #define propagateError() do { if (UNLIKELY(hasError())) return 0; } while (0)
  41 #define internalFailWithMessage(shouldPrintToken, ...) do { updateErrorMessage(shouldPrintToken, __VA_ARGS__); return 0; } while (0)
  42 #define handleErrorToken() do { if (m_token.m_type == EOFTOK || m_token.m_type &amp; ErrorTokenFlag) { failDueToUnexpectedToken(); } } while (0)
  43 #define failWithMessage(...) do { { handleErrorToken(); updateErrorMessage(true, __VA_ARGS__); } return 0; } while (0)
  44 #define failWithStackOverflow() do { updateErrorMessage(false, &quot;Stack exhausted&quot;); m_hasStackOverflow = true; return 0; } while (0)
  45 #define failIfFalse(cond, ...) do { if (!(cond)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  46 #define failIfTrue(cond, ...) do { if (cond) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  47 #define failIfTrueIfStrict(cond, ...) do { if ((cond) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  48 #define failIfFalseIfStrict(cond, ...) do { if ((!(cond)) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  49 #define consumeOrFail(tokenType, ...) do { if (!consume(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  50 #define consumeOrFailWithFlags(tokenType, flags, ...) do { if (!consume(tokenType, flags)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  51 #define matchOrFail(tokenType, ...) do { if (!match(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  52 #define failIfStackOverflow() do { if (UNLIKELY(!canRecurse())) failWithStackOverflow(); } while (0)
  53 #define semanticFail(...) do { internalFailWithMessage(false, __VA_ARGS__); } while (0)
  54 #define semanticFailIfTrue(cond, ...) do { if (UNLIKELY(cond)) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  55 #define semanticFailIfFalse(cond, ...) do { if (UNLIKELY(!(cond))) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  56 #define regexFail(failure) do { setErrorMessage(failure); return 0; } while (0)
  57 #define failDueToUnexpectedToken() do {\
  58         logError(true);\
  59     return 0;\
  60 } while (0)
  61 
  62 #define handleProductionOrFail(token, tokenString, operation, production) do {\
  63     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; a &quot;, production);\
  64 } while (0)
  65 
  66 #define handleProductionOrFail2(token, tokenString, operation, production) do {\
  67     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; an &quot;, production);\
  68 } while (0)
  69 
  70 #define semanticFailureDueToKeywordCheckingToken(token, ...) do { \
  71     if (strictMode() &amp;&amp; token.m_type == RESERVED_IF_STRICT) \
  72         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__, &quot; in strict mode&quot;); \
  73     if (token.m_type == RESERVED || token.m_type == RESERVED_IF_STRICT) \
  74         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  75     if (token.m_type &amp; KeywordTokenFlag) { \
  76         if (!isAnyContextualKeyword(token)) \
  77             semanticFail(&quot;Cannot use the keyword &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  78         if (isDisallowedIdentifierLet(token)) \
  79             semanticFail(&quot;Cannot use &#39;let&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierLetReason()); \
  80         if (isDisallowedIdentifierAwait(token)) \
  81             semanticFail(&quot;Cannot use &#39;await&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierAwaitReason()); \
  82         if (isDisallowedIdentifierYield(token)) \
  83             semanticFail(&quot;Cannot use &#39;yield&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierYieldReason()); \
  84     } \
  85 } while (0)
  86 
  87 #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  88 
  89 namespace JSC {
  90 
  91 std::atomic&lt;unsigned&gt; globalParseCount { 0 };
  92 
  93 ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  94 {
  95     if (isAsyncGeneratorWrapperParseMode(parseMode))
  96         return SourceParseMode::AsyncGeneratorBodyMode;
  97 
  98     if (parseMode == SourceParseMode::AsyncArrowFunctionMode)
  99         return SourceParseMode::AsyncArrowFunctionBodyMode;
 100 
 101     return SourceParseMode::AsyncFunctionBodyMode;
 102 }
 103 
 104 template &lt;typename LexerType&gt;
 105 void Parser&lt;LexerType&gt;::logError(bool)
 106 {
 107     if (hasError())
 108         return;
 109     StringPrintStream stream;
 110     printUnexpectedTokenText(stream);
 111     setErrorMessage(stream.toStringWithLatin1Fallback());
 112 }
 113 
 114 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 115 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 116 {
 117     if (hasError())
 118         return;
 119     StringPrintStream stream;
 120     if (shouldPrintToken) {
 121         printUnexpectedTokenText(stream);
 122         stream.print(&quot;. &quot;);
 123     }
 124     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 125     setErrorMessage(stream.toStringWithLatin1Fallback());
 126 }
 127 
 128 template &lt;typename LexerType&gt;
 129 Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)
 130     : m_vm(vm)
 131     , m_source(&amp;source)
 132     , m_hasStackOverflow(false)
 133     , m_allowsIn(true)
 134     , m_statementDepth(0)
 135     , m_sourceElements(0)
 136     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 137     , m_scriptMode(scriptMode)
 138     , m_superBinding(superBinding)
 139     , m_defaultConstructorKind(defaultConstructorKind)
 140     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 141     , m_debuggerParseData(debuggerParseData)
 142 {
 143     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
 144     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 145     m_token.m_location.line = source.firstLine().oneBasedInt();
 146     m_token.m_location.startOffset = source.startOffset();
 147     m_token.m_location.endOffset = source.startOffset();
 148     m_token.m_location.lineStartOffset = source.startOffset();
 149     m_functionCache = vm.addSourceProviderCache(source.provider());
 150     m_expressionErrorClassifier = nullptr;
 151 
 152     ScopeRef scope = pushScope();
 153     scope-&gt;setSourceParseMode(parseMode);
 154     scope-&gt;setIsEvalContext(isEvalContext);
 155     if (isEvalContext)
 156         scope-&gt;setEvalContextType(evalContextType);
 157 
 158     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 159         scope-&gt;setConstructorKind(ConstructorKind::Extends);
 160         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 161     }
 162 
 163     if (derivedContextType == DerivedContextType::DerivedMethodContext)
 164         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 165 
 166     if (strictMode == JSParserStrictMode::Strict)
 167         scope-&gt;setStrictMode();
 168 
 169     if (isModuleParseMode(parseMode))
 170         m_moduleScopeData = ModuleScopeData::create();
 171 
 172     if (isProgramOrModuleParseMode(parseMode))
 173         scope-&gt;setIsGlobalCodeScope();
 174 
 175     next();
 176 }
 177 
 178 class Scope::MaybeParseAsGeneratorForScope {
 179 public:
 180     MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
 181         : m_scope(scope)
 182         , m_oldValue(scope-&gt;m_isGenerator)
 183     {
 184         m_scope-&gt;m_isGenerator = shouldParseAsGenerator;
 185     }
 186 
 187     ~MaybeParseAsGeneratorForScope()
 188     {
 189         m_scope-&gt;m_isGenerator = m_oldValue;
 190     }
 191 
 192 private:
 193     ScopeRef m_scope;
 194     bool m_oldValue;
 195 };
 196 
 197 struct DepthManager : private SetForScope&lt;int&gt; {
 198 public:
 199     DepthManager(int* depth)
 200         : SetForScope&lt;int&gt;(*depth, *depth)
 201     {
 202     }
 203 };
 204 
 205 template &lt;typename LexerType&gt;
 206 Parser&lt;LexerType&gt;::~Parser()
 207 {
 208 }
 209 
 210 template &lt;typename LexerType&gt;
 211 String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 212 {
 213     String parseError = String();
 214 
 215     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
 216     ScopeRef scope = currentScope();
 217     scope-&gt;setIsLexicalScope();
 218     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 219 
 220     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 221     if (m_lexer-&gt;isReparsingFunction()) {
 222         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 223         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 224             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);
 225         else
 226             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);
 227 
 228         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 229             // The only way we could have an error wile reparsing is if we run out of stack space.
 230             RELEASE_ASSERT(match(ARROWFUNCTION));
 231             next();
 232             isArrowFunctionBodyExpression = !match(OPENBRACE);
 233         }
 234     }
 235 
 236     if (!calleeName.isNull())
 237         scope-&gt;declareCallee(&amp;calleeName);
 238 
 239     if (m_lexer-&gt;isReparsingFunction())
 240         m_statementDepth--;
 241 
 242     SourceElements* sourceElements = nullptr;
 243     // The only way we can error this early is if we reparse a function and we run out of stack space.
 244     if (!hasError()) {
 245         if (isAsyncFunctionWrapperParseMode(parseMode))
 246             sourceElements = parseAsyncFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 247         else if (isArrowFunctionBodyExpression)
 248             sourceElements = parseArrowFunctionSingleExpressionBodySourceElements(context);
 249         else if (isModuleParseMode(parseMode))
 250             sourceElements = parseModuleSourceElements(context, parseMode);
 251         else if (isGeneratorWrapperParseMode(parseMode))
 252             sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
 253         else if (isAsyncGeneratorWrapperParseMode(parseMode))
 254             sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 255         else if (parsingContext == ParsingContext::FunctionConstructor)
 256             sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
 257         else
 258             sourceElements = parseSourceElements(context, CheckForStrictMode);
 259     }
 260 
 261     bool validEnding = consume(EOFTOK);
 262     if (!sourceElements || !validEnding) {
 263         if (hasError())
 264             parseError = m_errorMessage;
 265         else
 266             parseError = &quot;Parser error&quot;_s;
 267     }
 268 
 269     IdentifierSet capturedVariables;
 270     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 271     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 272     scope-&gt;getCapturedVars(capturedVariables);
 273 
 274     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 275     for (auto&amp; entry : capturedVariables)
 276         varDeclarations.markVariableAsCaptured(entry);
 277 
 278     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
 279         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 280             context.propagateArgumentsUse();
 281     }
 282 
 283     CodeFeatures features = context.features();
 284     if (scope-&gt;strictMode())
 285         features |= StrictModeFeature;
 286     if (scope-&gt;shadowsArguments())
 287         features |= ShadowsArgumentsFeature;
 288     if (m_seenTaggedTemplate)
 289         features |= NoEvalCacheFeature;
 290 
 291 #ifndef NDEBUG
 292     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 293         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 294         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 295         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 296             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
 297             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {
 298                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 299                 dataLog(m_source-&gt;view());
 300                 CRASH();
 301             }
 302         }
 303     }
 304 #endif // NDEBUG
 305     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());
 306 
 307     return parseError;
 308 }
 309 
 310 template &lt;typename LexerType&gt;
 311 void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,
 312     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)
 313 {
 314     m_sourceElements = sourceElements;
 315     m_funcDeclarations = WTFMove(funcStack);
 316     m_varDeclarations.swap(varDeclarations);
 317     m_features = features;
 318     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);
 319     m_numConstants = numConstants;
 320 }
 321 
 322 template &lt;typename LexerType&gt;
 323 bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()
 324 {
 325     if (match(OPENPAREN)) {
 326         SavePoint saveArrowFunctionPoint = createSavePoint();
 327         next();
 328         bool isArrowFunction = false;
 329         if (match(CLOSEPAREN)) {
 330             next();
 331             isArrowFunction = match(ARROWFUNCTION);
 332         } else {
 333             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 334             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 335             AutoPopScopeRef fakeScope(this, pushScope());
 336             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 337 
 338             unsigned parametersCount = 0;
 339             bool isArrowFunctionParameterList = true;
 340             bool isMethod = false;
 341             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 342             propagateError();
 343             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 344         }
 345         restoreSavePoint(saveArrowFunctionPoint);
 346         return isArrowFunction;
 347     }
 348 
 349     if (matchSpecIdentifier()) {
 350         SavePoint saveArrowFunctionPoint = createSavePoint();
 351         next();
 352         bool isArrowFunction = match(ARROWFUNCTION);
 353         restoreSavePoint(saveArrowFunctionPoint);
 354         return isArrowFunction;
 355     }
 356 
 357     return false;
 358 }
 359 
 360 template &lt;typename LexerType&gt;
 361 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 362 {
 363     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 364 }
 365 
 366 template &lt;typename LexerType&gt;
 367 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 368 {
 369     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 370     TreeSourceElements sourceElements = context.createSourceElements();
 371     const Identifier* directive = 0;
 372     unsigned directiveLiteralLength = 0;
 373     auto savePoint = createSavePoint();
 374     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 375 
 376     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 377         if (shouldCheckForUseStrict) {
 378             if (directive) {
 379                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
 380                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {
 381                     setStrictMode();
 382                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 383                     if (!isValidStrictMode()) {
 384                         if (m_parserState.lastFunctionName) {
 385                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)
 386                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
 387                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)
 388                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 389                         }
 390                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))
 391                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
 392                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))
 393                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 394                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 395                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 396                     }
 397                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
 398                     restoreSavePoint(savePoint);
 399                     propagateError();
 400                     continue;
 401                 }
 402 
 403                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 404                 // see if the next statement we parse is also a directive.
 405                 directive = nullptr;
 406             } else {
 407                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 408                 // is only allowed as the first statement, or after a sequence of directives before it, but
 409                 // not after non-directive statements.
 410                 shouldCheckForUseStrict = false;
 411             }
 412         }
 413         context.appendStatement(sourceElements, statement);
 414     }
 415 
 416     propagateError();
 417     return sourceElements;
 418 }
 419 
 420 template &lt;typename LexerType&gt;
 421 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 422 {
 423     TreeSourceElements sourceElements = context.createSourceElements();
 424     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 425 
 426     while (true) {
 427         TreeStatement statement = 0;
 428         switch (m_token.m_type) {
 429         case EXPORT:
 430             statement = parseExportDeclaration(context);
 431             if (statement)
 432                 recordPauseLocation(context.breakpointLocation(statement));
 433             break;
 434 
 435         case IMPORT: {
 436             SavePoint savePoint = createSavePoint();
 437             next();
 438             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
 439             restoreSavePoint(savePoint);
 440             if (isImportDeclaration) {
 441                 statement = parseImportDeclaration(context);
 442                 if (statement)
 443                     recordPauseLocation(context.breakpointLocation(statement));
 444                 break;
 445             }
 446 
 447             // This is `import(&quot;...&quot;)` call or `import.meta` meta property case.
 448             FALLTHROUGH;
 449         }
 450 
 451         default: {
 452             const Identifier* directive = 0;
 453             unsigned directiveLiteralLength = 0;
 454             if (parseMode == SourceParseMode::ModuleAnalyzeMode) {
 455                 if (!parseStatementListItem(syntaxChecker, directive, &amp;directiveLiteralLength))
 456                     goto end;
 457                 continue;
 458             }
 459             statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength);
 460             break;
 461         }
 462         }
 463 
 464         if (!statement)
 465             goto end;
 466         context.appendStatement(sourceElements, statement);
 467     }
 468 
 469 end:
 470     propagateError();
 471 
 472     for (const auto&amp; pair : m_moduleScopeData-&gt;exportedBindings()) {
 473         const auto&amp; uid = pair.key;
 474         if (currentScope()-&gt;hasDeclaredVariable(uid)) {
 475             currentScope()-&gt;declaredVariables().markVariableAsExported(uid);
 476             continue;
 477         }
 478 
 479         if (currentScope()-&gt;hasLexicallyDeclaredVariable(uid)) {
 480             currentScope()-&gt;lexicalVariables().markVariableAsExported(uid);
 481             continue;
 482         }
 483 
 484         semanticFail(&quot;Exported binding &#39;&quot;, uid.get(), &quot;&#39; needs to refer to a top-level declared variable&quot;);
 485     }
 486 
 487     return sourceElements;
 488 }
 489 
 490 template &lt;typename LexerType&gt;
 491 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseGeneratorFunctionSourceElements(TreeBuilder&amp; context, const Identifier&amp; name, SourceElementsMode mode)
 492 {
 493     auto sourceElements = context.createSourceElements();
 494 
 495     unsigned functionKeywordStart = tokenStart();
 496     JSTokenLocation startLocation(tokenLocation());
 497     JSTextPosition start = tokenStartPosition();
 498     unsigned startColumn = tokenColumn();
 499     int functionNameStart = m_token.m_location.startOffset;
 500     int parametersStart = m_token.m_location.startOffset;
 501 
 502     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 503     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 504     createGeneratorParameters(context, info.parameterCount);
 505     info.startOffset = parametersStart;
 506     info.startLine = tokenLine();
 507 
 508     {
 509         AutoPopScopeRef generatorBodyScope(this, pushScope());
 510         generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
 511         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
 512         generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
 513 
 514         SyntaxChecker generatorFunctionContext(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 515         failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
 516         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 517     }
 518     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
 519 
 520     info.endLine = tokenLine();
 521     info.endOffset = m_token.m_data.offset;
 522     info.parametersStartColumn = startColumn;
 523 
 524     auto functionExpr = context.createGeneratorFunctionBody(startLocation, info, name);
 525     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 526     context.appendStatement(sourceElements, statement);
 527 
 528     return sourceElements;
 529 }
 530 
 531 template &lt;typename LexerType&gt;
 532 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 533 {
 534     ASSERT(isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode));
 535     auto sourceElements = context.createSourceElements();
 536 
 537     unsigned functionKeywordStart = tokenStart();
 538     JSTokenLocation startLocation(tokenLocation());
 539     JSTextPosition start = tokenStartPosition();
 540     unsigned startColumn = tokenColumn();
 541     int functionNameStart = m_token.m_location.startOffset;
 542     int parametersStart = m_token.m_location.startOffset;
 543 
 544     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 545     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 546     createGeneratorParameters(context, info.parameterCount);
 547     info.startOffset = parametersStart;
 548     info.startLine = tokenLine();
 549 
 550     SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
 551 
 552     {
 553         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 554         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
 555         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 556         if (isArrowFunctionBodyExpression) {
 557             if (m_debuggerParseData)
 558                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 559             else
 560                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 561         } else {
 562             if (m_debuggerParseData)
 563                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 564             else
 565                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 566         }
 567         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 568     }
 569     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 570 
 571     info.endLine = tokenLine();
 572     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 573     info.parametersStartColumn = startColumn;
 574 
 575     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 576     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 577     context.appendStatement(sourceElements, statement);
 578 
 579     return sourceElements;
 580 }
 581 
 582 template &lt;typename LexerType&gt;
 583 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 584 {
 585     ASSERT_UNUSED(parseMode, isAsyncGeneratorWrapperParseMode(parseMode));
 586     auto sourceElements = context.createSourceElements();
 587 
 588     unsigned functionKeywordStart = tokenStart();
 589     JSTokenLocation startLocation(tokenLocation());
 590     JSTextPosition start = tokenStartPosition();
 591     unsigned startColumn = tokenColumn();
 592     int functionNameStart = m_token.m_location.startOffset;
 593     int parametersStart = m_token.m_location.startOffset;
 594 
 595     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 596     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 597     createGeneratorParameters(context, info.parameterCount);
 598     info.startOffset = parametersStart;
 599     info.startLine = tokenLine();
 600     SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
 601     {
 602         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 603         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
 604         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 605         if (isArrowFunctionBodyExpression) {
 606             if (m_debuggerParseData)
 607                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 608             else
 609                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 610         } else {
 611             if (m_debuggerParseData)
 612                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 613             else
 614                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 615         }
 616         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 617     }
 618     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 619 
 620     info.endLine = tokenLine();
 621     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 622     info.parametersStartColumn = startColumn;
 623 
 624     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 625     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 626     context.appendStatement(sourceElements, statement);
 627 
 628     return sourceElements;
 629 }
 630 
 631 template &lt;typename LexerType&gt;
 632 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSingleFunction(TreeBuilder&amp; context, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 633 {
 634     TreeSourceElements sourceElements = context.createSourceElements();
 635     TreeStatement statement = 0;
 636     switch (m_token.m_type) {
 637     case FUNCTION:
 638         statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 639         break;
 640     case IDENT:
 641         if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {
 642             next();
 643             failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
 644             statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 645             break;
 646         }
 647         FALLTHROUGH;
 648     default:
 649         failDueToUnexpectedToken();
 650         break;
 651     }
 652 
 653     if (statement) {
 654         context.setEndOffset(statement, m_lastTokenEndPosition.offset);
 655         context.appendStatement(sourceElements, statement);
 656     }
 657 
 658     propagateError();
 659     return sourceElements;
 660 }
 661 
 662 
 663 template &lt;typename LexerType&gt;
 664 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 665 {
 666     // The grammar is documented here:
 667     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 668     DepthManager statementDepth(&amp;m_statementDepth);
 669     m_statementDepth++;
 670     failIfStackOverflow();
 671     TreeStatement result = 0;
 672     bool shouldSetEndOffset = true;
 673     bool shouldSetPauseLocation = false;
 674 
 675     switch (m_token.m_type) {
 676     case CONSTTOKEN:
 677         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 678         shouldSetPauseLocation = true;
 679         break;
 680     case LET: {
 681         bool shouldParseVariableDeclaration = true;
 682         if (!strictMode()) {
 683             SavePoint savePoint = createSavePoint();
 684             next();
 685             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 686             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 687             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 688             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 689             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 690             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 691                 shouldParseVariableDeclaration = false;
 692             restoreSavePoint(savePoint);
 693         }
 694         if (shouldParseVariableDeclaration)
 695             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 696         else {
 697             bool allowFunctionDeclarationAsStatement = true;
 698             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 699         }
 700         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 701         break;
 702     }
 703     case CLASSTOKEN:
 704         result = parseClassDeclaration(context);
 705         break;
 706     case FUNCTION:
 707         result = parseFunctionDeclaration(context);
 708         break;
 709     case IDENT:
 710         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
 711             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 712             // but could be mistakenly parsed as an AsyncFunctionExpression.
 713             SavePoint savePoint = createSavePoint();
 714             next();
 715             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 716                 result = parseAsyncFunctionDeclaration(context);
 717                 break;
 718             }
 719             restoreSavePoint(savePoint);
 720         }
 721         FALLTHROUGH;
 722     case AWAIT:
 723     case YIELD: {
 724         // This is a convenient place to notice labeled statements
 725         // (even though we also parse them as normal statements)
 726         // because we allow the following type of code in sloppy mode:
 727         // ``` function foo() { label: function bar() { } } ```
 728         bool allowFunctionDeclarationAsStatement = true;
 729         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 730         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 731         break;
 732     }
 733     default:
 734         m_statementDepth--; // parseStatement() increments the depth.
 735         result = parseStatement(context, directive, directiveLiteralLength);
 736         shouldSetEndOffset = false;
 737         break;
 738     }
 739 
 740     if (result) {
 741         if (shouldSetEndOffset)
 742             context.setEndOffset(result, m_lastTokenEndPosition.offset);
 743         if (shouldSetPauseLocation)
 744             recordPauseLocation(context.breakpointLocation(result));
 745     }
 746 
 747     return result;
 748 }
 749 
 750 template &lt;typename LexerType&gt;
 751 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseVariableDeclaration(TreeBuilder&amp; context, DeclarationType declarationType, ExportType exportType)
 752 {
 753     ASSERT(match(VAR) || match(LET) || match(CONSTTOKEN));
 754     JSTokenLocation location(tokenLocation());
 755     int start = tokenLine();
 756     int end = 0;
 757     int scratch;
 758     TreeDestructuringPattern scratch1 = 0;
 759     TreeExpression scratch2 = 0;
 760     JSTextPosition scratch3;
 761     bool scratchBool;
 762     TreeExpression variableDecls = parseVariableDeclarationList(context, scratch, scratch1, scratch2, scratch3, scratch3, scratch3, VarDeclarationContext, declarationType, exportType, scratchBool);
 763     propagateError();
 764     failIfFalse(autoSemiColon(), &quot;Expected &#39;;&#39; after variable declaration&quot;);
 765 
 766     return context.createDeclarationStatement(location, variableDecls, start, end);
 767 }
 768 
 769 template &lt;typename LexerType&gt;
 770 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDoWhileStatement(TreeBuilder&amp; context)
 771 {
 772     ASSERT(match(DO));
 773     int startLine = tokenLine();
 774     next();
 775     const Identifier* unused = 0;
 776     startLoop();
 777     TreeStatement statement = parseStatement(context, unused);
 778     endLoop();
 779     failIfFalse(statement, &quot;Expected a statement following &#39;do&#39;&quot;);
 780     int endLine = tokenLine();
 781     JSTokenLocation location(tokenLocation());
 782     handleProductionOrFail(WHILE, &quot;while&quot;, &quot;end&quot;, &quot;do-while loop&quot;);
 783     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;do-while loop condition&quot;);
 784     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a do-while loop condition&quot;);
 785     TreeExpression expr = parseExpression(context);
 786     failIfFalse(expr, &quot;Unable to parse do-while loop condition&quot;);
 787     recordPauseLocation(context.breakpointLocation(expr));
 788     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;do-while loop condition&quot;);
 789     if (match(SEMICOLON))
 790         next(); // Always performs automatic semicolon insertion.
 791     return context.createDoWhileStatement(location, statement, expr, startLine, endLine);
 792 }
 793 
 794 template &lt;typename LexerType&gt;
 795 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWhileStatement(TreeBuilder&amp; context)
 796 {
 797     ASSERT(match(WHILE));
 798     JSTokenLocation location(tokenLocation());
 799     int startLine = tokenLine();
 800     next();
 801 
 802     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;while loop condition&quot;);
 803     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a while loop condition&quot;);
 804     TreeExpression expr = parseExpression(context);
 805     failIfFalse(expr, &quot;Unable to parse while loop condition&quot;);
 806     recordPauseLocation(context.breakpointLocation(expr));
 807     int endLine = tokenLine();
 808     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;while loop condition&quot;);
 809 
 810     const Identifier* unused = 0;
 811     startLoop();
 812     TreeStatement statement = parseStatement(context, unused);
 813     endLoop();
 814     failIfFalse(statement, &quot;Expected a statement as the body of a while loop&quot;);
 815     return context.createWhileStatement(location, expr, statement, startLine, endLine);
 816 }
 817 
 818 template &lt;typename LexerType&gt;
 819 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseVariableDeclarationList(TreeBuilder&amp; context, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext declarationListContext, DeclarationType declarationType, ExportType exportType, bool&amp; forLoopConstDoesNotHaveInitializer)
 820 {
 821     ASSERT(declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::VarDeclaration || declarationType == DeclarationType::ConstDeclaration);
 822     TreeExpression head = 0;
 823     TreeExpression tail = 0;
 824     const Identifier* lastIdent;
 825     JSToken lastIdentToken;
 826     AssignmentContext assignmentContext = assignmentContextFromDeclarationType(declarationType);
 827     do {
 828         lastIdent = 0;
 829         lastPattern = TreeDestructuringPattern(0);
 830         JSTokenLocation location(tokenLocation());
 831         next();
 832         TreeExpression node = 0;
 833         declarations++;
 834         bool hasInitializer = false;
 835         if (matchSpecIdentifier()) {
 836             failIfTrue(match(LET) &amp;&amp; (declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::ConstDeclaration),
 837                 &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
 838             semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, declarationTypeToVariableKind(declarationType), &quot; &quot;, disallowedIdentifierAwaitReason());
 839             JSTextPosition varStart = tokenStartPosition();
 840             JSTokenLocation varStartLocation(tokenLocation());
 841             identStart = varStart;
 842             const Identifier* name = m_token.m_data.ident;
 843             lastIdent = name;
 844             lastIdentToken = m_token;
 845             next();
 846             hasInitializer = match(EQUAL);
 847             DeclarationResultMask declarationResult = declareVariable(name, declarationType);
 848             if (declarationResult != DeclarationResult::Valid) {
 849                 failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &quot;, name-&gt;impl(), &quot; in strict mode&quot;);
 850                 if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 851                     if (declarationType == DeclarationType::LetDeclaration)
 852                         internalFailWithMessage(false, &quot;Cannot declare a let variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 853                     if (declarationType == DeclarationType::ConstDeclaration)
 854                         internalFailWithMessage(false, &quot;Cannot declare a const variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 855                     ASSERT(declarationType == DeclarationType::VarDeclaration);
 856                     internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 857                 }
 858             }
 859             if (exportType == ExportType::Exported) {
 860                 semanticFailIfFalse(exportName(*name), &quot;Cannot export a duplicate name &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 861                 m_moduleScopeData-&gt;exportBinding(*name);
 862             }
 863 
 864             if (hasInitializer) {
 865                 JSTextPosition varDivot = tokenStartPosition() + 1;
 866                 initStart = tokenStartPosition();
 867                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 868                 propagateError();
 869                 TreeExpression initializer = parseAssignmentExpression(context);
 870                 initEnd = lastTokenEndPosition();
 871                 lastInitializer = initializer;
 872                 failIfFalse(initializer, &quot;Expected expression as the intializer for the variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 873 
 874                 node = context.createAssignResolve(location, *name, initializer, varStart, varDivot, lastTokenEndPosition(), assignmentContext);
 875             } else {
 876                 if (declarationListContext == ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration)
 877                     forLoopConstDoesNotHaveInitializer = true;
 878                 failIfTrue(declarationListContext != ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration, &quot;const declared variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;, &quot; must have an initializer&quot;);
 879                 if (declarationType == DeclarationType::VarDeclaration)
 880                     node = context.createEmptyVarExpression(varStartLocation, *name);
 881                 else
 882                     node = context.createEmptyLetExpression(varStartLocation, *name);
 883             }
 884         } else {
 885             lastIdent = 0;
 886             auto pattern = parseDestructuringPattern(context, destructuringKindFromDeclarationType(declarationType), exportType, nullptr, nullptr, assignmentContext);
 887             failIfFalse(pattern, &quot;Cannot parse this destructuring pattern&quot;);
 888             hasInitializer = match(EQUAL);
 889             failIfTrue(declarationListContext == VarDeclarationContext &amp;&amp; !hasInitializer, &quot;Expected an initializer in destructuring variable declaration&quot;);
 890             lastPattern = pattern;
 891             if (hasInitializer) {
 892                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 893                 TreeExpression rhs = parseAssignmentExpression(context);
 894                 propagateError();
 895                 ASSERT(rhs);
 896                 node = context.createDestructuringAssignment(location, pattern, rhs);
 897                 lastInitializer = rhs;
 898             }
 899         }
 900 
 901         if (node) {
 902             if (!head)
 903                 head = node;
 904             else if (!tail) {
 905                 head = context.createCommaExpr(location, head);
 906                 tail = context.appendToCommaExpr(location, head, head, node);
 907             } else
 908                 tail = context.appendToCommaExpr(location, head, tail, node);
 909         }
 910     } while (match(COMMA));
 911     if (lastIdent)
 912         lastPattern = context.createBindingLocation(lastIdentToken.m_location, *lastIdent, lastIdentToken.m_startPosition, lastIdentToken.m_endPosition, assignmentContext);
 913 
 914     return head;
 915 }
 916 
 917 template &lt;typename LexerType&gt;
 918 bool Parser&lt;LexerType&gt;::declareRestOrNormalParameter(const Identifier&amp; name, const Identifier** duplicateIdentifier)
 919 {
 920     DeclarationResultMask declarationResult = declareParameter(&amp;name);
 921     if ((declarationResult &amp; DeclarationResult::InvalidStrictMode) &amp;&amp; strictMode()) {
 922         semanticFailIfTrue(isEvalOrArguments(&amp;name), &quot;Cannot destructure to a parameter name &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 923         if (m_parserState.lastFunctionName &amp;&amp; name == *m_parserState.lastFunctionName)
 924             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; as it shadows the name of a strict mode function&quot;);
 925         semanticFailureDueToKeyword(&quot;parameter name&quot;);
 926         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 927             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 928         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 929     }
 930     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 931         // It&#39;s not always an error to define a duplicate parameter.
 932         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 933         // We note this value now so we can check it later.
 934         if (duplicateIdentifier)
 935             *duplicateIdentifier = &amp;name;
 936     }
 937 
 938     return true;
 939 }
 940 
 941 template &lt;typename LexerType&gt;
 942 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
 943 {
 944     ASSERT(!name.isNull());
 945 
 946     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
 947 
 948     switch (kind) {
 949     case DestructuringKind::DestructureToVariables: {
 950         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 951         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 952         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 953             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 954         break;
 955     }
 956 
 957     case DestructuringKind::DestructureToLet:
 958     case DestructuringKind::DestructureToConst:
 959     case DestructuringKind::DestructureToCatchParameters: {
 960         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 961         if (declarationResult != DeclarationResult::Valid) {
 962             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 963             failIfTrue(declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration, &quot;Cannot declare a lexical variable twice: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 964         }
 965         break;
 966     }
 967 
 968     case DestructuringKind::DestructureToParameters: {
 969         declareRestOrNormalParameter(name, duplicateIdentifier);
 970         propagateError();
 971         break;
 972     }
 973 
 974     case DestructuringKind::DestructureToExpressions: {
 975         break;
 976     }
 977     }
 978 
 979     if (exportType == ExportType::Exported) {
 980         semanticFailIfFalse(exportName(name), &quot;Cannot export a duplicate name &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 981         m_moduleScopeData-&gt;exportBinding(name);
 982     }
 983     return context.createBindingLocation(token.m_location, name, token.m_startPosition, token.m_endPosition, bindingContext);
 984 }
 985 
 986 template &lt;typename LexerType&gt;
 987 template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern Parser&lt;LexerType&gt;::createAssignmentElement(TreeBuilder&amp; context, TreeExpression&amp; assignmentTarget, const JSTextPosition&amp; startPosition, const JSTextPosition&amp; endPosition)
 988 {
 989     return context.createAssignmentElement(assignmentTarget, startPosition, endPosition);
 990 }
 991 
 992 template &lt;typename LexerType&gt;
 993 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp; context)
 994 {
 995     ASSERT(!match(OPENBRACE));
 996 
 997     JSTokenLocation location(tokenLocation());
 998     JSTextPosition start = tokenStartPosition();
 999 
1000     failIfStackOverflow();
1001     TreeExpression expr = parseAssignmentExpression(context);
1002     failIfFalse(expr, &quot;Cannot parse the arrow function expression&quot;);
1003 
1004     context.setEndOffset(expr, m_lastTokenEndPosition.offset);
1005 
1006     JSTextPosition end = tokenEndPosition();
1007 
1008     TreeSourceElements sourceElements = context.createSourceElements();
1009     TreeStatement body = context.createReturnStatement(location, expr, start, end);
1010     context.setEndOffset(body, m_lastTokenEndPosition.offset);
1011     recordPauseLocation(context.breakpointLocation(body));
1012     context.appendStatement(sourceElements, body);
1013 
1014     return sourceElements;
1015 }
1016 
1017 template &lt;typename LexerType&gt;
1018 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::tryParseDestructuringPatternExpression(TreeBuilder&amp; context, AssignmentContext bindingContext)
1019 {
1020     return parseDestructuringPattern(context, DestructuringKind::DestructureToExpressions, ExportType::NotExported, nullptr, nullptr, bindingContext);
1021 }
1022 
1023 template &lt;typename LexerType&gt;
1024 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1025 {
1026     if (kind == DestructuringKind::DestructureToExpressions)
1027         return parseAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1028     return parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1029 }
1030 
1031 template &lt;typename LexerType&gt;
1032 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestAssignmentElement(TreeBuilder&amp; context)
1033 {
1034     JSTextPosition startPosition = tokenStartPosition();
1035     auto element = parseMemberExpression(context);
1036 
1037     if (!element || !context.isAssignmentLocation(element)) {
1038         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1039         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1040     }
1041 
1042     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1043         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1044         if (isEvalOrArguments &amp;&amp; strictMode())
1045             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1046         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1047     }
1048 
1049     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1050 }
1051 
1052 template &lt;typename LexerType&gt;
1053 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1054 {
1055     TreeDestructuringPattern assignmentTarget = 0;
1056 
1057     if (match(OPENBRACE) || match(OPENBRACKET)) {
1058         SavePoint savePoint = createSavePoint();
1059         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1060         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1061             return assignmentTarget;
1062         restoreSavePoint(savePoint);
1063     }
1064 
1065     JSTextPosition startPosition = tokenStartPosition();
1066     auto element = parseMemberExpression(context);
1067 
1068     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1069 
1070     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1071         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1072         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1073     }
1074 
1075     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1076 }
1077 
1078 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1079 {
1080     switch (kind) {
1081     case DestructuringKind::DestructureToLet:
1082     case DestructuringKind::DestructureToConst:
1083         return &quot;lexical variable name&quot;;
1084     case DestructuringKind::DestructureToVariables:
1085         return &quot;variable name&quot;;
1086     case DestructuringKind::DestructureToParameters:
1087         return &quot;parameter name&quot;;
1088     case DestructuringKind::DestructureToCatchParameters:
1089         return &quot;catch parameter name&quot;;
1090     case DestructuringKind::DestructureToExpressions:
1091         return &quot;expression name&quot;;
1092     }
1093     RELEASE_ASSERT_NOT_REACHED();
1094     return &quot;invalid&quot;;
1095 }
1096 
1097 template &lt;typename LexerType&gt;
1098 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1099 {
1100     ASSERT(kind != DestructuringKind::DestructureToExpressions);
1101     failIfStackOverflow();
1102     TreeDestructuringPattern pattern;
1103 
1104     if (!matchSpecIdentifier()) {
1105         semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1106         failWithMessage(&quot;Expected a binding element&quot;);
1107     }
1108     failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1109     semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1110     pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1111     next();
1112     return pattern;
1113 }
1114 
1115 template &lt;typename LexerType&gt;
1116 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1117 {
1118     if (kind == DestructuringKind::DestructureToExpressions)
1119         return parseObjectRestAssignmentElement(context);
1120     return parseObjectRestElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1121 }
1122 
1123 template &lt;typename LexerType&gt;
1124 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseDestructuringPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1125 {
1126     failIfStackOverflow();
1127     int nonLHSCount = m_parserState.nonLHSCount;
1128     TreeDestructuringPattern pattern;
1129     switch (m_token.m_type) {
1130     case OPENBRACKET: {
1131         JSTextPosition divotStart = tokenStartPosition();
1132         auto arrayPattern = context.createArrayPattern(m_token.m_location);
1133         next();
1134 
1135         if (hasDestructuringPattern)
1136             *hasDestructuringPattern = true;
1137 
1138         bool restElementWasFound = false;
1139 
1140         do {
1141             while (match(COMMA)) {
1142                 context.appendArrayPatternSkipEntry(arrayPattern, m_token.m_location);
1143                 next();
1144             }
1145             propagateError();
1146 
1147             if (match(CLOSEBRACKET))
1148                 break;
1149 
1150             if (UNLIKELY(match(DOTDOTDOT))) {
1151                 JSTokenLocation location = m_token.m_location;
1152                 next();
1153                 auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1154                 if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1155                     return 0;
1156                 failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1157                 context.appendArrayPatternRestEntry(arrayPattern, location, innerPattern);
1158                 restElementWasFound = true;
1159                 break;
1160             }
1161 
1162             JSTokenLocation location = m_token.m_location;
1163             auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1164             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1165                 return 0;
1166             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1167             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1168             propagateError();
1169             context.appendArrayPatternEntry(arrayPattern, location, innerPattern, defaultValue);
1170         } while (consume(COMMA));
1171 
1172         consumeOrFail(CLOSEBRACKET, restElementWasFound ? &quot;Expected a closing &#39;]&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an element destructuring pattern&quot;);
1173         context.finishArrayPattern(arrayPattern, divotStart, divotStart, lastTokenEndPosition());
1174         pattern = arrayPattern;
1175         break;
1176     }
1177     case OPENBRACE: {
1178         auto objectPattern = context.createObjectPattern(m_token.m_location);
1179         next();
1180 
1181         if (hasDestructuringPattern)
1182             *hasDestructuringPattern = true;
1183 
1184         bool restElementWasFound = false;
1185 
1186         do {
1187             bool wasString = false;
1188 
1189             if (match(CLOSEBRACE))
1190                 break;
1191 
1192             if (match(DOTDOTDOT)) {
1193                 JSTokenLocation location = m_token.m_location;
1194                 next();
1195                 auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1196                 propagateError();
1197                 if (!innerPattern)
1198                     return 0;
1199                 context.appendObjectPatternRestEntry(m_vm, objectPattern, location, innerPattern);
1200                 restElementWasFound = true;
1201                 context.setContainsObjectRestElement(objectPattern, restElementWasFound);
1202                 break;
1203             }
1204 
1205             const Identifier* propertyName = nullptr;
1206             TreeExpression propertyExpression = 0;
1207             TreeDestructuringPattern innerPattern = 0;
1208             JSTokenLocation location = m_token.m_location;
1209             if (matchSpecIdentifier()) {
1210                 failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1211                 propertyName = m_token.m_data.ident;
1212                 JSToken identifierToken = m_token;
1213                 next();
1214                 if (consume(COLON))
1215                     innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1216                 else {
1217                     if (kind == DestructuringKind::DestructureToExpressions) {
1218                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;
1219                         if (isEvalOrArguments &amp;&amp; strictMode())
1220                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1221                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1222                     }
1223                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1224                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1225                 }
1226             } else {
1227                 JSTokenType tokenType = m_token.m_type;
1228                 switch (m_token.m_type) {
1229                 case DOUBLE:
1230                 case INTEGER:
1231                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
1232                     break;
1233                 case STRING:
1234                     propertyName = m_token.m_data.ident;
1235                     wasString = true;
1236                     break;
1237                 case OPENBRACKET:
1238                     next();
1239                     propertyExpression = parseAssignmentExpression(context);
1240                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1241                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1242                     break;
1243                 default:
1244                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1245                         if (kind == DestructuringKind::DestructureToExpressions)
1246                             return 0;
1247                         failWithMessage(&quot;Expected a property name&quot;);
1248                     }
1249                     propertyName = m_token.m_data.ident;
1250                     break;
1251                 }
1252                 next();
1253                 if (!consume(COLON)) {
1254                     if (kind == DestructuringKind::DestructureToExpressions)
1255                         return 0;
1256                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1257                     semanticFailIfTrue(tokenType == RESERVED_IF_STRICT, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1258                     semanticFailIfTrue(tokenType &amp; KeywordTokenFlag, &quot;Cannot use abbreviated destructuring syntax for keyword &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1259 
1260                     failWithMessage(&quot;Expected a &#39;:&#39; prior to a named destructuring property&quot;);
1261                 }
1262                 innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1263             }
1264             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1265                 return 0;
1266             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1267             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1268             propagateError();
1269             if (propertyExpression) {
1270                 context.appendObjectPatternEntry(m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);
1271                 context.setContainsComputedProperty(objectPattern, true);
1272             } else {
1273                 ASSERT(propertyName);
1274                 context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
1275             }
1276         } while (consume(COMMA));
1277 
1278         if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !match(CLOSEBRACE))
1279             return 0;
1280         consumeOrFail(CLOSEBRACE, restElementWasFound ? &quot;Expected a closing &#39;}&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;}&#39; or an &#39;,&#39; after a property destructuring pattern&quot;);
1281         pattern = objectPattern;
1282         break;
1283     }
1284 
1285     default: {
1286         if (!matchSpecIdentifier()) {
1287             if (kind == DestructuringKind::DestructureToExpressions)
1288                 return 0;
1289             semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1290             failWithMessage(&quot;Expected a parameter pattern or a &#39;)&#39; in parameter list&quot;);
1291         }
1292         failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1293         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1294         pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1295         next();
1296         break;
1297     }
1298     }
1299     m_parserState.nonLHSCount = nonLHSCount;
1300     return pattern;
1301 }
1302 
1303 template &lt;typename LexerType&gt;
1304 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseDefaultValueForDestructuringPattern(TreeBuilder&amp; context)
1305 {
1306     if (!match(EQUAL))
1307         return 0;
1308 
1309     next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
1310     return parseAssignmentExpression(context);
1311 }
1312 
1313 template &lt;typename LexerType&gt;
1314 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
1315 {
1316     ASSERT(match(FOR));
1317     JSTokenLocation location(tokenLocation());
1318     int startLine = tokenLine();
1319     bool isAwaitFor = false;
1320     next();
1321 
1322     DepthManager statementDepth(&amp;m_statementDepth);
1323     m_statementDepth++;
1324 
1325     if (match(AWAIT)) {
1326         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can only be used in an async function or async generator&quot;);
1327         isAwaitFor = true;
1328         next();
1329     }
1330 
1331     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
1332     int nonLHSCount = m_parserState.nonLHSCount;
1333     int declarations = 0;
1334     JSTokenLocation declLocation(tokenLocation());
1335     JSTextPosition declsStart;
1336     JSTextPosition declsEnd;
1337     TreeExpression decls = 0;
1338     TreeDestructuringPattern pattern = 0;
1339     bool isVarDeclaraton = match(VAR);
1340     bool isLetDeclaration = match(LET);
1341     bool isConstDeclaration = match(CONSTTOKEN);
1342     bool forLoopConstDoesNotHaveInitializer = false;
1343 
1344     VariableEnvironment dummySet;
1345     VariableEnvironment* lexicalVariables = nullptr;
1346     AutoCleanupLexicalScope lexicalScope;
1347 
1348     auto gatherLexicalVariablesIfNecessary = [&amp;] {
1349         if (isLetDeclaration || isConstDeclaration) {
1350             ScopeRef scope = lexicalScope.scope();
1351             lexicalVariables = &amp;scope-&gt;finalizeLexicalEnvironment();
1352         } else
1353             lexicalVariables = &amp;dummySet;
1354     };
1355 
1356     auto popLexicalScopeIfNecessary = [&amp;] {
1357         if (isLetDeclaration || isConstDeclaration)
1358             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1359     };
1360 
1361     if (isVarDeclaraton || isLetDeclaration || isConstDeclaration) {
1362         /*
1363          for (var/let/const IDENT in/of expression) statement
1364          for (var/let/const varDeclarationList; expressionOpt; expressionOpt)
1365          */
1366         if (isLetDeclaration || isConstDeclaration) {
1367             ScopeRef newScope = pushScope();
1368             newScope-&gt;setIsLexicalScope();
1369             newScope-&gt;preventVarDeclarations();
1370             lexicalScope.setIsValid(newScope, this);
1371         }
1372 
1373         TreeDestructuringPattern forInTarget = 0;
1374         TreeExpression forInInitializer = 0;
1375         m_allowsIn = false;
1376         JSTextPosition initStart;
1377         JSTextPosition initEnd;
1378         DeclarationType declarationType;
1379         if (isVarDeclaraton)
1380             declarationType = DeclarationType::VarDeclaration;
1381         else if (isLetDeclaration)
1382             declarationType = DeclarationType::LetDeclaration;
1383         else if (isConstDeclaration)
1384             declarationType = DeclarationType::ConstDeclaration;
1385         else
1386             RELEASE_ASSERT_NOT_REACHED();
1387         decls = parseVariableDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd, ForLoopContext, declarationType, ExportType::NotExported, forLoopConstDoesNotHaveInitializer);
1388         m_allowsIn = true;
1389         propagateError();
1390 
1391         // Remainder of a standard for loop is handled identically
1392         if (match(SEMICOLON))
1393             goto standardForLoop;
1394 
1395         failIfFalse(declarations == 1, &quot;can only declare a single variable in an enumeration&quot;);
1396 
1397         // Handle for-in with var declaration
1398         JSTextPosition inLocation = tokenStartPosition();
1399         bool isOfEnumeration = false;
1400         if (!match(INTOKEN)) {
1401             failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);
1402             isOfEnumeration = true;
1403             next();
1404         } else {
1405             failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1406             next();
1407         }
1408 
1409         bool hasAnyAssignments = !!forInInitializer;
1410         if (hasAnyAssignments) {
1411             if (isOfEnumeration)
1412                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-of loop header&quot;);
1413             if (strictMode() || (isLetDeclaration || isConstDeclaration) || !context.isBindingNode(forInTarget))
1414                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-in loop header&quot;);
1415         }
1416         TreeExpression expr = parseExpression(context);
1417         failIfFalse(expr, &quot;Expected expression to enumerate&quot;);
1418         recordPauseLocation(context.breakpointLocation(expr));
1419         JSTextPosition exprEnd = lastTokenEndPosition();
1420 
1421         int endLine = tokenLine();
1422 
1423         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1424 
1425         const Identifier* unused = 0;
1426         startLoop();
1427         TreeStatement statement = parseStatement(context, unused);
1428         endLoop();
1429         failIfFalse(statement, &quot;Expected statement as body of for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1430         gatherLexicalVariablesIfNecessary();
1431         TreeStatement result;
1432         if (isOfEnumeration)
1433             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1434         else {
1435             ASSERT(!isAwaitFor);
1436             if (isVarDeclaraton &amp;&amp; forInInitializer)
1437                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1438             else
1439                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1440         }
1441         popLexicalScopeIfNecessary();
1442         return result;
1443     }
1444 
1445     if (!match(SEMICOLON)) {
1446         if (match(OPENBRACE) || match(OPENBRACKET)) {
1447             SavePoint savePoint = createSavePoint();
1448             declsStart = tokenStartPosition();
1449             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1450             declsEnd = lastTokenEndPosition();
1451             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
1452                 goto enumerationLoop;
1453             pattern = TreeDestructuringPattern(0);
1454             restoreSavePoint(savePoint);
1455         }
1456         m_allowsIn = false;
1457         declsStart = tokenStartPosition();
1458         decls = parseExpression(context);
1459         declsEnd = lastTokenEndPosition();
1460         m_allowsIn = true;
1461         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1462         recordPauseLocation(context.breakpointLocation(decls));
1463     }
1464 
1465     if (match(SEMICOLON)) {
1466     standardForLoop:
1467         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1468         // Standard for loop
1469         if (decls)
1470             recordPauseLocation(context.breakpointLocation(decls));
1471         next();
1472         TreeExpression condition = 0;
1473         failIfTrue(forLoopConstDoesNotHaveInitializer &amp;&amp; isConstDeclaration, &quot;const variables in for loops must have initializers&quot;);
1474 
1475         if (!match(SEMICOLON)) {
1476             condition = parseExpression(context);
1477             failIfFalse(condition, &quot;Cannot parse for loop condition expression&quot;);
1478             recordPauseLocation(context.breakpointLocation(condition));
1479         }
1480         consumeOrFail(SEMICOLON, &quot;Expected a &#39;;&#39; after the for loop condition expression&quot;);
1481 
1482         TreeExpression increment = 0;
1483         if (!match(CLOSEPAREN)) {
1484             increment = parseExpression(context);
1485             failIfFalse(increment, &quot;Cannot parse for loop iteration expression&quot;);
1486             recordPauseLocation(context.breakpointLocation(increment));
1487         }
1488         int endLine = tokenLine();
1489         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;for-loop header&quot;);
1490         const Identifier* unused = 0;
1491         startLoop();
1492         TreeStatement statement = parseStatement(context, unused);
1493         endLoop();
1494         failIfFalse(statement, &quot;Expected a statement as the body of a for loop&quot;);
1495         gatherLexicalVariablesIfNecessary();
1496         TreeStatement result = context.createForLoop(location, decls, condition, increment, statement, startLine, endLine, *lexicalVariables);
1497         popLexicalScopeIfNecessary();
1498         return result;
1499     }
1500 
1501     // For-in and For-of loop
1502 enumerationLoop:
1503     failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
1504     bool isOfEnumeration = false;
1505     if (!match(INTOKEN)) {
1506         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);
1507         isOfEnumeration = true;
1508         next();
1509     } else {
1510         failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1511         next();
1512     }
1513 
1514     TreeExpression expr = parseExpression(context);
1515     failIfFalse(expr, &quot;Cannot parse subject for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1516     recordPauseLocation(context.breakpointLocation(expr));
1517     JSTextPosition exprEnd = lastTokenEndPosition();
1518     int endLine = tokenLine();
1519 
1520     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1521     const Identifier* unused = 0;
1522     startLoop();
1523     TreeStatement statement = parseStatement(context, unused);
1524     endLoop();
1525     failIfFalse(statement, &quot;Expected a statement as the body of a for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot;loop&quot;);
1526     gatherLexicalVariablesIfNecessary();
1527     TreeStatement result;
1528     if (pattern) {
1529         ASSERT(!decls);
1530         if (isOfEnumeration)
1531             result = context.createForOfLoop(isAwaitFor, location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1532         else {
1533             ASSERT(!isAwaitFor);
1534             result = context.createForInLoop(location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1535         }
1536 
1537         popLexicalScopeIfNecessary();
1538         return result;
1539     }
1540     if (isOfEnumeration)
1541         result = context.createForOfLoop(isAwaitFor, location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1542     else {
1543         ASSERT(!isAwaitFor);
1544         result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1545     }
1546     popLexicalScopeIfNecessary();
1547     return result;
1548 }
1549 
1550 template &lt;typename LexerType&gt;
1551 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
1552 {
1553     ASSERT(match(BREAK));
1554     JSTokenLocation location(tokenLocation());
1555     JSTextPosition start = tokenStartPosition();
1556     JSTextPosition end = tokenEndPosition();
1557     next();
1558 
1559     if (autoSemiColon()) {
1560         semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
1561         return context.createBreakStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);
1562     }
1563     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
1564     const Identifier* ident = m_token.m_data.ident;
1565     semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1566     end = tokenEndPosition();
1567     next();
1568     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted break statement&quot;);
1569     return context.createBreakStatement(location, ident, start, end);
1570 }
1571 
1572 template &lt;typename LexerType&gt;
1573 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
1574 {
1575     ASSERT(match(CONTINUE));
1576     JSTokenLocation location(tokenLocation());
1577     JSTextPosition start = tokenStartPosition();
1578     JSTextPosition end = tokenEndPosition();
1579     next();
1580 
1581     if (autoSemiColon()) {
1582         semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
1583         return context.createContinueStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);
1584     }
1585     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
1586     const Identifier* ident = m_token.m_data.ident;
1587     ScopeLabelInfo* label = getLabel(ident);
1588     semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1589     semanticFailIfFalse(label-&gt;isLoop, &quot;Cannot continue to the label &#39;&quot;, ident-&gt;impl(), &quot;&#39; as it is not targeting a loop&quot;);
1590     end = tokenEndPosition();
1591     next();
1592     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted continue statement&quot;);
1593     return context.createContinueStatement(location, ident, start, end);
1594 }
1595 
1596 template &lt;typename LexerType&gt;
1597 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
1598 {
1599     ASSERT(match(RETURN));
1600     JSTokenLocation location(tokenLocation());
1601     semanticFailIfFalse(currentScope()-&gt;isFunction(), &quot;Return statements are only valid inside functions&quot;);
1602     JSTextPosition start = tokenStartPosition();
1603     JSTextPosition end = tokenEndPosition();
1604     next();
1605     // We do the auto semicolon check before attempting to parse expression
1606     // as we need to ensure the a line break after the return correctly terminates
1607     // the statement
1608     if (match(SEMICOLON))
1609         end = tokenEndPosition();
1610 
1611     if (autoSemiColon())
1612         return context.createReturnStatement(location, 0, start, end);
1613     TreeExpression expr = parseExpression(context);
1614     failIfFalse(expr, &quot;Cannot parse the return expression&quot;);
1615     end = lastTokenEndPosition();
1616     if (match(SEMICOLON))
1617         end  = tokenEndPosition();
1618     if (!autoSemiColon())
1619         failWithMessage(&quot;Expected a &#39;;&#39; following a return statement&quot;);
1620     return context.createReturnStatement(location, expr, start, end);
1621 }
1622 
1623 template &lt;typename LexerType&gt;
1624 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseThrowStatement(TreeBuilder&amp; context)
1625 {
1626     ASSERT(match(THROW));
1627     JSTokenLocation location(tokenLocation());
1628     JSTextPosition start = tokenStartPosition();
1629     next();
1630     failIfTrue(match(SEMICOLON), &quot;Expected expression after &#39;throw&#39;&quot;);
1631     semanticFailIfTrue(autoSemiColon(), &quot;Cannot have a newline after &#39;throw&#39;&quot;);
1632 
1633     TreeExpression expr = parseExpression(context);
1634     failIfFalse(expr, &quot;Cannot parse expression for throw statement&quot;);
1635     JSTextPosition end = lastTokenEndPosition();
1636     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; after a throw statement&quot;);
1637 
1638     return context.createThrowStatement(location, expr, start, end);
1639 }
1640 
1641 template &lt;typename LexerType&gt;
1642 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWithStatement(TreeBuilder&amp; context)
1643 {
1644     ASSERT(match(WITH));
1645     JSTokenLocation location(tokenLocation());
1646     semanticFailIfTrue(strictMode(), &quot;&#39;with&#39; statements are not valid in strict mode&quot;);
1647     currentScope()-&gt;setNeedsFullActivation();
1648     int startLine = tokenLine();
1649     next();
1650 
1651     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1652     int start = tokenStart();
1653     TreeExpression expr = parseExpression(context);
1654     failIfFalse(expr, &quot;Cannot parse &#39;with&#39; subject expression&quot;);
1655     recordPauseLocation(context.breakpointLocation(expr));
1656     JSTextPosition end = lastTokenEndPosition();
1657     int endLine = tokenLine();
1658     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1659     const Identifier* unused = 0;
1660     TreeStatement statement = parseStatement(context, unused);
1661     failIfFalse(statement, &quot;A &#39;with&#39; statement must have a body&quot;);
1662 
1663     return context.createWithStatement(location, expr, statement, start, end, startLine, endLine);
1664 }
1665 
1666 template &lt;typename LexerType&gt;
1667 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseSwitchStatement(TreeBuilder&amp; context)
1668 {
1669     ASSERT(match(SWITCH));
1670     JSTokenLocation location(tokenLocation());
1671     int startLine = tokenLine();
1672     next();
1673     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1674     TreeExpression expr = parseExpression(context);
1675     failIfFalse(expr, &quot;Cannot parse switch subject expression&quot;);
1676     recordPauseLocation(context.breakpointLocation(expr));
1677     int endLine = tokenLine();
1678 
1679     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1680     handleProductionOrFail(OPENBRACE, &quot;{&quot;, &quot;start&quot;, &quot;body of a &#39;switch&#39;&quot;);
1681     AutoPopScopeRef lexicalScope(this, pushScope());
1682     lexicalScope-&gt;setIsLexicalScope();
1683     lexicalScope-&gt;preventVarDeclarations();
1684     startSwitch();
1685     TreeClauseList firstClauses = parseSwitchClauses(context);
1686     propagateError();
1687 
1688     TreeClause defaultClause = parseSwitchDefaultClause(context);
1689     propagateError();
1690 
1691     TreeClauseList secondClauses = parseSwitchClauses(context);
1692     propagateError();
1693     endSwitch();
1694     handleProductionOrFail(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;body of a &#39;switch&#39;&quot;);
1695 
1696     TreeStatement result = context.createSwitchStatement(location, expr, firstClauses, defaultClause, secondClauses, startLine, endLine, lexicalScope-&gt;finalizeLexicalEnvironment(), lexicalScope-&gt;takeFunctionDeclarations());
1697     popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1698     return result;
1699 }
1700 
1701 template &lt;typename LexerType&gt;
1702 template &lt;class TreeBuilder&gt; TreeClauseList Parser&lt;LexerType&gt;::parseSwitchClauses(TreeBuilder&amp; context)
1703 {
1704     if (!match(CASE))
1705         return 0;
1706     unsigned startOffset = tokenStart();
1707     next();
1708     TreeExpression condition = parseExpression(context);
1709     failIfFalse(condition, &quot;Cannot parse switch clause&quot;);
1710     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1711     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1712     failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1713     TreeClause clause = context.createClause(condition, statements);
1714     context.setStartOffset(clause, startOffset);
1715     TreeClauseList clauseList = context.createClauseList(clause);
1716     TreeClauseList tail = clauseList;
1717 
1718     while (match(CASE)) {
1719         startOffset = tokenStart();
1720         next();
1721         TreeExpression condition = parseExpression(context);
1722         failIfFalse(condition, &quot;Cannot parse switch case expression&quot;);
1723         consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1724         TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1725         failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1726         clause = context.createClause(condition, statements);
1727         context.setStartOffset(clause, startOffset);
1728         tail = context.createClauseList(tail, clause);
1729     }
1730     return clauseList;
1731 }
1732 
1733 template &lt;typename LexerType&gt;
1734 template &lt;class TreeBuilder&gt; TreeClause Parser&lt;LexerType&gt;::parseSwitchDefaultClause(TreeBuilder&amp; context)
1735 {
1736     if (!match(DEFAULT))
1737         return 0;
1738     unsigned startOffset = tokenStart();
1739     next();
1740     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch default clause&quot;);
1741     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1742     failIfFalse(statements, &quot;Cannot parse the body of a switch default clause&quot;);
1743     TreeClause result = context.createClause(0, statements);
1744     context.setStartOffset(result, startOffset);
1745     return result;
1746 }
1747 
1748 template &lt;typename LexerType&gt;
1749 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseTryStatement(TreeBuilder&amp; context)
1750 {
1751     ASSERT(match(TRY));
1752     JSTokenLocation location(tokenLocation());
1753     TreeStatement tryBlock = 0;
1754     TreeDestructuringPattern catchPattern = 0;
1755     TreeStatement catchBlock = 0;
1756     TreeStatement finallyBlock = 0;
1757     int firstLine = tokenLine();
1758     next();
1759     matchOrFail(OPENBRACE, &quot;Expected a block statement as body of a try statement&quot;);
1760 
1761     tryBlock = parseBlockStatement(context);
1762     failIfFalse(tryBlock, &quot;Cannot parse the body of try block&quot;);
1763     int lastLine = m_lastTokenEndPosition.line;
1764     VariableEnvironment catchEnvironment;
1765     if (match(CATCH)) {
1766         next();
1767 
1768         if (match(OPENBRACE)) {
1769             catchBlock = parseBlockStatement(context);
1770             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1771         } else {
1772             handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;catch&#39; target&quot;);
1773             AutoPopScopeRef catchScope(this, pushScope());
1774             catchScope-&gt;setIsLexicalScope();
1775             catchScope-&gt;preventVarDeclarations();
1776             const Identifier* ident = nullptr;
1777             if (matchSpecIdentifier()) {
1778                 catchScope-&gt;setIsSimpleCatchParameterScope();
1779                 ident = m_token.m_data.ident;
1780                 catchPattern = context.createBindingLocation(m_token.m_location, *ident, m_token.m_startPosition, m_token.m_endPosition, AssignmentContext::DeclarationStatement);
1781                 next();
1782                 failIfTrueIfStrict(catchScope-&gt;declareLexicalVariable(ident, false) &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a catch variable named &#39;&quot;, ident-&gt;impl(), &quot;&#39; in strict mode&quot;);
1783             } else {
1784                 catchPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToCatchParameters, ExportType::NotExported);
1785                 failIfFalse(catchPattern, &quot;Cannot parse this destructuring pattern&quot;);
1786             }
1787             handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;catch&#39; target&quot;);
1788             matchOrFail(OPENBRACE, &quot;Expected exception handler to be a block statement&quot;);
1789             catchBlock = parseBlockStatement(context);
1790             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1791             catchEnvironment = catchScope-&gt;finalizeLexicalEnvironment();
1792             RELEASE_ASSERT(!ident || (catchEnvironment.size() == 1 &amp;&amp; catchEnvironment.contains(ident-&gt;impl())));
1793             popScope(catchScope, TreeBuilder::NeedsFreeVariableInfo);
1794         }
1795     }
1796 
1797     if (match(FINALLY)) {
1798         next();
1799         matchOrFail(OPENBRACE, &quot;Expected block statement for finally body&quot;);
1800         finallyBlock = parseBlockStatement(context);
1801         failIfFalse(finallyBlock, &quot;Cannot parse finally body&quot;);
1802     }
1803     failIfFalse(catchBlock || finallyBlock, &quot;Try statements must have at least a catch or finally block&quot;);
1804     return context.createTryStatement(location, tryBlock, catchPattern, catchBlock, finallyBlock, firstLine, lastLine, catchEnvironment);
1805 }
1806 
1807 template &lt;typename LexerType&gt;
1808 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDebuggerStatement(TreeBuilder&amp; context)
1809 {
1810     ASSERT(match(DEBUGGER));
1811     JSTokenLocation location(tokenLocation());
1812     int startLine = tokenLine();
1813     int endLine = startLine;
1814     next();
1815     if (match(SEMICOLON))
1816         startLine = tokenLine();
1817     failIfFalse(autoSemiColon(), &quot;Debugger keyword must be followed by a &#39;;&#39;&quot;);
1818     return context.createDebugger(location, startLine, endLine);
1819 }
1820 
1821 template &lt;typename LexerType&gt;
1822 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBlockStatement(TreeBuilder&amp; context)
1823 {
1824     ASSERT(match(OPENBRACE));
1825 
1826     // We should treat the first block statement of the function (the body of the function) as the lexical
1827     // scope of the function itself, and not the lexical scope of a &#39;block&#39; statement within the function.
1828     AutoCleanupLexicalScope lexicalScope;
1829     bool shouldPushLexicalScope = m_statementDepth &gt; 0;
1830     if (shouldPushLexicalScope) {
1831         ScopeRef newScope = pushScope();
1832         newScope-&gt;setIsLexicalScope();
1833         newScope-&gt;preventVarDeclarations();
1834         lexicalScope.setIsValid(newScope, this);
1835     }
1836     JSTokenLocation location(tokenLocation());
1837     int startOffset = m_token.m_data.offset;
1838     int start = tokenLine();
1839     VariableEnvironment emptyEnvironment;
1840     DeclarationStacks::FunctionStack emptyFunctionStack;
1841     next();
1842     if (match(CLOSEBRACE)) {
1843         int endOffset = m_token.m_data.offset;
1844         next();
1845         TreeStatement result = context.createBlockStatement(location, 0, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1846         context.setStartOffset(result, startOffset);
1847         context.setEndOffset(result, endOffset);
1848         if (shouldPushLexicalScope)
1849             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1850         return result;
1851     }
1852     TreeSourceElements subtree = parseSourceElements(context, DontCheckForStrictMode);
1853     failIfFalse(subtree, &quot;Cannot parse the body of the block statement&quot;);
1854     matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; at the end of a block statement&quot;);
1855     int endOffset = m_token.m_data.offset;
1856     next();
1857     TreeStatement result = context.createBlockStatement(location, subtree, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1858     context.setStartOffset(result, startOffset);
1859     context.setEndOffset(result, endOffset);
1860     if (shouldPushLexicalScope)
1861         popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1862 
1863     return result;
1864 }
1865 
1866 template &lt;typename LexerType&gt;
1867 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatement(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
1868 {
1869     DepthManager statementDepth(&amp;m_statementDepth);
1870     m_statementDepth++;
1871     int nonTrivialExpressionCount = 0;
1872     failIfStackOverflow();
1873     TreeStatement result = 0;
1874     bool shouldSetEndOffset = true;
1875     bool shouldSetPauseLocation = false;
1876     bool parentAllowsFunctionDeclarationAsStatement = m_immediateParentAllowsFunctionDeclarationInStatement;
1877     m_immediateParentAllowsFunctionDeclarationInStatement = false;
1878 
1879     switch (m_token.m_type) {
1880     case OPENBRACE:
1881         result = parseBlockStatement(context);
1882         shouldSetEndOffset = false;
1883         break;
1884     case VAR:
1885         result = parseVariableDeclaration(context, DeclarationType::VarDeclaration);
1886         shouldSetPauseLocation = true;
1887         break;
1888     case FUNCTION: {
1889         const bool isAsync = false;
1890         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
1891         break;
1892     }
1893     case SEMICOLON: {
1894         JSTokenLocation location(tokenLocation());
1895         next();
1896         result = context.createEmptyStatement(location);
1897         shouldSetPauseLocation = true;
1898         break;
1899     }
1900     case IF:
1901         result = parseIfStatement(context);
1902         break;
1903     case DO:
1904         result = parseDoWhileStatement(context);
1905         break;
1906     case WHILE:
1907         result = parseWhileStatement(context);
1908         break;
1909     case FOR:
1910         result = parseForStatement(context);
1911         break;
1912     case CONTINUE:
1913         result = parseContinueStatement(context);
1914         shouldSetPauseLocation = true;
1915         break;
1916     case BREAK:
1917         result = parseBreakStatement(context);
1918         shouldSetPauseLocation = true;
1919         break;
1920     case RETURN:
1921         result = parseReturnStatement(context);
1922         shouldSetPauseLocation = true;
1923         break;
1924     case WITH:
1925         result = parseWithStatement(context);
1926         break;
1927     case SWITCH:
1928         result = parseSwitchStatement(context);
1929         break;
1930     case THROW:
1931         result = parseThrowStatement(context);
1932         shouldSetPauseLocation = true;
1933         break;
1934     case TRY:
1935         result = parseTryStatement(context);
1936         break;
1937     case DEBUGGER:
1938         result = parseDebuggerStatement(context);
1939         shouldSetPauseLocation = true;
1940         break;
1941     case EOFTOK:
1942     case CASE:
1943     case CLOSEBRACE:
1944     case DEFAULT:
1945         // These tokens imply the end of a set of source elements
1946         return 0;
1947     case LET: {
1948         if (!strictMode())
1949             goto identcase;
1950         goto defaultCase;
1951     }
1952     case IDENT:
1953         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
1954             if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
1955                 break;
1956         }
1957         FALLTHROUGH;
1958     case AWAIT:
1959     case YIELD: {
1960         identcase:
1961         bool allowFunctionDeclarationAsStatement = false;
1962         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
1963         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
1964         break;
1965     }
1966     case STRING:
1967         directive = m_token.m_data.ident;
1968         if (directiveLiteralLength)
1969             *directiveLiteralLength = m_token.m_location.endOffset - m_token.m_location.startOffset;
1970         nonTrivialExpressionCount = m_parserState.nonTrivialExpressionCount;
1971         FALLTHROUGH;
1972     default:
1973         defaultCase:
1974         TreeStatement exprStatement = parseExpressionStatement(context);
1975         if (directive &amp;&amp; nonTrivialExpressionCount != m_parserState.nonTrivialExpressionCount)
1976             directive = nullptr;
1977         result = exprStatement;
1978         shouldSetPauseLocation = true;
1979         break;
1980     }
1981 
1982     if (result) {
1983         if (shouldSetEndOffset)
1984             context.setEndOffset(result, m_lastTokenEndPosition.offset);
1985         if (shouldSetPauseLocation)
1986             recordPauseLocation(context.breakpointLocation(result));
1987     }
1988 
1989     return result;
1990 }
1991 
1992 template &lt;typename LexerType&gt;
1993 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclarationStatement(TreeBuilder&amp; context, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement)
1994 {
1995     semanticFailIfTrue(strictMode(), &quot;Function declarations are only allowed inside blocks or switch statements in strict mode&quot;);
1996     failIfFalse(parentAllowsFunctionDeclarationAsStatement, &quot;Function declarations are only allowed inside block statements or at the top level of a program&quot;);
1997     if (!currentScope()-&gt;isFunction() &amp;&amp; !closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext()) {
1998         // We only implement annex B.3.3 if we&#39;re in function mode or eval mode. Otherwise, we fall back
1999         // to hoisting behavior.
2000         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=155813
2001         DepthManager statementDepth(&amp;m_statementDepth);
2002         m_statementDepth = 1;
2003         if (isAsync)
2004             return parseAsyncFunctionDeclaration(context);
2005         return parseFunctionDeclaration(context);
2006     }
2007 
2008     // Any function declaration that isn&#39;t in a block is a syntax error unless it&#39;s
2009     // in an if/else statement. If it&#39;s in an if/else statement, we will magically
2010     // treat it as if the if/else statement is inside a block statement.
2011     // to the very top like a &quot;var&quot;. For example:
2012     // function a() {
2013     //     if (cond) function foo() { }
2014     // }
2015     // will be rewritten as:
2016     // function a() {
2017     //     if (cond) { function foo() { } }
2018     // }
2019     AutoPopScopeRef blockScope(this, pushScope());
2020     blockScope-&gt;setIsLexicalScope();
2021     blockScope-&gt;preventVarDeclarations();
2022     JSTokenLocation location(tokenLocation());
2023     int start = tokenLine();
2024 
2025     TreeStatement function = 0;
2026     if (!isAsync)
2027         function = parseFunctionDeclaration(context);
2028     else
2029         function = parseAsyncFunctionDeclaration(context);
2030     propagateError();
2031     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2032     TreeSourceElements sourceElements = context.createSourceElements();
2033     context.appendStatement(sourceElements, function);
2034     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2035     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2036     return result;
2037 }
2038 
2039 template &lt;typename LexerType&gt;
2040 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2041 {
2042     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
2043     SavePoint savePoint = createSavePoint();
2044     next();
2045     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2046         const bool isAsync = true;
2047         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2048         return true;
2049     }
2050     restoreSavePoint(savePoint);
2051     return false;
2052 }
2053 
2054 template &lt;typename LexerType&gt;
2055 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2056 {
2057 #define failIfDuplicateIfViolation() \
2058     if (duplicateParameter) {\
2059         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2060         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2061         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2062         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
2063         semanticFailIfTrue(isMethod, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in a method&quot;);\
2064     }
2065 
2066     bool hasDefaultParameterValues = false;
2067     bool hasDestructuringPattern = false;
2068     bool isRestParameter = false;
2069     const Identifier* duplicateParameter = nullptr;
2070     unsigned restParameterStart = 0;
2071     do {
2072         TreeDestructuringPattern parameter = 0;
2073         TreeExpression defaultValue = 0;
2074 
2075         if (UNLIKELY(match(CLOSEPAREN)))
2076             break;
2077 
2078         if (match(DOTDOTDOT)) {
2079             next();
2080             semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);
2081             TreeDestructuringPattern destructuringPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2082             propagateError();
2083             parameter = context.createRestParameter(destructuringPattern, restParameterStart);
2084             failIfTrue(match(COMMA), &quot;Rest parameter should be the last parameter in a function declaration&quot;); // Let&#39;s have a good error message for this common case.
2085             isRestParameter = true;
2086         } else
2087             parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2088         failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2089         if (!isRestParameter) {
2090             defaultValue = parseDefaultValueForDestructuringPattern(context);
2091             if (defaultValue)
2092                 hasDefaultParameterValues = true;
2093         }
2094         propagateError();
2095         failIfDuplicateIfViolation();
2096         if (isRestParameter || defaultValue || hasDestructuringPattern)
2097             currentScope()-&gt;setHasNonSimpleParameterList();
2098         context.appendParameter(list, parameter, defaultValue);
2099         if (!isRestParameter) {
2100             restParameterStart++;
2101             if (!hasDefaultParameterValues)
2102                 parameterCount++;
2103         }
2104     } while (!isRestParameter &amp;&amp; consume(COMMA));
2105 
2106     return true;
2107 #undef failIfDuplicateIfViolation
2108 }
2109 
2110 template &lt;typename LexerType&gt;
2111 template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
2112     TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
2113     ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
2114 {
2115     bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
2116     if (!isArrowFunctionBodyExpression) {
2117         next();
2118         if (match(CLOSEBRACE)) {
2119             unsigned endColumn = tokenColumn();
2120             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2121             return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2122         }
2123     }
2124 
2125     DepthManager statementDepth(&amp;m_statementDepth);
2126     m_statementDepth = 0;
2127     if (bodyType == ArrowFunctionBodyExpression) {
2128         if (m_debuggerParseData)
2129             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse body of this arrow function&quot;);
2130         else
2131             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse body of this arrow function&quot;);
2132     } else {
2133         if (m_debuggerParseData)
2134             failIfFalse(parseSourceElements(context, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2135         else
2136             failIfFalse(parseSourceElements(syntaxChecker, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2137     }
2138     unsigned endColumn = tokenColumn();
2139     SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2140     return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2141 }
2142 
2143 static const char* stringArticleForFunctionMode(SourceParseMode mode)
2144 {
2145     switch (mode) {
2146     case SourceParseMode::GetterMode:
2147     case SourceParseMode::SetterMode:
2148     case SourceParseMode::NormalFunctionMode:
2149     case SourceParseMode::MethodMode:
2150     case SourceParseMode::GeneratorBodyMode:
2151     case SourceParseMode::GeneratorWrapperFunctionMode:
2152     case SourceParseMode::GeneratorWrapperMethodMode:
2153         return &quot;a &quot;;
2154     case SourceParseMode::ArrowFunctionMode:
2155     case SourceParseMode::AsyncFunctionMode:
2156     case SourceParseMode::AsyncFunctionBodyMode:
2157     case SourceParseMode::AsyncMethodMode:
2158     case SourceParseMode::AsyncArrowFunctionBodyMode:
2159     case SourceParseMode::AsyncArrowFunctionMode:
2160     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2161     case SourceParseMode::AsyncGeneratorBodyMode:
2162     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2163         return &quot;an &quot;;
2164     case SourceParseMode::ProgramMode:
2165     case SourceParseMode::ModuleAnalyzeMode:
2166     case SourceParseMode::ModuleEvaluateMode:
2167         RELEASE_ASSERT_NOT_REACHED();
2168         return &quot;&quot;;
2169     }
2170     RELEASE_ASSERT_NOT_REACHED();
2171     return nullptr;
2172 }
2173 
2174 static const char* stringForFunctionMode(SourceParseMode mode)
2175 {
2176     switch (mode) {
2177     case SourceParseMode::GetterMode:
2178         return &quot;getter&quot;;
2179     case SourceParseMode::SetterMode:
2180         return &quot;setter&quot;;
2181     case SourceParseMode::NormalFunctionMode:
2182         return &quot;function&quot;;
2183     case SourceParseMode::MethodMode:
2184         return &quot;method&quot;;
2185     case SourceParseMode::GeneratorBodyMode:
2186         return &quot;generator&quot;;
2187     case SourceParseMode::GeneratorWrapperFunctionMode:
2188     case SourceParseMode::GeneratorWrapperMethodMode:
2189         return &quot;generator function&quot;;
2190     case SourceParseMode::ArrowFunctionMode:
2191         return &quot;arrow function&quot;;
2192     case SourceParseMode::AsyncFunctionMode:
2193     case SourceParseMode::AsyncFunctionBodyMode:
2194         return &quot;async function&quot;;
2195     case SourceParseMode::AsyncMethodMode:
2196         return &quot;async method&quot;;
2197     case SourceParseMode::AsyncArrowFunctionBodyMode:
2198     case SourceParseMode::AsyncArrowFunctionMode:
2199         return &quot;async arrow function&quot;;
2200     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2201     case SourceParseMode::AsyncGeneratorBodyMode:
2202         return &quot;async generator function&quot;;
2203     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2204         return &quot;async generator method&quot;;
2205     case SourceParseMode::ProgramMode:
2206     case SourceParseMode::ModuleAnalyzeMode:
2207     case SourceParseMode::ModuleEvaluateMode:
2208         RELEASE_ASSERT_NOT_REACHED();
2209         return &quot;&quot;;
2210     }
2211     RELEASE_ASSERT_NOT_REACHED();
2212     return nullptr;
2213 }
2214 
2215 template &lt;typename LexerType&gt; template &lt;class TreeBuilder, class FunctionInfoType&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::parseFunctionParameters(TreeBuilder&amp; context, SourceParseMode mode, FunctionInfoType&amp; functionInfo)
2216 {
2217     RELEASE_ASSERT(!(SourceParseModeSet(SourceParseMode::ProgramMode, SourceParseMode::ModuleAnalyzeMode, SourceParseMode::ModuleEvaluateMode).contains(mode)));
2218     TreeFormalParameterList parameterList = context.createFormalParameterList();
2219     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Parameters);
2220 
2221     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2222         if (!matchSpecIdentifier() &amp;&amp; !match(OPENPAREN)) {
2223             semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2224             failWithMessage(&quot;Expected an arrow function input parameter&quot;);
2225         } else {
2226             if (match(OPENPAREN)) {
2227                 next();
2228 
2229                 if (match(CLOSEPAREN)) {
2230                     functionInfo.parameterCount = 0;
2231                 } else {
2232                     bool isArrowFunction = true;
2233                     bool isMethod = false;
2234                     failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2235                 }
2236 
2237                 consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2238             } else {
2239                 functionInfo.parameterCount = 1;
2240                 auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported);
2241                 failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2242                 context.appendParameter(parameterList, parameter, 0);
2243             }
2244         }
2245 
2246         return parameterList;
2247     }
2248 
2249     if (!consume(OPENPAREN)) {
2250         semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2251         failWithMessage(&quot;Expected an opening &#39;(&#39; before a &quot;, stringForFunctionMode(mode), &quot;&#39;s parameter list&quot;);
2252     }
2253 
2254     if (mode == SourceParseMode::GetterMode) {
2255         consumeOrFail(CLOSEPAREN, &quot;getter functions must have no parameters&quot;);
2256         functionInfo.parameterCount = 0;
2257     } else if (mode == SourceParseMode::SetterMode) {
2258         failIfTrue(match(CLOSEPAREN), &quot;setter functions must have one parameter&quot;);
2259         const Identifier* duplicateParameter = nullptr;
2260         bool hasDestructuringPattern = false;
2261         auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2262         failIfFalse(parameter, &quot;setter functions must have one parameter&quot;);
2263         auto defaultValue = parseDefaultValueForDestructuringPattern(context);
2264         propagateError();
2265         if (defaultValue || hasDestructuringPattern) {
2266             semanticFailIfTrue(duplicateParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with non-simple parameter list&quot;);
2267             currentScope()-&gt;setHasNonSimpleParameterList();
2268         }
2269         context.appendParameter(parameterList, parameter, defaultValue);
2270         functionInfo.parameterCount = defaultValue ? 0 : 1;
2271         failIfTrue(match(COMMA), &quot;setter functions must have one parameter&quot;);
2272         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; after a parameter declaration&quot;);
2273     } else {
2274         if (match(CLOSEPAREN)) {
2275             functionInfo.parameterCount = 0;
2276         } else {
2277             bool isArrowFunction = false;
2278             bool isMethod = isMethodParseMode(mode);
2279             failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2280         }
2281         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2282     }
2283 
2284     return parameterList;
2285 }
2286 
2287 template &lt;typename LexerType&gt;
2288 template &lt;class TreeBuilder&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::createGeneratorParameters(TreeBuilder&amp; context, unsigned&amp; parameterCount)
2289 {
2290     auto parameters = context.createFormalParameterList();
2291 
2292     JSTokenLocation location(tokenLocation());
2293     JSTextPosition position = tokenStartPosition();
2294 
2295     auto addParameter = [&amp;](const Identifier&amp; name) {
2296         declareParameter(&amp;name);
2297         auto binding = context.createBindingLocation(location, name, position, position, AssignmentContext::DeclarationStatement);
2298         context.appendParameter(parameters, binding, 0);
2299         ++parameterCount;
2300     };
2301 
2302     // @generator
2303     addParameter(m_vm.propertyNames-&gt;generatorPrivateName);
2304     // @generatorState
2305     addParameter(m_vm.propertyNames-&gt;generatorStatePrivateName);
2306     // @generatorValue
2307     addParameter(m_vm.propertyNames-&gt;generatorValuePrivateName);
2308     // @generatorResumeMode
2309     addParameter(m_vm.propertyNames-&gt;generatorResumeModePrivateName);
2310     // @generatorFrame
2311     addParameter(m_vm.propertyNames-&gt;generatorFramePrivateName);
2312 
2313     return parameters;
2314 }
2315 
2316 template &lt;typename LexerType&gt;
2317 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, FunctionNameRequirements requirements, SourceParseMode mode, bool nameIsInContainingScope, ConstructorKind constructorKind, SuperBinding expectedSuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp; functionInfo, FunctionDefinitionType functionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2318 {
2319     RELEASE_ASSERT(isFunctionParseMode(mode));
2320 
2321     ScopeRef parentScope = currentScope();
2322 
2323     bool isDisallowedAwaitFunctionName = isDisallowedIdentifierAwait(m_token);
2324     const char* isDisallowedAwaitFunctionNameReason = isDisallowedAwaitFunctionName ? disallowedIdentifierAwaitReason() : nullptr;
2325 
2326     AutoPopScopeRef functionScope(this, pushScope());
2327     functionScope-&gt;setSourceParseMode(mode);
2328     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2329     functionScope-&gt;setConstructorKind(constructorKind);
2330     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
2331     int functionNameStart = m_token.m_location.startOffset;
2332     const Identifier* lastFunctionName = m_parserState.lastFunctionName;
2333     m_parserState.lastFunctionName = nullptr;
2334     int parametersStart = -1;
2335     JSTokenLocation startLocation;
2336     int startColumn = -1;
2337     FunctionBodyType functionBodyType;
2338 
2339     auto loadCachedFunction = [&amp;] () -&gt; bool {
2340         if (UNLIKELY(!Options::useSourceProviderCache()))
2341             return false;
2342 
2343         if (UNLIKELY(m_debuggerParseData))
2344             return false;
2345 
2346         ASSERT(parametersStart != -1);
2347         ASSERT(startColumn != -1);
2348 
2349         // If we know about this function already, we can use the cached info and skip the parser to the end of the function.
2350         if (const SourceProviderCacheItem* cachedInfo = TreeBuilder::CanUseFunctionCache ? findCachedFunctionInfo(parametersStart) : 0) {
2351             // If we&#39;re in a strict context, the cached function info must say it was strict too.
2352             ASSERT(!strictMode() || cachedInfo-&gt;strictMode);
2353             JSTokenLocation endLocation;
2354 
2355             ConstructorKind constructorKind = static_cast&lt;ConstructorKind&gt;(cachedInfo-&gt;constructorKind);
2356             SuperBinding expectedSuperBinding = static_cast&lt;SuperBinding&gt;(cachedInfo-&gt;expectedSuperBinding);
2357 
2358             endLocation.line = cachedInfo-&gt;lastTokenLine;
2359             endLocation.startOffset = cachedInfo-&gt;lastTokenStartOffset;
2360             endLocation.lineStartOffset = cachedInfo-&gt;lastTokenLineStartOffset;
2361             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2362 
2363             bool endColumnIsOnStartLine = endLocation.line == functionInfo.startLine;
2364             unsigned currentLineStartOffset = m_lexer-&gt;currentLineStartOffset();
2365             unsigned bodyEndColumn = endColumnIsOnStartLine ? endLocation.startOffset - currentLineStartOffset : endLocation.startOffset - endLocation.lineStartOffset;
2366 
2367             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2368 
2369             FunctionBodyType functionBodyType;
2370             if (UNLIKELY(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))
2371                 functionBodyType = cachedInfo-&gt;isBodyArrowExpression ?  ArrowFunctionBodyExpression : ArrowFunctionBodyBlock;
2372             else
2373                 functionBodyType = StandardFunctionBodyBlock;
2374 
2375             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, expectedSuperBinding, cachedInfo-&gt;needsSuperBinding, cachedInfo-&gt;usesEval, cachedInfo-&gt;innerArrowFunctionFeatures);
2376 
2377             functionInfo.body = context.createFunctionMetadata(
2378                 startLocation, endLocation, startColumn, bodyEndColumn,
2379                 functionKeywordStart, functionNameStart, parametersStart,
2380                 cachedInfo-&gt;strictMode, constructorKind, functionSuperBinding,
2381                 cachedInfo-&gt;parameterCount,
2382                 mode, functionBodyType == ArrowFunctionBodyExpression);
2383             functionInfo.endOffset = cachedInfo-&gt;endFunctionOffset;
2384             functionInfo.parameterCount = cachedInfo-&gt;parameterCount;
2385 
2386             functionScope-&gt;restoreFromSourceProviderCache(cachedInfo);
2387             popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2388 
2389             m_token = cachedInfo-&gt;endFunctionToken();
2390 
2391             if (endColumnIsOnStartLine)
2392                 m_token.m_location.lineStartOffset = currentLineStartOffset;
2393 
2394             m_lexer-&gt;setOffset(m_token.m_location.endOffset, m_token.m_location.lineStartOffset);
2395             m_lexer-&gt;setLineNumber(m_token.m_location.line);
2396 
2397             switch (functionBodyType) {
2398             case ArrowFunctionBodyExpression:
2399                 next();
2400                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2401                 break;
2402             case ArrowFunctionBodyBlock:
2403             case StandardFunctionBodyBlock:
2404                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2405                 next();
2406                 break;
2407             }
2408             functionInfo.endLine = m_lastTokenEndPosition.line;
2409             return true;
2410         }
2411 
2412         return false;
2413     };
2414 
2415     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
2416 
2417     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2418         startLocation = tokenLocation();
2419         functionInfo.startLine = tokenLine();
2420         startColumn = tokenColumn();
2421 
2422         parametersStart = m_token.m_location.startOffset;
2423         functionInfo.startOffset = parametersStart;
2424         functionInfo.parametersStartColumn = startColumn;
2425 
2426         if (loadCachedFunction())
2427             return true;
2428 
2429         {
2430             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2431             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2432             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
2433             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2434             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2435             propagateError();
2436         }
2437 
2438         matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
2439 
2440         if (m_lexer-&gt;hasLineTerminatorBeforeToken())
2441             failDueToUnexpectedToken();
2442 
2443         ASSERT(constructorKind == ConstructorKind::None);
2444 
2445         // Check if arrow body start with {. If it true it mean that arrow function is Fat arrow function
2446         // and we need use common approach to parse function body
2447         next();
2448         functionBodyType = match(OPENBRACE) ? ArrowFunctionBodyBlock : ArrowFunctionBodyExpression;
2449     } else {
2450         // http://ecma-international.org/ecma-262/6.0/#sec-function-definitions
2451         // FunctionExpression :
2452         //     function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
2453         //
2454         // FunctionDeclaration[Yield, Default] :
2455         //     function BindingIdentifier[?Yield] ( FormalParameters ) { FunctionBody }
2456         //     [+Default] function ( FormalParameters ) { FunctionBody }
2457         //
2458         // GeneratorDeclaration[Yield, Default] :
2459         //     function * BindingIdentifier[?Yield] ( FormalParameters[Yield] ) { GeneratorBody }
2460         //     [+Default] function * ( FormalParameters[Yield] ) { GeneratorBody }
2461         //
2462         // GeneratorExpression :
2463         //     function * BindingIdentifier[Yield]opt ( FormalParameters[Yield] ) { GeneratorBody }
2464         //
2465         // The name of FunctionExpression and AsyncFunctionExpression can accept &quot;yield&quot; even in the context of generator.
2466         bool upperScopeIsGenerator = false;
2467         if (!(functionDefinitionType == FunctionDefinitionType::Expression &amp;&amp; SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::AsyncFunctionMode).contains(mode)))
2468             upperScopeIsGenerator = upperScope(1)-&gt;isGenerator();
2469 
2470         if (requirements != FunctionNameRequirements::Unnamed) {
2471             ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !functionInfo.name), &quot;When specifying FunctionNameRequirements::None, we need to initialize functionInfo.name with the default value in the caller side.&quot;);
2472             if (matchSpecIdentifier(upperScopeIsGenerator)) {
2473                 functionInfo.name = m_token.m_data.ident;
2474                 m_parserState.lastFunctionName = functionInfo.name;
2475                 if (UNLIKELY(isDisallowedAwaitFunctionName))
2476                     semanticFailIfTrue(functionDefinitionType == FunctionDefinitionType::Declaration || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode), &quot;Cannot declare function named &#39;await&#39; &quot;, isDisallowedAwaitFunctionNameReason);
2477                 else if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode) &amp;&amp; match(AWAIT) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2478                     semanticFail(&quot;Cannot declare &quot;, stringForFunctionMode(mode), &quot; named &#39;await&#39;&quot;);
2479                 else if (isGeneratorWrapperParseMode(mode) &amp;&amp; match(YIELD) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2480                     semanticFail(&quot;Cannot declare generator function named &#39;yield&#39;&quot;);
2481                 next();
2482                 if (!nameIsInContainingScope)
2483                     failIfTrueIfStrict(functionScope-&gt;declareCallee(functionInfo.name) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid &quot;, stringForFunctionMode(mode), &quot; name in strict mode&quot;);
2484             } else if (requirements == FunctionNameRequirements::Named) {
2485                 if (match(OPENPAREN)) {
2486                     semanticFailIfTrue(mode == SourceParseMode::NormalFunctionMode, &quot;Function statements must have a name&quot;);
2487                     semanticFailIfTrue(mode == SourceParseMode::AsyncFunctionMode, &quot;Async function statements must have a name&quot;);
2488                 }
2489                 semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2490                 failDueToUnexpectedToken();
2491                 return false;
2492             }
2493             ASSERT(functionInfo.name);
2494         }
2495 
2496         startLocation = tokenLocation();
2497         functionInfo.startLine = tokenLine();
2498         startColumn = tokenColumn();
2499         functionInfo.parametersStartColumn = startColumn;
2500 
2501         parametersStart = m_token.m_location.startOffset;
2502         functionInfo.startOffset = parametersStart;
2503 
2504         if (loadCachedFunction())
2505             return true;
2506         {
2507             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2508             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2509             propagateError();
2510         }
2511 
2512         matchOrFail(OPENBRACE, &quot;Expected an opening &#39;{&#39; at the start of a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2513 
2514         // If the code is invoked from function constructor, we need to ensure that parameters are only composed by the string offered as parameters.
2515         if (UNLIKELY(functionConstructorParametersEndPosition))
2516             semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
2517 
2518         // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
2519         // Set ConstructorKind to None for non-constructor methods of classes.
2520 
2521         if (m_defaultConstructorKind != ConstructorKind::None) {
2522             constructorKind = m_defaultConstructorKind;
2523             expectedSuperBinding = m_defaultConstructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;
2524         }
2525 
2526         functionBodyType = StandardFunctionBodyBlock;
2527     }
2528 
2529     functionScope-&gt;setConstructorKind(constructorKind);
2530     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2531 
2532     m_parserState.lastFunctionName = lastFunctionName;
2533     ParserState oldState = internalSaveParserState();
2534 
2535     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
2536     // This loop collects the set of capture candidates that aren&#39;t
2537     // part of the set of this function&#39;s declared parameters. We will
2538     // figure out which parameters are captured for this function when
2539     // we actually generate code for it. For now, we just propagate to
2540     // our parent scopes which variables we might have closed over that
2541     // belong to them. This is necessary for correctness when using
2542     // the source provider cache because we can&#39;t close over a variable
2543     // that we don&#39;t claim to close over. The source provider cache must
2544     // know this information to properly cache this function.
2545     // This might work itself out nicer if we declared a different
2546     // Scope struct for the parameters (because they are indeed implemented
2547     // as their own scope).
2548     UniquedStringImplPtrSet nonLocalCapturesFromParameterExpressions;
2549     functionScope-&gt;forEachUsedVariable([&amp;] (UniquedStringImpl* impl) {
2550         if (!functionScope-&gt;hasDeclaredParameter(impl)) {
2551             nonLocalCapturesFromParameterExpressions.add(impl);
2552             if (TreeBuilder::NeedsFreeVariableInfo)
2553                 parentScope-&gt;addClosedVariableCandidateUnconditionally(impl);
2554         }
2555     });
2556 
2557     auto performParsingFunctionBody = [&amp;] {
2558         return parseFunctionBody(context, syntaxChecker, startLocation, startColumn, functionKeywordStart, functionNameStart, parametersStart, constructorKind, expectedSuperBinding, functionBodyType, functionInfo.parameterCount, mode);
2559     };
2560 
2561     if (isGeneratorOrAsyncFunctionWrapperParseMode(mode)) {
2562         AutoPopScopeRef generatorBodyScope(this, pushScope());
2563         SourceParseMode innerParseMode = SourceParseMode::GeneratorBodyMode;
2564         if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode))
2565             innerParseMode = getAsynFunctionBodyParseMode(mode);
2566 
2567         generatorBodyScope-&gt;setSourceParseMode(innerParseMode);
2568         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
2569         generatorBodyScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2570 
2571         // Disallow &#39;use strict&#39; directives in the implicit inner function if
2572         // needed.
2573         if (functionScope-&gt;hasNonSimpleParameterList())
2574             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2575 
2576         functionInfo.body = performParsingFunctionBody();
2577 
2578         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2579         if  (generatorBodyScope-&gt;strictMode())
2580             functionScope-&gt;setStrictMode();
2581 
2582         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2583     } else
2584         functionInfo.body = performParsingFunctionBody();
2585 
2586     restoreParserState(oldState);
2587     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2588     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2589     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2590         ASSERT(functionInfo.name);
2591         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
2592         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2593         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2594     }
2595 
2596     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2597     functionInfo.endOffset = m_token.m_data.offset;
2598 
2599     if (functionBodyType == ArrowFunctionBodyExpression) {
2600         location = locationBeforeLastToken();
2601         functionInfo.endOffset = location.endOffset;
2602     } else {
2603         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2604         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2605     }
2606 
2607     // Cache the tokenizer state and the function scope the first time the function is parsed.
2608     // Any future reparsing can then skip the function.
2609     // For arrow function is 8 = x=&gt;x + 4 symbols;
2610     // For ordinary function is 16  = function(){} + 4 symbols
2611     const int minimumSourceLengthToCache = functionBodyType == StandardFunctionBodyBlock ? 16 : 8;
2612     std::unique_ptr&lt;SourceProviderCacheItem&gt; newInfo;
2613     int sourceLength = functionInfo.endOffset - functionInfo.startOffset;
2614     if (TreeBuilder::CanUseFunctionCache &amp;&amp; m_functionCache &amp;&amp; sourceLength &gt; minimumSourceLengthToCache) {
2615         SourceProviderCacheItemCreationParameters parameters;
2616         parameters.endFunctionOffset = functionInfo.endOffset;
2617         parameters.lastTokenLine = location.line;
2618         parameters.lastTokenStartOffset = location.startOffset;
2619         parameters.lastTokenEndOffset = location.endOffset;
2620         parameters.lastTokenLineStartOffset = location.lineStartOffset;
2621         parameters.parameterCount = functionInfo.parameterCount;
2622         parameters.constructorKind = constructorKind;
2623         parameters.expectedSuperBinding = expectedSuperBinding;
2624         if (functionBodyType == ArrowFunctionBodyExpression) {
2625             parameters.isBodyArrowExpression = true;
2626             parameters.tokenType = m_token.m_type;
2627         }
2628         functionScope-&gt;fillParametersForSourceProviderCache(parameters, nonLocalCapturesFromParameterExpressions);
2629         newInfo = SourceProviderCacheItem::create(parameters);
2630     }
2631 
2632     bool functionScopeWasStrictMode = functionScope-&gt;strictMode();
2633 
2634     popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2635 
2636     if (functionBodyType != ArrowFunctionBodyExpression) {
2637         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2638         next();
2639     } else {
2640         // We need to lex the last token again because the last token is lexed under the different context because of the following possibilities.
2641         // 1. which may have different strict mode.
2642         // 2. which may not build strings for tokens.
2643         // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
2644         // So we only check TreeBuilder&#39;s type here.
2645         ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
2646         if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
2647             lexCurrentTokenAgainUnderCurrentContext();
2648     }
2649 
2650     if (newInfo)
2651         m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
2652 
2653     functionInfo.endLine = m_lastTokenEndPosition.line;
2654     return true;
2655 }
2656 
2657 static NO_RETURN_DUE_TO_CRASH FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
2658 static FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;ASTBuilder&gt;&amp; info) { return info.body; }
2659 
2660 template &lt;typename LexerType&gt;
2661 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2662 {
2663     ASSERT(match(FUNCTION));
2664     JSTokenLocation location(tokenLocation());
2665     unsigned functionKeywordStart = tokenStart();
2666     next();
2667     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
2668     if (consume(TIMES))
2669         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
2670 
2671     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2672     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2673     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2674         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2675         //
2676         //     ExportDeclaration:
2677         //         ...
2678         //         export default HoistableDeclaration[~Yield, +Default]
2679         //         ...
2680         //
2681         //     HoistableDeclaration[Yield, Default]:
2682         //         FunctionDeclaration[?Yield, ?Default]
2683         //         GeneratorDeclaration[?Yield, ?Default]
2684         //
2685         //     FunctionDeclaration[Yield, Default]:
2686         //         ...
2687         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2688         //
2689         //     GeneratorDeclaration[Yield, Default]:
2690         //         ...
2691         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2692         //
2693         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2694         requirements = FunctionNameRequirements::None;
2695         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2696     }
2697 
2698     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
2699     ASSERT(functionInfo.name);
2700 
2701     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2702     DeclarationResultMask declarationResult = functionDeclaration.first;
2703     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2704     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2705         internalFailWithMessage(false, &quot;Cannot declare a function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2706     if (exportType == ExportType::Exported) {
2707         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2708         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2709         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2710     }
2711 
2712     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2713     if (TreeBuilder::CreatesAST)
2714         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2715     return result;
2716 }
2717 
2718 template &lt;typename LexerType&gt;
2719 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseAsyncFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2720 {
2721     ASSERT(match(FUNCTION));
2722     JSTokenLocation location(tokenLocation());
2723     unsigned functionKeywordStart = tokenStart();
2724     next();
2725     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2726     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
2727     if (consume(TIMES))
2728         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
2729 
2730     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2731     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2732         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2733         //
2734         //     ExportDeclaration:
2735         //         ...
2736         //         export default HoistableDeclaration[~Yield, +Default]
2737         //         ...
2738         //
2739         //     HoistableDeclaration[Yield, Default]:
2740         //         FunctionDeclaration[?Yield, ?Default]
2741         //         GeneratorDeclaration[?Yield, ?Default]
2742         //
2743         //     FunctionDeclaration[Yield, Default]:
2744         //         ...
2745         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2746         //
2747         //     GeneratorDeclaration[Yield, Default]:
2748         //         ...
2749         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2750         //
2751         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2752         requirements = FunctionNameRequirements::None;
2753         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2754     }
2755 
2756     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
2757     failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
2758 
2759     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2760     DeclarationResultMask declarationResult = functionDeclaration.first;
2761     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an async function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2762     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2763         internalFailWithMessage(false, &quot;Cannot declare an async function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2764     if (exportType == ExportType::Exported) {
2765         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2766         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2767     }
2768 
2769     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2770     if (TreeBuilder::CreatesAST)
2771         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2772     return result;
2773 }
2774 
2775 template &lt;typename LexerType&gt;
2776 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseClassDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext)
2777 {
2778     ASSERT(match(CLASSTOKEN));
2779     JSTokenLocation location(tokenLocation());
2780     JSTextPosition classStart = tokenStartPosition();
2781     unsigned classStartLine = tokenLine();
2782 
2783     ParserClassInfo&lt;TreeBuilder&gt; info;
2784     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2785     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2786         // Under the &quot;export default&quot; context, class declaration does not require the class name.
2787         //
2788         //     ExportDeclaration:
2789         //         ...
2790         //         export default ClassDeclaration[~Yield, +Default]
2791         //         ...
2792         //
2793         //     ClassDeclaration[Yield, Default]:
2794         //         ...
2795         //         [+Default] class ClassTail[?Yield]
2796         //
2797         // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
2798         requirements = FunctionNameRequirements::None;
2799         info.className = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2800     }
2801 
2802     TreeClassExpression classExpr = parseClass(context, requirements, info);
2803     failIfFalse(classExpr, &quot;Failed to parse class&quot;);
2804     ASSERT(info.className);
2805 
2806     DeclarationResultMask declarationResult = declareVariable(info.className, DeclarationType::LetDeclaration);
2807     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2808         internalFailWithMessage(false, &quot;Cannot declare a class twice: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2809     if (exportType == ExportType::Exported) {
2810         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2811         semanticFailIfFalse(exportName(*info.className), &quot;Cannot export a duplicate class name: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2812         m_moduleScopeData-&gt;exportBinding(*info.className);
2813     }
2814 
2815     JSTextPosition classEnd = lastTokenEndPosition();
2816     unsigned classEndLine = tokenLine();
2817 
2818     return context.createClassDeclStatement(location, classExpr, classStart, classEnd, classStartLine, classEndLine);
2819 }
2820 
2821 template &lt;typename LexerType&gt;
2822 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClass(TreeBuilder&amp; context, FunctionNameRequirements requirements, ParserClassInfo&lt;TreeBuilder&gt;&amp; info)
2823 {
2824     ASSERT(match(CLASSTOKEN));
2825     JSTokenLocation location(tokenLocation());
2826     info.startLine = location.line;
2827     info.startColumn = tokenColumn();
2828     info.startOffset = location.startOffset;
2829     next();
2830 
2831     AutoPopScopeRef classScope(this, pushScope());
2832     classScope-&gt;setIsLexicalScope();
2833     classScope-&gt;preventVarDeclarations();
2834     classScope-&gt;setStrictMode();
2835 
2836     ASSERT_WITH_MESSAGE(requirements != FunctionNameRequirements::Unnamed, &quot;Currently, there is no caller that uses FunctionNameRequirements::Unnamed for class syntax.&quot;);
2837     ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !info.className), &quot;When specifying FunctionNameRequirements::None, we need to initialize info.className with the default value in the caller side.&quot;);
2838     if (match(IDENT)) {
2839         info.className = m_token.m_data.ident;
2840         next();
2841         failIfTrue(classScope-&gt;declareLexicalVariable(info.className, true) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, info.className-&gt;impl(), &quot;&#39; is not a valid class name&quot;);
2842     } else if (requirements == FunctionNameRequirements::Named) {
2843         if (match(OPENBRACE))
2844             semanticFail(&quot;Class statements must have a name&quot;);
2845         semanticFailureDueToKeyword(&quot;class name&quot;);
2846         failDueToUnexpectedToken();
2847     }
2848     ASSERT(info.className);
2849 
2850     TreeExpression parentClass = 0;
2851     if (consume(EXTENDS)) {
2852         parentClass = parseMemberExpression(context);
2853         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2854     }
2855     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2856 
2857     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2858 
2859     TreeExpression constructor = 0;
2860     TreePropertyList classElements = 0;
2861     TreePropertyList classElementsTail = 0;
2862     while (!match(CLOSEBRACE)) {
2863         if (match(SEMICOLON)) {
2864             next();
2865             continue;
2866         }
2867 
2868         JSTokenLocation methodLocation(tokenLocation());
2869         unsigned methodStart = tokenStart();
2870 
2871         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2872         ClassElementTag tag = ClassElementTag::Instance;
2873         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
2874             SavePoint savePoint = createSavePoint();
2875             next();
2876             if (match(OPENPAREN)) {
2877                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
2878                 restoreSavePoint(savePoint);
2879             } else
2880                 tag = ClassElementTag::Static;
2881         }
2882 
2883         // FIXME: Figure out a way to share more code with parseProperty.
2884         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;
2885         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2886         TreeExpression computedPropertyName = 0;
2887         bool isGetter = false;
2888         bool isSetter = false;
2889         SourceParseMode parseMode = SourceParseMode::MethodMode;
2890         if (consume(TIMES))
2891             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2892 
2893 parseMethod:
2894         switch (m_token.m_type) {
2895         namedKeyword:
2896         case STRING:
2897             ident = m_token.m_data.ident;
2898             ASSERT(ident);
2899             next();
2900             break;
2901         case IDENT:
2902             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
2903                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2904                     ident = m_token.m_data.ident;
2905                     next();
2906                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
2907                         break;
2908                     if (UNLIKELY(consume(TIMES)))
2909                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2910                     else
2911                         parseMode = SourceParseMode::AsyncMethodMode;
2912                     goto parseMethod;
2913                 }
2914             }
2915             FALLTHROUGH;
2916         case AWAIT:
2917             ident = m_token.m_data.ident;
2918             ASSERT(ident);
2919             next();
2920             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {
2921                 isGetter = *ident == propertyNames.get;
2922                 isSetter = *ident == propertyNames.set;
2923             }
2924             break;
2925         case DOUBLE:
2926         case INTEGER:
2927             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
2928             ASSERT(ident);
2929             next();
2930             break;
2931         case OPENBRACKET:
2932             next();
2933             computedPropertyName = parseAssignmentExpression(context);
2934             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2935             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2936             break;
2937         default:
2938             if (m_token.m_type &amp; KeywordTokenFlag)
2939                 goto namedKeyword;
2940             failDueToUnexpectedToken();
2941         }
2942 
2943         TreeProperty property;
2944         const bool alwaysStrictInsideClass = true;
2945         if (isGetter || isSetter) {
2946             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,
2947                 methodStart, ConstructorKind::None, tag);
2948             failIfFalse(property, &quot;Cannot parse this method&quot;);
2949         } else {
2950             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2951             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2952             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2953                 isConstructor = false;
2954                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);
2955                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);
2956             }
2957 
2958             methodInfo.name = isConstructor ? info.className : ident;
2959             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2960 
2961             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2962             if (isConstructor) {
2963                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2964                 constructor = method;
2965                 continue;
2966             }
2967 
2968             // FIXME: Syntax error when super() is called
2969             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
2970                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
2971 
2972             if (computedPropertyName) {
2973                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),
2974                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);
2975             } else {
2976                 property = context.createProperty(methodInfo.name, method, PropertyNode::Constant,
2977                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);
2978             }
2979         }
2980 
2981         if (classElementsTail)
2982             classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
2983         else
2984             classElements = classElementsTail = context.createPropertyList(methodLocation, property);
2985     }
2986 
2987     info.endOffset = tokenLocation().endOffset - 1;
2988     consumeOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a class body&quot;);
2989 
2990     auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
2991     popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
2992     return classExpression;
2993 }
2994 
2995 struct LabelInfo {
2996     LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
2997     : m_ident(ident)
2998     , m_start(start)
2999     , m_end(end)
3000     {
3001     }
3002 
3003     const Identifier* m_ident;
3004     JSTextPosition m_start;
3005     JSTextPosition m_end;
3006 };
3007 
3008 template &lt;typename LexerType&gt;
3009 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context, bool allowFunctionDeclarationAsStatement)
3010 {
3011 
3012     /* Expression and Label statements are ambiguous at LL(1), so we have a
3013      * special case that looks for a colon as the next character in the input.
3014      */
3015     Vector&lt;LabelInfo&gt; labels;
3016     JSTokenLocation location;
3017     do {
3018         JSTextPosition start = tokenStartPosition();
3019         location = tokenLocation();
3020         if (!nextTokenIsColon()) {
3021             // If we hit this path we&#39;re making a expression statement, which
3022             // by definition can&#39;t make use of continue/break so we can just
3023             // ignore any labels we might have accumulated.
3024             TreeExpression expression = parseExpression(context);
3025             failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3026             if (!autoSemiColon())
3027                 failDueToUnexpectedToken();
3028             return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3029         }
3030 
3031         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a label &quot;, disallowedIdentifierAwaitReason());
3032         semanticFailIfTrue(isDisallowedIdentifierYield(m_token), &quot;Cannot use &#39;yield&#39; as a label &quot;, disallowedIdentifierYieldReason());
3033 
3034         const Identifier* ident = m_token.m_data.ident;
3035         JSTextPosition end = tokenEndPosition();
3036         next();
3037         consumeOrFail(COLON, &quot;Labels must be followed by a &#39;:&#39;&quot;);
3038 
3039         // This is O(N^2) over the current list of consecutive labels, but I
3040         // have never seen more than one label in a row in the real world.
3041         for (size_t i = 0; i &lt; labels.size(); i++)
3042             failIfTrue(ident-&gt;impl() == labels[i].m_ident-&gt;impl(), &quot;Attempted to redeclare the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3043         failIfTrue(getLabel(ident), &quot;Cannot find scope for the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3044         labels.append(LabelInfo(ident, start, end));
3045     } while (matchSpecIdentifier());
3046     bool isLoop = false;
3047     switch (m_token.m_type) {
3048     case FOR:
3049     case WHILE:
3050     case DO:
3051         isLoop = true;
3052         break;
3053 
3054     default:
3055         break;
3056     }
3057     const Identifier* unused = 0;
3058     ScopeRef labelScope = currentScope();
3059     for (size_t i = 0; i &lt; labels.size(); i++)
3060         pushLabel(labels[i].m_ident, isLoop);
3061     m_immediateParentAllowsFunctionDeclarationInStatement = allowFunctionDeclarationAsStatement;
3062     TreeStatement statement = parseStatement(context, unused);
3063     for (size_t i = 0; i &lt; labels.size(); i++)
3064         popLabel(labelScope);
3065     failIfFalse(statement, &quot;Cannot parse statement&quot;);
3066     for (size_t i = 0; i &lt; labels.size(); i++) {
3067         const LabelInfo&amp; info = labels[labels.size() - i - 1];
3068         statement = context.createLabelStatement(location, info.m_ident, statement, info.m_start, info.m_end);
3069     }
3070     return statement;
3071 }
3072 
3073 template &lt;typename LexerType&gt;
3074 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionStatement(TreeBuilder&amp; context)
3075 {
3076     switch (m_token.m_type) {
3077     // Consult: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-expression-statement
3078     // The ES6 spec mandates that we should fail from FUNCTION token here. We handle this case
3079     // in parseStatement() which is the only caller of parseExpressionStatement().
3080     // We actually allow FUNCTION in situations where it should not be allowed unless we&#39;re in strict mode.
3081     case CLASSTOKEN:
3082         failWithMessage(&quot;&#39;class&#39; declaration is not directly within a block statement&quot;);
3083         break;
3084     default:
3085         // FIXME: when implementing &#39;let&#39; we should fail when we see the token sequence &quot;let [&quot;.
3086         // https://bugs.webkit.org/show_bug.cgi?id=142944
3087         break;
3088     }
3089     JSTextPosition start = tokenStartPosition();
3090     JSTokenLocation location(tokenLocation());
3091     TreeExpression expression = parseExpression(context);
3092     failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3093     failIfFalse(autoSemiColon(), &quot;Parse error&quot;);
3094     return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3095 }
3096 
3097 template &lt;typename LexerType&gt;
3098 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
3099 {
3100     ASSERT(match(IF));
3101     JSTokenLocation ifLocation(tokenLocation());
3102     int start = tokenLine();
3103     next();
3104     handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3105 
3106     TreeExpression condition = parseExpression(context);
3107     failIfFalse(condition, &quot;Expected an expression as the condition for an if statement&quot;);
3108     recordPauseLocation(context.breakpointLocation(condition));
3109     int end = tokenLine();
3110     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3111 
3112     const Identifier* unused = 0;
3113     m_immediateParentAllowsFunctionDeclarationInStatement = true;
3114     TreeStatement trueBlock = parseStatement(context, unused);
3115     failIfFalse(trueBlock, &quot;Expected a statement as the body of an if block&quot;);
3116 
3117     if (!match(ELSE))
3118         return context.createIfStatement(ifLocation, condition, trueBlock, 0, start, end);
3119 
3120     Vector&lt;TreeExpression&gt; exprStack;
3121     Vector&lt;std::pair&lt;int, int&gt;&gt; posStack;
3122     Vector&lt;JSTokenLocation&gt; tokenLocationStack;
3123     Vector&lt;TreeStatement&gt; statementStack;
3124     bool trailingElse = false;
3125     do {
3126         JSTokenLocation tempLocation = tokenLocation();
3127         next();
3128         if (!match(IF)) {
3129             const Identifier* unused = 0;
3130             m_immediateParentAllowsFunctionDeclarationInStatement = true;
3131             TreeStatement block = parseStatement(context, unused);
3132             failIfFalse(block, &quot;Expected a statement as the body of an else block&quot;);
3133             statementStack.append(block);
3134             trailingElse = true;
3135             break;
3136         }
3137         int innerStart = tokenLine();
3138         next();
3139 
3140         handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3141 
3142         TreeExpression innerCondition = parseExpression(context);
3143         failIfFalse(innerCondition, &quot;Expected an expression as the condition for an if statement&quot;);
3144         recordPauseLocation(context.breakpointLocation(innerCondition));
3145         int innerEnd = tokenLine();
3146         handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3147         const Identifier* unused = 0;
3148         m_immediateParentAllowsFunctionDeclarationInStatement = true;
3149         TreeStatement innerTrueBlock = parseStatement(context, unused);
3150         failIfFalse(innerTrueBlock, &quot;Expected a statement as the body of an if block&quot;);
3151         tokenLocationStack.append(tempLocation);
3152         exprStack.append(innerCondition);
3153         posStack.append(std::make_pair(innerStart, innerEnd));
3154         statementStack.append(innerTrueBlock);
3155     } while (match(ELSE));
3156 
3157     if (!trailingElse) {
3158         TreeExpression condition = exprStack.last();
3159         exprStack.removeLast();
3160         TreeStatement trueBlock = statementStack.last();
3161         statementStack.removeLast();
3162         std::pair&lt;int, int&gt; pos = posStack.last();
3163         posStack.removeLast();
3164         JSTokenLocation elseLocation = tokenLocationStack.last();
3165         tokenLocationStack.removeLast();
3166         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, 0, pos.first, pos.second);
3167         context.setEndOffset(ifStatement, context.endOffset(trueBlock));
3168         statementStack.append(ifStatement);
3169     }
3170 
3171     while (!exprStack.isEmpty()) {
3172         TreeExpression condition = exprStack.last();
3173         exprStack.removeLast();
3174         TreeStatement falseBlock = statementStack.last();
3175         statementStack.removeLast();
3176         TreeStatement trueBlock = statementStack.last();
3177         statementStack.removeLast();
3178         std::pair&lt;int, int&gt; pos = posStack.last();
3179         posStack.removeLast();
3180         JSTokenLocation elseLocation = tokenLocationStack.last();
3181         tokenLocationStack.removeLast();
3182         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, falseBlock, pos.first, pos.second);
3183         context.setEndOffset(ifStatement, context.endOffset(falseBlock));
3184         statementStack.append(ifStatement);
3185     }
3186 
3187     return context.createIfStatement(ifLocation, condition, trueBlock, statementStack.last(), start, end);
3188 }
3189 
3190 template &lt;typename LexerType&gt;
3191 template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName Parser&lt;LexerType&gt;::parseModuleName(TreeBuilder&amp; context)
3192 {
3193     // ModuleName (ModuleSpecifier in the spec) represents the module name imported by the script.
3194     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3195     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3196     JSTokenLocation specifierLocation(tokenLocation());
3197     failIfFalse(match(STRING), &quot;Imported modules names must be string literals&quot;);
3198     const Identifier* moduleName = m_token.m_data.ident;
3199     next();
3200     return context.createModuleName(specifierLocation, *moduleName);
3201 }
3202 
3203 template &lt;typename LexerType&gt;
3204 template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier Parser&lt;LexerType&gt;::parseImportClauseItem(TreeBuilder&amp; context, ImportSpecifierType specifierType)
3205 {
3206     // Produced node is the item of the ImportClause.
3207     // That is the ImportSpecifier, ImportedDefaultBinding or NameSpaceImport.
3208     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3209     JSTokenLocation specifierLocation(tokenLocation());
3210     JSToken localNameToken;
3211     const Identifier* importedName = nullptr;
3212     const Identifier* localName = nullptr;
3213 
3214     switch (specifierType) {
3215     case ImportSpecifierType::NamespaceImport: {
3216         // NameSpaceImport :
3217         // * as ImportedBinding
3218         // e.g.
3219         //     * as namespace
3220         ASSERT(match(TIMES));
3221         importedName = &amp;m_vm.propertyNames-&gt;timesIdentifier;
3222         next();
3223 
3224         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);
3225         next();
3226 
3227         failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3228         localNameToken = m_token;
3229         localName = m_token.m_data.ident;
3230         next();
3231         break;
3232     }
3233 
3234     case ImportSpecifierType::NamedImport: {
3235         // ImportSpecifier :
3236         // ImportedBinding
3237         // IdentifierName as ImportedBinding
3238         // e.g.
3239         //     A
3240         //     A as B
3241         ASSERT(matchIdentifierOrKeyword());
3242         localNameToken = m_token;
3243         localName = m_token.m_data.ident;
3244         importedName = localName;
3245         next();
3246 
3247         if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3248             next();
3249             failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3250             localNameToken = m_token;
3251             localName = m_token.m_data.ident;
3252             next();
3253         }
3254         break;
3255     }
3256 
3257     case ImportSpecifierType::DefaultImport: {
3258         // ImportedDefaultBinding :
3259         // ImportedBinding
3260         ASSERT(matchSpecIdentifier());
3261         localNameToken = m_token;
3262         localName = m_token.m_data.ident;
3263         importedName = &amp;m_vm.propertyNames-&gt;defaultKeyword;
3264         next();
3265         break;
3266     }
3267     }
3268 
3269     semanticFailIfTrue(localNameToken.m_type == AWAIT, &quot;Cannot use &#39;await&#39; as an imported binding name&quot;);
3270     semanticFailIfTrue(localNameToken.m_type &amp; KeywordTokenFlag, &quot;Cannot use keyword as imported binding name&quot;);
3271     DeclarationResultMask declarationResult = declareVariable(localName, DeclarationType::ConstDeclaration, (specifierType == ImportSpecifierType::NamespaceImport) ? DeclarationImportType::ImportedNamespace : DeclarationImportType::Imported);
3272     if (declarationResult != DeclarationResult::Valid) {
3273         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an imported binding named &quot;, localName-&gt;impl(), &quot; in strict mode&quot;);
3274         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3275             internalFailWithMessage(false, &quot;Cannot declare an imported binding name twice: &#39;&quot;, localName-&gt;impl(), &quot;&#39;&quot;);
3276     }
3277 
3278     return context.createImportSpecifier(specifierLocation, *importedName, *localName);
3279 }
3280 
3281 template &lt;typename LexerType&gt;
3282 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseImportDeclaration(TreeBuilder&amp; context)
3283 {
3284     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3285     ASSERT(match(IMPORT));
3286     JSTokenLocation importLocation(tokenLocation());
3287     next();
3288 
3289     auto specifierList = context.createImportSpecifierList();
3290 
3291     if (match(STRING)) {
3292         // import ModuleSpecifier ;
3293         auto moduleName = parseModuleName(context);
3294         failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3295         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3296         return context.createImportDeclaration(importLocation, specifierList, moduleName);
3297     }
3298 
3299     bool isFinishedParsingImport = false;
3300     if (matchSpecIdentifier()) {
3301         // ImportedDefaultBinding :
3302         // ImportedBinding
3303         auto specifier = parseImportClauseItem(context, ImportSpecifierType::DefaultImport);
3304         failIfFalse(specifier, &quot;Cannot parse the default import&quot;);
3305         context.appendImportSpecifier(specifierList, specifier);
3306         if (match(COMMA))
3307             next();
3308         else
3309             isFinishedParsingImport = true;
3310     }
3311 
3312     if (!isFinishedParsingImport) {
3313         if (match(TIMES)) {
3314             // import NameSpaceImport FromClause ;
3315             auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamespaceImport);
3316             failIfFalse(specifier, &quot;Cannot parse the namespace import&quot;);
3317             context.appendImportSpecifier(specifierList, specifier);
3318         } else if (match(OPENBRACE)) {
3319             // NamedImports :
3320             // { }
3321             // { ImportsList }
3322             // { ImportsList , }
3323             next();
3324 
3325             while (!match(CLOSEBRACE)) {
3326                 failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an imported name for the import declaration&quot;);
3327                 auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamedImport);
3328                 failIfFalse(specifier, &quot;Cannot parse the named import&quot;);
3329                 context.appendImportSpecifier(specifierList, specifier);
3330                 if (!consume(COMMA))
3331                     break;
3332             }
3333             handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;import list&quot;);
3334         } else
3335             failWithMessage(&quot;Expected namespace import or import list&quot;);
3336     }
3337 
3338     // FromClause :
3339     // from ModuleSpecifier
3340 
3341     failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);
3342     next();
3343 
3344     auto moduleName = parseModuleName(context);
3345     failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3346     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3347 
3348     return context.createImportDeclaration(importLocation, specifierList, moduleName);
3349 }
3350 
3351 template &lt;typename LexerType&gt;
3352 template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier Parser&lt;LexerType&gt;::parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings)
3353 {
3354     // ExportSpecifier :
3355     // IdentifierName
3356     // IdentifierName as IdentifierName
3357     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3358     ASSERT(matchIdentifierOrKeyword());
3359     JSTokenLocation specifierLocation(tokenLocation());
3360     if (m_token.m_type &amp; KeywordTokenFlag)
3361         hasKeywordForLocalBindings = true;
3362     const Identifier* localName = m_token.m_data.ident;
3363     const Identifier* exportedName = localName;
3364     next();
3365 
3366     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3367         next();
3368         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3369         exportedName = m_token.m_data.ident;
3370         next();
3371     }
3372 
3373     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3374     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3375     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3376 }
3377 
3378 template &lt;typename LexerType&gt;
3379 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3380 {
3381     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3382     ASSERT(match(EXPORT));
3383     JSTokenLocation exportLocation(tokenLocation());
3384     next();
3385 
3386     switch (m_token.m_type) {
3387     case TIMES: {
3388         // export * FromClause ;
3389         next();
3390 
3391         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);
3392         next();
3393         auto moduleName = parseModuleName(context);
3394         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3395         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3396 
3397         return context.createExportAllDeclaration(exportLocation, moduleName);
3398     }
3399 
3400     case DEFAULT: {
3401         // export default HoistableDeclaration[Default]
3402         // export default ClassDeclaration[Default]
3403         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3404 
3405         next();
3406 
3407         TreeStatement result = 0;
3408         bool isFunctionOrClassDeclaration = false;
3409         const Identifier* localName = nullptr;
3410 
3411         bool startsWithFunction = match(FUNCTION);
3412         if (startsWithFunction || match(CLASSTOKEN)) {
3413             SavePoint savePoint = createSavePoint();
3414             isFunctionOrClassDeclaration = true;
3415             next();
3416 
3417             // ES6 Generators
3418             if (startsWithFunction &amp;&amp; match(TIMES))
3419                 next();
3420             if (match(IDENT))
3421                 localName = m_token.m_data.ident;
3422             restoreSavePoint(savePoint);
3423         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3424             SavePoint savePoint = createSavePoint();
3425             next();
3426             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3427                 next();
3428                 if (match(IDENT))
3429                     localName = m_token.m_data.ident;
3430                 isFunctionOrClassDeclaration = true;
3431             }
3432             restoreSavePoint(savePoint);
3433         }
3434 
3435         if (!localName)
3436             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
3437 
3438         if (isFunctionOrClassDeclaration) {
3439             if (startsWithFunction) {
3440                 ASSERT(match(FUNCTION));
3441                 DepthManager statementDepth(&amp;m_statementDepth);
3442                 m_statementDepth = 1;
3443                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3444             } else if (match(CLASSTOKEN)) {
3445                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3446             } else {
3447                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
3448                 next();
3449                 DepthManager statementDepth(&amp;m_statementDepth);
3450                 m_statementDepth = 1;
3451                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3452             }
3453         } else {
3454             // export default expr;
3455             //
3456             // It should be treated as the same to the following.
3457             //
3458             // const *default* = expr;
3459             // export { *default* as default }
3460             //
3461             // In the above example, *default* is the invisible variable to the users.
3462             // We use the private symbol to represent the name of this variable.
3463             JSTokenLocation location(tokenLocation());
3464             JSTextPosition start = tokenStartPosition();
3465             TreeExpression expression = parseAssignmentExpression(context);
3466             failIfFalse(expression, &quot;Cannot parse expression&quot;);
3467 
3468             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm.propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);
3469             if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3470                 internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
3471 
3472             TreeExpression assignment = context.createAssignResolve(location, m_vm.propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);
3473             result = context.createExprStatement(location, assignment, start, tokenEndPosition());
3474             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3475         }
3476         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3477 
3478         semanticFailIfFalse(exportName(m_vm.propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);
3479         m_moduleScopeData-&gt;exportBinding(*localName, m_vm.propertyNames-&gt;defaultKeyword);
3480         return context.createExportDefaultDeclaration(exportLocation, result, *localName);
3481     }
3482 
3483     case OPENBRACE: {
3484         // export ExportClause FromClause ;
3485         // export ExportClause ;
3486         //
3487         // ExportClause :
3488         // { }
3489         // { ExportsList }
3490         // { ExportsList , }
3491         //
3492         // ExportsList :
3493         // ExportSpecifier
3494         // ExportsList , ExportSpecifier
3495 
3496         next();
3497 
3498         auto specifierList = context.createExportSpecifierList();
3499         Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt; maybeExportedLocalNames;
3500 
3501         bool hasKeywordForLocalBindings = false;
3502         while (!match(CLOSEBRACE)) {
3503             failIfFalse(matchIdentifierOrKeyword(), &quot;Expected a variable name for the export declaration&quot;);
3504             auto specifier = parseExportSpecifier(context, maybeExportedLocalNames, hasKeywordForLocalBindings);
3505             failIfFalse(specifier, &quot;Cannot parse the named export&quot;);
3506             context.appendExportSpecifier(specifierList, specifier);
3507             if (!consume(COMMA))
3508                 break;
3509         }
3510         handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
3511 
3512         typename TreeBuilder::ModuleName moduleName = 0;
3513         if (matchContextualKeyword(m_vm.propertyNames-&gt;from)) {
3514             next();
3515             moduleName = parseModuleName(context);
3516             failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3517         }
3518         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3519 
3520         if (!moduleName) {
3521             semanticFailIfTrue(hasKeywordForLocalBindings, &quot;Cannot use keyword as exported variable name&quot;);
3522             // Since this export declaration does not have module specifier part, it exports the local bindings.
3523             // While the export declaration with module specifier does not have any effect on the current module&#39;s scope,
3524             // the export named declaration without module specifier references the local binding names.
3525             // For example,
3526             //   export { A, B, C as D } from &quot;mod&quot;
3527             // does not have effect on the current module&#39;s scope. But,
3528             //   export { A, B, C as D }
3529             // will reference the current module&#39;s bindings.
3530             for (const auto&amp; pair : maybeExportedLocalNames) {
3531                 const Identifier* localName = pair.first;
3532                 const Identifier* exportedName = pair.second;
3533                 m_moduleScopeData-&gt;exportBinding(*localName, *exportedName);
3534             }
3535         }
3536 
3537         return context.createExportNamedDeclaration(exportLocation, specifierList, moduleName);
3538     }
3539 
3540     default: {
3541         // export VariableStatement
3542         // export Declaration
3543         TreeStatement result = 0;
3544         switch (m_token.m_type) {
3545         case VAR:
3546             result = parseVariableDeclaration(context, DeclarationType::VarDeclaration, ExportType::Exported);
3547             break;
3548 
3549         case CONSTTOKEN:
3550             result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration, ExportType::Exported);
3551             break;
3552 
3553         case LET:
3554             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration, ExportType::Exported);
3555             break;
3556 
3557         case FUNCTION: {
3558             DepthManager statementDepth(&amp;m_statementDepth);
3559             m_statementDepth = 1;
3560             result = parseFunctionDeclaration(context, ExportType::Exported);
3561             break;
3562         }
3563 
3564         case CLASSTOKEN:
3565             result = parseClassDeclaration(context, ExportType::Exported);
3566             break;
3567 
3568         case IDENT:
3569             if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {
3570                 next();
3571                 semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
3572                 DepthManager statementDepth(&amp;m_statementDepth);
3573                 m_statementDepth = 1;
3574                 result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
3575                 break;
3576             }
3577             FALLTHROUGH;
3578         default:
3579             failWithMessage(&quot;Expected either a declaration or a variable statement&quot;);
3580             break;
3581         }
3582 
3583         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3584         return context.createExportLocalDeclaration(exportLocation, result);
3585     }
3586     }
3587 
3588     RELEASE_ASSERT_NOT_REACHED();
3589     return 0;
3590 }
3591 
3592 template &lt;typename LexerType&gt;
3593 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseExpression(TreeBuilder&amp; context)
3594 {
3595     failIfStackOverflow();
3596     JSTokenLocation location(tokenLocation());
3597     TreeExpression node = parseAssignmentExpression(context);
3598     failIfFalse(node, &quot;Cannot parse expression&quot;);
3599     context.setEndOffset(node, m_lastTokenEndPosition.offset);
3600     if (!match(COMMA))
3601         return node;
3602     next();
3603     m_parserState.nonTrivialExpressionCount++;
3604     m_parserState.nonLHSCount++;
3605     TreeExpression right = parseAssignmentExpression(context);
3606     failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3607     context.setEndOffset(right, m_lastTokenEndPosition.offset);
3608     typename TreeBuilder::Comma head = context.createCommaExpr(location, node);
3609     typename TreeBuilder::Comma tail = context.appendToCommaExpr(location, head, head, right);
3610     while (match(COMMA)) {
3611         next(TreeBuilder::DontBuildStrings);
3612         right = parseAssignmentExpression(context);
3613         failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3614         context.setEndOffset(right, m_lastTokenEndPosition.offset);
3615         tail = context.appendToCommaExpr(location, head, tail, right);
3616     }
3617     context.setEndOffset(head, m_lastTokenEndPosition.offset);
3618     return head;
3619 }
3620 
3621 template &lt;typename LexerType&gt;
3622 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp; context)
3623 {
3624     ExpressionErrorClassifier classifier(this);
3625     auto assignment = parseAssignmentExpression(context, classifier);
3626     if (!assignment)
3627         classifier.propagateExpressionErrorClass();
3628     return assignment;
3629 }
3630 
3631 template &lt;typename LexerType&gt;
3632 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
3633 {
3634     ExpressionErrorClassifier classifier(this);
3635     return parseAssignmentExpression(context, classifier);
3636 }
3637 
3638 
3639 template &lt;typename LexerType&gt;
3640 template &lt;typename TreeBuilder&gt; NEVER_INLINE const char* Parser&lt;LexerType&gt;::metaPropertyName(TreeBuilder&amp; context, TreeExpression expr)
3641 {
3642     if (context.isNewTarget(expr))
3643         return &quot;new.target&quot;;
3644     if (context.isImportMeta(expr))
3645         return &quot;import.meta&quot;;
3646     RELEASE_ASSERT_NOT_REACHED();
3647     return &quot;error&quot;;
3648 }
3649 
3650 template &lt;typename LexerType&gt;
3651 template &lt;typename TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isSimpleAssignmentTarget(TreeBuilder&amp; context, TreeExpression expr)
3652 {
3653     // Web compatibility concerns prevent us from handling a function call LHS as an early error in sloppy mode.
3654     // This behavior is currently unspecified, but see: https://github.com/tc39/ecma262/issues/257#issuecomment-195106880
3655     return context.isLocation(expr) || (!strictMode() &amp;&amp; context.isFunctionCall(expr));
3656 }
3657 
3658 template &lt;typename LexerType&gt;
3659 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3660 {
3661     ASSERT(!hasError());
3662 
3663     failIfStackOverflow();
3664 
3665     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3666         return parseYieldExpression(context);
3667 
3668     JSTextPosition start = tokenStartPosition();
3669     JSTokenLocation location(tokenLocation());
3670     int initialAssignmentCount = m_parserState.assignmentCount;
3671     int initialNonLHSCount = m_parserState.nonLHSCount;
3672     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3673     bool wasOpenParen = match(OPENPAREN);
3674     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3675     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3676     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3677     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
3678     SavePoint savePoint = createSavePoint();
3679     size_t usedVariablesSize = 0;
3680 
3681     if (wasOpenParen) {
3682         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3683         currentScope()-&gt;pushUsedVariableSet();
3684     }
3685 
3686     TreeExpression lhs = parseConditionalExpression(context);
3687 
3688     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3689         bool isArrowFunctionToken = match(ARROWFUNCTION);
3690         if (!lhs || isArrowFunctionToken) {
3691             SavePointWithError errorRestorationSavePoint = createSavePointForError();
3692             restoreSavePoint(savePoint);
3693             bool isAsyncArrow = false;
3694             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
3695                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3696                     next();
3697                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3698                 }
3699             }
3700             if (isArrowFunctionParameters()) {
3701                 if (wasOpenParen)
3702                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3703                 return parseArrowFunctionExpression(context, isAsyncArrow);
3704             }
3705             if (isArrowFunctionToken)
3706                 propagateError();
3707             restoreSavePointWithError(errorRestorationSavePoint);
3708             if (isArrowFunctionToken)
3709                 failDueToUnexpectedToken();
3710         }
3711     }
3712 
3713     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3714         propagateError();
3715 
3716     if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
3717         SavePointWithError expressionErrorLocation = createSavePointForError();
3718         restoreSavePoint(savePoint);
3719         auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
3720         if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
3721             restoreSavePointWithError(expressionErrorLocation);
3722             return 0;
3723         }
3724         failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
3725         consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
3726         auto rhs = parseAssignmentExpression(context);
3727         if (!rhs)
3728             propagateError();
3729         return context.createDestructuringAssignment(location, pattern, rhs);
3730     }
3731 
3732     failIfFalse(lhs, &quot;Cannot parse expression&quot;);
3733     if (initialNonLHSCount != m_parserState.nonLHSCount) {
3734         if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3735             semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3736 
3737         return lhs;
3738     }
3739 
3740     int assignmentStack = 0;
3741     Operator op;
3742     bool hadAssignment = false;
3743     while (true) {
3744         switch (m_token.m_type) {
3745         case EQUAL: op = OpEqual; break;
3746         case PLUSEQUAL: op = OpPlusEq; break;
3747         case MINUSEQUAL: op = OpMinusEq; break;
3748         case MULTEQUAL: op = OpMultEq; break;
3749         case DIVEQUAL: op = OpDivEq; break;
3750         case LSHIFTEQUAL: op = OpLShift; break;
3751         case RSHIFTEQUAL: op = OpRShift; break;
3752         case URSHIFTEQUAL: op = OpURShift; break;
3753         case ANDEQUAL: op = OpAndEq; break;
3754         case XOREQUAL: op = OpXOrEq; break;
3755         case OREQUAL: op = OpOrEq; break;
3756         case MODEQUAL: op = OpModEq; break;
3757         case POWEQUAL: op = OpPowEq; break;
3758         default:
3759             goto end;
3760         }
3761         m_parserState.nonTrivialExpressionCount++;
3762         hadAssignment = true;
3763         semanticFailIfTrue(context.isMetaProperty(lhs), metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);
3764         semanticFailIfFalse(isSimpleAssignmentTarget(context, lhs), &quot;Left side of assignment is not a reference&quot;);
3765         context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
3766         start = tokenStartPosition();
3767         m_parserState.assignmentCount++;
3768         next(TreeBuilder::DontBuildStrings);
3769         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
3770             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);
3771             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);
3772             m_parserState.lastIdentifier = 0;
3773         }
3774         lhs = parseAssignmentExpression(context);
3775         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3776         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3777             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3778                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3779             break;
3780         }
3781     }
3782 end:
3783     if (hadAssignment)
3784         m_parserState.nonLHSCount++;
3785 
3786     if (!TreeBuilder::CreatesAST)
3787         return lhs;
3788 
3789     while (assignmentStack)
3790         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3791 
3792     return lhs;
3793 }
3794 
3795 template &lt;typename LexerType&gt;
3796 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseYieldExpression(TreeBuilder&amp; context)
3797 {
3798     // YieldExpression[In] :
3799     //     yield
3800     //     yield [no LineTerminator here] AssignmentExpression[?In, Yield]
3801     //     yield [no LineTerminator here] * AssignmentExpression[?In, Yield]
3802 
3803     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions
3804     failIfFalse(currentScope()-&gt;isGenerator() &amp;&amp; !currentScope()-&gt;isArrowFunctionBoundary(), &quot;Cannot use yield expression out of generator&quot;);
3805 
3806     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
3807     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
3808 
3809     JSTokenLocation location(tokenLocation());
3810     JSTextPosition divotStart = tokenStartPosition();
3811     ASSERT(match(YIELD));
3812     SavePoint savePoint = createSavePoint();
3813     next();
3814     if (m_lexer-&gt;hasLineTerminatorBeforeToken())
3815         return context.createYield(location);
3816 
3817     bool delegate = consume(TIMES);
3818     JSTextPosition argumentStart = tokenStartPosition();
3819     TreeExpression argument = parseAssignmentExpression(context);
3820     if (!argument) {
3821         restoreSavePoint(savePoint);
3822         next();
3823         return context.createYield(location);
3824     }
3825     return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
3826 }
3827 
3828 template &lt;typename LexerType&gt;
3829 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
3830 {
3831     ASSERT(match(AWAIT));
3832     ASSERT(currentScope()-&gt;isAsyncFunction());
3833     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use await expression within parameters&quot;);
3834     JSTokenLocation location(tokenLocation());
3835     JSTextPosition divotStart = tokenStartPosition();
3836     next();
3837     JSTextPosition argumentStart = tokenStartPosition();
3838     ExpressionErrorClassifier classifier(this);
3839     TreeExpression argument = parseUnaryExpression(context);
3840     failIfFalse(argument, &quot;Failed to parse await expression&quot;);
3841     return context.createAwait(location, argument, divotStart, argumentStart, lastTokenEndPosition());
3842 }
3843 
3844 template &lt;typename LexerType&gt;
3845 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
3846 {
3847     JSTokenLocation location(tokenLocation());
3848     TreeExpression cond = parseBinaryExpression(context);
3849     failIfFalse(cond, &quot;Cannot parse expression&quot;);
3850     if (!match(QUESTION))
3851         return cond;
3852     m_parserState.nonTrivialExpressionCount++;
3853     m_parserState.nonLHSCount++;
3854     next(TreeBuilder::DontBuildStrings);
3855     TreeExpression lhs = parseAssignmentExpression(context);
3856     failIfFalse(lhs, &quot;Cannot parse left hand side of ternary operator&quot;);
3857     context.setEndOffset(lhs, m_lastTokenEndPosition.offset);
3858     consumeOrFailWithFlags(COLON, TreeBuilder::DontBuildStrings, &quot;Expected &#39;:&#39; in ternary operator&quot;);
3859 
3860     TreeExpression rhs = parseAssignmentExpression(context);
3861     failIfFalse(rhs, &quot;Cannot parse right hand side of ternary operator&quot;);
3862     context.setEndOffset(rhs, m_lastTokenEndPosition.offset);
3863     return context.createConditionalExpr(location, cond, lhs, rhs);
3864 }
3865 
3866 ALWAYS_INLINE static bool isUnaryOpExcludingUpdateOp(JSTokenType token)
3867 {
3868     if (isUpdateOp(token))
3869         return false;
3870     return isUnaryOp(token);
3871 }
3872 
3873 template &lt;typename LexerType&gt;
3874 int Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
3875 {
3876     if (m_allowsIn)
3877         return token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
3878     return token &amp; BinaryOpTokenPrecedenceMask;
3879 }
3880 
3881 template &lt;typename LexerType&gt;
3882 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
3883 {
3884     int operandStackDepth = 0;
3885     int operatorStackDepth = 0;
3886     typename TreeBuilder::BinaryExprContext binaryExprContext(context);
3887     JSTokenLocation location(tokenLocation());
3888     bool hasLogicalOperator = false;
3889     bool hasCoalesceOperator = false;
3890 
3891     while (true) {
3892         JSTextPosition exprStart = tokenStartPosition();
3893         int initialAssignments = m_parserState.assignmentCount;
3894         JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
3895         TreeExpression current = parseUnaryExpression(context);
3896         failIfFalse(current, &quot;Cannot parse expression&quot;);
3897 
3898         context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);
3899         int precedence = isBinaryOperator(m_token.m_type);
3900         if (!precedence)
3901             break;
3902 
3903         // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
3904         // ExponentiationExpresion is described as follows.
3905         //
3906         //     ExponentiationExpression[Yield]:
3907         //         UnaryExpression[?Yield]
3908         //         UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
3909         //
3910         // As we can see, the left hand side of the ExponentiationExpression is UpdateExpression, not UnaryExpression.
3911         // So placing UnaryExpression not included in UpdateExpression here is a syntax error.
3912         // This is intentional. For example, if UnaryExpression is allowed, we can have the code like `-x**y`.
3913         // But this is confusing: `-(x**y)` OR `(-x)**y`, which interpretation is correct?
3914         // To avoid this problem, ECMA262 makes unparenthesized exponentiation expression as operand of unary operators an early error.
3915         // More rationale: https://mail.mozilla.org/pipermail/es-discuss/2015-September/044232.html
3916         //
3917         // Here, we guarantee that the left hand side of this expression is not unary expression by checking the leading operator of the parseUnaryExpression.
3918         // This check just works. Let&#39;s consider the example,
3919         //     y &lt;&gt; -x ** z
3920         //          ^
3921         //          Check this.
3922         // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
3923         // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
3924         failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
3925 
3926         // Mixing ?? with || or &amp;&amp; is currently specified as an early error.
3927         // Since ?? is the lowest-precedence binary operator, it suffices to check whether these ever coexist in the operator stack.
3928         if (match(AND) || match(OR))
3929             hasLogicalOperator = true;
3930         else if (match(COALESCE))
3931             hasCoalesceOperator = true;
3932         failIfTrue(hasLogicalOperator &amp;&amp; hasCoalesceOperator, &quot;Coalescing and logical operators used together in the same expression; parentheses must be used to disambiguate&quot;);
3933 
3934         m_parserState.nonTrivialExpressionCount++;
3935         m_parserState.nonLHSCount++;
3936         int operatorToken = m_token.m_type;
3937         next(TreeBuilder::DontBuildStrings);
3938 
3939         while (operatorStackDepth &amp;&amp; context.operatorStackShouldReduce(precedence)) {
3940             ASSERT(operandStackDepth &gt; 1);
3941 
3942             typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3943             typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3944             context.shrinkOperandStackBy(operandStackDepth, 2);
3945             context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3946             context.operatorStackPop(operatorStackDepth);
3947         }
3948         context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
3949     }
3950     while (operatorStackDepth) {
3951         ASSERT(operandStackDepth &gt; 1);
3952 
3953         typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
3954         typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
3955         context.shrinkOperandStackBy(operandStackDepth, 2);
3956         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3957         context.operatorStackPop(operatorStackDepth);
3958     }
3959     return context.popOperandStack(operandStackDepth);
3960 }
3961 
3962 template &lt;typename LexerType&gt;
3963 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
3964 {
3965     SourceParseMode parseMode = SourceParseMode::MethodMode;
3966     bool wasIdent = false;
3967 
3968     if (consume(TIMES))
3969         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
3970 
3971 parseProperty:
3972     switch (m_token.m_type) {
3973     case IDENT:
3974         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
3975             if (parseMode == SourceParseMode::MethodMode) {
3976                 SavePoint savePoint = createSavePoint();
3977                 next();
3978 
3979                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
3980                     restoreSavePoint(savePoint);
3981                     wasIdent = true;
3982                     goto namedProperty;
3983                 }
3984 
3985                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
3986                 if (UNLIKELY(consume(TIMES)))
3987                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
3988                 else
3989                     parseMode = SourceParseMode::AsyncMethodMode;
3990                 goto parseProperty;
3991             }
3992         }
3993         FALLTHROUGH;
3994     case YIELD:
3995     case AWAIT:
3996         wasIdent = true;
3997         FALLTHROUGH;
3998     case STRING: {
3999 namedProperty:
4000         const Identifier* ident = m_token.m_data.ident;
4001         unsigned getterOrSetterStartOffset = tokenStart();
4002         JSToken identToken = m_token;
4003 
4004         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
4005             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
4006         else
4007             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
4008 
4009         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
4010             next();
4011             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
4012             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4013             context.setEndOffset(node, m_lexer-&gt;currentOffset());
4014             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;
4015             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
4016         }
4017 
4018         if (match(OPENPAREN)) {
4019             auto method = parsePropertyMethod(context, ident, parseMode);
4020             propagateError();
4021             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4022         }
4023         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4024 
4025         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
4026 
4027         if (match(COMMA) || match(CLOSEBRACE)) {
4028             semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
4029             JSTextPosition start = tokenStartPosition();
4030             JSTokenLocation location(tokenLocation());
4031             currentScope()-&gt;useVariable(ident, m_vm.propertyNames-&gt;eval == *ident);
4032             if (currentScope()-&gt;isArrowFunction())
4033                 currentScope()-&gt;setInnerArrowFunctionUsesEval();
4034             TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
4035             return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4036         }
4037 
4038         if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
4039             classifyExpressionError(ErrorIndicatesPattern);
4040 
4041         PropertyNode::Type type;
4042         if (*ident == m_vm.propertyNames-&gt;get)
4043             type = PropertyNode::Getter;
4044         else if (*ident == m_vm.propertyNames-&gt;set)
4045             type = PropertyNode::Setter;
4046         else
4047             failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
4048         return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
4049     }
4050     case DOUBLE:
4051     case INTEGER: {
4052         double propertyName = m_token.m_data.doubleValue;
4053         next();
4054 
4055         if (match(OPENPAREN)) {
4056             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);
4057             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4058             propagateError();
4059             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4060         }
4061         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4062 
4063         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4064         TreeExpression node = parseAssignmentExpression(context);
4065         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4066         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4067         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4068     }
4069     case OPENBRACKET: {
4070         next();
4071         auto propertyName = parseAssignmentExpression(context);
4072         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4073         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4074 
4075         if (match(OPENPAREN)) {
4076             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);
4077             propagateError();
4078             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4079         }
4080         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4081 
4082         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4083         TreeExpression node = parseAssignmentExpression(context);
4084         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4085         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4086         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4087     }
4088     case DOTDOTDOT: {
4089         auto spreadLocation = m_token.m_location;
4090         auto start = m_token.m_startPosition;
4091         auto divot = m_token.m_endPosition;
4092         next();
4093         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4094         failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4095         auto node = context.createObjectSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4096         return context.createProperty(node, PropertyNode::Spread, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4097     }
4098     default:
4099         failIfFalse(m_token.m_type &amp; KeywordTokenFlag, &quot;Expected a property name&quot;);
4100         wasIdent = true; // Treat keyword token as an identifier
4101         goto namedProperty;
4102     }
4103 }
4104 
4105 template &lt;typename LexerType&gt;
4106 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode parseMode)
4107 {
4108     ASSERT(isMethodParseMode(parseMode));
4109     JSTokenLocation methodLocation(tokenLocation());
4110     unsigned methodStart = tokenStart();
4111     ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
4112     methodInfo.name = methodName;
4113     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
4114     return context.createMethodDefinition(methodLocation, methodInfo);
4115 }
4116 
4117 template &lt;typename LexerType&gt;
4118 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4119     ConstructorKind constructorKind, ClassElementTag tag)
4120 {
4121     const Identifier* stringPropertyName = 0;
4122     double numericPropertyName = 0;
4123     TreeExpression computedPropertyName = 0;
4124 
4125     JSTokenLocation location(tokenLocation());
4126 
4127     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4128         stringPropertyName = m_token.m_data.ident;
4129         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,
4130             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
4131         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,
4132             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4133         next();
4134     } else if (match(DOUBLE) || match(INTEGER)) {
4135         numericPropertyName = m_token.m_data.doubleValue;
4136         next();
4137     } else if (match(OPENBRACKET)) {
4138         next();
4139         computedPropertyName = parseAssignmentExpression(context);
4140         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4141         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4142     } else
4143         failDueToUnexpectedToken();
4144 
4145     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4146     if (type &amp; PropertyNode::Getter) {
4147         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4148         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4149     } else {
4150         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4151         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4152     }
4153 
4154     if (stringPropertyName)
4155         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4156 
4157     if (computedPropertyName)
4158         return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
4159 
4160     return context.createGetterOrSetterProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);
4161 }
4162 
4163 template &lt;typename LexerType&gt;
4164 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
4165 {
4166     if (!context.getName(property))
4167         return false;
4168 
4169     // A Constant property that is not a Computed or Shorthand Constant property.
4170     return context.getType(property) == PropertyNode::Constant;
4171 }
4172 
4173 template &lt;typename LexerType&gt;
4174 void Parser&lt;LexerType&gt;::recordPauseLocation(const JSTextPosition&amp; position)
4175 {
4176     if (LIKELY(!m_debuggerParseData))
4177         return;
4178 
4179     if (position.line &lt; 0)
4180         return;
4181 
4182     m_debuggerParseData-&gt;pausePositions.appendPause(position);
4183 }
4184 
4185 template &lt;typename LexerType&gt;
4186 void Parser&lt;LexerType&gt;::recordFunctionEntryLocation(const JSTextPosition&amp; position)
4187 {
4188     if (LIKELY(!m_debuggerParseData))
4189         return;
4190 
4191     m_debuggerParseData-&gt;pausePositions.appendEntry(position);
4192 }
4193 
4194 template &lt;typename LexerType&gt;
4195 void Parser&lt;LexerType&gt;::recordFunctionLeaveLocation(const JSTextPosition&amp; position)
4196 {
4197     if (LIKELY(!m_debuggerParseData))
4198         return;
4199 
4200     m_debuggerParseData-&gt;pausePositions.appendLeave(position);
4201 }
4202 
4203 template &lt;typename LexerType&gt;
4204 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
4205 {
4206     SavePoint savePoint = createSavePoint();
4207     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4208 
4209     int oldNonLHSCount = m_parserState.nonLHSCount;
4210 
4211     JSTokenLocation location(tokenLocation());
4212     if (match(CLOSEBRACE)) {
4213         next();
4214         return context.createObjectLiteral(location);
4215     }
4216 
4217     TreeProperty property = parseProperty(context, false);
4218     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4219 
4220     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4221         restoreSavePoint(savePoint);
4222         return parseStrictObjectLiteral(context);
4223     }
4224 
4225     bool seenUnderscoreProto = false;
4226     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
4227         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;
4228 
4229     TreePropertyList propertyList = context.createPropertyList(location, property);
4230     TreePropertyList tail = propertyList;
4231     while (match(COMMA)) {
4232         next(TreeBuilder::DontBuildStrings);
4233         if (match(CLOSEBRACE))
4234             break;
4235         JSTokenLocation propertyLocation(tokenLocation());
4236         property = parseProperty(context, false);
4237         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4238         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
4239             restoreSavePoint(savePoint);
4240             return parseStrictObjectLiteral(context);
4241         }
4242         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
4243             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {
4244                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4245                 seenUnderscoreProto = true;
4246             }
4247         }
4248         tail = context.createPropertyList(propertyLocation, property, tail);
4249     }
4250 
4251     location = tokenLocation();
4252     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4253 
4254     m_parserState.nonLHSCount = oldNonLHSCount;
4255 
4256     return context.createObjectLiteral(location, propertyList);
4257 }
4258 
4259 template &lt;typename LexerType&gt;
4260 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)
4261 {
4262     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4263 
4264     int oldNonLHSCount = m_parserState.nonLHSCount;
4265 
4266     JSTokenLocation location(tokenLocation());
4267     if (match(CLOSEBRACE)) {
4268         next();
4269         return context.createObjectLiteral(location);
4270     }
4271 
4272     TreeProperty property = parseProperty(context, true);
4273     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4274 
4275     bool seenUnderscoreProto = false;
4276     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
4277         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;
4278 
4279     TreePropertyList propertyList = context.createPropertyList(location, property);
4280     TreePropertyList tail = propertyList;
4281     while (match(COMMA)) {
4282         next();
4283         if (match(CLOSEBRACE))
4284             break;
4285         JSTokenLocation propertyLocation(tokenLocation());
4286         property = parseProperty(context, true);
4287         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4288         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
4289             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {
4290                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4291                 seenUnderscoreProto = true;
4292             }
4293         }
4294         tail = context.createPropertyList(propertyLocation, property, tail);
4295     }
4296 
4297     location = tokenLocation();
4298     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4299 
4300     m_parserState.nonLHSCount = oldNonLHSCount;
4301 
4302     return context.createObjectLiteral(location, propertyList);
4303 }
4304 
4305 template &lt;typename LexerType&gt;
4306 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
4307 {
4308     consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings, &quot;Expected an opening &#39;[&#39; at the beginning of an array literal&quot;);
4309 
4310     int oldNonLHSCount = m_parserState.nonLHSCount;
4311 
4312     int elisions = 0;
4313     while (match(COMMA)) {
4314         next(TreeBuilder::DontBuildStrings);
4315         elisions++;
4316     }
4317     if (match(CLOSEBRACKET)) {
4318         JSTokenLocation location(tokenLocation());
4319         next(TreeBuilder::DontBuildStrings);
4320         return context.createArray(location, elisions);
4321     }
4322 
4323     TreeExpression elem;
4324     if (UNLIKELY(match(DOTDOTDOT))) {
4325         auto spreadLocation = m_token.m_location;
4326         auto start = m_token.m_startPosition;
4327         auto divot = m_token.m_endPosition;
4328         next();
4329         auto spreadExpr = parseAssignmentExpressionOrPropagateErrorClass(context);
4330         failIfFalse(spreadExpr, &quot;Cannot parse subject of a spread operation&quot;);
4331         elem = context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, m_lastTokenEndPosition);
4332     } else
4333         elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4334     failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4335     typename TreeBuilder::ElementList elementList = context.createElementList(elisions, elem);
4336     typename TreeBuilder::ElementList tail = elementList;
4337     elisions = 0;
4338     while (match(COMMA)) {
4339         next(TreeBuilder::DontBuildStrings);
4340         elisions = 0;
4341 
4342         while (match(COMMA)) {
4343             next();
4344             elisions++;
4345         }
4346 
4347         if (match(CLOSEBRACKET)) {
4348             JSTokenLocation location(tokenLocation());
4349             next(TreeBuilder::DontBuildStrings);
4350             return context.createArray(location, elisions, elementList);
4351         }
4352         if (UNLIKELY(match(DOTDOTDOT))) {
4353             auto spreadLocation = m_token.m_location;
4354             auto start = m_token.m_startPosition;
4355             auto divot = m_token.m_endPosition;
4356             next();
4357             TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4358             failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4359             auto spread = context.createSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4360             tail = context.createElementList(tail, elisions, spread);
4361             continue;
4362         }
4363         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4364         failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4365         tail = context.createElementList(tail, elisions, elem);
4366     }
4367 
4368     JSTokenLocation location(tokenLocation());
4369     if (!consume(CLOSEBRACKET)) {
4370         failIfFalse(match(DOTDOTDOT), &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an array element&quot;);
4371         semanticFail(&quot;The &#39;...&#39; operator should come before a target expression&quot;);
4372     }
4373 
4374     m_parserState.nonLHSCount = oldNonLHSCount;
4375 
4376     return context.createArray(location, elementList);
4377 }
4378 
4379 template &lt;typename LexerType&gt;
4380 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
4381 {
4382     ASSERT(match(CLASSTOKEN));
4383     ParserClassInfo&lt;TreeBuilder&gt; info;
4384     info.className = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4385     return parseClass(context, FunctionNameRequirements::None, info);
4386 }
4387 
4388 template &lt;typename LexerType&gt;
4389 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
4390 {
4391     ASSERT(match(FUNCTION));
4392     JSTokenLocation location(tokenLocation());
4393     unsigned functionKeywordStart = tokenStart();
4394     next();
4395     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
4396     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4397     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
4398     if (consume(TIMES))
4399         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
4400     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
4401     return context.createFunctionExpr(location, functionInfo);
4402 }
4403 
4404 template &lt;typename LexerType&gt;
4405 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAsyncFunctionExpression(TreeBuilder&amp; context)
4406 {
4407     ASSERT(match(FUNCTION));
4408     JSTokenLocation location(tokenLocation());
4409     unsigned functionKeywordStart = tokenStart();
4410     next();
4411     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
4412 
4413     if (consume(TIMES))
4414         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
4415 
4416     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
4417     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4418     failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
4419     return context.createFunctionExpr(location, functionInfo);
4420 }
4421 
4422 template &lt;typename LexerType&gt;
4423 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateString Parser&lt;LexerType&gt;::parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode rawStringsBuildMode, bool&amp; elementIsTail)
4424 {
4425     if (isTemplateHead)
4426         ASSERT(match(BACKQUOTE));
4427     else
4428         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; following an expression in template literal&quot;);
4429 
4430     // Re-scan the token to recognize it as Template Element.
4431     m_token.m_type = m_lexer-&gt;scanTemplateString(&amp;m_token, rawStringsBuildMode);
4432     matchOrFail(TEMPLATE, &quot;Expected an template element&quot;);
4433     const Identifier* cooked = m_token.m_data.cooked;
4434     const Identifier* raw = m_token.m_data.raw;
4435     elementIsTail = m_token.m_data.isTail;
4436     JSTokenLocation location(tokenLocation());
4437     next();
4438     return context.createTemplateString(location, cooked, raw);
4439 }
4440 
4441 template &lt;typename LexerType&gt;
4442 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateLiteral Parser&lt;LexerType&gt;::parseTemplateLiteral(TreeBuilder&amp; context, typename LexerType::RawStringsBuildMode rawStringsBuildMode)
4443 {
4444     ASSERT(match(BACKQUOTE));
4445     JSTokenLocation location(tokenLocation());
4446     bool elementIsTail = false;
4447 
4448     auto headTemplateString = parseTemplateString(context, true, rawStringsBuildMode, elementIsTail);
4449     failIfFalse(headTemplateString, &quot;Cannot parse head template element&quot;);
4450 
4451     typename TreeBuilder::TemplateStringList templateStringList = context.createTemplateStringList(headTemplateString);
4452     typename TreeBuilder::TemplateStringList templateStringTail = templateStringList;
4453 
4454     if (elementIsTail)
4455         return context.createTemplateLiteral(location, templateStringList);
4456 
4457     failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4458     TreeExpression expression = parseExpression(context);
4459     failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4460 
4461     typename TreeBuilder::TemplateExpressionList templateExpressionList = context.createTemplateExpressionList(expression);
4462     typename TreeBuilder::TemplateExpressionList templateExpressionTail = templateExpressionList;
4463 
4464     auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4465     failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4466     templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4467 
4468     while (!elementIsTail) {
4469         failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4470         TreeExpression expression = parseExpression(context);
4471         failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4472 
4473         templateExpressionTail = context.createTemplateExpressionList(templateExpressionTail, expression);
4474 
4475         auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4476         failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4477         templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4478     }
4479 
4480     return context.createTemplateLiteral(location, templateStringList, templateExpressionList);
4481 }
4482 
4483 template &lt;class LexerType&gt;
4484 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::createResolveAndUseVariable(TreeBuilder&amp; context, const Identifier* ident, bool isEval, const JSTextPosition&amp; start, const JSTokenLocation&amp; location)
4485 {
4486     currentScope()-&gt;useVariable(ident, isEval);
4487     m_parserState.lastIdentifier = ident;
4488     return context.createResolve(location, *ident, start, lastTokenEndPosition());
4489 }
4490 
4491 template &lt;typename LexerType&gt;
4492 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
4493 {
4494     failIfStackOverflow();
4495     switch (m_token.m_type) {
4496     case FUNCTION:
4497         return parseFunctionExpression(context);
4498     case CLASSTOKEN:
4499         return parseClassExpression(context);
4500     case OPENBRACE:
4501         if (strictMode())
4502             return parseStrictObjectLiteral(context);
4503         return parseObjectLiteral(context);
4504     case OPENBRACKET:
4505         return parseArrayLiteral(context);
4506     case OPENPAREN: {
4507         next();
4508         int oldNonLHSCount = m_parserState.nonLHSCount;
4509         TreeExpression result = parseExpression(context);
4510         m_parserState.nonLHSCount = oldNonLHSCount;
4511         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4512         return result;
4513     }
4514     case THISTOKEN: {
4515         JSTokenLocation location(tokenLocation());
4516         next();
4517         if (currentScope()-&gt;isArrowFunction())
4518             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4519         return context.createThisExpr(location);
4520     }
4521     case AWAIT:
4522         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
4523             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);
4524         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4525             return parseAwaitExpression(context);
4526 
4527         goto identifierExpression;
4528     case IDENT: {
4529         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4530             JSTextPosition start = tokenStartPosition();
4531             const Identifier* ident = m_token.m_data.ident;
4532             JSTokenLocation location(tokenLocation());
4533             next();
4534             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4535                 return parseAsyncFunctionExpression(context);
4536 
4537             // Avoid using variable if it is an arrow function parameter
4538             if (UNLIKELY(match(ARROWFUNCTION)))
4539                 return 0;
4540 
4541             const bool isEval = false;
4542             return createResolveAndUseVariable(context, ident, isEval, start, location);
4543         }
4544     identifierExpression:
4545         JSTextPosition start = tokenStartPosition();
4546         const Identifier* ident = m_token.m_data.ident;
4547         JSTokenLocation location(tokenLocation());
4548         next();
4549 
4550         // Avoid using variable if it is an arrow function parameter
4551         if (UNLIKELY(match(ARROWFUNCTION)))
4552             return 0;
4553 
4554         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);
4555     }
4556     case BIGINT: {
4557         const Identifier* ident = m_token.m_data.bigIntString;
4558         uint8_t radix = m_token.m_data.radix;
4559         JSTokenLocation location(tokenLocation());
4560         next();
4561         return context.createBigInt(location, ident, radix);
4562     }
4563     case STRING: {
4564         const Identifier* ident = m_token.m_data.ident;
4565         JSTokenLocation location(tokenLocation());
4566         next();
4567         return context.createString(location, ident);
4568     }
4569     case DOUBLE: {
4570         double d = m_token.m_data.doubleValue;
4571         JSTokenLocation location(tokenLocation());
4572         next();
4573         return context.createDoubleExpr(location, d);
4574     }
4575     case INTEGER: {
4576         double d = m_token.m_data.doubleValue;
4577         JSTokenLocation location(tokenLocation());
4578         next();
4579         return context.createIntegerExpr(location, d);
4580     }
4581     case NULLTOKEN: {
4582         JSTokenLocation location(tokenLocation());
4583         next();
4584         return context.createNull(location);
4585     }
4586     case TRUETOKEN: {
4587         JSTokenLocation location(tokenLocation());
4588         next();
4589         return context.createBoolean(location, true);
4590     }
4591     case FALSETOKEN: {
4592         JSTokenLocation location(tokenLocation());
4593         next();
4594         return context.createBoolean(location, false);
4595     }
4596     case DIVEQUAL:
4597     case DIVIDE: {
4598         /* regexp */
4599         if (match(DIVEQUAL))
4600             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token, &#39;=&#39;);
4601         else
4602             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token);
4603         matchOrFail(REGEXP, &quot;Invalid regular expression&quot;);
4604 
4605         const Identifier* pattern = m_token.m_data.pattern;
4606         const Identifier* flags = m_token.m_data.flags;
4607         JSTextPosition start = tokenStartPosition();
4608         JSTokenLocation location(tokenLocation());
4609         next();
4610         TreeExpression re = context.createRegExp(location, *pattern, *flags, start);
4611         if (!re) {
4612             Yarr::ErrorCode errorCode = Yarr::checkSyntax(pattern-&gt;string(), flags-&gt;string());
4613             regexFail(Yarr::errorMessage(errorCode));
4614         }
4615         return re;
4616     }
4617     case BACKQUOTE:
4618         return parseTemplateLiteral(context, LexerType::RawStringsBuildMode::DontBuildRawStrings);
4619     case YIELD:
4620         if (!strictMode() &amp;&amp; !currentScope()-&gt;isGenerator())
4621             goto identifierExpression;
4622         failDueToUnexpectedToken();
4623     case LET:
4624         if (!strictMode())
4625             goto identifierExpression;
4626         FALLTHROUGH;
4627     default:
4628         failDueToUnexpectedToken();
4629     }
4630 }
4631 
4632 template &lt;typename LexerType&gt;
4633 template &lt;class TreeBuilder&gt; TreeArguments Parser&lt;LexerType&gt;::parseArguments(TreeBuilder&amp; context)
4634 {
4635     consumeOrFailWithFlags(OPENPAREN, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;(&#39; at start of argument list&quot;);
4636     JSTokenLocation location(tokenLocation());
4637     if (match(CLOSEPAREN)) {
4638         next(TreeBuilder::DontBuildStrings);
4639         return context.createArguments();
4640     }
4641     auto argumentsStart = m_token.m_startPosition;
4642     auto argumentsDivot = m_token.m_endPosition;
4643 
4644     ArgumentType argType = ArgumentType::Normal;
4645     TreeExpression firstArg = parseArgument(context, argType);
4646     failIfFalse(firstArg, &quot;Cannot parse function argument&quot;);
4647     semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4648 
4649     bool hasSpread = false;
4650     if (argType == ArgumentType::Spread)
4651         hasSpread = true;
4652     TreeArgumentsList argList = context.createArgumentsList(location, firstArg);
4653     TreeArgumentsList tail = argList;
4654 
4655     while (match(COMMA)) {
4656         JSTokenLocation argumentLocation(tokenLocation());
4657         next(TreeBuilder::DontBuildStrings);
4658 
4659         if (UNLIKELY(match(CLOSEPAREN)))
4660             break;
4661 
4662         TreeExpression arg = parseArgument(context, argType);
4663         propagateError();
4664         semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4665 
4666         if (argType == ArgumentType::Spread)
4667             hasSpread = true;
4668 
4669         tail = context.createArgumentsList(argumentLocation, tail, arg);
4670     }
4671 
4672     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;argument list&quot;);
4673     if (hasSpread) {
4674         TreeExpression spreadArray = context.createSpreadExpression(location, context.createArray(location, context.createElementList(argList)), argumentsStart, argumentsDivot, m_lastTokenEndPosition);
4675         return context.createArguments(context.createArgumentsList(location, spreadArray));
4676     }
4677 
4678     return context.createArguments(argList);
4679 }
4680 
4681 template &lt;typename LexerType&gt;
4682 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArgument(TreeBuilder&amp; context, ArgumentType&amp; type)
4683 {
4684     if (UNLIKELY(match(DOTDOTDOT))) {
4685         JSTokenLocation spreadLocation(tokenLocation());
4686         auto start = m_token.m_startPosition;
4687         auto divot = m_token.m_endPosition;
4688         next();
4689         TreeExpression spreadExpr = parseAssignmentExpression(context);
4690         propagateError();
4691         auto end = m_lastTokenEndPosition;
4692         type = ArgumentType::Spread;
4693         return context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, end);
4694     }
4695 
4696     type = ArgumentType::Normal;
4697     return parseAssignmentExpression(context);
4698 }
4699 
4700 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, ASTBuilder&gt;::value&gt;::type&gt;
4701 static inline void recordCallOrApplyDepth(ParserType* parser, VM&amp; vm, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp; callOrApplyDepthScope, ExpressionNode* expression)
4702 {
4703     if (expression-&gt;isDotAccessorNode()) {
4704         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expression);
4705         bool isCallOrApply = dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().applyPublicName();
4706         if (isCallOrApply)
4707             callOrApplyDepthScope.emplace(parser);
4708     }
4709 }
4710 
4711 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value&gt;::type&gt;
4712 static inline void recordCallOrApplyDepth(ParserType*, VM&amp;, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp;, SyntaxChecker::Expression)
4713 {
4714 }
4715 
4716 template &lt;typename LexerType&gt;
4717 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseMemberExpression(TreeBuilder&amp; context)
4718 {
4719     TreeExpression base = 0;
4720     JSTextPosition expressionStart = tokenStartPosition();
4721     int newCount = 0;
4722     JSTokenLocation startLocation = tokenLocation();
4723     JSTokenLocation lastNewTokenLocation;
4724     while (match(NEW)) {
4725         lastNewTokenLocation = tokenLocation();
4726         next();
4727         newCount++;
4728     }
4729     JSTokenLocation location = tokenLocation();
4730 
4731     bool baseIsSuper = match(SUPER);
4732     bool previousBaseWasSuper = false;
4733     bool baseIsImport = match(IMPORT);
4734     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4735 
4736     bool baseIsNewTarget = false;
4737     if (newCount &amp;&amp; match(DOT)) {
4738         next();
4739         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
4740             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4741             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
4742             baseIsNewTarget = true;
4743             if (currentScope()-&gt;isArrowFunction()) {
4744                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
4745                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4746             }
4747             ASSERT(lastNewTokenLocation.line);
4748             base = context.createNewTargetExpr(lastNewTokenLocation);
4749             newCount--;
4750             next();
4751         } else {
4752             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4753             failDueToUnexpectedToken();
4754         }
4755     }
4756 
4757     bool baseIsAsyncKeyword = false;
4758 
4759     if (baseIsSuper) {
4760         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4761         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);
4762         base = context.createSuperExpr(location);
4763         next();
4764         ScopeRef functionScope = currentFunctionScope();
4765         if (!functionScope-&gt;setNeedsSuperBinding()) {
4766             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4767             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4768             // inside of the constructor or method.
4769             if (!m_lexer-&gt;isReparsingFunction()) {
4770                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4771                     ? functionScope-&gt;expectedSuperBinding()
4772                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
4773                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);
4774             }
4775         }
4776     } else if (baseIsImport) {
4777         next();
4778         JSTextPosition expressionEnd = lastTokenEndPosition();
4779         if (consume(DOT)) {
4780             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {
4781                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
4782                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));
4783                 next();
4784             } else {
4785                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4786                 failDueToUnexpectedToken();
4787             }
4788         } else {
4789             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4790             TreeExpression expr = parseAssignmentExpression(context);
4791             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4792             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4793             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
4794         }
4795     } else if (!baseIsNewTarget) {
4796         const bool isAsync = matchContextualKeyword(m_vm.propertyNames-&gt;async);
4797 
4798         base = parsePrimaryExpression(context);
4799         failIfFalse(base, &quot;Cannot parse base expression&quot;);
4800         if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
4801             if (matchSpecIdentifier()) {
4802                 // AsyncArrowFunction
4803                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4804                 failDueToUnexpectedToken();
4805             }
4806             baseIsAsyncKeyword = true;
4807         }
4808     }
4809 
4810     failIfFalse(base, &quot;Cannot parse base expression&quot;);
4811 
4812     do {
4813         TreeExpression optionalChainBase = 0;
4814         JSTokenLocation optionalChainLocation;
4815         JSTokenType type = m_token.m_type;
4816 
4817         if (match(QUESTIONDOT)) {
4818             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
4819             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
4820             optionalChainBase = base;
4821             optionalChainLocation = tokenLocation();
4822 
4823             SavePoint savePoint = createSavePoint();
4824             next();
4825             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
4826                 type = m_token.m_type;
4827             else {
4828                 type = DOT;
4829                 restoreSavePoint(savePoint);
4830             }
4831         }
4832 
4833         while (true) {
4834             location = tokenLocation();
4835             switch (type) {
4836             case OPENBRACKET: {
4837                 m_parserState.nonTrivialExpressionCount++;
4838                 JSTextPosition expressionEnd = lastTokenEndPosition();
4839                 next();
4840                 int nonLHSCount = m_parserState.nonLHSCount;
4841                 int initialAssignments = m_parserState.assignmentCount;
4842                 TreeExpression property = parseExpression(context);
4843                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);
4844                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());
4845 
4846                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4847                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4848 
4849                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);
4850                 m_parserState.nonLHSCount = nonLHSCount;
4851                 break;
4852             }
4853             case OPENPAREN: {
4854                 m_parserState.nonTrivialExpressionCount++;
4855                 int nonLHSCount = m_parserState.nonLHSCount;
4856                 if (newCount) {
4857                     newCount--;
4858                     JSTextPosition expressionEnd = lastTokenEndPosition();
4859                     TreeArguments arguments = parseArguments(context);
4860                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4861                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());
4862                 } else {
4863                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
4864                     JSTextPosition expressionEnd = lastTokenEndPosition();
4865                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;
4866                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);
4867 
4868                     TreeArguments arguments = parseArguments(context);
4869 
4870                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {
4871                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
4872                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4873                         failDueToUnexpectedToken();
4874                     }
4875 
4876                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4877                     if (baseIsSuper) {
4878                         ScopeRef functionScope = currentFunctionScope();
4879                         if (!functionScope-&gt;setHasDirectSuper()) {
4880                             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4881                             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4882                             // inside of the constructor or method.
4883                             if (!m_lexer-&gt;isReparsingFunction()) {
4884                                 ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4885                                 ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4886                                     ? functionScope-&gt;constructorKind()
4887                                     : closestOrdinaryFunctionScope-&gt;constructorKind();
4888                                 semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);
4889                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);
4890                             }
4891                         }
4892                         if (currentScope()-&gt;isArrowFunction())
4893                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();
4894                     }
4895 
4896                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);
4897                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,
4898                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);
4899 
4900                     if (isOptionalCall)
4901                         optionalChainBase = base;
4902                 }
4903                 m_parserState.nonLHSCount = nonLHSCount;
4904                 break;
4905             }
4906             case DOT: {
4907                 m_parserState.nonTrivialExpressionCount++;
4908                 JSTextPosition expressionEnd = lastTokenEndPosition();
4909                 nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
4910                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
4911                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
4912                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4913                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4914                 next();
4915                 break;
4916             }
4917             case BACKQUOTE: {
4918                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);
4919                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);
4920                 JSTextPosition expressionEnd = lastTokenEndPosition();
4921                 int nonLHSCount = m_parserState.nonLHSCount;
4922                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);
4923                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);
4924                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());
4925                 m_parserState.nonLHSCount = nonLHSCount;
4926                 m_seenTaggedTemplate = true;
4927                 break;
4928             }
4929             default:
4930                 goto endOfChain;
4931             }
4932             previousBaseWasSuper = baseIsSuper;
4933             baseIsSuper = false;
4934             type = m_token.m_type;
4935         }
4936 endOfChain:
4937         if (optionalChainBase)
4938             base = context.createOptionalChain(optionalChainLocation, optionalChainBase, base, !match(QUESTIONDOT));
4939     } while (match(QUESTIONDOT));
4940 
4941     semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
4942     while (newCount--)
4943         base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
4944     return base;
4945 }
4946 
4947 template &lt;typename LexerType&gt;
4948 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrowFunctionExpression(TreeBuilder&amp; context, bool isAsync)
4949 {
4950     JSTokenLocation location;
4951 
4952     unsigned functionKeywordStart = tokenStart();
4953     location = tokenLocation();
4954     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4955     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4956 
4957     SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
4958     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
4959 
4960     return context.createArrowFunctionExpr(location, info);
4961 }
4962 
4963 static const char* operatorString(bool prefix, unsigned tok)
4964 {
4965     switch (tok) {
4966     case MINUSMINUS:
4967     case AUTOMINUSMINUS:
4968         return prefix ? &quot;prefix-decrement&quot; : &quot;decrement&quot;;
4969 
4970     case PLUSPLUS:
4971     case AUTOPLUSPLUS:
4972         return prefix ? &quot;prefix-increment&quot; : &quot;increment&quot;;
4973 
4974     case EXCLAMATION:
4975         return &quot;logical-not&quot;;
4976 
4977     case TILDE:
4978         return &quot;bitwise-not&quot;;
4979 
4980     case TYPEOF:
4981         return &quot;typeof&quot;;
4982 
4983     case VOIDTOKEN:
4984         return &quot;void&quot;;
4985 
4986     case DELETETOKEN:
4987         return &quot;delete&quot;;
4988     }
4989     RELEASE_ASSERT_NOT_REACHED();
4990     return &quot;error&quot;;
4991 }
4992 
4993 template &lt;typename LexerType&gt;
4994 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
4995 {
4996     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
4997     AllowInOverride allowInOverride(this);
4998     int tokenStackDepth = 0;
4999     bool hasPrefixUpdateOp = false;
5000     unsigned lastOperator = 0;
5001 
5002     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
5003         return parseAwaitExpression(context);
5004 
5005     JSTokenLocation location(tokenLocation());
5006 
5007     while (isUnaryOp(m_token.m_type)) {
5008         switch (m_token.m_type) {
5009         case PLUSPLUS:
5010         case MINUSMINUS:
5011         case AUTOPLUSPLUS:
5012         case AUTOMINUSMINUS:
5013             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);
5014             hasPrefixUpdateOp = true;
5015             break;
5016         default:
5017             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);
5018             break;
5019         }
5020         lastOperator = m_token.m_type;
5021         m_parserState.nonLHSCount++;
5022         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
5023         next();
5024         m_parserState.nonTrivialExpressionCount++;
5025     }
5026     JSTextPosition subExprStart = tokenStartPosition();
5027     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
5028     TreeExpression expr = parseMemberExpression(context);
5029     if (!expr) {
5030         if (lastOperator)
5031             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
5032         failWithMessage(&quot;Cannot parse member expression&quot;);
5033     }
5034     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {
5035         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);
5036         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);
5037     }
5038     bool isEvalOrArguments = false;
5039     if (strictMode()) {
5040         if (context.isResolve(expr))
5041             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;
5042     }
5043     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5044     switch (m_token.m_type) {
5045     case PLUSPLUS:
5046         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5047         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);
5048         m_parserState.nonTrivialExpressionCount++;
5049         m_parserState.nonLHSCount++;
5050         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5051         m_parserState.assignmentCount++;
5052         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5053         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5054         next();
5055         break;
5056     case MINUSMINUS:
5057         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5058         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);
5059         m_parserState.nonTrivialExpressionCount++;
5060         m_parserState.nonLHSCount++;
5061         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5062         m_parserState.assignmentCount++;
5063         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
5064         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5065         next();
5066         break;
5067     default:
5068         break;
5069     }
5070 
5071     JSTextPosition end = lastTokenEndPosition();
5072     while (tokenStackDepth) {
5073         switch (context.unaryTokenStackLastType(tokenStackDepth)) {
5074         case EXCLAMATION:
5075             expr = context.createLogicalNot(location, expr);
5076             break;
5077         case TILDE:
5078             expr = context.makeBitwiseNotNode(location, expr);
5079             break;
5080         case MINUS:
5081             expr = context.makeNegateNode(location, expr);
5082             break;
5083         case PLUS:
5084             expr = context.createUnaryPlus(location, expr);
5085             break;
5086         case PLUSPLUS:
5087         case AUTOPLUSPLUS:
5088             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5089             m_parserState.assignmentCount++;
5090             break;
5091         case MINUSMINUS:
5092         case AUTOMINUSMINUS:
5093             expr = context.makePrefixNode(location, expr, OpMinusMinus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
5094             m_parserState.assignmentCount++;
5095             break;
5096         case TYPEOF:
5097             expr = context.makeTypeOfNode(location, expr);
5098             break;
5099         case VOIDTOKEN:
5100             expr = context.createVoid(location, expr);
5101             break;
5102         case DELETETOKEN:
5103             failIfTrueIfStrict(context.isResolve(expr), &quot;Cannot delete unqualified property &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5104             expr = context.makeDeleteNode(location, expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
5105             break;
5106         default:
5107             // If we get here something has gone horribly horribly wrong
5108             CRASH();
5109         }
5110         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);
5111         context.unaryTokenStackRemoveLast(tokenStackDepth);
5112     }
5113     return expr;
5114 }
5115 
5116 template &lt;typename LexerType&gt; void Parser&lt;LexerType&gt;::printUnexpectedTokenText(WTF::PrintStream&amp; out)
5117 {
5118     switch (m_token.m_type) {
5119     case EOFTOK:
5120         out.print(&quot;Unexpected end of script&quot;);
5121         return;
5122     case UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK:
5123     case UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5124         out.print(&quot;Incomplete unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5125         return;
5126     case UNTERMINATED_MULTILINE_COMMENT_ERRORTOK:
5127         out.print(&quot;Unterminated multiline comment&quot;);
5128         return;
5129     case UNTERMINATED_NUMERIC_LITERAL_ERRORTOK:
5130         out.print(&quot;Unterminated numeric literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5131         return;
5132     case UNTERMINATED_STRING_LITERAL_ERRORTOK:
5133         out.print(&quot;Unterminated string literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5134         return;
5135     case INVALID_IDENTIFIER_ESCAPE_ERRORTOK:
5136         out.print(&quot;Invalid escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5137         return;
5138     case UNEXPECTED_ESCAPE_ERRORTOK:
5139         out.print(&quot;Unexpected escaped characters in keyword token: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5140         return;
5141     case INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5142         out.print(&quot;Invalid unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5143         return;
5144     case INVALID_NUMERIC_LITERAL_ERRORTOK:
5145         out.print(&quot;Invalid numeric literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5146         return;
5147     case UNTERMINATED_OCTAL_NUMBER_ERRORTOK:
5148         out.print(&quot;Invalid use of octal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5149         return;
5150     case INVALID_STRING_LITERAL_ERRORTOK:
5151         out.print(&quot;Invalid string literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5152         return;
5153     case ERRORTOK:
5154         out.print(&quot;Unrecognized token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5155         return;
5156     case STRING:
5157         out.print(&quot;Unexpected string literal &quot;, getToken());
5158         return;
5159     case INTEGER:
5160     case DOUBLE:
5161         out.print(&quot;Unexpected number &#39;&quot;, getToken(), &quot;&#39;&quot;);
5162         return;
5163 
5164     case RESERVED_IF_STRICT:
5165         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39; in strict mode&quot;);
5166         return;
5167 
5168     case RESERVED:
5169         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39;&quot;);
5170         return;
5171 
5172     case INVALID_PRIVATE_NAME_ERRORTOK:
5173         out.print(&quot;Invalid private name &#39;&quot;, getToken(), &quot;&#39;&quot;);
5174         return;
5175 
5176     case AWAIT:
5177     case IDENT:
5178         out.print(&quot;Unexpected identifier &#39;&quot;, getToken(), &quot;&#39;&quot;);
5179         return;
5180 
5181     default:
5182         break;
5183     }
5184 
5185     if (m_token.m_type &amp; KeywordTokenFlag) {
5186         out.print(&quot;Unexpected keyword &#39;&quot;, getToken(), &quot;&#39;&quot;);
5187         return;
5188     }
5189 
5190     out.print(&quot;Unexpected token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5191 }
5192 
5193 // Instantiate the two flavors of Parser we need instead of putting most of this file in Parser.h
5194 template class Parser&lt;Lexer&lt;LChar&gt;&gt;;
5195 template class Parser&lt;Lexer&lt;UChar&gt;&gt;;
5196 
5197 } // namespace JSC
    </pre>
  </body>
</html>