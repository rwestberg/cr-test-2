<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Element.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 class Frame;
 47 class HTMLDocument;
 48 class IntSize;
 49 class JSCustomElementInterface;
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
 59 struct ElementStyle;
 60 struct ScrollIntoViewOptions;
 61 
 62 #if ENABLE(INTERSECTION_OBSERVER)
 63 struct IntersectionObserverData;
 64 #endif
 65 




 66 enum SpellcheckAttributeState {
 67     SpellcheckAttributeTrue,
 68     SpellcheckAttributeFalse,
 69     SpellcheckAttributeDefault
 70 };
 71 
<span class="line-removed"> 72 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed"> 73 enum class TouchAction : uint8_t;</span>
<span class="line-removed"> 74 #endif</span>
<span class="line-removed"> 75 </span>
 76 class Element : public ContainerNode {
 77     WTF_MAKE_ISO_ALLOCATED(Element);
 78 public:
 79     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 80     virtual ~Element();
 81 
 82     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
<span class="line-modified"> 83     WEBCORE_EXPORT const AtomicString&amp; getAttribute(const QualifiedName&amp;) const;</span>
 84     template&lt;typename... QualifiedNames&gt;
<span class="line-modified"> 85     const AtomicString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;</span>
<span class="line-modified"> 86     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomicString&amp; value);</span>
<span class="line-modified"> 87     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomicString&amp; value);</span>
<span class="line-modified"> 88     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomicString&amp; value);</span>
 89     bool removeAttribute(const QualifiedName&amp;);
 90     Vector&lt;String&gt; getAttributeNames() const;
 91 
 92     // Typed getters and setters for language bindings.
 93     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 94     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 95     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 96     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
 97 
 98     // Call this to get the value of an attribute that is known not to be the style
 99     // attribute or one of the SVG animatable attributes.
100     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
<span class="line-modified">101     const AtomicString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;</span>
102 #ifndef NDEBUG
103     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;
104 #endif
105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
109     WEBCORE_EXPORT bool hasAttributes() const;
110     // This variant will not update the potentially invalid attributes. To be used when not interested
111     // in style attribute or one of the SVG animation attributes.
112     bool hasAttributesWithoutUpdate() const;
113 
<span class="line-modified">114     WEBCORE_EXPORT bool hasAttribute(const AtomicString&amp; qualifiedName) const;</span>
<span class="line-modified">115     WEBCORE_EXPORT bool hasAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const;</span>
116 
<span class="line-modified">117     WEBCORE_EXPORT const AtomicString&amp; getAttribute(const AtomicString&amp; qualifiedName) const;</span>
<span class="line-modified">118     WEBCORE_EXPORT const AtomicString&amp; getAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const;</span>
119 
<span class="line-modified">120     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomicString&amp; qualifiedName, const AtomicString&amp; value);</span>
<span class="line-modified">121     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName, const AtomicString&amp; value);</span>
123 
<span class="line-modified">124     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomicString&amp; qualifiedName, Optional&lt;bool&gt; force);</span>
125 
<span class="line-modified">126     const AtomicString&amp; getIdAttribute() const;</span>
<span class="line-modified">127     void setIdAttribute(const AtomicString&amp;);</span>
128 
<span class="line-modified">129     const AtomicString&amp; getNameAttribute() const;</span>
130 
131     // Call this to get the value of the id attribute for style resolution purposes.
132     // The value will already be lowercased if the document is in compatibility mode,
133     // so this function is not suitable for non-style uses.
<span class="line-modified">134     const AtomicString&amp; idForStyleResolution() const;</span>
135 
136     // Internal methods that assume the existence of attribute storage, one should use hasAttributes()
137     // before calling them.
138     AttributeIteratorAccessor attributesIterator() const { return elementData()-&gt;attributesIterator(); }
139     unsigned attributeCount() const;
140     const Attribute&amp; attributeAt(unsigned index) const;
141     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
142     unsigned findAttributeIndexByName(const QualifiedName&amp; name) const { return elementData()-&gt;findAttributeIndexByName(name); }
<span class="line-modified">143     unsigned findAttributeIndexByName(const AtomicString&amp; name, bool shouldIgnoreAttributeCase) const { return elementData()-&gt;findAttributeIndexByName(name, shouldIgnoreAttributeCase); }</span>
144 
145     WEBCORE_EXPORT void scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg);
146     WEBCORE_EXPORT void scrollIntoView(bool alignToTop = true);
147     WEBCORE_EXPORT void scrollIntoViewIfNeeded(bool centerIfNeeded = true);
148     WEBCORE_EXPORT void scrollIntoViewIfNotVisible(bool centerIfNotVisible = true);
149 
150     void scrollBy(const ScrollToOptions&amp;);
151     void scrollBy(double x, double y);
152     virtual void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped);
153     void scrollTo(double x, double y);
154 
155     WEBCORE_EXPORT void scrollByLines(int lines);
156     WEBCORE_EXPORT void scrollByPages(int pages);
157 
158     WEBCORE_EXPORT double offsetLeftForBindings();
159     WEBCORE_EXPORT double offsetLeft();
160     WEBCORE_EXPORT double offsetTopForBindings();
161     WEBCORE_EXPORT double offsetTop();
162     WEBCORE_EXPORT double offsetWidth();
163     WEBCORE_EXPORT double offsetHeight();
</pre>
<hr />
<pre>
168     // to the render layer and merge bindingsOffsetParent and offsetParent.
169     WEBCORE_EXPORT Element* offsetParentForBindings();
170 
171     const Element* rootElement() const;
172 
173     Element* offsetParent();
174     WEBCORE_EXPORT double clientLeft();
175     WEBCORE_EXPORT double clientTop();
176     WEBCORE_EXPORT double clientWidth();
177     WEBCORE_EXPORT double clientHeight();
178 
179     virtual int scrollLeft();
180     virtual int scrollTop();
181     virtual void setScrollLeft(int);
182     virtual void setScrollTop(int);
183     virtual int scrollWidth();
184     virtual int scrollHeight();
185 
186     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
187 


188     WEBCORE_EXPORT FloatRect boundingClientRect();
189 
190     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
191     Ref&lt;DOMRect&gt; getBoundingClientRect();
192 
193     // Returns the absolute bounding box translated into client coordinates.
194     WEBCORE_EXPORT IntRect clientRect() const;
195     // Returns the absolute bounding box translated into screen coordinates.
196     WEBCORE_EXPORT IntRect screenRect() const;
197 
<span class="line-modified">198     WEBCORE_EXPORT bool removeAttribute(const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">199     WEBCORE_EXPORT bool removeAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName);</span>
200 
201     Ref&lt;Attr&gt; detachAttribute(unsigned index);
202 
<span class="line-modified">203     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">204     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName);</span>
205     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
206     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
207     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
208 
209     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
<span class="line-modified">210     RefPtr&lt;Attr&gt; attrIfExists(const AtomicString&amp; localName, bool shouldIgnoreAttributeCase);</span>
211     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
212 
213     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
214 
215     const QualifiedName&amp; tagQName() const { return m_tagName; }
216 #if ENABLE(JIT)
217     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
218 #endif // ENABLE(JIT)
219     String tagName() const { return nodeName(); }
220     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
221     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
222     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
223     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
224 
225     // A fast function for checking the local name against another atomic string.
<span class="line-modified">226     bool hasLocalName(const AtomicString&amp; other) const { return m_tagName.localName() == other; }</span>
227 
<span class="line-modified">228     const AtomicString&amp; localName() const final { return m_tagName.localName(); }</span>
<span class="line-modified">229     const AtomicString&amp; prefix() const final { return m_tagName.prefix(); }</span>
<span class="line-modified">230     const AtomicString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }</span>
231 
<span class="line-modified">232     ExceptionOr&lt;void&gt; setPrefix(const AtomicString&amp;) final;</span>
233 
234     String nodeName() const override;
235 
236     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
237     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
238 
239     void normalizeAttributes();
240     String nodeNamePreservingCase() const;
241 
242     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
243 
244     // For exposing to DOM only.
245     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
246 
247     enum AttributeModificationReason {
248         ModifiedDirectly,
249         ModifiedByCloning
250     };
251 
252     // This method is called whenever an attribute is added, changed or removed.
<span class="line-modified">253     virtual void attributeChanged(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason = ModifiedDirectly);</span>
<span class="line-modified">254     virtual void parseAttribute(const QualifiedName&amp;, const AtomicString&amp;) { }</span>
255 
256     // Only called by the parser immediately after element construction.
257     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
258 
259     bool isEventHandlerAttribute(const Attribute&amp;) const;
260     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
261 
262     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
263     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
264 
265     const ElementData* elementData() const { return m_elementData.get(); }
266     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
267     UniqueElementData&amp; ensureUniqueElementData();
268 
269     void synchronizeAllAttributes() const;
270 
271     // Clones attributes only.
272     void cloneAttributesFromElement(const Element&amp;);
273 
274     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
</pre>
<hr />
<pre>
284     virtual bool rendererIsNeeded(const RenderStyle&amp;);
285 
286     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
287     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;
288 
289     struct ShadowRootInit {
290         ShadowRootMode mode;
291     };
292     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
293 
294     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
295     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
296 
297     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
298     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
299     void setIsCustomElementUpgradeCandidate();
300     void enqueueToUpgrade(JSCustomElementInterface&amp;);
301     CustomElementReactionQueue* reactionQueue() const;
302 
303     // FIXME: this should not be virtual, do not override this.
<span class="line-modified">304     virtual const AtomicString&amp; shadowPseudoId() const;</span>
305 
306     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
307     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
308     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
309     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
310     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
311 
312     virtual void setActive(bool flag = true, bool pause = false);
313     virtual void setHovered(bool flag = true);
314     virtual void setFocus(bool flag);
315     void setHasFocusWithin(bool flag);
316 
<span class="line-modified">317     bool tabIndexSetExplicitly() const;</span>

318     virtual bool supportsFocus() const;
319     virtual bool isFocusable() const;
320     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
321     virtual bool isMouseFocusable() const;
322 
323     virtual bool shouldUseInputMethod();
324 
<span class="line-modified">325     virtual int tabIndex() const;</span>
<span class="line-modified">326     WEBCORE_EXPORT void setTabIndex(int);</span>
327     virtual RefPtr&lt;Element&gt; focusDelegate();
328 
329     ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html, NodeVector* addedNodes);
330 
331     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; insertAdjacentElement(const String&amp; where, Element&amp; newChild);
332     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html);
333     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentText(const String&amp; where, const String&amp; text);
334 
335     const RenderStyle* computedStyle(PseudoId = PseudoId::None) override;
336 
337     bool needsStyleInvalidation() const;
338 
339     // Methods for indicating the style is affected by dynamic updates (e.g., children changing, our position changing in our sibling list, etc.)
<span class="line-modified">340     bool styleAffectedByActive() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByActive(); }</span>
<span class="line-modified">341     bool styleAffectedByEmpty() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByEmpty(); }</span>
<span class="line-modified">342     bool styleAffectedByFocusWithin() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByFocusWithin(); }</span>
343     bool descendantsAffectedByPreviousSibling() const { return getFlag(DescendantsAffectedByPreviousSiblingFlag); }
344     bool childrenAffectedByHover() const { return getFlag(ChildrenAffectedByHoverRulesFlag); }
<span class="line-modified">345     bool childrenAffectedByDrag() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByDrag(); }</span>
346     bool childrenAffectedByFirstChildRules() const { return getFlag(ChildrenAffectedByFirstChildRulesFlag); }
347     bool childrenAffectedByLastChildRules() const { return getFlag(ChildrenAffectedByLastChildRulesFlag); }
<span class="line-modified">348     bool childrenAffectedByForwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByForwardPositionalRules(); }</span>
<span class="line-modified">349     bool descendantsAffectedByForwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataDescendantsAffectedByForwardPositionalRules(); }</span>
<span class="line-modified">350     bool childrenAffectedByBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByBackwardPositionalRules(); }</span>
<span class="line-modified">351     bool descendantsAffectedByBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataDescendantsAffectedByBackwardPositionalRules(); }</span>
<span class="line-modified">352     bool childrenAffectedByPropertyBasedBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules(); }</span>
353     bool affectsNextSiblingElementStyle() const { return getFlag(AffectsNextSiblingElementStyle); }
354     unsigned childIndex() const { return hasRareData() ? rareDataChildIndex() : 0; }
355 
356     bool hasFlagsSetDuringStylingOfChildren() const;
357 
<span class="line-modified">358     void setStyleAffectedByEmpty();</span>
<span class="line-modified">359     void setStyleAffectedByFocusWithin();</span>
<span class="line-modified">360     void setDescendantsAffectedByPreviousSibling() const { return setFlag(DescendantsAffectedByPreviousSiblingFlag); }</span>
361     void setChildrenAffectedByHover() { setFlag(ChildrenAffectedByHoverRulesFlag); }
<span class="line-modified">362     void setStyleAffectedByActive();</span>
<span class="line-modified">363     void setChildrenAffectedByDrag();</span>
364     void setChildrenAffectedByFirstChildRules() { setFlag(ChildrenAffectedByFirstChildRulesFlag); }
365     void setChildrenAffectedByLastChildRules() { setFlag(ChildrenAffectedByLastChildRulesFlag); }
<span class="line-modified">366     void setChildrenAffectedByForwardPositionalRules();</span>
<span class="line-modified">367     void setDescendantsAffectedByForwardPositionalRules();</span>
<span class="line-modified">368     void setChildrenAffectedByBackwardPositionalRules();</span>
<span class="line-modified">369     void setDescendantsAffectedByBackwardPositionalRules();</span>
<span class="line-modified">370     void setChildrenAffectedByPropertyBasedBackwardPositionalRules();</span>
371     void setAffectsNextSiblingElementStyle() { setFlag(AffectsNextSiblingElementStyle); }
372     void setStyleIsAffectedByPreviousSibling() { setFlag(StyleIsAffectedByPreviousSibling); }
373     void setChildIndex(unsigned);
374 
<span class="line-modified">375     WEBCORE_EXPORT AtomicString computeInheritedLanguage() const;</span>
376     Locale&amp; locale() const;
377 
378     virtual void accessKeyAction(bool /*sendToAnyEvent*/) { }
379 
380     virtual bool isURLAttribute(const Attribute&amp;) const { return false; }
381     virtual bool attributeContainsURL(const Attribute&amp; attribute) const { return isURLAttribute(attribute); }
382     virtual String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const;
383     virtual bool isHTMLContentAttribute(const Attribute&amp;) const { return false; }
384 
385     WEBCORE_EXPORT URL getURLAttribute(const QualifiedName&amp;) const;
386     URL getNonEmptyURLAttribute(const QualifiedName&amp;) const;
387 
<span class="line-modified">388     virtual const AtomicString&amp; imageSourceURL() const;</span>
389     virtual String target() const { return String(); }
390 
391     static AXTextStateChangeIntent defaultFocusTextStateChangeIntent() { return AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, true }); }
392     virtual void focus(bool restorePreviousSelection = true, FocusDirection = FocusDirectionNone);
393     virtual RefPtr&lt;Element&gt; focusAppearanceUpdateTarget();
394     virtual void updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode = SelectionRevealMode::Reveal);
395     virtual void blur();
396 
397     WEBCORE_EXPORT String innerHTML() const;
398     WEBCORE_EXPORT String outerHTML() const;
399     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
400     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
401     WEBCORE_EXPORT String innerText();
402     WEBCORE_EXPORT String outerText();
403 
404     virtual String title() const;
405 
<span class="line-modified">406     const AtomicString&amp; pseudo() const;</span>
<span class="line-modified">407     WEBCORE_EXPORT void setPseudo(const AtomicString&amp;);</span>
408 
409     LayoutSize minimumSizeForResizing() const;
410     void setMinimumSizeForResizing(const LayoutSize&amp;);
411 
412     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
413     virtual void prepareForDocumentSuspension() { }
414     virtual void resumeFromDocumentSuspension() { }
415 
416     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this
417     virtual void mediaVolumeDidChange() { }
418 
419     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.
<span class="line-modified">420     virtual void privateBrowsingStateDidChange() { }</span>
421 
422     virtual void willBecomeFullscreenElement();
423     virtual void ancestorWillEnterFullscreen() { }
424     virtual void didBecomeFullscreenElement() { }
425     virtual void willStopBeingFullscreenElement() { }
426 
427 #if ENABLE(VIDEO_TRACK)
428     virtual void captionPreferencesChanged() { }
429 #endif
430 
431     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
432     void finishParsingChildren() override;
433     void beginParsingChildren() final;
434 
435     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
436     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
437     bool childNeedsShadowWalker() const;
438     void didShadowTreeAwareChildrenChange();
439 
440     virtual bool matchesValidPseudoClass() const;
</pre>
<hr />
<pre>
445     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
446     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
447     virtual bool shouldAppearIndeterminate() const;
448 
449     WEBCORE_EXPORT DOMTokenList&amp; classList();
450 
451     DatasetDOMStringMap&amp; dataset();
452 
453 #if ENABLE(VIDEO)
454     virtual bool isMediaElement() const { return false; }
455 #endif
456 
457     virtual bool isFormControlElement() const { return false; }
458     virtual bool isSpinButtonElement() const { return false; }
459     virtual bool isTextFormControlElement() const { return false; }
460     virtual bool isTextField() const { return false; }
461     virtual bool isOptionalFormControl() const { return false; }
462     virtual bool isRequiredFormControl() const { return false; }
463     virtual bool isInRange() const { return false; }
464     virtual bool isOutOfRange() const { return false; }
<span class="line-removed">465     virtual bool isFrameElementBase() const { return false; }</span>
466     virtual bool isUploadButton() const { return false; }
467     virtual bool isSliderContainerElement() const { return false; }
468 
469     bool canContainRangeEndPoint() const override;
470 
471     // Used for disabled form elements; if true, prevents mouse events from being dispatched
472     // to event listeners, and prevents DOMActivate events from being sent at all.
473     virtual bool isDisabledFormControl() const { return false; }
474 
475     virtual bool childShouldCreateRenderer(const Node&amp;) const;
476 
477     bool hasPendingResources() const;
478     void setHasPendingResources();
479     void clearHasPendingResources();
480     virtual void buildPendingResource() { };
481 
482     bool hasCSSAnimation() const;
483     void setHasCSSAnimation();
484     void clearHasCSSAnimation();
485 
</pre>
<hr />
<pre>
493 #if ENABLE(POINTER_EVENTS)
494     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
495     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
496     bool hasPointerCapture(int32_t);
497 #endif
498 
499 #if ENABLE(POINTER_LOCK)
500     WEBCORE_EXPORT void requestPointerLock();
501 #endif
502 
503     bool isSpellCheckingEnabled() const;
504 
505     bool hasID() const;
506     bool hasClass() const;
507     bool hasName() const;
508     const SpaceSplitString&amp; classNames() const;
509 
510     IntPoint savedLayerScrollPosition() const;
511     void setSavedLayerScrollPosition(const IntPoint&amp;);
512 
<span class="line-modified">513     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomicString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);</span>
514     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
515     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
516     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
<span class="line-modified">517     void dispatchFocusInEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);</span>
<span class="line-modified">518     void dispatchFocusOutEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);</span>
519     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
520     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
521     void dispatchWebKitImageReadyEventForTesting();
522 
523     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
524 
525     virtual void willRecalcStyle(Style::Change);
526     virtual void didRecalcStyle(Style::Change);
527     virtual void willResetComputedStyle();
528     virtual void willAttachRenderers();
529     virtual void didAttachRenderers();
530     virtual void willDetachRenderers();
531     virtual void didDetachRenderers();
532     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);
533 
534     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
535 
536     const RenderStyle* existingComputedStyle() const;
<span class="line-modified">537     const RenderStyle* renderOrDisplayContentsStyle() const;</span>
538 
539     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
540     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
541     void clearBeforePseudoElement();
542     void clearAfterPseudoElement();
543     void resetComputedStyle();
544     void resetStyleRelations();
545     void clearHoverAndActiveStatusBeforeDetachingRenderer();
546 
547     WEBCORE_EXPORT URL absoluteLinkURL() const;
548 
549 #if ENABLE(TOUCH_EVENTS)
550     bool allowsDoubleTapGesture() const override;
551 #endif
552 
553     StyleResolver&amp; styleResolver();
554     ElementStyle resolveStyle(const RenderStyle* parentStyle);
555 
556     // Invalidates the style of a single element. Style is resolved lazily.
557     // Descendant elements are resolved as needed, for example if an inherited property changes.
</pre>
<hr />
<pre>
563     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
564 
565     // Invalidate the element and all its descendants. This is used when there is some sort of change
566     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
567     // the case to limit the scope. This is expensive and should be avoided.
568     void invalidateStyleForSubtree();
569 
570     // Invalidates renderers for the element and all its descendants causing them to be torn down
571     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
572     // custom (not style based) renderers. This is expensive and should be avoided.
573     // Elements newly added to the tree are also in this state.
574     void invalidateStyleAndRenderersForSubtree();
575 
576     void invalidateStyleInternal();
577     void invalidateStyleForSubtreeInternal();
578 
579     bool hasDisplayContents() const;
580     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
581 
582     using ContainerNode::setAttributeEventListener;
<span class="line-modified">583     void setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value);</span>
584 
585 #if ENABLE(INTERSECTION_OBSERVER)
586     IntersectionObserverData&amp; ensureIntersectionObserverData();
587     IntersectionObserverData* intersectionObserverData();
588 #endif
589 





590     Element* findAnchorElementForLink(String&amp; outAnchorName);
591 
592     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);
593     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
594 
<span class="line-modified">595 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">596     OptionSet&lt;TouchAction&gt; computedTouchActions() const;</span>
<span class="line-removed">597 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-removed">598     ScrollingNodeID nearestScrollingNodeIDUsingTouchOverflowScrolling() const;</span>
<span class="line-removed">599 #endif</span>
<span class="line-removed">600 #endif</span>
601 
602 protected:
603     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
604 
605     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
606     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
607     void childrenChanged(const ChildChange&amp;) override;
608     void removeAllEventListeners() final;
609     virtual void parserDidSetAttributes();
610 
611     void clearTabIndexExplicitlyIfNeeded();
612     void setTabIndexExplicitly(int);
613 
614     // classAttributeChanged() exists to share code between
615     // parseAttribute (called via setAttribute()) and
616     // svgAttributeChanged (called when element.className.baseValue is set)
<span class="line-modified">617     void classAttributeChanged(const AtomicString&amp; newClassString);</span>
618 
619     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
620 
621     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
622 
623 #if ENABLE(CSS_TYPED_OM)
624     StylePropertyMap* attributeStyleMap();
625     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
626 #endif
627 
628 private:
629     Frame* documentFrameWithNonNullView() const;
630 
631     bool isTextNode() const;
632 
633     bool isUserActionElementInActiveChain() const;
634     bool isUserActionElementActive() const;
635     bool isUserActionElementFocused() const;
636     bool isUserActionElementHovered() const;
637 
638     virtual void didAddUserAgentShadowRoot(ShadowRoot&amp;) { }
639 
<span class="line-modified">640     void didAddAttribute(const QualifiedName&amp;, const AtomicString&amp;);</span>
<span class="line-modified">641     void willModifyAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue);</span>
<span class="line-modified">642     void didModifyAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue);</span>
<span class="line-modified">643     void didRemoveAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue);</span>
644 
645     void synchronizeAttribute(const QualifiedName&amp;) const;
<span class="line-modified">646     void synchronizeAttribute(const AtomicString&amp; localName) const;</span>
647 
<span class="line-modified">648     void updateName(const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
<span class="line-modified">649     void updateNameForTreeScope(TreeScope&amp;, const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
<span class="line-modified">650     void updateNameForDocument(HTMLDocument&amp;, const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
651 
652     enum class NotifyObservers { No, Yes };
<span class="line-modified">653     void updateId(const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
<span class="line-modified">654     void updateIdForTreeScope(TreeScope&amp;, const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
655 
656     enum HTMLDocumentNamedItemMapsUpdatingCondition { AlwaysUpdateHTMLDocumentNamedItemMaps, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute };
<span class="line-modified">657     void updateIdForDocument(HTMLDocument&amp;, const AtomicString&amp; oldId, const AtomicString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition);</span>
<span class="line-modified">658     void updateLabel(TreeScope&amp;, const AtomicString&amp; oldForAttributeValue, const AtomicString&amp; newForAttributeValue);</span>
659 
660     ExceptionOr&lt;Node*&gt; insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild);
661 
662     void scrollByUnits(int units, ScrollGranularity);
663 
664     NodeType nodeType() const final;
665     bool childTypeAllowed(NodeType) const final;
666 
667     enum SynchronizationOfLazyAttribute { NotInSynchronizationOfLazyAttribute, InSynchronizationOfLazyAttribute };
<span class="line-modified">668     void setAttributeInternal(unsigned index, const QualifiedName&amp;, const AtomicString&amp; value, SynchronizationOfLazyAttribute);</span>
<span class="line-modified">669     void addAttributeInternal(const QualifiedName&amp;, const AtomicString&amp; value, SynchronizationOfLazyAttribute);</span>
670     void removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute);
671 
672     LayoutRect absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements);
673     LayoutRect absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements);
674 
675 #if ENABLE(TREE_DEBUGGING)
676     void formatForDebugger(char* buffer, unsigned length) const override;
677 #endif
678 
679 #if ENABLE(INTERSECTION_OBSERVER)
680     void disconnectFromIntersectionObservers();
681 #endif
682 




683     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
684     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
685     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
686 
687     void removeShadowRoot();
688 
689     const RenderStyle&amp; resolveComputedStyle();
690     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
691 
<span class="line-removed">692     bool rareDataStyleAffectedByEmpty() const;</span>
<span class="line-removed">693     bool rareDataStyleAffectedByFocusWithin() const;</span>
<span class="line-removed">694     bool rareDataChildrenAffectedByHover() const;</span>
<span class="line-removed">695     bool rareDataStyleAffectedByActive() const;</span>
<span class="line-removed">696     bool rareDataChildrenAffectedByDrag() const;</span>
<span class="line-removed">697     bool rareDataChildrenAffectedByLastChildRules() const;</span>
<span class="line-removed">698     bool rareDataChildrenAffectedByForwardPositionalRules() const;</span>
<span class="line-removed">699     bool rareDataDescendantsAffectedByForwardPositionalRules() const;</span>
<span class="line-removed">700     bool rareDataChildrenAffectedByBackwardPositionalRules() const;</span>
<span class="line-removed">701     bool rareDataDescendantsAffectedByBackwardPositionalRules() const;</span>
<span class="line-removed">702     bool rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules() const;</span>
703     unsigned rareDataChildIndex() const;
704 
705     SpellcheckAttributeState spellcheckAttributeState() const;
706 
707     void createUniqueElementData();
708 
709     ElementRareData* elementRareData() const;
710     ElementRareData&amp; ensureElementRareData();
711 


712     void detachAllAttrNodesFromElement();
<span class="line-modified">713     void detachAttrNodeFromElementWithValue(Attr*, const AtomicString&amp; value);</span>
714 
715     // Anyone thinking of using this should call document instead of ownerDocument.
716     void ownerDocument() const = delete;
717 
718     void attachAttributeNodeIfNeeded(Attr&amp;);
719 
720     QualifiedName m_tagName;
721     RefPtr&lt;ElementData&gt; m_elementData;
722 };
723 
724 inline bool Node::hasAttributes() const
725 {
726     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
727 }
728 
729 inline NamedNodeMap* Node::attributes() const
730 {
731     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
732 }
733 
</pre>
<hr />
<pre>
737     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
738 }
739 
740 inline const Element* Element::rootElement() const
741 {
742     if (isConnected())
743         return document().documentElement();
744 
745     const Element* highest = this;
746     while (highest-&gt;parentElement())
747         highest = highest-&gt;parentElement();
748     return highest;
749 }
750 
751 inline bool Element::hasAttributeWithoutSynchronization(const QualifiedName&amp; name) const
752 {
753     ASSERT(fastAttributeLookupAllowed(name));
754     return elementData() &amp;&amp; findAttributeByName(name);
755 }
756 
<span class="line-modified">757 inline const AtomicString&amp; Element::attributeWithoutSynchronization(const QualifiedName&amp; name) const</span>
758 {
759     if (elementData()) {
760         if (const Attribute* attribute = findAttributeByName(name))
761             return attribute-&gt;value();
762     }
763     return nullAtom();
764 }
765 
766 inline bool Element::hasAttributesWithoutUpdate() const
767 {
768     return elementData() &amp;&amp; !elementData()-&gt;isEmpty();
769 }
770 
<span class="line-modified">771 inline const AtomicString&amp; Element::idForStyleResolution() const</span>
772 {
773     return hasID() ? elementData()-&gt;idForStyleResolution() : nullAtom();
774 }
775 
<span class="line-modified">776 inline const AtomicString&amp; Element::getIdAttribute() const</span>
777 {
778     if (hasID())
779         return elementData()-&gt;findAttributeByName(HTMLNames::idAttr)-&gt;value();
780     return nullAtom();
781 }
782 
<span class="line-modified">783 inline const AtomicString&amp; Element::getNameAttribute() const</span>
784 {
785     if (hasName())
786         return elementData()-&gt;findAttributeByName(HTMLNames::nameAttr)-&gt;value();
787     return nullAtom();
788 }
789 
<span class="line-modified">790 inline void Element::setIdAttribute(const AtomicString&amp; value)</span>
791 {
792     setAttributeWithoutSynchronization(HTMLNames::idAttr, value);
793 }
794 
795 inline const SpaceSplitString&amp; Element::classNames() const
796 {
797     ASSERT(hasClass());
798     ASSERT(elementData());
799     return elementData()-&gt;classNames();
800 }
801 
802 inline unsigned Element::attributeCount() const
803 {
804     ASSERT(elementData());
805     return elementData()-&gt;length();
806 }
807 
808 inline const Attribute&amp; Element::attributeAt(unsigned index) const
809 {
810     ASSERT(elementData());
</pre>
<hr />
<pre>
837     if (!elementData() || !elementData()-&gt;isUnique())
838         createUniqueElementData();
839     return static_cast&lt;UniqueElementData&amp;&gt;(*m_elementData);
840 }
841 
842 inline bool shouldIgnoreAttributeCase(const Element&amp; element)
843 {
844     return element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument();
845 }
846 
847 inline void Element::setHasFocusWithin(bool flag)
848 {
849     if (hasFocusWithin() == flag)
850         return;
851     setFlag(flag, HasFocusWithin);
852     if (styleAffectedByFocusWithin())
853         invalidateStyleForSubtree();
854 }
855 
856 template&lt;typename... QualifiedNames&gt;
<span class="line-modified">857 inline const AtomicString&amp; Element::getAttribute(const QualifiedName&amp; name, const QualifiedNames&amp;... names) const</span>
858 {
<span class="line-modified">859     const AtomicString&amp; value = getAttribute(name);</span>
860     if (!value.isNull())
861         return value;
862     return getAttribute(names...);
863 }
864 
865 } // namespace WebCore
866 
867 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Element)
868     static bool isType(const WebCore::Node&amp; node) { return node.isElementNode(); }
869     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
870 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
<td>
<hr />
<pre>
 46 class Frame;
 47 class HTMLDocument;
 48 class IntSize;
 49 class JSCustomElementInterface;
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
 59 struct ElementStyle;
 60 struct ScrollIntoViewOptions;
 61 
 62 #if ENABLE(INTERSECTION_OBSERVER)
 63 struct IntersectionObserverData;
 64 #endif
 65 
<span class="line-added"> 66 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added"> 67 struct ResizeObserverData;</span>
<span class="line-added"> 68 #endif</span>
<span class="line-added"> 69 </span>
 70 enum SpellcheckAttributeState {
 71     SpellcheckAttributeTrue,
 72     SpellcheckAttributeFalse,
 73     SpellcheckAttributeDefault
 74 };
 75 




 76 class Element : public ContainerNode {
 77     WTF_MAKE_ISO_ALLOCATED(Element);
 78 public:
 79     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 80     virtual ~Element();
 81 
 82     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
<span class="line-modified"> 83     WEBCORE_EXPORT const AtomString&amp; getAttribute(const QualifiedName&amp;) const;</span>
 84     template&lt;typename... QualifiedNames&gt;
<span class="line-modified"> 85     const AtomString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;</span>
<span class="line-modified"> 86     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomString&amp; value);</span>
<span class="line-modified"> 87     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomString&amp; value);</span>
<span class="line-modified"> 88     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomString&amp; value);</span>
 89     bool removeAttribute(const QualifiedName&amp;);
 90     Vector&lt;String&gt; getAttributeNames() const;
 91 
 92     // Typed getters and setters for language bindings.
 93     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 94     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 95     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 96     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
 97 
 98     // Call this to get the value of an attribute that is known not to be the style
 99     // attribute or one of the SVG animatable attributes.
100     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
<span class="line-modified">101     const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;</span>
102 #ifndef NDEBUG
103     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;
104 #endif
105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
109     WEBCORE_EXPORT bool hasAttributes() const;
110     // This variant will not update the potentially invalid attributes. To be used when not interested
111     // in style attribute or one of the SVG animation attributes.
112     bool hasAttributesWithoutUpdate() const;
113 
<span class="line-modified">114     WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;</span>
<span class="line-modified">115     WEBCORE_EXPORT bool hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;</span>
116 
<span class="line-modified">117     WEBCORE_EXPORT const AtomString&amp; getAttribute(const AtomString&amp; qualifiedName) const;</span>
<span class="line-modified">118     WEBCORE_EXPORT const AtomString&amp; getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;</span>
119 
<span class="line-modified">120     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value);</span>
<span class="line-modified">121     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName);</span>
<span class="line-modified">122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value);</span>
123 
<span class="line-modified">124     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force);</span>
125 
<span class="line-modified">126     const AtomString&amp; getIdAttribute() const;</span>
<span class="line-modified">127     void setIdAttribute(const AtomString&amp;);</span>
128 
<span class="line-modified">129     const AtomString&amp; getNameAttribute() const;</span>
130 
131     // Call this to get the value of the id attribute for style resolution purposes.
132     // The value will already be lowercased if the document is in compatibility mode,
133     // so this function is not suitable for non-style uses.
<span class="line-modified">134     const AtomString&amp; idForStyleResolution() const;</span>
135 
136     // Internal methods that assume the existence of attribute storage, one should use hasAttributes()
137     // before calling them.
138     AttributeIteratorAccessor attributesIterator() const { return elementData()-&gt;attributesIterator(); }
139     unsigned attributeCount() const;
140     const Attribute&amp; attributeAt(unsigned index) const;
141     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
142     unsigned findAttributeIndexByName(const QualifiedName&amp; name) const { return elementData()-&gt;findAttributeIndexByName(name); }
<span class="line-modified">143     unsigned findAttributeIndexByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const { return elementData()-&gt;findAttributeIndexByName(name, shouldIgnoreAttributeCase); }</span>
144 
145     WEBCORE_EXPORT void scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg);
146     WEBCORE_EXPORT void scrollIntoView(bool alignToTop = true);
147     WEBCORE_EXPORT void scrollIntoViewIfNeeded(bool centerIfNeeded = true);
148     WEBCORE_EXPORT void scrollIntoViewIfNotVisible(bool centerIfNotVisible = true);
149 
150     void scrollBy(const ScrollToOptions&amp;);
151     void scrollBy(double x, double y);
152     virtual void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped);
153     void scrollTo(double x, double y);
154 
155     WEBCORE_EXPORT void scrollByLines(int lines);
156     WEBCORE_EXPORT void scrollByPages(int pages);
157 
158     WEBCORE_EXPORT double offsetLeftForBindings();
159     WEBCORE_EXPORT double offsetLeft();
160     WEBCORE_EXPORT double offsetTopForBindings();
161     WEBCORE_EXPORT double offsetTop();
162     WEBCORE_EXPORT double offsetWidth();
163     WEBCORE_EXPORT double offsetHeight();
</pre>
<hr />
<pre>
168     // to the render layer and merge bindingsOffsetParent and offsetParent.
169     WEBCORE_EXPORT Element* offsetParentForBindings();
170 
171     const Element* rootElement() const;
172 
173     Element* offsetParent();
174     WEBCORE_EXPORT double clientLeft();
175     WEBCORE_EXPORT double clientTop();
176     WEBCORE_EXPORT double clientWidth();
177     WEBCORE_EXPORT double clientHeight();
178 
179     virtual int scrollLeft();
180     virtual int scrollTop();
181     virtual void setScrollLeft(int);
182     virtual void setScrollTop(int);
183     virtual int scrollWidth();
184     virtual int scrollHeight();
185 
186     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
187 
<span class="line-added">188     Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; boundingAbsoluteRectWithoutLayout();</span>
<span class="line-added">189 </span>
190     WEBCORE_EXPORT FloatRect boundingClientRect();
191 
192     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
193     Ref&lt;DOMRect&gt; getBoundingClientRect();
194 
195     // Returns the absolute bounding box translated into client coordinates.
196     WEBCORE_EXPORT IntRect clientRect() const;
197     // Returns the absolute bounding box translated into screen coordinates.
198     WEBCORE_EXPORT IntRect screenRect() const;
199 
<span class="line-modified">200     WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);</span>
<span class="line-modified">201     WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);</span>
202 
203     Ref&lt;Attr&gt; detachAttribute(unsigned index);
204 
<span class="line-modified">205     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomString&amp; qualifiedName);</span>
<span class="line-modified">206     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);</span>
207     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
208     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
209     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
210 
211     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
<span class="line-modified">212     RefPtr&lt;Attr&gt; attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase);</span>
213     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
214 
215     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
216 
217     const QualifiedName&amp; tagQName() const { return m_tagName; }
218 #if ENABLE(JIT)
219     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
220 #endif // ENABLE(JIT)
221     String tagName() const { return nodeName(); }
222     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
223     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
224     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
225     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
226 
227     // A fast function for checking the local name against another atomic string.
<span class="line-modified">228     bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }</span>
229 
<span class="line-modified">230     const AtomString&amp; localName() const final { return m_tagName.localName(); }</span>
<span class="line-modified">231     const AtomString&amp; prefix() const final { return m_tagName.prefix(); }</span>
<span class="line-modified">232     const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }</span>
233 
<span class="line-modified">234     ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;) final;</span>
235 
236     String nodeName() const override;
237 
238     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
239     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
240 
241     void normalizeAttributes();
242     String nodeNamePreservingCase() const;
243 
244     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
245 
246     // For exposing to DOM only.
247     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
248 
249     enum AttributeModificationReason {
250         ModifiedDirectly,
251         ModifiedByCloning
252     };
253 
254     // This method is called whenever an attribute is added, changed or removed.
<span class="line-modified">255     virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);</span>
<span class="line-modified">256     virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }</span>
257 
258     // Only called by the parser immediately after element construction.
259     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
260 
261     bool isEventHandlerAttribute(const Attribute&amp;) const;
262     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
263 
264     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
265     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
266 
267     const ElementData* elementData() const { return m_elementData.get(); }
268     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
269     UniqueElementData&amp; ensureUniqueElementData();
270 
271     void synchronizeAllAttributes() const;
272 
273     // Clones attributes only.
274     void cloneAttributesFromElement(const Element&amp;);
275 
276     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
</pre>
<hr />
<pre>
286     virtual bool rendererIsNeeded(const RenderStyle&amp;);
287 
288     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
289     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;
290 
291     struct ShadowRootInit {
292         ShadowRootMode mode;
293     };
294     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
295 
296     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
297     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
298 
299     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
300     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
301     void setIsCustomElementUpgradeCandidate();
302     void enqueueToUpgrade(JSCustomElementInterface&amp;);
303     CustomElementReactionQueue* reactionQueue() const;
304 
305     // FIXME: this should not be virtual, do not override this.
<span class="line-modified">306     virtual const AtomString&amp; shadowPseudoId() const;</span>
307 
308     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
309     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
310     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
311     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
312     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
313 
314     virtual void setActive(bool flag = true, bool pause = false);
315     virtual void setHovered(bool flag = true);
316     virtual void setFocus(bool flag);
317     void setHasFocusWithin(bool flag);
318 
<span class="line-modified">319     Optional&lt;int&gt; tabIndexSetExplicitly() const;</span>
<span class="line-added">320     bool shouldBeIgnoredInSequentialFocusNavigation() const { return defaultTabIndex() &lt; 0 &amp;&amp; !supportsFocus(); }</span>
321     virtual bool supportsFocus() const;
322     virtual bool isFocusable() const;
323     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
324     virtual bool isMouseFocusable() const;
325 
326     virtual bool shouldUseInputMethod();
327 
<span class="line-modified">328     virtual int tabIndexForBindings() const;</span>
<span class="line-modified">329     WEBCORE_EXPORT void setTabIndexForBindings(int);</span>
330     virtual RefPtr&lt;Element&gt; focusDelegate();
331 
332     ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html, NodeVector* addedNodes);
333 
334     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; insertAdjacentElement(const String&amp; where, Element&amp; newChild);
335     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html);
336     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentText(const String&amp; where, const String&amp; text);
337 
338     const RenderStyle* computedStyle(PseudoId = PseudoId::None) override;
339 
340     bool needsStyleInvalidation() const;
341 
342     // Methods for indicating the style is affected by dynamic updates (e.g., children changing, our position changing in our sibling list, etc.)
<span class="line-modified">343     bool styleAffectedByActive() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByActive); }</span>
<span class="line-modified">344     bool styleAffectedByEmpty() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }</span>
<span class="line-modified">345     bool styleAffectedByFocusWithin() const { return getFlag(StyleAffectedByFocusWithinFlag); }</span>
346     bool descendantsAffectedByPreviousSibling() const { return getFlag(DescendantsAffectedByPreviousSiblingFlag); }
347     bool childrenAffectedByHover() const { return getFlag(ChildrenAffectedByHoverRulesFlag); }
<span class="line-modified">348     bool childrenAffectedByDrag() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }</span>
349     bool childrenAffectedByFirstChildRules() const { return getFlag(ChildrenAffectedByFirstChildRulesFlag); }
350     bool childrenAffectedByLastChildRules() const { return getFlag(ChildrenAffectedByLastChildRulesFlag); }
<span class="line-modified">351     bool childrenAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }</span>
<span class="line-modified">352     bool descendantsAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }</span>
<span class="line-modified">353     bool childrenAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }</span>
<span class="line-modified">354     bool descendantsAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }</span>
<span class="line-modified">355     bool childrenAffectedByPropertyBasedBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }</span>
356     bool affectsNextSiblingElementStyle() const { return getFlag(AffectsNextSiblingElementStyle); }
357     unsigned childIndex() const { return hasRareData() ? rareDataChildIndex() : 0; }
358 
359     bool hasFlagsSetDuringStylingOfChildren() const;
360 
<span class="line-modified">361     void setStyleAffectedByEmpty() { setStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }</span>
<span class="line-modified">362     void setStyleAffectedByFocusWithin() { setFlag(StyleAffectedByFocusWithinFlag); }</span>
<span class="line-modified">363     void setDescendantsAffectedByPreviousSibling() { setFlag(DescendantsAffectedByPreviousSiblingFlag); }</span>
364     void setChildrenAffectedByHover() { setFlag(ChildrenAffectedByHoverRulesFlag); }
<span class="line-modified">365     void setStyleAffectedByActive() { setStyleFlag(ElementStyleFlag::StyleAffectedByActive); }</span>
<span class="line-modified">366     void setChildrenAffectedByDrag() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }</span>
367     void setChildrenAffectedByFirstChildRules() { setFlag(ChildrenAffectedByFirstChildRulesFlag); }
368     void setChildrenAffectedByLastChildRules() { setFlag(ChildrenAffectedByLastChildRulesFlag); }
<span class="line-modified">369     void setChildrenAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }</span>
<span class="line-modified">370     void setDescendantsAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }</span>
<span class="line-modified">371     void setChildrenAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }</span>
<span class="line-modified">372     void setDescendantsAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }</span>
<span class="line-modified">373     void setChildrenAffectedByPropertyBasedBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }</span>
374     void setAffectsNextSiblingElementStyle() { setFlag(AffectsNextSiblingElementStyle); }
375     void setStyleIsAffectedByPreviousSibling() { setFlag(StyleIsAffectedByPreviousSibling); }
376     void setChildIndex(unsigned);
377 
<span class="line-modified">378     WEBCORE_EXPORT AtomString computeInheritedLanguage() const;</span>
379     Locale&amp; locale() const;
380 
381     virtual void accessKeyAction(bool /*sendToAnyEvent*/) { }
382 
383     virtual bool isURLAttribute(const Attribute&amp;) const { return false; }
384     virtual bool attributeContainsURL(const Attribute&amp; attribute) const { return isURLAttribute(attribute); }
385     virtual String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const;
386     virtual bool isHTMLContentAttribute(const Attribute&amp;) const { return false; }
387 
388     WEBCORE_EXPORT URL getURLAttribute(const QualifiedName&amp;) const;
389     URL getNonEmptyURLAttribute(const QualifiedName&amp;) const;
390 
<span class="line-modified">391     virtual const AtomString&amp; imageSourceURL() const;</span>
392     virtual String target() const { return String(); }
393 
394     static AXTextStateChangeIntent defaultFocusTextStateChangeIntent() { return AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, true }); }
395     virtual void focus(bool restorePreviousSelection = true, FocusDirection = FocusDirectionNone);
396     virtual RefPtr&lt;Element&gt; focusAppearanceUpdateTarget();
397     virtual void updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode = SelectionRevealMode::Reveal);
398     virtual void blur();
399 
400     WEBCORE_EXPORT String innerHTML() const;
401     WEBCORE_EXPORT String outerHTML() const;
402     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
403     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
404     WEBCORE_EXPORT String innerText();
405     WEBCORE_EXPORT String outerText();
406 
407     virtual String title() const;
408 
<span class="line-modified">409     const AtomString&amp; pseudo() const;</span>
<span class="line-modified">410     WEBCORE_EXPORT void setPseudo(const AtomString&amp;);</span>
411 
412     LayoutSize minimumSizeForResizing() const;
413     void setMinimumSizeForResizing(const LayoutSize&amp;);
414 
415     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
416     virtual void prepareForDocumentSuspension() { }
417     virtual void resumeFromDocumentSuspension() { }
418 
419     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this
420     virtual void mediaVolumeDidChange() { }
421 
422     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.
<span class="line-modified">423     virtual void privateBrowsingStateDidChange(PAL::SessionID) { }</span>
424 
425     virtual void willBecomeFullscreenElement();
426     virtual void ancestorWillEnterFullscreen() { }
427     virtual void didBecomeFullscreenElement() { }
428     virtual void willStopBeingFullscreenElement() { }
429 
430 #if ENABLE(VIDEO_TRACK)
431     virtual void captionPreferencesChanged() { }
432 #endif
433 
434     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
435     void finishParsingChildren() override;
436     void beginParsingChildren() final;
437 
438     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
439     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
440     bool childNeedsShadowWalker() const;
441     void didShadowTreeAwareChildrenChange();
442 
443     virtual bool matchesValidPseudoClass() const;
</pre>
<hr />
<pre>
448     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
449     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
450     virtual bool shouldAppearIndeterminate() const;
451 
452     WEBCORE_EXPORT DOMTokenList&amp; classList();
453 
454     DatasetDOMStringMap&amp; dataset();
455 
456 #if ENABLE(VIDEO)
457     virtual bool isMediaElement() const { return false; }
458 #endif
459 
460     virtual bool isFormControlElement() const { return false; }
461     virtual bool isSpinButtonElement() const { return false; }
462     virtual bool isTextFormControlElement() const { return false; }
463     virtual bool isTextField() const { return false; }
464     virtual bool isOptionalFormControl() const { return false; }
465     virtual bool isRequiredFormControl() const { return false; }
466     virtual bool isInRange() const { return false; }
467     virtual bool isOutOfRange() const { return false; }

468     virtual bool isUploadButton() const { return false; }
469     virtual bool isSliderContainerElement() const { return false; }
470 
471     bool canContainRangeEndPoint() const override;
472 
473     // Used for disabled form elements; if true, prevents mouse events from being dispatched
474     // to event listeners, and prevents DOMActivate events from being sent at all.
475     virtual bool isDisabledFormControl() const { return false; }
476 
477     virtual bool childShouldCreateRenderer(const Node&amp;) const;
478 
479     bool hasPendingResources() const;
480     void setHasPendingResources();
481     void clearHasPendingResources();
482     virtual void buildPendingResource() { };
483 
484     bool hasCSSAnimation() const;
485     void setHasCSSAnimation();
486     void clearHasCSSAnimation();
487 
</pre>
<hr />
<pre>
495 #if ENABLE(POINTER_EVENTS)
496     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
497     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
498     bool hasPointerCapture(int32_t);
499 #endif
500 
501 #if ENABLE(POINTER_LOCK)
502     WEBCORE_EXPORT void requestPointerLock();
503 #endif
504 
505     bool isSpellCheckingEnabled() const;
506 
507     bool hasID() const;
508     bool hasClass() const;
509     bool hasName() const;
510     const SpaceSplitString&amp; classNames() const;
511 
512     IntPoint savedLayerScrollPosition() const;
513     void setSavedLayerScrollPosition(const IntPoint&amp;);
514 
<span class="line-modified">515     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);</span>
516     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
517     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
518     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
<span class="line-modified">519     void dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);</span>
<span class="line-modified">520     void dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);</span>
521     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
522     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
523     void dispatchWebKitImageReadyEventForTesting();
524 
525     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
526 
527     virtual void willRecalcStyle(Style::Change);
528     virtual void didRecalcStyle(Style::Change);
529     virtual void willResetComputedStyle();
530     virtual void willAttachRenderers();
531     virtual void didAttachRenderers();
532     virtual void willDetachRenderers();
533     virtual void didDetachRenderers();
534     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);
535 
536     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
537 
538     const RenderStyle* existingComputedStyle() const;
<span class="line-modified">539     WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;</span>
540 
541     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
542     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
543     void clearBeforePseudoElement();
544     void clearAfterPseudoElement();
545     void resetComputedStyle();
546     void resetStyleRelations();
547     void clearHoverAndActiveStatusBeforeDetachingRenderer();
548 
549     WEBCORE_EXPORT URL absoluteLinkURL() const;
550 
551 #if ENABLE(TOUCH_EVENTS)
552     bool allowsDoubleTapGesture() const override;
553 #endif
554 
555     StyleResolver&amp; styleResolver();
556     ElementStyle resolveStyle(const RenderStyle* parentStyle);
557 
558     // Invalidates the style of a single element. Style is resolved lazily.
559     // Descendant elements are resolved as needed, for example if an inherited property changes.
</pre>
<hr />
<pre>
565     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
566 
567     // Invalidate the element and all its descendants. This is used when there is some sort of change
568     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
569     // the case to limit the scope. This is expensive and should be avoided.
570     void invalidateStyleForSubtree();
571 
572     // Invalidates renderers for the element and all its descendants causing them to be torn down
573     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
574     // custom (not style based) renderers. This is expensive and should be avoided.
575     // Elements newly added to the tree are also in this state.
576     void invalidateStyleAndRenderersForSubtree();
577 
578     void invalidateStyleInternal();
579     void invalidateStyleForSubtreeInternal();
580 
581     bool hasDisplayContents() const;
582     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
583 
584     using ContainerNode::setAttributeEventListener;
<span class="line-modified">585     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value);</span>
586 
587 #if ENABLE(INTERSECTION_OBSERVER)
588     IntersectionObserverData&amp; ensureIntersectionObserverData();
589     IntersectionObserverData* intersectionObserverData();
590 #endif
591 
<span class="line-added">592 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">593     ResizeObserverData&amp; ensureResizeObserverData();</span>
<span class="line-added">594     ResizeObserverData* resizeObserverData();</span>
<span class="line-added">595 #endif</span>
<span class="line-added">596 </span>
597     Element* findAnchorElementForLink(String&amp; outAnchorName);
598 
599     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);
600     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
601 
<span class="line-modified">602     ElementIdentifier createElementIdentifier();</span>





603 
604 protected:
605     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
606 
607     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
608     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
609     void childrenChanged(const ChildChange&amp;) override;
610     void removeAllEventListeners() final;
611     virtual void parserDidSetAttributes();
612 
613     void clearTabIndexExplicitlyIfNeeded();
614     void setTabIndexExplicitly(int);
615 
616     // classAttributeChanged() exists to share code between
617     // parseAttribute (called via setAttribute()) and
618     // svgAttributeChanged (called when element.className.baseValue is set)
<span class="line-modified">619     void classAttributeChanged(const AtomString&amp; newClassString);</span>
620 
621     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
622 
623     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
624 
625 #if ENABLE(CSS_TYPED_OM)
626     StylePropertyMap* attributeStyleMap();
627     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
628 #endif
629 
630 private:
631     Frame* documentFrameWithNonNullView() const;
632 
633     bool isTextNode() const;
634 
635     bool isUserActionElementInActiveChain() const;
636     bool isUserActionElementActive() const;
637     bool isUserActionElementFocused() const;
638     bool isUserActionElementHovered() const;
639 
640     virtual void didAddUserAgentShadowRoot(ShadowRoot&amp;) { }
641 
<span class="line-modified">642     void didAddAttribute(const QualifiedName&amp;, const AtomString&amp;);</span>
<span class="line-modified">643     void willModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);</span>
<span class="line-modified">644     void didModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);</span>
<span class="line-modified">645     void didRemoveAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue);</span>
646 
647     void synchronizeAttribute(const QualifiedName&amp;) const;
<span class="line-modified">648     void synchronizeAttribute(const AtomString&amp; localName) const;</span>
649 
<span class="line-modified">650     void updateName(const AtomString&amp; oldName, const AtomString&amp; newName);</span>
<span class="line-modified">651     void updateNameForTreeScope(TreeScope&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);</span>
<span class="line-modified">652     void updateNameForDocument(HTMLDocument&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);</span>
653 
654     enum class NotifyObservers { No, Yes };
<span class="line-modified">655     void updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
<span class="line-modified">656     void updateIdForTreeScope(TreeScope&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
657 
658     enum HTMLDocumentNamedItemMapsUpdatingCondition { AlwaysUpdateHTMLDocumentNamedItemMaps, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute };
<span class="line-modified">659     void updateIdForDocument(HTMLDocument&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition);</span>
<span class="line-modified">660     void updateLabel(TreeScope&amp;, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue);</span>
661 
662     ExceptionOr&lt;Node*&gt; insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild);
663 
664     void scrollByUnits(int units, ScrollGranularity);
665 
666     NodeType nodeType() const final;
667     bool childTypeAllowed(NodeType) const final;
668 
669     enum SynchronizationOfLazyAttribute { NotInSynchronizationOfLazyAttribute, InSynchronizationOfLazyAttribute };
<span class="line-modified">670     void setAttributeInternal(unsigned index, const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);</span>
<span class="line-modified">671     void addAttributeInternal(const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);</span>
672     void removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute);
673 
674     LayoutRect absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements);
675     LayoutRect absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements);
676 
677 #if ENABLE(TREE_DEBUGGING)
678     void formatForDebugger(char* buffer, unsigned length) const override;
679 #endif
680 
681 #if ENABLE(INTERSECTION_OBSERVER)
682     void disconnectFromIntersectionObservers();
683 #endif
684 
<span class="line-added">685 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">686     void disconnectFromResizeObservers();</span>
<span class="line-added">687 #endif</span>
<span class="line-added">688 </span>
689     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
690     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
691     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
692 
693     void removeShadowRoot();
694 
695     const RenderStyle&amp; resolveComputedStyle();
696     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
697 











698     unsigned rareDataChildIndex() const;
699 
700     SpellcheckAttributeState spellcheckAttributeState() const;
701 
702     void createUniqueElementData();
703 
704     ElementRareData* elementRareData() const;
705     ElementRareData&amp; ensureElementRareData();
706 
<span class="line-added">707     virtual int defaultTabIndex() const;</span>
<span class="line-added">708 </span>
709     void detachAllAttrNodesFromElement();
<span class="line-modified">710     void detachAttrNodeFromElementWithValue(Attr*, const AtomString&amp; value);</span>
711 
712     // Anyone thinking of using this should call document instead of ownerDocument.
713     void ownerDocument() const = delete;
714 
715     void attachAttributeNodeIfNeeded(Attr&amp;);
716 
717     QualifiedName m_tagName;
718     RefPtr&lt;ElementData&gt; m_elementData;
719 };
720 
721 inline bool Node::hasAttributes() const
722 {
723     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
724 }
725 
726 inline NamedNodeMap* Node::attributes() const
727 {
728     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
729 }
730 
</pre>
<hr />
<pre>
734     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
735 }
736 
737 inline const Element* Element::rootElement() const
738 {
739     if (isConnected())
740         return document().documentElement();
741 
742     const Element* highest = this;
743     while (highest-&gt;parentElement())
744         highest = highest-&gt;parentElement();
745     return highest;
746 }
747 
748 inline bool Element::hasAttributeWithoutSynchronization(const QualifiedName&amp; name) const
749 {
750     ASSERT(fastAttributeLookupAllowed(name));
751     return elementData() &amp;&amp; findAttributeByName(name);
752 }
753 
<span class="line-modified">754 inline const AtomString&amp; Element::attributeWithoutSynchronization(const QualifiedName&amp; name) const</span>
755 {
756     if (elementData()) {
757         if (const Attribute* attribute = findAttributeByName(name))
758             return attribute-&gt;value();
759     }
760     return nullAtom();
761 }
762 
763 inline bool Element::hasAttributesWithoutUpdate() const
764 {
765     return elementData() &amp;&amp; !elementData()-&gt;isEmpty();
766 }
767 
<span class="line-modified">768 inline const AtomString&amp; Element::idForStyleResolution() const</span>
769 {
770     return hasID() ? elementData()-&gt;idForStyleResolution() : nullAtom();
771 }
772 
<span class="line-modified">773 inline const AtomString&amp; Element::getIdAttribute() const</span>
774 {
775     if (hasID())
776         return elementData()-&gt;findAttributeByName(HTMLNames::idAttr)-&gt;value();
777     return nullAtom();
778 }
779 
<span class="line-modified">780 inline const AtomString&amp; Element::getNameAttribute() const</span>
781 {
782     if (hasName())
783         return elementData()-&gt;findAttributeByName(HTMLNames::nameAttr)-&gt;value();
784     return nullAtom();
785 }
786 
<span class="line-modified">787 inline void Element::setIdAttribute(const AtomString&amp; value)</span>
788 {
789     setAttributeWithoutSynchronization(HTMLNames::idAttr, value);
790 }
791 
792 inline const SpaceSplitString&amp; Element::classNames() const
793 {
794     ASSERT(hasClass());
795     ASSERT(elementData());
796     return elementData()-&gt;classNames();
797 }
798 
799 inline unsigned Element::attributeCount() const
800 {
801     ASSERT(elementData());
802     return elementData()-&gt;length();
803 }
804 
805 inline const Attribute&amp; Element::attributeAt(unsigned index) const
806 {
807     ASSERT(elementData());
</pre>
<hr />
<pre>
834     if (!elementData() || !elementData()-&gt;isUnique())
835         createUniqueElementData();
836     return static_cast&lt;UniqueElementData&amp;&gt;(*m_elementData);
837 }
838 
839 inline bool shouldIgnoreAttributeCase(const Element&amp; element)
840 {
841     return element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument();
842 }
843 
844 inline void Element::setHasFocusWithin(bool flag)
845 {
846     if (hasFocusWithin() == flag)
847         return;
848     setFlag(flag, HasFocusWithin);
849     if (styleAffectedByFocusWithin())
850         invalidateStyleForSubtree();
851 }
852 
853 template&lt;typename... QualifiedNames&gt;
<span class="line-modified">854 inline const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name, const QualifiedNames&amp;... names) const</span>
855 {
<span class="line-modified">856     const AtomString&amp; value = getAttribute(name);</span>
857     if (!value.isNull())
858         return value;
859     return getAttribute(names...);
860 }
861 
862 } // namespace WebCore
863 
864 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Element)
865     static bool isType(const WebCore::Node&amp; node) { return node.isElementNode(); }
866     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
867 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
</tr>
</table>
<center><a href="Element.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>