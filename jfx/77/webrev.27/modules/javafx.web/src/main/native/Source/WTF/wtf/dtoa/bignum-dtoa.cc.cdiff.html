<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/bignum-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../dtoa.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="bignum-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/bignum-dtoa.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,67 ***</span>
  #include &lt;wtf/dtoa/bignum.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">!     </span>
  static int NormalizedExponent(uint64_t significand, int exponent) {
<span class="line-modified">!         ASSERT(significand != 0);</span>
<span class="line-modified">!         while ((significand &amp; Double::kHiddenBit) == 0) {</span>
<span class="line-modified">!             significand = significand &lt;&lt; 1;</span>
<span class="line-modified">!             exponent = exponent - 1;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return exponent;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Forward declarations:
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k.
  static int EstimatePower(int exponent);
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator.
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="line-modified">!                                          int estimated_power,</span>
<span class="line-modified">!                                          bool need_boundary_deltas,</span>
<span class="line-modified">!                                          Bignum* numerator,</span>
<span class="line-modified">!                                          Bignum* denominator,</span>
<span class="line-modified">!                                          Bignum* delta_minus,</span>
<span class="line-modified">!                                          Bignum* delta_plus);</span>
  // Multiplies numerator/denominator so that its values lies in the range 1-10.
  // Returns decimal_point s.t.
  //  v = numerator&#39;/denominator&#39; * 10^(decimal_point-1)
  //     where numerator&#39; and denominator&#39; are the values of numerator and
  //     denominator after the call to this function.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="line-modified">!                                 int* decimal_point,</span>
<span class="line-modified">!                                 Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                 Bignum* delta_minus, Bignum* delta_plus);</span>
  // Generates digits from the left to the right and stops when the generated
  // digits yield the shortest decimal representation of v.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="line-modified">!                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified">!                                        bool is_even,</span>
<span class="line-modified">!                                        BufferReference&lt;char&gt; buffer, int* length);</span>
  // Generates &#39;requested_digits&#39; after the decimal point.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="line-modified">!                               Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                               BufferReference&lt;char&gt;(buffer), int* length);</span>
  // Generates &#39;count&#39; digits of numerator/denominator.
  // Once &#39;count&#39; digits have been produced rounds the result depending on the
  // remainder (remainders of exactly .5 round upwards). Might update the
  // decimal_point when rounding up (for example for 0.9999).
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="line-modified">!                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                       BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
<span class="line-modified">!                     BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {</span>
<span class="line-modified">!         ASSERT(v &gt; 0);</span>
<span class="line-modified">!         ASSERT(!Double(v).IsSpecial());</span>
    uint64_t significand;
    int exponent;
    bool lower_boundary_is_closer;
    if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {
      float f = static_cast&lt;float&gt;(v);
<span class="line-new-header">--- 34,67 ---</span>
  #include &lt;wtf/dtoa/bignum.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">! </span>
  static int NormalizedExponent(uint64_t significand, int exponent) {
<span class="line-modified">!   ASSERT(significand != 0);</span>
<span class="line-modified">!   while ((significand &amp; Double::kHiddenBit) == 0) {</span>
<span class="line-modified">!     significand = significand &lt;&lt; 1;</span>
<span class="line-modified">!     exponent = exponent - 1;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return exponent;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Forward declarations:
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k.
  static int EstimatePower(int exponent);
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator.
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="line-modified">!                                      int estimated_power,</span>
<span class="line-modified">!                                      bool need_boundary_deltas,</span>
<span class="line-modified">!                                      Bignum* numerator,</span>
<span class="line-modified">!                                      Bignum* denominator,</span>
<span class="line-modified">!                                      Bignum* delta_minus,</span>
<span class="line-modified">!                                      Bignum* delta_plus);</span>
  // Multiplies numerator/denominator so that its values lies in the range 1-10.
  // Returns decimal_point s.t.
  //  v = numerator&#39;/denominator&#39; * 10^(decimal_point-1)
  //     where numerator&#39; and denominator&#39; are the values of numerator and
  //     denominator after the call to this function.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="line-modified">!                             int* decimal_point,</span>
<span class="line-modified">!                             Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                             Bignum* delta_minus, Bignum* delta_plus);</span>
  // Generates digits from the left to the right and stops when the generated
  // digits yield the shortest decimal representation of v.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="line-modified">!                                    Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified">!                                    bool is_even,</span>
<span class="line-modified">!                                    BufferReference&lt;char&gt; buffer, int* length);</span>
  // Generates &#39;requested_digits&#39; after the decimal point.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="line-modified">!                           Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                           BufferReference&lt;char&gt;(buffer), int* length);</span>
  // Generates &#39;count&#39; digits of numerator/denominator.
  // Once &#39;count&#39; digits have been produced rounds the result depending on the
  // remainder (remainders of exactly .5 round upwards). Might update the
  // decimal_point when rounding up (for example for 0.9999).
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="line-modified">!                                   Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                   BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
<span class="line-modified">!                 BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {</span>
<span class="line-modified">!   ASSERT(v &gt; 0);</span>
<span class="line-modified">!   ASSERT(!Double(v).IsSpecial());</span>
    uint64_t significand;
    int exponent;
    bool lower_boundary_is_closer;
    if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {
      float f = static_cast&lt;float&gt;(v);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,72 ***</span>
      lower_boundary_is_closer = Double(v).LowerBoundaryIsCloser();
    }
    bool need_boundary_deltas =
        (mode == BIGNUM_DTOA_SHORTEST || mode == BIGNUM_DTOA_SHORTEST_SINGLE);
  
<span class="line-modified">!         bool is_even = (significand &amp; 1) == 0;</span>
<span class="line-modified">!         int normalized_exponent = NormalizedExponent(significand, exponent);</span>
<span class="line-modified">!         // estimated_power might be too low by 1.</span>
<span class="line-modified">!         int estimated_power = EstimatePower(normalized_exponent);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Shortcut for Fixed.</span>
<span class="line-modified">!         // The requested digits correspond to the digits after the point. If the</span>
<span class="line-modified">!         // number is much too small, then there is no need in trying to get any</span>
<span class="line-modified">!         // digits.</span>
<span class="line-modified">!         if (mode == BIGNUM_DTOA_FIXED &amp;&amp; -estimated_power - 1 &gt; requested_digits) {</span>
<span class="line-modified">!             buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">!             *length = 0;</span>
<span class="line-modified">!             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">!             // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">!             // empty.</span>
<span class="line-modified">!             *decimal_point = -requested_digits;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         Bignum numerator;</span>
<span class="line-modified">!         Bignum denominator;</span>
<span class="line-modified">!         Bignum delta_minus;</span>
<span class="line-modified">!         Bignum delta_plus;</span>
<span class="line-modified">!         // Make sure the bignum can grow large enough. The smallest double equals</span>
<span class="line-modified">!         // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.</span>
<span class="line-modified">!         // The maximum double is 1.7976931348623157e308 which needs fewer than</span>
<span class="line-modified">!         // 308*4 binary digits.</span>
<span class="line-modified">!         ASSERT(Bignum::kMaxSignificantBits &gt;= 324*4);</span>
    InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,
                             estimated_power, need_boundary_deltas,
<span class="line-modified">!                                  &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                                  &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">!         // We now have v = (numerator / denominator) * 10^estimated_power.</span>
<span class="line-modified">!         FixupMultiply10(estimated_power, is_even, decimal_point,</span>
<span class="line-modified">!                         &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                         &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">!         // We now have v = (numerator / denominator) * 10^(decimal_point-1), and</span>
<span class="line-modified">!         //  1 &lt;= (numerator + delta_plus) / denominator &lt; 10</span>
<span class="line-modified">!         switch (mode) {</span>
<span class="line-modified">!             case BIGNUM_DTOA_SHORTEST:</span>
      case BIGNUM_DTOA_SHORTEST_SINGLE:
<span class="line-modified">!                 GenerateShortestDigits(&amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                                        &amp;delta_minus, &amp;delta_plus,</span>
<span class="line-modified">!                                        is_even, buffer, length);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case BIGNUM_DTOA_FIXED:</span>
<span class="line-modified">!                 BignumToFixed(requested_digits, decimal_point,</span>
<span class="line-modified">!                               &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                               buffer, length);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case BIGNUM_DTOA_PRECISION:</span>
<span class="line-modified">!                 GenerateCountedDigits(requested_digits, decimal_point,</span>
<span class="line-modified">!                                       &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                                       buffer, length);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 UNREACHABLE();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         buffer[*length] = &#39;\0&#39;;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // The procedure starts generating digits from the left to the right and stops
  // when the generated digits yield the shortest decimal representation of v. A
  // decimal representation of v is a number lying closer to v than to any other
  // double, so it converts to v when read.
  //
<span class="line-new-header">--- 108,72 ---</span>
      lower_boundary_is_closer = Double(v).LowerBoundaryIsCloser();
    }
    bool need_boundary_deltas =
        (mode == BIGNUM_DTOA_SHORTEST || mode == BIGNUM_DTOA_SHORTEST_SINGLE);
  
<span class="line-modified">!   bool is_even = (significand &amp; 1) == 0;</span>
<span class="line-modified">!   int normalized_exponent = NormalizedExponent(significand, exponent);</span>
<span class="line-modified">!   // estimated_power might be too low by 1.</span>
<span class="line-modified">!   int estimated_power = EstimatePower(normalized_exponent);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Shortcut for Fixed.</span>
<span class="line-modified">!   // The requested digits correspond to the digits after the point. If the</span>
<span class="line-modified">!   // number is much too small, then there is no need in trying to get any</span>
<span class="line-modified">!   // digits.</span>
<span class="line-modified">!   if (mode == BIGNUM_DTOA_FIXED &amp;&amp; -estimated_power - 1 &gt; requested_digits) {</span>
<span class="line-modified">!     buffer[0] = &#39;\0&#39;;</span>
<span class="line-modified">!     *length = 0;</span>
<span class="line-modified">!     // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">!     // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">!     // empty.</span>
<span class="line-modified">!     *decimal_point = -requested_digits;</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Bignum numerator;</span>
<span class="line-modified">!   Bignum denominator;</span>
<span class="line-modified">!   Bignum delta_minus;</span>
<span class="line-modified">!   Bignum delta_plus;</span>
<span class="line-modified">!   // Make sure the bignum can grow large enough. The smallest double equals</span>
<span class="line-modified">!   // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.</span>
<span class="line-modified">!   // The maximum double is 1.7976931348623157e308 which needs fewer than</span>
<span class="line-modified">!   // 308*4 binary digits.</span>
<span class="line-modified">!   ASSERT(Bignum::kMaxSignificantBits &gt;= 324*4);</span>
    InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,
                             estimated_power, need_boundary_deltas,
<span class="line-modified">!                            &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                            &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">!   // We now have v = (numerator / denominator) * 10^estimated_power.</span>
<span class="line-modified">!   FixupMultiply10(estimated_power, is_even, decimal_point,</span>
<span class="line-modified">!                   &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                   &amp;delta_minus, &amp;delta_plus);</span>
<span class="line-modified">!   // We now have v = (numerator / denominator) * 10^(decimal_point-1), and</span>
<span class="line-modified">!   //  1 &lt;= (numerator + delta_plus) / denominator &lt; 10</span>
<span class="line-modified">!   switch (mode) {</span>
<span class="line-modified">!     case BIGNUM_DTOA_SHORTEST:</span>
      case BIGNUM_DTOA_SHORTEST_SINGLE:
<span class="line-modified">!       GenerateShortestDigits(&amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                              &amp;delta_minus, &amp;delta_plus,</span>
<span class="line-modified">!                              is_even, buffer, length);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case BIGNUM_DTOA_FIXED:</span>
<span class="line-modified">!       BignumToFixed(requested_digits, decimal_point,</span>
<span class="line-modified">!                     &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                     buffer, length);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case BIGNUM_DTOA_PRECISION:</span>
<span class="line-modified">!       GenerateCountedDigits(requested_digits, decimal_point,</span>
<span class="line-modified">!                             &amp;numerator, &amp;denominator,</span>
<span class="line-modified">!                             buffer, length);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!       UNREACHABLE();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   buffer[*length] = &#39;\0&#39;;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // The procedure starts generating digits from the left to the right and stops
  // when the generated digits yield the shortest decimal representation of v. A
  // decimal representation of v is a number lying closer to v than to any other
  // double, so it converts to v when read.
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,194 ***</span>
  //
  // Precondition: 0 &lt;= (numerator+delta_plus) / denominator &lt; 10.
  //   If 1 &lt;= (numerator+delta_plus) / denominator &lt; 10 then no leading 0 digit
  //   will be produced. This should be the standard precondition.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="line-modified">!                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified">!                                        bool is_even,</span>
<span class="line-modified">!                                        BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!         // Small optimization: if delta_minus and delta_plus are the same just reuse</span>
<span class="line-modified">!         // one of the two bignums.</span>
<span class="line-modified">!         if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">!             delta_plus = delta_minus;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         *length = 0;</span>
    for (;;) {
<span class="line-modified">!             uint16_t digit;</span>
<span class="line-modified">!             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">!             // digit = numerator / denominator (integer division).</span>
<span class="line-modified">!             // numerator = numerator % denominator.</span>
      buffer[(*length)++] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">!             </span>
<span class="line-modified">!             // Can we stop already?</span>
<span class="line-modified">!             // If the remainder of the division is less than the distance to the lower</span>
<span class="line-modified">!             // boundary we can stop. In this case we simply round down (discarding the</span>
<span class="line-modified">!             // remainder).</span>
<span class="line-modified">!             // Similarly we test if we can round up (using the upper boundary).</span>
<span class="line-modified">!             bool in_delta_room_minus;</span>
<span class="line-modified">!             bool in_delta_room_plus;</span>
<span class="line-modified">!             if (is_even) {</span>
<span class="line-modified">!                 in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (is_even) {</span>
<span class="line-modified">!                 in_delta_room_plus =</span>
<span class="line-modified">!                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 in_delta_room_plus =</span>
<span class="line-modified">!                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (!in_delta_room_minus &amp;&amp; !in_delta_room_plus) {</span>
<span class="line-modified">!                 // Prepare for next iteration.</span>
<span class="line-modified">!                 numerator-&gt;Times10();</span>
<span class="line-modified">!                 delta_minus-&gt;Times10();</span>
<span class="line-modified">!                 // We optimized delta_plus to be equal to delta_minus (if they share the</span>
<span class="line-modified">!                 // same value). So don&#39;t multiply delta_plus if they point to the same</span>
<span class="line-modified">!                 // object.</span>
<span class="line-modified">!                 if (delta_minus != delta_plus) {</span>
<span class="line-modified">!                     delta_plus-&gt;Times10();</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else if (in_delta_room_minus &amp;&amp; in_delta_room_plus) {</span>
<span class="line-modified">!                 // Let&#39;s see if 2*numerator &lt; denominator.</span>
<span class="line-modified">!                 // If yes, then the next digit would be &lt; 5 and we can round down.</span>
<span class="line-modified">!                 int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);</span>
<span class="line-modified">!                 if (compare &lt; 0) {</span>
<span class="line-modified">!                     // Remaining digits are less than .5. -&gt; Round down (== do nothing).</span>
<span class="line-modified">!                 } else if (compare &gt; 0) {</span>
<span class="line-modified">!                     // Remaining digits are more than .5 of denominator. -&gt; Round up.</span>
<span class="line-modified">!                     // Note that the last digit could not be a &#39;9&#39; as otherwise the whole</span>
<span class="line-modified">!                     // loop would have stopped earlier.</span>
<span class="line-modified">!                     // We still have an assert here in case the preconditions were not</span>
<span class="line-modified">!                     // satisfied.</span>
<span class="line-modified">!                     ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">!                     buffer[(*length) - 1]++;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     // Halfway case.</span>
<span class="line-modified">!                     // TODO(floitsch): need a way to solve half-way cases.</span>
<span class="line-modified">!                     //   For now let&#39;s round towards even (since this is what Gay seems to</span>
<span class="line-modified">!                     //   do).</span>
<span class="line-modified">!                     </span>
<span class="line-modified">!                     if ((buffer[(*length) - 1] - &#39;0&#39;) % 2 == 0) {</span>
<span class="line-modified">!                         // Round down =&gt; Do nothing.</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">!                         buffer[(*length) - 1]++;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             } else if (in_delta_room_minus) {</span>
<span class="line-removed">-                 // Round down (== do nothing).</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             } else {  // in_delta_room_plus</span>
<span class="line-removed">-                 // Round up.</span>
<span class="line-removed">-                 // Note again that the last digit could not be &#39;9&#39; since this would have</span>
<span class="line-removed">-                 // stopped the loop earlier.</span>
<span class="line-removed">-                 // We still have an ASSERT here, in case the preconditions were not</span>
<span class="line-removed">-                 // satisfied.</span>
<span class="line-removed">-                 ASSERT(buffer[(*length) -1] != &#39;9&#39;);</span>
<span class="line-removed">-                 buffer[(*length) - 1]++;</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
          }
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Let v = numerator / denominator &lt; 10.
  // Then we generate &#39;count&#39; digits of d = x.xxxxx... (without the decimal point)
  // from left to right. Once &#39;count&#39; digits have been produced we decide wether
  // to round up or down. Remainders of exactly .5 round upwards. Numbers such
  // as 9.999999 propagate a carry all the way, and change the
  // exponent (decimal_point), when rounding upwards.
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="line-modified">!                                       Bignum* numerator, Bignum* denominator,</span>
                                    BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!         ASSERT(count &gt;= 0);</span>
<span class="line-modified">!         for (int i = 0; i &lt; count - 1; ++i) {</span>
<span class="line-modified">!             uint16_t digit;</span>
<span class="line-modified">!             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">!             // digit = numerator / denominator (integer division).</span>
<span class="line-modified">!             // numerator = numerator % denominator.</span>
      buffer[i] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">!             // Prepare for next iteration.</span>
<span class="line-modified">!             numerator-&gt;Times10();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Generate the last digit.</span>
<span class="line-modified">!         uint16_t digit;</span>
<span class="line-modified">!         digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!         if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">!             digit++;</span>
<span class="line-modified">!         }</span>
    ASSERT(digit &lt;= 10);
    buffer[count - 1] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">!         // Correct bad digits (in case we had a sequence of &#39;9&#39;s). Propagate the</span>
<span class="line-modified">!         // carry until we hat a non-&#39;9&#39; or til we reach the first digit.</span>
<span class="line-modified">!         for (int i = count - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!             if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">!             buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!             buffer[i - 1]++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!             // Propagate a carry past the top place.</span>
<span class="line-modified">!             buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!             (*decimal_point)++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         *length = count;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Generates &#39;requested_digits&#39; after the decimal point. It might omit
  // trailing &#39;0&#39;s. If the input number is too small then no digits at all are
  // generated (ex.: 2 fixed digits for 0.00001).
  //
  // Input verifies:  1 &lt;= (numerator + delta) / denominator &lt; 10.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="line-modified">!                               Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                               BufferReference&lt;char&gt;(buffer), int* length) {</span>
<span class="line-modified">!         // Note that we have to look at more than just the requested_digits, since</span>
<span class="line-modified">!         // a number could be rounded up. Example: v=0.5 with requested_digits=0.</span>
<span class="line-modified">!         // Even though the power of v equals 0 we can&#39;t just stop here.</span>
<span class="line-modified">!         if (-(*decimal_point) &gt; requested_digits) {</span>
<span class="line-modified">!             // The number is definitively too small.</span>
<span class="line-modified">!             // Ex: 0.001 with requested_digits == 1.</span>
<span class="line-modified">!             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">!             // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">!             // empty.</span>
<span class="line-modified">!             *decimal_point = -requested_digits;</span>
<span class="line-modified">!             *length = 0;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         } else if (-(*decimal_point) == requested_digits) {</span>
<span class="line-modified">!             // We only need to verify if the number rounds down or up.</span>
<span class="line-modified">!             // Ex: 0.04 and 0.06 with requested_digits == 1.</span>
<span class="line-modified">!             ASSERT(*decimal_point == -requested_digits);</span>
<span class="line-modified">!             // Initially the fraction lies in range (1, 10]. Multiply the denominator</span>
<span class="line-modified">!             // by 10 so that we can compare more easily.</span>
<span class="line-modified">!             denominator-&gt;Times10();</span>
<span class="line-modified">!             if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">!                 // If the fraction is &gt;= 0.5 then we have to include the rounded</span>
<span class="line-modified">!                 // digit.</span>
<span class="line-modified">!                 buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!                 *length = 1;</span>
<span class="line-modified">!                 (*decimal_point)++;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 // Note that we caught most of similar cases earlier.</span>
<span class="line-modified">!                 *length = 0;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             // The requested digits correspond to the digits after the point.</span>
<span class="line-modified">!             // The variable &#39;needed_digits&#39; includes the digits before the point.</span>
<span class="line-modified">!             int needed_digits = (*decimal_point) + requested_digits;</span>
<span class="line-modified">!             GenerateCountedDigits(needed_digits, decimal_point,</span>
<span class="line-modified">!                                   numerator, denominator,</span>
<span class="line-modified">!                                   buffer, length);</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k where
  // v = f * 2^exponent and 2^52 &lt;= f &lt; 2^53.
  // v is hence a normalized double with the given exponent. The output is an
  // approximation for the exponent of the decimal approimation .digits * 10^k.
  //
<span class="line-new-header">--- 184,194 ---</span>
  //
  // Precondition: 0 &lt;= (numerator+delta_plus) / denominator &lt; 10.
  //   If 1 &lt;= (numerator+delta_plus) / denominator &lt; 10 then no leading 0 digit
  //   will be produced. This should be the standard precondition.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="line-modified">!                                    Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="line-modified">!                                    bool is_even,</span>
<span class="line-modified">!                                    BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="line-modified">!   // Small optimization: if delta_minus and delta_plus are the same just reuse</span>
<span class="line-modified">!   // one of the two bignums.</span>
<span class="line-modified">!   if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">!     delta_plus = delta_minus;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   *length = 0;</span>
    for (;;) {
<span class="line-modified">!     uint16_t digit;</span>
<span class="line-modified">!     digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!     ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">!     // digit = numerator / denominator (integer division).</span>
<span class="line-modified">!     // numerator = numerator % denominator.</span>
      buffer[(*length)++] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">! </span>
<span class="line-modified">!     // Can we stop already?</span>
<span class="line-modified">!     // If the remainder of the division is less than the distance to the lower</span>
<span class="line-modified">!     // boundary we can stop. In this case we simply round down (discarding the</span>
<span class="line-modified">!     // remainder).</span>
<span class="line-modified">!     // Similarly we test if we can round up (using the upper boundary).</span>
<span class="line-modified">!     bool in_delta_room_minus;</span>
<span class="line-modified">!     bool in_delta_room_plus;</span>
<span class="line-modified">!     if (is_even) {</span>
<span class="line-modified">!       in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (is_even) {</span>
<span class="line-modified">!       in_delta_room_plus =</span>
<span class="line-modified">!           Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       in_delta_room_plus =</span>
<span class="line-modified">!           Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (!in_delta_room_minus &amp;&amp; !in_delta_room_plus) {</span>
<span class="line-modified">!       // Prepare for next iteration.</span>
<span class="line-modified">!       numerator-&gt;Times10();</span>
<span class="line-modified">!       delta_minus-&gt;Times10();</span>
<span class="line-modified">!       // We optimized delta_plus to be equal to delta_minus (if they share the</span>
<span class="line-modified">!       // same value). So don&#39;t multiply delta_plus if they point to the same</span>
<span class="line-modified">!       // object.</span>
<span class="line-modified">!       if (delta_minus != delta_plus) {</span>
<span class="line-modified">!         delta_plus-&gt;Times10();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     } else if (in_delta_room_minus &amp;&amp; in_delta_room_plus) {</span>
<span class="line-modified">!       // Let&#39;s see if 2*numerator &lt; denominator.</span>
<span class="line-modified">!       // If yes, then the next digit would be &lt; 5 and we can round down.</span>
<span class="line-modified">!       int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);</span>
<span class="line-modified">!       if (compare &lt; 0) {</span>
<span class="line-modified">!         // Remaining digits are less than .5. -&gt; Round down (== do nothing).</span>
<span class="line-modified">!       } else if (compare &gt; 0) {</span>
<span class="line-modified">!         // Remaining digits are more than .5 of denominator. -&gt; Round up.</span>
<span class="line-modified">!         // Note that the last digit could not be a &#39;9&#39; as otherwise the whole</span>
<span class="line-modified">!         // loop would have stopped earlier.</span>
<span class="line-modified">!         // We still have an assert here in case the preconditions were not</span>
<span class="line-modified">!         // satisfied.</span>
<span class="line-modified">!         ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">!         buffer[(*length) - 1]++;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         // Halfway case.</span>
<span class="line-modified">!         // TODO(floitsch): need a way to solve half-way cases.</span>
<span class="line-modified">!         //   For now let&#39;s round towards even (since this is what Gay seems to</span>
<span class="line-modified">!         //   do).</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if ((buffer[(*length) - 1] - &#39;0&#39;) % 2 == 0) {</span>
<span class="line-modified">!           // Round down =&gt; Do nothing.</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="line-modified">!           buffer[(*length) - 1]++;</span>
          }
<span class="line-added">+       }</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     } else if (in_delta_room_minus) {</span>
<span class="line-added">+       // Round down (== do nothing).</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     } else {  // in_delta_room_plus</span>
<span class="line-added">+       // Round up.</span>
<span class="line-added">+       // Note again that the last digit could not be &#39;9&#39; since this would have</span>
<span class="line-added">+       // stopped the loop earlier.</span>
<span class="line-added">+       // We still have an ASSERT here, in case the preconditions were not</span>
<span class="line-added">+       // satisfied.</span>
<span class="line-added">+       ASSERT(buffer[(*length) -1] != &#39;9&#39;);</span>
<span class="line-added">+       buffer[(*length) - 1]++;</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Let v = numerator / denominator &lt; 10.
  // Then we generate &#39;count&#39; digits of d = x.xxxxx... (without the decimal point)
  // from left to right. Once &#39;count&#39; digits have been produced we decide wether
  // to round up or down. Remainders of exactly .5 round upwards. Numbers such
  // as 9.999999 propagate a carry all the way, and change the
  // exponent (decimal_point), when rounding upwards.
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="line-modified">!                                   Bignum* numerator, Bignum* denominator,</span>
                                    BufferReference&lt;char&gt; buffer, int* length) {
<span class="line-modified">!   ASSERT(count &gt;= 0);</span>
<span class="line-modified">!   for (int i = 0; i &lt; count - 1; ++i) {</span>
<span class="line-modified">!     uint16_t digit;</span>
<span class="line-modified">!     digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!     ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="line-modified">!     // digit = numerator / denominator (integer division).</span>
<span class="line-modified">!     // numerator = numerator % denominator.</span>
      buffer[i] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">!     // Prepare for next iteration.</span>
<span class="line-modified">!     numerator-&gt;Times10();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // Generate the last digit.</span>
<span class="line-modified">!   uint16_t digit;</span>
<span class="line-modified">!   digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="line-modified">!   if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">!     digit++;</span>
<span class="line-modified">!   }</span>
    ASSERT(digit &lt;= 10);
    buffer[count - 1] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="line-modified">!   // Correct bad digits (in case we had a sequence of &#39;9&#39;s). Propagate the</span>
<span class="line-modified">!   // carry until we hat a non-&#39;9&#39; or til we reach the first digit.</span>
<span class="line-modified">!   for (int i = count - 1; i &gt; 0; --i) {</span>
<span class="line-modified">!     if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="line-modified">!     buffer[i] = &#39;0&#39;;</span>
<span class="line-modified">!     buffer[i - 1]++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="line-modified">!     // Propagate a carry past the top place.</span>
<span class="line-modified">!     buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!     (*decimal_point)++;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   *length = count;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Generates &#39;requested_digits&#39; after the decimal point. It might omit
  // trailing &#39;0&#39;s. If the input number is too small then no digits at all are
  // generated (ex.: 2 fixed digits for 0.00001).
  //
  // Input verifies:  1 &lt;= (numerator + delta) / denominator &lt; 10.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="line-modified">!                           Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                           BufferReference&lt;char&gt;(buffer), int* length) {</span>
<span class="line-modified">!   // Note that we have to look at more than just the requested_digits, since</span>
<span class="line-modified">!   // a number could be rounded up. Example: v=0.5 with requested_digits=0.</span>
<span class="line-modified">!   // Even though the power of v equals 0 we can&#39;t just stop here.</span>
<span class="line-modified">!   if (-(*decimal_point) &gt; requested_digits) {</span>
<span class="line-modified">!     // The number is definitively too small.</span>
<span class="line-modified">!     // Ex: 0.001 with requested_digits == 1.</span>
<span class="line-modified">!     // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="line-modified">!     // Note that it should not have any effect anyways since the string is</span>
<span class="line-modified">!     // empty.</span>
<span class="line-modified">!     *decimal_point = -requested_digits;</span>
<span class="line-modified">!     *length = 0;</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   } else if (-(*decimal_point) == requested_digits) {</span>
<span class="line-modified">!     // We only need to verify if the number rounds down or up.</span>
<span class="line-modified">!     // Ex: 0.04 and 0.06 with requested_digits == 1.</span>
<span class="line-modified">!     ASSERT(*decimal_point == -requested_digits);</span>
<span class="line-modified">!     // Initially the fraction lies in range (1, 10]. Multiply the denominator</span>
<span class="line-modified">!     // by 10 so that we can compare more easily.</span>
<span class="line-modified">!     denominator-&gt;Times10();</span>
<span class="line-modified">!     if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="line-modified">!       // If the fraction is &gt;= 0.5 then we have to include the rounded</span>
<span class="line-modified">!       // digit.</span>
<span class="line-modified">!       buffer[0] = &#39;1&#39;;</span>
<span class="line-modified">!       *length = 1;</span>
<span class="line-modified">!       (*decimal_point)++;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       // Note that we caught most of similar cases earlier.</span>
<span class="line-modified">!       *length = 0;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // The requested digits correspond to the digits after the point.</span>
<span class="line-modified">!     // The variable &#39;needed_digits&#39; includes the digits before the point.</span>
<span class="line-modified">!     int needed_digits = (*decimal_point) + requested_digits;</span>
<span class="line-modified">!     GenerateCountedDigits(needed_digits, decimal_point,</span>
<span class="line-modified">!                           numerator, denominator,</span>
<span class="line-modified">!                           buffer, length);</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k where
  // v = f * 2^exponent and 2^52 &lt;= f &lt; 2^53.
  // v is hence a normalized double with the given exponent. The output is an
  // approximation for the exponent of the decimal approimation .digits * 10^k.
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,154 ***</span>
  //  EstimatePower(0)   =&gt; 16
  //  EstimatePower(-52) =&gt; 0
  //
  // Note: e &gt;= 0 =&gt; EstimatedPower(e) &gt; 0. No similar claim can be made for e&lt;0.
  static int EstimatePower(int exponent) {
<span class="line-modified">!         // This function estimates log10 of v where v = f*2^e (with e == exponent).</span>
<span class="line-modified">!         // Note that 10^floor(log10(v)) &lt;= v, but v &lt;= 10^ceil(log10(v)).</span>
<span class="line-modified">!         // Note that f is bounded by its container size. Let p = 53 (the double&#39;s</span>
<span class="line-modified">!         // significand size). Then 2^(p-1) &lt;= f &lt; 2^p.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close</span>
<span class="line-modified">!         // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).</span>
<span class="line-modified">!         // The computed number undershoots by less than 0.631 (when we compute log3</span>
<span class="line-modified">!         // and not log10).</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Optimization: since we only need an approximated result this computation</span>
<span class="line-modified">!         // can be performed on 64 bit integers. On x86/x64 architecture the speedup is</span>
<span class="line-modified">!         // not really measurable, though.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Since we want to avoid overshooting we decrement by 1e10 so that</span>
<span class="line-modified">!         // floating-point imprecisions don&#39;t affect us.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Explanation for v&#39;s boundary m+: the computation takes advantage of</span>
<span class="line-modified">!         // the fact that 2^(p-1) &lt;= f &lt; 2^p. Boundaries still satisfy this requirement</span>
<span class="line-modified">!         // (even for denormals where the delta can be much more important).</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         const double k1Log10 = 0.30102999566398114;  // 1/lg(10)</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // For doubles len(f) == 53 (don&#39;t forget the hidden bit).</span>
    const int kSignificandSize = Double::kSignificandSize;
<span class="line-modified">!         double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);</span>
<span class="line-modified">!         return static_cast&lt;int&gt;(estimate);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // See comments for InitialScaledStartValues.
  static void InitialScaledStartValuesPositiveExponent(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!                                                          Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                                          Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!         // A positive exponent implies a positive power.</span>
<span class="line-modified">!         ASSERT(estimated_power &gt;= 0);</span>
<span class="line-modified">!         // Since the estimated_power is positive we simply multiply the denominator</span>
<span class="line-modified">!         // by 10^estimated_power.</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // numerator = v.</span>
    numerator-&gt;AssignUInt64(significand);
    numerator-&gt;ShiftLeft(exponent);
<span class="line-modified">!         // denominator = 10^estimated_power.</span>
<span class="line-modified">!         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (need_boundary_deltas) {</span>
<span class="line-modified">!             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!             // integers.</span>
<span class="line-modified">!             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">!             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">!             delta_plus-&gt;AssignUInt16(1);</span>
      delta_plus-&gt;ShiftLeft(exponent);
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="line-modified">!             delta_minus-&gt;AssignUInt16(1);</span>
      delta_minus-&gt;ShiftLeft(exponent);
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentPositivePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!         // v = f * 2^e with e &lt; 0, and with estimated_power &gt;= 0.</span>
<span class="line-modified">!         // This means that e is close to 0 (have a look at how estimated_power is</span>
<span class="line-modified">!         // computed).</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // numerator = significand</span>
<span class="line-modified">!         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">!         //  numerator = v * / 2^-exponent</span>
<span class="line-modified">!         numerator-&gt;AssignUInt64(significand);</span>
<span class="line-modified">!         // denominator = 10^estimated_power * 2^-exponent (with exponent &lt; 0)</span>
<span class="line-modified">!         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">!         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (need_boundary_deltas) {</span>
<span class="line-modified">!             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!             // integers.</span>
<span class="line-modified">!             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">!             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">!             // Given that the denominator already includes v&#39;s exponent the distance</span>
<span class="line-modified">!             // to the boundaries is simply 1.</span>
<span class="line-modified">!             delta_plus-&gt;AssignUInt16(1);</span>
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="line-modified">!             delta_minus-&gt;AssignUInt16(1);</span>
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentNegativePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!         // Instead of multiplying the denominator with 10^estimated_power we</span>
<span class="line-modified">!         // multiply all values (numerator and deltas) by 10^-estimated_power.</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Use numerator as temporary container for power_ten.</span>
<span class="line-modified">!         Bignum* power_ten = numerator;</span>
<span class="line-modified">!         power_ten-&gt;AssignPowerUInt16(10, -estimated_power);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (need_boundary_deltas) {</span>
<span class="line-modified">!             // Since power_ten == numerator we must make a copy of 10^estimated_power</span>
<span class="line-modified">!             // before we complete the computation of the numerator.</span>
<span class="line-modified">!             // delta_plus = delta_minus = 10^estimated_power</span>
<span class="line-modified">!             delta_plus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">!             delta_minus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // numerator = significand * 2 * 10^-estimated_power</span>
<span class="line-modified">!         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">!         // numerator = v * 10^-estimated_power * 2 * 2^-exponent.</span>
<span class="line-modified">!         // Remember: numerator has been abused as power_ten. So no need to assign it</span>
<span class="line-modified">!         //  to itself.</span>
<span class="line-modified">!         ASSERT(numerator == power_ten);</span>
<span class="line-modified">!         numerator-&gt;MultiplyByUInt64(significand);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // denominator = 2 * 2^-exponent with exponent &lt; 0.</span>
<span class="line-modified">!         denominator-&gt;AssignUInt16(1);</span>
<span class="line-modified">!         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (need_boundary_deltas) {</span>
<span class="line-modified">!             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!             // integers.</span>
<span class="line-modified">!             numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!             // With this shift the boundaries have their correct value, since</span>
<span class="line-modified">!             // delta_plus = 10^-estimated_power, and</span>
<span class="line-modified">!             // delta_minus = 10^-estimated_power.</span>
<span class="line-modified">!             // These assignments have been done earlier.</span>
      // The adjustments if f == 2^p-1 (lower boundary is closer) are done later.
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Let v = significand * 2^exponent.
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator. The functions GenerateShortestDigits and
  // GenerateCountedDigits will then convert this ratio to its decimal
  // representation d, with the required accuracy.
<span class="line-new-header">--- 384,154 ---</span>
  //  EstimatePower(0)   =&gt; 16
  //  EstimatePower(-52) =&gt; 0
  //
  // Note: e &gt;= 0 =&gt; EstimatedPower(e) &gt; 0. No similar claim can be made for e&lt;0.
  static int EstimatePower(int exponent) {
<span class="line-modified">!   // This function estimates log10 of v where v = f*2^e (with e == exponent).</span>
<span class="line-modified">!   // Note that 10^floor(log10(v)) &lt;= v, but v &lt;= 10^ceil(log10(v)).</span>
<span class="line-modified">!   // Note that f is bounded by its container size. Let p = 53 (the double&#39;s</span>
<span class="line-modified">!   // significand size). Then 2^(p-1) &lt;= f &lt; 2^p.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close</span>
<span class="line-modified">!   // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).</span>
<span class="line-modified">!   // The computed number undershoots by less than 0.631 (when we compute log3</span>
<span class="line-modified">!   // and not log10).</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Optimization: since we only need an approximated result this computation</span>
<span class="line-modified">!   // can be performed on 64 bit integers. On x86/x64 architecture the speedup is</span>
<span class="line-modified">!   // not really measurable, though.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Since we want to avoid overshooting we decrement by 1e10 so that</span>
<span class="line-modified">!   // floating-point imprecisions don&#39;t affect us.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Explanation for v&#39;s boundary m+: the computation takes advantage of</span>
<span class="line-modified">!   // the fact that 2^(p-1) &lt;= f &lt; 2^p. Boundaries still satisfy this requirement</span>
<span class="line-modified">!   // (even for denormals where the delta can be much more important).</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const double k1Log10 = 0.30102999566398114;  // 1/lg(10)</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // For doubles len(f) == 53 (don&#39;t forget the hidden bit).</span>
    const int kSignificandSize = Double::kSignificandSize;
<span class="line-modified">!   double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);</span>
<span class="line-modified">!   return static_cast&lt;int&gt;(estimate);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // See comments for InitialScaledStartValues.
  static void InitialScaledStartValuesPositiveExponent(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!     Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!   // A positive exponent implies a positive power.</span>
<span class="line-modified">!   ASSERT(estimated_power &gt;= 0);</span>
<span class="line-modified">!   // Since the estimated_power is positive we simply multiply the denominator</span>
<span class="line-modified">!   // by 10^estimated_power.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // numerator = v.</span>
    numerator-&gt;AssignUInt64(significand);
    numerator-&gt;ShiftLeft(exponent);
<span class="line-modified">!   // denominator = 10^estimated_power.</span>
<span class="line-modified">!   denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (need_boundary_deltas) {</span>
<span class="line-modified">!     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!     // integers.</span>
<span class="line-modified">!     denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">!     // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">!     delta_plus-&gt;AssignUInt16(1);</span>
      delta_plus-&gt;ShiftLeft(exponent);
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="line-modified">!     delta_minus-&gt;AssignUInt16(1);</span>
      delta_minus-&gt;ShiftLeft(exponent);
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentPositivePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!     Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!   // v = f * 2^e with e &lt; 0, and with estimated_power &gt;= 0.</span>
<span class="line-modified">!   // This means that e is close to 0 (have a look at how estimated_power is</span>
<span class="line-modified">!   // computed).</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // numerator = significand</span>
<span class="line-modified">!   //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">!   //  numerator = v * / 2^-exponent</span>
<span class="line-modified">!   numerator-&gt;AssignUInt64(significand);</span>
<span class="line-modified">!   // denominator = 10^estimated_power * 2^-exponent (with exponent &lt; 0)</span>
<span class="line-modified">!   denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="line-modified">!   denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (need_boundary_deltas) {</span>
<span class="line-modified">!     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!     // integers.</span>
<span class="line-modified">!     denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="line-modified">!     // denominator (of 2) delta_plus equals 2^e.</span>
<span class="line-modified">!     // Given that the denominator already includes v&#39;s exponent the distance</span>
<span class="line-modified">!     // to the boundaries is simply 1.</span>
<span class="line-modified">!     delta_plus-&gt;AssignUInt16(1);</span>
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="line-modified">!     delta_minus-&gt;AssignUInt16(1);</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentNegativePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="line-modified">!     Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!   // Instead of multiplying the denominator with 10^estimated_power we</span>
<span class="line-modified">!   // multiply all values (numerator and deltas) by 10^-estimated_power.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Use numerator as temporary container for power_ten.</span>
<span class="line-modified">!   Bignum* power_ten = numerator;</span>
<span class="line-modified">!   power_ten-&gt;AssignPowerUInt16(10, -estimated_power);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (need_boundary_deltas) {</span>
<span class="line-modified">!     // Since power_ten == numerator we must make a copy of 10^estimated_power</span>
<span class="line-modified">!     // before we complete the computation of the numerator.</span>
<span class="line-modified">!     // delta_plus = delta_minus = 10^estimated_power</span>
<span class="line-modified">!     delta_plus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">!     delta_minus-&gt;AssignBignum(*power_ten);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // numerator = significand * 2 * 10^-estimated_power</span>
<span class="line-modified">!   //  since v = significand * 2^exponent this is equivalent to</span>
<span class="line-modified">!   // numerator = v * 10^-estimated_power * 2 * 2^-exponent.</span>
<span class="line-modified">!   // Remember: numerator has been abused as power_ten. So no need to assign it</span>
<span class="line-modified">!   //  to itself.</span>
<span class="line-modified">!   ASSERT(numerator == power_ten);</span>
<span class="line-modified">!   numerator-&gt;MultiplyByUInt64(significand);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // denominator = 2 * 2^-exponent with exponent &lt; 0.</span>
<span class="line-modified">!   denominator-&gt;AssignUInt16(1);</span>
<span class="line-modified">!   denominator-&gt;ShiftLeft(-exponent);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (need_boundary_deltas) {</span>
<span class="line-modified">!     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="line-modified">!     // integers.</span>
<span class="line-modified">!     numerator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     denominator-&gt;ShiftLeft(1);</span>
<span class="line-modified">!     // With this shift the boundaries have their correct value, since</span>
<span class="line-modified">!     // delta_plus = 10^-estimated_power, and</span>
<span class="line-modified">!     // delta_minus = 10^-estimated_power.</span>
<span class="line-modified">!     // These assignments have been done earlier.</span>
      // The adjustments if f == 2^p-1 (lower boundary is closer) are done later.
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Let v = significand * 2^exponent.
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator. The functions GenerateShortestDigits and
  // GenerateCountedDigits will then convert this ratio to its decimal
  // representation d, with the required accuracy.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,40 ***</span>
  // or BIGNUM_DTOA_SHORTEST_SINGLE.
  
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="line-modified">!                                          int estimated_power,</span>
<span class="line-modified">!                                          bool need_boundary_deltas,</span>
<span class="line-modified">!                                          Bignum* numerator,</span>
<span class="line-modified">!                                          Bignum* denominator,</span>
<span class="line-modified">!                                          Bignum* delta_minus,</span>
<span class="line-modified">!                                          Bignum* delta_plus) {</span>
    if (exponent &gt;= 0) {
<span class="line-modified">!             InitialScaledStartValuesPositiveExponent(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!                                                      numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!         } else if (estimated_power &gt;= 0) {</span>
<span class="line-modified">!             InitialScaledStartValuesNegativeExponentPositivePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             InitialScaledStartValuesNegativeExponentNegativePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!         }</span>
  
    if (need_boundary_deltas &amp;&amp; lower_boundary_is_closer) {
      // The lower boundary is closer at half the distance of &quot;normal&quot; numbers.
      // Increase the common denominator and adapt all but the delta_minus.
      denominator-&gt;ShiftLeft(1);  // *2
      numerator-&gt;ShiftLeft(1);    // *2
      delta_plus-&gt;ShiftLeft(1);   // *2
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // This routine multiplies numerator/denominator so that its values lies in the
  // range 1-10. That is after a call to this function we have:
  //    1 &lt;= (numerator + delta_plus) /denominator &lt; 10.
  // Let numerator the input before modification and numerator&#39; the argument
  // after modification, then the output-parameter decimal_point is such that
<span class="line-new-header">--- 569,40 ---</span>
  // or BIGNUM_DTOA_SHORTEST_SINGLE.
  
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="line-modified">!                                      int estimated_power,</span>
<span class="line-modified">!                                      bool need_boundary_deltas,</span>
<span class="line-modified">!                                      Bignum* numerator,</span>
<span class="line-modified">!                                      Bignum* denominator,</span>
<span class="line-modified">!                                      Bignum* delta_minus,</span>
<span class="line-modified">!                                      Bignum* delta_plus) {</span>
    if (exponent &gt;= 0) {
<span class="line-modified">!     InitialScaledStartValuesPositiveExponent(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!         numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!   } else if (estimated_power &gt;= 0) {</span>
<span class="line-modified">!     InitialScaledStartValuesNegativeExponentPositivePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!         numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     InitialScaledStartValuesNegativeExponentNegativePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="line-modified">!         numerator, denominator, delta_minus, delta_plus);</span>
<span class="line-modified">!   }</span>
  
    if (need_boundary_deltas &amp;&amp; lower_boundary_is_closer) {
      // The lower boundary is closer at half the distance of &quot;normal&quot; numbers.
      // Increase the common denominator and adapt all but the delta_minus.
      denominator-&gt;ShiftLeft(1);  // *2
      numerator-&gt;ShiftLeft(1);    // *2
      delta_plus-&gt;ShiftLeft(1);   // *2
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // This routine multiplies numerator/denominator so that its values lies in the
  // range 1-10. That is after a call to this function we have:
  //    1 &lt;= (numerator + delta_plus) /denominator &lt; 10.
  // Let numerator the input before modification and numerator&#39; the argument
  // after modification, then the output-parameter decimal_point is such that
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,35 ***</span>
  // In some cases estimated_power was too low, and this is already the case. We
  // then simply adjust the power so that 10^(k-1) &lt;= v &lt; 10^k (with k ==
  // estimated_power) but do not touch the numerator or denominator.
  // Otherwise the routine multiplies the numerator and the deltas by 10.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="line-modified">!                                 int* decimal_point,</span>
<span class="line-modified">!                                 Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                                 Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!         bool in_range;</span>
<span class="line-modified">!         if (is_even) {</span>
<span class="line-modified">!             // For IEEE doubles half-way cases (in decimal system numbers ending with 5)</span>
<span class="line-modified">!             // are rounded to the closest floating-point number with even significand.</span>
<span class="line-modified">!             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (in_range) {</span>
<span class="line-modified">!             // Since numerator + delta_plus &gt;= denominator we already have</span>
<span class="line-modified">!             // 1 &lt;= numerator/denominator &lt; 10. Simply update the estimated_power.</span>
<span class="line-modified">!             *decimal_point = estimated_power + 1;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             *decimal_point = estimated_power;</span>
<span class="line-modified">!             numerator-&gt;Times10();</span>
<span class="line-modified">!             if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">!                 delta_minus-&gt;Times10();</span>
<span class="line-modified">!                 delta_plus-&gt;AssignBignum(*delta_minus);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 delta_minus-&gt;Times10();</span>
<span class="line-modified">!                 delta_plus-&gt;Times10();</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
<span class="line-new-header">--- 611,35 ---</span>
  // In some cases estimated_power was too low, and this is already the case. We
  // then simply adjust the power so that 10^(k-1) &lt;= v &lt; 10^k (with k ==
  // estimated_power) but do not touch the numerator or denominator.
  // Otherwise the routine multiplies the numerator and the deltas by 10.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="line-modified">!                             int* decimal_point,</span>
<span class="line-modified">!                             Bignum* numerator, Bignum* denominator,</span>
<span class="line-modified">!                             Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="line-modified">!   bool in_range;</span>
<span class="line-modified">!   if (is_even) {</span>
<span class="line-modified">!     // For IEEE doubles half-way cases (in decimal system numbers ending with 5)</span>
<span class="line-modified">!     // are rounded to the closest floating-point number with even significand.</span>
<span class="line-modified">!     in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (in_range) {</span>
<span class="line-modified">!     // Since numerator + delta_plus &gt;= denominator we already have</span>
<span class="line-modified">!     // 1 &lt;= numerator/denominator &lt; 10. Simply update the estimated_power.</span>
<span class="line-modified">!     *decimal_point = estimated_power + 1;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     *decimal_point = estimated_power;</span>
<span class="line-modified">!     numerator-&gt;Times10();</span>
<span class="line-modified">!     if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="line-modified">!       delta_minus-&gt;Times10();</span>
<span class="line-modified">!       delta_plus-&gt;AssignBignum(*delta_minus);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       delta_minus-&gt;Times10();</span>
<span class="line-modified">!       delta_plus-&gt;Times10();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
</pre>
<center><a href="../dtoa.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="bignum-dtoa.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>