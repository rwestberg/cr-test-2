<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSONObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
<span class="line-new-header">--- 1,9 ---</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,12 ***</span>
  #include &quot;CatchScope.h&quot;
  #include &quot;CustomGetterSetter.h&quot;
  #include &quot;DatePrototype.h&quot;
  #include &quot;ErrorConstructor.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;GetterSetter.h&quot;
<span class="line-modified">! #include &quot;HeapSnapshotBuilder.h&quot;</span>
  #include &quot;IndexingHeaderInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCustomGetterSetterFunction.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObject.h&quot;
<span class="line-new-header">--- 28,13 ---</span>
  #include &quot;CatchScope.h&quot;
  #include &quot;CustomGetterSetter.h&quot;
  #include &quot;DatePrototype.h&quot;
  #include &quot;ErrorConstructor.h&quot;
  #include &quot;Exception.h&quot;
<span class="line-added">+ #include &quot;GCDeferralContextInlines.h&quot;</span>
  #include &quot;GetterSetter.h&quot;
<span class="line-modified">! #include &quot;HeapAnalyzer.h&quot;</span>
  #include &quot;IndexingHeaderInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCustomGetterSetterFunction.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObject.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,11 ***</span>
          if (!table)
              continue;
  
          for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
              if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
<span class="line-modified">!                 propertyNames.add(Identifier::fromString(&amp;vm, iter.key()));</span>
          }
      }
  }
  
  ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)
<span class="line-new-header">--- 85,11 ---</span>
          if (!table)
              continue;
  
          for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
              if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
<span class="line-modified">!                 propertyNames.add(Identifier::fromString(vm, iter.key()));</span>
          }
      }
  }
  
  ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset lastOffset)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,20 ***</span>
  #if !ASSERT_DISABLED
      visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
  #endif
  }
  
<span class="line-modified">! void JSObject::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)</span>
  {
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified">!     Base::heapSnapshot(cell, builder);</span>
  
      Structure* structure = thisObject-&gt;structure();
      for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
          JSValue toValue = thisObject-&gt;getDirect(entry.offset);
          if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified">!             builder.appendPropertyNameEdge(thisObject, toValue.asCell(), entry.key);</span>
      }
  
      Butterfly* butterfly = thisObject-&gt;butterfly();
      if (butterfly) {
          WriteBarrier&lt;Unknown&gt;* data = nullptr;
<span class="line-new-header">--- 448,20 ---</span>
  #if !ASSERT_DISABLED
      visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
  #endif
  }
  
<span class="line-modified">! void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)</span>
  {
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
<span class="line-modified">!     Base::analyzeHeap(cell, analyzer);</span>
  
      Structure* structure = thisObject-&gt;structure();
      for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
          JSValue toValue = thisObject-&gt;getDirect(entry.offset);
          if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified">!             analyzer.analyzePropertyNameEdge(thisObject, toValue.asCell(), entry.key);</span>
      }
  
      Butterfly* butterfly = thisObject-&gt;butterfly();
      if (butterfly) {
          WriteBarrier&lt;Unknown&gt;* data = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,11 ***</span>
          }
  
          for (uint32_t i = 0; i &lt; count; ++i) {
              JSValue toValue = data[i].get();
              if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified">!                 builder.appendIndexEdge(thisObject, toValue.asCell(), i);</span>
          }
      }
  }
  
  void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
<span class="line-new-header">--- 481,11 ---</span>
          }
  
          for (uint32_t i = 0; i &lt; count; ++i) {
              JSValue toValue = data[i].get();
              if (toValue &amp;&amp; toValue.isCell())
<span class="line-modified">!                 analyzer.analyzeIndexEdge(thisObject, toValue.asCell(), i);</span>
          }
      }
  }
  
  void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,62 ***</span>
      return info-&gt;className;
  }
  
  String JSObject::calculatedClassName(JSObject* object)
  {
<span class="line-modified">!     String prototypeFunctionName;</span>
<span class="line-modified">!     auto globalObject = object-&gt;globalObject();</span>
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-modified">!     PropertySlot slot(object-&gt;getPrototypeDirect(vm), PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-modified">!     PropertyName constructor(vm.propertyNames-&gt;constructor);</span>
<span class="line-modified">!     if (object-&gt;getPropertySlot(exec, constructor, slot)) {</span>
          EXCEPTION_ASSERT(!scope.exception());
          if (slot.isValue()) {
<span class="line-modified">!             JSValue constructorValue = slot.getValue(exec, constructor);</span>
<span class="line-modified">!             if (constructorValue.isCell()) {</span>
<span class="line-modified">!                 if (JSCell* constructorCell = constructorValue.asCell()) {</span>
<span class="line-modified">!                     if (JSObject* ctorObject = constructorCell-&gt;getObject()) {</span>
<span class="line-modified">!                         if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified">!                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified">!                         else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified">!                             prototypeFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
                      }
                  }
              }
          }
      }
<span class="line-modified">!     EXCEPTION_ASSERT(!scope.exception() || prototypeFunctionName.isNull());</span>
      if (UNLIKELY(scope.exception()))
          scope.clearException();
  
<span class="line-modified">!     if (prototypeFunctionName.isNull() || prototypeFunctionName == &quot;Object&quot;) {</span>
          String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
          if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
              return tableClassName;
  
          String classInfoName = object-&gt;classInfo(vm)-&gt;className;
          if (!classInfoName.isNull())
              return classInfoName;
  
<span class="line-modified">!         if (prototypeFunctionName.isNull())</span>
              return &quot;Object&quot;_s;
      }
  
<span class="line-modified">!     return prototypeFunctionName;</span>
  }
  
  bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)
  {
      // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
      // legal for anyone to override getOwnPropertySlot() without also overriding
      // getOwnPropertySlotByIndex().
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">!         return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(exec, i), slot);</span>
  
      switch (thisObject-&gt;indexingType()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          break;
<span class="line-new-header">--- 524,90 ---</span>
      return info-&gt;className;
  }
  
  String JSObject::calculatedClassName(JSObject* object)
  {
<span class="line-modified">!     String constructorFunctionName;</span>
<span class="line-modified">!     auto* structure = object-&gt;structure();</span>
<span class="line-added">+     auto* globalObject = structure-&gt;globalObject();</span>
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-added">+     auto* exec = globalObject-&gt;globalExec();</span>
  
<span class="line-modified">!     // Check for a display name of obj.constructor.</span>
<span class="line-modified">!     // This is useful to get `Foo` for the `(class Foo).prototype` object.</span>
<span class="line-modified">!     PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-modified">!     if (object-&gt;getOwnPropertySlot(object, exec, vm.propertyNames-&gt;constructor, slot)) {</span>
          EXCEPTION_ASSERT(!scope.exception());
          if (slot.isValue()) {
<span class="line-modified">!             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="line-modified">!                 if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified">!                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified">!                 else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-modified">!                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());</span>
<span class="line-added">+     if (UNLIKELY(scope.exception()))</span>
<span class="line-added">+         scope.clearException();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Get the display name of obj.__proto__.constructor.</span>
<span class="line-added">+     // This is useful to get `Foo` for a `new Foo` object.</span>
<span class="line-added">+     if (constructorFunctionName.isNull()) {</span>
<span class="line-added">+         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;</span>
<span class="line-added">+         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {</span>
<span class="line-added">+             JSValue protoValue = object-&gt;getPrototypeDirect(vm);</span>
<span class="line-added">+             if (protoValue.isObject()) {</span>
<span class="line-added">+                 JSObject* protoObject = asObject(protoValue);</span>
<span class="line-added">+                 PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-added">+                 if (protoObject-&gt;getPropertySlot(exec, vm.propertyNames-&gt;constructor, slot)) {</span>
<span class="line-added">+                     EXCEPTION_ASSERT(!scope.exception());</span>
<span class="line-added">+                     if (slot.isValue()) {</span>
<span class="line-added">+                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(exec, vm.propertyNames-&gt;constructor))) {</span>
<span class="line-added">+                             if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))</span>
<span class="line-added">+                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-added">+                             else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))</span>
<span class="line-added">+                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);</span>
<span class="line-added">+                         }</span>
                      }
                  }
              }
          }
      }
<span class="line-modified">! </span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());</span>
      if (UNLIKELY(scope.exception()))
          scope.clearException();
  
<span class="line-modified">!     if (constructorFunctionName.isNull() || constructorFunctionName == &quot;Object&quot;) {</span>
          String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
          if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
              return tableClassName;
  
          String classInfoName = object-&gt;classInfo(vm)-&gt;className;
          if (!classInfoName.isNull())
              return classInfoName;
  
<span class="line-modified">!         if (constructorFunctionName.isNull())</span>
              return &quot;Object&quot;_s;
      }
  
<span class="line-modified">!     return constructorFunctionName;</span>
  }
  
  bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, ExecState* exec, unsigned i, PropertySlot&amp; slot)
  {
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+ </span>
      // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
      // legal for anyone to override getOwnPropertySlot() without also overriding
      // getOwnPropertySlotByIndex().
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">!         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, Identifier::from(vm, i), slot);</span>
  
      switch (thisObject-&gt;indexingType()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,11 ***</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSObject* current = object;
      PropertyDescriptor ownDescriptor;
      while (true) {
<span class="line-modified">!         if (current-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
              PutPropertySlot slot(receiver, shouldThrow);
              RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
          }
  
<span class="line-new-header">--- 682,11 ---</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSObject* current = object;
      PropertyDescriptor ownDescriptor;
      while (true) {
<span class="line-modified">!         if (current-&gt;type() == ProxyObjectType) {</span>
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
              PutPropertySlot slot(receiver, shouldThrow);
              RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 761,22 ***</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* obj = this;
      for (;;) {
          unsigned attributes;
<span class="line-modified">!         PropertyOffset offset = obj-&gt;structure(vm)-&gt;get(vm, propertyName, attributes);</span>
          if (isValidOffset(offset)) {
              if (attributes &amp; PropertyAttribute::ReadOnly) {
                  ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
                  return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
              }
  
              JSValue gs = obj-&gt;getDirect(offset);
              if (gs.isGetterSetter()) {
                  // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
<span class="line-modified">!                 if (!structure(vm)-&gt;isDictionary())</span>
                      slot.setCacheableSetter(obj, offset);
  
                  bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
<span class="line-new-header">--- 790,27 ---</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* obj = this;
      for (;;) {
<span class="line-added">+         Structure* structure = obj-&gt;structure(vm);</span>
<span class="line-added">+         if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {</span>
<span class="line-added">+             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, exec, propertyName, slot);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         }</span>
          unsigned attributes;
<span class="line-modified">!         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);</span>
          if (isValidOffset(offset)) {
              if (attributes &amp; PropertyAttribute::ReadOnly) {
                  ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
                  return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
              }
  
              JSValue gs = obj-&gt;getDirect(offset);
              if (gs.isGetterSetter()) {
                  // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
<span class="line-modified">!                 if (!this-&gt;structure(vm)-&gt;isDictionary())</span>
                      slot.setCacheableSetter(obj, offset);
  
                  bool result = callSetter(exec, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 792,21 ***</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
              }
              ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
  
<span class="line-modified">!             // If there&#39;s an existing property on the object or one of its</span>
<span class="line-modified">!             // prototypes it should be replaced, so break here.</span>
              break;
          }
          if (!obj-&gt;staticPropertiesReified(vm)) {
              if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
                  if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
                      RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
              }
          }
<span class="line-modified">!         if (obj-&gt;type() == ProxyObjectType &amp;&amp; propertyName != vm.propertyNames-&gt;underscoreProto) {</span>
              // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.
              // We need to do more because this is observable behavior.
              // https://bugs.webkit.org/show_bug.cgi?id=155012
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
              RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
<span class="line-new-header">--- 826,21 ---</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  return result;
              }
              ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
  
<span class="line-modified">!             // If there&#39;s an existing property on the base object, or on one of its</span>
<span class="line-modified">!             // prototypes, we should store the property on the *base* object.</span>
              break;
          }
          if (!obj-&gt;staticPropertiesReified(vm)) {
              if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
                  if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
                      RELEASE_AND_RETURN(scope, putEntry(exec, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
              }
          }
<span class="line-modified">!         if (obj-&gt;type() == ProxyObjectType) {</span>
              // FIXME: We shouldn&#39;t unconditionally perform [[Set]] here.
              // We need to do more because this is observable behavior.
              // https://bugs.webkit.org/show_bug.cgi?id=155012
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
              RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, exec, propertyName, value, slot));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,11 ***</span>
      VM&amp; vm = exec-&gt;vm();
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (propertyName &gt; MAX_ARRAY_INDEX) {
          PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified">!         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(exec, propertyName), value, slot);</span>
      }
  
      thisObject-&gt;ensureWritable(vm);
  
      switch (thisObject-&gt;indexingType()) {
<span class="line-new-header">--- 862,11 ---</span>
      VM&amp; vm = exec-&gt;vm();
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (propertyName &gt; MAX_ARRAY_INDEX) {
          PutPropertySlot slot(cell, shouldThrow);
<span class="line-modified">!         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, exec, Identifier::from(vm, propertyName), value, slot);</span>
      }
  
      thisObject-&gt;ensureWritable(vm);
  
      switch (thisObject-&gt;indexingType()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,21 ***</span>
              break;
  
          WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
          unsigned length = storage-&gt;length();
  
          // Update length &amp; m_numValuesInVector as necessary.
          if (propertyName &gt;= length) {
              bool putResult = false;
<span class="line-modified">!             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>
                  return putResult;
              length = propertyName + 1;
              storage-&gt;setLength(length);
              ++storage-&gt;m_numValuesInVector;
          } else if (!valueSlot) {
              bool putResult = false;
<span class="line-modified">!             if (thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult))</span>
                  return putResult;
              ++storage-&gt;m_numValuesInVector;
          }
  
          valueSlot.set(vm, thisObject, value);
<span class="line-new-header">--- 949,27 ---</span>
              break;
  
          WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
          unsigned length = storage-&gt;length();
  
<span class="line-added">+         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
          // Update length &amp; m_numValuesInVector as necessary.
          if (propertyName &gt;= length) {
              bool putResult = false;
<span class="line-modified">!             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+             if (result)</span>
                  return putResult;
              length = propertyName + 1;
              storage-&gt;setLength(length);
              ++storage-&gt;m_numValuesInVector;
          } else if (!valueSlot) {
              bool putResult = false;
<span class="line-modified">!             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(exec, propertyName, value, shouldThrow, putResult);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+             if (result)</span>
                  return putResult;
              ++storage-&gt;m_numValuesInVector;
          }
  
          valueSlot.set(vm, thisObject, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1895,10 ***</span>
<span class="line-new-header">--- 1935,23 ---</span>
  
      structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
      return result;
  }
  
<span class="line-added">+ void JSObject::putDirectNonIndexAccessorWithoutTransition(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(attributes &amp; PropertyAttribute::Accessor);</span>
<span class="line-added">+     StructureID structureID = this-&gt;structureID();</span>
<span class="line-added">+     Structure* structure = vm.heap.structureIDTable().get(structureID);</span>
<span class="line-added">+     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);</span>
<span class="line-added">+     putDirect(vm, offset, accessor);</span>
<span class="line-added">+     if (attributes &amp; PropertyAttribute::ReadOnly)</span>
<span class="line-added">+         structure-&gt;setContainsReadOnlyProperties();</span>
<span class="line-added">+ </span>
<span class="line-added">+     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // HasProperty(O, P) from Section 7.3.10 of the spec.
  // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
  bool JSObject::hasProperty(ExecState* exec, PropertyName propertyName) const
  {
      return hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::HasProperty);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1969,11 ***</span>
  {
      VM&amp; vm = exec-&gt;vm();
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">!         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(exec, i));</span>
  
      switch (thisObject-&gt;indexingMode()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          return true;
<span class="line-new-header">--- 2022,11 ---</span>
  {
      VM&amp; vm = exec-&gt;vm();
      JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
  
      if (i &gt; MAX_ARRAY_INDEX)
<span class="line-modified">!         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, i));</span>
  
      switch (thisObject-&gt;indexingMode()) {
      case ALL_BLANK_INDEXING_TYPES:
      case ALL_UNDECIDED_INDEXING_TYPES:
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2393,12 ***</span>
  JSString* JSObject::toString(ExecState* exec) const
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue primitive = toPrimitive(exec, PreferString);
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, jsEmptyString(exec));</span>
<span class="line-modified">!     return primitive.toString(exec);</span>
  }
  
  JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)
  {
      return jsCast&lt;JSObject*&gt;(cell);
<span class="line-new-header">--- 2446,12 ---</span>
  JSString* JSObject::toString(ExecState* exec) const
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue primitive = toPrimitive(exec, PreferString);
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, primitive.toString(exec));</span>
  }
  
  JSValue JSObject::toThis(JSCell* cell, ExecState*, ECMAMode)
  {
      return jsCast&lt;JSObject*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2466,11 ***</span>
          if (!hashTable)
              continue;
  
          for (auto&amp; value : *hashTable) {
              unsigned attributes;
<span class="line-modified">!             auto key = Identifier::fromString(&amp;vm, value.m_key);</span>
              PropertyOffset offset = getDirectOffset(vm, key, attributes);
              if (!isValidOffset(offset))
                  reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
          }
      }
<span class="line-new-header">--- 2519,11 ---</span>
          if (!hashTable)
              continue;
  
          for (auto&amp; value : *hashTable) {
              unsigned attributes;
<span class="line-modified">!             auto key = Identifier::fromString(vm, value.m_key);</span>
              PropertyOffset offset = getDirectOffset(vm, key, attributes);
              if (!isValidOffset(offset))
                  reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2674,46 ***</span>
  }
  
  bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
  {
      VM&amp; vm = exec-&gt;vm();
      for (JSObject* current = this; ;) {
          // This has the same behavior with respect to prototypes as JSObject::put(). It only
          // allows a prototype to intercept a put if (a) the prototype declares the property
          // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
          // (b) that property is declared as ReadOnly or Accessor.
  
          ArrayStorage* storage = current-&gt;arrayStorageOrNull();
          if (storage &amp;&amp; storage-&gt;m_sparseMap) {
              SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
              if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
                  putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
                  return true;
              }
          }
  
          if (current-&gt;type() == ProxyObjectType) {
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
              putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);
              return true;
          }
  
<span class="line-modified">!         JSValue prototypeValue = current-&gt;getPrototypeDirect(vm);</span>
          if (prototypeValue.isNull())
              return false;
  
          current = asObject(prototypeValue);
      }
  }
  
  bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
  {
<span class="line-modified">!     JSValue prototypeValue = getPrototypeDirect(exec-&gt;vm());</span>
      if (prototypeValue.isNull())
          return false;
  
<span class="line-modified">!     return asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult);</span>
  }
  
  template&lt;IndexingType indexingShape&gt;
  bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)
  {
<span class="line-new-header">--- 2727,55 ---</span>
  }
  
  bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(ExecState* exec, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      for (JSObject* current = this; ;) {
          // This has the same behavior with respect to prototypes as JSObject::put(). It only
          // allows a prototype to intercept a put if (a) the prototype declares the property
          // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
          // (b) that property is declared as ReadOnly or Accessor.
  
          ArrayStorage* storage = current-&gt;arrayStorageOrNull();
          if (storage &amp;&amp; storage-&gt;m_sparseMap) {
              SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
              if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
<span class="line-added">+                 scope.release();</span>
                  putResult = iter-&gt;value.put(exec, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
                  return true;
              }
          }
  
          if (current-&gt;type() == ProxyObjectType) {
<span class="line-added">+             scope.release();</span>
              ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
              putResult = proxy-&gt;putByIndexCommon(exec, thisValue, i, value, shouldThrow);
              return true;
          }
  
<span class="line-modified">!         JSValue prototypeValue = current-&gt;getPrototype(vm, exec);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
          if (prototypeValue.isNull())
              return false;
  
          current = asObject(prototypeValue);
      }
  }
  
  bool JSObject::attemptToInterceptPutByIndexOnHole(ExecState* exec, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue prototypeValue = getPrototype(vm, exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, false);</span>
      if (prototypeValue.isNull())
          return false;
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(exec, this, i, value, shouldThrow, putResult));</span>
  }
  
  template&lt;IndexingType indexingShape&gt;
  bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(ExecState* exec, unsigned i, JSValue value)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2851,31 ***</span>
  }
  
  bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)
  {
      VM&amp; vm = exec-&gt;vm();
  
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
  
      switch (indexingType()) {
      case ALL_BLANK_INDEXING_TYPES: {
          if (indexingShouldBeSparse(vm)) {
<span class="line-modified">!             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
                  exec, i, value, shouldThrow,
<span class="line-modified">!                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));</span>
          }
          if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">!             return putByIndexBeyondVectorLengthWithArrayStorage(</span>
<span class="line-removed">-                 exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0));</span>
          }
          if (needsSlowPutIndexing(vm)) {
              // Convert the indexing type to the SlowPutArrayStorage and retry.
              createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">!             return putByIndex(this, exec, i, value, shouldThrow);</span>
          }
  
          createInitialForValueAndSet(vm, i, value);
          return true;
      }
<span class="line-new-header">--- 2913,31 ---</span>
  }
  
  bool JSObject::putByIndexBeyondVectorLength(ExecState* exec, unsigned i, JSValue value, bool shouldThrow)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
  
      switch (indexingType()) {
      case ALL_BLANK_INDEXING_TYPES: {
          if (indexingShouldBeSparse(vm)) {
<span class="line-modified">!             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(</span>
                  exec, i, value, shouldThrow,
<span class="line-modified">!                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));</span>
          }
          if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">!             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));</span>
          }
          if (needsSlowPutIndexing(vm)) {
              // Convert the indexing type to the SlowPutArrayStorage and retry.
              createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-modified">!             RELEASE_AND_RETURN(scope, putByIndex(this, exec, i, value, shouldThrow));</span>
          }
  
          createInitialForValueAndSet(vm, i, value);
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2884,31 ***</span>
          CRASH();
          break;
      }
  
      case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">!         return putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value);</span>
  
      case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">!         return putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value);</span>
  
      case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">!         return putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value);</span>
  
      case NonArrayWithSlowPutArrayStorage:
      case ArrayWithSlowPutArrayStorage: {
          // No own property present in the vector, but there might be in the sparse map!
          SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
          bool putResult = false;
<span class="line-modified">!         if (!(map &amp;&amp; map-&gt;contains(i)) &amp;&amp; attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult))</span>
<span class="line-modified">!             return putResult;</span>
          FALLTHROUGH;
      }
  
      case NonArrayWithArrayStorage:
      case ArrayWithArrayStorage:
<span class="line-modified">!         return putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage());</span>
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
      return false;
<span class="line-new-header">--- 2946,35 ---</span>
          CRASH();
          break;
      }
  
      case ALL_INT32_INDEXING_TYPES:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(exec, i, value));</span>
  
      case ALL_DOUBLE_INDEXING_TYPES:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(exec, i, value));</span>
  
      case ALL_CONTIGUOUS_INDEXING_TYPES:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(exec, i, value));</span>
  
      case NonArrayWithSlowPutArrayStorage:
      case ArrayWithSlowPutArrayStorage: {
          // No own property present in the vector, but there might be in the sparse map!
          SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
          bool putResult = false;
<span class="line-modified">!         if (!(map &amp;&amp; map-&gt;contains(i))) {</span>
<span class="line-modified">!             bool result = attemptToInterceptPutByIndexOnHole(exec, i, value, shouldThrow, putResult);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+             if (result)</span>
<span class="line-added">+                 return putResult;</span>
<span class="line-added">+         }</span>
          FALLTHROUGH;
      }
  
      case NonArrayWithArrayStorage:
      case ArrayWithArrayStorage:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(exec, i, value, shouldThrow, arrayStorage()));</span>
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2998,11 ***</span>
      ASSERT(!value.isCustomGetterSetter());
  
      if (!canDoFastPutDirectIndex(vm, this)) {
          PropertyDescriptor descriptor;
          descriptor.setDescriptor(value, attributes);
<span class="line-modified">!         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(exec, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
      }
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
  
<span class="line-new-header">--- 3064,11 ---</span>
      ASSERT(!value.isCustomGetterSetter());
  
      if (!canDoFastPutDirectIndex(vm, this)) {
          PropertyDescriptor descriptor;
          descriptor.setDescriptor(value, attributes);
<span class="line-modified">!         return methodTable(vm)-&gt;defineOwnProperty(this, exec, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);</span>
      }
  
      // i should be a valid array index that is outside of the current vector.
      ASSERT(i &lt;= MAX_ARRAY_INDEX);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3014,11 ***</span>
          if (indexingShouldBeSparse(vm) || attributes) {
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
                  exec, i, value, attributes, mode,
                  ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
          }
<span class="line-modified">!         if (i &gt;= MIN_SPARSE_ARRAY_INDEX) {</span>
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
                  exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
          }
          if (needsSlowPutIndexing(vm)) {
              ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
<span class="line-new-header">--- 3080,11 ---</span>
          if (indexingShouldBeSparse(vm) || attributes) {
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
                  exec, i, value, attributes, mode,
                  ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
          }
<span class="line-modified">!         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {</span>
              return putDirectIndexBeyondVectorLengthWithArrayStorage(
                  exec, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
          }
          if (needsSlowPutIndexing(vm)) {
              ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3090,10 ***</span>
<span class="line-new-header">--- 3156,17 ---</span>
      JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
      GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
      return putDirectNonIndexAccessor(vm, name, accessor, attributes);
  }
  
<span class="line-added">+ void JSObject::putDirectNativeIntrinsicGetterWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);</span>
<span class="line-added">+     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);</span>
<span class="line-added">+     putDirectNonIndexAccessorWithoutTransition(vm, name, accessor, attributes);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
  {
      StringImpl* name = propertyName.publicName();
      if (!name)
          name = vm.propertyNames-&gt;anonymous.impl();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3309,10 ***</span>
<span class="line-new-header">--- 3382,12 ---</span>
      unsigned newVectorLength;
  
      Structure* structure = this-&gt;structure(vm);
      unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
  
<span class="line-added">+     GCDeferralContext deferralContext(vm.heap);</span>
<span class="line-added">+     DisallowGC disallowGC;</span>
      unsigned availableOldLength =
          Butterfly::availableContiguousVectorLength(propertyCapacity, oldVectorLength);
      Butterfly* newButterfly = nullptr;
      if (availableOldLength &gt;= length) {
          // This is the case where someone else selected a vector length that caused internal
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3320,12 ***</span>
          // this up, so this defense should stay.
          newVectorLength = availableOldLength;
      } else {
          newVectorLength = Butterfly::optimalContiguousVectorLength(
              propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
<span class="line-modified">!         butterfly = butterfly-&gt;growArrayRight(</span>
<span class="line-modified">!             vm, this, structure, propertyCapacity, true,</span>
              oldVectorLength * sizeof(EncodedJSValue),
              newVectorLength * sizeof(EncodedJSValue));
          if (!butterfly)
              return false;
          newButterfly = butterfly;
<span class="line-new-header">--- 3395,12 ---</span>
          // this up, so this defense should stay.
          newVectorLength = availableOldLength;
      } else {
          newVectorLength = Butterfly::optimalContiguousVectorLength(
              propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
<span class="line-modified">!         butterfly = butterfly-&gt;reallocArrayRightIfPossible(</span>
<span class="line-modified">!             vm, deferralContext, this, structure, propertyCapacity, true,</span>
              oldVectorLength * sizeof(EncodedJSValue),
              newVectorLength * sizeof(EncodedJSValue));
          if (!butterfly)
              return false;
          newButterfly = butterfly;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3390,14 ***</span>
  }
  
  bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
  {
      VM&amp; vm = exec-&gt;vm();
      JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     if (!methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot))</span>
          return false;
  
      // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
      // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
      // the property is not an own property.
      if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
          JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
<span class="line-new-header">--- 3465,23 ---</span>
  }
  
  bool JSObject::getOwnPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">! </span>
<span class="line-added">+     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added">+     if (!result)</span>
          return false;
  
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200560</span>
<span class="line-added">+     // This breaks the assumption that getOwnPropertySlot should return &quot;own&quot; property.</span>
<span class="line-added">+     // We should fix DebuggerScope, ProxyObject etc. to remove this.</span>
<span class="line-added">+     //</span>
      // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
      // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
      // the property is not an own property.
      if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
          JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3437,12 ***</span>
  
          if (getterSetter-&gt;getter())
              descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
          if (getterSetter-&gt;setter())
              descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
<span class="line-modified">!     } else</span>
<span class="line-modified">!         descriptor.setDescriptor(slot.getValue(exec, propertyName), slot.attributes());</span>
      return true;
  }
  
  static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
  {
<span class="line-new-header">--- 3521,16 ---</span>
  
          if (getterSetter-&gt;getter())
              descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
          if (getterSetter-&gt;setter())
              descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(exec, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         JSValue value = slot.getValue(exec, propertyName);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+         descriptor.setDescriptor(value, slot.attributes());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      return true;
  }
  
  static bool putDescriptor(ExecState* exec, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
  {
</pre>
<center><a href="JSONObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>