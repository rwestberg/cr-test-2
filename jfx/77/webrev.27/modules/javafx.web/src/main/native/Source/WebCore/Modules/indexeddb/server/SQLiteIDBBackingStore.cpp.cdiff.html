<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryObjectStoreCursor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,18 ***</span>
<span class="line-new-header">--- 27,20 ---</span>
  #include &quot;SQLiteIDBBackingStore.h&quot;
  
  #if ENABLE(INDEXED_DATABASE)
  
  #include &quot;IDBBindingUtilities.h&quot;
<span class="line-added">+ #include &quot;IDBCursorInfo.h&quot;</span>
  #include &quot;IDBGetAllRecordsData.h&quot;
  #include &quot;IDBGetAllResult.h&quot;
  #include &quot;IDBGetRecordData.h&quot;
  #include &quot;IDBGetResult.h&quot;
  #include &quot;IDBIterateCursorData.h&quot;
  #include &quot;IDBKeyData.h&quot;
  #include &quot;IDBObjectStoreInfo.h&quot;
  #include &quot;IDBSerialization.h&quot;
<span class="line-added">+ #include &quot;IDBSerializationContext.h&quot;</span>
  #include &quot;IDBTransactionInfo.h&quot;
  #include &quot;IDBValue.h&quot;
  #include &quot;IndexKey.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;SQLiteDatabase.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,15 ***</span>
  #include &quot;SQLiteIDBCursor.h&quot;
  #include &quot;SQLiteStatement.h&quot;
  #include &quot;SQLiteTransaction.h&quot;
  #include &quot;ThreadSafeDataBuffer.h&quot;
  #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
<span class="line-removed">- #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;</span>
<span class="line-removed">- #include &lt;JavaScriptCore/JSGlobalObject.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="line-removed">- #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  #include &lt;wtf/FileSystem.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  
  namespace WebCore {
<span class="line-new-header">--- 48,12 ---</span>
  #include &quot;SQLiteIDBCursor.h&quot;
  #include &quot;SQLiteStatement.h&quot;
  #include &quot;SQLiteTransaction.h&quot;
  #include &quot;ThreadSafeDataBuffer.h&quot;
  #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
  #include &lt;wtf/FileSystem.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,52 ***</span>
  {
      static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
      return blobFilesTableSchemaString;
  }
  
<span class="line-modified">! SQLiteIDBBackingStore::SQLiteIDBBackingStore(const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, uint64_t quota)</span>
<span class="line-modified">!     : m_identifier(identifier)</span>
      , m_temporaryFileHandler(fileHandler)
<span class="line-modified">!     , m_quota(quota)</span>
  {
<span class="line-modified">!     m_absoluteDatabaseDirectory = identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory);</span>
  }
  
  SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
  {
      if (m_sqliteDB)
          closeSQLiteDB();
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_vm) {</span>
<span class="line-removed">-         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed">-         m_globalObject.clear();</span>
<span class="line-removed">-         m_vm = nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void SQLiteIDBBackingStore::initializeVM()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_vm) {</span>
<span class="line-removed">-         ASSERT(!m_globalObject);</span>
<span class="line-removed">-         m_vm = VM::create();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         JSLockHolder locker(m_vm.get());</span>
<span class="line-removed">-         m_globalObject.set(*m_vm, JSGlobalObject::create(*m_vm, JSGlobalObject::createStructure(*m_vm, jsNull())));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- VM&amp; SQLiteIDBBackingStore::vm()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     initializeVM();</span>
<span class="line-removed">-     return *m_vm;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JSGlobalObject&amp; SQLiteIDBBackingStore::globalObject()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     initializeVM();</span>
<span class="line-removed">-     return **m_globalObject;</span>
  }
  
  static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
  {
      String currentSchema;
<span class="line-new-header">--- 227,24 ---</span>
  {
      static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
      return blobFilesTableSchemaString;
  }
  
<span class="line-modified">! SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
<span class="line-modified">!     : m_sessionID(sessionID)</span>
<span class="line-added">+     , m_identifier(identifier)</span>
<span class="line-added">+     , m_databaseRootDirectory(databaseRootDirectory)</span>
      , m_temporaryFileHandler(fileHandler)
<span class="line-modified">!     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))</span>
  {
<span class="line-modified">!     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();</span>
  }
  
  SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
  {
      if (m_sqliteDB)
          closeSQLiteDB();
  }
  
  static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
  {
      String currentSchema;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,11 ***</span>
          closeSQLiteDB();
          return nullptr;
      }
  
      // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified">!     return std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
  {
      ASSERT(m_sqliteDB);
<span class="line-new-header">--- 593,11 ---</span>
          closeSQLiteDB();
          return nullptr;
      }
  
      // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified">!     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
  {
      ASSERT(m_sqliteDB);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 657,11 ***</span>
              LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
              return nullptr;
          }
      }
  
<span class="line-modified">!     auto databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
  
      {
          SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
          if (sql.prepare() != SQLITE_OK)
              return nullptr;
<span class="line-new-header">--- 628,11 ---</span>
              LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
              return nullptr;
          }
      }
  
<span class="line-modified">!     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
  
      {
          SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);
          if (sql.prepare() != SQLITE_OK)
              return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,22 ***</span>
      filename.replace(&#39;.&#39;, &quot;%2E&quot;);
  
      return filename;
  }
  
<span class="line-modified">! String SQLiteIDBBackingStore::fullDatabaseDirectory() const</span>
  {
<span class="line-modified">!     ASSERT(!m_identifier.databaseName().isNull());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return FileSystem::pathByAppendingComponent(m_absoluteDatabaseDirectory, filenameForDatabaseName());</span>
  }
  
  String SQLiteIDBBackingStore::fullDatabasePath() const
  {
<span class="line-modified">!     ASSERT(!m_identifier.databaseName().isNull());</span>
  
<span class="line-modified">!     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory(), &quot;IndexedDB.sqlite3&quot;);</span>
  }
  
  IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
<span class="line-new-header">--- 733,55 ---</span>
      filename.replace(&#39;.&#39;, &quot;%2E&quot;);
  
      return filename;
  }
  
<span class="line-modified">! String SQLiteIDBBackingStore::fullDatabasePathForDirectory(const String&amp; fullDatabaseDirectory)</span>
  {
<span class="line-modified">!     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory, &quot;IndexedDB.sqlite3&quot;);</span>
  }
  
  String SQLiteIDBBackingStore::fullDatabasePath() const
  {
<span class="line-modified">!     return fullDatabasePathForDirectory(m_databaseDirectory);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! String SQLiteIDBBackingStore::databaseNameFromFile(const String&amp; databasePath)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     SQLiteDatabase database;</span>
<span class="line-added">+     if (!database.open(databasePath)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39; when getting database name&quot;, databasePath.utf8().data());</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!database.tableExists(&quot;IDBDatabaseInfo&quot;_s)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not find IDBDatabaseInfo table and get database name(%i) - %s&quot;, database.lastError(), database.lastErrorMsg());</span>
<span class="line-added">+         database.close();</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     SQLiteStatement sql(database, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);</span>
<span class="line-added">+     auto databaseName = sql.getColumnText(0);</span>
<span class="line-added">+     database.close();</span>
<span class="line-added">+     return databaseName;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String SQLiteIDBBackingStore::fullDatabaseDirectoryWithUpgrade()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto databaseRootDirectory = this-&gt;databaseRootDirectoryIsolatedCopy();</span>
<span class="line-added">+     String oldOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v0&quot;);</span>
<span class="line-added">+     String oldDatabaseDirectory = FileSystem::pathByAppendingComponent(oldOriginDirectory, filenameForDatabaseName());</span>
<span class="line-added">+     String newOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v1&quot;);</span>
<span class="line-added">+     String fileNameHash = SQLiteFileSystem::computeHashForFileName(m_identifier.databaseName());</span>
<span class="line-added">+     Vector&lt;String&gt; directoriesWithSameHash = FileSystem::listDirectory(newOriginDirectory, fileNameHash + &quot;*&quot;);</span>
<span class="line-added">+     String newDatabaseDirectory = FileSystem::pathByAppendingComponent(newOriginDirectory, fileNameHash);</span>
<span class="line-added">+     FileSystem::makeAllDirectories(newDatabaseDirectory);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (FileSystem::fileExists(oldDatabaseDirectory)) {</span>
<span class="line-added">+         FileSystem::moveFile(oldDatabaseDirectory, newDatabaseDirectory);</span>
<span class="line-added">+         FileSystem::deleteEmptyDirectory(oldOriginDirectory);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return newDatabaseDirectory;</span>
  }
  
  IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 785,14 ***</span>
      if (m_databaseInfo) {
          info = *m_databaseInfo;
          return IDBError { };
      }
  
<span class="line-removed">-     FileSystem::makeAllDirectories(fullDatabaseDirectory());</span>
      String dbFilename = fullDatabasePath();
  
<span class="line-modified">!     m_sqliteDB = std::make_unique&lt;SQLiteDatabase&gt;();</span>
      if (!m_sqliteDB-&gt;open(dbFilename)) {
          LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
          closeSQLiteDB();
      }
  
<span class="line-new-header">--- 789,13 ---</span>
      if (m_databaseInfo) {
          info = *m_databaseInfo;
          return IDBError { };
      }
  
      String dbFilename = fullDatabasePath();
  
<span class="line-modified">!     m_sqliteDB = makeUnique&lt;SQLiteDatabase&gt;();</span>
      if (!m_sqliteDB-&gt;open(dbFilename)) {
          LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
          closeSQLiteDB();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 840,69 ***</span>
      m_databaseInfo = WTFMove(databaseInfo);
      info = *m_databaseInfo;
      return IDBError { };
  }
  
<span class="line-modified">! uint64_t SQLiteIDBBackingStore::quotaForOrigin() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     uint64_t diskFreeSpaceSize = 0;</span>
<span class="line-removed">-     FileSystem::getVolumeFreeSpace(m_absoluteDatabaseDirectory, diskFreeSpaceSize);</span>
<span class="line-removed">-     return std::min(diskFreeSpaceSize / 2, m_quota);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t SQLiteIDBBackingStore::maximumSize() const</span>
  {
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The maximum size for one database file is the quota for its origin, minus size of all databases within that origin,</span>
<span class="line-removed">-     // and plus current size of the database file.</span>
<span class="line-removed">-     uint64_t databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
<span class="line-removed">-     uint64_t quota = quotaForOrigin();</span>
<span class="line-removed">- </span>
      uint64_t diskUsage = 0;
<span class="line-modified">!     for (auto&amp; directory : FileSystem::listDirectory(m_absoluteDatabaseDirectory, &quot;*&quot;)) {</span>
<span class="line-modified">!         for (auto&amp; file : FileSystem::listDirectory(directory, &quot;*.sqlite3&quot;_s))</span>
              diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
      }
<span class="line-modified">!     ASSERT(diskUsage &gt;= databaseFileSize);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (quota &lt; diskUsage)</span>
<span class="line-removed">-         return databaseFileSize;</span>
  
<span class="line-modified">!     return quota - diskUsage + databaseFileSize;</span>
  }
  
  IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
      ASSERT(m_databaseInfo);
  
<span class="line-removed">-     m_sqliteDB-&gt;setMaximumSize(maximumSize());</span>
      auto addResult = m_transactions.add(info.identifier(), nullptr);
      if (!addResult.isNewEntry) {
          LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
          return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
      }
  
<span class="line-modified">!     addResult.iterator-&gt;value = std::make_unique&lt;SQLiteIDBTransaction&gt;(*this, info);</span>
  
      auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
      if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
<span class="line-modified">!         m_originalDatabaseInfoBeforeVersionChange = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);</span>
  
          SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
          if (sql.prepare() != SQLITE_OK
              || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
              || sql.step() != SQLITE_DONE) {
<span class="line-modified">!             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 error = IDBError { QuotaExceededError, &quot;Failed to store new database version in database because no enough space for domain&quot;_s };</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };</span>
          }
      }
  
      return error;
  }
<span class="line-new-header">--- 843,51 ---</span>
      m_databaseInfo = WTFMove(databaseInfo);
      info = *m_databaseInfo;
      return IDBError { };
  }
  
<span class="line-modified">! uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)</span>
  {
      uint64_t diskUsage = 0;
<span class="line-modified">!     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {</span>
<span class="line-modified">!         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))</span>
              diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
      }
<span class="line-modified">!     return diskUsage;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! uint64_t SQLiteIDBBackingStore::databaseSize() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
  }
  
  IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
      ASSERT(m_databaseInfo);
  
      auto addResult = m_transactions.add(info.identifier(), nullptr);
      if (!addResult.isNewEntry) {
          LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
          return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
      }
  
<span class="line-modified">!     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);</span>
  
      auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
      if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
<span class="line-modified">!         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);</span>
  
          SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
          if (sql.prepare() != SQLITE_OK
              || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
              || sql.step() != SQLITE_DONE) {
<span class="line-modified">!             error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };</span>
          }
      }
  
      return error;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 957,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to create an object store without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
      }
  
<span class="line-new-header">--- 942,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,24 ***</span>
              || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
              || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
              || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Could not create object store because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
          }
      }
  
      {
          auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
          if (!sql
              || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Could not seed initial key generator value for object store because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
          }
      }
  
      m_databaseInfo-&gt;addExistingObjectStore(info);
<span class="line-new-header">--- 966,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1013,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to delete an object store without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
      }
  
<span class="line-new-header">--- 993,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1105,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to rename an object store without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
      }
  
<span class="line-new-header">--- 1084,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1121,12 ***</span>
          if (!sql
              || sql-&gt;bindText(1, newName) != SQLITE_OK
              || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Could not rename object store because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
          }
      }
  
      m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
<span class="line-new-header">--- 1099,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1140,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to clear an object store without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 1116,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1181,14 ***</span>
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to create an index without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
      }
  
<span class="line-new-header">--- 1156,13 ---</span>
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1206,12 ***</span>
          || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
          || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
          || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
          || sql-&gt;step() != SQLITE_DONE) {
          LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-             return IDBError { QuotaExceededError, &quot;Unable to create index in database because no enough space for domain&quot;_s };</span>
          return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
      }
  
      // Write index records for any records that already exist in this object store.
  
<span class="line-new-header">--- 1180,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1247,10 ***</span>
<span class="line-new-header">--- 1219,16 ---</span>
              LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
              return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
          }
      }
  
<span class="line-added">+     ASSERT(m_databaseInfo);</span>
<span class="line-added">+     if (!m_databaseInfo) {</span>
<span class="line-added">+         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);</span>
<span class="line-added">+         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
      ASSERT(objectStore);
      objectStore-&gt;addExistingIndex(info);
  
      return IDBError { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1350,12 ***</span>
              || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
              || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
              || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Error putting index record into database because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
          }
      }
  
      return IDBError { };
<span class="line-new-header">--- 1328,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1368,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to delete index without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
      }
<span class="line-new-header">--- 1344,12 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
  
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1423,14 ***</span>
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
      if (!indexInfo)
          return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to rename an index without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
      }
<span class="line-new-header">--- 1397,12 ---</span>
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
      if (!indexInfo)
          return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
  
      if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
          LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1441,12 ***</span>
              || sql-&gt;bindText(1, newName) != SQLITE_OK
              || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
              || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Could not rename index because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
          }
      }
  
      indexInfo-&gt;rename(newName);
<span class="line-new-header">--- 1413,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1462,14 ***</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      keyExists = false;
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
      if (!keyBuffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
<span class="line-new-header">--- 1432,12 ---</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      keyExists = false;
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
  
      RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
      if (!keyBuffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1637,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to delete range from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 1605,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1692,38 ***</span>
      return error;
  }
  
  IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
  {
<span class="line-modified">!     JSLockHolder locker(vm());</span>
  
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
      if (jsValue.isUndefinedOrNull())
          return IDBError { };
  
      IndexKey indexKey;
<span class="line-modified">!     generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), info, jsValue, indexKey);</span>
  
      if (indexKey.isNull())
          return IDBError { };
  
      return uncheckedPutIndexKey(info, key, indexKey, recordID);
  }
  
  IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
  {
<span class="line-modified">!     JSLockHolder locker(vm());</span>
  
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(*globalObject().globalExec(), value);</span>
      if (jsValue.isUndefinedOrNull())
          return IDBError { };
  
      IDBError error;
      bool anyRecordsSucceeded = false;
      for (auto&amp; index : info.indexMap().values()) {
          IndexKey indexKey;
<span class="line-modified">!         generateIndexKeyForValue(*m_globalObject-&gt;globalExec(), index, jsValue, indexKey);</span>
  
          if (indexKey.isNull())
              continue;
  
          error = uncheckedPutIndexKey(index, key, indexKey, recordID);
<span class="line-new-header">--- 1659,40 ---</span>
      return error;
  }
  
  IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
  {
<span class="line-modified">!     JSLockHolder locker(m_serializationContext-&gt;vm());</span>
  
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);</span>
      if (jsValue.isUndefinedOrNull())
          return IDBError { };
  
      IndexKey indexKey;
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     generateIndexKeyForValue(m_serializationContext-&gt;execState(), info, jsValue, indexKey, objectStoreInfo-&gt;keyPath(), key);</span>
  
      if (indexKey.isNull())
          return IDBError { };
  
      return uncheckedPutIndexKey(info, key, indexKey, recordID);
  }
  
  IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
  {
<span class="line-modified">!     JSLockHolder locker(m_serializationContext-&gt;vm());</span>
  
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);</span>
      if (jsValue.isUndefinedOrNull())
          return IDBError { };
  
      IDBError error;
      bool anyRecordsSucceeded = false;
      for (auto&amp; index : info.indexMap().values()) {
          IndexKey indexKey;
<span class="line-modified">!         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);</span>
  
          if (indexKey.isNull())
              continue;
  
          error = uncheckedPutIndexKey(index, key, indexKey, recordID);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1758,14 ***</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
      ASSERT(value.data().data());
      ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to store a record in an object store without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 1727,13 ---</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
      ASSERT(value.data().data());
      ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1782,12 ***</span>
              || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
              || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
              || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-             if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                 return IDBError { QuotaExceededError, &quot;Unable to store record in object store because no enough space for domain&quot;_s };</span>
              return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
          }
  
          recordID = m_sqliteDB-&gt;lastInsertRowID();
      }
<span class="line-new-header">--- 1750,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1816,12 ***</span>
              if (!sql
                  || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
                  || sql-&gt;bindText(2, url) != SQLITE_OK
                  || sql-&gt;step() != SQLITE_DONE) {
                  LOG_ERROR(&quot;Unable to record Blob record in database&quot;);
<span class="line-removed">-                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                     return IDBError { QuotaExceededError, &quot;Unable to record Blob record in database because no enough space for domain&quot;_s };</span>
                  return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
              }
          }
          int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
  
<span class="line-new-header">--- 1782,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1851,12 ***</span>
              if (!sql
                  || sql-&gt;bindText(1, url) != SQLITE_OK
                  || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
                  || sql-&gt;step() != SQLITE_DONE) {
                  LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);
<span class="line-removed">-                 if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-                     return IDBError { QuotaExceededError, &quot;Unable to record Blob file in database because no enough space for domain&quot;_s };</span>
                  return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
              }
          }
  
          transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
<span class="line-new-header">--- 1815,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1865,11 ***</span>
      transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
  
      return error;
  }
  
<span class="line-modified">! IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, PAL::SessionID&amp; sessionID, Vector&lt;String&gt;&amp; blobFilePaths)</span>
  {
      ASSERT(objectStoreRecord);
  
      HashSet&lt;String&gt; blobURLSet;
      {
<span class="line-new-header">--- 1827,11 ---</span>
      transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
  
      return error;
  }
  
<span class="line-modified">! IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, Vector&lt;String&gt;&amp; blobFilePaths)</span>
  {
      ASSERT(objectStoreRecord);
  
      HashSet&lt;String&gt; blobURLSet;
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1896,11 ***</span>
              return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
          }
      }
  
      ASSERT(!blobURLSet.isEmpty());
<span class="line-removed">-     String databaseDirectory = fullDatabaseDirectory();</span>
      for (auto&amp; blobURL : blobURLSet) {
          auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
          if (!sql
              || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
              LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-new-header">--- 1858,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1913,14 ***</span>
          }
  
          blobURLs.append(blobURL);
  
          String fileName = sql-&gt;getColumnText(0);
<span class="line-modified">!         blobFilePaths.append(FileSystem::pathByAppendingComponent(databaseDirectory, fileName));</span>
      }
<span class="line-removed">-     sessionID = m_identifier.sessionID();</span>
<span class="line-removed">- </span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
  {
<span class="line-new-header">--- 1874,12 ---</span>
          }
  
          blobURLs.append(blobURL);
  
          String fileName = sql-&gt;getColumnText(0);
<span class="line-modified">!         blobFilePaths.append(FileSystem::pathByAppendingComponent(m_databaseDirectory, fileName));</span>
      }
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1928,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to get a record from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto key = keyRange.lowerKey;
      if (key.isNull())
          key = IDBKeyData::minimum();
      RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
<span class="line-new-header">--- 1887,12 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
  
      auto key = keyRange.lowerKey;
      if (key.isNull())
          key = IDBKeyData::minimum();
      RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1952,16 ***</span>
          LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
      }
  
      int64_t recordID = 0;
<span class="line-modified">!     ThreadSafeDataBuffer resultBuffer;</span>
      {
<span class="line-modified">!         static const char* const lowerOpenUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerOpenUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerClosedUpperOpen = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerClosedUpperClosed = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
  
          static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<span class="line-new-header">--- 1909,16 ---</span>
          LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
      }
  
      int64_t recordID = 0;
<span class="line-modified">!     ThreadSafeDataBuffer keyResultBuffer, valueResultBuffer;</span>
      {
<span class="line-modified">!         static const char* const lowerOpenUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerOpenUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerClosedUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!         static const char* const lowerClosedUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
  
          static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
          static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2014,45 ***</span>
              // There was an error fetching the record from the database.
              LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
          }
  
<span class="line-modified">!         Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">!         sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">!         resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
  
<span class="line-modified">!         if (type == IDBGetRecordDataType::KeyAndValue)</span>
<span class="line-modified">!             recordID = sql-&gt;getColumnInt64(1);</span>
      }
  
<span class="line-modified">!     if (type == IDBGetRecordDataType::KeyOnly) {</span>
<span class="line-modified">!         auto* vector = resultBuffer.data();</span>
<span class="line-modified">!         if (!vector) {</span>
<span class="line-modified">!             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">!             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         IDBKeyData keyData;</span>
<span class="line-modified">!         if (!deserializeIDBKeyData(vector-&gt;data(), vector-&gt;size(), keyData)) {</span>
<span class="line-modified">!             LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore.getKey()&quot;);</span>
<span class="line-modified">!             return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore.getKey()&quot;_s };</span>
<span class="line-modified">!         }</span>
  
          resultValue = { keyData };
          return IDBError { };
      }
  
      ASSERT(recordID);
      Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!     PAL::SessionID sessionID;</span>
<span class="line-removed">-     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
      ASSERT(blobURLs.size() == blobFilePaths.size());
  
      if (!error.isNull())
          return error;
  
<span class="line-modified">!     resultValue = { { resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) } };</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
  {
<span class="line-new-header">--- 1971,50 ---</span>
              // There was an error fetching the record from the database.
              LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
          }
  
<span class="line-modified">!         Vector&lt;uint8_t&gt; keyBuffer;</span>
<span class="line-modified">!         sql-&gt;getColumnBlobAsVector(0, keyBuffer);</span>
<span class="line-modified">!         keyResultBuffer = ThreadSafeDataBuffer::create(WTFMove(keyBuffer));</span>
  
<span class="line-modified">!         if (type == IDBGetRecordDataType::KeyAndValue) {</span>
<span class="line-modified">!             Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-added">+             sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-added">+             valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
<span class="line-added">+             recordID = sql-&gt;getColumnInt64(2);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     auto* keyVector = keyResultBuffer.data();</span>
<span class="line-modified">!     if (!keyVector) {</span>
<span class="line-modified">!         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);</span>
<span class="line-modified">!         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     IDBKeyData keyData;</span>
<span class="line-modified">!     if (!deserializeIDBKeyData(keyVector-&gt;data(), keyVector-&gt;size(), keyData)) {</span>
<span class="line-modified">!         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);</span>
<span class="line-modified">!         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };</span>
<span class="line-modified">!     }</span>
  
<span class="line-added">+     if (type == IDBGetRecordDataType::KeyOnly) {</span>
          resultValue = { keyData };
          return IDBError { };
      }
  
      ASSERT(recordID);
      Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>
      ASSERT(blobURLs.size() == blobFilePaths.size());
  
      if (!error.isNull())
          return error;
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     resultValue = { keyData, { valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath()};</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2063,14 ***</span>
  {
      static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<span class="line-modified">!     static const char* const lowerOpenUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerOpenUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerClosedUpperOpenValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerClosedUpperClosedValue = &quot;SELECT value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
  
      if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
          if (getAllRecordsData.keyRangeData.lowerOpen) {
              if (getAllRecordsData.keyRangeData.upperOpen)
                  return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
<span class="line-new-header">--- 2025,14 ---</span>
  {
      static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
      static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
<span class="line-modified">!     static const char* const lowerOpenUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerOpenUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerClosedUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;</span>
<span class="line-modified">!     static const char* const lowerClosedUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;</span>
  
      if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
          if (getAllRecordsData.keyRangeData.lowerOpen) {
              if (getAllRecordsData.keyRangeData.upperOpen)
                  return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2099,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to get records from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto key = getAllRecordsData.keyRangeData.lowerKey;
      if (key.isNull())
          key = IDBKeyData::minimum();
      auto lowerBuffer = serializeIDBKeyData(key);
<span class="line-new-header">--- 2061,12 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
  
      auto key = getAllRecordsData.keyRangeData.lowerKey;
      if (key.isNull())
          key = IDBKeyData::minimum();
      auto lowerBuffer = serializeIDBKeyData(key);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2131,11 ***</span>
          || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
          LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
      }
  
<span class="line-modified">!     result = { getAllRecordsData.getAllType };</span>
  
      uint32_t targetResults;
      if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
          targetResults = getAllRecordsData.count.value();
      else
<span class="line-new-header">--- 2091,13 ---</span>
          || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
          LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
      }
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };</span>
  
      uint32_t targetResults;
      if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
          targetResults = getAllRecordsData.count.value();
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2143,38 ***</span>
  
      int sqlResult = sql-&gt;step();
      uint32_t returnedResults = 0;
  
      while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
          if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
<span class="line-modified">!             Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-modified">!             sql-&gt;getColumnBlobAsVector(0, buffer);</span>
<span class="line-modified">!             ThreadSafeDataBuffer resultBuffer = ThreadSafeDataBuffer::create(WTFMove(buffer));</span>
  
<span class="line-modified">!             auto recordID = sql-&gt;getColumnInt64(1);</span>
  
              ASSERT(recordID);
              Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!             PAL::SessionID sessionID;</span>
<span class="line-removed">-             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
              ASSERT(blobURLs.size() == blobFilePaths.size());
  
              if (!error.isNull())
                  return error;
  
<span class="line-modified">!             result.addValue({ resultBuffer, WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) });</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             Vector&lt;uint8_t&gt; keyData;</span>
<span class="line-removed">-             IDBKeyData key;</span>
<span class="line-removed">-             sql-&gt;getColumnBlobAsVector(0, keyData);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (!deserializeIDBKeyData(keyData.data(), keyData.size(), key)) {</span>
<span class="line-removed">-                 LOG_ERROR(&quot;Unable to deserialize key data from database while getting all key records&quot;);</span>
<span class="line-removed">-                 return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all key records&quot;_s };</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             result.addKey(WTFMove(key));</span>
          }
  
          ++returnedResults;
          sqlResult = sql-&gt;step();
      }
<span class="line-new-header">--- 2105,35 ---</span>
  
      int sqlResult = sql-&gt;step();
      uint32_t returnedResults = 0;
  
      while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
<span class="line-added">+         Vector&lt;uint8_t&gt; keyBuffer;</span>
<span class="line-added">+         IDBKeyData keyData;</span>
<span class="line-added">+         sql-&gt;getColumnBlobAsVector(0, keyBuffer);</span>
<span class="line-added">+         if (!deserializeIDBKeyData(keyBuffer.data(), keyBuffer.size(), keyData)) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Unable to deserialize key data from database while getting all records&quot;);</span>
<span class="line-added">+             return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all records&quot;_s };</span>
<span class="line-added">+         }</span>
<span class="line-added">+         result.addKey(WTFMove(keyData));</span>
<span class="line-added">+ </span>
          if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
<span class="line-modified">!             Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-modified">!             sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-modified">!             ThreadSafeDataBuffer valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
  
<span class="line-modified">!             auto recordID = sql-&gt;getColumnInt64(2);</span>
  
              ASSERT(recordID);
              Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>
              ASSERT(blobURLs.size() == blobFilePaths.size());
  
              if (!error.isNull())
                  return error;
  
<span class="line-modified">!             result.addValue({ valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) });</span>
          }
  
          ++returnedResults;
          sqlResult = sql-&gt;step();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2195,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to get all index records from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
      if (!cursor) {
          LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
          return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
<span class="line-new-header">--- 2154,12 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
      if (!cursor) {
          LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
          return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2211,20 ***</span>
      if (cursor-&gt;didError()) {
          LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
          return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
      }
  
<span class="line-modified">!     result = { getAllRecordsData.getAllType };</span>
      uint32_t currentCount = 0;
      uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
      if (!targetCount)
          targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
      while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
<span class="line-modified">!         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {</span>
<span class="line-modified">!             IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();</span>
<span class="line-modified">!             result.addKey(WTFMove(keyCopy));</span>
<span class="line-removed">-         } else</span>
              result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
  
          ++currentCount;
          cursor-&gt;advance(1);
      }
<span class="line-new-header">--- 2168,22 ---</span>
      if (cursor-&gt;didError()) {
          LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
          return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
      }
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };</span>
<span class="line-added">+ </span>
      uint32_t currentCount = 0;
      uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
      if (!targetCount)
          targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
      while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
<span class="line-modified">!         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();</span>
<span class="line-modified">!         result.addKey(WTFMove(keyCopy));</span>
<span class="line-modified">!         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)</span>
              result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());
  
          ++currentCount;
          cursor-&gt;advance(1);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2243,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to get an index record from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      if (range.isExactlyOneKey())
          return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
<span class="line-new-header">--- 2202,12 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
  
      if (range.isExactlyOneKey())
          return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2267,12 ***</span>
      if (cursor-&gt;didComplete())
          getResult = { };
      else {
          if (type == IndexedDB::IndexRecordType::Key)
              getResult = { cursor-&gt;currentPrimaryKey() };
<span class="line-modified">!         else</span>
<span class="line-modified">!             getResult = { cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), cursor-&gt;currentPrimaryKey() };</span>
      }
  
      return IDBError { };
  }
  
<span class="line-new-header">--- 2224,15 ---</span>
      if (cursor-&gt;didComplete())
          getResult = { };
      else {
          if (type == IndexedDB::IndexRecordType::Key)
              getResult = { cursor-&gt;currentPrimaryKey() };
<span class="line-modified">!         else {</span>
<span class="line-modified">!             auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">+             ASSERT(objectStoreInfo);</span>
<span class="line-added">+             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), objectStoreInfo-&gt;keyPath() };</span>
<span class="line-added">+         }</span>
      }
  
      return IDBError { };
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2319,22 ***</span>
      if (type == IndexedDB::IndexRecordType::Key) {
          getResult = { objectStoreKey };
          return IDBError { };
      }
  
<span class="line-modified">!     sql-&gt;getColumnBlobAsVector(1, keyVector);</span>
  
      int64_t recordID = sql-&gt;getColumnInt64(2);
      Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!     PAL::SessionID sessionID;</span>
<span class="line-removed">-     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, sessionID, blobFilePaths);</span>
      ASSERT(blobURLs.size() == blobFilePaths.size());
  
      if (!error.isNull())
          return error;
  
<span class="line-modified">!     getResult = { { ThreadSafeDataBuffer::create(WTFMove(keyVector)), WTFMove(blobURLs), sessionID, WTFMove(blobFilePaths) }, objectStoreKey };</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
  {
<span class="line-new-header">--- 2279,24 ---</span>
      if (type == IndexedDB::IndexRecordType::Key) {
          getResult = { objectStoreKey };
          return IDBError { };
      }
  
<span class="line-modified">!     Vector&lt;uint8_t&gt; valueVector;</span>
<span class="line-added">+     sql-&gt;getColumnBlobAsVector(1, valueVector);</span>
  
      int64_t recordID = sql-&gt;getColumnInt64(2);
      Vector&lt;String&gt; blobURLs, blobFilePaths;
<span class="line-modified">!     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);</span>
      ASSERT(blobURLs.size() == blobFilePaths.size());
  
      if (!error.isNull())
          return error;
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(objectStoreID);</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2343,14 ***</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      outCount = 0;
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to get count from database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
      if (!cursor) {
          LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
          return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
<span class="line-new-header">--- 2305,12 ---</span>
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      outCount = 0;
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
  
      auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
      if (!cursor) {
          LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
          return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2390,12 ***</span>
      if (!sql
          || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
          || sql-&gt;bindInt64(2, value) != SQLITE_OK
          || sql-&gt;step() != SQLITE_DONE) {
          LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-removed">-         if (m_sqliteDB-&gt;lastError() == SQLITE_FULL)</span>
<span class="line-removed">-             return IDBError { QuotaExceededError, &quot;Error storing new key generator value in database because no enough space for domain&quot;_s };</span>
          return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
      }
  
      return IDBError { };
  }
<span class="line-new-header">--- 2350,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2406,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to generate key in database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 2364,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2435,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to revert key generator value in database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 2392,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2456,14 ***</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to update key generator value in database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">!     }</span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
      }
  
<span class="line-new-header">--- 2412,13 ---</span>
  
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
<span class="line-modified">! </span>
      if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
          LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
          return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2482,24 ***</span>
  {
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to open a cursor in database without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto* cursor = transaction-&gt;maybeOpenCursor(info);
      if (!cursor) {
          LOG_ERROR(&quot;Unable to open cursor&quot;);
          return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
      }
  
      m_cursors.set(cursor-&gt;identifier(), cursor);
  
<span class="line-modified">!     cursor-&gt;currentData(result);</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
  {
<span class="line-new-header">--- 2437,24 ---</span>
  {
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
<span class="line-modified">!     if (!transaction || !transaction-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
  
      auto* cursor = transaction-&gt;maybeOpenCursor(info);
      if (!cursor) {
          LOG_ERROR(&quot;Unable to open cursor&quot;);
          return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
      }
  
      m_cursors.set(cursor-&gt;identifier(), cursor);
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2514,14 ***</span>
          return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
      }
  
      ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
  
<span class="line-modified">!     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress()) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Attempt to iterate a cursor without an in-progress transaction&quot;);</span>
          return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
<span class="line-removed">-     }</span>
  
      auto key = data.keyData;
      auto primaryKey = data.primaryKeyData;
      auto count = data.count;
  
<span class="line-new-header">--- 2469,12 ---</span>
          return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
      }
  
      ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
  
<span class="line-modified">!     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())</span>
          return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
  
      auto key = data.keyData;
      auto primaryKey = data.primaryKeyData;
      auto count = data.count;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2538,11 ***</span>
              LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
              return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
          }
      }
  
<span class="line-modified">!     cursor-&gt;currentData(result);</span>
      return IDBError { };
  }
  
  bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
  {
<span class="line-new-header">--- 2491,13 ---</span>
              LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
              return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
          }
      }
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-added">+     ASSERT(objectStoreInfo);</span>
<span class="line-added">+     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
      return IDBError { };
  }
  
  bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2592,23 ***</span>
  
          if (errored)
              LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
      }
  
<span class="line-removed">-     String databaseDirectory = fullDatabaseDirectory();</span>
      for (auto&amp; file : blobFiles) {
<span class="line-modified">!         String fullPath = FileSystem::pathByAppendingComponent(databaseDirectory, file);</span>
          if (!FileSystem::deleteFile(fullPath))
              LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
      }
  
      if (m_sqliteDB)
          closeSQLiteDB();
  
      SQLiteFileSystem::deleteDatabaseFile(dbFilename);
<span class="line-modified">!     SQLiteFileSystem::deleteEmptyDatabaseDirectory(fullDatabaseDirectory());</span>
<span class="line-modified">!     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_absoluteDatabaseDirectory);</span>
  }
  
  void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
  {
      ASSERT(m_cursors.contains(cursor.identifier()));
<span class="line-new-header">--- 2547,22 ---</span>
  
          if (errored)
              LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
      }
  
      for (auto&amp; file : blobFiles) {
<span class="line-modified">!         String fullPath = FileSystem::pathByAppendingComponent(m_databaseDirectory, file);</span>
          if (!FileSystem::deleteFile(fullPath))
              LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
      }
  
      if (m_sqliteDB)
          closeSQLiteDB();
  
      SQLiteFileSystem::deleteDatabaseFile(dbFilename);
<span class="line-modified">!     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);</span>
<span class="line-modified">!     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));</span>
  }
  
  void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
  {
      ASSERT(m_cursors.contains(cursor.identifier()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2627,18 ***</span>
              return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
          m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
      }
  
      if (m_sqliteDB) {
<span class="line-modified">!         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = std::make_unique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);</span>
          if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
              m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
      }
  
      return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
  }
  
  void SQLiteIDBBackingStore::closeSQLiteDB()
  {
      for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
          m_cachedStatements[i] = nullptr;
  
<span class="line-new-header">--- 2581,23 ---</span>
              return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
          m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
      }
  
      if (m_sqliteDB) {
<span class="line-modified">!         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);</span>
          if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
              m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
      }
  
      return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
  }
  
<span class="line-added">+ void SQLiteIDBBackingStore::close()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     closeSQLiteDB();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SQLiteIDBBackingStore::closeSQLiteDB()
  {
      for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)
          m_cachedStatements[i] = nullptr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2646,9 ***</span>
<span class="line-new-header">--- 2605,15 ---</span>
          m_sqliteDB-&gt;close();
  
      m_sqliteDB = nullptr;
  }
  
<span class="line-added">+ bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     return m_transactions.contains(transactionIdentifier);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace IDBServer
  } // namespace WebCore
  
  #endif // ENABLE(INDEXED_DATABASE)
</pre>
<center><a href="MemoryObjectStoreCursor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>