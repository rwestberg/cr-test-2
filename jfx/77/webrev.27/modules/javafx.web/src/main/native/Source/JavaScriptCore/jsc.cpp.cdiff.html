<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jit/ThunkGenerators.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
<span class="line-new-header">--- 1,8 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #include &quot;ArrayBuffer.h&quot;
  #include &quot;ArrayPrototype.h&quot;
  #include &quot;BuiltinNames.h&quot;
  #include &quot;ButterflyInlines.h&quot;
<span class="line-added">+ #include &quot;BytecodeCacheError.h&quot;</span>
  #include &quot;CatchScope.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeCache.h&quot;
  #include &quot;Completion.h&quot;
  #include &quot;ConfigFile.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,10 ***</span>
<span class="line-new-header">--- 68,11 ---</span>
  #include &quot;StructureInlines.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;TestRunnerUtils.h&quot;
  #include &quot;TypedArrayInlines.h&quot;
<span class="line-added">+ #include &quot;WasmCapabilities.h&quot;</span>
  #include &quot;WasmContext.h&quot;
  #include &quot;WasmFaultSignalHandler.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &lt;locale.h&gt;
  #include &lt;math.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,10 ***</span>
<span class="line-new-header">--- 83,11 ---</span>
  #include &lt;sys/types.h&gt;
  #include &lt;thread&gt;
  #include &lt;type_traits&gt;
  #include &lt;wtf/Box.h&gt;
  #include &lt;wtf/CommaPrinter.h&gt;
<span class="line-added">+ #include &lt;wtf/FileSystem.h&gt;</span>
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/MemoryPressureHandler.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/Scope.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,11 ***</span>
  
  #if OS(WINDOWS)
  #include &lt;direct.h&gt;
  #include &lt;fcntl.h&gt;
  #include &lt;io.h&gt;
<span class="line-removed">- #include &lt;wtf/text/win/WCharStringExtras.h&gt;</span>
  #else
  #include &lt;unistd.h&gt;
  #endif
  
  #if PLATFORM(COCOA)
<span class="line-new-header">--- 99,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,12 ***</span>
  #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
  #include &lt;fenv.h&gt;
  #include &lt;arm/arch.h&gt;
  #endif
  
<span class="line-modified">! #if __has_include(&lt;WebKitAdditions/MemoryFootprint.h&gt;)</span>
<span class="line-modified">! #include &lt;WebKitAdditions/MemoryFootprint.h&gt;</span>
  #else
  struct MemoryFootprint {
      uint64_t current;
      uint64_t peak;
  
<span class="line-new-header">--- 135,18 ---</span>
  #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
  #include &lt;fenv.h&gt;
  #include &lt;arm/arch.h&gt;
  #endif
  
<span class="line-modified">! #if OS(DARWIN)</span>
<span class="line-modified">! #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;</span>
<span class="line-added">+ struct MemoryFootprint : ProcessMemoryFootprint {</span>
<span class="line-added">+     MemoryFootprint(const ProcessMemoryFootprint&amp; src)</span>
<span class="line-added">+         : ProcessMemoryFootprint(src)</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ };</span>
  #else
  struct MemoryFootprint {
      uint64_t current;
      uint64_t peak;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,11 ***</span>
  
      static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
          Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">!         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap, sizeof(Masquerader))) Masquerader(vm, structure);</span>
          result-&gt;finishCreation(vm);
          return result;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
<span class="line-new-header">--- 199,11 ---</span>
  
      static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
          Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">!         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);</span>
          result-&gt;finishCreation(vm);
          return result;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,10 ***</span>
<span class="line-new-header">--- 334,11 ---</span>
  static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
  static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,10 ***</span>
<span class="line-new-header">--- 382,12 ---</span>
  static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
  static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
  
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
<span class="line-added">+ </span>
  struct Script {
      enum class StrictMode {
          Strict,
          Sloppy
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,19 ***</span>
      CommandLine(int argc, char** argv)
      {
          parseArguments(argc, argv);
      }
  
      bool m_interactive { false };
      bool m_dump { false };
      bool m_module { false };
      bool m_exitCode { false };
<span class="line-modified">!     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-removed">-     Vector&lt;String&gt; m_arguments;</span>
      bool m_profile { false };
<span class="line-removed">-     String m_profilerOutput;</span>
<span class="line-removed">-     String m_uncaughtExceptionName;</span>
      bool m_treatWatchdogExceptionAsSuccess { false };
      bool m_alwaysDumpUncaughtException { false };
      bool m_dumpMemoryFootprint { false };
      bool m_dumpSamplingProfilerData { false };
      bool m_enableRemoteDebugging { false };
<span class="line-new-header">--- 423,20 ---</span>
      CommandLine(int argc, char** argv)
      {
          parseArguments(argc, argv);
      }
  
<span class="line-added">+     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-added">+     Vector&lt;String&gt; m_arguments;</span>
<span class="line-added">+     String m_profilerOutput;</span>
<span class="line-added">+     String m_uncaughtExceptionName;</span>
      bool m_interactive { false };
      bool m_dump { false };
      bool m_module { false };
      bool m_exitCode { false };
<span class="line-modified">!     bool m_destroyVM { false };</span>
      bool m_profile { false };
      bool m_treatWatchdogExceptionAsSuccess { false };
      bool m_alwaysDumpUncaughtException { false };
      bool m_dumpMemoryFootprint { false };
      bool m_dumpSamplingProfilerData { false };
      bool m_enableRemoteDebugging { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,26 ***</span>
  #if ENABLE(SAMPLING_FLAGS)
          addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
          addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
  #endif
  
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
          addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
          addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
          addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
  
          addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
  
          addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
  
          addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
  
          addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
          addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
          addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
          addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
<span class="line-new-header">--- 549,27 ---</span>
  #if ENABLE(SAMPLING_FLAGS)
          addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
          addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
  #endif
  
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
          addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
          addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
          addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
  
          addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
  
          addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
  
          addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
<span class="line-added">+         addFunction(vm, &quot;releaseWeakRefs&quot;, functionReleaseWeakRefs, 0);</span>
  
          addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
          addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
          addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
          addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,30 ***</span>
  #endif
  
          if (!arguments.isEmpty()) {
              JSArray* array = constructEmptyArray(globalExec(), 0);
              for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified">!                 array-&gt;putDirectIndex(globalExec(), i, jsString(globalExec(), arguments[i]));</span>
<span class="line-modified">!             putDirect(vm, Identifier::fromString(globalExec(), &quot;arguments&quot;), array);</span>
          }
  
<span class="line-modified">!         putDirect(vm, Identifier::fromString(globalExec(), &quot;console&quot;), jsUndefined());</span>
  
          Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
  
          JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified">!         putDirect(vm, Identifier::fromString(globalExec(), &quot;$&quot;), dollar);</span>
<span class="line-modified">!         putDirect(vm, Identifier::fromString(globalExec(), &quot;$262&quot;), dollar);</span>
  
          addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
          addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
          addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
  
<span class="line-modified">!         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;global&quot;), this);</span>
  
          JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified">!         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;agent&quot;), agent);</span>
  
          // The test262 INTERPRETING.md document says that some of these functions are just in the main
          // thread and some are in the other threads. We just put them in all threads.
          addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
          addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
<span class="line-new-header">--- 598,30 ---</span>
  #endif
  
          if (!arguments.isEmpty()) {
              JSArray* array = constructEmptyArray(globalExec(), 0);
              for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified">!                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
<span class="line-modified">!             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
          }
  
<span class="line-modified">!         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());</span>
  
          Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
  
          JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified">!         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);</span>
<span class="line-modified">!         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);</span>
  
          addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
          addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
          addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
  
<span class="line-modified">!         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);</span>
  
          JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified">!         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);</span>
  
          // The test262 INTERPRETING.md document says that some of these functions are just in the main
          // thread and some are in the other threads. We just put them in all threads.
          addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
          addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,15 ***</span>
          addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
  
          addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
          addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
          addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
      }
  
      void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
      {
<span class="line-modified">!         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
          object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
      }
  
      void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
      {
<span class="line-new-header">--- 638,17 ---</span>
          addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
  
          addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
          addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
          addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
<span class="line-added">+ </span>
<span class="line-added">+         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);</span>
      }
  
      void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
      {
<span class="line-modified">!         Identifier identifier = Identifier::fromString(vm, name);</span>
          object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
      }
  
      void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,11 ***</span>
      // In Windows, wchar_t is the UTF-16LE.
      // https://msdn.microsoft.com/en-us/library/dd374081.aspx
      // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
      Vector&lt;wchar_t&gt; buffer(bufferLength);
      DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<span class="line-modified">!     String directoryString = wcharToString(buffer.data(), lengthNotIncludingNull);</span>
      // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
      if (directoryString.startsWith(&quot;\\\\&quot;))
          return WTF::nullopt;
  #else
      Vector&lt;char&gt; buffer(PATH_MAX);
<span class="line-new-header">--- 761,11 ---</span>
      // In Windows, wchar_t is the UTF-16LE.
      // https://msdn.microsoft.com/en-us/library/dd374081.aspx
      // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
      Vector&lt;wchar_t&gt; buffer(bufferLength);
      DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<span class="line-modified">!     String directoryString(buffer.data(), lengthNotIncludingNull);</span>
      // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
      if (directoryString.startsWith(&quot;\\\\&quot;))
          return WTF::nullopt;
  #else
      Vector&lt;char&gt; buffer(PATH_MAX);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,11 ***</span>
  
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName)
          return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
  
<span class="line-modified">!     auto result = JSC::importModule(exec, Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
      return result;
  }
  
<span class="line-new-header">--- 842,11 ---</span>
  
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName)
          return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
  
<span class="line-modified">!     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
      return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,11 ***</span>
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
              throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
              return { };
          }
<span class="line-modified">!         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
      }
  
      const Identifier referrer = referrerValue.toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-new-header">--- 866,11 ---</span>
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
              throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
              return { };
          }
<span class="line-modified">!         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
      }
  
      const Identifier referrer = referrerValue.toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,20 ***</span>
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
              throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
              return { };
          }
<span class="line-modified">!         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
      }
  
      // If the referrer exists, we assume that the referrer is the correct absolute path.
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName) {
          throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
          return { };
      }
<span class="line-modified">!     return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
  }
  
  template&lt;typename Vector&gt;
  static void convertShebangToJSComment(Vector&amp; buffer)
  {
<span class="line-new-header">--- 878,20 ---</span>
          auto directoryName = currentWorkingDirectory();
          if (!directoryName) {
              throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
              return { };
          }
<span class="line-modified">!         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
      }
  
      // If the referrer exists, we assume that the referrer is the correct absolute path.
      auto directoryName = extractDirectoryName(referrer.impl());
      if (!directoryName) {
          throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
          return { };
      }
<span class="line-modified">!     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
  }
  
  template&lt;typename Vector&gt;
  static void convertShebangToJSComment(Vector&amp; buffer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,82 ***</span>
          return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
      }
  
      ~ShellSourceProvider()
      {
<span class="line-modified">! #if OS(DARWIN)</span>
<span class="line-removed">-         if (m_cachedBytecode.size())</span>
<span class="line-removed">-             munmap(const_cast&lt;void*&gt;(m_cachedBytecode.data()), m_cachedBytecode.size());</span>
<span class="line-removed">- #endif</span>
      }
  
<span class="line-modified">!     const CachedBytecode* cachedBytecode() const override</span>
      {
<span class="line-modified">!         return &amp;m_cachedBytecode;</span>
      }
  
      void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
      {
<span class="line-modified">! #if OS(DARWIN)</span>
          String filename = cachePath();
<span class="line-modified">!         if (filename.isNull())</span>
              return;
<span class="line-modified">!         int fd = open(filename.utf8().data(), O_CREAT | O_WRONLY | O_TRUNC | O_EXLOCK | O_NONBLOCK, 0666);</span>
<span class="line-modified">!         if (fd == -1)</span>
              return;
<span class="line-modified">!         CachedBytecode cachedBytecode = generator();</span>
<span class="line-modified">!         write(fd, cachedBytecode.data(), cachedBytecode.size());</span>
<span class="line-modified">!         close(fd);</span>
<span class="line-modified">! #endif</span>
      }
  
  private:
      String cachePath() const
      {
<span class="line-modified">!         const char* cachePath = Options::diskCachePath();</span>
<span class="line-removed">-         if (!cachePath)</span>
              return static_cast&lt;const char*&gt;(nullptr);
<span class="line-modified">!         String filename = sourceOrigin().string();</span>
<span class="line-modified">!         filename.replace(&#39;/&#39;, &#39;_&#39;);</span>
<span class="line-modified">!         return makeString(cachePath, &#39;/&#39;, source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;);</span>
      }
  
<span class="line-modified">!     void loadBytecode()</span>
      {
<span class="line-modified">! #if OS(DARWIN)</span>
          String filename = cachePath();
          if (filename.isNull())
              return;
  
<span class="line-modified">!         int fd = open(filename.utf8().data(), O_RDONLY | O_SHLOCK | O_NONBLOCK);</span>
<span class="line-modified">!         if (fd == -1)</span>
              return;
  
          auto closeFD = makeScopeExit([&amp;] {
<span class="line-modified">!             close(fd);</span>
          });
  
<span class="line-modified">!         struct stat sb;</span>
<span class="line-modified">!         int res = fstat(fd, &amp;sb);</span>
<span class="line-removed">-         size_t size = static_cast&lt;size_t&gt;(sb.st_size);</span>
<span class="line-removed">-         if (res || !size)</span>
<span class="line-removed">-             return;</span>
  
<span class="line-modified">!         void* buffer = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);</span>
<span class="line-removed">-         if (buffer == MAP_FAILED)</span>
              return;
<span class="line-modified">!         m_cachedBytecode = CachedBytecode { buffer, size };</span>
<span class="line-modified">! #endif</span>
      }
  
      ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
          : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
      {
<span class="line-removed">-         loadBytecode();</span>
      }
  
<span class="line-modified">!     CachedBytecode m_cachedBytecode;</span>
  };
  
  static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
  {
      return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
<span class="line-new-header">--- 979,128 ---</span>
          return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
      }
  
      ~ShellSourceProvider()
      {
<span class="line-modified">!         commitCachedBytecode();</span>
      }
  
<span class="line-modified">!     RefPtr&lt;CachedBytecode&gt; cachedBytecode() const override</span>
      {
<span class="line-modified">!         if (!m_cachedBytecode)</span>
<span class="line-added">+             loadBytecode();</span>
<span class="line-added">+         return m_cachedBytecode.copyRef();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp;, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock) const override</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!cacheEnabled() || !m_cachedBytecode)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         BytecodeCacheError error;</span>
<span class="line-added">+         RefPtr&lt;CachedBytecode&gt; cachedBytecode = encodeFunctionCodeBlock(executable-&gt;vm(), codeBlock, error);</span>
<span class="line-added">+         if (cachedBytecode &amp;&amp; !error.isValid())</span>
<span class="line-added">+             m_cachedBytecode-&gt;addFunctionUpdate(executable, kind, *cachedBytecode);</span>
      }
  
      void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
      {
<span class="line-modified">!         if (!cacheEnabled())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         if (!m_cachedBytecode)</span>
<span class="line-added">+             m_cachedBytecode = CachedBytecode::create();</span>
<span class="line-added">+         auto update = generator();</span>
<span class="line-added">+         if (update)</span>
<span class="line-added">+             m_cachedBytecode-&gt;addGlobalUpdate(*update);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void commitCachedBytecode() const override</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!cacheEnabled() || !m_cachedBytecode || !m_cachedBytecode-&gt;hasUpdates())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto clearBytecode = makeScopeExit([&amp;] {</span>
<span class="line-added">+             m_cachedBytecode = nullptr;</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
          String filename = cachePath();
<span class="line-modified">!         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Write, {FileSystem::FileLockMode::Exclusive, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-added">+         if (!FileSystem::isHandleValid(fd))</span>
              return;
<span class="line-modified">! </span>
<span class="line-modified">!         auto closeFD = makeScopeExit([&amp;] {</span>
<span class="line-added">+             FileSystem::unlockAndCloseFile(fd);</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+         long long fileSize;</span>
<span class="line-added">+         if (!FileSystem::getFileSize(fd, fileSize))</span>
              return;
<span class="line-modified">! </span>
<span class="line-modified">!         size_t cacheFileSize;</span>
<span class="line-modified">!         if (!WTF::convertSafely(fileSize, cacheFileSize) || cacheFileSize != m_cachedBytecode-&gt;size()) {</span>
<span class="line-modified">!             // The bytecode cache has already been updated</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!FileSystem::truncateFile(fd, m_cachedBytecode-&gt;sizeForUpdate()))</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_cachedBytecode-&gt;commitUpdates([&amp;] (off_t offset, const void* data, size_t size) {</span>
<span class="line-added">+             long long result = FileSystem::seekFile(fd, offset, FileSystem::FileSeekOrigin::Beginning);</span>
<span class="line-added">+             ASSERT_UNUSED(result, result != -1);</span>
<span class="line-added">+             size_t bytesWritten = static_cast&lt;size_t&gt;(FileSystem::writeToFile(fd, static_cast&lt;const char*&gt;(data), size));</span>
<span class="line-added">+             ASSERT_UNUSED(bytesWritten, bytesWritten == size);</span>
<span class="line-added">+         });</span>
      }
  
  private:
      String cachePath() const
      {
<span class="line-modified">!         if (!cacheEnabled())</span>
              return static_cast&lt;const char*&gt;(nullptr);
<span class="line-modified">!         const char* cachePath = Options::diskCachePath();</span>
<span class="line-modified">!         String filename = FileSystem::encodeForFileName(FileSystem::lastComponentOfPathIgnoringTrailingSlash(sourceOrigin().string()));</span>
<span class="line-modified">!         return FileSystem::pathByAppendingComponent(cachePath, makeString(source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;));</span>
      }
  
<span class="line-modified">!     void loadBytecode() const</span>
      {
<span class="line-modified">!         if (!cacheEnabled())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
          String filename = cachePath();
          if (filename.isNull())
              return;
  
<span class="line-modified">!         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Read, {FileSystem::FileLockMode::Shared, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-modified">!         if (!FileSystem::isHandleValid(fd))</span>
              return;
  
          auto closeFD = makeScopeExit([&amp;] {
<span class="line-modified">!             FileSystem::unlockAndCloseFile(fd);</span>
          });
  
<span class="line-modified">!         bool success;</span>
<span class="line-modified">!         FileSystem::MappedFileData mappedFileData(fd, FileSystem::MappedFileMode::Private, success);</span>
  
<span class="line-modified">!         if (!success)</span>
              return;
<span class="line-modified">! </span>
<span class="line-modified">!         m_cachedBytecode = CachedBytecode::create(WTFMove(mappedFileData));</span>
      }
  
      ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
          : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
      {
      }
  
<span class="line-modified">!     static bool cacheEnabled()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         static bool enabled = !!Options::diskCachePath();</span>
<span class="line-added">+         return enabled;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     mutable RefPtr&lt;CachedBytecode&gt; m_cachedBytecode;</span>
  };
  
  static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
  {
      return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1058,12 ***</span>
  {
      // We assume that fileName is always an absolute path.
  #if OS(WINDOWS)
      // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
      // Use long UNC to pass the long path name to the Windows APIs.
<span class="line-modified">!     String longUNCPathName = WTF::makeString(&quot;\\\\?\\&quot;, fileName);</span>
<span class="line-removed">-     auto pathName = stringToNullTerminatedWChar(longUNCPathName);</span>
      struct _stat status { };
      if (_wstat(pathName.data(), &amp;status))
          return false;
      if ((status.st_mode &amp; S_IFMT) != S_IFREG)
          return false;
<span class="line-new-header">--- 1119,11 ---</span>
  {
      // We assume that fileName is always an absolute path.
  #if OS(WINDOWS)
      // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
      // Use long UNC to pass the long path name to the Windows APIs.
<span class="line-modified">!     auto pathName = makeString(&quot;\\\\?\\&quot;, fileName).wideCharacters();</span>
      struct _stat status { };
      if (_wstat(pathName.data(), &amp;status))
          return false;
      if ((status.st_mode &amp; S_IFMT) != S_IFREG)
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1146,11 ***</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!     metaProperties-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;filename&quot;), key);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return metaProperties;
  }
  
<span class="line-new-header">--- 1206,11 ---</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-modified">!     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return metaProperties;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1222,24 ***</span>
      return JSValue::encode(jsUndefined());
  }
  
  EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
  {
      if (exec-&gt;argumentCount() &lt; 1)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(jsString(exec, toString(exec-&gt;argument(0))));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
  {
      if (exec-&gt;argumentCount() &lt; 1)
          return JSValue::encode(jsUndefined());
      VM&amp; vm = exec-&gt;vm();
      JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
      if (!object)
<span class="line-modified">!         return JSValue::encode(jsNontrivialString(exec, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">!     return JSValue::encode(jsNontrivialString(exec, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-new-header">--- 1282,25 ---</span>
      return JSValue::encode(jsUndefined());
  }
  
  EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
  {
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
      if (exec-&gt;argumentCount() &lt; 1)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
  {
      if (exec-&gt;argumentCount() &lt; 1)
          return JSValue::encode(jsUndefined());
      VM&amp; vm = exec-&gt;vm();
      JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
      if (!object)
<span class="line-modified">!         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">!     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1334,11 ***</span>
      }
  
      static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">!         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap, sizeof(JSCMemoryFootprint))) JSCMemoryFootprint(vm, structure);</span>
          footprint-&gt;finishCreation(vm);
          return footprint;
      }
  
      void finishCreation(VM&amp; vm)
<span class="line-new-header">--- 1395,11 ---</span>
      }
  
      static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">!         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);</span>
          footprint-&gt;finishCreation(vm);
          return footprint;
      }
  
      void finishCreation(VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,11 ***</span>
      DECLARE_INFO;
  
  private:
      void addProperty(VM&amp; vm, const char* name, JSValue value)
      {
<span class="line-modified">!         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
          putDirect(vm, identifier, value);
      }
  };
  
  const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
<span class="line-new-header">--- 1419,11 ---</span>
      DECLARE_INFO;
  
  private:
      void addProperty(VM&amp; vm, const char* name, JSValue value)
      {
<span class="line-modified">!         Identifier identifier = Identifier::fromString(vm, name);</span>
          putDirect(vm, identifier, value);
      }
  };
  
  const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1418,12 ***</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
          array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(</span>
<span class="line-removed">-         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
      StopWatch stopWatch;
      stopWatch.start();
      evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
<span class="line-new-header">--- 1479,11 ---</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
          array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
      StopWatch stopWatch;
      stopWatch.start();
      evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1451,15 ***</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
          array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(</span>
<span class="line-removed">-         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     evaluate(globalObject-&gt;globalExec(), makeSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
  
      if (exception) {
          scope.throwException(globalObject-&gt;globalExec(), exception);
          return JSValue::encode(jsUndefined());
      }
<span class="line-new-header">--- 1511,14 ---</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
          array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
<span class="line-modified">!     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
  
      NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">!     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
  
      if (exception) {
          scope.throwException(globalObject-&gt;globalExec(), exception);
          return JSValue::encode(jsUndefined());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1495,11 ***</span>
      String sourceCode = exec-&gt;argument(0).toWTFString(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
      if (evaluationException)
          throwException(exec, scope, evaluationException);
      return JSValue::encode(result);
  }
  
<span class="line-new-header">--- 1554,11 ---</span>
      String sourceCode = exec-&gt;argument(0).toWTFString(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
      if (evaluationException)
          throwException(exec, scope, evaluationException);
      return JSValue::encode(result);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1523,11 ***</span>
      RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
      if (!content)
          return throwVMError(exec, scope, &quot;Could not open file.&quot;);
  
      if (!isBinary)
<span class="line-modified">!         return JSValue::encode(jsString(exec, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
  
      Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
      JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-new-header">--- 1582,11 ---</span>
      RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
      if (!content)
          return throwVMError(exec, scope, &quot;Could not open file.&quot;);
  
      if (!isBinary)
<span class="line-modified">!         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
  
      Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
      JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1609,11 ***</span>
  EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
  {
      SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
      if (sourceOrigin.isNull())
          return JSValue::encode(jsNull());
<span class="line-modified">!     return JSValue::encode(jsString(state, sourceOrigin.string()));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
  {
      Vector&lt;char, 256&gt; line;
<span class="line-new-header">--- 1668,11 ---</span>
  EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
  {
      SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
      if (sourceOrigin.isNull())
          return JSValue::encode(jsNull());
<span class="line-modified">!     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
  {
      Vector&lt;char, 256&gt; line;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1623,11 ***</span>
          if (c == &#39;\n&#39;)
              break;
          line.append(c);
      }
      line.append(&#39;\0&#39;);
<span class="line-modified">!     return JSValue::encode(jsString(exec, line.data()));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
  {
      return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
<span class="line-new-header">--- 1682,11 ---</span>
          if (c == &#39;\n&#39;)
              break;
          line.append(c);
      }
      line.append(&#39;\0&#39;);
<span class="line-modified">!     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
  {
      return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1781,11 ***</span>
  
  EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<span class="line-modified">!     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(exec, &quot;$&quot;)));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
  {
      return functionTransferArrayBuffer(exec);
<span class="line-new-header">--- 1840,11 ---</span>
  
  EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<span class="line-modified">!     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
  {
      return functionTransferArrayBuffer(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1798,11 ***</span>
  
      String sourceCode = exec-&gt;argument(0).toWTFString(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<span class="line-modified">!         exec-&gt;thisValue().get(exec, Identifier::fromString(exec, &quot;global&quot;)));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (!globalObject)
          return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
  
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-new-header">--- 1857,11 ---</span>
  
      String sourceCode = exec-&gt;argument(0).toWTFString(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<span class="line-modified">!         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (!globalObject)
          return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
  
      NakedPtr&lt;Exception&gt; evaluationException;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1839,11 ***</span>
                          didStartCondition.notifyOne();
                      }
  
                      NakedPtr&lt;Exception&gt; evaluationException;
                      JSValue result;
<span class="line-modified">!                     result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
                      if (evaluationException)
                          result = evaluationException-&gt;value();
                      checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
                      if (!success)
                          exit(1);
<span class="line-new-header">--- 1898,11 ---</span>
                          didStartCondition.notifyOne();
                      }
  
                      NakedPtr&lt;Exception&gt; evaluationException;
                      JSValue result;
<span class="line-modified">!                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
                      if (evaluationException)
                          result = evaluationException-&gt;value();
                      checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
                      if (!success)
                          exit(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1944,11 ***</span>
  
      String string = Workers::singleton().tryGetReport();
      if (!string)
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     return JSValue::encode(jsString(&amp;vm, string));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
  {
      return JSValue::encode(jsUndefined());
<span class="line-new-header">--- 2003,11 ---</span>
  
      String string = Workers::singleton().tryGetReport();
      if (!string)
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     return JSValue::encode(jsString(vm, string));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
  {
      return JSValue::encode(jsUndefined());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1969,11 ***</span>
          string = Workers::singleton().getReport();
      }
      if (!string)
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     return JSValue::encode(jsString(&amp;vm, string));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-new-header">--- 2028,11 ---</span>
          string = Workers::singleton().getReport();
      }
      if (!string)
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     return JSValue::encode(jsString(vm, string));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2035,11 ***</span>
  EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      JSObject* optionsObject = constructEmptyObject(exec);
  #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<span class="line-modified">!     addOption(vm, optionsObject, Identifier::fromString(exec, #name_), Options::name_());</span>
      JSC_OPTIONS(FOR_EACH_OPTION)
  #undef FOR_EACH_OPTION
      return JSValue::encode(optionsObject);
  }
  
<span class="line-new-header">--- 2094,11 ---</span>
  EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      JSObject* optionsObject = constructEmptyObject(exec);
  #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<span class="line-modified">!     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());</span>
      JSC_OPTIONS(FOR_EACH_OPTION)
  #undef FOR_EACH_OPTION
      return JSValue::encode(optionsObject);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2154,10 ***</span>
<span class="line-new-header">--- 2213,17 ---</span>
      VM&amp; vm = exec-&gt;vm();
      vm.drainMicrotasks();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     vm.finalizeSynchronousJSExecution();</span>
<span class="line-added">+     return JSValue::encode(jsUndefined());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
  {
  #if USE(JSVALUE64)
      return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2181,16 ***</span>
  
      StopWatch stopWatch;
      stopWatch.start();
  
      ParserError error;
<span class="line-modified">!     bool validSyntax = checkModuleSyntax(exec, makeSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(exec, scope, jsNontrivialString(exec, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
  EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
  {
<span class="line-new-header">--- 2247,16 ---</span>
  
      StopWatch stopWatch;
      stopWatch.start();
  
      ParserError error;
<span class="line-modified">!     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      stopWatch.stop();
  
      if (!validSyntax)
<span class="line-modified">!         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
      return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
  }
  
  EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2229,11 ***</span>
          snapshotBuilder.buildSnapshot();
  
          jsonString = snapshotBuilder.json();
      }
      scope.releaseAssertNoException();
<span class="line-modified">!     return JSValue::encode(jsString(&amp;vm, jsonString));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
  {
      resetSuperSamplerState();
<span class="line-new-header">--- 2295,11 ---</span>
          snapshotBuilder.buildSnapshot();
  
          jsonString = snapshotBuilder.json();
      }
      scope.releaseAssertNoException();
<span class="line-modified">!     return JSValue::encode(jsString(vm, jsonString));</span>
  }
  
  EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
  {
      resetSuperSamplerState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2285,11 ***</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue numberOfAsyncPasses = exec-&gt;argument(0);
      if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">!         return throwVMError(exec, scope, &quot;Expected first argument to a uint32&quot;_s);</span>
  
      asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
      return encodedJSUndefined();
  }
  
<span class="line-new-header">--- 2351,11 ---</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue numberOfAsyncPasses = exec-&gt;argument(0);
      if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">!         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
  
      asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
      return encodedJSUndefined();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2304,25 ***</span>
  static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!Options::useWebAssembly())</span>
          return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
  
      if (JSObject* object = exec-&gt;argument(0).getObject()) {
          if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<span class="line-modified">!             return JSValue::encode(jsString(&amp;vm, makeString(memory-&gt;memory().mode())));</span>
          if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<span class="line-modified">!             return JSValue::encode(jsString(&amp;vm, makeString(instance-&gt;memoryMode())));</span>
      }
  
      return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
  }
  
  #endif // ENABLE(WEBASSEMBLY)
  
  // Use SEH for Release builds only to get rid of the crash report dialog
  // (luckily the same tests fail in Release and Debug builds so far). Need to
  // be in a separate main function because the jscmain function requires object
  // unwinding.
  
<span class="line-new-header">--- 2370,38 ---</span>
  static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!Wasm::isSupported())</span>
          return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
  
      if (JSObject* object = exec-&gt;argument(0).getObject()) {
          if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<span class="line-modified">!             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));</span>
          if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<span class="line-modified">!             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));</span>
      }
  
      return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
  }
  
  #endif // ENABLE(WEBASSEMBLY)
  
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     JSObject* object = exec-&gt;argument(0).getObject();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!object || !object-&gt;isFunction(vm))</span>
<span class="line-added">+         return throwVMTypeError(exec, scope);</span>
<span class="line-added">+ </span>
<span class="line-added">+     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
<span class="line-added">+     return JSValue::encode(jsUndefined());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Use SEH for Release builds only to get rid of the crash report dialog
  // (luckily the same tests fail in Release and Debug builds so far). Need to
  // be in a separate main function because the jscmain function requires object
  // unwinding.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2429,17 ***</span>
      if (expectedCString)
          printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
      else
          printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
  
<span class="line-modified">!     Identifier nameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;name&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier fileNameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;sourceURL&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier lineNumberID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;line&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier stackID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;stack&quot;);</span>
      CHECK_EXCEPTION();
  
      JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
      CHECK_EXCEPTION();
      JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
<span class="line-new-header">--- 2508,17 ---</span>
      if (expectedCString)
          printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
      else
          printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
  
<span class="line-modified">!     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);</span>
      CHECK_EXCEPTION();
  
      JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
      CHECK_EXCEPTION();
      JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2475,11 ***</span>
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
      ExecState* exec = globalObject-&gt;globalExec();
<span class="line-modified">!     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(exec, expectedExceptionName));</span>
      if (!exceptionClass.isObject() || scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
<span class="line-new-header">--- 2554,11 ---</span>
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
      ExecState* exec = globalObject-&gt;globalExec();
<span class="line-modified">!     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
      if (!exceptionClass.isObject() || scope.exception()) {
          printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2620,11 ***</span>
              shouldQuit = !line;
              if (!line)
                  break;
              source = source + String::fromUTF8(line);
              source = source + &#39;\n&#39;;
<span class="line-modified">!             checkSyntax(vm, makeSource(source, sourceOrigin), error);</span>
              if (!line[0]) {
                  free(line);
                  break;
              }
              add_history(line);
<span class="line-new-header">--- 2699,11 ---</span>
              shouldQuit = !line;
              if (!line)
                  break;
              source = source + String::fromUTF8(line);
              source = source + &#39;\n&#39;;
<span class="line-modified">!             checkSyntax(vm, jscSource(source, sourceOrigin), error);</span>
              if (!line[0]) {
                  free(line);
                  break;
              }
              add_history(line);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2636,11 ***</span>
              continue;
          }
  
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), makeSource(source, sourceOrigin), JSValue(), evaluationException);</span>
  #else
          printf(&quot;%s&quot;, interactivePrompt);
          Vector&lt;char, 256&gt; line;
          int c;
          while ((c = getchar()) != EOF) {
<span class="line-new-header">--- 2715,11 ---</span>
              continue;
          }
  
  
          NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
  #else
          printf(&quot;%s&quot;, interactivePrompt);
          Vector&lt;char, 256&gt; line;
          int c;
          while ((c = getchar()) != EOF) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2690,10 ***</span>
<span class="line-new-header">--- 2769,11 ---</span>
      fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
      fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
      fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
      fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
      fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
<span class="line-added">+     fprintf(stderr, &quot;  --destroy-vm               Destroy VM before exiting\n&quot;);</span>
      fprintf(stderr, &quot;\n&quot;);
      fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
      fprintf(stderr, &quot;\n&quot;);
  
      jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2798,10 ***</span>
<span class="line-new-header">--- 2878,14 ---</span>
              JSC::Options::useSamplingProfiler() = true;
              JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
              m_dumpSamplingProfilerData = true;
              continue;
          }
<span class="line-added">+         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {</span>
<span class="line-added">+             m_destroyVM = true;</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
  
          static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
          static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
          if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
              const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2899,11 ***</span>
      GlobalObject* globalObject = nullptr;
      {
          JSLockHolder locker(vm);
  
          if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<span class="line-modified">!             vm.m_perBytecodeProfiler = std::make_unique&lt;Profiler::Database&gt;(vm);</span>
  
          globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
          globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
          func(vm, globalObject, success);
          vm.drainMicrotasks();
<span class="line-new-header">--- 2983,11 ---</span>
      GlobalObject* globalObject = nullptr;
      {
          JSLockHolder locker(vm);
  
          if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<span class="line-modified">!             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);</span>
  
          globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
          globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
          func(vm, globalObject, success);
          vm.drainMicrotasks();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2971,11 ***</span>
  #endif
      }
  
      vm.codeCache()-&gt;write(vm);
  
<span class="line-modified">!     if (isWorker) {</span>
          JSLockHolder locker(vm);
          // This is needed because we don&#39;t want the worker&#39;s main
          // thread to die before its compilation threads finish.
          vm.deref();
      }
<span class="line-new-header">--- 3055,11 ---</span>
  #endif
      }
  
      vm.codeCache()-&gt;write(vm);
  
<span class="line-modified">!     if (options.m_destroyVM || isWorker) {</span>
          JSLockHolder locker(vm);
          // This is needed because we don&#39;t want the worker&#39;s main
          // thread to die before its compilation threads finish.
          vm.deref();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2986,18 ***</span>
  int jscmain(int argc, char** argv)
  {
      // Need to override and enable restricted options before we start parsing options below.
      Options::enableRestrictedOptions(true);
  
      // Note that the options parsing can affect VM creation, and thus
      // comes first.
      CommandLine options(argc, argv);
  
      processConfigFile(Options::configFile(), &quot;jsc&quot;);
  
      // Initialize JSC before getting VM.
<span class="line-removed">-     WTF::initializeMainThread();</span>
      JSC::initializeThreading();
      startTimeoutThreadIfNeeded();
  #if ENABLE(WEBASSEMBLY)
      JSC::Wasm::enableFastMemory();
  #endif
<span class="line-new-header">--- 3070,19 ---</span>
  int jscmain(int argc, char** argv)
  {
      // Need to override and enable restricted options before we start parsing options below.
      Options::enableRestrictedOptions(true);
  
<span class="line-added">+     WTF::initializeMainThread();</span>
<span class="line-added">+ </span>
      // Note that the options parsing can affect VM creation, and thus
      // comes first.
      CommandLine options(argc, argv);
  
      processConfigFile(Options::configFile(), &quot;jsc&quot;);
  
      // Initialize JSC before getting VM.
      JSC::initializeThreading();
      startTimeoutThreadIfNeeded();
  #if ENABLE(WEBASSEMBLY)
      JSC::Wasm::enableFastMemory();
  #endif
</pre>
<center><a href="jit/ThunkGenerators.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>