<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeMac.mm</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #import &quot;config.h&quot;
  21 #import &quot;RenderThemeMac.h&quot;
  22 
  23 #if PLATFORM(MAC)
  24 
  25 #import &quot;BitmapImage.h&quot;
  26 #import &quot;CSSValueKeywords.h&quot;
  27 #import &quot;CSSValueList.h&quot;
  28 #import &quot;Color.h&quot;
  29 #import &quot;ColorMac.h&quot;
  30 #import &quot;Document.h&quot;
  31 #import &quot;Element.h&quot;
  32 #import &quot;FileList.h&quot;
  33 #import &quot;FloatRoundedRect.h&quot;
  34 #import &quot;FocusController.h&quot;
  35 #import &quot;Frame.h&quot;
  36 #import &quot;FrameSelection.h&quot;
  37 #import &quot;FrameView.h&quot;
  38 #import &quot;GeometryUtilities.h&quot;
  39 #import &quot;GraphicsContext.h&quot;
  40 #import &quot;HTMLAttachmentElement.h&quot;
  41 #import &quot;HTMLInputElement.h&quot;
  42 #import &quot;HTMLMediaElement.h&quot;
  43 #import &quot;HTMLNames.h&quot;
  44 #import &quot;HTMLPlugInImageElement.h&quot;
  45 #import &quot;Icon.h&quot;
  46 #import &quot;Image.h&quot;
  47 #import &quot;ImageBuffer.h&quot;
  48 #import &quot;LocalCurrentGraphicsContext.h&quot;
  49 #import &quot;LocalDefaultSystemAppearance.h&quot;
  50 #import &quot;LocalizedStrings.h&quot;
  51 #import &quot;MediaControlElements.h&quot;
  52 #import &quot;Page.h&quot;
  53 #import &quot;PaintInfo.h&quot;
  54 #import &quot;PathUtilities.h&quot;
  55 #import &quot;RenderAttachment.h&quot;
  56 #import &quot;RenderLayer.h&quot;
  57 #import &quot;RenderMedia.h&quot;
  58 #import &quot;RenderMediaControlElements.h&quot;
  59 #import &quot;RenderProgress.h&quot;
  60 #import &quot;RenderSlider.h&quot;
  61 #import &quot;RenderSnapshottedPlugIn.h&quot;
  62 #import &quot;RenderView.h&quot;
  63 #import &quot;RuntimeEnabledFeatures.h&quot;
  64 #import &quot;SharedBuffer.h&quot;
  65 #import &quot;StringTruncator.h&quot;
  66 #import &quot;StyleResolver.h&quot;
  67 #import &quot;ThemeMac.h&quot;
  68 #import &quot;TimeRanges.h&quot;
  69 #import &quot;UTIUtilities.h&quot;
  70 #import &quot;UserAgentScripts.h&quot;
  71 #import &quot;UserAgentStyleSheets.h&quot;
  72 #import &lt;Carbon/Carbon.h&gt;
  73 #import &lt;Cocoa/Cocoa.h&gt;
  74 #import &lt;CoreServices/CoreServices.h&gt;
  75 #import &lt;math.h&gt;
  76 #import &lt;pal/spi/cg/CoreGraphicsSPI.h&gt;
  77 #import &lt;pal/spi/cocoa/NSColorSPI.h&gt;
  78 #import &lt;pal/spi/mac/NSCellSPI.h&gt;
  79 #import &lt;pal/spi/mac/NSSharingServicePickerSPI.h&gt;
  80 #import &lt;wtf/MathExtras.h&gt;
  81 #import &lt;wtf/ObjCRuntimeExtras.h&gt;
  82 #import &lt;wtf/RetainPtr.h&gt;
  83 #import &lt;wtf/StdLibExtras.h&gt;
  84 #import &lt;wtf/text/StringBuilder.h&gt;
  85 
  86 #if ENABLE(METER_ELEMENT)
  87 #import &quot;RenderMeter.h&quot;
  88 #import &quot;HTMLMeterElement.h&quot;
  89 #endif
  90 
  91 #if ENABLE(SERVICE_CONTROLS)
  92 
  93 // FIXME: This should go into an SPI.h file in the spi directory.
  94 #if USE(APPLE_INTERNAL_SDK)
  95 #import &lt;AppKit/AppKitDefines_Private.h&gt;
  96 #import &lt;AppKit/NSServicesRolloverButtonCell.h&gt;
  97 #else
  98 #define APPKIT_PRIVATE_CLASS
  99 @interface NSServicesRolloverButtonCell : NSButtonCell
 100 @end
 101 #endif
 102 
 103 // FIXME: This should go into an SPI.h file in the spi directory.
 104 @interface NSServicesRolloverButtonCell ()
 105 + (NSServicesRolloverButtonCell *)serviceRolloverButtonCellForStyle:(NSSharingServicePickerStyle)style;
 106 - (NSRect)rectForBounds:(NSRect)bounds preferredEdge:(NSRectEdge)preferredEdge;
 107 @end
 108 
 109 #endif // ENABLE(SERVICE_CONTROLS)
 110 
 111 // FIXME: This should go into an SPI.h file in the spi directory.
 112 @interface NSTextFieldCell ()
 113 - (CFDictionaryRef)_coreUIDrawOptionsWithFrame:(NSRect)cellFrame inView:(NSView *)controlView includeFocus:(BOOL)includeFocus;
 114 - (CFDictionaryRef)_coreUIDrawOptionsWithFrame:(NSRect)cellFrame inView:(NSView *)controlView includeFocus:(BOOL)includeFocus maskOnly:(BOOL)maskOnly;
 115 @end
 116 
 117 // FIXME: This should go into an SPI.h file in the spi directory.
 118 @interface NSSearchFieldCell ()
 119 @property (getter=isCenteredLook) BOOL centeredLook;
 120 @end
 121 
 122 static const Seconds progressAnimationFrameRate = 33_ms; // 30 fps
 123 static const double progressAnimationNumFrames = 256;
 124 
 125 @interface WebCoreRenderThemeNotificationObserver : NSObject
 126 @end
 127 
 128 @implementation WebCoreRenderThemeNotificationObserver
 129 
 130 - (id)init
 131 {
 132     self = [super init];
 133     if (!self)
 134         return nil;
 135 
 136     [[NSNotificationCenter defaultCenter] addObserver:self
 137         selector:@selector(systemColorsDidChange:) name:NSSystemColorsDidChangeNotification object:nil];
 138 
 139     [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self
 140         selector:@selector(systemColorsDidChange:) name:NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification object:nil];
 141 
 142     return self;
 143 }
 144 
 145 - (void)systemColorsDidChange:(NSNotification *)notification
 146 {
 147     UNUSED_PARAM(notification);
 148     WebCore::RenderTheme::singleton().platformColorsDidChange();
 149 }
 150 
 151 @end
 152 
 153 @interface WebCoreTextFieldCell : NSTextFieldCell
 154 @end
 155 
 156 @implementation WebCoreTextFieldCell
 157 
 158 - (CFDictionaryRef)_adjustedCoreUIDrawOptionsForDrawingBordersOnly:(CFDictionaryRef)defaultOptions
 159 {
 160 #if HAVE(OS_DARK_MODE_SUPPORT)
 161     // Dark mode controls don&#39;t have borders, just a semi-transparent background of shadows.
 162     // In the dark mode case we can&#39;t disable borders, or we will not paint anything for the control.
 163     NSAppearanceName appearance = [self.controlView.effectiveAppearance bestMatchFromAppearancesWithNames:@[ NSAppearanceNameAqua, NSAppearanceNameDarkAqua ]];
 164     if ([appearance isEqualToString:NSAppearanceNameDarkAqua])
 165         return defaultOptions;
 166 #endif
 167 
 168     // FIXME: This is a workaround for &lt;rdar://problem/11385461&gt;. When that bug is resolved, we should remove this code,
 169     // as well as the internal method overrides below.
 170     CFMutableDictionaryRef coreUIDrawOptions = CFDictionaryCreateMutableCopy(NULL, 0, defaultOptions);
 171     CFDictionarySetValue(coreUIDrawOptions, CFSTR(&quot;borders only&quot;), kCFBooleanTrue);
 172     CFAutorelease(coreUIDrawOptions);
 173     return coreUIDrawOptions;
 174 }
 175 
 176 - (CFDictionaryRef)_coreUIDrawOptionsWithFrame:(NSRect)cellFrame inView:(NSView *)controlView includeFocus:(BOOL)includeFocus
 177 {
 178     return [self _adjustedCoreUIDrawOptionsForDrawingBordersOnly:[super _coreUIDrawOptionsWithFrame:cellFrame inView:controlView includeFocus:includeFocus]];
 179 }
 180 
 181 - (CFDictionaryRef)_coreUIDrawOptionsWithFrame:(NSRect)cellFrame inView:(NSView *)controlView includeFocus:(BOOL)includeFocus maskOnly:(BOOL)maskOnly
 182 {
 183     return [self _adjustedCoreUIDrawOptionsForDrawingBordersOnly:[super _coreUIDrawOptionsWithFrame:cellFrame inView:controlView includeFocus:includeFocus maskOnly:maskOnly]];
 184 }
 185 
 186 @end
 187 
 188 @interface WebCoreRenderThemeBundle : NSObject
 189 @end
 190 
 191 @implementation WebCoreRenderThemeBundle
 192 @end
 193 
 194 #if ENABLE(DATALIST_ELEMENT)
 195 
 196 static const CGFloat listButtonWidth = 16.0f;
 197 static const CGFloat listButtonCornerRadius = 5.0f;
 198 
 199 @interface WebListButtonCell : NSCell
 200 @end
 201 
 202 @implementation WebListButtonCell
 203 - (void)drawWithFrame:(NSRect)cellFrame inView:(__unused NSView *)controlView
 204 {
 205     CGFloat listButtonCornerRadius = 5.0f;
 206     NSPoint topLeft = NSMakePoint(NSMinX(cellFrame), NSMinY(cellFrame));
 207     NSPoint topRight = NSMakePoint(NSMaxX(cellFrame), NSMinY(cellFrame));
 208     NSPoint bottomRight = NSMakePoint(NSMaxX(cellFrame), NSMaxY(cellFrame));
 209     NSPoint bottomLeft = NSMakePoint(NSMinX(cellFrame), NSMaxY(cellFrame));
 210 
 211     NSBezierPath *path = [NSBezierPath bezierPath];
 212     [path moveToPoint:topLeft];
 213 
 214     [path lineToPoint:NSMakePoint(topRight.x - listButtonCornerRadius, topRight.y)];
 215     [path curveToPoint:NSMakePoint(topRight.x, topRight.y + listButtonCornerRadius) controlPoint1:topRight controlPoint2:topRight];
 216 
 217     [path lineToPoint:NSMakePoint(bottomRight.x, bottomRight.y - listButtonCornerRadius)];
 218     [path curveToPoint:NSMakePoint(bottomRight.x - listButtonCornerRadius, bottomRight.y) controlPoint1:bottomRight controlPoint2:bottomRight];
 219 
 220     [path lineToPoint:bottomLeft];
 221     [path lineToPoint:topLeft];
 222 
 223     if ([self userInterfaceLayoutDirection] == NSUserInterfaceLayoutDirectionRightToLeft) {
 224         NSAffineTransform *transform = [NSAffineTransform transform];
 225         [transform translateXBy:NSMidX(cellFrame) yBy:NSMidY(cellFrame)];
 226         [transform rotateByDegrees:180];
 227         [transform translateXBy:-1 * NSMidX(cellFrame) yBy:-1 * NSMidY(cellFrame)];
 228         [path transformUsingAffineTransform:transform];
 229     }
 230 
 231     // FIXME: Obtain the gradient colors from CoreUI or AppKit
 232     RetainPtr&lt;NSGradient&gt; gradient;
 233 #if HAVE(OS_DARK_MODE_SUPPORT)
 234     NSUserAccentColor accentColor = NSColorGetUserAccentColor();
 235     if (accentColor == NSUserAccentColorRed)
 236         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(212.0 / 255) green:(122.0 / 255) blue:(117.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(189.0 / 255) green:(34.0 / 255) blue:(23.0 / 255) alpha:1.0]]);
 237     else if (accentColor == NSUserAccentColorOrange)
 238         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(242.0 / 255) green:(185.0 / 255) blue:(113.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(242.0 / 255) green:(145.0 / 255) blue:(17.0 / 255) alpha:1.0]]);
 239     else if (accentColor == NSUserAccentColorYellow)
 240         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(241.0 / 255) green:(212.0 / 255) blue:(119.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(239.0 / 255) green:(193.0 / 255) blue:(27.0 / 255) alpha:1.0]]);
 241     else if (accentColor == NSUserAccentColorGreen)
 242         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(132.0 / 255) green:(186.0 / 255) blue:(120.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(46.0 / 255) green:(145.0 / 255) blue:(30.0 / 255) alpha:1.0]]);
 243     else if (accentColor == NSUserAccentColorPurple)
 244         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(178.0 / 255) green:(128.0 / 255) blue:(175.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(130.0 / 255) green:(43.0 / 255) blue:(123.0 / 255) alpha:1.0]]);
 245     else if (accentColor == NSUserAccentColorPink)
 246         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(225.0 / 255) green:(126.0 / 255) blue:(165.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(211.0 / 255) green:(42.0 / 255) blue:(105.0 / 255) alpha:1.0]]);
 247     else if (accentColor == NSUserAccentColorNoColor)
 248         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(177.0 / 255) green:(177.0 / 255) blue:(182.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(145.0 / 255) green:(145.0 / 255) blue:(150.0 / 255) alpha:1.0]]);
 249     else
 250 #endif
 251         gradient = adoptNS([[NSGradient alloc] initWithStartingColor:[NSColor colorWithRed:(114.0 / 255) green:(164.0 / 255) blue:(243.0 / 255) alpha:1.0] endingColor:[NSColor colorWithRed:(45.0 / 255) green:(117.0 / 255) blue:(246.0 / 255) alpha:1.0]]);
 252 
 253     [gradient drawInBezierPath:path angle:90];
 254     if ([self isHighlighted]) {
 255         NSColor *overlay = [NSColor colorWithWhite:0 alpha:0.1];
 256         [overlay setFill];
 257         [path fill];
 258     }
 259 }
 260 @end
 261 
 262 #endif // ENABLE(DATALIST_ELEMENT)
 263 
 264 namespace WebCore {
 265 
 266 using namespace HTMLNames;
 267 
 268 enum {
 269     topMargin,
 270     rightMargin,
 271     bottomMargin,
 272     leftMargin
 273 };
 274 
 275 enum {
 276     topPadding,
 277     rightPadding,
 278     bottomPadding,
 279     leftPadding
 280 };
 281 
 282 RenderTheme&amp; RenderTheme::singleton()
 283 {
 284     static NeverDestroyed&lt;RenderThemeMac&gt; theme;
 285     return theme;
 286 }
 287 
 288 RenderThemeMac::RenderThemeMac()
 289     : m_notificationObserver(adoptNS([[WebCoreRenderThemeNotificationObserver alloc] init]))
 290 {
 291 }
 292 
 293 NSView *RenderThemeMac::documentViewFor(const RenderObject&amp; o) const
 294 {
 295     LocalDefaultSystemAppearance localAppearance(o.useDarkAppearance());
 296     ControlStates states(extractControlStatesForRenderer(o));
 297     return ThemeMac::ensuredView(&amp;o.view().frameView(), states);
 298 }
 299 
 300 #if ENABLE(VIDEO)
 301 
 302 String RenderThemeMac::mediaControlsStyleSheet()
 303 {
 304 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 305     if (m_legacyMediaControlsStyleSheet.isEmpty())
 306         m_legacyMediaControlsStyleSheet = [NSString stringWithContentsOfFile:[[NSBundle bundleForClass:[WebCoreRenderThemeBundle class]] pathForResource:@&quot;mediaControlsApple&quot; ofType:@&quot;css&quot;] encoding:NSUTF8StringEncoding error:nil];
 307     return m_legacyMediaControlsStyleSheet;
 308 #else
 309     return emptyString();
 310 #endif
 311 }
 312 
 313 String RenderThemeMac::modernMediaControlsStyleSheet()
 314 {
 315 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 316     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled()) {
 317         if (m_mediaControlsStyleSheet.isEmpty())
 318             m_mediaControlsStyleSheet = [NSString stringWithContentsOfFile:[[NSBundle bundleForClass:[WebCoreRenderThemeBundle class]] pathForResource:@&quot;modern-media-controls&quot; ofType:@&quot;css&quot; inDirectory:@&quot;modern-media-controls&quot;] encoding:NSUTF8StringEncoding error:nil];
 319         return m_mediaControlsStyleSheet;
 320     }
 321     return emptyString();
 322 #else
 323     return emptyString();
 324 #endif
 325 }
 326 
 327 void RenderThemeMac::purgeCaches()
 328 {
 329     m_legacyMediaControlsScript.clearImplIfNotShared();
 330     m_mediaControlsScript.clearImplIfNotShared();
 331     m_legacyMediaControlsStyleSheet.clearImplIfNotShared();
 332     m_mediaControlsStyleSheet.clearImplIfNotShared();
 333 
 334     RenderTheme::purgeCaches();
 335 }
 336 
 337 String RenderThemeMac::mediaControlsScript()
 338 {
 339 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 340     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled()) {
 341         if (m_mediaControlsScript.isEmpty()) {
 342             NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
 343             NSString *localizedStrings = [NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;modern-media-controls-localized-strings&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
 344             NSString *script = [NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;modern-media-controls&quot; ofType:@&quot;js&quot; inDirectory:@&quot;modern-media-controls&quot;] encoding:NSUTF8StringEncoding error:nil];
 345             m_mediaControlsScript = makeString(String { localizedStrings }, String { script });
 346         }
 347         return m_mediaControlsScript;
 348     }
 349 
 350     if (m_legacyMediaControlsScript.isEmpty()) {
 351         NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
 352         NSString *localizedStrings = [NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;mediaControlsLocalizedStrings&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
 353         NSString *script = [NSString stringWithContentsOfFile:[bundle pathForResource:@&quot;mediaControlsApple&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
 354         m_legacyMediaControlsScript = makeString(String { localizedStrings }, String { script });
 355     }
 356     return m_legacyMediaControlsScript;
 357 #else
 358     return emptyString();
 359 #endif
 360 }
 361 
 362 String RenderThemeMac::mediaControlsBase64StringForIconNameAndType(const String&amp; iconName, const String&amp; iconType)
 363 {
 364 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 365     if (!RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
 366         return emptyString();
 367 
 368     NSString *directory = @&quot;modern-media-controls/images&quot;;
 369     NSBundle *bundle = [NSBundle bundleForClass:[WebCoreRenderThemeBundle class]];
 370     return [[NSData dataWithContentsOfFile:[bundle pathForResource:iconName ofType:iconType inDirectory:directory]] base64EncodedStringWithOptions:0];
 371 #else
 372     return emptyString();
 373 #endif
 374 }
 375 
 376 #endif // ENABLE(VIDEO)
 377 
 378 #if ENABLE(SERVICE_CONTROLS)
 379 
 380 String RenderThemeMac::imageControlsStyleSheet() const
 381 {
 382     return String(imageControlsMacUserAgentStyleSheet, sizeof(imageControlsMacUserAgentStyleSheet));
 383 }
 384 
 385 #endif
 386 
 387 Color RenderThemeMac::platformActiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 388 {
 389     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 390     return colorFromNSColor([NSColor selectedTextBackgroundColor]);
 391 }
 392 
 393 Color RenderThemeMac::platformInactiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 394 {
 395 #if HAVE(OS_DARK_MODE_SUPPORT)
 396     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 397     return colorFromNSColor([NSColor unemphasizedSelectedTextBackgroundColor]);
 398 #else
 399     UNUSED_PARAM(options);
 400     return colorFromNSColor([NSColor secondarySelectedControlColor]);
 401 #endif
 402 }
 403 
 404 Color RenderThemeMac::transformSelectionBackgroundColor(const Color&amp; color, OptionSet&lt;StyleColor::Options&gt; options) const
 405 {
 406     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 407     if (localAppearance.usingDarkAppearance()) {
 408         // Use an alpha value that is similar to results from blendWithWhite() on light colors.
 409         static const float darkAppearanceAlpha = 0.8;
 410         return !color.isOpaque() ? color : color.colorWithAlpha(darkAppearanceAlpha);
 411     }
 412 
 413     return RenderTheme::transformSelectionBackgroundColor(color, options);
 414 }
 415 
 416 bool RenderThemeMac::supportsSelectionForegroundColors(OptionSet&lt;StyleColor::Options&gt; options) const
 417 {
 418     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 419     return localAppearance.usingDarkAppearance();
 420 }
 421 
 422 Color RenderThemeMac::platformActiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 423 {
 424     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 425     if (localAppearance.usingDarkAppearance())
 426         return colorFromNSColor([NSColor selectedTextColor]);
 427     return { };
 428 }
 429 
 430 Color RenderThemeMac::platformInactiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 431 {
 432 #if HAVE(OS_DARK_MODE_SUPPORT)
 433     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 434     if (localAppearance.usingDarkAppearance())
 435         return colorFromNSColor([NSColor unemphasizedSelectedTextColor]);
 436     return { };
 437 #else
 438     UNUSED_PARAM(options);
 439     return { };
 440 #endif
 441 }
 442 
 443 Color RenderThemeMac::platformActiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 444 {
 445 #if HAVE(OS_DARK_MODE_SUPPORT)
 446     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 447     return colorFromNSColor([NSColor selectedContentBackgroundColor]);
 448 #else
 449     UNUSED_PARAM(options);
 450     return colorFromNSColor([NSColor alternateSelectedControlColor]);
 451 #endif
 452 }
 453 
 454 Color RenderThemeMac::platformInactiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 455 {
 456 #if HAVE(OS_DARK_MODE_SUPPORT)
 457     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 458     return colorFromNSColor([NSColor unemphasizedSelectedContentBackgroundColor]);
 459 #else
 460     UNUSED_PARAM(options);
 461     return colorFromNSColor([NSColor secondarySelectedControlColor]);
 462 #endif
 463 }
 464 
 465 Color RenderThemeMac::platformActiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 466 {
 467     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 468     return colorFromNSColor([NSColor alternateSelectedControlTextColor]);
 469 }
 470 
 471 Color RenderThemeMac::platformInactiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 472 {
 473 #if HAVE(OS_DARK_MODE_SUPPORT)
 474     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 475     return colorFromNSColor([NSColor unemphasizedSelectedTextColor]);
 476 #else
 477     UNUSED_PARAM(options);
 478     return colorFromNSColor([NSColor selectedControlTextColor]);
 479 #endif
 480 }
 481 
 482 Color RenderThemeMac::platformFocusRingColor(OptionSet&lt;StyleColor::Options&gt; options) const
 483 {
 484     if (usesTestModeFocusRingColor())
 485         return oldAquaFocusRingColor();
 486     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 487     // The color is expected to be opaque, since CoreGraphics will apply opacity when drawing (because opacity is normally animated).
 488     return colorWithOverrideAlpha(colorFromNSColor([NSColor keyboardFocusIndicatorColor]).rgb(), 1);
 489 }
 490 
 491 Color RenderThemeMac::platformActiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
 492 {
 493     LocalDefaultSystemAppearance localAppearance(options.contains(StyleColor::Options::UseDarkAppearance));
 494     return colorFromNSColor([NSColor findHighlightColor]);
 495 }
 496 
 497 Color RenderThemeMac::platformInactiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
 498 {
 499     // The inactive color is normally used, since no legacy WebKit client marks a text match as active.
 500     // So just return the same color for both states.
 501     return platformActiveTextSearchHighlightColor(options);
 502 }
 503 
 504 static FontSelectionValue toFontWeight(NSInteger appKitFontWeight)
 505 {
 506     ASSERT(appKitFontWeight &gt; 0 &amp;&amp; appKitFontWeight &lt; 15);
 507     if (appKitFontWeight &gt; 14)
 508         appKitFontWeight = 14;
 509     else if (appKitFontWeight &lt; 1)
 510         appKitFontWeight = 1;
 511 
 512     static const FontSelectionValue fontWeights[] = {
 513         FontSelectionValue(100),
 514         FontSelectionValue(100),
 515         FontSelectionValue(200),
 516         FontSelectionValue(300),
 517         FontSelectionValue(400),
 518         FontSelectionValue(500),
 519         FontSelectionValue(600),
 520         FontSelectionValue(600),
 521         FontSelectionValue(700),
 522         FontSelectionValue(800),
 523         FontSelectionValue(800),
 524         FontSelectionValue(900),
 525         FontSelectionValue(900),
 526         FontSelectionValue(900)
 527     };
 528     return fontWeights[appKitFontWeight - 1];
 529 }
 530 
 531 void RenderThemeMac::updateCachedSystemFontDescription(CSSValueID cssValueId, FontCascadeDescription&amp; fontDescription) const
 532 {
 533     NSFont* font;
 534     // System-font-ness can&#39;t be encapsulated by simply a font name. Instead, we must use a token
 535     // which FontCache will look for.
 536     // Make sure we keep this list of possible tokens in sync with FontCascade::primaryFontIsSystemFont()
 537     AtomString fontName;
 538     switch (cssValueId) {
 539         case CSSValueSmallCaption:
 540             font = [NSFont systemFontOfSize:[NSFont smallSystemFontSize]];
 541             break;
 542         case CSSValueMenu:
 543             font = [NSFont menuFontOfSize:[NSFont systemFontSize]];
 544             fontName = AtomString(&quot;-apple-menu&quot;, AtomString::ConstructFromLiteral);
 545             break;
 546         case CSSValueStatusBar:
 547             font = [NSFont labelFontOfSize:[NSFont labelFontSize]];
 548             fontName = AtomString(&quot;-apple-status-bar&quot;, AtomString::ConstructFromLiteral);
 549             break;
 550         case CSSValueWebkitMiniControl:
 551             font = [NSFont systemFontOfSize:[NSFont systemFontSizeForControlSize:NSControlSizeMini]];
 552             break;
 553         case CSSValueWebkitSmallControl:
 554             font = [NSFont systemFontOfSize:[NSFont systemFontSizeForControlSize:NSControlSizeSmall]];
 555             break;
 556         case CSSValueWebkitControl:
 557             font = [NSFont systemFontOfSize:[NSFont systemFontSizeForControlSize:NSControlSizeRegular]];
 558             break;
 559         default:
 560             font = [NSFont systemFontOfSize:[NSFont systemFontSize]];
 561     }
 562 
 563     if (!font)
 564         return;
 565 
 566     if (fontName.isNull())
 567         fontName = AtomString(&quot;system-ui&quot;, AtomString::ConstructFromLiteral);
 568 
 569     NSFontManager *fontManager = [NSFontManager sharedFontManager];
 570     fontDescription.setIsAbsoluteSize(true);
 571     fontDescription.setOneFamily(fontName);
 572     fontDescription.setSpecifiedSize([font pointSize]);
 573     fontDescription.setWeight(toFontWeight([fontManager weightOfFont:font]));
 574     fontDescription.setIsItalic([fontManager traitsOfFont:font] &amp; NSItalicFontMask);
 575 }
 576 
 577 static RGBA32 menuBackgroundColor()
 578 {
 579     RetainPtr&lt;NSBitmapImageRep&gt; offscreenRep = adoptNS([[NSBitmapImageRep alloc] initWithBitmapDataPlanes:nil pixelsWide:1 pixelsHigh:1
 580         bitsPerSample:8 samplesPerPixel:4 hasAlpha:YES isPlanar:NO colorSpaceName:NSDeviceRGBColorSpace bytesPerRow:4 bitsPerPixel:32]);
 581 
 582     CGContextRef bitmapContext = [NSGraphicsContext graphicsContextWithBitmapImageRep:offscreenRep.get()].CGContext;
 583     const CGRect rect = CGRectMake(0, 0, 1, 1);
 584 
 585     HIThemeMenuDrawInfo drawInfo;
 586     drawInfo.version =  0;
 587     drawInfo.menuType = kThemeMenuTypePopUp;
 588 
 589     HIThemeDrawMenuBackground(&amp;rect, &amp;drawInfo, bitmapContext, kHIThemeOrientationInverted);
 590 
 591     NSUInteger pixel[4];
 592     [offscreenRep getPixel:pixel atX:0 y:0];
 593 
 594     return makeRGBA(pixel[0], pixel[1], pixel[2], pixel[3]);
 595 }
 596 
 597 Color RenderThemeMac::systemColor(CSSValueID cssValueID, OptionSet&lt;StyleColor::Options&gt; options) const
 598 {
 599     const bool useSystemAppearance = options.contains(StyleColor::Options::UseSystemAppearance);
 600     const bool useDarkAppearance = options.contains(StyleColor::Options::UseDarkAppearance);
 601     const bool forVisitedLink = options.contains(StyleColor::Options::ForVisitedLink);
 602 
 603     auto&amp; cache = colorCache(options);
 604 
 605     if (useSystemAppearance) {
 606         // Special handling for links and other system colors when the system appearance is desired.
 607         auto systemAppearanceColor = [useDarkAppearance] (Color&amp; color, SEL selector) -&gt; Color {
 608             if (!color.isValid()) {
 609                 LocalDefaultSystemAppearance localAppearance(useDarkAppearance);
 610                 auto systemColor = wtfObjCMsgSend&lt;NSColor *&gt;([NSColor class], selector);
 611                 color = semanticColorFromNSColor(systemColor);
 612             }
 613 
 614             return color;
 615         };
 616 
 617         switch (cssValueID) {
 618         // Web views that want system appearance get the system version of link colors, which differ from the HTML spec.
 619         case CSSValueWebkitLink:
 620             if (forVisitedLink)
 621                 return systemAppearanceColor(cache.systemVisitedLinkColor, @selector(systemPurpleColor));
 622             return systemAppearanceColor(cache.systemLinkColor, @selector(linkColor));
 623 
 624         case CSSValueWebkitActivelink:
 625             // FIXME: Use a semantic system color for this, instead of systemRedColor. &lt;rdar://problem/39256684&gt;
 626             return systemAppearanceColor(cache.systemActiveLinkColor, @selector(systemRedColor));
 627 
 628         // The following colors would expose user appearance preferences to the web, and could be used for fingerprinting.
 629         // These should only be available when the web view is wanting the system appearance.
 630         case CSSValueWebkitFocusRingColor:
 631         case CSSValueActiveborder:
 632             return focusRingColor(options);
 633 
 634         case CSSValueAppleSystemControlAccent:
 635 #if HAVE(OS_DARK_MODE_SUPPORT)
 636             return systemAppearanceColor(cache.systemControlAccentColor, @selector(controlAccentColor));
 637 #else
 638             return systemAppearanceColor(cache.systemControlAccentColor, @selector(alternateSelectedControlColor));
 639 #endif
 640 
 641         case CSSValueAppleSystemSelectedContentBackground:
 642             return activeListBoxSelectionBackgroundColor(options);
 643 
 644         case CSSValueAppleSystemSelectedTextBackground:
 645         case CSSValueHighlight:
 646             return activeSelectionBackgroundColor(options);
 647 
 648         default:
 649             // Handle other system colors below, that don&#39;t need special system appearance handling.
 650             break;
 651         }
 652     } else if (forVisitedLink &amp;&amp; cssValueID == CSSValueWebkitLink) {
 653         // The system color cache below can&#39;t handle visited links. The only color value
 654         // that cares about visited links is CSSValueWebkitLink, so handle it here.
 655         return RenderTheme::systemColor(cssValueID, options);
 656     }
 657 
 658     ASSERT(!forVisitedLink);
 659 
 660     return cache.systemStyleColors.ensure(cssValueID, [this, cssValueID, options, useDarkAppearance] () -&gt; Color {
 661         LocalDefaultSystemAppearance localAppearance(useDarkAppearance);
 662 
 663         auto selectCocoaColor = [cssValueID] () -&gt; SEL {
 664             switch (cssValueID) {
 665             case CSSValueActivecaption:
 666                 return @selector(windowFrameTextColor);
 667             case CSSValueAppworkspace:
 668                 return @selector(headerColor);
 669             case CSSValueButtonhighlight:
 670                 return @selector(controlHighlightColor);
 671             case CSSValueButtonshadow:
 672                 return @selector(controlShadowColor);
 673             case CSSValueButtontext:
 674                 return @selector(controlTextColor);
 675             case CSSValueCaptiontext:
 676                 return @selector(textColor);
 677             case CSSValueGraytext:
 678                 return @selector(disabledControlTextColor);
 679             case CSSValueHighlighttext:
 680                 return @selector(selectedTextColor);
 681             case CSSValueInactiveborder:
 682                 return @selector(controlBackgroundColor);
 683             case CSSValueInactivecaption:
 684                 return @selector(controlBackgroundColor);
 685             case CSSValueInactivecaptiontext:
 686                 return @selector(textColor);
 687             case CSSValueInfotext:
 688                 return @selector(textColor);
 689             case CSSValueMenutext:
 690                 return @selector(selectedMenuItemTextColor);
 691             case CSSValueScrollbar:
 692                 return @selector(scrollBarColor);
 693             case CSSValueText:
 694                 return @selector(textColor);
 695             case CSSValueThreeddarkshadow:
 696                 return @selector(controlDarkShadowColor);
 697             case CSSValueThreedshadow:
 698                 return @selector(shadowColor);
 699             case CSSValueThreedhighlight:
 700                 return @selector(highlightColor);
 701             case CSSValueThreedlightshadow:
 702                 return @selector(controlLightHighlightColor);
 703             case CSSValueWindow:
 704                 return @selector(windowBackgroundColor);
 705             case CSSValueWindowframe:
 706                 return @selector(windowFrameColor);
 707             case CSSValueWindowtext:
 708                 return @selector(windowFrameTextColor);
 709             case CSSValueAppleSystemHeaderText:
 710                 return @selector(headerTextColor);
 711             case CSSValueAppleSystemBackground:
 712             case CSSValueAppleSystemSecondaryBackground:
 713             case CSSValueAppleSystemTertiaryBackground:
 714             case CSSValueAppleSystemGroupedBackground:
 715             case CSSValueAppleSystemSecondaryGroupedBackground:
 716             case CSSValueAppleSystemTertiaryGroupedBackground:
 717             case CSSValueAppleSystemTextBackground:
 718                 return @selector(textBackgroundColor);
 719             case CSSValueAppleSystemControlBackground:
 720 #if HAVE(OS_DARK_MODE_SUPPORT)
 721             case CSSValueWebkitControlBackground:
 722 #endif
 723                 return @selector(controlBackgroundColor);
 724             case CSSValueAppleSystemAlternateSelectedText:
 725                 return @selector(alternateSelectedControlTextColor);
 726             case CSSValueAppleSystemUnemphasizedSelectedContentBackground:
 727 #if HAVE(OS_DARK_MODE_SUPPORT)
 728                 return @selector(unemphasizedSelectedContentBackgroundColor);
 729 #else
 730                 return @selector(secondarySelectedControlColor);
 731 #endif
 732             case CSSValueAppleSystemSelectedText:
 733                 return @selector(selectedTextColor);
 734             case CSSValueAppleSystemUnemphasizedSelectedText:
 735 #if HAVE(OS_DARK_MODE_SUPPORT)
 736                 return @selector(unemphasizedSelectedTextColor);
 737 #else
 738                 return @selector(textColor);
 739 #endif
 740             case CSSValueAppleSystemUnemphasizedSelectedTextBackground:
 741 #if HAVE(OS_DARK_MODE_SUPPORT)
 742                 return @selector(unemphasizedSelectedTextBackgroundColor);
 743 #else
 744                 return @selector(secondarySelectedControlColor);
 745 #endif
 746             case CSSValueAppleSystemPlaceholderText:
 747                 return @selector(placeholderTextColor);
 748             case CSSValueAppleSystemFindHighlightBackground:
 749                 return @selector(findHighlightColor);
 750             case CSSValueAppleSystemContainerBorder:
 751 #if HAVE(OS_DARK_MODE_SUPPORT)
 752                 return @selector(containerBorderColor);
 753 #else
 754                 // Handled below.
 755                 return nullptr;
 756 #endif
 757             case CSSValueAppleSystemLabel:
 758                 return @selector(labelColor);
 759             case CSSValueAppleSystemSecondaryLabel:
 760                 return @selector(secondaryLabelColor);
 761             case CSSValueAppleSystemTertiaryLabel:
 762                 return @selector(tertiaryLabelColor);
 763             case CSSValueAppleSystemQuaternaryLabel:
 764                 return @selector(quaternaryLabelColor);
 765             case CSSValueAppleSystemGrid:
 766                 return @selector(gridColor);
 767             case CSSValueAppleSystemSeparator:
 768 #if HAVE(OS_DARK_MODE_SUPPORT)
 769                 return @selector(separatorColor);
 770 #else
 771                 return @selector(gridColor);
 772 #endif
 773             case CSSValueAppleWirelessPlaybackTargetActive:
 774             case CSSValueAppleSystemBlue:
 775                 return @selector(systemBlueColor);
 776             case CSSValueAppleSystemBrown:
 777                 return @selector(systemBrownColor);
 778             case CSSValueAppleSystemGray:
 779                 return @selector(systemGrayColor);
 780             case CSSValueAppleSystemGreen:
 781                 return @selector(systemGreenColor);
 782             case CSSValueAppleSystemOrange:
 783                 return @selector(systemOrangeColor);
 784             case CSSValueAppleSystemPink:
 785                 return @selector(systemPinkColor);
 786             case CSSValueAppleSystemPurple:
 787                 return @selector(systemPurpleColor);
 788             case CSSValueAppleSystemRed:
 789                 return @selector(systemRedColor);
 790             case CSSValueAppleSystemYellow:
 791                 return @selector(systemYellowColor);
 792             default:
 793                 return nullptr;
 794             }
 795         };
 796 
 797         if (auto selector = selectCocoaColor()) {
 798             if (auto color = wtfObjCMsgSend&lt;NSColor *&gt;([NSColor class], selector))
 799                 return semanticColorFromNSColor(color);
 800         }
 801 
 802         switch (cssValueID) {
 803         case CSSValueActivebuttontext:
 804             // No corresponding NSColor for this so we use a hard coded value.
 805             return Color::white;
 806 
 807         case CSSValueButtonface:
 808         case CSSValueThreedface:
 809             // We selected this value instead of [NSColor controlColor] to avoid website incompatibilities.
 810             // We may want to consider changing to [NSColor controlColor] some day.
 811             return 0xFFC0C0C0;
 812 
 813         case CSSValueInfobackground:
 814             // No corresponding NSColor for this so we use a hard coded value.
 815             return 0xFFFBFCC5;
 816 
 817         case CSSValueMenu:
 818             return menuBackgroundColor();
 819 
 820         case CSSValueWebkitFocusRingColor:
 821         case CSSValueActiveborder:
 822             // Hardcoded to avoid exposing a user appearance preference to the web for fingerprinting.
 823             if (localAppearance.usingDarkAppearance())
 824                 return Color(0xFF1AA9FF, Color::Semantic);
 825             return Color(0xFF0067F4, Color::Semantic);
 826 
 827         case CSSValueAppleSystemControlAccent:
 828             // Hardcoded to avoid exposing a user appearance preference to the web for fingerprinting.
 829             // Same color in light and dark appearances.
 830             return Color(0xFF007AFF, Color::Semantic);
 831 
 832         case CSSValueAppleSystemSelectedContentBackground:
 833             // Hardcoded to avoid exposing a user appearance preference to the web for fingerprinting.
 834             if (localAppearance.usingDarkAppearance())
 835                 return Color(0xFF0058D0, Color::Semantic);
 836             return Color(0xFF0063E1, Color::Semantic);
 837 
 838         case CSSValueHighlight:
 839         case CSSValueAppleSystemSelectedTextBackground:
 840             // Hardcoded to avoid exposing a user appearance preference to the web for fingerprinting.
 841             if (localAppearance.usingDarkAppearance())
 842                 return Color(0xCC3F638B, Color::Semantic);
 843             return Color(0x9980BCFE, Color::Semantic);
 844 
 845 #if !HAVE(OS_DARK_MODE_SUPPORT)
 846         case CSSValueAppleSystemContainerBorder:
 847             return 0xFFC5C5C5;
 848 #endif
 849 
 850         case CSSValueAppleSystemEvenAlternatingContentBackground: {
 851 #if HAVE(OS_DARK_MODE_SUPPORT)
 852             NSArray&lt;NSColor *&gt; *alternateColors = [NSColor alternatingContentBackgroundColors];
 853 #else
 854             NSArray&lt;NSColor *&gt; *alternateColors = [NSColor controlAlternatingRowBackgroundColors];
 855 #endif
 856             ASSERT(alternateColors.count &gt;= 2);
 857             return semanticColorFromNSColor(alternateColors[0]);
 858         }
 859 
 860         case CSSValueAppleSystemOddAlternatingContentBackground: {
 861 #if HAVE(OS_DARK_MODE_SUPPORT)
 862             NSArray&lt;NSColor *&gt; *alternateColors = [NSColor alternatingContentBackgroundColors];
 863 #else
 864             NSArray&lt;NSColor *&gt; *alternateColors = [NSColor controlAlternatingRowBackgroundColors];
 865 #endif
 866             ASSERT(alternateColors.count &gt;= 2);
 867             return semanticColorFromNSColor(alternateColors[1]);
 868         }
 869 
 870         case CSSValueBackground:
 871             // Use platform-independent value returned by base class.
 872             FALLTHROUGH;
 873 
 874         default:
 875             return RenderTheme::systemColor(cssValueID, options);
 876         }
 877     }).iterator-&gt;value;
 878 }
 879 
 880 bool RenderThemeMac::usesTestModeFocusRingColor() const
 881 {
 882     return WebCore::usesTestModeFocusRingColor();
 883 }
 884 
 885 bool RenderThemeMac::isControlStyled(const RenderStyle&amp; style, const BorderData&amp; border,
 886                                      const FillLayer&amp; background, const Color&amp; backgroundColor) const
 887 {
 888     if (style.appearance() == TextFieldPart || style.appearance() == TextAreaPart || style.appearance() == ListboxPart)
 889         return style.border() != border;
 890 
 891     // FIXME: This is horrible, but there is not much else that can be done.  Menu lists cannot draw properly when
 892     // scaled.  They can&#39;t really draw properly when transformed either.  We can&#39;t detect the transform case at style
 893     // adjustment time so that will just have to stay broken.  We can however detect that we&#39;re zooming.  If zooming
 894     // is in effect we treat it like the control is styled.
 895     if (style.appearance() == MenulistPart &amp;&amp; style.effectiveZoom() != 1.0f)
 896         return true;
 897 
 898     return RenderTheme::isControlStyled(style, border, background, backgroundColor);
 899 }
 900 
 901 static FloatRect inflateRect(const FloatRect&amp; rect, const IntSize&amp; size, const int* margins, float zoomLevel)
 902 {
 903     // Only do the inflation if the available width/height are too small. Otherwise try to
 904     // fit the glow/check space into the available box&#39;s width/height.
 905     int widthDelta = rect.width() - (size.width() + margins[leftMargin] * zoomLevel + margins[rightMargin] * zoomLevel);
 906     int heightDelta = rect.height() - (size.height() + margins[topMargin] * zoomLevel + margins[bottomMargin] * zoomLevel);
 907     FloatRect result(rect);
 908     if (widthDelta &lt; 0) {
 909         result.setX(result.x() - margins[leftMargin] * zoomLevel);
 910         result.setWidth(result.width() - widthDelta);
 911     }
 912     if (heightDelta &lt; 0) {
 913         result.setY(result.y() - margins[topMargin] * zoomLevel);
 914         result.setHeight(result.height() - heightDelta);
 915     }
 916     return result;
 917 }
 918 
 919 void RenderThemeMac::adjustRepaintRect(const RenderObject&amp; renderer, FloatRect&amp; rect)
 920 {
 921     ControlPart part = renderer.style().appearance();
 922 
 923 #if USE(NEW_THEME)
 924     switch (part) {
 925         case CheckboxPart:
 926         case RadioPart:
 927         case PushButtonPart:
 928         case SquareButtonPart:
 929 #if ENABLE(INPUT_TYPE_COLOR)
 930         case ColorWellPart:
 931 #endif
 932         case DefaultButtonPart:
 933         case ButtonPart:
 934         case InnerSpinButtonPart:
 935             return RenderTheme::adjustRepaintRect(renderer, rect);
 936         default:
 937             break;
 938     }
 939 #endif
 940 
 941     float zoomLevel = renderer.style().effectiveZoom();
 942 
 943     if (part == MenulistPart) {
 944         setPopupButtonCellState(renderer, IntSize(rect.size()));
 945         IntSize size = popupButtonSizes()[[popupButton() controlSize]];
 946         size.setHeight(size.height() * zoomLevel);
 947         size.setWidth(rect.width());
 948         rect = inflateRect(rect, size, popupButtonMargins(), zoomLevel);
 949     }
 950 }
 951 
 952 static FloatPoint convertToPaintingPosition(const RenderBox&amp; inputRenderer, const RenderBox&amp; customButtonRenderer, const FloatPoint&amp; customButtonLocalPosition,
 953     const IntPoint&amp; paintOffset)
 954 {
 955     IntPoint offsetFromInputRenderer = roundedIntPoint(customButtonRenderer.localToContainerPoint(customButtonRenderer.contentBoxRect().location(), &amp;inputRenderer));
 956     FloatPoint paintingPosition = customButtonLocalPosition;
 957     paintingPosition.moveBy(-offsetFromInputRenderer);
 958     paintingPosition.moveBy(paintOffset);
 959     return paintingPosition;
 960 }
 961 
 962 void RenderThemeMac::updateCheckedState(NSCell* cell, const RenderObject&amp; o)
 963 {
 964     bool oldIndeterminate = [cell state] == NSControlStateValueMixed;
 965     bool indeterminate = isIndeterminate(o);
 966     bool checked = isChecked(o);
 967 
 968     if (oldIndeterminate != indeterminate) {
 969         [cell setState:indeterminate ? NSControlStateValueMixed : (checked ? NSControlStateValueOn : NSControlStateValueOff)];
 970         return;
 971     }
 972 
 973     bool oldChecked = [cell state] == NSControlStateValueOn;
 974     if (checked != oldChecked)
 975         [cell setState:checked ? NSControlStateValueOn : NSControlStateValueOff];
 976 }
 977 
 978 void RenderThemeMac::updateEnabledState(NSCell* cell, const RenderObject&amp; o)
 979 {
 980     bool oldEnabled = [cell isEnabled];
 981     bool enabled = isEnabled(o);
 982     if (enabled != oldEnabled)
 983         [cell setEnabled:enabled];
 984 }
 985 
 986 void RenderThemeMac::updateFocusedState(NSCell* cell, const RenderObject&amp; o)
 987 {
 988     bool oldFocused = [cell showsFirstResponder];
 989     bool focused = isFocused(o) &amp;&amp; o.style().outlineStyleIsAuto() == OutlineIsAuto::On;
 990     if (focused != oldFocused)
 991         [cell setShowsFirstResponder:focused];
 992 }
 993 
 994 void RenderThemeMac::updatePressedState(NSCell* cell, const RenderObject&amp; o)
 995 {
 996     bool oldPressed = [cell isHighlighted];
 997     bool pressed = is&lt;Element&gt;(o.node()) &amp;&amp; downcast&lt;Element&gt;(*o.node()).active();
 998     if (pressed != oldPressed)
 999         [cell setHighlighted:pressed];
1000 }
1001 
1002 bool RenderThemeMac::controlSupportsTints(const RenderObject&amp; o) const
1003 {
1004     // An alternate way to implement this would be to get the appropriate cell object
1005     // and call the private _needRedrawOnWindowChangedKeyState method. An advantage of
1006     // that would be that we would match AppKit behavior more closely, but a disadvantage
1007     // would be that we would rely on an AppKit SPI method.
1008 
1009     if (!isEnabled(o))
1010         return false;
1011 
1012     // Checkboxes only have tint when checked.
1013     if (o.style().appearance() == CheckboxPart)
1014         return isChecked(o);
1015 
1016     // For now assume other controls have tint if enabled.
1017     return true;
1018 }
1019 
1020 NSControlSize RenderThemeMac::controlSizeForFont(const RenderStyle&amp; style) const
1021 {
1022     int fontSize = style.computedFontPixelSize();
1023     if (fontSize &gt;= 16)
1024         return NSControlSizeRegular;
1025     if (fontSize &gt;= 11)
1026         return NSControlSizeSmall;
1027     return NSControlSizeMini;
1028 }
1029 
1030 NSControlSize RenderThemeMac::controlSizeForCell(NSCell*, const IntSize* sizes, const IntSize&amp; minSize, float zoomLevel) const
1031 {
1032     if (minSize.width() &gt;= static_cast&lt;int&gt;(sizes[NSControlSizeRegular].width() * zoomLevel)
1033         &amp;&amp; minSize.height() &gt;= static_cast&lt;int&gt;(sizes[NSControlSizeRegular].height() * zoomLevel))
1034         return NSControlSizeRegular;
1035 
1036     if (minSize.width() &gt;= static_cast&lt;int&gt;(sizes[NSControlSizeSmall].width() * zoomLevel)
1037         &amp;&amp; minSize.height() &gt;= static_cast&lt;int&gt;(sizes[NSControlSizeSmall].height() * zoomLevel))
1038         return NSControlSizeSmall;
1039 
1040     return NSControlSizeMini;
1041 }
1042 
1043 void RenderThemeMac::setControlSize(NSCell* cell, const IntSize* sizes, const IntSize&amp; minSize, float zoomLevel)
1044 {
1045     NSControlSize size = controlSizeForCell(cell, sizes, minSize, zoomLevel);
1046     if (size != [cell controlSize]) // Only update if we have to, since AppKit does work even if the size is the same.
1047         [cell setControlSize:size];
1048 }
1049 
1050 IntSize RenderThemeMac::sizeForFont(const RenderStyle&amp; style, const IntSize* sizes) const
1051 {
1052     if (style.effectiveZoom() != 1.0f) {
1053         IntSize result = sizes[controlSizeForFont(style)];
1054         return IntSize(result.width() * style.effectiveZoom(), result.height() * style.effectiveZoom());
1055     }
1056     return sizes[controlSizeForFont(style)];
1057 }
1058 
1059 IntSize RenderThemeMac::sizeForSystemFont(const RenderStyle&amp; style, const IntSize* sizes) const
1060 {
1061     if (style.effectiveZoom() != 1.0f) {
1062         IntSize result = sizes[controlSizeForSystemFont(style)];
1063         return IntSize(result.width() * style.effectiveZoom(), result.height() * style.effectiveZoom());
1064     }
1065     return sizes[controlSizeForSystemFont(style)];
1066 }
1067 
1068 void RenderThemeMac::setSizeFromFont(RenderStyle&amp; style, const IntSize* sizes) const
1069 {
1070     // FIXME: Check is flawed, since it doesn&#39;t take min-width/max-width into account.
1071     IntSize size = sizeForFont(style, sizes);
1072     if (style.width().isIntrinsicOrAuto() &amp;&amp; size.width() &gt; 0)
1073         style.setWidth(Length(size.width(), Fixed));
1074     if (style.height().isAuto() &amp;&amp; size.height() &gt; 0)
1075         style.setHeight(Length(size.height(), Fixed));
1076 }
1077 
1078 void RenderThemeMac::setFontFromControlSize(StyleResolver&amp;, RenderStyle&amp; style, NSControlSize controlSize) const
1079 {
1080     FontCascadeDescription fontDescription;
1081     fontDescription.setIsAbsoluteSize(true);
1082 
1083     NSFont* font = [NSFont systemFontOfSize:[NSFont systemFontSizeForControlSize:controlSize]];
1084     fontDescription.setOneFamily(AtomString(&quot;-apple-system&quot;, AtomString::ConstructFromLiteral));
1085     fontDescription.setComputedSize([font pointSize] * style.effectiveZoom());
1086     fontDescription.setSpecifiedSize([font pointSize] * style.effectiveZoom());
1087 
1088     // Reset line height
1089     style.setLineHeight(RenderStyle::initialLineHeight());
1090 
1091     if (style.setFontDescription(WTFMove(fontDescription)))
1092         style.fontCascade().update(0);
1093 }
1094 
1095 NSControlSize RenderThemeMac::controlSizeForSystemFont(const RenderStyle&amp; style) const
1096 {
1097     int fontSize = style.computedFontPixelSize();
1098     if (fontSize &gt;= [NSFont systemFontSizeForControlSize:NSControlSizeRegular])
1099         return NSControlSizeRegular;
1100     if (fontSize &gt;= [NSFont systemFontSizeForControlSize:NSControlSizeSmall])
1101         return NSControlSizeSmall;
1102     return NSControlSizeMini;
1103 }
1104 
1105 #if ENABLE(DATALIST_ELEMENT)
1106 
1107 void RenderThemeMac::paintListButtonForInput(const RenderObject&amp; o, GraphicsContext&amp; context, const FloatRect&amp; r)
1108 {
1109     // We can&#39;t paint an NSComboBoxCell since they are not height-resizable.
1110     const auto&amp; input = downcast&lt;HTMLInputElement&gt;(*(o.generatingNode()));
1111     NSCell *listButton = this-&gt;listButton();
1112 
1113     NSRect listButtonFrame = NSMakeRect(r.maxX() - listButtonWidth, r.y(), listButtonWidth, r.height());
1114     if (!o.style().isLeftToRightDirection()) {
1115         listButtonFrame.origin.x = r.x();
1116         [listButton setUserInterfaceLayoutDirection:NSUserInterfaceLayoutDirectionRightToLeft];
1117     } else
1118         [listButton setUserInterfaceLayoutDirection:NSUserInterfaceLayoutDirectionLeftToRight];
1119 
1120     [listButton setHighlighted:input.isPresentingAttachedView()];
1121     if (!input.isPresentingAttachedView()) {
1122         ASSERT(input.dataListButtonElement());
1123         if (auto* buttonElement = input.dataListButtonElement())
1124             updatePressedState(listButton, *buttonElement-&gt;renderer());
1125     }
1126 
1127     [listButton drawWithFrame:listButtonFrame inView:documentViewFor(o)];
1128     [listButton setControlView:nil];
1129 
1130     RefPtr&lt;Image&gt; image;
1131     float imageScale = 1;
1132     if (o.document().deviceScaleFactor() &gt;= 2) {
1133         image = Image::loadPlatformResource(&quot;ListButtonArrow@2x&quot;);
1134         imageScale = 2;
1135     } else
1136         image = Image::loadPlatformResource(&quot;ListButtonArrow&quot;);
1137 
1138     FloatRect imageRect(0, 0, image-&gt;width() / imageScale, image-&gt;height() / imageScale);
1139     imageRect.setX(NSMidX(listButtonFrame) - imageRect.width() / 2);
1140     imageRect.setY(NSMidY(listButtonFrame) - imageRect.height() / 2);
1141 
1142     context.drawImage(*image, imageRect);
1143 }
1144 
1145 void RenderThemeMac::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1146 {
1147     // Add a margin to place the button at end of the input field.
1148     if (style.isLeftToRightDirection())
1149         style.setMarginRight(Length(-4, Fixed));
1150     else
1151         style.setMarginLeft(Length(-4, Fixed));
1152 }
1153 
1154 #endif
1155 
1156 bool RenderThemeMac::paintTextField(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const FloatRect&amp; r)
1157 {
1158     LocalCurrentGraphicsContext localContext(paintInfo.context());
1159 
1160     // &lt;rdar://problem/22896977&gt; We adjust the paint rect here to account for how AppKit draws the text
1161     // field cell slightly smaller than the rect we pass to drawWithFrame.
1162     FloatRect adjustedPaintRect(r);
1163     AffineTransform transform = paintInfo.context().getCTM();
1164     if (transform.xScale() &gt; 1 || transform.yScale() &gt; 1) {
1165         adjustedPaintRect.inflateX(1 / transform.xScale());
1166 #if __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101400
1167         adjustedPaintRect.inflateY(2 / transform.yScale());
1168         adjustedPaintRect.move(0, -1 / transform.yScale());
1169 #else
1170         adjustedPaintRect.inflateY(1 / transform.yScale());
1171 #endif
1172     }
1173     NSTextFieldCell *textField = this-&gt;textField();
1174 
1175     GraphicsContextStateSaver stateSaver(paintInfo.context());
1176 
1177     [textField setEnabled:(isEnabled(o) &amp;&amp; !isReadOnlyControl(o))];
1178     [textField drawWithFrame:NSRect(adjustedPaintRect) inView:documentViewFor(o)];
1179 
1180     [textField setControlView:nil];
1181 
1182 #if ENABLE(DATALIST_ELEMENT)
1183     if (!is&lt;HTMLInputElement&gt;(o.generatingNode()))
1184         return false;
1185 
1186     const auto&amp; input = downcast&lt;HTMLInputElement&gt;(*(o.generatingNode()));
1187     if (input.list())
1188         paintListButtonForInput(o, paintInfo.context(), adjustedPaintRect);
1189 #endif
1190 
1191     return false;
1192 }
1193 
1194 void RenderThemeMac::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const
1195 {
1196 }
1197 
1198 bool RenderThemeMac::paintTextArea(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const FloatRect&amp; r)
1199 {
1200     LocalCurrentGraphicsContext localContext(paintInfo.context());
1201     _NSDrawCarbonThemeListBox(r, isEnabled(o) &amp;&amp; !isReadOnlyControl(o), YES, YES);
1202     return false;
1203 }
1204 
1205 void RenderThemeMac::adjustTextAreaStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const
1206 {
1207 }
1208 
1209 const int* RenderThemeMac::popupButtonMargins() const
1210 {
1211     static const int margins[3][4] =
1212     {
1213         { 0, 3, 1, 3 },
1214         { 0, 3, 2, 3 },
1215         { 0, 1, 0, 1 }
1216     };
1217     return margins[[popupButton() controlSize]];
1218 }
1219 
1220 const IntSize* RenderThemeMac::popupButtonSizes() const
1221 {
1222     static const IntSize sizes[3] = { IntSize(0, 21), IntSize(0, 18), IntSize(0, 15) };
1223     return sizes;
1224 }
1225 
1226 const int* RenderThemeMac::popupButtonPadding(NSControlSize size, bool isRTL) const
1227 {
1228     static const int paddingLTR[3][4] =
1229     {
1230         { 2, 26, 3, 8 },
1231         { 2, 23, 3, 8 },
1232         { 2, 22, 3, 10 }
1233     };
1234     static const int paddingRTL[3][4] =
1235     {
1236         { 2, 8, 3, 26 },
1237         { 2, 8, 3, 23 },
1238         { 2, 8, 3, 22 }
1239     };
1240     return isRTL ? paddingRTL[size] : paddingLTR[size];
1241 }
1242 
1243 bool RenderThemeMac::paintMenuList(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
1244 {
1245     LocalCurrentGraphicsContext localContext(paintInfo.context());
1246     setPopupButtonCellState(renderer, IntSize(rect.size()));
1247 
1248     NSPopUpButtonCell* popupButton = this-&gt;popupButton();
1249 
1250     float zoomLevel = renderer.style().effectiveZoom();
1251     IntSize size = popupButtonSizes()[[popupButton controlSize]];
1252     size.setHeight(size.height() * zoomLevel);
1253     size.setWidth(rect.width());
1254 
1255     // Now inflate it to account for the shadow.
1256     FloatRect inflatedRect = rect;
1257     if (rect.width() &gt;= minimumMenuListSize(renderer.style()))
1258         inflatedRect = inflateRect(rect, size, popupButtonMargins(), zoomLevel);
1259 
1260     GraphicsContextStateSaver stateSaver(paintInfo.context());
1261 
1262     if (zoomLevel != 1.0f) {
1263         inflatedRect.setWidth(inflatedRect.width() / zoomLevel);
1264         inflatedRect.setHeight(inflatedRect.height() / zoomLevel);
1265         paintInfo.context().translate(inflatedRect.location());
1266         paintInfo.context().scale(zoomLevel);
1267         paintInfo.context().translate(-inflatedRect.location());
1268     }
1269 
1270     paintCellAndSetFocusedElementNeedsRepaintIfNecessary(popupButton, renderer, paintInfo, inflatedRect);
1271     [popupButton setControlView:nil];
1272 
1273     return false;
1274 }
1275 
1276 #if ENABLE(METER_ELEMENT)
1277 
1278 IntSize RenderThemeMac::meterSizeForBounds(const RenderMeter&amp; renderMeter, const IntRect&amp; bounds) const
1279 {
1280     if (NoControlPart == renderMeter.style().appearance())
1281         return bounds.size();
1282 
1283     NSLevelIndicatorCell* cell = levelIndicatorFor(renderMeter);
1284     // Makes enough room for cell&#39;s intrinsic size.
1285     NSSize cellSize = [cell cellSizeForBounds:IntRect(IntPoint(), bounds.size())];
1286     return IntSize(bounds.width() &lt; cellSize.width ? cellSize.width : bounds.width(),
1287                    bounds.height() &lt; cellSize.height ? cellSize.height : bounds.height());
1288 }
1289 
1290 bool RenderThemeMac::paintMeter(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1291 {
1292     if (!is&lt;RenderMeter&gt;(renderObject))
1293         return true;
1294 
1295     LocalCurrentGraphicsContext localContext(paintInfo.context());
1296 
1297     NSLevelIndicatorCell* cell = levelIndicatorFor(downcast&lt;RenderMeter&gt;(renderObject));
1298     GraphicsContextStateSaver stateSaver(paintInfo.context());
1299 
1300     [cell drawWithFrame:rect inView:documentViewFor(renderObject)];
1301     [cell setControlView:nil];
1302     return false;
1303 }
1304 
1305 bool RenderThemeMac::supportsMeter(ControlPart part) const
1306 {
1307     switch (part) {
1308     case RelevancyLevelIndicatorPart:
1309     case DiscreteCapacityLevelIndicatorPart:
1310     case RatingLevelIndicatorPart:
1311     case MeterPart:
1312     case ContinuousCapacityLevelIndicatorPart:
1313         return true;
1314     default:
1315         return false;
1316     }
1317 }
1318 
1319 NSLevelIndicatorStyle RenderThemeMac::levelIndicatorStyleFor(ControlPart part) const
1320 {
1321     switch (part) {
1322     case RelevancyLevelIndicatorPart:
1323         return NSLevelIndicatorStyleRelevancy;
1324     case DiscreteCapacityLevelIndicatorPart:
1325         return NSLevelIndicatorStyleDiscreteCapacity;
1326     case RatingLevelIndicatorPart:
1327         return NSLevelIndicatorStyleRating;
1328     case MeterPart:
1329     case ContinuousCapacityLevelIndicatorPart:
1330     default:
1331         return NSLevelIndicatorStyleContinuousCapacity;
1332     }
1333 
1334 }
1335 
1336 NSLevelIndicatorCell* RenderThemeMac::levelIndicatorFor(const RenderMeter&amp; renderMeter) const
1337 {
1338     const RenderStyle&amp; style = renderMeter.style();
1339     ASSERT(style.appearance() != NoControlPart);
1340 
1341     if (!m_levelIndicator)
1342         m_levelIndicator = adoptNS([[NSLevelIndicatorCell alloc] initWithLevelIndicatorStyle:NSLevelIndicatorStyleContinuousCapacity]);
1343     NSLevelIndicatorCell* cell = m_levelIndicator.get();
1344 
1345     HTMLMeterElement* element = renderMeter.meterElement();
1346     double value = element-&gt;value();
1347 
1348     // Because NSLevelIndicatorCell does not support optimum-in-the-middle type coloring,
1349     // we explicitly control the color instead giving low and high value to NSLevelIndicatorCell as is.
1350     switch (element-&gt;gaugeRegion()) {
1351     case HTMLMeterElement::GaugeRegionOptimum:
1352         // Make meter the green
1353         [cell setWarningValue:value + 1];
1354         [cell setCriticalValue:value + 2];
1355         break;
1356     case HTMLMeterElement::GaugeRegionSuboptimal:
1357         // Make the meter yellow
1358         [cell setWarningValue:value - 1];
1359         [cell setCriticalValue:value + 1];
1360         break;
1361     case HTMLMeterElement::GaugeRegionEvenLessGood:
1362         // Make the meter red
1363         [cell setWarningValue:value - 2];
1364         [cell setCriticalValue:value - 1];
1365         break;
1366     }
1367 
1368     [cell setLevelIndicatorStyle:levelIndicatorStyleFor(style.appearance())];
1369     [cell setUserInterfaceLayoutDirection:style.isLeftToRightDirection() ? NSUserInterfaceLayoutDirectionLeftToRight : NSUserInterfaceLayoutDirectionRightToLeft];
1370     [cell setMinValue:element-&gt;min()];
1371     [cell setMaxValue:element-&gt;max()];
1372     [cell setObjectValue:@(value)];
1373 
1374     return cell;
1375 }
1376 
1377 #endif
1378 
1379 const IntSize* RenderThemeMac::progressBarSizes() const
1380 {
1381     static const IntSize sizes[3] = { IntSize(0, 20), IntSize(0, 12), IntSize(0, 12) };
1382     return sizes;
1383 }
1384 
1385 const int* RenderThemeMac::progressBarMargins(NSControlSize controlSize) const
1386 {
1387     static const int margins[3][4] =
1388     {
1389         { 0, 0, 1, 0 },
1390         { 0, 0, 1, 0 },
1391         { 0, 0, 1, 0 },
1392     };
1393     return margins[controlSize];
1394 }
1395 
1396 IntRect RenderThemeMac::progressBarRectForBounds(const RenderObject&amp; renderObject, const IntRect&amp; bounds) const
1397 {
1398     // Workaround until &lt;rdar://problem/15855086&gt; is fixed.
1399     int maxDimension = static_cast&lt;int&gt;(std::numeric_limits&lt;ushort&gt;::max());
1400     IntRect progressBarBounds(bounds.x(), bounds.y(), std::min(bounds.width(), maxDimension), std::min(bounds.height(), maxDimension));
1401     if (NoControlPart == renderObject.style().appearance())
1402         return progressBarBounds;
1403 
1404     float zoomLevel = renderObject.style().effectiveZoom();
1405     NSControlSize controlSize = controlSizeForFont(renderObject.style());
1406     IntSize size = progressBarSizes()[controlSize];
1407     size.setHeight(size.height() * zoomLevel);
1408     size.setWidth(progressBarBounds.width());
1409 
1410     // Now inflate it to account for the shadow.
1411     IntRect inflatedRect = progressBarBounds;
1412     if (progressBarBounds.height() &lt;= minimumProgressBarHeight(renderObject.style()))
1413         inflatedRect = IntRect(inflateRect(inflatedRect, size, progressBarMargins(controlSize), zoomLevel));
1414 
1415     return inflatedRect;
1416 }
1417 
1418 int RenderThemeMac::minimumProgressBarHeight(const RenderStyle&amp; style) const
1419 {
1420     return sizeForSystemFont(style, progressBarSizes()).height();
1421 }
1422 
1423 Seconds RenderThemeMac::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1424 {
1425     return progressAnimationFrameRate;
1426 }
1427 
1428 Seconds RenderThemeMac::animationDurationForProgressBar(RenderProgress&amp;) const
1429 {
1430     return progressAnimationFrameRate * progressAnimationNumFrames;
1431 }
1432 
1433 void RenderThemeMac::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const
1434 {
1435 }
1436 
1437 bool RenderThemeMac::paintProgressBar(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1438 {
1439     if (!is&lt;RenderProgress&gt;(renderObject))
1440         return true;
1441 
1442     IntRect inflatedRect = progressBarRectForBounds(renderObject, rect);
1443     NSControlSize controlSize = controlSizeForFont(renderObject.style());
1444 
1445     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
1446     HIThemeTrackDrawInfo trackInfo;
1447     trackInfo.version = 0;
1448     if (controlSize == NSControlSizeRegular)
1449         trackInfo.kind = renderProgress.position() &lt; 0 ? kThemeLargeIndeterminateBar : kThemeLargeProgressBar;
1450     else
1451         trackInfo.kind = renderProgress.position() &lt; 0 ? kThemeMediumIndeterminateBar : kThemeMediumProgressBar;
1452 
1453     float deviceScaleFactor = renderObject.document().deviceScaleFactor();
1454     trackInfo.bounds = IntRect(IntPoint(), inflatedRect.size());
1455     trackInfo.min = 0;
1456     trackInfo.max = std::numeric_limits&lt;SInt32&gt;::max();
1457     trackInfo.value = lround(renderProgress.position() * nextafter(trackInfo.max, 0));
1458     trackInfo.trackInfo.progress.phase = lround(renderProgress.animationProgress() * nextafter(progressAnimationNumFrames, 0) * deviceScaleFactor);
1459     trackInfo.attributes = kThemeTrackHorizontal;
1460     trackInfo.enableState = isActive(renderObject) ? kThemeTrackActive : kThemeTrackInactive;
1461     trackInfo.reserved = 0;
1462     trackInfo.filler1 = 0;
1463 
1464     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::createCompatibleBuffer(inflatedRect.size(), deviceScaleFactor, ColorSpaceSRGB, paintInfo.context());
1465     if (!imageBuffer)
1466         return true;
1467 
1468     ContextContainer cgContextContainer(imageBuffer-&gt;context());
1469     CGContextRef cgContext = cgContextContainer.context();
1470     HIThemeDrawTrack(&amp;trackInfo, 0, cgContext, kHIThemeOrientationNormal);
1471 
1472     GraphicsContextStateSaver stateSaver(paintInfo.context());
1473 
1474     if (!renderProgress.style().isLeftToRightDirection()) {
1475         paintInfo.context().translate(2 * inflatedRect.x() + inflatedRect.width(), 0);
1476         paintInfo.context().scale(FloatSize(-1, 1));
1477     }
1478 
1479     paintInfo.context().drawConsumingImageBuffer(WTFMove(imageBuffer), inflatedRect.location());
1480     return false;
1481 }
1482 
1483 const float baseFontSize = 11.0f;
1484 const float baseArrowHeight = 4.0f;
1485 const float baseArrowWidth = 5.0f;
1486 const float baseSpaceBetweenArrows = 2.0f;
1487 const int arrowPaddingBefore = 6;
1488 const int arrowPaddingAfter = 6;
1489 const int paddingBeforeSeparator = 4;
1490 const int baseBorderRadius = 5;
1491 const int styledPopupPaddingLeft = 8;
1492 const int styledPopupPaddingTop = 1;
1493 const int styledPopupPaddingBottom = 2;
1494 
1495 static void TopGradientInterpolate(void*, const CGFloat* inData, CGFloat* outData)
1496 {
1497     static const float dark[4] = { 1.0f, 1.0f, 1.0f, 0.4f };
1498     static const float light[4] = { 1.0f, 1.0f, 1.0f, 0.15f };
1499     float a = inData[0];
1500     int i = 0;
1501     for (i = 0; i &lt; 4; i++)
1502         outData[i] = (1.0f - a) * dark[i] + a * light[i];
1503 }
1504 
1505 static void BottomGradientInterpolate(void*, const CGFloat* inData, CGFloat* outData)
1506 {
1507     static const float dark[4] = { 1.0f, 1.0f, 1.0f, 0.0f };
1508     static const float light[4] = { 1.0f, 1.0f, 1.0f, 0.3f };
1509     float a = inData[0];
1510     int i = 0;
1511     for (i = 0; i &lt; 4; i++)
1512         outData[i] = (1.0f - a) * dark[i] + a * light[i];
1513 }
1514 
1515 static void MainGradientInterpolate(void*, const CGFloat* inData, CGFloat* outData)
1516 {
1517     static const float dark[4] = { 0.0f, 0.0f, 0.0f, 0.15f };
1518     static const float light[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
1519     float a = inData[0];
1520     int i = 0;
1521     for (i = 0; i &lt; 4; i++)
1522         outData[i] = (1.0f - a) * dark[i] + a * light[i];
1523 }
1524 
1525 static void TrackGradientInterpolate(void*, const CGFloat* inData, CGFloat* outData)
1526 {
1527     static const float dark[4] = { 0.0f, 0.0f, 0.0f, 0.678f };
1528     static const float light[4] = { 0.0f, 0.0f, 0.0f, 0.13f };
1529     float a = inData[0];
1530     int i = 0;
1531     for (i = 0; i &lt; 4; i++)
1532         outData[i] = (1.0f - a) * dark[i] + a * light[i];
1533 }
1534 
1535 void RenderThemeMac::paintMenuListButtonGradients(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1536 {
1537     if (r.isEmpty())
1538         return;
1539 
1540     ContextContainer cgContextContainer(paintInfo.context());
1541     CGContextRef context = cgContextContainer.context();
1542 
1543     GraphicsContextStateSaver stateSaver(paintInfo.context());
1544 
1545     FloatRoundedRect border = FloatRoundedRect(o.style().getRoundedBorderFor(r));
1546     int radius = border.radii().topLeft().width();
1547 
1548     CGColorSpaceRef cspace = sRGBColorSpaceRef();
1549 
1550     FloatRect topGradient(r.x(), r.y(), r.width(), r.height() / 2.0f);
1551     struct CGFunctionCallbacks topCallbacks = { 0, TopGradientInterpolate, NULL };
1552     RetainPtr&lt;CGFunctionRef&gt; topFunction = adoptCF(CGFunctionCreate(NULL, 1, NULL, 4, NULL, &amp;topCallbacks));
1553     RetainPtr&lt;CGShadingRef&gt; topShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(topGradient.x(), topGradient.y()), CGPointMake(topGradient.x(), topGradient.maxY()), topFunction.get(), false, false));
1554 
1555     FloatRect bottomGradient(r.x() + radius, r.y() + r.height() / 2.0f, r.width() - 2.0f * radius, r.height() / 2.0f);
1556     struct CGFunctionCallbacks bottomCallbacks = { 0, BottomGradientInterpolate, NULL };
1557     RetainPtr&lt;CGFunctionRef&gt; bottomFunction = adoptCF(CGFunctionCreate(NULL, 1, NULL, 4, NULL, &amp;bottomCallbacks));
1558     RetainPtr&lt;CGShadingRef&gt; bottomShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(bottomGradient.x(),  bottomGradient.y()), CGPointMake(bottomGradient.x(), bottomGradient.maxY()), bottomFunction.get(), false, false));
1559 
1560     struct CGFunctionCallbacks mainCallbacks = { 0, MainGradientInterpolate, NULL };
1561     RetainPtr&lt;CGFunctionRef&gt; mainFunction = adoptCF(CGFunctionCreate(NULL, 1, NULL, 4, NULL, &amp;mainCallbacks));
1562     RetainPtr&lt;CGShadingRef&gt; mainShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(r.x(),  r.y()), CGPointMake(r.x(), r.maxY()), mainFunction.get(), false, false));
1563 
1564     RetainPtr&lt;CGShadingRef&gt; leftShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(r.x(),  r.y()), CGPointMake(r.x() + radius, r.y()), mainFunction.get(), false, false));
1565 
1566     RetainPtr&lt;CGShadingRef&gt; rightShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(r.maxX(),  r.y()), CGPointMake(r.maxX() - radius, r.y()), mainFunction.get(), false, false));
1567 
1568     {
1569         GraphicsContextStateSaver stateSaver(paintInfo.context());
1570         CGContextClipToRect(context, r);
1571         paintInfo.context().clipRoundedRect(border);
1572         context = cgContextContainer.context();
1573         CGContextDrawShading(context, mainShading.get());
1574     }
1575 
1576     {
1577         GraphicsContextStateSaver stateSaver(paintInfo.context());
1578         CGContextClipToRect(context, topGradient);
1579         paintInfo.context().clipRoundedRect(FloatRoundedRect(enclosingIntRect(topGradient), border.radii().topLeft(), border.radii().topRight(), IntSize(), IntSize()));
1580         context = cgContextContainer.context();
1581         CGContextDrawShading(context, topShading.get());
1582     }
1583 
1584     if (!bottomGradient.isEmpty()) {
1585         GraphicsContextStateSaver stateSaver(paintInfo.context());
1586         CGContextClipToRect(context, bottomGradient);
1587         paintInfo.context().clipRoundedRect(FloatRoundedRect(enclosingIntRect(bottomGradient), IntSize(), IntSize(), border.radii().bottomLeft(), border.radii().bottomRight()));
1588         context = cgContextContainer.context();
1589         CGContextDrawShading(context, bottomShading.get());
1590     }
1591 
1592     {
1593         GraphicsContextStateSaver stateSaver(paintInfo.context());
1594         CGContextClipToRect(context, r);
1595         paintInfo.context().clipRoundedRect(border);
1596         context = cgContextContainer.context();
1597         CGContextDrawShading(context, leftShading.get());
1598         CGContextDrawShading(context, rightShading.get());
1599     }
1600 }
1601 
1602 bool RenderThemeMac::paintMenuListButtonDecorations(const RenderBox&amp; renderer, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
1603 {
1604     bool isRTL = renderer.style().direction() == TextDirection::RTL;
1605     IntRect bounds = IntRect(rect.x() + renderer.style().borderLeftWidth(),
1606         rect.y() + renderer.style().borderTopWidth(),
1607         rect.width() - renderer.style().borderLeftWidth() - renderer.style().borderRightWidth(),
1608         rect.height() - renderer.style().borderTopWidth() - renderer.style().borderBottomWidth());
1609     // Draw the gradients to give the styled popup menu a button appearance
1610     paintMenuListButtonGradients(renderer, paintInfo, bounds);
1611 
1612     // Since we actually know the size of the control here, we restrict the font scale to make sure the arrows will fit vertically in the bounds
1613     float fontScale = std::min(renderer.style().computedFontPixelSize() / baseFontSize, bounds.height() / (baseArrowHeight * 2 + baseSpaceBetweenArrows));
1614     float centerY = bounds.y() + bounds.height() / 2.0f;
1615     float arrowHeight = baseArrowHeight * fontScale;
1616     float arrowWidth = baseArrowWidth * fontScale;
1617     float leftEdge;
1618     if (isRTL)
1619         leftEdge = bounds.x() + arrowPaddingAfter * renderer.style().effectiveZoom();
1620     else
1621         leftEdge = bounds.maxX() - arrowPaddingAfter * renderer.style().effectiveZoom() - arrowWidth;
1622     float spaceBetweenArrows = baseSpaceBetweenArrows * fontScale;
1623 
1624     if (bounds.width() &lt; arrowWidth + arrowPaddingBefore * renderer.style().effectiveZoom())
1625         return false;
1626 
1627     GraphicsContextStateSaver stateSaver(paintInfo.context());
1628 
1629     paintInfo.context().setFillColor(renderer.style().visitedDependentColor(CSSPropertyColor));
1630     paintInfo.context().setStrokeStyle(NoStroke);
1631 
1632     // Draw the top arrow
1633     Vector&lt;FloatPoint&gt; arrow1 = {
1634         { leftEdge, centerY - spaceBetweenArrows / 2.0f },
1635         { leftEdge + arrowWidth, centerY - spaceBetweenArrows / 2.0f },
1636         { leftEdge + arrowWidth / 2.0f, centerY - spaceBetweenArrows / 2.0f - arrowHeight }
1637     };
1638     paintInfo.context().fillPath(Path::polygonPathFromPoints(arrow1));
1639 
1640     // Draw the bottom arrow
1641     Vector&lt;FloatPoint&gt; arrow2 = {
1642         { leftEdge, centerY + spaceBetweenArrows / 2.0f },
1643         { leftEdge + arrowWidth, centerY + spaceBetweenArrows / 2.0f },
1644         { leftEdge + arrowWidth / 2.0f, centerY + spaceBetweenArrows / 2.0f + arrowHeight }
1645     };
1646     paintInfo.context().fillPath(Path::polygonPathFromPoints(arrow2));
1647 
1648     Color leftSeparatorColor(0, 0, 0, 40);
1649     Color rightSeparatorColor(255, 255, 255, 40);
1650 
1651     // FIXME: Should the separator thickness and space be scaled up by fontScale?
1652     int separatorSpace = 2; // Deliberately ignores zoom since it looks nicer if it stays thin.
1653     int leftEdgeOfSeparator;
1654     if (isRTL)
1655         leftEdgeOfSeparator = static_cast&lt;int&gt;(roundf(leftEdge + arrowWidth + arrowPaddingBefore * renderer.style().effectiveZoom()));
1656     else
1657         leftEdgeOfSeparator = static_cast&lt;int&gt;(roundf(leftEdge - arrowPaddingBefore * renderer.style().effectiveZoom()));
1658 
1659     // Draw the separator to the left of the arrows
1660     paintInfo.context().setStrokeThickness(1); // Deliberately ignores zoom since it looks nicer if it stays thin.
1661     paintInfo.context().setStrokeStyle(SolidStroke);
1662     paintInfo.context().setStrokeColor(leftSeparatorColor);
1663     paintInfo.context().drawLine(IntPoint(leftEdgeOfSeparator, bounds.y()),
1664         IntPoint(leftEdgeOfSeparator, bounds.maxY()));
1665 
1666     paintInfo.context().setStrokeColor(rightSeparatorColor);
1667     paintInfo.context().drawLine(IntPoint(leftEdgeOfSeparator + separatorSpace, bounds.y()),
1668         IntPoint(leftEdgeOfSeparator + separatorSpace, bounds.maxY()));
1669     return false;
1670 }
1671 
1672 static const IntSize* menuListButtonSizes()
1673 {
1674     static const IntSize sizes[3] = { IntSize(0, 21), IntSize(0, 18), IntSize(0, 15) };
1675     return sizes;
1676 }
1677 
1678 void RenderThemeMac::adjustMenuListStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
1679 {
1680     NSControlSize controlSize = controlSizeForFont(style);
1681 
1682     style.resetBorder();
1683     style.resetPadding();
1684 
1685     // Height is locked to auto.
1686     style.setHeight(Length(Auto));
1687 
1688     // White-space is locked to pre
1689     style.setWhiteSpace(WhiteSpace::Pre);
1690 
1691     // Set the foreground color to black or gray when we have the aqua look.
1692     Color c = Color::darkGray;
1693     if (e) {
1694         OptionSet&lt;StyleColor::Options&gt; options = e-&gt;document().styleColorOptions(&amp;style);
1695         c = !e-&gt;isDisabledFormControl() ? systemColor(CSSValueButtontext, options) : systemColor(CSSValueGraytext, options);
1696     }
1697     style.setColor(c);
1698 
1699     // Set the button&#39;s vertical size.
1700     setSizeFromFont(style, menuListButtonSizes());
1701 
1702     // Our font is locked to the appropriate system font size for the control.  To clarify, we first use the CSS-specified font to figure out
1703     // a reasonable control size, but once that control size is determined, we throw that font away and use the appropriate
1704     // system font for the control size instead.
1705     setFontFromControlSize(styleResolver, style, controlSize);
1706 
1707     style.setBoxShadow(nullptr);
1708 }
1709 
1710 LengthBox RenderThemeMac::popupInternalPaddingBox(const RenderStyle&amp; style) const
1711 {
1712     if (style.appearance() == MenulistPart) {
1713         const int* padding = popupButtonPadding(controlSizeForFont(style), style.direction() == TextDirection::RTL);
1714         return { static_cast&lt;int&gt;(padding[topPadding] * style.effectiveZoom()),
1715             static_cast&lt;int&gt;(padding[rightPadding] * style.effectiveZoom()),
1716             static_cast&lt;int&gt;(padding[bottomPadding] * style.effectiveZoom()),
1717             static_cast&lt;int&gt;(padding[leftPadding] * style.effectiveZoom()) };
1718     }
1719 
1720     if (style.appearance() == MenulistButtonPart) {
1721         float arrowWidth = baseArrowWidth * (style.computedFontPixelSize() / baseFontSize);
1722         float rightPadding = ceilf(arrowWidth + (arrowPaddingBefore + arrowPaddingAfter + paddingBeforeSeparator) * style.effectiveZoom());
1723         float leftPadding = styledPopupPaddingLeft * style.effectiveZoom();
1724         if (style.direction() == TextDirection::RTL)
1725             std::swap(rightPadding, leftPadding);
1726         return { static_cast&lt;int&gt;(styledPopupPaddingTop * style.effectiveZoom()),
1727             static_cast&lt;int&gt;(rightPadding),
1728             static_cast&lt;int&gt;(styledPopupPaddingBottom * style.effectiveZoom()),
1729             static_cast&lt;int&gt;(leftPadding) };
1730     }
1731 
1732     return { 0, 0, 0, 0 };
1733 }
1734 
1735 PopupMenuStyle::PopupMenuSize RenderThemeMac::popupMenuSize(const RenderStyle&amp; style, IntRect&amp; rect) const
1736 {
1737     NSPopUpButtonCell* popupButton = this-&gt;popupButton();
1738     NSControlSize size = controlSizeForCell(popupButton, popupButtonSizes(), rect.size(), style.effectiveZoom());
1739     switch (size) {
1740     case NSControlSizeRegular:
1741         return PopupMenuStyle::PopupMenuSizeNormal;
1742     case NSControlSizeSmall:
1743         return PopupMenuStyle::PopupMenuSizeSmall;
1744     case NSControlSizeMini:
1745         return PopupMenuStyle::PopupMenuSizeMini;
1746     default:
1747         return PopupMenuStyle::PopupMenuSizeNormal;
1748     }
1749 }
1750 
1751 void RenderThemeMac::adjustMenuListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1752 {
1753     float fontScale = style.computedFontPixelSize() / baseFontSize;
1754 
1755     style.resetPadding();
1756     style.setBorderRadius(IntSize(int(baseBorderRadius + fontScale - 1), int(baseBorderRadius + fontScale - 1))); // FIXME: Round up?
1757 
1758     const int minHeight = 15;
1759     style.setMinHeight(Length(minHeight, Fixed));
1760 
1761     style.setLineHeight(RenderStyle::initialLineHeight());
1762 }
1763 
1764 void RenderThemeMac::setPopupButtonCellState(const RenderObject&amp; o, const IntSize&amp; buttonSize)
1765 {
1766     NSPopUpButtonCell* popupButton = this-&gt;popupButton();
1767 
1768     // Set the control size based off the rectangle we&#39;re painting into.
1769     setControlSize(popupButton, popupButtonSizes(), buttonSize, o.style().effectiveZoom());
1770 
1771     popupButton.userInterfaceLayoutDirection = o.style().direction() == TextDirection::LTR ? NSUserInterfaceLayoutDirectionLeftToRight : NSUserInterfaceLayoutDirectionRightToLeft;
1772 
1773     // Update the various states we respond to.
1774     updateCheckedState(popupButton, o);
1775     updateEnabledState(popupButton, o);
1776     updatePressedState(popupButton, o);
1777 }
1778 
1779 void RenderThemeMac::paintCellAndSetFocusedElementNeedsRepaintIfNecessary(NSCell* cell, const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
1780 {
1781     LocalDefaultSystemAppearance localAppearance(renderer.useDarkAppearance());
1782     bool shouldDrawFocusRing = isFocused(renderer) &amp;&amp; renderer.style().outlineStyleIsAuto() == OutlineIsAuto::On;
1783     bool shouldUseImageBuffer = renderer.style().effectiveZoom() != 1 || renderer.page().pageScaleFactor() != 1;
1784     bool shouldDrawCell = true;
1785     if (ThemeMac::drawCellOrFocusRingWithViewIntoContext(cell, paintInfo.context(), rect, documentViewFor(renderer), shouldDrawCell, shouldDrawFocusRing, shouldUseImageBuffer, renderer.page().deviceScaleFactor()))
1786         renderer.page().focusController().setFocusedElementNeedsRepaint();
1787 }
1788 
1789 const IntSize* RenderThemeMac::menuListSizes() const
1790 {
1791     static const IntSize sizes[3] = { IntSize(9, 0), IntSize(5, 0), IntSize(0, 0) };
1792     return sizes;
1793 }
1794 
1795 int RenderThemeMac::minimumMenuListSize(const RenderStyle&amp; style) const
1796 {
1797     return sizeForSystemFont(style, menuListSizes()).width();
1798 }
1799 
1800 const int trackWidth = 5;
1801 const int trackRadius = 2;
1802 
1803 void RenderThemeMac::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1804 {
1805     style.setBoxShadow(nullptr);
1806 }
1807 
1808 bool RenderThemeMac::paintSliderTrack(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1809 {
1810     IntRect bounds = r;
1811     float zoomLevel = o.style().effectiveZoom();
1812     float zoomedTrackWidth = trackWidth * zoomLevel;
1813 
1814     if (o.style().appearance() ==  SliderHorizontalPart || o.style().appearance() ==  MediaSliderPart) {
1815         bounds.setHeight(zoomedTrackWidth);
1816         bounds.setY(r.y() + r.height() / 2 - zoomedTrackWidth / 2);
1817     } else if (o.style().appearance() == SliderVerticalPart) {
1818         bounds.setWidth(zoomedTrackWidth);
1819         bounds.setX(r.x() + r.width() / 2 - zoomedTrackWidth / 2);
1820     }
1821 
1822     LocalCurrentGraphicsContext localContext(paintInfo.context());
1823     CGContextRef context = localContext.cgContext();
1824     CGColorSpaceRef cspace = sRGBColorSpaceRef();
1825 
1826 #if ENABLE(DATALIST_ELEMENT)
1827     paintSliderTicks(o, paintInfo, r);
1828 #endif
1829 
1830     GraphicsContextStateSaver stateSaver(paintInfo.context());
1831     CGContextClipToRect(context, bounds);
1832 
1833     struct CGFunctionCallbacks mainCallbacks = { 0, TrackGradientInterpolate, NULL };
1834     RetainPtr&lt;CGFunctionRef&gt; mainFunction = adoptCF(CGFunctionCreate(NULL, 1, NULL, 4, NULL, &amp;mainCallbacks));
1835     RetainPtr&lt;CGShadingRef&gt; mainShading;
1836     if (o.style().appearance() == SliderVerticalPart)
1837         mainShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(bounds.x(),  bounds.maxY()), CGPointMake(bounds.maxX(), bounds.maxY()), mainFunction.get(), false, false));
1838     else
1839         mainShading = adoptCF(CGShadingCreateAxial(cspace, CGPointMake(bounds.x(),  bounds.y()), CGPointMake(bounds.x(), bounds.maxY()), mainFunction.get(), false, false));
1840 
1841     IntSize radius(trackRadius, trackRadius);
1842     paintInfo.context().clipRoundedRect(FloatRoundedRect(bounds, radius, radius, radius, radius));
1843     context = localContext.cgContext();
1844     CGContextDrawShading(context, mainShading.get());
1845 
1846     return false;
1847 }
1848 
1849 void RenderThemeMac::adjustSliderThumbStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element) const
1850 {
1851     RenderTheme::adjustSliderThumbStyle(styleResolver, style, element);
1852     style.setBoxShadow(nullptr);
1853 }
1854 
1855 const float verticalSliderHeightPadding = 0.1f;
1856 
1857 bool RenderThemeMac::paintSliderThumb(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1858 {
1859     NSSliderCell* sliderThumbCell = o.style().appearance() == SliderThumbVerticalPart
1860         ? sliderThumbVertical()
1861         : sliderThumbHorizontal();
1862 
1863     LocalDefaultSystemAppearance localAppearance(o.useDarkAppearance());
1864 
1865     LocalCurrentGraphicsContext localContext(paintInfo.context());
1866 
1867     // Update the various states we respond to.
1868     updateEnabledState(sliderThumbCell, o);
1869     auto focusDelegate = is&lt;Element&gt;(o.node()) ? downcast&lt;Element&gt;(*o.node()).focusDelegate() : nullptr;
1870     if (focusDelegate)
1871         updateFocusedState(sliderThumbCell, *focusDelegate-&gt;renderer());
1872 
1873     // Update the pressed state using the NSCell tracking methods, since that&#39;s how NSSliderCell keeps track of it.
1874     bool oldPressed;
1875     if (o.style().appearance() == SliderThumbVerticalPart)
1876         oldPressed = m_isSliderThumbVerticalPressed;
1877     else
1878         oldPressed = m_isSliderThumbHorizontalPressed;
1879 
1880     bool pressed = isPressed(o);
1881 
1882     if (o.style().appearance() == SliderThumbVerticalPart)
1883         m_isSliderThumbVerticalPressed = pressed;
1884     else
1885         m_isSliderThumbHorizontalPressed = pressed;
1886 
1887     NSView *view = documentViewFor(o);
1888 
1889     if (pressed != oldPressed) {
1890         if (pressed)
1891             [sliderThumbCell startTrackingAt:NSPoint() inView:view];
1892         else
1893             [sliderThumbCell stopTracking:NSPoint() at:NSPoint() inView:view mouseIsUp:YES];
1894     }
1895 
1896     FloatRect bounds = r;
1897     // Make the height of the vertical slider slightly larger so NSSliderCell will draw a vertical slider.
1898     if (o.style().appearance() == SliderThumbVerticalPart)
1899         bounds.setHeight(bounds.height() + verticalSliderHeightPadding * o.style().effectiveZoom());
1900 
1901     GraphicsContextStateSaver stateSaver(paintInfo.context());
1902     float zoomLevel = o.style().effectiveZoom();
1903 
1904     FloatRect unzoomedRect = bounds;
1905     if (zoomLevel != 1.0f) {
1906         unzoomedRect.setSize(unzoomedRect.size() / zoomLevel);
1907         paintInfo.context().translate(unzoomedRect.location());
1908         paintInfo.context().scale(zoomLevel);
1909         paintInfo.context().translate(-unzoomedRect.location());
1910     }
1911 
1912     bool shouldDrawCell = true;
1913     bool shouldDrawFocusRing = false;
1914     float deviceScaleFactor = o.page().deviceScaleFactor();
1915     bool shouldUseImageBuffer = deviceScaleFactor != 1 || zoomLevel != 1;
1916     ThemeMac::drawCellOrFocusRingWithViewIntoContext(sliderThumbCell, paintInfo.context(), unzoomedRect, view, shouldDrawCell, shouldDrawFocusRing, shouldUseImageBuffer, deviceScaleFactor);
1917     [sliderThumbCell setControlView:nil];
1918 
1919     return false;
1920 }
1921 
1922 bool RenderThemeMac::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1923 {
1924     LocalCurrentGraphicsContext localContext(paintInfo.context());
1925     NSSearchFieldCell* search = this-&gt;search();
1926 
1927     setSearchCellState(o, r);
1928 
1929     GraphicsContextStateSaver stateSaver(paintInfo.context());
1930 
1931     float zoomLevel = o.style().effectiveZoom();
1932 
1933     FloatRect unzoomedRect = r;
1934     if (zoomLevel != 1.0f) {
1935         unzoomedRect.setSize(unzoomedRect.size() / zoomLevel);
1936         paintInfo.context().translate(unzoomedRect.location());
1937         paintInfo.context().scale(zoomLevel);
1938         paintInfo.context().translate(-unzoomedRect.location());
1939     }
1940 
1941     // Set the search button to nil before drawing.  Then reset it so we can draw it later.
1942     [search setSearchButtonCell:nil];
1943 
1944     paintCellAndSetFocusedElementNeedsRepaintIfNecessary(search, o, paintInfo, unzoomedRect);
1945     [search setControlView:nil];
1946     [search resetSearchButtonCell];
1947 
1948 #if ENABLE(DATALIST_ELEMENT)
1949     if (!is&lt;HTMLInputElement&gt;(o.generatingNode()))
1950         return false;
1951 
1952     const auto&amp; input = downcast&lt;HTMLInputElement&gt;(*(o.generatingNode()));
1953     if (input.list())
1954         paintListButtonForInput(o, paintInfo.context(), FloatRect(unzoomedRect.x(), unzoomedRect.y() + 1, unzoomedRect.width(), unzoomedRect.height() - 2));
1955 #endif
1956 
1957     return false;
1958 }
1959 
1960 void RenderThemeMac::setSearchCellState(const RenderObject&amp; o, const IntRect&amp;)
1961 {
1962     NSSearchFieldCell* search = this-&gt;search();
1963 
1964     [search setPlaceholderString:@&quot;&quot;];
1965     [search setControlSize:controlSizeForFont(o.style())];
1966 
1967     // Update the various states we respond to.
1968     updateEnabledState(search, o);
1969     updateFocusedState(search, o);
1970 }
1971 
1972 const IntSize* RenderThemeMac::searchFieldSizes() const
1973 {
1974     static const IntSize sizes[3] = { IntSize(0, 22), IntSize(0, 19), IntSize(0, 17) };
1975     return sizes;
1976 }
1977 
1978 void RenderThemeMac::setSearchFieldSize(RenderStyle&amp; style) const
1979 {
1980     // If the width and height are both specified, then we have nothing to do.
1981     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
1982         return;
1983 
1984     // Use the font size to determine the intrinsic width of the control.
1985     setSizeFromFont(style, searchFieldSizes());
1986 }
1987 
1988 void RenderThemeMac::adjustSearchFieldStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element*) const
1989 {
1990     // Override border.
1991     style.resetBorder();
1992     const short borderWidth = 2 * style.effectiveZoom();
1993     style.setBorderLeftWidth(borderWidth);
1994     style.setBorderLeftStyle(BorderStyle::Inset);
1995     style.setBorderRightWidth(borderWidth);
1996     style.setBorderRightStyle(BorderStyle::Inset);
1997     style.setBorderBottomWidth(borderWidth);
1998     style.setBorderBottomStyle(BorderStyle::Inset);
1999     style.setBorderTopWidth(borderWidth);
2000     style.setBorderTopStyle(BorderStyle::Inset);
2001 
2002     // Override height.
2003     style.setHeight(Length(Auto));
2004     setSearchFieldSize(style);
2005 
2006     // Override padding size to match AppKit text positioning.
2007     const int padding = 1 * style.effectiveZoom();
2008     style.setPaddingLeft(Length(padding, Fixed));
2009     style.setPaddingRight(Length(padding, Fixed));
2010     style.setPaddingTop(Length(padding, Fixed));
2011     style.setPaddingBottom(Length(padding, Fixed));
2012 
2013     NSControlSize controlSize = controlSizeForFont(style);
2014     setFontFromControlSize(styleResolver, style, controlSize);
2015 
2016     style.setBoxShadow(nullptr);
2017 }
2018 
2019 bool RenderThemeMac::paintSearchFieldCancelButton(const RenderBox&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
2020 {
2021     auto adjustedCancelButtonRect = [this, &amp;box] (const FloatRect&amp; localBoundsForCancelButton) -&gt; FloatRect
2022     {
2023         IntSize cancelButtonSizeBasedOnFontSize = sizeForSystemFont(box.style(), cancelButtonSizes());
2024         FloatSize diff = localBoundsForCancelButton.size() - FloatSize(cancelButtonSizeBasedOnFontSize);
2025         if (!diff.width() &amp;&amp; !diff.height())
2026             return localBoundsForCancelButton;
2027         // Vertically centered and right aligned.
2028         FloatRect adjustedLocalBoundsForCancelButton = localBoundsForCancelButton;
2029         adjustedLocalBoundsForCancelButton.move(diff.width(), floorToDevicePixel(diff.height() / 2, box.document().deviceScaleFactor()));
2030         adjustedLocalBoundsForCancelButton.setSize(cancelButtonSizeBasedOnFontSize);
2031         return adjustedLocalBoundsForCancelButton;
2032     };
2033 
2034     if (!box.element())
2035         return false;
2036     Element* input = box.element()-&gt;shadowHost();
2037     if (!input)
2038         input = box.element();
2039 
2040     if (!is&lt;RenderBox&gt;(input-&gt;renderer()))
2041         return false;
2042 
2043     const RenderBox&amp; inputBox = downcast&lt;RenderBox&gt;(*input-&gt;renderer());
2044     LocalCurrentGraphicsContext localContext(paintInfo.context());
2045     setSearchCellState(inputBox, r);
2046 
2047     NSSearchFieldCell* search = this-&gt;search();
2048 
2049     if (!input-&gt;isDisabledFormControl() &amp;&amp; (is&lt;HTMLTextFormControlElement&gt;(*input) &amp;&amp; !downcast&lt;HTMLTextFormControlElement&gt;(*input).isReadOnly()))
2050         updatePressedState([search cancelButtonCell], box);
2051     else if ([[search cancelButtonCell] isHighlighted])
2052         [[search cancelButtonCell] setHighlighted:NO];
2053 
2054     GraphicsContextStateSaver stateSaver(paintInfo.context());
2055     FloatRect localBounds = adjustedCancelButtonRect([search cancelButtonRectForBounds:NSRect(snappedIntRect(inputBox.contentBoxRect()))]);
2056     // Set the original horizontal position back (cancelButtonRectForBounds() moves it based on the system direction).
2057     localBounds.setX(inputBox.contentBoxRect().x() + box.x());
2058     FloatPoint paintingPos = convertToPaintingPosition(inputBox, box, localBounds.location(), r.location());
2059 
2060     FloatRect unzoomedRect(paintingPos, localBounds.size());
2061     auto zoomLevel = box.style().effectiveZoom();
2062     if (zoomLevel != 1.0f) {
2063         unzoomedRect.setSize(unzoomedRect.size() / zoomLevel);
2064         paintInfo.context().translate(unzoomedRect.location());
2065         paintInfo.context().scale(zoomLevel);
2066         paintInfo.context().translate(-unzoomedRect.location());
2067     }
2068     [[search cancelButtonCell] drawWithFrame:unzoomedRect inView:documentViewFor(box)];
2069     [[search cancelButtonCell] setControlView:nil];
2070     return false;
2071 }
2072 
2073 const IntSize* RenderThemeMac::cancelButtonSizes() const
2074 {
2075     static const IntSize sizes[3] = { IntSize(22, 22), IntSize(19, 19), IntSize(15, 15) };
2076     return sizes;
2077 }
2078 
2079 void RenderThemeMac::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
2080 {
2081     IntSize size = sizeForSystemFont(style, cancelButtonSizes());
2082     style.setWidth(Length(size.width(), Fixed));
2083     style.setHeight(Length(size.height(), Fixed));
2084     style.setBoxShadow(nullptr);
2085 }
2086 
2087 const int resultsArrowWidth = 5;
2088 const IntSize* RenderThemeMac::resultsButtonSizes() const
2089 {
2090     static const IntSize sizes[3] = { IntSize(19, 22), IntSize(17, 19), IntSize(17, 15) };
2091     return sizes;
2092 }
2093 
2094 const int emptyResultsOffset = 9;
2095 void RenderThemeMac::adjustSearchFieldDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
2096 {
2097     IntSize size = sizeForSystemFont(style, resultsButtonSizes());
2098     style.setWidth(Length(size.width() - emptyResultsOffset, Fixed));
2099     style.setHeight(Length(size.height(), Fixed));
2100     style.setBoxShadow(nullptr);
2101 }
2102 
2103 bool RenderThemeMac::paintSearchFieldDecorationPart(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
2104 {
2105     return false;
2106 }
2107 
2108 void RenderThemeMac::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
2109 {
2110     IntSize size = sizeForSystemFont(style, resultsButtonSizes());
2111     style.setWidth(Length(size.width(), Fixed));
2112     style.setHeight(Length(size.height(), Fixed));
2113     style.setBoxShadow(nullptr);
2114 }
2115 
2116 bool RenderThemeMac::paintSearchFieldResultsDecorationPart(const RenderBox&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
2117 {
2118     if (!box.element())
2119         return false;
2120     Element* input = box.element()-&gt;shadowHost();
2121     if (!input)
2122         input = box.element();
2123     if (!is&lt;RenderBox&gt;(input-&gt;renderer()))
2124         return false;
2125     
2126     const RenderBox&amp; inputBox = downcast&lt;RenderBox&gt;(*input-&gt;renderer());
2127     LocalCurrentGraphicsContext localContext(paintInfo.context());
2128     setSearchCellState(inputBox, r);
2129 
2130     NSSearchFieldCell* search = this-&gt;search();
2131 
2132     if ([search searchMenuTemplate] != nil)
2133         [search setSearchMenuTemplate:nil];
2134 
2135     FloatRect localBounds = [search searchButtonRectForBounds:NSRect(snappedIntRect(inputBox.borderBoxRect()))];
2136     FloatPoint paintingPos = convertToPaintingPosition(inputBox, box, localBounds.location(), r.location());
2137     localBounds.setLocation(paintingPos);
2138 
2139     [[search searchButtonCell] drawWithFrame:localBounds inView:documentViewFor(box)];
2140     [[search searchButtonCell] setControlView:nil];
2141     return false;
2142 }
2143 
2144 void RenderThemeMac::adjustSearchFieldResultsButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
2145 {
2146     IntSize size = sizeForSystemFont(style, resultsButtonSizes());
2147     style.setWidth(Length(size.width() + resultsArrowWidth, Fixed));
2148     style.setHeight(Length(size.height(), Fixed));
2149     style.setBoxShadow(nullptr);
2150 }
2151 
2152 bool RenderThemeMac::paintSearchFieldResultsButton(const RenderBox&amp; box, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
2153 {
2154     auto adjustedResultButtonRect = [this, &amp;box] (const FloatRect&amp; localBounds) -&gt; FloatRect
2155     {
2156         IntSize buttonSize = sizeForSystemFont(box.style(), resultsButtonSizes());
2157         buttonSize.expand(resultsArrowWidth, 0);
2158         FloatSize diff = localBounds.size() - FloatSize(buttonSize);
2159         if (!diff.isZero())
2160             return localBounds;
2161         // Vertically centered and left aligned.
2162         FloatRect adjustedLocalBounds = localBounds;
2163         adjustedLocalBounds.move(0, floorToDevicePixel(diff.height() / 2, box.document().deviceScaleFactor()));
2164         adjustedLocalBounds.setSize(buttonSize);
2165         return adjustedLocalBounds;
2166     };
2167 
2168     Element* input = box.element()-&gt;shadowHost();
2169     if (!input)
2170         input = box.element();
2171     if (!is&lt;RenderBox&gt;(input-&gt;renderer()))
2172         return false;
2173     
2174     const RenderBox&amp; inputBox = downcast&lt;RenderBox&gt;(*input-&gt;renderer());
2175     LocalCurrentGraphicsContext localContext(paintInfo.context());
2176     setSearchCellState(inputBox, r);
2177 
2178     NSSearchFieldCell* search = this-&gt;search();
2179 
2180     if (![search searchMenuTemplate])
2181         [search setSearchMenuTemplate:searchMenuTemplate()];
2182 
2183     GraphicsContextStateSaver stateSaver(paintInfo.context());
2184     float zoomLevel = box.style().effectiveZoom();
2185 
2186     FloatRect localBounds = adjustedResultButtonRect([search searchButtonRectForBounds:NSRect(snappedIntRect(inputBox.contentBoxRect()))]);
2187     // Adjust position based on the content direction.
2188     float adjustedXPosition;
2189     if (box.style().direction() == TextDirection::RTL)
2190         adjustedXPosition = inputBox.contentBoxRect().maxX() - localBounds.size().width();
2191     else
2192         adjustedXPosition = inputBox.contentBoxRect().x();
2193     localBounds.setX(adjustedXPosition);
2194     FloatPoint paintingPos = convertToPaintingPosition(inputBox, box, localBounds.location(), r.location());
2195     
2196     FloatRect unzoomedRect(paintingPos, localBounds.size());
2197     if (zoomLevel != 1.0f) {
2198         unzoomedRect.setSize(unzoomedRect.size() / zoomLevel);
2199         paintInfo.context().translate(unzoomedRect.location());
2200         paintInfo.context().scale(zoomLevel);
2201         paintInfo.context().translate(-unzoomedRect.location());
2202     }
2203 
2204     [[search searchButtonCell] drawWithFrame:unzoomedRect inView:documentViewFor(box)];
2205     [[search searchButtonCell] setControlView:nil];
2206 
2207     return false;
2208 }
2209 
2210 bool RenderThemeMac::paintSnapshottedPluginOverlay(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const IntRect&amp;)
2211 {
2212     if (paintInfo.phase != PaintPhase::BlockBackground)
2213         return true;
2214 
2215     if (!is&lt;RenderBlock&gt;(renderer))
2216         return true;
2217 
2218     const RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(renderer);
2219 
2220     LayoutUnit contentWidth = renderBlock.contentWidth();
2221     LayoutUnit contentHeight = renderBlock.contentHeight();
2222     if (!contentWidth || !contentHeight)
2223         return true;
2224 
2225     GraphicsContext&amp; context = paintInfo.context();
2226 
2227     LayoutSize contentSize(contentWidth, contentHeight);
2228     LayoutPoint contentLocation = renderBlock.location();
2229     contentLocation.move(renderBlock.borderLeft() + renderBlock.paddingLeft(), renderBlock.borderTop() + renderBlock.paddingTop());
2230 
2231     LayoutRect rect(contentLocation, contentSize);
2232     IntRect alignedRect = snappedIntRect(rect);
2233     if (alignedRect.width() &lt;= 0 || alignedRect.height() &lt;= 0)
2234         return true;
2235 
2236     // We need to get the snapshot image from the plugin element, which should be available
2237     // from our node. Assuming this node is the plugin overlay element, we should get to the
2238     // plugin itself by asking for the shadow root parent, and then its parent.
2239 
2240     if (!is&lt;HTMLElement&gt;(*renderBlock.element()))
2241         return true;
2242 
2243     HTMLElement&amp; plugInOverlay = downcast&lt;HTMLElement&gt;(*renderBlock.element());
2244     Element* parent = plugInOverlay.parentOrShadowHostElement();
2245     while (parent &amp;&amp; !is&lt;HTMLPlugInElement&gt;(*parent))
2246         parent = parent-&gt;parentOrShadowHostElement();
2247 
2248     if (!parent)
2249         return true;
2250 
2251     HTMLPlugInElement&amp; plugInElement = downcast&lt;HTMLPlugInElement&gt;(*parent);
2252     if (!is&lt;HTMLPlugInImageElement&gt;(plugInElement))
2253         return true;
2254 
2255     HTMLPlugInImageElement&amp; plugInImageElement = downcast&lt;HTMLPlugInImageElement&gt;(plugInElement);
2256 
2257     Image* snapshot = plugInImageElement.snapshotImage();
2258     if (!snapshot)
2259         return true;
2260 
2261     RenderSnapshottedPlugIn&amp; plugInRenderer = downcast&lt;RenderSnapshottedPlugIn&gt;(*plugInImageElement.renderer());
2262     FloatPoint snapshotAbsPos = plugInRenderer.localToAbsolute();
2263     snapshotAbsPos.move(plugInRenderer.borderLeft() + plugInRenderer.paddingLeft(), plugInRenderer.borderTop() + plugInRenderer.paddingTop());
2264 
2265     // We could draw the snapshot with that coordinates, but we need to make sure there
2266     // isn&#39;t a composited layer between us and the plugInRenderer.
2267     for (auto* renderBox = &amp;downcast&lt;RenderBox&gt;(renderer); renderBox != &amp;plugInRenderer; renderBox = renderBox-&gt;parentBox()) {
2268         if (renderBox-&gt;isComposited()) {
2269             snapshotAbsPos = -renderBox-&gt;location();
2270             break;
2271         }
2272     }
2273 
2274     LayoutSize pluginSize(plugInRenderer.contentWidth(), plugInRenderer.contentHeight());
2275     LayoutRect pluginRect(snapshotAbsPos, pluginSize);
2276     IntRect alignedPluginRect = snappedIntRect(pluginRect);
2277 
2278     if (alignedPluginRect.width() &lt;= 0 || alignedPluginRect.height() &lt;= 0)
2279         return true;
2280 
2281     context.drawImage(*snapshot, alignedPluginRect);
2282     return false;
2283 }
2284 
2285 #if ENABLE(DATALIST_ELEMENT)
2286 IntSize RenderThemeMac::sliderTickSize() const
2287 {
2288     return IntSize(1, 3);
2289 }
2290 
2291 int RenderThemeMac::sliderTickOffsetFromTrackCenter() const
2292 {
2293     return -9;
2294 }
2295 #endif
2296 
2297 const int sliderThumbWidth = 15;
2298 const int sliderThumbHeight = 15;
2299 
2300 void RenderThemeMac::adjustSliderThumbSize(RenderStyle&amp; style, const Element*) const
2301 {
2302     float zoomLevel = style.effectiveZoom();
2303     if (style.appearance() == SliderThumbHorizontalPart || style.appearance() == SliderThumbVerticalPart) {
2304         style.setWidth(Length(static_cast&lt;int&gt;(sliderThumbWidth * zoomLevel), Fixed));
2305         style.setHeight(Length(static_cast&lt;int&gt;(sliderThumbHeight * zoomLevel), Fixed));
2306     }
2307 }
2308 
2309 NSPopUpButtonCell* RenderThemeMac::popupButton() const
2310 {
2311     if (!m_popupButton) {
2312         m_popupButton = adoptNS([[NSPopUpButtonCell alloc] initTextCell:@&quot;&quot; pullsDown:NO]);
2313         [m_popupButton.get() setUsesItemFromMenu:NO];
2314         [m_popupButton.get() setFocusRingType:NSFocusRingTypeExterior];
2315         [m_popupButton setUserInterfaceLayoutDirection:NSUserInterfaceLayoutDirectionLeftToRight];
2316     }
2317 
2318     return m_popupButton.get();
2319 }
2320 
2321 NSSearchFieldCell* RenderThemeMac::search() const
2322 {
2323     if (!m_search) {
2324         m_search = adoptNS([[NSSearchFieldCell alloc] initTextCell:@&quot;&quot;]);
2325         [m_search.get() setBezelStyle:NSTextFieldRoundedBezel];
2326         [m_search.get() setBezeled:YES];
2327         [m_search.get() setEditable:YES];
2328         [m_search.get() setFocusRingType:NSFocusRingTypeExterior];
2329         [m_search.get() setCenteredLook:NO];
2330     }
2331 
2332     return m_search.get();
2333 }
2334 
2335 NSMenu* RenderThemeMac::searchMenuTemplate() const
2336 {
2337     if (!m_searchMenuTemplate)
2338         m_searchMenuTemplate = adoptNS([[NSMenu alloc] initWithTitle:@&quot;&quot;]);
2339 
2340     return m_searchMenuTemplate.get();
2341 }
2342 
2343 NSSliderCell* RenderThemeMac::sliderThumbHorizontal() const
2344 {
2345     if (!m_sliderThumbHorizontal) {
2346         m_sliderThumbHorizontal = adoptNS([[NSSliderCell alloc] init]);
2347         [m_sliderThumbHorizontal.get() setSliderType:NSSliderTypeLinear];
2348         [m_sliderThumbHorizontal.get() setControlSize:NSControlSizeSmall];
2349         [m_sliderThumbHorizontal.get() setFocusRingType:NSFocusRingTypeExterior];
2350     }
2351 
2352     return m_sliderThumbHorizontal.get();
2353 }
2354 
2355 NSSliderCell* RenderThemeMac::sliderThumbVertical() const
2356 {
2357     if (!m_sliderThumbVertical) {
2358         m_sliderThumbVertical = adoptNS([[NSSliderCell alloc] init]);
2359         [m_sliderThumbVertical.get() setSliderType:NSSliderTypeLinear];
2360         [m_sliderThumbVertical.get() setControlSize:NSControlSizeSmall];
2361         [m_sliderThumbVertical.get() setFocusRingType:NSFocusRingTypeExterior];
2362     }
2363 
2364     return m_sliderThumbVertical.get();
2365 }
2366 
2367 NSTextFieldCell* RenderThemeMac::textField() const
2368 {
2369     if (!m_textField) {
2370         m_textField = adoptNS([[WebCoreTextFieldCell alloc] initTextCell:@&quot;&quot;]);
2371         [m_textField.get() setBezeled:YES];
2372         [m_textField.get() setEditable:YES];
2373         [m_textField.get() setFocusRingType:NSFocusRingTypeExterior];
2374         // Post-Lion, WebCore can be in charge of paintinng the background thanks to
2375         // the workaround in place for &lt;rdar://problem/11385461&gt;, which is implemented
2376         // above as _coreUIDrawOptionsWithFrame.
2377         [m_textField.get() setDrawsBackground:NO];
2378     }
2379 
2380     return m_textField.get();
2381 }
2382 
2383 #if ENABLE(DATALIST_ELEMENT)
2384 NSCell *RenderThemeMac::listButton() const
2385 {
2386     if (!m_listButton)
2387         m_listButton = adoptNS([[WebListButtonCell alloc] init]);
2388 
2389     return m_listButton.get();
2390 }
2391 #endif
2392 
2393 String RenderThemeMac::fileListNameForWidth(const FileList* fileList, const FontCascade&amp; font, int width, bool multipleFilesAllowed) const
2394 {
2395     if (width &lt;= 0)
2396         return String();
2397 
2398     String strToTruncate;
2399     if (fileList-&gt;isEmpty())
2400         strToTruncate = fileListDefaultLabel(multipleFilesAllowed);
2401     else if (fileList-&gt;length() == 1)
2402         strToTruncate = [[NSFileManager defaultManager] displayNameAtPath:(fileList-&gt;item(0)-&gt;path())];
2403     else
2404         return StringTruncator::rightTruncate(multipleFileUploadText(fileList-&gt;length()), width, font);
2405 
2406     return StringTruncator::centerTruncate(strToTruncate, width, font);
2407 }
2408 
2409 #if ENABLE(SERVICE_CONTROLS)
2410 NSServicesRolloverButtonCell* RenderThemeMac::servicesRolloverButtonCell() const
2411 {
2412     if (!m_servicesRolloverButton) {
2413         m_servicesRolloverButton = [NSServicesRolloverButtonCell serviceRolloverButtonCellForStyle:NSSharingServicePickerStyleRollover];
2414         [m_servicesRolloverButton setBezelStyle:NSBezelStyleRoundedDisclosure];
2415         [m_servicesRolloverButton setButtonType:NSButtonTypePushOnPushOff];
2416         [m_servicesRolloverButton setImagePosition:NSImageOnly];
2417         [m_servicesRolloverButton setState:NO];
2418     }
2419 
2420     return m_servicesRolloverButton.get();
2421 }
2422 
2423 bool RenderThemeMac::paintImageControlsButton(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
2424 {
2425     if (paintInfo.phase != PaintPhase::BlockBackground)
2426         return true;
2427 
2428     NSServicesRolloverButtonCell *cell = servicesRolloverButtonCell();
2429 
2430     LocalCurrentGraphicsContext localContext(paintInfo.context());
2431     GraphicsContextStateSaver stateSaver(paintInfo.context());
2432 
2433     paintInfo.context().translate(rect.location());
2434 
2435     IntRect innerFrame(IntPoint(), rect.size());
2436     [cell drawWithFrame:innerFrame inView:documentViewFor(renderer)];
2437     [cell setControlView:nil];
2438 
2439     return true;
2440 }
2441 
2442 IntSize RenderThemeMac::imageControlsButtonSize(const RenderObject&amp;) const
2443 {
2444     return IntSize(servicesRolloverButtonCell().cellSize);
2445 }
2446 
2447 IntSize RenderThemeMac::imageControlsButtonPositionOffset() const
2448 {
2449     // FIXME: Currently the offsets will always be the same no matter what image rect you try with.
2450     // This may not always be true in the future.
2451     static const int dummyDimension = 100;
2452     IntRect dummyImageRect(0, 0, dummyDimension, dummyDimension);
2453     NSRect bounds = [servicesRolloverButtonCell() rectForBounds:dummyImageRect preferredEdge:NSMinYEdge];
2454 
2455     return IntSize(dummyDimension - bounds.origin.x, bounds.origin.y);
2456 }
2457 #endif
2458 
2459 #if ENABLE(ATTACHMENT_ELEMENT)
2460 const CGFloat attachmentIconSize = 48;
2461 const CGFloat attachmentIconBackgroundPadding = 6;
2462 const CGFloat attachmentIconBackgroundSize = attachmentIconSize + attachmentIconBackgroundPadding;
2463 const CGFloat attachmentIconSelectionBorderThickness = 1;
2464 const CGFloat attachmentIconBackgroundRadius = 3;
2465 const CGFloat attachmentIconToTitleMargin = 2;
2466 
2467 static Color attachmentIconBackgroundColor() { return Color(0, 0, 0, 30); }
2468 static Color attachmentIconBorderColor() { return Color(255, 255, 255, 125); }
2469 
2470 const CGFloat attachmentTitleFontSize = 12;
2471 const CGFloat attachmentTitleBackgroundRadius = 3;
2472 const CGFloat attachmentTitleBackgroundPadding = 3;
2473 const CGFloat attachmentTitleMaximumWidth = 100 - (attachmentTitleBackgroundPadding * 2);
2474 const CFIndex attachmentTitleMaximumLineCount = 2;
2475 
2476 static Color attachmentTitleInactiveBackgroundColor() { return Color(204, 204, 204, 255); }
2477 static Color attachmentTitleInactiveTextColor() { return Color(100, 100, 100, 255); }
2478 
2479 const CGFloat attachmentSubtitleFontSize = 10;
2480 const int attachmentSubtitleWidthIncrement = 10;
2481 static Color attachmentSubtitleTextColor() { return Color(82, 145, 214, 255); }
2482 
2483 const CGFloat attachmentProgressBarWidth = 30;
2484 const CGFloat attachmentProgressBarHeight = 5;
2485 const CGFloat attachmentProgressBarOffset = -9;
2486 const CGFloat attachmentProgressBarBorderWidth = 1;
2487 static Color attachmentProgressBarBackgroundColor() { return Color(0, 0, 0, 89); }
2488 static Color attachmentProgressBarFillColor() { return Color(Color::white); }
2489 static Color attachmentProgressBarBorderColor() { return Color(0, 0, 0, 128); }
2490 
2491 const CGFloat attachmentPlaceholderBorderRadius = 5;
2492 static Color attachmentPlaceholderBorderColor() { return Color(0, 0, 0, 56); }
2493 const CGFloat attachmentPlaceholderBorderWidth = 2;
2494 const CGFloat attachmentPlaceholderBorderDashLength = 6;
2495 
2496 const CGFloat attachmentMargin = 3;
2497 
2498 enum class AttachmentLayoutStyle : uint8_t { NonSelected, Selected };
2499 
2500 struct AttachmentLayout {
2501     explicit AttachmentLayout(const RenderAttachment&amp;, AttachmentLayoutStyle);
2502 
2503     struct LabelLine {
2504         FloatRect backgroundRect;
2505         FloatPoint origin;
2506         RetainPtr&lt;CTLineRef&gt; line;
2507     };
2508 
2509     Vector&lt;LabelLine&gt; lines;
2510 
2511     FloatRect iconRect;
2512     FloatRect iconBackgroundRect;
2513     FloatRect attachmentRect;
2514 
2515     int baseline;
2516     AttachmentLayoutStyle style;
2517 
2518     RetainPtr&lt;CTLineRef&gt; subtitleLine;
2519     FloatRect subtitleTextRect;
2520 
2521 private:
2522     void layOutTitle(const RenderAttachment&amp;);
2523     void layOutSubtitle(const RenderAttachment&amp;);
2524 
2525     void addTitleLine(CTLineRef, CGFloat&amp; yOffset, Vector&lt;CGPoint&gt; origins, CFIndex lineIndex, const RenderAttachment&amp;);
2526 };
2527 
2528 static Color titleTextColorForAttachment(const RenderAttachment&amp; attachment, AttachmentLayoutStyle style)
2529 {
2530     Color result = Color::black;
2531     
2532     if (style == AttachmentLayoutStyle::Selected) {
2533         if (attachment.frame().selection().isFocusedAndActive())
2534             result = colorFromNSColor([NSColor alternateSelectedControlTextColor]);
2535         else
2536             result = attachmentTitleInactiveTextColor();
2537     }
2538 
2539     return attachment.style().colorByApplyingColorFilter(result);
2540 }
2541 
2542 void AttachmentLayout::addTitleLine(CTLineRef line, CGFloat&amp; yOffset, Vector&lt;CGPoint&gt; origins, CFIndex lineIndex, const RenderAttachment&amp; attachment)
2543 {
2544     CGRect lineBounds = CTLineGetBoundsWithOptions(line, 0);
2545     CGFloat trailingWhitespaceWidth = CTLineGetTrailingWhitespaceWidth(line);
2546     CGFloat lineWidthIgnoringTrailingWhitespace = lineBounds.size.width - trailingWhitespaceWidth;
2547     CGFloat lineHeight = CGCeiling(lineBounds.size.height);
2548 
2549     // Center the line relative to the icon.
2550     CGFloat xOffset = (attachmentIconBackgroundSize / 2) - (lineWidthIgnoringTrailingWhitespace / 2);
2551 
2552     if (lineIndex)
2553         yOffset += origins[lineIndex - 1].y - origins[lineIndex].y;
2554 
2555     LabelLine labelLine;
2556     labelLine.origin = FloatPoint(xOffset, yOffset + lineHeight - origins.last().y);
2557     labelLine.line = line;
2558     labelLine.backgroundRect = FloatRect(xOffset, yOffset, lineWidthIgnoringTrailingWhitespace, lineHeight);
2559     labelLine.backgroundRect.inflateX(attachmentTitleBackgroundPadding);
2560     labelLine.backgroundRect = encloseRectToDevicePixels(labelLine.backgroundRect, attachment.document().deviceScaleFactor());
2561 
2562     // If the text rects are close in size, the curved enclosing background won&#39;t
2563     // look right, so make them the same exact size.
2564     if (!lines.isEmpty()) {
2565         float previousBackgroundRectWidth = lines.last().backgroundRect.width();
2566         if (fabs(labelLine.backgroundRect.width() - previousBackgroundRectWidth) &lt; attachmentTitleBackgroundRadius * 4) {
2567             float newBackgroundRectWidth = std::max(previousBackgroundRectWidth, labelLine.backgroundRect.width());
2568             labelLine.backgroundRect.inflateX((newBackgroundRectWidth - labelLine.backgroundRect.width()) / 2);
2569             lines.last().backgroundRect.inflateX((newBackgroundRectWidth - previousBackgroundRectWidth) / 2);
2570         }
2571     }
2572 
2573     lines.append(labelLine);
2574 }
2575 
2576 void AttachmentLayout::layOutTitle(const RenderAttachment&amp; attachment)
2577 {
2578     CFStringRef language = 0; // By not specifying a language we use the system language.
2579     RetainPtr&lt;CTFontRef&gt; font = adoptCF(CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, attachmentTitleFontSize, language));
2580     baseline = CGRound(attachmentIconBackgroundSize + attachmentIconToTitleMargin + CTFontGetAscent(font.get()));
2581 
2582     String title = attachment.attachmentElement().attachmentTitleForDisplay();
2583     if (title.isEmpty())
2584         return;
2585 
2586     NSDictionary *textAttributes = @{
2587         (__bridge id)kCTFontAttributeName: (__bridge id)font.get(),
2588         (__bridge id)kCTForegroundColorAttributeName: (__bridge NSColor *)cachedCGColor(titleTextColorForAttachment(attachment, style))
2589     };
2590     RetainPtr&lt;NSAttributedString&gt; attributedTitle = adoptNS([[NSAttributedString alloc] initWithString:title attributes:textAttributes]);
2591     RetainPtr&lt;CTFramesetterRef&gt; titleFramesetter = adoptCF(CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributedTitle.get()));
2592 
2593     CFRange fitRange;
2594     CGSize titleTextSize = CTFramesetterSuggestFrameSizeWithConstraints(titleFramesetter.get(), CFRangeMake(0, 0), nullptr, CGSizeMake(attachmentTitleMaximumWidth, CGFLOAT_MAX), &amp;fitRange);
2595 
2596     RetainPtr&lt;CGPathRef&gt; titlePath = adoptCF(CGPathCreateWithRect(CGRectMake(0, 0, titleTextSize.width, titleTextSize.height), nullptr));
2597     RetainPtr&lt;CTFrameRef&gt; titleFrame = adoptCF(CTFramesetterCreateFrame(titleFramesetter.get(), fitRange, titlePath.get(), nullptr));
2598 
2599     CFArrayRef ctLines = CTFrameGetLines(titleFrame.get());
2600     CFIndex lineCount = CFArrayGetCount(ctLines);
2601     if (!lineCount)
2602         return;
2603 
2604     Vector&lt;CGPoint&gt; origins(lineCount);
2605     CTFrameGetLineOrigins(titleFrame.get(), CFRangeMake(0, 0), origins.data());
2606 
2607     // Lay out and record the first (attachmentTitleMaximumLineCount - 1) lines.
2608     CFIndex lineIndex = 0;
2609     CGFloat yOffset = attachmentIconBackgroundSize + attachmentIconToTitleMargin;
2610     for (; lineIndex &lt; std::min(attachmentTitleMaximumLineCount - 1, lineCount); ++lineIndex) {
2611         CTLineRef line = (CTLineRef)CFArrayGetValueAtIndex(ctLines, lineIndex);
2612         addTitleLine(line, yOffset, origins, lineIndex, attachment);
2613     }
2614 
2615     if (lineIndex == lineCount)
2616         return;
2617 
2618     // We had text that didn&#39;t fit in the first (attachmentTitleMaximumLineCount - 1) lines.
2619     // Combine it into one last line, and center-truncate it.
2620     CTLineRef firstRemainingLine = (CTLineRef)CFArrayGetValueAtIndex(ctLines, lineIndex);
2621     CFIndex remainingRangeStart = CTLineGetStringRange(firstRemainingLine).location;
2622     CFRange remainingRange = CFRangeMake(remainingRangeStart, [attributedTitle length] - remainingRangeStart);
2623     RetainPtr&lt;CGPathRef&gt; remainingPath = adoptCF(CGPathCreateWithRect(CGRectMake(0, 0, CGFLOAT_MAX, CGFLOAT_MAX), nullptr));
2624     RetainPtr&lt;CTFrameRef&gt; remainingFrame = adoptCF(CTFramesetterCreateFrame(titleFramesetter.get(), remainingRange, remainingPath.get(), nullptr));
2625     RetainPtr&lt;NSAttributedString&gt; ellipsisString = adoptNS([[NSAttributedString alloc] initWithString:@&quot;\u2026&quot; attributes:textAttributes]);
2626     RetainPtr&lt;CTLineRef&gt; ellipsisLine = adoptCF(CTLineCreateWithAttributedString((CFAttributedStringRef)ellipsisString.get()));
2627     CTLineRef remainingLine = (CTLineRef)CFArrayGetValueAtIndex(CTFrameGetLines(remainingFrame.get()), 0);
2628     RetainPtr&lt;CTLineRef&gt; truncatedLine = adoptCF(CTLineCreateTruncatedLine(remainingLine, attachmentTitleMaximumWidth, kCTLineTruncationMiddle, ellipsisLine.get()));
2629 
2630     if (!truncatedLine)
2631         truncatedLine = remainingLine;
2632 
2633     addTitleLine(truncatedLine.get(), yOffset, origins, lineIndex, attachment);
2634 }
2635 
2636 void AttachmentLayout::layOutSubtitle(const RenderAttachment&amp; attachment)
2637 {
2638     auto&amp; subtitleText = attachment.attachmentElement().attributeWithoutSynchronization(subtitleAttr);
2639     if (subtitleText.isEmpty())
2640         return;
2641 
2642     Color subtitleColor = attachment.style().colorByApplyingColorFilter(attachmentSubtitleTextColor());
2643     CFStringRef language = 0; // By not specifying a language we use the system language.
2644     RetainPtr&lt;CTFontRef&gt; font = adoptCF(CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, attachmentSubtitleFontSize, language));
2645     NSDictionary *textAttributes = @{
2646         (__bridge id)kCTFontAttributeName: (__bridge id)font.get(),
2647         (__bridge id)kCTForegroundColorAttributeName: (__bridge NSColor *)cachedCGColor(subtitleColor)
2648     };
2649     RetainPtr&lt;NSAttributedString&gt; attributedSubtitleText = adoptNS([[NSAttributedString alloc] initWithString:subtitleText attributes:textAttributes]);
2650     subtitleLine = adoptCF(CTLineCreateWithAttributedString((CFAttributedStringRef)attributedSubtitleText.get()));
2651 
2652     CGRect lineBounds = CTLineGetBoundsWithOptions(subtitleLine.get(), 0);
2653 
2654     // Center the line relative to the icon.
2655     CGFloat xOffset = (attachmentIconBackgroundSize / 2) - (lineBounds.size.width / 2);
2656     CGFloat yOffset = 0;
2657 
2658     if (!lines.isEmpty())
2659         yOffset = lines.last().backgroundRect.maxY();
2660     else
2661         yOffset = attachmentIconBackgroundSize + attachmentIconToTitleMargin;
2662 
2663     LabelLine labelLine;
2664     subtitleTextRect = FloatRect(xOffset, yOffset, lineBounds.size.width, lineBounds.size.height);
2665 }
2666 
2667 AttachmentLayout::AttachmentLayout(const RenderAttachment&amp; attachment, AttachmentLayoutStyle layoutStyle)
2668     : style(layoutStyle)
2669 {
2670     layOutTitle(attachment);
2671     layOutSubtitle(attachment);
2672 
2673     iconBackgroundRect = FloatRect(0, 0, attachmentIconBackgroundSize, attachmentIconBackgroundSize);
2674 
2675     iconRect = iconBackgroundRect;
2676     iconRect.setSize(FloatSize(attachmentIconSize, attachmentIconSize));
2677     iconRect.move(attachmentIconBackgroundPadding / 2, attachmentIconBackgroundPadding / 2);
2678 
2679     attachmentRect = iconBackgroundRect;
2680     for (const auto&amp; line : lines)
2681         attachmentRect.unite(line.backgroundRect);
2682     if (!subtitleTextRect.isEmpty()) {
2683         FloatRect roundedSubtitleTextRect = subtitleTextRect;
2684         roundedSubtitleTextRect.inflateX(attachmentSubtitleWidthIncrement - clampToInteger(ceilf(subtitleTextRect.width())) % attachmentSubtitleWidthIncrement);
2685         attachmentRect.unite(roundedSubtitleTextRect);
2686     }
2687     attachmentRect.inflate(attachmentMargin);
2688     attachmentRect = encloseRectToDevicePixels(attachmentRect, attachment.document().deviceScaleFactor());
2689 }
2690 
2691 LayoutSize RenderThemeMac::attachmentIntrinsicSize(const RenderAttachment&amp; attachment) const
2692 {
2693     AttachmentLayout layout(attachment, AttachmentLayoutStyle::NonSelected);
2694     return LayoutSize(layout.attachmentRect.size());
2695 }
2696 
2697 int RenderThemeMac::attachmentBaseline(const RenderAttachment&amp; attachment) const
2698 {
2699     AttachmentLayout layout(attachment, AttachmentLayoutStyle::NonSelected);
2700     return layout.baseline;
2701 }
2702 
2703 static void paintAttachmentIconBackground(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2704 {
2705     if (layout.style == AttachmentLayoutStyle::NonSelected)
2706         return;
2707 
2708     // FIXME: Finder has a discontinuous behavior here when you have a background color other than white,
2709     // where it switches into &#39;bordered mode&#39; and the border pops in on top of the background.
2710     bool paintBorder = true;
2711 
2712     FloatRect backgroundRect = layout.iconBackgroundRect;
2713     if (paintBorder)
2714         backgroundRect.inflate(-attachmentIconSelectionBorderThickness);
2715 
2716     Color backgroundColor = attachment.style().colorByApplyingColorFilter(attachmentIconBackgroundColor());
2717     context.fillRoundedRect(FloatRoundedRect(backgroundRect, FloatRoundedRect::Radii(attachmentIconBackgroundRadius)), backgroundColor);
2718 
2719     if (paintBorder) {
2720         FloatRect borderRect = layout.iconBackgroundRect;
2721         borderRect.inflate(-attachmentIconSelectionBorderThickness / 2);
2722 
2723         FloatSize iconBackgroundRadiusSize(attachmentIconBackgroundRadius, attachmentIconBackgroundRadius);
2724         Path borderPath;
2725         borderPath.addRoundedRect(borderRect, iconBackgroundRadiusSize);
2726 
2727         Color borderColor = attachment.style().colorByApplyingColorFilter(attachmentIconBorderColor());
2728         context.setStrokeColor(borderColor);
2729         context.setStrokeThickness(attachmentIconSelectionBorderThickness);
2730         context.strokePath(borderPath);
2731     }
2732 }
2733 
2734 static RefPtr&lt;Icon&gt; iconForAttachment(const RenderAttachment&amp; attachment)
2735 {
2736     String attachmentType = attachment.attachmentElement().attachmentType();
2737     
2738     if (!attachmentType.isEmpty()) {
2739         if (equalIgnoringASCIICase(attachmentType, &quot;multipart/x-folder&quot;) || equalIgnoringASCIICase(attachmentType, &quot;application/vnd.apple.folder&quot;)) {
2740             if (auto icon = Icon::createIconForUTI(kUTTypeFolder))
2741                 return icon;
2742         } else {
2743             String UTI;
2744             if (isDeclaredUTI(attachmentType))
2745                 UTI = attachmentType;
2746             else
2747                 UTI = UTIFromMIMEType(attachmentType);
2748 
2749             if (auto icon = Icon::createIconForUTI(UTI))
2750                 return icon;
2751         }
2752     }
2753 
2754     if (File* file = attachment.attachmentElement().file()) {
2755         if (auto icon = Icon::createIconForFiles({ file-&gt;path() }))
2756             return icon;
2757     }
2758 
2759     NSString *fileExtension = [static_cast&lt;NSString *&gt;(attachment.attachmentElement().attachmentTitle()) pathExtension];
2760     if (fileExtension.length) {
2761         if (auto icon = Icon::createIconForFileExtension(fileExtension))
2762             return icon;
2763     }
2764 
2765     return Icon::createIconForUTI(&quot;public.data&quot;);
2766 }
2767 
2768 static void paintAttachmentIcon(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2769 {
2770     auto icon = iconForAttachment(attachment);
2771     if (!icon)
2772         return;
2773     icon-&gt;paint(context, layout.iconRect);
2774 }
2775 
2776 static void paintAttachmentIconPlaceholder(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2777 {
2778     RefPtr&lt;Image&gt; placeholderImage;
2779     float imageScale = 1;
2780     if (attachment.document().deviceScaleFactor() &gt;= 2) {
2781         placeholderImage = Image::loadPlatformResource(&quot;AttachmentPlaceholder@2x&quot;);
2782         imageScale = 2;
2783     } else
2784         placeholderImage = Image::loadPlatformResource(&quot;AttachmentPlaceholder&quot;);
2785 
2786     // Center the placeholder image where the icon would usually be.
2787     FloatRect placeholderRect(0, 0, placeholderImage-&gt;width() / imageScale, placeholderImage-&gt;height() / imageScale);
2788     placeholderRect.setX(layout.iconRect.x() + (layout.iconRect.width() - placeholderRect.width()) / 2);
2789     placeholderRect.setY(layout.iconRect.y() + (layout.iconRect.height() - placeholderRect.height()) / 2);
2790 
2791     context.drawImage(*placeholderImage, placeholderRect);
2792 }
2793 
2794 static void paintAttachmentTitleBackground(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2795 {
2796     if (layout.style == AttachmentLayoutStyle::NonSelected)
2797         return;
2798 
2799     if (layout.lines.isEmpty())
2800         return;
2801 
2802     Vector&lt;FloatRect&gt; backgroundRects;
2803 
2804     for (size_t i = 0; i &lt; layout.lines.size(); ++i)
2805         backgroundRects.append(layout.lines[i].backgroundRect);
2806 
2807     Color backgroundColor;
2808     if (attachment.frame().selection().isFocusedAndActive())
2809         backgroundColor = colorFromNSColor([NSColor alternateSelectedControlColor]);
2810     else
2811         backgroundColor = attachmentTitleInactiveBackgroundColor();
2812 
2813     backgroundColor = attachment.style().colorByApplyingColorFilter(backgroundColor);
2814     context.setFillColor(backgroundColor);
2815 
2816     Path backgroundPath = PathUtilities::pathWithShrinkWrappedRects(backgroundRects, attachmentTitleBackgroundRadius);
2817     context.fillPath(backgroundPath);
2818 }
2819 
2820 static void paintAttachmentTitle(const RenderAttachment&amp;, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2821 {
2822     for (const auto&amp; line : layout.lines) {
2823         GraphicsContextStateSaver saver(context);
2824 
2825         context.translate(toFloatSize(line.origin));
2826         context.scale(FloatSize(1, -1));
2827 
2828         CGContextSetTextPosition(context.platformContext(), 0, 0);
2829         CTLineDraw(line.line.get(), context.platformContext());
2830     }
2831 }
2832 
2833 static void paintAttachmentSubtitle(const RenderAttachment&amp;, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2834 {
2835     GraphicsContextStateSaver saver(context);
2836 
2837     context.translate(toFloatSize(layout.subtitleTextRect.minXMaxYCorner()));
2838     context.scale(FloatSize(1, -1));
2839 
2840     CGContextSetTextPosition(context.platformContext(), 0, 0);
2841     CTLineDraw(layout.subtitleLine.get(), context.platformContext());
2842 }
2843 
2844 static void paintAttachmentProgress(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout, float progress)
2845 {
2846     GraphicsContextStateSaver saver(context);
2847 
2848     FloatRect progressBounds((attachmentIconBackgroundSize - attachmentProgressBarWidth) / 2, layout.iconBackgroundRect.maxY() + attachmentProgressBarOffset - attachmentProgressBarHeight, attachmentProgressBarWidth, attachmentProgressBarHeight);
2849 
2850     FloatRect borderRect = progressBounds;
2851     borderRect.inflate(-0.5);
2852     FloatRect backgroundRect = borderRect;
2853     backgroundRect.inflate(-attachmentProgressBarBorderWidth / 2);
2854 
2855     FloatRoundedRect backgroundRoundedRect(backgroundRect, FloatRoundedRect::Radii(backgroundRect.height() / 2));
2856     context.fillRoundedRect(backgroundRoundedRect, attachmentProgressBarBackgroundColor());
2857 
2858     {
2859         GraphicsContextStateSaver clipSaver(context);
2860         context.clipRoundedRect(backgroundRoundedRect);
2861 
2862         FloatRect progressRect = progressBounds;
2863         progressRect.setWidth(progressRect.width() * progress);
2864         progressRect = encloseRectToDevicePixels(progressRect, attachment.document().deviceScaleFactor());
2865 
2866         context.fillRect(progressRect, attachmentProgressBarFillColor());
2867     }
2868 
2869     Path borderPath;
2870     float borderRadius = borderRect.height() / 2;
2871     borderPath.addRoundedRect(borderRect, FloatSize(borderRadius, borderRadius));
2872     context.setStrokeColor(attachmentProgressBarBorderColor());
2873     context.setStrokeThickness(attachmentProgressBarBorderWidth);
2874     context.strokePath(borderPath);
2875 }
2876 
2877 static void paintAttachmentPlaceholderBorder(const RenderAttachment&amp; attachment, GraphicsContext&amp; context, AttachmentLayout&amp; layout)
2878 {
2879     Path borderPath;
2880     borderPath.addRoundedRect(layout.attachmentRect, FloatSize(attachmentPlaceholderBorderRadius, attachmentPlaceholderBorderRadius));
2881 
2882     Color placeholderBorderColor = attachment.style().colorByApplyingColorFilter(attachmentPlaceholderBorderColor());
2883     context.setStrokeColor(placeholderBorderColor);
2884     context.setStrokeThickness(attachmentPlaceholderBorderWidth);
2885     context.setStrokeStyle(DashedStroke);
2886     context.setLineDash({attachmentPlaceholderBorderDashLength}, 0);
2887     context.strokePath(borderPath);
2888 }
2889 
2890 bool RenderThemeMac::paintAttachment(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const IntRect&amp; paintRect)
2891 {
2892     if (!is&lt;RenderAttachment&gt;(renderer))
2893         return false;
2894 
2895     const RenderAttachment&amp; attachment = downcast&lt;RenderAttachment&gt;(renderer);
2896 
2897     auto layoutStyle = AttachmentLayoutStyle::NonSelected;
2898     if (attachment.selectionState() != RenderObject::SelectionNone &amp;&amp; paintInfo.phase != PaintPhase::Selection)
2899         layoutStyle = AttachmentLayoutStyle::Selected;
2900 
2901     AttachmentLayout layout(attachment, layoutStyle);
2902 
2903     auto&amp; progressString = attachment.attachmentElement().attributeWithoutSynchronization(progressAttr);
2904     bool validProgress = false;
2905     float progress = 0;
2906     if (!progressString.isEmpty())
2907         progress = progressString.toFloat(&amp;validProgress);
2908 
2909     GraphicsContext&amp; context = paintInfo.context();
2910     LocalCurrentGraphicsContext localContext(context);
2911     GraphicsContextStateSaver saver(context);
2912 
2913     context.translate(toFloatSize(paintRect.location()));
2914     context.translate(floorSizeToDevicePixels({ LayoutUnit((paintRect.width() - attachmentIconBackgroundSize) / 2), 0 }, renderer.document().deviceScaleFactor()));
2915 
2916     bool usePlaceholder = validProgress &amp;&amp; !progress;
2917 
2918     paintAttachmentIconBackground(attachment, context, layout);
2919     if (usePlaceholder)
2920         paintAttachmentIconPlaceholder(attachment, context, layout);
2921     else
2922         paintAttachmentIcon(attachment, context, layout);
2923 
2924     paintAttachmentTitleBackground(attachment, context, layout);
2925     paintAttachmentTitle(attachment, context, layout);
2926     paintAttachmentSubtitle(attachment, context, layout);
2927 
2928     if (validProgress &amp;&amp; progress)
2929         paintAttachmentProgress(attachment, context, layout, progress);
2930 
2931     if (usePlaceholder)
2932         paintAttachmentPlaceholderBorder(attachment, context, layout);
2933 
2934     return true;
2935 }
2936 
2937 #endif // ENABLE(ATTACHMENT_ELEMENT)
2938 
2939 } // namespace WebCore
2940 
2941 #endif // PLATFORM(MAC)
    </pre>
  </body>
</html>