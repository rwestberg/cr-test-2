<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;SerializedScriptValue.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  44 #include &quot;StorageQuotaManager.h&quot;</span>
  45 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  46 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<a name="2" id="anc2"></a><span class="line-modified">  47 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
  48 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<a name="3" id="anc3"></a>
  49 #include &lt;wtf/MainThread.h&gt;
  50 #include &lt;wtf/NeverDestroyed.h&gt;
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 
<a name="4" id="anc4"></a><span class="line-added">  57 static const uint64_t defaultWriteOperationCost = 4;</span>
<span class="line-added">  58 </span>
<span class="line-added">  59 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)</span>
<span class="line-added">  60 {</span>
<span class="line-added">  61     uint64_t size = 4;</span>
<span class="line-added">  62     switch (keyData.type()) {</span>
<span class="line-added">  63     case IndexedDB::KeyType::String:</span>
<span class="line-added">  64         size += keyData.string().sizeInBytes();</span>
<span class="line-added">  65         break;</span>
<span class="line-added">  66     case IndexedDB::KeyType::Binary: {</span>
<span class="line-added">  67         size += keyData.binary().size();</span>
<span class="line-added">  68         break;</span>
<span class="line-added">  69     }</span>
<span class="line-added">  70     case IndexedDB::KeyType::Array:</span>
<span class="line-added">  71         for (auto&amp; data : keyData.array())</span>
<span class="line-added">  72             size += estimateSize(data);</span>
<span class="line-added">  73         break;</span>
<span class="line-added">  74     default:</span>
<span class="line-added">  75         break;</span>
<span class="line-added">  76     }</span>
<span class="line-added">  77     return size;</span>
<span class="line-added">  78 }</span>
<span class="line-added">  79 </span>
<span class="line-added">  80 static inline uint64_t estimateSize(const IDBValue&amp; value)</span>
<span class="line-added">  81 {</span>
<span class="line-added">  82     uint64_t size = 4;</span>
<span class="line-added">  83     size += value.data().size();</span>
<span class="line-added">  84     for (auto&amp; url : value.blobURLs())</span>
<span class="line-added">  85         size += url.sizeInBytes();</span>
<span class="line-added">  86     for (auto&amp; path : value.blobFilePaths())</span>
<span class="line-added">  87         size += path.sizeInBytes();</span>
<span class="line-added">  88     return size;</span>
<span class="line-added">  89 }</span>
<span class="line-added">  90 </span>
<span class="line-added">  91 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)</span>
<span class="line-added">  92 {</span>
<span class="line-added">  93     uint64_t size = 4;</span>
<span class="line-added">  94     size += info.name().sizeInBytes();</span>
<span class="line-added">  95     return size;</span>
<span class="line-added">  96 }</span>
<span class="line-added">  97 </span>
<span class="line-added">  98 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)</span>
<span class="line-added">  99 {</span>
<span class="line-added"> 100     uint64_t size = 4;</span>
<span class="line-added"> 101     size += info.name().sizeInBytes();</span>
<span class="line-added"> 102     // FIXME: estimate keyPath.</span>
<span class="line-added"> 103     for (auto&amp; indexInfo : info.indexMap().values())</span>
<span class="line-added"> 104         size += estimateSize(indexInfo);</span>
<span class="line-added"> 105     return size;</span>
<span class="line-added"> 106 }</span>
<span class="line-added"> 107 </span>
 108 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 109     : m_server(server)
 110     , m_identifier(identifier)
 111     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
 112 {
 113     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 114 }
 115 
 116 UniqueIDBDatabase::~UniqueIDBDatabase()
 117 {
 118     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 119     ASSERT(isMainThread());
 120     ASSERT(!hasAnyPendingCallbacks());
 121     ASSERT(!hasUnfinishedTransactions());
 122     ASSERT(m_pendingTransactions.isEmpty());
 123     ASSERT(m_openDatabaseConnections.isEmpty());
 124     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());
 125     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());
 126 
 127     RELEASE_ASSERT(m_databaseQueue.isKilled());
 128     RELEASE_ASSERT(m_databaseReplyQueue.isKilled());
 129     RELEASE_ASSERT(!m_backingStore);
 130 }
 131 
 132 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
 133 {
 134     RELEASE_ASSERT(m_databaseInfo);
 135     return *m_databaseInfo;
 136 }
 137 
 138 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 139 {
 140     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
 141     ASSERT(!m_hardClosedForUserDelete);
 142     ASSERT(isMainThread());
 143 
 144     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 145 
 146     // An open operation is already in progress, so we can&#39;t possibly handle this one yet.
 147     if (m_isOpeningBackingStore)
 148         return;
 149 
 150     handleDatabaseOperations();
 151 }
 152 
 153 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const
 154 {
 155     return !m_errorCallbacks.isEmpty()
 156         || !m_keyDataCallbacks.isEmpty()
 157         || !m_getResultCallbacks.isEmpty()
 158         || !m_getAllResultsCallbacks.isEmpty()
 159         || !m_countCallbacks.isEmpty();
 160 }
 161 
 162 bool UniqueIDBDatabase::isVersionChangeInProgress()
 163 {
 164 #if !LOG_DISABLED
 165     if (m_versionChangeTransaction)
 166         ASSERT(m_versionChangeDatabaseConnection);
 167 #endif
 168 
 169     return m_versionChangeDatabaseConnection;
 170 }
 171 
<a name="5" id="anc5"></a><span class="line-added"> 172 static inline String quotaErrorMessageName(const char* taskName)</span>
<span class="line-added"> 173 {</span>
<span class="line-added"> 174     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);</span>
<span class="line-added"> 175 }</span>
<span class="line-added"> 176 </span>
<span class="line-added"> 177 void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-added"> 178 {</span>
<span class="line-added"> 179     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {</span>
<span class="line-added"> 180         if (!weakThis) {</span>
<span class="line-added"> 181             callback(IDBError { UnknownError });</span>
<span class="line-added"> 182             return;</span>
<span class="line-added"> 183         }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185         if (m_owningPointerForClose) {</span>
<span class="line-added"> 186             // We are closing the database, there is no point in trying to modify the database at that point.</span>
<span class="line-added"> 187             callback(IDBError { UnknownError });</span>
<span class="line-added"> 188             return;</span>
<span class="line-added"> 189         }</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191         switch (decision) {</span>
<span class="line-added"> 192         case StorageQuotaManager::Decision::Deny:</span>
<span class="line-added"> 193             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });</span>
<span class="line-added"> 194             return;</span>
<span class="line-added"> 195         case StorageQuotaManager::Decision::Grant:</span>
<span class="line-added"> 196             callback({ });</span>
<span class="line-added"> 197         };</span>
<span class="line-added"> 198     });</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-added"> 202 {</span>
<span class="line-added"> 203     requestSpace(0, &quot;&quot;, WTFMove(callback));</span>
<span class="line-added"> 204 }</span>
<span class="line-added"> 205 </span>
 206 void UniqueIDBDatabase::performCurrentOpenOperation()
 207 {
 208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 209 
 210     ASSERT(m_currentOpenDBRequest);
 211     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 212 
 213     if (!m_databaseInfo) {
 214         if (!m_isOpeningBackingStore) {
 215             m_isOpeningBackingStore = true;
<a name="6" id="anc6"></a><span class="line-modified"> 216             // We do not know whether this is an existing or a new database.</span>
<span class="line-added"> 217             // We set a small cost so that it is not possible to open an infinite number of database.</span>
<span class="line-added"> 218             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {</span>
<span class="line-added"> 219                 if (!weakThis)</span>
<span class="line-added"> 220                     return;</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222                 if (m_owningPointerForClose)</span>
<span class="line-added"> 223                     return;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225                 switch (decision) {</span>
<span class="line-added"> 226                 case StorageQuotaManager::Decision::Deny: {</span>
<span class="line-added"> 227                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });</span>
<span class="line-added"> 228                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 229                     m_currentOpenDBRequest = nullptr;</span>
<span class="line-added"> 230                     m_isOpeningBackingStore = false;</span>
<span class="line-added"> 231                     break;</span>
<span class="line-added"> 232                 }</span>
<span class="line-added"> 233                 case StorageQuotaManager::Decision::Grant:</span>
<span class="line-added"> 234                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="line-added"> 235                 };</span>
<span class="line-added"> 236             });</span>
 237         }
<a name="7" id="anc7"></a>
 238         return;
 239     }
 240 
 241     // If we previously started a version change operation but were blocked by having open connections,
 242     // we might now be unblocked.
 243     if (m_versionChangeDatabaseConnection) {
 244         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 245             startVersionChangeTransaction();
 246         return;
 247     }
 248 
 249     // 3.3.1 Opening a database
 250     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 251     // or the current version of db otherwise.
 252     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 253     if (!requestedVersion)
 254         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 255 
 256     // 3.3.1 Opening a database
 257     // If the database version higher than the requested version, abort these steps and return a VersionError.
 258     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 259         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 260         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 261         m_currentOpenDBRequest = nullptr;
 262 
 263         return;
 264     }
 265 
 266     if (!m_backingStoreOpenError.isNull()) {
 267         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), m_backingStoreOpenError);
 268         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 269         m_currentOpenDBRequest = nullptr;
 270 
 271         return;
 272     }
 273 
 274     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 275 
 276     if (requestedVersion == m_databaseInfo-&gt;version()) {
 277         auto* rawConnection = &amp;connection.get();
 278         addOpenDatabaseConnection(WTFMove(connection));
 279 
 280         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 281         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 282         m_currentOpenDBRequest = nullptr;
 283 
 284         return;
 285     }
 286 
 287     ASSERT(!m_versionChangeDatabaseConnection);
 288     m_versionChangeDatabaseConnection = WTFMove(connection);
 289 
 290     // 3.3.7 &quot;versionchange&quot; transaction steps
 291     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 292     if (!hasAnyOpenConnections()) {
 293         startVersionChangeTransaction();
 294         return;
 295     }
 296 
 297     // Otherwise we have to notify all those open connections and wait for them to close.
 298     maybeNotifyConnectionsOfVersionChange();
 299 }
 300 
 301 void UniqueIDBDatabase::performCurrentDeleteOperation()
 302 {
 303     ASSERT(isMainThread());
 304     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.debugString().utf8().data());
 305 
 306     ASSERT(m_currentOpenDBRequest);
 307     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 308 
 309     if (m_deleteBackingStoreInProgress)
 310         return;
 311 
 312     if (hasAnyOpenConnections()) {
 313         maybeNotifyConnectionsOfVersionChange();
 314         return;
 315     }
 316 
 317     if (hasUnfinishedTransactions())
 318         return;
 319 
 320     ASSERT(!hasAnyPendingCallbacks());
 321     ASSERT(m_pendingTransactions.isEmpty());
 322     ASSERT(m_openDatabaseConnections.isEmpty());
 323 
 324     // It&#39;s possible to have multiple delete requests queued up in a row.
 325     // In that scenario only the first request will actually have to delete the database.
 326     // Subsequent requests can immediately notify their completion.
 327 
 328     if (!m_deleteBackingStoreInProgress) {
 329         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 330             didDeleteBackingStore(0);
 331         else {
 332             m_deleteBackingStoreInProgress = true;
 333             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));
 334         }
 335     }
 336 }
 337 
 338 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 339 {
 340     ASSERT(!isMainThread());
 341     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);
 342 
 343     uint64_t deletedVersion = 0;
 344 
 345     if (m_backingStore) {
 346         m_backingStore-&gt;deleteBackingStore();
<a name="8" id="anc8"></a><span class="line-added"> 347         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 348 </span>
 349         m_backingStore = nullptr;
 350         m_backingStoreSupportsSimultaneousTransactions = false;
 351         m_backingStoreIsEphemeral = false;
 352     } else {
<a name="9" id="anc9"></a><span class="line-modified"> 353         auto backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-added"> 354         m_currentDatabaseSize = backingStore-&gt;databaseSize();</span>
 355 
 356         IDBDatabaseInfo databaseInfo;
 357         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 358         if (!error.isNull())
 359             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
 360 
 361         deletedVersion = databaseInfo.version();
 362         backingStore-&gt;deleteBackingStore();
<a name="10" id="anc10"></a><span class="line-added"> 363         m_newDatabaseSize = backingStore-&gt;databaseSize();</span>
 364     }
 365 
 366     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 367 }
 368 
 369 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()
 370 {
 371     ASSERT(!isMainThread());
 372     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);
 373 
 374     if (m_backingStore)
 375         m_backingStore-&gt;deleteBackingStore();
 376 
 377     shutdownForClose();
 378 }
 379 
 380 void UniqueIDBDatabase::scheduleShutdownForClose()
 381 {
 382     ASSERT(isMainThread());
 383 
 384     m_operationAndTransactionTimer.stop();
 385 
 386     RELEASE_ASSERT(!m_owningPointerForClose);
<a name="11" id="anc11"></a><span class="line-modified"> 387     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
 388 
 389     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 390 }
 391 
 392 void UniqueIDBDatabase::shutdownForClose()
 393 {
 394     ASSERT(!isMainThread());
 395     ASSERT(m_owningPointerForClose.get() == this);
 396 
 397     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
 398 
<a name="12" id="anc12"></a><span class="line-added"> 399     if (m_backingStore) {</span>
<span class="line-added"> 400         m_backingStore-&gt;close();</span>
<span class="line-added"> 401         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 402     }</span>
<span class="line-added"> 403 </span>
 404     m_backingStore = nullptr;
 405     m_backingStoreSupportsSimultaneousTransactions = false;
 406     m_backingStoreIsEphemeral = false;
 407 
 408     if (!m_databaseQueue.isEmpty()) {
 409         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 410         return;
 411     }
 412     m_databaseQueue.kill();
 413 
 414     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));
 415 }
 416 
 417 void UniqueIDBDatabase::didShutdownForClose()
 418 {
 419     ASSERT(m_databaseReplyQueue.isEmpty());
 420     m_databaseReplyQueue.kill();
<a name="13" id="anc13"></a><span class="line-added"> 421 </span>
<span class="line-added"> 422     updateSpaceUsedIfNeeded();</span>
 423 }
 424 
 425 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 426 {
 427     ASSERT(isMainThread());
 428     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);
 429 
 430     ASSERT(!hasAnyPendingCallbacks());
 431     ASSERT(!hasUnfinishedTransactions());
 432     ASSERT(m_pendingTransactions.isEmpty());
 433     ASSERT(m_openDatabaseConnections.isEmpty());
 434     ASSERT(!m_backingStore);
 435 
 436     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.
 437     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.
 438     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());
 439 
 440     if (m_databaseInfo)
 441         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 442 
 443     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 444     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 445     // passed in deletedVersion argument.
 446     if (!m_mostRecentDeletedDatabaseInfo)
<a name="14" id="anc14"></a><span class="line-modified"> 447         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
 448 
 449     if (m_currentOpenDBRequest) {
 450         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 451         m_currentOpenDBRequest = nullptr;
 452     }
 453 
<a name="15" id="anc15"></a><span class="line-added"> 454     updateSpaceUsedIfNeeded();</span>
<span class="line-added"> 455 </span>
 456     m_deleteBackingStoreInProgress = false;
 457 
 458     if (m_hardClosedForUserDelete)
 459         return;
 460 
 461     invokeOperationAndTransactionTimer();
 462 }
 463 
 464 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 465 {
 466     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 467         m_pendingOpenDBRequests.removeFirst();
 468 }
 469 
 470 void UniqueIDBDatabase::handleDatabaseOperations()
 471 {
 472     ASSERT(isMainThread());
 473     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 474     ASSERT(!m_hardClosedForUserDelete);
 475 
<a name="16" id="anc16"></a><span class="line-modified"> 476     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)</span>
 477         return;
 478 
 479     clearStalePendingOpenDBRequests();
 480 
 481     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
 482         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 483         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
 484             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 485 
 486         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle
 487         if (m_currentOpenDBRequest)
 488             handleCurrentOperation();
 489 
 490         return;
 491     }
 492 
 493     if (m_pendingOpenDBRequests.isEmpty()) {
 494         m_currentOpenDBRequest = nullptr;
 495         return;
 496     }
 497 
 498     m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 499     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - Popped an operation, now there are %u pending&quot;, m_pendingOpenDBRequests.size());
 500 
 501     handleCurrentOperation();
 502 }
 503 
 504 void UniqueIDBDatabase::handleCurrentOperation()
 505 {
 506     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleCurrentOperation&quot;);
 507     ASSERT(!m_hardClosedForUserDelete);
 508     ASSERT(m_currentOpenDBRequest);
 509 
 510     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 511         performCurrentOpenOperation();
 512     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 513         performCurrentDeleteOperation();
 514     else
 515         ASSERT_NOT_REACHED();
 516 
 517     if (!m_currentOpenDBRequest)
 518         invokeOperationAndTransactionTimer();
 519 }
 520 
 521 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 522 {
 523     return !m_openDatabaseConnections.isEmpty();
 524 }
 525 
 526 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 527 {
 528     for (auto&amp; connection : m_openDatabaseConnections) {
 529         if (!connection-&gt;connectionIsClosing())
 530             return false;
 531     }
 532 
 533     return true;
 534 }
 535 
 536 static uint64_t generateUniqueCallbackIdentifier()
 537 {
 538     ASSERT(isMainThread());
 539     static uint64_t currentID = 0;
 540     return ++currentID;
 541 }
 542 
<a name="17" id="anc17"></a><span class="line-modified"> 543 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)</span>
 544 {
 545     if (m_hardClosedForUserDelete) {
 546         callback(IDBError::userDeleteError());
 547         return 0;
 548     }
 549 
 550     uint64_t identifier = generateUniqueCallbackIdentifier();
 551     ASSERT(!m_errorCallbacks.contains(identifier));
 552     m_errorCallbacks.add(identifier, WTFMove(callback));
<a name="18" id="anc18"></a><span class="line-added"> 553 </span>
<span class="line-added"> 554     if (taskSize) {</span>
<span class="line-added"> 555         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-added"> 556         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-added"> 557     }</span>
<span class="line-added"> 558 </span>
 559     m_callbackQueue.append(identifier);
 560     return identifier;
 561 }
 562 
<a name="19" id="anc19"></a><span class="line-modified"> 563 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)</span>
 564 {
 565     if (m_hardClosedForUserDelete) {
 566         callback(IDBError::userDeleteError(), { });
 567         return 0;
 568     }
 569 
 570     uint64_t identifier = generateUniqueCallbackIdentifier();
 571     ASSERT(!m_keyDataCallbacks.contains(identifier));
 572     m_keyDataCallbacks.add(identifier, WTFMove(callback));
<a name="20" id="anc20"></a><span class="line-added"> 573 </span>
<span class="line-added"> 574     if (taskSize) {</span>
<span class="line-added"> 575         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-added"> 576         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-added"> 577     }</span>
<span class="line-added"> 578 </span>
 579     m_callbackQueue.append(identifier);
 580     return identifier;
 581 }
 582 
 583 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
 584 {
 585     if (m_hardClosedForUserDelete) {
 586         callback(IDBError::userDeleteError(), { });
 587         return 0;
 588     }
 589 
 590     uint64_t identifier = generateUniqueCallbackIdentifier();
 591     ASSERT(!m_getResultCallbacks.contains(identifier));
 592     m_getResultCallbacks.add(identifier, WTFMove(callback));
 593     m_callbackQueue.append(identifier);
 594     return identifier;
 595 }
 596 
 597 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)
 598 {
 599     if (m_hardClosedForUserDelete) {
 600         callback(IDBError::userDeleteError(), { });
 601         return 0;
 602     }
 603 
 604     uint64_t identifier = generateUniqueCallbackIdentifier();
 605     ASSERT(!m_getAllResultsCallbacks.contains(identifier));
 606     m_getAllResultsCallbacks.add(identifier, WTFMove(callback));
 607     m_callbackQueue.append(identifier);
 608     return identifier;
 609 }
 610 
 611 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(CountCallback&amp;&amp; callback)
 612 {
 613     if (m_hardClosedForUserDelete) {
 614         callback(IDBError::userDeleteError(), 0);
 615         return 0;
 616     }
 617 
 618     uint64_t identifier = generateUniqueCallbackIdentifier();
 619     ASSERT(!m_countCallbacks.contains(identifier));
 620     m_countCallbacks.add(identifier, WTFMove(callback));
 621     m_callbackQueue.append(identifier);
 622     return identifier;
 623 }
 624 
 625 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 626 {
 627     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);
 628     ASSERT(!m_hardClosedForUserDelete);
 629 
 630     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 631     handleDatabaseOperations();
 632 }
 633 
 634 void UniqueIDBDatabase::startVersionChangeTransaction()
 635 {
 636     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 637 
 638     ASSERT(!m_versionChangeTransaction);
 639     ASSERT(m_currentOpenDBRequest);
 640     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 641     ASSERT(m_versionChangeDatabaseConnection);
 642 
<a name="21" id="anc21"></a><span class="line-modified"> 643     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();</span>


 644     if (!requestedVersion)
 645         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 646 
<a name="22" id="anc22"></a>

 647     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<a name="23" id="anc23"></a>

 648     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);
<a name="24" id="anc24"></a>
 649 
<a name="25" id="anc25"></a><span class="line-modified"> 650     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));</span>

 651 }
 652 
<a name="26" id="anc26"></a><span class="line-modified"> 653 void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)</span>
 654 {
<a name="27" id="anc27"></a><span class="line-modified"> 655     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);</span>
<span class="line-modified"> 656 </span>
<span class="line-added"> 657     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-added"> 658     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));</span>
<span class="line-added"> 659 }</span>
<span class="line-added"> 660 </span>
<span class="line-added"> 661 void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)</span>
<span class="line-added"> 662 {</span>
<span class="line-added"> 663     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665     // Open request may already be canceled by client or user, or connection to client is lost.</span>
<span class="line-added"> 666     if (!m_versionChangeDatabaseConnection)</span>
<span class="line-added"> 667         return;</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669     ASSERT(m_currentOpenDBRequest);</span>
<span class="line-added"> 670     ASSERT(m_versionChangeTransaction);</span>
<span class="line-added"> 671     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="line-added"> 672     IDBResultData result;</span>
<span class="line-added"> 673     if (error.isNull()) {</span>
<span class="line-added"> 674         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="line-added"> 675         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());</span>
<span class="line-added"> 676         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="line-added"> 677         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 678     } else {</span>
<span class="line-added"> 679         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-added"> 680         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added"> 681         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);</span>
<span class="line-added"> 682         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 683     }</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685     invokeOperationAndTransactionTimer();</span>
 686 }
 687 
 688 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 689 {
 690     ASSERT(m_currentOpenDBRequest);
 691 
 692     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 693         return;
 694 
 695     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 696     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 697 
 698     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 699 
 700     // 3.3.7 &quot;versionchange&quot; transaction steps
 701     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 702     // The event must not be fired on connections which has the closePending flag set.
 703     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 704     for (const auto&amp; connection : m_openDatabaseConnections) {
 705         if (connection-&gt;closePending())
 706             continue;
 707 
 708         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 709         connectionIdentifiers.add(connection-&gt;identifier());
 710     }
 711 
 712     if (!connectionIdentifiers.isEmpty())
 713         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 714     else
 715         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 716 }
 717 
 718 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 719 {
 720     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 721 
 722     ASSERT(m_currentOpenDBRequest);
 723 
 724     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 725 
 726     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 727         return;
 728 
 729     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
 730         invokeOperationAndTransactionTimer();
 731         return;
 732     }
 733 
 734     // Since all open connections have fired their version change events but not all of them have closed,
 735     // this request is officially blocked.
 736     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 737 }
 738 
 739 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier)
 740 {
 741     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 742 
 743     if (!m_currentOpenDBRequest)
 744         return;
 745 
 746     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 747 
 748     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 749 }
 750 
 751 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 752 {
 753     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 754 
 755     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 756         m_currentOpenDBRequest = nullptr;
 757 
 758     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 759         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 760         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 761 
 762         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 763     }
 764 
 765     for (auto&amp; request : m_pendingOpenDBRequests) {
 766         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 767             m_pendingOpenDBRequests.remove(request);
 768             return;
 769         }
 770     }
 771 }
 772 
 773 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 774 {
 775     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 776     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 777 }
 778 
 779 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 780 {
 781     ASSERT(!isMainThread());
 782     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
 783 
 784     ASSERT(!m_backingStore);
<a name="28" id="anc28"></a><span class="line-modified"> 785     m_backingStore = m_server-&gt;createBackingStore(identifier);</span>
 786     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
 787     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
 788 
<a name="29" id="anc29"></a><span class="line-added"> 789     // QuotaUser should have initiliazed storage usage, which contains the</span>
<span class="line-added"> 790     // size of this database.</span>
<span class="line-added"> 791     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 792 </span>
 793     IDBDatabaseInfo databaseInfo;
 794     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 795 
 796     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 797 }
 798 
 799 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
 800 {
 801     ASSERT(isMainThread());
 802     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
 803 
<a name="30" id="anc30"></a><span class="line-modified"> 804     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);</span>
 805     m_backingStoreOpenError = error;
 806 
 807     ASSERT(m_isOpeningBackingStore);
 808     m_isOpeningBackingStore = false;
 809 
<a name="31" id="anc31"></a><span class="line-added"> 810     updateSpaceUsedIfNeeded();</span>
<span class="line-added"> 811 </span>
 812     if (m_hardClosedForUserDelete)
 813         return;
 814 
 815     handleDatabaseOperations();
 816 }
 817 
 818 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 819 {
 820     ASSERT(isMainThread());
 821     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
 822 
<a name="32" id="anc32"></a><span class="line-modified"> 823     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added"> 824     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 825         if (error) {</span>
<span class="line-added"> 826             callback(WTFMove(*error));</span>
<span class="line-added"> 827             return;</span>
<span class="line-added"> 828         }</span>
<span class="line-added"> 829         if (!transaction) {</span>
<span class="line-added"> 830             callback(IDBError { UnknownError });</span>
<span class="line-added"> 831             return;</span>
<span class="line-added"> 832         }</span>
<span class="line-added"> 833         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-added"> 834     });</span>
<span class="line-added"> 835 }</span>
<span class="line-added"> 836 </span>
<span class="line-added"> 837 void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
<span class="line-added"> 838 {</span>
<span class="line-added"> 839     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
 840     if (!callbackID)
 841         return;
 842 
 843     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 844 }
 845 
 846 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 847 {
 848     ASSERT(!isMainThread());
 849     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);
 850 
 851     ASSERT(m_backingStore);
 852     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);
 853 
 854     IDBError error;
 855     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));
 856 }
 857 
 858 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)
 859 {
 860     ASSERT(isMainThread());
 861     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);
 862 
 863     if (error.isNull())
 864         m_databaseInfo-&gt;addExistingObjectStore(info);
 865 
 866     performErrorCallback(callbackIdentifier, error);
 867 }
 868 
 869 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 870 {
 871     ASSERT(isMainThread());
 872     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
 873 
<a name="33" id="anc33"></a><span class="line-added"> 874     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 875         if (error) {</span>
<span class="line-added"> 876             callback(WTFMove(*error));</span>
<span class="line-added"> 877             return;</span>
<span class="line-added"> 878         }</span>
<span class="line-added"> 879         if (!transaction) {</span>
<span class="line-added"> 880             callback(IDBError { UnknownError });</span>
<span class="line-added"> 881             return;</span>
<span class="line-added"> 882         }</span>
<span class="line-added"> 883         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));</span>
<span class="line-added"> 884     });</span>
<span class="line-added"> 885 }</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887 void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
<span class="line-added"> 888 {</span>
 889     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 890     if (!callbackID)
 891         return;
 892 
 893     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 894     if (!info) {
 895         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 896         return;
 897     }
 898 
 899     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));
 900 }
 901 
 902 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 903 {
 904     ASSERT(!isMainThread());
 905     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);
 906 
 907     ASSERT(m_backingStore);
 908     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);
 909 
 910     IDBError error;
 911     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));
 912 }
 913 
 914 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)
 915 {
 916     ASSERT(isMainThread());
 917     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);
 918 
 919     if (error.isNull())
 920         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
 921 
 922     performErrorCallback(callbackIdentifier, error);
 923 }
 924 
 925 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 926 {
 927     ASSERT(isMainThread());
 928     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
 929 
<a name="34" id="anc34"></a><span class="line-modified"> 930     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-added"> 931     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 932         if (error) {</span>
<span class="line-added"> 933             callback(WTFMove(*error));</span>
<span class="line-added"> 934             return;</span>
<span class="line-added"> 935         }</span>
<span class="line-added"> 936         if (!transaction) {</span>
<span class="line-added"> 937             callback(IDBError { UnknownError });</span>
<span class="line-added"> 938             return;</span>
<span class="line-added"> 939         }</span>
<span class="line-added"> 940         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));</span>
<span class="line-added"> 941     });</span>
<span class="line-added"> 942 }</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944 void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-added"> 945 {</span>
<span class="line-added"> 946     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
 947     if (!callbackID)
 948         return;
 949 
 950     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 951     if (!info) {
 952         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 953         return;
 954     }
 955 
 956     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));
 957 }
 958 
 959 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
 960 {
 961     ASSERT(!isMainThread());
 962     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);
 963 
 964     ASSERT(m_backingStore);
 965     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);
 966 
 967     IDBError error;
 968     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));
 969 }
 970 
 971 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)
 972 {
 973     ASSERT(isMainThread());
 974     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);
 975 
 976     if (error.isNull())
 977         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 978 
 979     performErrorCallback(callbackIdentifier, error);
 980 }
 981 
 982 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 983 {
 984     ASSERT(isMainThread());
 985     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
 986 
<a name="35" id="anc35"></a><span class="line-added"> 987     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 988         if (error) {</span>
<span class="line-added"> 989             callback(WTFMove(*error));</span>
<span class="line-added"> 990             return;</span>
<span class="line-added"> 991         }</span>
<span class="line-added"> 992         if (!transaction) {</span>
<span class="line-added"> 993             callback(IDBError { UnknownError });</span>
<span class="line-added"> 994             return;</span>
<span class="line-added"> 995         }</span>
<span class="line-added"> 996         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));</span>
<span class="line-added"> 997     });</span>
<span class="line-added"> 998 }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000 void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-added">1001 {</span>
1002     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1003     if (!callbackID)
1004         return;
1005     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
1006 }
1007 
1008 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1009 {
1010     ASSERT(!isMainThread());
1011     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);
1012 
1013     ASSERT(m_backingStore);
1014     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);
1015 
1016     IDBError error;
1017     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));
1018 }
1019 
1020 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)
1021 {
1022     ASSERT(isMainThread());
1023     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);
1024 
1025     performErrorCallback(callbackIdentifier, error);
1026 }
1027 
1028 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
1029 {
1030     ASSERT(isMainThread());
1031     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
1032 
<a name="36" id="anc36"></a><span class="line-modified">1033     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added">1034     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1035         if (error) {</span>
<span class="line-added">1036             callback(WTFMove(*error));</span>
<span class="line-added">1037             return;</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039         if (!transaction) {</span>
<span class="line-added">1040             callback(IDBError { UnknownError });</span>
<span class="line-added">1041             return;</span>
<span class="line-added">1042         }</span>
<span class="line-added">1043         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-added">1044     });</span>
<span class="line-added">1045 }</span>
<span class="line-added">1046 </span>
<span class="line-added">1047 void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-added">1048 {</span>
<span class="line-added">1049     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
1050     if (!callbackID)
1051         return;
1052     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
1053 }
1054 
1055 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1056 {
1057     ASSERT(!isMainThread());
1058     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
1059 
<a name="37" id="anc37"></a><span class="line-added">1060     IDBError error;</span>
1061     ASSERT(m_backingStore);
<a name="38" id="anc38"></a><span class="line-modified">1062     if (!m_backingStore) {</span>
<span class="line-added">1063         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);</span>
<span class="line-added">1064         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);</span>
<span class="line-added">1065         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-added">1066         return;</span>
<span class="line-added">1067     }</span>
1068 
<a name="39" id="anc39"></a><span class="line-added">1069     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
1070     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
1071 }
1072 
1073 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
1074 {
1075     ASSERT(isMainThread());
1076     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);
1077 
1078     if (error.isNull()) {
1079         ASSERT(m_databaseInfo);
1080         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1081         ASSERT(objectStoreInfo);
1082         objectStoreInfo-&gt;addExistingIndex(info);
1083     }
1084 
1085     performErrorCallback(callbackIdentifier, error);
1086 }
1087 
1088 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
1089 {
1090     ASSERT(isMainThread());
1091     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
1092 
<a name="40" id="anc40"></a><span class="line-added">1093     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1094         if (error) {</span>
<span class="line-added">1095             callback(WTFMove(*error));</span>
<span class="line-added">1096             return;</span>
<span class="line-added">1097         }</span>
<span class="line-added">1098         if (!transaction) {</span>
<span class="line-added">1099             callback(IDBError { UnknownError });</span>
<span class="line-added">1100             return;</span>
<span class="line-added">1101         }</span>
<span class="line-added">1102         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));</span>
<span class="line-added">1103     });</span>
<span class="line-added">1104 }</span>
<span class="line-added">1105 </span>
<span class="line-added">1106 void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-added">1107 {</span>
1108     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1109     if (!callbackID)
1110         return;
1111 
1112     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1113     if (!objectStoreInfo) {
1114         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
1115         return;
1116     }
1117 
1118     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
1119     if (!indexInfo) {
1120         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
1121         return;
1122     }
1123 
1124     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));
1125 }
1126 
1127 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)
1128 {
1129     ASSERT(!isMainThread());
1130     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteIndex&quot;);
1131 
1132     ASSERT(m_backingStore);
1133     m_backingStore-&gt;deleteIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier);
1134 
1135     IDBError error;
1136     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier));
1137 }
1138 
1139 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1140 {
1141     ASSERT(isMainThread());
1142     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);
1143 
1144     if (error.isNull()) {
1145         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1146         if (objectStoreInfo)
1147             objectStoreInfo-&gt;deleteIndex(indexIdentifier);
1148     }
1149 
1150     performErrorCallback(callbackIdentifier, error);
1151 }
1152 
1153 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
1154 {
1155     ASSERT(isMainThread());
1156     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
1157 
<a name="41" id="anc41"></a><span class="line-modified">1158     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-added">1159     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1160         if (error) {</span>
<span class="line-added">1161             callback(WTFMove(*error));</span>
<span class="line-added">1162             return;</span>
<span class="line-added">1163         }</span>
<span class="line-added">1164         if (!transaction) {</span>
<span class="line-added">1165             callback(IDBError { UnknownError });</span>
<span class="line-added">1166             return;</span>
<span class="line-added">1167         }</span>
<span class="line-added">1168         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));</span>
<span class="line-added">1169     });</span>
<span class="line-added">1170 }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172 void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-added">1173 {</span>
<span class="line-added">1174     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
1175     if (!callbackID)
1176         return;
1177 
1178     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1179     if (!objectStoreInfo) {
1180         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
1181         return;
1182     }
1183 
1184     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1185     if (!indexInfo) {
1186         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
1187         return;
1188     }
1189 
1190     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));
1191 }
1192 
1193 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1194 {
1195     ASSERT(!isMainThread());
1196     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameIndex&quot;);
1197 
1198     ASSERT(m_backingStore);
1199     m_backingStore-&gt;renameIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier, newName);
1200 
1201     IDBError error;
1202     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier, newName));
1203 }
1204 
1205 void UniqueIDBDatabase::didPerformRenameIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1206 {
1207     ASSERT(isMainThread());
1208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);
1209 
1210     if (error.isNull()) {
1211         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1212         ASSERT(objectStoreInfo);
1213         if (objectStoreInfo) {
1214             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1215             ASSERT(indexInfo);
1216             indexInfo-&gt;rename(newName);
1217         }
1218     }
1219 
1220     performErrorCallback(callbackIdentifier, error);
1221 }
1222 
1223 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
1224 {
1225     ASSERT(isMainThread());
1226     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
1227 
<a name="42" id="anc42"></a><span class="line-modified">1228     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-modified">1229     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {</span>
<span class="line-modified">1230         if (error) {</span>
<span class="line-modified">1231             callback(WTFMove(*error), { });</span>
<span class="line-modified">1232             return;</span>
<span class="line-modified">1233         }</span>
<span class="line-modified">1234         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));</span>
<span class="line-modified">1235     });</span>



1236 }
1237 
<a name="43" id="anc43"></a><span class="line-modified">1238 void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)</span>
1239 {
<a name="44" id="anc44"></a><span class="line-modified">1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-modified">1241     if (!callbackID)</span>
<span class="line-modified">1242         return;</span>
<span class="line-modified">1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>


1244 }
1245 
1246 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
1247 {
1248     ASSERT(!isMainThread());
1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);
1250 
1251     ASSERT(m_backingStore);
1252     ASSERT(objectStoreIdentifier);
1253 
1254     IDBKeyData usedKey;
1255     IDBError error;
1256 
<a name="45" id="anc45"></a><span class="line-added">1257     if (!m_backingStore) {</span>
<span class="line-added">1258         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);</span>
<span class="line-added">1259         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);</span>
<span class="line-added">1260         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
<span class="line-added">1261         return;</span>
<span class="line-added">1262     }</span>
<span class="line-added">1263 </span>
1264     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
1265     if (!objectStoreInfo) {
1266         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
1267         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1268         return;
1269     }
1270 
1271     bool usedKeyIsGenerated = false;
1272     uint64_t keyNumber;
1273     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1274         if (usedKeyIsGenerated)
1275             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1276     });
1277     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1278         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1279         if (!error.isNull()) {
1280             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1281             return;
1282         }
1283 
1284         usedKey.setNumberValue(keyNumber);
1285         usedKeyIsGenerated = true;
1286     } else
1287         usedKey = keyData;
1288 
1289     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1290         bool keyExists;
1291         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1292         if (error.isNull() &amp;&amp; keyExists)
1293             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);
1294 
1295         if (!error.isNull()) {
1296             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1297             return;
1298         }
1299     }
1300 
<a name="46" id="anc46"></a>




























1301     // 3.4.1 Object Store Storage Operation
1302     // ...If a record already exists in store ...
1303     // then remove the record from store using the steps for deleting records from an object store...
1304     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1305     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1306     if (!error.isNull()) {
1307         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1308         return;
1309     }
1310 
<a name="47" id="anc47"></a><span class="line-modified">1311     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>



1312 
1313     if (!error.isNull()) {
1314         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1315         return;
1316     }
1317 
1318     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1319         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1320 
1321     generatedKeyResetter.release();
1322     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1323 }
1324 
1325 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1326 {
1327     ASSERT(isMainThread());
1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);
1329 
1330     performKeyDataCallback(callbackIdentifier, error, resultKey);
1331 }
1332 
1333 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1334 {
1335     ASSERT(isMainThread());
1336     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
1337 
<a name="48" id="anc48"></a><span class="line-added">1338     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1339         if (error) {</span>
<span class="line-added">1340             callback(WTFMove(*error), { });</span>
<span class="line-added">1341             return;</span>
<span class="line-added">1342         }</span>
<span class="line-added">1343         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));</span>
<span class="line-added">1344     });</span>
<span class="line-added">1345 }</span>
<span class="line-added">1346 </span>
<span class="line-added">1347 void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)</span>
<span class="line-added">1348 {</span>
1349     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1350     if (!callbackID)
1351         return;
1352 
1353     if (uint64_t indexIdentifier = requestData.indexIdentifier())
1354         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));
1355     else
1356         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));
1357 }
1358 
1359 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1360 {
1361     ASSERT(isMainThread());
1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
1363 
<a name="49" id="anc49"></a><span class="line-added">1364     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1365         if (error) {</span>
<span class="line-added">1366             callback(WTFMove(*error), { });</span>
<span class="line-added">1367             return;</span>
<span class="line-added">1368         }</span>
<span class="line-added">1369         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));</span>
<span class="line-added">1370     });</span>
<span class="line-added">1371 }</span>
<span class="line-added">1372 </span>
<span class="line-added">1373 void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-added">1374 {</span>
1375     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1376     if (!callbackID)
1377         return;
1378 
1379     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
1380 }
1381 
1382 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)
1383 {
1384     ASSERT(!isMainThread());
1385     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);
1386 
1387     ASSERT(m_backingStore);
1388 
1389     IDBGetResult result;
1390     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);
1391 
1392     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1393 }
1394 
1395 void UniqueIDBDatabase::performGetIndexRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range)
1396 {
1397     ASSERT(!isMainThread());
1398     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetIndexRecord&quot;);
1399 
1400     ASSERT(m_backingStore);
1401 
1402     IDBGetResult result;
1403     IDBError error = m_backingStore-&gt;getIndexRecord(transactionIdentifier, objectStoreIdentifier, indexIdentifier, recordType, range, result);
1404 
1405     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1406 }
1407 
1408 void UniqueIDBDatabase::didPerformGetRecord(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1409 {
1410     ASSERT(isMainThread());
1411     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetRecord&quot;);
1412 
1413     performGetResultCallback(callbackIdentifier, error, result);
1414 }
1415 
1416 void UniqueIDBDatabase::performGetAllRecords(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData)
1417 {
1418     ASSERT(!isMainThread());
1419     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetAllRecords&quot;);
1420 
1421     ASSERT(m_backingStore);
1422 
1423     IDBGetAllResult result;
1424     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);
1425 
1426     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));
1427 }
1428 
1429 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)
1430 {
1431     ASSERT(isMainThread());
1432     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);
1433 
1434     performGetAllResultsCallback(callbackIdentifier, error, result);
1435 }
1436 
1437 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1438 {
1439     ASSERT(isMainThread());
1440     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
1441 
<a name="50" id="anc50"></a><span class="line-added">1442     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1443         if (error) {</span>
<span class="line-added">1444             callback(WTFMove(*error), { });</span>
<span class="line-added">1445             return;</span>
<span class="line-added">1446         }</span>
<span class="line-added">1447         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));</span>
<span class="line-added">1448     });</span>
<span class="line-added">1449 }</span>
<span class="line-added">1450 </span>
<span class="line-added">1451 void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-added">1452 {</span>
1453     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1454     if (!callbackID)
1455         return;
1456     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
1457 }
1458 
1459 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)
1460 {
1461     ASSERT(!isMainThread());
1462     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);
1463 
1464     ASSERT(m_backingStore);
1465     ASSERT(objectStoreIdentifier);
1466 
1467     uint64_t count;
1468     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);
1469 
1470     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));
1471 }
1472 
1473 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1474 {
1475     ASSERT(isMainThread());
1476     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);
1477 
1478     performCountCallback(callbackIdentifier, error, count);
1479 }
1480 
1481 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1482 {
1483     ASSERT(isMainThread());
1484     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
1485 
<a name="51" id="anc51"></a><span class="line-added">1486     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1487         if (error) {</span>
<span class="line-added">1488             callback(WTFMove(*error));</span>
<span class="line-added">1489             return;</span>
<span class="line-added">1490         }</span>
<span class="line-added">1491         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));</span>
<span class="line-added">1492     });</span>
<span class="line-added">1493 }</span>
<span class="line-added">1494 </span>
<span class="line-added">1495 void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-added">1496 {</span>
1497     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1498     if (!callbackID)
1499         return;
1500     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
1501 }
1502 
1503 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
1504 {
1505     ASSERT(!isMainThread());
1506     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);
1507 
1508     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);
1509 
1510     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));
1511 }
1512 
1513 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)
1514 {
1515     ASSERT(isMainThread());
1516     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);
1517 
1518     performErrorCallback(callbackIdentifier, error);
1519 }
1520 
1521 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1522 {
1523     ASSERT(isMainThread());
1524     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
1525 
<a name="52" id="anc52"></a><span class="line-added">1526     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1527         if (error) {</span>
<span class="line-added">1528             callback(WTFMove(*error), { });</span>
<span class="line-added">1529             return;</span>
<span class="line-added">1530         }</span>
<span class="line-added">1531         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));</span>
<span class="line-added">1532     });</span>
<span class="line-added">1533 }</span>
<span class="line-added">1534 </span>
<span class="line-added">1535 void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-added">1536 {</span>
1537     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1538     if (!callbackID)
1539         return;
1540     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
1541 }
1542 
1543 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)
1544 {
1545     ASSERT(!isMainThread());
1546     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);
1547 
1548     IDBGetResult result;
1549     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);
1550 
1551     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));
1552 }
1553 
1554 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1555 {
1556     ASSERT(isMainThread());
1557     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);
1558 
1559     performGetResultCallback(callbackIdentifier, error, result);
1560 }
1561 
1562 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1563 {
1564     ASSERT(isMainThread());
1565     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
1566 
<a name="53" id="anc53"></a><span class="line-added">1567     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1568         if (error) {</span>
<span class="line-added">1569             callback(WTFMove(*error), { });</span>
<span class="line-added">1570             return;</span>
<span class="line-added">1571         }</span>
<span class="line-added">1572         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));</span>
<span class="line-added">1573     });</span>
<span class="line-added">1574 }</span>
<span class="line-added">1575 </span>
<span class="line-added">1576 void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-added">1577 {</span>
1578     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1579     if (!callbackID)
1580         return;
1581     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
1582 }
1583 
1584 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)
1585 {
1586     ASSERT(!isMainThread());
1587     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);
1588 
1589     IDBGetResult result;
1590     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
1591 
1592     if (error.isNull()) {
1593         auto addResult = m_cursorPrefetches.add(cursorIdentifier);
1594         if (addResult.isNewEntry)
1595             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1596     }
1597 
1598     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformIterateCursor, callbackIdentifier, error, result));
1599 }
1600 
1601 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
1602 {
1603     ASSERT(!isMainThread());
1604     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));
1605     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);
1606 
1607     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))
1608         m_cursorPrefetches.remove(cursorIdentifier);
1609     else
1610         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1611 }
1612 
1613 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1614 {
1615     ASSERT(isMainThread());
1616     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
1617 
1618     performGetResultCallback(callbackIdentifier, error, result);
1619 }
1620 
<a name="54" id="anc54"></a><span class="line-modified">1621 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)</span>
1622 {
1623     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
1624     if (!takenTransaction)
1625         return false;
1626 
1627     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
<a name="55" id="anc55"></a><span class="line-added">1628     takenTransaction-&gt;setState(state);</span>
1629     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
1630 
1631     return true;
1632 }
1633 
1634 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1635 {
1636     ASSERT(isMainThread());
1637     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1638 
1639     ASSERT(transaction.databaseConnection().database() == this);
1640 
<a name="56" id="anc56"></a><span class="line-added">1641     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1642         if (error) {</span>
<span class="line-added">1643             callback(WTFMove(*error));</span>
<span class="line-added">1644             return;</span>
<span class="line-added">1645         }</span>
<span class="line-added">1646         if (!transaction) {</span>
<span class="line-added">1647             callback(IDBError { UnknownError });</span>
<span class="line-added">1648             return;</span>
<span class="line-added">1649         }</span>
<span class="line-added">1650         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));</span>
<span class="line-added">1651     });</span>
<span class="line-added">1652 }</span>
<span class="line-added">1653 </span>
<span class="line-added">1654 void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="line-added">1655 {</span>
1656     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1657     if (!callbackID)
1658         return;
1659 
<a name="57" id="anc57"></a><span class="line-modified">1660     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {</span>
1661         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1662             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
1663             forgetErrorCallback(callbackID);
1664             return;
1665         }
1666 
1667         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });
1668         return;
1669     }
1670 
1671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));
1672 }
1673 
1674 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1675 {
1676     ASSERT(!isMainThread());
1677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1678 
1679     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);
1680     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));
1681 }
1682 
1683 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1684 {
1685     ASSERT(isMainThread());
1686     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1687 
<a name="58" id="anc58"></a><span class="line-modified">1688     IDBError result = error;</span>
<span class="line-added">1689     auto transaction = m_finishingTransactions.get(transactionIdentifier);</span>
<span class="line-added">1690     switch (transaction-&gt;state()) {</span>
<span class="line-added">1691     case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-added">1692         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };</span>
<span class="line-added">1693         break;</span>
<span class="line-added">1694     case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-added">1695         result = transaction-&gt;result();</span>
<span class="line-added">1696         break;</span>
<span class="line-added">1697     case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-added">1698         break;</span>
<span class="line-added">1699     case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-added">1700     case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-added">1701         ASSERT_NOT_REACHED();</span>
<span class="line-added">1702     }</span>
<span class="line-added">1703 </span>
<span class="line-added">1704     performErrorCallback(callbackIdentifier, result);</span>
1705 
1706     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
1707 }
1708 
<a name="59" id="anc59"></a><span class="line-modified">1709 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)</span>
1710 {
1711     ASSERT(isMainThread());
1712     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1713 
1714     ASSERT(transaction.databaseConnection().database() == this);
1715 
<a name="60" id="anc60"></a><span class="line-added">1716     if (waitForPendingTasks == WaitForPendingTasks::Yes) {</span>
<span class="line-added">1717         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {</span>
<span class="line-added">1718             if (error) {</span>
<span class="line-added">1719                 callback(WTFMove(*error));</span>
<span class="line-added">1720                 return;</span>
<span class="line-added">1721             }</span>
<span class="line-added">1722             if (!transaction) {</span>
<span class="line-added">1723                 callback(IDBError { UnknownError });</span>
<span class="line-added">1724                 return;</span>
<span class="line-added">1725             }</span>
<span class="line-added">1726             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));</span>
<span class="line-added">1727         });</span>
<span class="line-added">1728         return;</span>
<span class="line-added">1729     }</span>
<span class="line-added">1730 </span>
1731     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1732     if (!callbackID)
1733         return;
1734 
<a name="61" id="anc61"></a><span class="line-modified">1735     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {</span>
1736         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1737             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
1738             forgetErrorCallback(callbackID);
1739             return;
1740         }
1741 
1742         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });
1743         return;
1744     }
1745 
1746     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));
1747 }
1748 
1749 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
1750 {
1751     ASSERT(isMainThread());
1752     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
1753 
1754     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
1755     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
1756 
1757     m_versionChangeTransaction = nullptr;
1758     m_versionChangeDatabaseConnection = nullptr;
1759 
1760     if (m_hardClosedForUserDelete) {
1761         maybeFinishHardClose();
1762         return;
1763     }
1764 
1765     invokeOperationAndTransactionTimer();
1766 }
1767 
1768 void UniqueIDBDatabase::performAbortTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1769 {
1770     ASSERT(!isMainThread());
1771     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1772 
1773     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
1774     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));
1775 }
1776 
1777 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1778 {
1779     ASSERT(isMainThread());
1780     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1781 
1782     auto transaction = m_finishingTransactions.take(transactionIdentifier);
1783     ASSERT(transaction);
1784 
1785     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
1786         ASSERT(m_versionChangeTransaction == transaction);
1787         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1788         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
<a name="62" id="anc62"></a><span class="line-modified">1789         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
1790     }
1791 
<a name="63" id="anc63"></a><span class="line-modified">1792     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;</span>
<span class="line-added">1793     performErrorCallback(callbackIdentifier, result);</span>
1794 
1795     transactionCompleted(WTFMove(transaction));
1796 }
1797 
1798 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
1799 {
1800     if (m_versionChangeTransaction == &amp;transaction)
1801         m_versionChangeTransaction = nullptr;
1802 }
1803 
1804 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1805 {
1806     ASSERT(isMainThread());
1807     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1808 
<a name="64" id="anc64"></a><span class="line-added">1809     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-added">1810         m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added">1811         if (m_hardClosedForUserDelete)</span>
<span class="line-added">1812             maybeFinishHardClose();</span>
<span class="line-added">1813         return;</span>
<span class="line-added">1814     }</span>
<span class="line-added">1815 </span>
1816     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1817     m_openDatabaseConnections.remove(&amp;connection);
1818 
1819     if (m_versionChangeDatabaseConnection == &amp;connection) {
1820         if (m_versionChangeTransaction) {
1821             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));
1822 
1823             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();
1824             if (m_inProgressTransactions.contains(transactionIdentifier)) {
1825                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));
1826                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
1827             }
1828 
1829             return;
1830         }
1831 
1832         m_versionChangeDatabaseConnection = nullptr;
1833     }
1834 
1835     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
1836     while (!m_pendingTransactions.isEmpty()) {
1837         auto transaction = m_pendingTransactions.takeFirst();
1838         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)
1839             pendingTransactions.append(WTFMove(transaction));
1840     }
1841 
1842     if (!pendingTransactions.isEmpty())
1843         m_pendingTransactions.swap(pendingTransactions);
1844 
1845     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;
1846     for (auto&amp; transaction : m_inProgressTransactions.values()) {
1847         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)
1848             transactionsToAbort.append(transaction);
1849     }
1850 
1851     for (auto&amp; transaction : transactionsToAbort)
1852         transaction-&gt;abortWithoutCallback();
1853 
1854     if (m_currentOpenDBRequest)
1855         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
1856 
1857     if (connection.hasNonFinishedTransactions()) {
1858         m_clientClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1859         return;
1860     }
1861 
1862     if (m_hardClosedForUserDelete) {
1863         maybeFinishHardClose();
1864         return;
1865     }
1866 
1867     // Now that a database connection has closed, previously blocked operations might be runnable.
1868     invokeOperationAndTransactionTimer();
1869 }
1870 
1871 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
1872 {
1873     ASSERT(isMainThread());
1874     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1875 
1876     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {
1877         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));
1878         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));
1879         return;
1880     }
1881 
1882     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1883     m_openDatabaseConnections.remove(&amp;connection);
1884 
1885     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1886 
1887     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1888 }
1889 
1890 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
1891 {
1892     ASSERT(isMainThread());
1893     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1894 
<a name="65" id="anc65"></a><span class="line-added">1895     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))</span>
<span class="line-added">1896         return;</span>
<span class="line-added">1897     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added">1898 </span>
1899     if (m_hardClosedForUserDelete)
1900         maybeFinishHardClose();
<a name="66" id="anc66"></a>

1901 }
1902 
1903 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1904 {
1905     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
1906     ASSERT(!m_hardClosedForUserDelete);
1907 
1908     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1909 
1910     m_pendingTransactions.append(WTFMove(transaction));
1911 
1912     invokeOperationAndTransactionTimer();
1913 }
1914 
1915 bool UniqueIDBDatabase::isCurrentlyInUse() const
1916 {
1917     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;
1918 }
1919 
1920 bool UniqueIDBDatabase::hasUnfinishedTransactions() const
1921 {
1922     return !m_inProgressTransactions.isEmpty() || !m_finishingTransactions.isEmpty();
1923 }
1924 
1925 void UniqueIDBDatabase::invokeOperationAndTransactionTimer()
1926 {
1927     LOG(IndexedDB, &quot;UniqueIDBDatabase::invokeOperationAndTransactionTimer()&quot;);
1928     RELEASE_ASSERT(!m_hardClosedForUserDelete);
1929     RELEASE_ASSERT(!m_owningPointerForClose);
1930 
1931     if (!m_operationAndTransactionTimer.isActive())
1932         m_operationAndTransactionTimer.startOneShot(0_s);
1933 }
1934 
1935 void UniqueIDBDatabase::operationAndTransactionTimerFired()
1936 {
1937     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::operationAndTransactionTimerFired&quot;);
1938     ASSERT(!m_hardClosedForUserDelete);
1939     ASSERT(isMainThread());
1940 
1941     // This UniqueIDBDatabase might be no longer in use by any web page.
1942     // Assuming it is not ephemeral, the server should now close it to free up resources.
1943     if (!m_backingStoreIsEphemeral &amp;&amp; !isCurrentlyInUse()) {
1944         ASSERT(m_pendingTransactions.isEmpty());
1945         ASSERT(!hasUnfinishedTransactions());
1946 
1947         scheduleShutdownForClose();
1948         return;
1949     }
1950 
1951     // The current operation might require multiple attempts to handle, so try to
1952     // make further progress on it now.
1953     if (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())
1954         handleCurrentOperation();
1955     else
1956         handleDatabaseOperations();
1957 
1958     bool hadDeferredTransactions = false;
1959     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
1960 
1961     if (transaction) {
1962         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
1963         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1964             m_objectStoreTransactionCounts.add(objectStore);
1965             if (!transaction-&gt;isReadOnly()) {
1966                 m_objectStoreWriteTransactions.add(objectStore);
1967                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
1968             }
1969         }
1970 
1971         activateTransactionInBackingStore(*transaction);
1972 
1973         // If no transactions were deferred, it&#39;s possible we can start another transaction right now.
1974         if (!hadDeferredTransactions)
1975             invokeOperationAndTransactionTimer();
1976     }
1977 }
1978 
1979 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1980 {
1981     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::activateTransactionInBackingStore&quot;);
1982     ASSERT(isMainThread());
1983 
1984     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; refTransaction(&amp;transaction);
1985 
1986     ErrorCallback callback = [refTransaction](const IDBError&amp; error) {
1987         refTransaction-&gt;didActivateInBackingStore(error);
1988     };
1989 
1990     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1991     if (!callbackID)
1992         return;
1993     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performActivateTransactionInBackingStore, callbackID, transaction.info()));
1994 }
1995 
1996 void UniqueIDBDatabase::performActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBTransactionInfo&amp; info)
1997 {
1998     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performActivateTransactionInBackingStore&quot;);
1999 
2000     IDBError error = m_backingStore-&gt;beginTransaction(info);
2001     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformActivateTransactionInBackingStore, callbackIdentifier, error));
2002 }
2003 
2004 void UniqueIDBDatabase::didPerformActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBError&amp; error)
2005 {
2006     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformActivateTransactionInBackingStore&quot;);
2007 
2008     if (m_hardClosedForUserDelete)
2009         return;
2010 
2011     invokeOperationAndTransactionTimer();
2012 
2013     performErrorCallback(callbackIdentifier, error);
2014 }
2015 
2016 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
2017 {
2018     for (auto scope : bScopes) {
2019         if (aScopes.contains(scope))
2020             return true;
2021     }
2022 
2023     return false;
2024 }
2025 
2026 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
2027 {
2028     hadDeferredTransactions = false;
2029 
2030     if (m_pendingTransactions.isEmpty())
2031         return nullptr;
2032 
2033     if (!m_backingStoreSupportsSimultaneousTransactions &amp;&amp; hasUnfinishedTransactions()) {
2034         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
2035         return nullptr;
2036     }
2037 
2038     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
2039     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
2040 
2041     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
2042 
2043     while (!m_pendingTransactions.isEmpty()) {
2044         currentTransaction = m_pendingTransactions.takeFirst();
2045 
2046         switch (currentTransaction-&gt;info().mode()) {
2047         case IDBTransactionMode::Readonly: {
2048             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2049             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
2050 
2051             if (hasOverlappingScopes)
2052                 deferredTransactions.append(WTFMove(currentTransaction));
2053 
2054             break;
2055         }
2056         case IDBTransactionMode::Readwrite: {
2057             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
2058             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
2059 
2060             if (hasOverlappingScopes) {
2061                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
2062                     deferredReadWriteScopes.add(objectStore);
2063                 deferredTransactions.append(WTFMove(currentTransaction));
2064             }
2065 
2066             break;
2067         }
2068         case IDBTransactionMode::Versionchange:
2069             // Version change transactions should never be scheduled in the traditional manner.
2070             RELEASE_ASSERT_NOT_REACHED();
2071         }
2072 
2073         // If we didn&#39;t defer the currentTransaction above, it can be run now.
2074         if (currentTransaction)
2075             break;
2076     }
2077 
2078     hadDeferredTransactions = !deferredTransactions.isEmpty();
2079     if (!hadDeferredTransactions)
2080         return currentTransaction;
2081 
2082     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
2083     while (!deferredTransactions.isEmpty())
2084         m_pendingTransactions.prepend(deferredTransactions.takeLast());
2085 
2086     return currentTransaction;
2087 }
2088 
2089 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
2090 {
2091     ASSERT(transaction);
2092     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
2093     ASSERT(!m_finishingTransactions.contains(transaction-&gt;info().identifier()));
2094     ASSERT(isMainThread());
2095 
2096     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
2097         if (!transaction-&gt;isReadOnly()) {
2098             m_objectStoreWriteTransactions.remove(objectStore);
2099             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
2100         }
2101         m_objectStoreTransactionCounts.remove(objectStore);
2102     }
2103 
2104     if (!transaction-&gt;databaseConnection().hasNonFinishedTransactions())
2105         m_clientClosePendingDatabaseConnections.remove(&amp;transaction-&gt;databaseConnection());
2106 
2107     if (m_versionChangeTransaction == transaction)
2108         m_versionChangeTransaction = nullptr;
2109 
2110     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.
2111     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.
2112     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {
2113         scheduleShutdownForClose();
2114         return;
2115     }
2116 
2117     // Previously blocked operations might be runnable.
2118     if (!m_hardClosedForUserDelete)
2119         invokeOperationAndTransactionTimer();
2120     else
2121         maybeFinishHardClose();
2122 }
2123 
2124 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
2125 {
2126     m_databaseQueue.append(WTFMove(task));
<a name="67" id="anc67"></a><span class="line-modified">2127     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
2128 }
2129 
2130 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
2131 {
<a name="68" id="anc68"></a><span class="line-added">2132     if (m_backingStore)</span>
<span class="line-added">2133         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added">2134 </span>
2135     m_databaseReplyQueue.append(WTFMove(task));
<a name="69" id="anc69"></a><span class="line-modified">2136     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
2137 }
2138 
2139 void UniqueIDBDatabase::executeNextDatabaseTask()
2140 {
2141     ASSERT(!isMainThread());
2142     ASSERT(!m_databaseQueue.isKilled());
2143 
2144     auto task = m_databaseQueue.tryGetMessage();
2145     ASSERT(task);
2146 
2147     task-&gt;performTask();
2148 }
2149 
2150 void UniqueIDBDatabase::executeNextDatabaseTaskReply()
2151 {
2152     ASSERT(isMainThread());
2153     ASSERT(!m_databaseReplyQueue.isKilled());
2154 
2155     auto task = m_databaseReplyQueue.tryGetMessage();
2156     ASSERT(task);
2157 
2158     task-&gt;performTask();
2159 
2160     // If this database was force closed (e.g. for a user delete) and there are no more
2161     // cleanup tasks left, delete this.
2162     maybeFinishHardClose();
2163 }
2164 
2165 void UniqueIDBDatabase::maybeFinishHardClose()
2166 {
2167     if (m_owningPointerForClose &amp;&amp; isDoneWithHardClose()) {
2168         if (m_owningPointerReleaseScheduled)
2169             return;
2170         m_owningPointerReleaseScheduled = true;
2171 
2172         callOnMainThread([this] {
2173             ASSERT(isDoneWithHardClose());
2174             m_owningPointerForClose = nullptr;
2175         });
2176     }
2177 }
2178 
2179 bool UniqueIDBDatabase::isDoneWithHardClose()
2180 {
2181     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();
2182 }
2183 
2184 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
2185 {
2186     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
2187     if (request.isOpenRequest())
2188         request.connection().didOpenDatabase(result);
2189     else
2190         request.connection().didDeleteDatabase(result);
2191 }
2192 
2193 void UniqueIDBDatabase::immediateCloseForUserDelete()
2194 {
2195     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
2196 
2197     ASSERT(isMainThread());
2198 
<a name="70" id="anc70"></a><span class="line-added">2199     m_pendingSpaceIncreasingTasks.clear();</span>
<span class="line-added">2200     m_server-&gt;resetSpaceUsed(m_identifier.origin());</span>
<span class="line-added">2201 </span>
2202     // Error out all transactions
2203     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
2204         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
2205 
2206     ASSERT(m_inProgressTransactions.isEmpty());
2207 
2208     for (auto&amp; transaction : m_pendingTransactions)
2209         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
2210     m_pendingTransactions.clear();
2211     m_objectStoreTransactionCounts.clear();
2212     m_objectStoreWriteTransactions.clear();
2213 
2214     // Error out all pending callbacks
2215     IDBError error = IDBError::userDeleteError();
2216     IDBKeyData keyData;
2217     IDBGetResult getResult;
2218     IDBGetAllResult getAllResult;
2219 
2220     while (!m_callbackQueue.isEmpty()) {
2221         auto identifier = m_callbackQueue.first();
2222         if (m_errorCallbacks.contains(identifier))
2223             performErrorCallback(identifier, error);
2224         else if (m_keyDataCallbacks.contains(identifier))
2225             performKeyDataCallback(identifier, error, keyData);
2226         else if (m_getResultCallbacks.contains(identifier))
2227             performGetResultCallback(identifier, error, getResult);
2228         else if (m_countCallbacks.contains(identifier))
2229             performCountCallback(identifier, error, 0);
2230         else if (m_getAllResultsCallbacks.contains(identifier))
2231             performGetAllResultsCallback(identifier, error, getAllResult);
2232         else
2233             ASSERT_NOT_REACHED();
2234     }
2235 
2236     // Error out all IDBOpenDBRequests
2237     if (m_currentOpenDBRequest) {
2238         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
2239         m_currentOpenDBRequest = nullptr;
2240     }
2241 
2242     for (auto&amp; request : m_pendingOpenDBRequests)
2243         errorOpenDBRequestForUserDelete(*request);
2244 
2245     m_pendingOpenDBRequests.clear();
2246 
2247     // Close all open connections
2248     auto openDatabaseConnections = m_openDatabaseConnections;
2249     for (auto&amp; connection : openDatabaseConnections)
2250         connectionClosedFromServer(*connection);
2251 
<a name="71" id="anc71"></a><span class="line-added">2252     if (m_versionChangeDatabaseConnection) {</span>
<span class="line-added">2253         connectionClosedFromServer(*m_versionChangeDatabaseConnection);</span>
<span class="line-added">2254         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added">2255     }</span>
<span class="line-added">2256 </span>
2257     // Cancel the operation timer
2258     m_operationAndTransactionTimer.stop();
2259 
2260     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
2261     // database connections confirm that they have closed.
2262     m_hardClosedForUserDelete = true;
2263 
2264     // If this database already owns itself, it is already closing on the background thread.
2265     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;
2266     // which will also cover this database.
2267     if (m_owningPointerForClose)
2268         return;
2269 
2270     // Otherwise, this database is still potentially active.
2271     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
<a name="72" id="anc72"></a><span class="line-modified">2272     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
2273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
2274 }
2275 
<a name="73" id="anc73"></a><span class="line-added">2276 void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)</span>
<span class="line-added">2277 {</span>
<span class="line-added">2278     ASSERT(isMainThread());</span>
<span class="line-added">2279 </span>
<span class="line-added">2280     if (optionalCallbackIdentifier) {</span>
<span class="line-added">2281         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();</span>
<span class="line-added">2282         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);</span>
<span class="line-added">2283         if (iterator != m_pendingSpaceIncreasingTasks.end()) {</span>
<span class="line-added">2284             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);</span>
<span class="line-added">2285             m_pendingSpaceIncreasingTasks.remove(iterator);</span>
<span class="line-added">2286         }</span>
<span class="line-added">2287     }</span>
<span class="line-added">2288 </span>
<span class="line-added">2289     uint64_t databaseSize = m_newDatabaseSize;</span>
<span class="line-added">2290     if (databaseSize != m_currentDatabaseSize) {</span>
<span class="line-added">2291         if (databaseSize &gt; m_currentDatabaseSize)</span>
<span class="line-added">2292             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);</span>
<span class="line-added">2293         else</span>
<span class="line-added">2294             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);</span>
<span class="line-added">2295         m_currentDatabaseSize = databaseSize;</span>
<span class="line-added">2296     }</span>
<span class="line-added">2297 }</span>
<span class="line-added">2298 </span>
2299 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
2300 {
<a name="74" id="anc74"></a><span class="line-added">2301     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2302 </span>
2303     auto callback = m_errorCallbacks.take(callbackIdentifier);
2304     ASSERT(callback || m_hardClosedForUserDelete);
2305     if (callback) {
2306         callback(error);
2307         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2308         m_callbackQueue.removeFirst();
2309     }
2310 }
2311 
2312 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
2313 {
<a name="75" id="anc75"></a><span class="line-added">2314     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2315 </span>
2316     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
2317     ASSERT(callback || m_hardClosedForUserDelete);
2318     if (callback) {
2319         callback(error, resultKey);
2320         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2321         m_callbackQueue.removeFirst();
2322     }
2323 }
2324 
2325 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)
2326 {
2327     auto callback = m_getResultCallbacks.take(callbackIdentifier);
2328     ASSERT(callback || m_hardClosedForUserDelete);
2329     if (callback) {
2330         callback(error, resultData);
2331         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2332         m_callbackQueue.removeFirst();
2333     }
2334 }
2335 
2336 void UniqueIDBDatabase::performGetAllResultsCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; resultData)
2337 {
2338     auto callback = m_getAllResultsCallbacks.take(callbackIdentifier);
2339     ASSERT(callback || m_hardClosedForUserDelete);
2340     if (callback) {
2341         callback(error, resultData);
2342         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2343         m_callbackQueue.removeFirst();
2344     }
2345 }
2346 
2347 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
2348 {
2349     auto callback = m_countCallbacks.take(callbackIdentifier);
2350     ASSERT(callback || m_hardClosedForUserDelete);
2351     if (callback) {
2352         callback(error, count);
2353         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2354         m_callbackQueue.removeFirst();
2355     }
2356 }
2357 
2358 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
2359 {
<a name="76" id="anc76"></a><span class="line-added">2360     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2361 </span>
2362     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
2363     ASSERT(m_callbackQueue.last() == callbackIdentifier);
2364     m_callbackQueue.removeLast();
2365     m_errorCallbacks.remove(callbackIdentifier);
2366 }
2367 
<a name="77" id="anc77"></a><span class="line-modified">2368 void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
2369 {
<a name="78" id="anc78"></a><span class="line-modified">2370     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));</span>
<span class="line-modified">2371     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);</span>
<span class="line-added">2372 }</span>
<span class="line-added">2373 </span>
<span class="line-added">2374 void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="line-added">2375 {</span>
<span class="line-added">2376     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));</span>
<span class="line-added">2377     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);</span>
<span class="line-added">2378 }</span>
<span class="line-added">2379 </span>
<span class="line-added">2380 void UniqueIDBDatabase::finishActiveTransactions()</span>
<span class="line-added">2381 {</span>
<span class="line-added">2382     ASSERT(isMainThread());</span>
<span class="line-added">2383 </span>
<span class="line-added">2384     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-added">2385         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-added">2386         abortTransactionOnMainThread(*transaction);</span>
<span class="line-added">2387     }</span>
<span class="line-added">2388 </span>
<span class="line-added">2389     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {</span>
<span class="line-added">2390         if (!m_backingStore-&gt;hasTransaction(identifier))</span>
<span class="line-added">2391             continue;</span>
<span class="line-added">2392 </span>
<span class="line-added">2393         auto transaction = m_finishingTransactions.get(identifier);</span>
<span class="line-added">2394         switch (transaction-&gt;state()) {</span>
<span class="line-added">2395         case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-added">2396             abortTransactionOnMainThread(*transaction);</span>
<span class="line-added">2397             break;</span>
<span class="line-added">2398         case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-added">2399             commitTransactionOnMainThread(*transaction);</span>
<span class="line-added">2400             break;</span>
<span class="line-added">2401         case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-added">2402         case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-added">2403         case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-added">2404             ASSERT_NOT_REACHED();</span>
<span class="line-added">2405         }</span>
<span class="line-added">2406     }</span>
2407 }
2408 
2409 } // namespace IDBServer
2410 } // namespace WebCore
2411 
2412 #endif // ENABLE(INDEXED_DATABASE)
<a name="79" id="anc79"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="79" type="hidden" />
</body>
</html>