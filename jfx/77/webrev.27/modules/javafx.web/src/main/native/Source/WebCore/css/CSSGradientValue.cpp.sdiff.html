<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFontVariationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGridAutoRepeatValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008 Apple Inc.  All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  47         return downcast&lt;CSSLinearGradientValue&gt;(value).createGradient(renderer, size);
  48     if (is&lt;CSSRadialGradientValue&gt;(value))
  49         return downcast&lt;CSSRadialGradientValue&gt;(value).createGradient(renderer, size);
  50     return downcast&lt;CSSConicGradientValue&gt;(value).createGradient(renderer, size);
  51 }
  52 
  53 RefPtr&lt;Image&gt; CSSGradientValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)
  54 {
  55     if (size.isEmpty())
  56         return nullptr;
  57     bool cacheable = isCacheable() &amp;&amp; !renderer.style().hasAppleColorFilter();
  58     if (cacheable) {
  59         if (!clients().contains(&amp;renderer))
  60             return nullptr;
  61         if (auto* result = cachedImageForSize(size))
  62             return result;
  63     }
  64     auto newImage = GradientImage::create(createGradient(*this, renderer, size), size);
  65     if (cacheable)
  66         saveCachedImageForSize(size, newImage.get());
<span class="line-modified">  67     return WTFMove(newImage);</span>
  68 }
  69 
  70 // Should only ever be called for deprecated gradients.
  71 static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  72 {
  73     double aVal = a.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);
  74     double bVal = b.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);
  75 
  76     return aVal &lt; bVal;
  77 }
  78 
  79 void CSSGradientValue::sortStopsIfNeeded()
  80 {
  81     ASSERT(m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient);
  82     if (!m_stopsSorted) {
  83         if (m_stops.size())
  84             std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
  85         m_stopsSorted = true;
  86     }
  87 }
</pre>
<hr />
<pre>
 213             } else {
 214                 // All stops are below 0; just clamp them.
 215                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i)
 216                     stops[i].offset = 0;
 217             }
 218         }
 219 
 220         for (auto&amp; stop : stops)
 221             stop.offset /= scale;
 222 
 223         m_data.startRadius *= scale;
 224         m_data.endRadius *= scale;
 225     }
 226 
 227 private:
 228     Gradient::RadialData&amp; m_data;
 229 };
 230 
 231 class ConicGradientAdapter {
 232 public:
<span class="line-removed"> 233     explicit ConicGradientAdapter() { }</span>
 234     float gradientLength() const { return 1; }
 235     float maxExtent(float, float) const { return 1; }
 236 
 237     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 238     {
 239         auto numStops = stops.size();
 240 
 241         size_t firstZeroOrGreaterIndex = numStops;
 242         for (size_t i = 0; i &lt; numStops; ++i) {
 243             if (stops[i].offset &gt;= 0) {
 244                 firstZeroOrGreaterIndex = i;
 245                 break;
 246             }
 247         }
 248 
 249         if (firstZeroOrGreaterIndex &gt; 0) {
 250             if (firstZeroOrGreaterIndex &lt; numStops &amp;&amp; stops[firstZeroOrGreaterIndex].offset &gt; 0) {
 251                 float prevOffset = stops[firstZeroOrGreaterIndex - 1].offset;
 252                 float nextOffset = stops[firstZeroOrGreaterIndex].offset;
 253 
</pre>
<hr />
<pre>
 650 }
 651 
 652 bool CSSGradientValue::knownToBeOpaque(const RenderElement&amp; renderer) const
 653 {
 654     bool hasColorFilter = renderer.style().hasAppleColorFilter();
 655 
 656     for (auto&amp; stop : m_stops) {
 657         if (hasColorFilter) {
 658             Color stopColor = stop.m_resolvedColor;
 659             renderer.style().appleColorFilter().transformColor(stopColor);
 660             if (!stopColor.isOpaque())
 661                 return false;
 662         }
 663 
 664         if (!stop.m_resolvedColor.isOpaque())
 665             return false;
 666     }
 667     return true;
 668 }
 669 













 670 String CSSLinearGradientValue::customCSSText() const
 671 {
 672     StringBuilder result;
 673     if (m_gradientType == CSSDeprecatedLinearGradient) {
<span class="line-modified"> 674         result.appendLiteral(&quot;-webkit-gradient(linear, &quot;);</span>
<span class="line-modified"> 675         result.append(m_firstX-&gt;cssText());</span>
<span class="line-removed"> 676         result.append(&#39; &#39;);</span>
<span class="line-removed"> 677         result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed"> 678         result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 679         result.append(m_secondX-&gt;cssText());</span>
<span class="line-removed"> 680         result.append(&#39; &#39;);</span>
<span class="line-removed"> 681         result.append(m_secondY-&gt;cssText());</span>
<span class="line-removed"> 682 </span>
<span class="line-removed"> 683         for (auto&amp; stop : m_stops) {</span>
<span class="line-removed"> 684             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 685             auto position = stop.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-removed"> 686             if (!position) {</span>
<span class="line-removed"> 687                 result.appendLiteral(&quot;from(&quot;);</span>
<span class="line-removed"> 688                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 689                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 690             } else if (position == 1) {</span>
<span class="line-removed"> 691                 result.appendLiteral(&quot;to(&quot;);</span>
<span class="line-removed"> 692                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 693                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 694             } else {</span>
<span class="line-removed"> 695                 result.appendLiteral(&quot;color-stop(&quot;);</span>
<span class="line-removed"> 696                 result.appendNumber(position);</span>
<span class="line-removed"> 697                 result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 698                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 699                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 700             }</span>
<span class="line-removed"> 701         }</span>
 702     } else if (m_gradientType == CSSPrefixedLinearGradient) {
 703         if (m_repeating)
 704             result.appendLiteral(&quot;-webkit-repeating-linear-gradient(&quot;);
 705         else
 706             result.appendLiteral(&quot;-webkit-linear-gradient(&quot;);
 707 
 708         if (m_angle)
 709             result.append(m_angle-&gt;cssText());
 710         else {
<span class="line-modified"> 711             if (m_firstX &amp;&amp; m_firstY) {</span>


 712                 result.append(m_firstX-&gt;cssText());
<span class="line-modified"> 713                 result.append(&#39; &#39;);</span>
 714                 result.append(m_firstY-&gt;cssText());
<span class="line-removed"> 715             } else if (m_firstX || m_firstY) {</span>
<span class="line-removed"> 716                 if (m_firstX)</span>
<span class="line-removed"> 717                     result.append(m_firstX-&gt;cssText());</span>
<span class="line-removed"> 718 </span>
<span class="line-removed"> 719                 if (m_firstY)</span>
<span class="line-removed"> 720                     result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed"> 721             }</span>
 722         }
 723 
<span class="line-modified"> 724         for (unsigned i = 0; i &lt; m_stops.size(); i++) {</span>
<span class="line-modified"> 725             auto&amp; stop = m_stops[i];</span>
<span class="line-modified"> 726             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified"> 727             result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 728             if (stop.m_position) {</span>
<span class="line-removed"> 729                 result.append(&#39; &#39;);</span>
<span class="line-removed"> 730                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed"> 731             }</span>
 732         }
 733     } else {
 734         if (m_repeating)
 735             result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
 736         else
 737             result.appendLiteral(&quot;linear-gradient(&quot;);
 738 
 739         bool wroteSomething = false;
 740 
 741         if (m_angle &amp;&amp; m_angle-&gt;computeDegrees() != 180) {
 742             result.append(m_angle-&gt;cssText());
 743             wroteSomething = true;
 744         } else if ((m_firstX || m_firstY) &amp;&amp; !(!m_firstX &amp;&amp; m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)) {
 745             result.appendLiteral(&quot;to &quot;);
<span class="line-modified"> 746             if (m_firstX &amp;&amp; m_firstY) {</span>
<span class="line-modified"> 747                 result.append(m_firstX-&gt;cssText());</span>
<span class="line-modified"> 748                 result.append(&#39; &#39;);</span>
<span class="line-removed"> 749                 result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed"> 750             } else if (m_firstX)</span>
 751                 result.append(m_firstX-&gt;cssText());
 752             else
 753                 result.append(m_firstY-&gt;cssText());
 754             wroteSomething = true;
 755         }
 756 
 757         if (wroteSomething)
 758             result.appendLiteral(&quot;, &quot;);
 759 
<span class="line-modified"> 760         for (unsigned i = 0; i &lt; m_stops.size(); i++) {</span>
<span class="line-modified"> 761             const CSSGradientColorStop&amp; stop = m_stops[i];</span>
<span class="line-modified"> 762             if (i)</span>
 763                 result.appendLiteral(&quot;, &quot;);

 764             if (!stop.isMidpoint)
 765                 result.append(stop.m_color-&gt;cssText());
 766             if (stop.m_position) {
 767                 if (!stop.isMidpoint)
 768                     result.append(&#39; &#39;);
 769                 result.append(stop.m_position-&gt;cssText());
 770             }
 771         }
<span class="line-removed"> 772 </span>
 773     }
 774 
 775     result.append(&#39;)&#39;);
 776     return result.toString();
 777 }
 778 
 779 // Compute the endpoints so that a gradient of the given angle covers a box of the given size.
 780 static void endPointsFromAngle(float angleDeg, const FloatSize&amp; size, FloatPoint&amp; firstPoint, FloatPoint&amp; secondPoint, CSSGradientType type)
 781 {
 782     // Prefixed gradients use &quot;polar coordinate&quot; angles, rather than &quot;bearing&quot; angles.
 783     if (type == CSSPrefixedLinearGradient)
 784         angleDeg = 90 - angleDeg;
 785 
 786     angleDeg = fmodf(angleDeg, 360);
 787     if (angleDeg &lt; 0)
 788         angleDeg += 360;
 789 
 790     if (!angleDeg) {
 791         firstPoint.set(0, size.height());
 792         secondPoint.set(0, 0);
</pre>
<hr />
<pre>
 930         return false;
 931 
 932     bool equalXandY = false;
 933     if (m_firstX &amp;&amp; m_firstY)
 934         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
 935     else if (m_firstX)
 936         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
 937     else if (m_firstY)
 938         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
 939     else
 940         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
 941 
 942     return equalXandY &amp;&amp; m_stops == other.m_stops;
 943 }
 944 
 945 String CSSRadialGradientValue::customCSSText() const
 946 {
 947     StringBuilder result;
 948 
 949     if (m_gradientType == CSSDeprecatedRadialGradient) {
<span class="line-modified"> 950         result.appendLiteral(&quot;-webkit-gradient(radial, &quot;);</span>
<span class="line-modified"> 951         result.append(m_firstX-&gt;cssText());</span>
<span class="line-modified"> 952         result.append(&#39; &#39;);</span>
<span class="line-removed"> 953         result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed"> 954         result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 955         result.append(m_firstRadius-&gt;cssText());</span>
<span class="line-removed"> 956         result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 957         result.append(m_secondX-&gt;cssText());</span>
<span class="line-removed"> 958         result.append(&#39; &#39;);</span>
<span class="line-removed"> 959         result.append(m_secondY-&gt;cssText());</span>
<span class="line-removed"> 960         result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 961         result.append(m_secondRadius-&gt;cssText());</span>
<span class="line-removed"> 962 </span>
<span class="line-removed"> 963         // FIXME: share?</span>
<span class="line-removed"> 964         for (auto&amp; stop : m_stops) {</span>
<span class="line-removed"> 965             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 966             auto position = stop.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-removed"> 967             if (!position) {</span>
<span class="line-removed"> 968                 result.appendLiteral(&quot;from(&quot;);</span>
<span class="line-removed"> 969                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 970                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 971             } else if (position == 1) {</span>
<span class="line-removed"> 972                 result.appendLiteral(&quot;to(&quot;);</span>
<span class="line-removed"> 973                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 974                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 975             } else {</span>
<span class="line-removed"> 976                 result.appendLiteral(&quot;color-stop(&quot;);</span>
<span class="line-removed"> 977                 result.appendNumber(position);</span>
<span class="line-removed"> 978                 result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed"> 979                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 980                 result.append(&#39;)&#39;);</span>
<span class="line-removed"> 981             }</span>
<span class="line-removed"> 982         }</span>
 983     } else if (m_gradientType == CSSPrefixedRadialGradient) {
 984         if (m_repeating)
 985             result.appendLiteral(&quot;-webkit-repeating-radial-gradient(&quot;);
 986         else
 987             result.appendLiteral(&quot;-webkit-radial-gradient(&quot;);
 988 
<span class="line-modified"> 989         if (m_firstX &amp;&amp; m_firstY) {</span>
<span class="line-modified"> 990             result.append(m_firstX-&gt;cssText());</span>
<span class="line-modified"> 991             result.append(&#39; &#39;);</span>
<span class="line-removed"> 992             result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed"> 993         } else if (m_firstX)</span>
 994             result.append(m_firstX-&gt;cssText());
<span class="line-modified"> 995          else if (m_firstY)</span>
 996             result.append(m_firstY-&gt;cssText());
 997         else
 998             result.appendLiteral(&quot;center&quot;);
 999 
1000         if (m_shape || m_sizingBehavior) {
1001             result.appendLiteral(&quot;, &quot;);
<span class="line-modified">1002             if (m_shape) {</span>
<span class="line-modified">1003                 result.append(m_shape-&gt;cssText());</span>
<span class="line-modified">1004                 result.append(&#39; &#39;);</span>
<span class="line-removed">1005             } else</span>
1006                 result.appendLiteral(&quot;ellipse &quot;);
<span class="line-removed">1007 </span>
1008             if (m_sizingBehavior)
1009                 result.append(m_sizingBehavior-&gt;cssText());
1010             else
1011                 result.appendLiteral(&quot;cover&quot;);


1012 
<span class="line-modified">1013         } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize) {</span>
<span class="line-modified">1014             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified">1015             result.append(m_endHorizontalSize-&gt;cssText());</span>
<span class="line-modified">1016             result.append(&#39; &#39;);</span>
<span class="line-removed">1017             result.append(m_endVerticalSize-&gt;cssText());</span>
<span class="line-removed">1018         }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020         for (unsigned i = 0; i &lt; m_stops.size(); i++) {</span>
<span class="line-removed">1021             const CSSGradientColorStop&amp; stop = m_stops[i];</span>
<span class="line-removed">1022             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">1023             result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">1024             if (stop.m_position) {</span>
<span class="line-removed">1025                 result.append(&#39; &#39;);</span>
<span class="line-removed">1026                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">1027             }</span>
1028         }
1029     } else {
1030         if (m_repeating)
1031             result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
1032         else
1033             result.appendLiteral(&quot;radial-gradient(&quot;);
1034 
1035         bool wroteSomething = false;
1036 
1037         // The only ambiguous case that needs an explicit shape to be provided
1038         // is when a sizing keyword is used (or all sizing is omitted).
1039         if (m_shape &amp;&amp; m_shape-&gt;valueID() != CSSValueEllipse &amp;&amp; (m_sizingBehavior || (!m_sizingBehavior &amp;&amp; !m_endHorizontalSize))) {
1040             result.appendLiteral(&quot;circle&quot;);
1041             wroteSomething = true;
1042         }
1043 
1044         if (m_sizingBehavior &amp;&amp; m_sizingBehavior-&gt;valueID() != CSSValueFarthestCorner) {
1045             if (wroteSomething)
1046                 result.append(&#39; &#39;);
1047             result.append(m_sizingBehavior-&gt;cssText());
1048             wroteSomething = true;
1049         } else if (m_endHorizontalSize) {
1050             if (wroteSomething)
1051                 result.append(&#39; &#39;);
1052             result.append(m_endHorizontalSize-&gt;cssText());
<span class="line-modified">1053             if (m_endVerticalSize) {</span>
<span class="line-modified">1054                 result.append(&#39; &#39;);</span>
<span class="line-removed">1055                 result.append(m_endVerticalSize-&gt;cssText());</span>
<span class="line-removed">1056             }</span>
1057             wroteSomething = true;
1058         }
1059 
1060         if (m_firstX || m_firstY) {
1061             if (wroteSomething)
1062                 result.append(&#39; &#39;);
1063             result.appendLiteral(&quot;at &quot;);
<span class="line-modified">1064             if (m_firstX &amp;&amp; m_firstY) {</span>
<span class="line-modified">1065                 result.append(m_firstX-&gt;cssText());</span>
<span class="line-modified">1066                 result.append(&#39; &#39;);</span>
<span class="line-removed">1067                 result.append(m_firstY-&gt;cssText());</span>
<span class="line-removed">1068             } else if (m_firstX)</span>
1069                 result.append(m_firstX-&gt;cssText());
1070             else
1071                 result.append(m_firstY-&gt;cssText());
1072             wroteSomething = true;
1073         }
1074 
1075         if (wroteSomething)
1076             result.appendLiteral(&quot;, &quot;);
1077 
1078         for (unsigned i = 0; i &lt; m_stops.size(); i++) {
1079             const CSSGradientColorStop&amp; stop = m_stops[i];
1080             if (i)
1081                 result.appendLiteral(&quot;, &quot;);
1082             if (!stop.isMidpoint)
1083                 result.append(stop.m_color-&gt;cssText());
1084             if (stop.m_position) {
1085                 if (!stop.isMidpoint)
1086                     result.append(&#39; &#39;);
1087                 result.append(stop.m_position-&gt;cssText());
1088             }
1089         }
1090 
1091     }
1092 
1093     result.append(&#39;)&#39;);
1094     return result.toString();
1095 }
1096 
1097 float CSSRadialGradientValue::resolveRadius(CSSPrimitiveValue&amp; radius, const CSSToLengthConversionData&amp; conversionData, float* widthOrHeight)
1098 {
1099     float result = 0;
<span class="line-modified">1100     if (radius.isNumber()) // Can the radius be a percentage?</span>
1101         result = radius.floatValue() * conversionData.zoom();
1102     else if (widthOrHeight &amp;&amp; radius.isPercentage())
1103         result = *widthOrHeight * radius.floatValue() / 100;
1104     else
1105         result = radius.computeLength&lt;float&gt;(conversionData);
<span class="line-removed">1106 </span>
1107     return result;
1108 }
1109 
1110 static float distanceToClosestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1111 {
1112     FloatPoint topLeft;
1113     float topLeftDistance = FloatSize(p - topLeft).diagonalLength();
1114 
1115     FloatPoint topRight(size.width(), 0);
1116     float topRightDistance = FloatSize(p - topRight).diagonalLength();
1117 
1118     FloatPoint bottomLeft(0, size.height());
1119     float bottomLeftDistance = FloatSize(p - bottomLeft).diagonalLength();
1120 
1121     FloatPoint bottomRight(size.width(), size.height());
1122     float bottomRightDistance = FloatSize(p - bottomRight).diagonalLength();
1123 
1124     corner = topLeft;
1125     float minDistance = topLeftDistance;
1126     if (topRightDistance &lt; minDistance) {
</pre>
<hr />
<pre>
1369         equalShape = !other.m_shape;
1370         equalSizingBehavior = !other.m_sizingBehavior;
1371         equalHorizontalAndVerticalSize = !other.m_endHorizontalSize &amp;&amp; !other.m_endVerticalSize;
1372     }
1373     return equalShape &amp;&amp; equalSizingBehavior &amp;&amp; equalHorizontalAndVerticalSize &amp;&amp; m_stops == other.m_stops;
1374 }
1375 
1376 
1377 String CSSConicGradientValue::customCSSText() const
1378 {
1379     StringBuilder result;
1380 
1381     if (m_repeating)
1382         result.appendLiteral(&quot;repeating-conic-gradient(&quot;);
1383     else
1384         result.appendLiteral(&quot;conic-gradient(&quot;);
1385 
1386     bool wroteSomething = false;
1387 
1388     if (m_angle) {
<span class="line-modified">1389         result.appendLiteral(&quot;from &quot;);</span>
<span class="line-removed">1390         result.append(m_angle-&gt;cssText());</span>
1391         wroteSomething = true;
1392     }
1393 
1394     if (m_firstX &amp;&amp; m_firstY) {
1395         if (wroteSomething)
<span class="line-modified">1396             result.appendLiteral(&quot; &quot;);</span>
<span class="line-modified">1397         result.appendLiteral(&quot;at &quot;);</span>
<span class="line-removed">1398         result.append(m_firstX-&gt;cssText());</span>
<span class="line-removed">1399         result.append(&#39; &#39;);</span>
<span class="line-removed">1400         result.append(m_firstY-&gt;cssText());</span>
1401         wroteSomething = true;
1402     }
1403 
1404     if (wroteSomething)
1405         result.appendLiteral(&quot;, &quot;);
1406 
1407     bool wroteFirstStop = false;
1408     for (auto&amp; stop : m_stops) {
1409         if (wroteFirstStop)
1410             result.appendLiteral(&quot;, &quot;);
1411         wroteFirstStop = true;
1412         if (!stop.isMidpoint)
1413             result.append(stop.m_color-&gt;cssText());
1414         if (stop.m_position) {
1415             if (!stop.isMidpoint)
1416                 result.append(&#39; &#39;);
1417             result.append(stop.m_position-&gt;cssText());
1418         }
1419     }
1420 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  47         return downcast&lt;CSSLinearGradientValue&gt;(value).createGradient(renderer, size);
  48     if (is&lt;CSSRadialGradientValue&gt;(value))
  49         return downcast&lt;CSSRadialGradientValue&gt;(value).createGradient(renderer, size);
  50     return downcast&lt;CSSConicGradientValue&gt;(value).createGradient(renderer, size);
  51 }
  52 
  53 RefPtr&lt;Image&gt; CSSGradientValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)
  54 {
  55     if (size.isEmpty())
  56         return nullptr;
  57     bool cacheable = isCacheable() &amp;&amp; !renderer.style().hasAppleColorFilter();
  58     if (cacheable) {
  59         if (!clients().contains(&amp;renderer))
  60             return nullptr;
  61         if (auto* result = cachedImageForSize(size))
  62             return result;
  63     }
  64     auto newImage = GradientImage::create(createGradient(*this, renderer, size), size);
  65     if (cacheable)
  66         saveCachedImageForSize(size, newImage.get());
<span class="line-modified">  67     return newImage;</span>
  68 }
  69 
  70 // Should only ever be called for deprecated gradients.
  71 static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  72 {
  73     double aVal = a.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);
  74     double bVal = b.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);
  75 
  76     return aVal &lt; bVal;
  77 }
  78 
  79 void CSSGradientValue::sortStopsIfNeeded()
  80 {
  81     ASSERT(m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient);
  82     if (!m_stopsSorted) {
  83         if (m_stops.size())
  84             std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
  85         m_stopsSorted = true;
  86     }
  87 }
</pre>
<hr />
<pre>
 213             } else {
 214                 // All stops are below 0; just clamp them.
 215                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i)
 216                     stops[i].offset = 0;
 217             }
 218         }
 219 
 220         for (auto&amp; stop : stops)
 221             stop.offset /= scale;
 222 
 223         m_data.startRadius *= scale;
 224         m_data.endRadius *= scale;
 225     }
 226 
 227 private:
 228     Gradient::RadialData&amp; m_data;
 229 };
 230 
 231 class ConicGradientAdapter {
 232 public:

 233     float gradientLength() const { return 1; }
 234     float maxExtent(float, float) const { return 1; }
 235 
 236     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 237     {
 238         auto numStops = stops.size();
 239 
 240         size_t firstZeroOrGreaterIndex = numStops;
 241         for (size_t i = 0; i &lt; numStops; ++i) {
 242             if (stops[i].offset &gt;= 0) {
 243                 firstZeroOrGreaterIndex = i;
 244                 break;
 245             }
 246         }
 247 
 248         if (firstZeroOrGreaterIndex &gt; 0) {
 249             if (firstZeroOrGreaterIndex &lt; numStops &amp;&amp; stops[firstZeroOrGreaterIndex].offset &gt; 0) {
 250                 float prevOffset = stops[firstZeroOrGreaterIndex - 1].offset;
 251                 float nextOffset = stops[firstZeroOrGreaterIndex].offset;
 252 
</pre>
<hr />
<pre>
 649 }
 650 
 651 bool CSSGradientValue::knownToBeOpaque(const RenderElement&amp; renderer) const
 652 {
 653     bool hasColorFilter = renderer.style().hasAppleColorFilter();
 654 
 655     for (auto&amp; stop : m_stops) {
 656         if (hasColorFilter) {
 657             Color stopColor = stop.m_resolvedColor;
 658             renderer.style().appleColorFilter().transformColor(stopColor);
 659             if (!stopColor.isOpaque())
 660                 return false;
 661         }
 662 
 663         if (!stop.m_resolvedColor.isOpaque())
 664             return false;
 665     }
 666     return true;
 667 }
 668 
<span class="line-added"> 669 static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)</span>
<span class="line-added"> 670 {</span>
<span class="line-added"> 671     for (auto&amp; stop : stops) {</span>
<span class="line-added"> 672         double position = stop.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-added"> 673         if (!position)</span>
<span class="line-added"> 674             builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
<span class="line-added"> 675         else if (position == 1)</span>
<span class="line-added"> 676             builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
<span class="line-added"> 677         else</span>
<span class="line-added"> 678             builder.append(&quot;, color-stop(&quot;, FormattedNumber::fixedPrecision(position), &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
<span class="line-added"> 679     }</span>
<span class="line-added"> 680 }</span>
<span class="line-added"> 681 </span>
 682 String CSSLinearGradientValue::customCSSText() const
 683 {
 684     StringBuilder result;
 685     if (m_gradientType == CSSDeprecatedLinearGradient) {
<span class="line-modified"> 686         result.append(&quot;-webkit-gradient(linear, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText());</span>
<span class="line-modified"> 687         appendGradientStops(result, m_stops);</span>


























 688     } else if (m_gradientType == CSSPrefixedLinearGradient) {
 689         if (m_repeating)
 690             result.appendLiteral(&quot;-webkit-repeating-linear-gradient(&quot;);
 691         else
 692             result.appendLiteral(&quot;-webkit-linear-gradient(&quot;);
 693 
 694         if (m_angle)
 695             result.append(m_angle-&gt;cssText());
 696         else {
<span class="line-modified"> 697             if (m_firstX &amp;&amp; m_firstY)</span>
<span class="line-added"> 698                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());</span>
<span class="line-added"> 699             else if (m_firstX)</span>
 700                 result.append(m_firstX-&gt;cssText());
<span class="line-modified"> 701             else if (m_firstY)</span>
 702                 result.append(m_firstY-&gt;cssText());







 703         }
 704 
<span class="line-modified"> 705         for (auto&amp; stop : m_stops) {</span>
<span class="line-modified"> 706             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified"> 707             if (stop.m_position)</span>
<span class="line-modified"> 708                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>




 709         }
 710     } else {
 711         if (m_repeating)
 712             result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
 713         else
 714             result.appendLiteral(&quot;linear-gradient(&quot;);
 715 
 716         bool wroteSomething = false;
 717 
 718         if (m_angle &amp;&amp; m_angle-&gt;computeDegrees() != 180) {
 719             result.append(m_angle-&gt;cssText());
 720             wroteSomething = true;
 721         } else if ((m_firstX || m_firstY) &amp;&amp; !(!m_firstX &amp;&amp; m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)) {
 722             result.appendLiteral(&quot;to &quot;);
<span class="line-modified"> 723             if (m_firstX &amp;&amp; m_firstY)</span>
<span class="line-modified"> 724                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());</span>
<span class="line-modified"> 725             else if (m_firstX)</span>


 726                 result.append(m_firstX-&gt;cssText());
 727             else
 728                 result.append(m_firstY-&gt;cssText());
 729             wroteSomething = true;
 730         }
 731 
 732         if (wroteSomething)
 733             result.appendLiteral(&quot;, &quot;);
 734 
<span class="line-modified"> 735         bool wroteFirstStop = false;</span>
<span class="line-modified"> 736         for (auto&amp; stop : m_stops) {</span>
<span class="line-modified"> 737             if (wroteFirstStop)</span>
 738                 result.appendLiteral(&quot;, &quot;);
<span class="line-added"> 739             wroteFirstStop = true;</span>
 740             if (!stop.isMidpoint)
 741                 result.append(stop.m_color-&gt;cssText());
 742             if (stop.m_position) {
 743                 if (!stop.isMidpoint)
 744                     result.append(&#39; &#39;);
 745                 result.append(stop.m_position-&gt;cssText());
 746             }
 747         }

 748     }
 749 
 750     result.append(&#39;)&#39;);
 751     return result.toString();
 752 }
 753 
 754 // Compute the endpoints so that a gradient of the given angle covers a box of the given size.
 755 static void endPointsFromAngle(float angleDeg, const FloatSize&amp; size, FloatPoint&amp; firstPoint, FloatPoint&amp; secondPoint, CSSGradientType type)
 756 {
 757     // Prefixed gradients use &quot;polar coordinate&quot; angles, rather than &quot;bearing&quot; angles.
 758     if (type == CSSPrefixedLinearGradient)
 759         angleDeg = 90 - angleDeg;
 760 
 761     angleDeg = fmodf(angleDeg, 360);
 762     if (angleDeg &lt; 0)
 763         angleDeg += 360;
 764 
 765     if (!angleDeg) {
 766         firstPoint.set(0, size.height());
 767         secondPoint.set(0, 0);
</pre>
<hr />
<pre>
 905         return false;
 906 
 907     bool equalXandY = false;
 908     if (m_firstX &amp;&amp; m_firstY)
 909         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
 910     else if (m_firstX)
 911         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
 912     else if (m_firstY)
 913         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
 914     else
 915         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
 916 
 917     return equalXandY &amp;&amp; m_stops == other.m_stops;
 918 }
 919 
 920 String CSSRadialGradientValue::customCSSText() const
 921 {
 922     StringBuilder result;
 923 
 924     if (m_gradientType == CSSDeprecatedRadialGradient) {
<span class="line-modified"> 925         result.append(&quot;-webkit-gradient(radial, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_firstRadius-&gt;cssText(),</span>
<span class="line-modified"> 926             &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText(), &quot;, &quot;, m_secondRadius-&gt;cssText());</span>
<span class="line-modified"> 927         appendGradientStops(result, m_stops);</span>






























 928     } else if (m_gradientType == CSSPrefixedRadialGradient) {
 929         if (m_repeating)
 930             result.appendLiteral(&quot;-webkit-repeating-radial-gradient(&quot;);
 931         else
 932             result.appendLiteral(&quot;-webkit-radial-gradient(&quot;);
 933 
<span class="line-modified"> 934         if (m_firstX &amp;&amp; m_firstY)</span>
<span class="line-modified"> 935             result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());</span>
<span class="line-modified"> 936         else if (m_firstX)</span>


 937             result.append(m_firstX-&gt;cssText());
<span class="line-modified"> 938         else if (m_firstY)</span>
 939             result.append(m_firstY-&gt;cssText());
 940         else
 941             result.appendLiteral(&quot;center&quot;);
 942 
 943         if (m_shape || m_sizingBehavior) {
 944             result.appendLiteral(&quot;, &quot;);
<span class="line-modified"> 945             if (m_shape)</span>
<span class="line-modified"> 946                 result.append(m_shape-&gt;cssText(), &#39; &#39;);</span>
<span class="line-modified"> 947             else</span>

 948                 result.appendLiteral(&quot;ellipse &quot;);

 949             if (m_sizingBehavior)
 950                 result.append(m_sizingBehavior-&gt;cssText());
 951             else
 952                 result.appendLiteral(&quot;cover&quot;);
<span class="line-added"> 953         } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)</span>
<span class="line-added"> 954             result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());</span>
 955 
<span class="line-modified"> 956         for (auto&amp; stop : m_stops) {</span>
<span class="line-modified"> 957             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified"> 958             if (stop.m_position)</span>
<span class="line-modified"> 959                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>











 960         }
 961     } else {
 962         if (m_repeating)
 963             result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
 964         else
 965             result.appendLiteral(&quot;radial-gradient(&quot;);
 966 
 967         bool wroteSomething = false;
 968 
 969         // The only ambiguous case that needs an explicit shape to be provided
 970         // is when a sizing keyword is used (or all sizing is omitted).
 971         if (m_shape &amp;&amp; m_shape-&gt;valueID() != CSSValueEllipse &amp;&amp; (m_sizingBehavior || (!m_sizingBehavior &amp;&amp; !m_endHorizontalSize))) {
 972             result.appendLiteral(&quot;circle&quot;);
 973             wroteSomething = true;
 974         }
 975 
 976         if (m_sizingBehavior &amp;&amp; m_sizingBehavior-&gt;valueID() != CSSValueFarthestCorner) {
 977             if (wroteSomething)
 978                 result.append(&#39; &#39;);
 979             result.append(m_sizingBehavior-&gt;cssText());
 980             wroteSomething = true;
 981         } else if (m_endHorizontalSize) {
 982             if (wroteSomething)
 983                 result.append(&#39; &#39;);
 984             result.append(m_endHorizontalSize-&gt;cssText());
<span class="line-modified"> 985             if (m_endVerticalSize)</span>
<span class="line-modified"> 986                 result.append(&#39; &#39;, m_endVerticalSize-&gt;cssText());</span>


 987             wroteSomething = true;
 988         }
 989 
 990         if (m_firstX || m_firstY) {
 991             if (wroteSomething)
 992                 result.append(&#39; &#39;);
 993             result.appendLiteral(&quot;at &quot;);
<span class="line-modified"> 994             if (m_firstX &amp;&amp; m_firstY)</span>
<span class="line-modified"> 995                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());</span>
<span class="line-modified"> 996             else if (m_firstX)</span>


 997                 result.append(m_firstX-&gt;cssText());
 998             else
 999                 result.append(m_firstY-&gt;cssText());
1000             wroteSomething = true;
1001         }
1002 
1003         if (wroteSomething)
1004             result.appendLiteral(&quot;, &quot;);
1005 
1006         for (unsigned i = 0; i &lt; m_stops.size(); i++) {
1007             const CSSGradientColorStop&amp; stop = m_stops[i];
1008             if (i)
1009                 result.appendLiteral(&quot;, &quot;);
1010             if (!stop.isMidpoint)
1011                 result.append(stop.m_color-&gt;cssText());
1012             if (stop.m_position) {
1013                 if (!stop.isMidpoint)
1014                     result.append(&#39; &#39;);
1015                 result.append(stop.m_position-&gt;cssText());
1016             }
1017         }
1018 
1019     }
1020 
1021     result.append(&#39;)&#39;);
1022     return result.toString();
1023 }
1024 
1025 float CSSRadialGradientValue::resolveRadius(CSSPrimitiveValue&amp; radius, const CSSToLengthConversionData&amp; conversionData, float* widthOrHeight)
1026 {
1027     float result = 0;
<span class="line-modified">1028     if (radius.isNumber())</span>
1029         result = radius.floatValue() * conversionData.zoom();
1030     else if (widthOrHeight &amp;&amp; radius.isPercentage())
1031         result = *widthOrHeight * radius.floatValue() / 100;
1032     else
1033         result = radius.computeLength&lt;float&gt;(conversionData);

1034     return result;
1035 }
1036 
1037 static float distanceToClosestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1038 {
1039     FloatPoint topLeft;
1040     float topLeftDistance = FloatSize(p - topLeft).diagonalLength();
1041 
1042     FloatPoint topRight(size.width(), 0);
1043     float topRightDistance = FloatSize(p - topRight).diagonalLength();
1044 
1045     FloatPoint bottomLeft(0, size.height());
1046     float bottomLeftDistance = FloatSize(p - bottomLeft).diagonalLength();
1047 
1048     FloatPoint bottomRight(size.width(), size.height());
1049     float bottomRightDistance = FloatSize(p - bottomRight).diagonalLength();
1050 
1051     corner = topLeft;
1052     float minDistance = topLeftDistance;
1053     if (topRightDistance &lt; minDistance) {
</pre>
<hr />
<pre>
1296         equalShape = !other.m_shape;
1297         equalSizingBehavior = !other.m_sizingBehavior;
1298         equalHorizontalAndVerticalSize = !other.m_endHorizontalSize &amp;&amp; !other.m_endVerticalSize;
1299     }
1300     return equalShape &amp;&amp; equalSizingBehavior &amp;&amp; equalHorizontalAndVerticalSize &amp;&amp; m_stops == other.m_stops;
1301 }
1302 
1303 
1304 String CSSConicGradientValue::customCSSText() const
1305 {
1306     StringBuilder result;
1307 
1308     if (m_repeating)
1309         result.appendLiteral(&quot;repeating-conic-gradient(&quot;);
1310     else
1311         result.appendLiteral(&quot;conic-gradient(&quot;);
1312 
1313     bool wroteSomething = false;
1314 
1315     if (m_angle) {
<span class="line-modified">1316         result.append(&quot;from &quot;, m_angle-&gt;cssText());</span>

1317         wroteSomething = true;
1318     }
1319 
1320     if (m_firstX &amp;&amp; m_firstY) {
1321         if (wroteSomething)
<span class="line-modified">1322             result.append(&#39; &#39;);</span>
<span class="line-modified">1323         result.append(&quot;at &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());</span>



1324         wroteSomething = true;
1325     }
1326 
1327     if (wroteSomething)
1328         result.appendLiteral(&quot;, &quot;);
1329 
1330     bool wroteFirstStop = false;
1331     for (auto&amp; stop : m_stops) {
1332         if (wroteFirstStop)
1333             result.appendLiteral(&quot;, &quot;);
1334         wroteFirstStop = true;
1335         if (!stop.isMidpoint)
1336             result.append(stop.m_color-&gt;cssText());
1337         if (stop.m_position) {
1338             if (!stop.isMidpoint)
1339                 result.append(&#39; &#39;);
1340             result.append(stop.m_position-&gt;cssText());
1341         }
1342     }
1343 
</pre>
</td>
</tr>
</table>
<center><a href="CSSFontVariationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGridAutoRepeatValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>