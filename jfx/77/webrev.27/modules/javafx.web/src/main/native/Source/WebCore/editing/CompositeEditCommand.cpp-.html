<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/editing/CompositeEditCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CompositeEditCommand.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;AppendNodeCommand.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BreakBlockquoteCommand.h&quot;
  33 #include &quot;DataTransfer.h&quot;
  34 #include &quot;DeleteFromTextNodeCommand.h&quot;
  35 #include &quot;DeleteSelectionCommand.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;DocumentFragment.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;EditorInsertAction.h&quot;
  42 #include &quot;ElementTraversal.h&quot;
  43 #include &quot;Event.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;HTMLBRElement.h&quot;
  46 #include &quot;HTMLDivElement.h&quot;
  47 #include &quot;HTMLLIElement.h&quot;
  48 #include &quot;HTMLNames.h&quot;
  49 #include &quot;HTMLSpanElement.h&quot;
  50 #include &quot;InlineTextBox.h&quot;
  51 #include &quot;InsertIntoTextNodeCommand.h&quot;
  52 #include &quot;InsertLineBreakCommand.h&quot;
  53 #include &quot;InsertNodeBeforeCommand.h&quot;
  54 #include &quot;InsertParagraphSeparatorCommand.h&quot;
  55 #include &quot;InsertTextCommand.h&quot;
  56 #include &quot;MergeIdenticalElementsCommand.h&quot;
  57 #include &quot;NodeTraversal.h&quot;
  58 #include &quot;Range.h&quot;
  59 #include &quot;RemoveNodeCommand.h&quot;
  60 #include &quot;RemoveNodePreservingChildrenCommand.h&quot;
  61 #include &quot;RenderBlockFlow.h&quot;
  62 #include &quot;RenderText.h&quot;
  63 #include &quot;RenderedDocumentMarker.h&quot;
  64 #include &quot;ReplaceNodeWithSpanCommand.h&quot;
  65 #include &quot;ReplaceSelectionCommand.h&quot;
  66 #include &quot;ScopedEventQueue.h&quot;
  67 #include &quot;SetNodeAttributeCommand.h&quot;
  68 #include &quot;SplitElementCommand.h&quot;
  69 #include &quot;SplitTextNodeCommand.h&quot;
  70 #include &quot;SplitTextNodeContainingElementCommand.h&quot;
  71 #include &quot;StaticRange.h&quot;
  72 #include &quot;Text.h&quot;
  73 #include &quot;TextIterator.h&quot;
  74 #include &quot;VisibleUnits.h&quot;
  75 #include &quot;WrapContentsInDummySpanCommand.h&quot;
  76 #include &quot;markup.h&quot;
  77 
  78 namespace WebCore {
  79 
  80 using namespace HTMLNames;
  81 
  82 int AccessibilityUndoReplacedText::indexForVisiblePosition(const VisiblePosition&amp; position, RefPtr&lt;ContainerNode&gt;&amp; scope) const
  83 {
  84     if (position.deepEquivalent().isNull())
  85         return -1;
  86     return WebCore::indexForVisiblePosition(position, scope);
  87 }
  88 
  89 void AccessibilityUndoReplacedText::configureRangeDeletedByReapplyWithEndingSelection(const VisibleSelection&amp; selection)
  90 {
  91     if (!AXObjectCache::accessibilityEnabled())
  92         return;
  93     if (selection.isNone())
  94         return;
  95     m_rangeDeletedByReapply.endIndex.value = indexForVisiblePosition(selection.end(), m_rangeDeletedByReapply.endIndex.scope);
  96 }
  97 
  98 void AccessibilityUndoReplacedText::configureRangeDeletedByReapplyWithStartingSelection(const VisibleSelection&amp; selection)
  99 {
 100     if (!AXObjectCache::accessibilityEnabled())
 101         return;
 102     if (selection.isNone())
 103         return;
 104     if (m_rangeDeletedByReapply.startIndex.value == -1)
 105         m_rangeDeletedByReapply.startIndex.value = indexForVisiblePosition(selection.start(), m_rangeDeletedByReapply.startIndex.scope);
 106 }
 107 
 108 void AccessibilityUndoReplacedText::setRangeDeletedByUnapply(const VisiblePositionIndexRange&amp; range)
 109 {
 110     if (m_rangeDeletedByUnapply.isNull())
 111         m_rangeDeletedByUnapply = range;
 112 }
 113 
 114 void AccessibilityUndoReplacedText::captureTextForUnapply()
 115 {
 116     if (!AXObjectCache::accessibilityEnabled())
 117         return;
 118     m_replacedText = textDeletedByReapply();
 119 }
 120 
 121 void AccessibilityUndoReplacedText::captureTextForReapply()
 122 {
 123     if (!AXObjectCache::accessibilityEnabled())
 124         return;
 125     m_replacedText = textDeletedByUnapply();
 126 }
 127 
 128 static String stringForVisiblePositionIndexRange(const VisiblePositionIndexRange&amp; range)
 129 {
 130     if (range.isNull())
 131         return String();
 132     VisiblePosition start = visiblePositionForIndex(range.startIndex.value, range.startIndex.scope.get());
 133     VisiblePosition end = visiblePositionForIndex(range.endIndex.value, range.endIndex.scope.get());
 134     return AccessibilityObject::stringForVisiblePositionRange(VisiblePositionRange(start, end));
 135 }
 136 
 137 String AccessibilityUndoReplacedText::textDeletedByUnapply()
 138 {
 139     if (!AXObjectCache::accessibilityEnabled())
 140         return String();
 141     return stringForVisiblePositionIndexRange(m_rangeDeletedByUnapply);
 142 }
 143 
 144 String AccessibilityUndoReplacedText::textDeletedByReapply()
 145 {
 146     if (!AXObjectCache::accessibilityEnabled())
 147         return String();
 148     return stringForVisiblePositionIndexRange(m_rangeDeletedByReapply);
 149 }
 150 
 151 static void postTextStateChangeNotification(AXObjectCache* cache, const VisiblePosition&amp; position, const String&amp; deletedText, const String&amp; insertedText)
 152 {
 153     ASSERT(cache);
 154     auto* node = highestEditableRoot(position.deepEquivalent(), HasEditableAXRole);
 155     if (!node)
 156         return;
 157     if (insertedText.length() &amp;&amp; deletedText.length())
 158         cache-&gt;postTextReplacementNotification(node, AXTextEditTypeDelete, insertedText, AXTextEditTypeInsert, deletedText, position);
 159     else if (deletedText.length())
 160         cache-&gt;postTextStateChangeNotification(node, AXTextEditTypeInsert, deletedText, position);
 161     else if (insertedText.length())
 162         cache-&gt;postTextStateChangeNotification(node, AXTextEditTypeDelete, insertedText, position);
 163 }
 164 
 165 void AccessibilityUndoReplacedText::postTextStateChangeNotificationForUnapply(AXObjectCache* cache)
 166 {
 167     if (!cache)
 168         return;
 169     if (!AXObjectCache::accessibilityEnabled())
 170         return;
 171     if (m_rangeDeletedByUnapply.isNull())
 172         return;
 173     VisiblePosition position = visiblePositionForIndex(m_rangeDeletedByUnapply.endIndex.value, m_rangeDeletedByUnapply.endIndex.scope.get());
 174     if (position.isNull())
 175         return;
 176     postTextStateChangeNotification(cache, position, textDeletedByUnapply(), m_replacedText);
 177     m_replacedText = String();
 178 }
 179 
 180 void AccessibilityUndoReplacedText::postTextStateChangeNotificationForReapply(AXObjectCache* cache)
 181 {
 182     if (!cache)
 183         return;
 184     if (!AXObjectCache::accessibilityEnabled())
 185         return;
 186     if (m_rangeDeletedByReapply.isNull())
 187         return;
 188     VisiblePosition position = visiblePositionForIndex(m_rangeDeletedByReapply.startIndex.value, m_rangeDeletedByReapply.startIndex.scope.get());
 189     if (position.isNull())
 190         return;
 191     postTextStateChangeNotification(cache, position, textDeletedByReapply(), m_replacedText);
 192     m_replacedText = String();
 193 }
 194 
 195 Ref&lt;EditCommandComposition&gt; EditCommandComposition::create(Document&amp; document,
 196     const VisibleSelection&amp; startingSelection, const VisibleSelection&amp; endingSelection, EditAction editAction)
 197 {
 198     return adoptRef(*new EditCommandComposition(document, startingSelection, endingSelection, editAction));
 199 }
 200 
 201 EditCommandComposition::EditCommandComposition(Document&amp; document, const VisibleSelection&amp; startingSelection, const VisibleSelection&amp; endingSelection, EditAction editAction)
 202     : m_document(&amp;document)
 203     , m_startingSelection(startingSelection)
 204     , m_endingSelection(endingSelection)
 205     , m_startingRootEditableElement(startingSelection.rootEditableElement())
 206     , m_endingRootEditableElement(endingSelection.rootEditableElement())
 207     , m_editAction(editAction)
 208 {
 209     m_replacedText.configureRangeDeletedByReapplyWithStartingSelection(startingSelection);
 210 }
 211 
 212 void EditCommandComposition::unapply()
 213 {
 214     ASSERT(m_document);
 215     RefPtr&lt;Frame&gt; frame = m_document-&gt;frame();
 216     if (!frame)
 217         return;
 218 
 219     m_replacedText.captureTextForUnapply();
 220 
 221     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 222     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 223     // if one is necessary (like for the creation of VisiblePositions).
 224     m_document-&gt;updateLayoutIgnorePendingStylesheets();
 225 #if PLATFORM(IOS_FAMILY)
 226     // FIXME: Where should iPhone code deal with the composition?
 227     // Since editing commands don&#39;t save/restore the composition, undoing without fixing
 228     // up the composition will leave a stale, invalid composition, as in &lt;rdar://problem/6831637&gt;.
 229     // Desktop handles this in -[WebHTMLView _updateSelectionForInputManager], but the phone
 230     // goes another route.
 231     frame-&gt;editor().cancelComposition();
 232 #endif
 233 
 234     if (!frame-&gt;editor().willUnapplyEditing(*this))
 235         return;
 236 
 237     size_t size = m_commands.size();
 238     for (size_t i = size; i; --i)
 239         m_commands[i - 1]-&gt;doUnapply();
 240 
 241     frame-&gt;editor().unappliedEditing(*this);
 242 
 243     if (AXObjectCache::accessibilityEnabled())
 244         m_replacedText.postTextStateChangeNotificationForUnapply(m_document-&gt;existingAXObjectCache());
 245 }
 246 
 247 void EditCommandComposition::reapply()
 248 {
 249     ASSERT(m_document);
 250     RefPtr&lt;Frame&gt; frame = m_document-&gt;frame();
 251     if (!frame)
 252         return;
 253 
 254     m_replacedText.captureTextForReapply();
 255 
 256     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 257     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 258     // if one is necessary (like for the creation of VisiblePositions).
 259     m_document-&gt;updateLayoutIgnorePendingStylesheets();
 260 
 261     if (!frame-&gt;editor().willReapplyEditing(*this))
 262         return;
 263 
 264     for (auto&amp; command : m_commands)
 265         command-&gt;doReapply();
 266 
 267     frame-&gt;editor().reappliedEditing(*this);
 268 
 269     if (AXObjectCache::accessibilityEnabled())
 270         m_replacedText.postTextStateChangeNotificationForReapply(m_document-&gt;existingAXObjectCache());
 271 }
 272 
 273 void EditCommandComposition::append(SimpleEditCommand* command)
 274 {
 275     m_commands.append(command);
 276 }
 277 
 278 void EditCommandComposition::setStartingSelection(const VisibleSelection&amp; selection)
 279 {
 280     m_startingSelection = selection;
 281     m_startingRootEditableElement = selection.rootEditableElement();
 282     m_replacedText.configureRangeDeletedByReapplyWithStartingSelection(selection);
 283 }
 284 
 285 void EditCommandComposition::setEndingSelection(const VisibleSelection&amp; selection)
 286 {
 287     m_endingSelection = selection;
 288     m_endingRootEditableElement = selection.rootEditableElement();
 289     m_replacedText.configureRangeDeletedByReapplyWithEndingSelection(selection);
 290 }
 291 
 292 void EditCommandComposition::setRangeDeletedByUnapply(const VisiblePositionIndexRange&amp; range)
 293 {
 294     m_replacedText.setRangeDeletedByUnapply(range);
 295 }
 296 
 297 #ifndef NDEBUG
 298 void EditCommandComposition::getNodesInCommand(HashSet&lt;Node*&gt;&amp; nodes)
 299 {
 300     for (auto&amp; command : m_commands)
 301         command-&gt;getNodesInCommand(nodes);
 302 }
 303 #endif
 304 
 305 String EditCommandComposition::label() const
 306 {
 307     return undoRedoLabel(m_editAction);
 308 }
 309 
 310 CompositeEditCommand::CompositeEditCommand(Document&amp; document, EditAction editingAction)
 311     : EditCommand(document, editingAction)
 312 {
 313 }
 314 
 315 CompositeEditCommand::~CompositeEditCommand()
 316 {
 317     ASSERT(isTopLevelCommand() || !m_composition);
 318 }
 319 
 320 bool CompositeEditCommand::willApplyCommand()
 321 {
 322     return frame().editor().willApplyEditing(*this, targetRangesForBindings());
 323 }
 324 
 325 void CompositeEditCommand::apply()
 326 {
 327     if (!endingSelection().isContentRichlyEditable()) {
 328         switch (editingAction()) {
 329         case EditAction::TypingDeleteSelection:
 330         case EditAction::TypingDeleteBackward:
 331         case EditAction::TypingDeleteForward:
 332         case EditAction::TypingDeleteWordBackward:
 333         case EditAction::TypingDeleteWordForward:
 334         case EditAction::TypingDeleteLineBackward:
 335         case EditAction::TypingDeleteLineForward:
 336         case EditAction::TypingDeletePendingComposition:
 337         case EditAction::TypingDeleteFinalComposition:
 338         case EditAction::TypingInsertText:
 339         case EditAction::TypingInsertLineBreak:
 340         case EditAction::TypingInsertParagraph:
 341         case EditAction::TypingInsertPendingComposition:
 342         case EditAction::TypingInsertFinalComposition:
 343         case EditAction::Paste:
 344         case EditAction::DeleteByDrag:
 345         case EditAction::SetWritingDirection:
 346         case EditAction::Cut:
 347         case EditAction::Unspecified:
 348         case EditAction::Insert:
 349         case EditAction::InsertReplacement:
 350         case EditAction::InsertFromDrop:
 351         case EditAction::Delete:
 352         case EditAction::Dictation:
 353             break;
 354         default:
 355             ASSERT_NOT_REACHED();
 356             return;
 357         }
 358     }
 359     ensureComposition();
 360 
 361     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 362     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 363     // if one is necessary (like for the creation of VisiblePositions).
 364     document().updateLayoutIgnorePendingStylesheets();
 365 
 366     if (!willApplyCommand())
 367         return;
 368 
 369     {
 370         EventQueueScope eventQueueScope;
 371         doApply();
 372     }
 373 
 374     didApplyCommand();
 375     setShouldRetainAutocorrectionIndicator(false);
 376 }
 377 
 378 void CompositeEditCommand::didApplyCommand()
 379 {
 380     frame().editor().appliedEditing(*this);
 381 }
 382 
 383 Vector&lt;RefPtr&lt;StaticRange&gt;&gt; CompositeEditCommand::targetRanges() const
 384 {
 385     ASSERT(!isEditingTextAreaOrTextInput());
 386     auto firstRange = frame().selection().selection().firstRange();
 387     if (!firstRange)
 388         return { };
 389 
 390     return { 1, StaticRange::createFromRange(*firstRange) };
 391 }
 392 
 393 Vector&lt;RefPtr&lt;StaticRange&gt;&gt; CompositeEditCommand::targetRangesForBindings() const
 394 {
 395     if (isEditingTextAreaOrTextInput())
 396         return { };
 397 
 398     return targetRanges();
 399 }
 400 
 401 RefPtr&lt;DataTransfer&gt; CompositeEditCommand::inputEventDataTransfer() const
 402 {
 403     return nullptr;
 404 }
 405 
 406 EditCommandComposition* CompositeEditCommand::composition() const
 407 {
 408     for (auto* command = this; command; command = command-&gt;parent()) {
 409         if (auto composition = command-&gt;m_composition) {
 410             ASSERT(!command-&gt;parent());
 411             return composition.get();
 412         }
 413     }
 414     return nullptr;
 415 }
 416 
 417 EditCommandComposition&amp; CompositeEditCommand::ensureComposition()
 418 {
 419     auto* command = this;
 420     while (auto* parent = command-&gt;parent())
 421         command = parent;
 422     if (!command-&gt;m_composition)
 423         command-&gt;m_composition = EditCommandComposition::create(document(), startingSelection(), endingSelection(), editingAction());
 424     return *command-&gt;m_composition;
 425 }
 426 
 427 bool CompositeEditCommand::isCreateLinkCommand() const
 428 {
 429     return false;
 430 }
 431 
 432 bool CompositeEditCommand::preservesTypingStyle() const
 433 {
 434     return false;
 435 }
 436 
 437 bool CompositeEditCommand::isTypingCommand() const
 438 {
 439     return false;
 440 }
 441 
 442 bool CompositeEditCommand::shouldRetainAutocorrectionIndicator() const
 443 {
 444     return false;
 445 }
 446 
 447 void CompositeEditCommand::setShouldRetainAutocorrectionIndicator(bool)
 448 {
 449 }
 450 
 451 String CompositeEditCommand::inputEventTypeName() const
 452 {
 453     return inputTypeNameForEditingAction(editingAction());
 454 }
 455 
 456 //
 457 // sugary-sweet convenience functions to help create and apply edit commands in composite commands
 458 //
 459 void CompositeEditCommand::applyCommandToComposite(Ref&lt;EditCommand&gt;&amp;&amp; command)
 460 {
 461     command-&gt;setParent(this);
 462     command-&gt;doApply();
 463     if (command-&gt;isSimpleEditCommand()) {
 464         command-&gt;setParent(nullptr);
 465         ensureComposition().append(toSimpleEditCommand(command.ptr()));
 466     }
 467     m_commands.append(WTFMove(command));
 468 }
 469 
 470 void CompositeEditCommand::applyCommandToComposite(Ref&lt;CompositeEditCommand&gt;&amp;&amp; command, const VisibleSelection&amp; selection)
 471 {
 472     command-&gt;setParent(this);
 473     if (selection != command-&gt;endingSelection()) {
 474         command-&gt;setStartingSelection(selection);
 475         command-&gt;setEndingSelection(selection);
 476     }
 477     command-&gt;doApply();
 478     m_commands.append(WTFMove(command));
 479 }
 480 
 481 void CompositeEditCommand::applyStyle(const EditingStyle* style, EditAction editingAction)
 482 {
 483     applyCommandToComposite(ApplyStyleCommand::create(document(), style, editingAction));
 484 }
 485 
 486 void CompositeEditCommand::applyStyle(const EditingStyle* style, const Position&amp; start, const Position&amp; end, EditAction editingAction)
 487 {
 488     applyCommandToComposite(ApplyStyleCommand::create(document(), style, start, end, editingAction));
 489 }
 490 
 491 void CompositeEditCommand::applyStyledElement(Ref&lt;Element&gt;&amp;&amp; element)
 492 {
 493     applyCommandToComposite(ApplyStyleCommand::create(WTFMove(element), false));
 494 }
 495 
 496 void CompositeEditCommand::removeStyledElement(Ref&lt;Element&gt;&amp;&amp; element)
 497 {
 498     applyCommandToComposite(ApplyStyleCommand::create(WTFMove(element), true));
 499 }
 500 
 501 void CompositeEditCommand::insertParagraphSeparator(bool useDefaultParagraphElement, bool pasteBlockqutoeIntoUnquotedArea)
 502 {
 503     applyCommandToComposite(InsertParagraphSeparatorCommand::create(document(), useDefaultParagraphElement, pasteBlockqutoeIntoUnquotedArea, editingAction()));
 504 }
 505 
 506 void CompositeEditCommand::insertLineBreak()
 507 {
 508     applyCommandToComposite(InsertLineBreakCommand::create(document()));
 509 }
 510 
 511 bool CompositeEditCommand::isRemovableBlock(const Node* node)
 512 {
 513     ASSERT(node);
 514     if (!is&lt;HTMLDivElement&gt;(*node))
 515         return false;
 516 
 517     Node* parentNode = node-&gt;parentNode();
 518     if (parentNode &amp;&amp; parentNode-&gt;firstChild() != parentNode-&gt;lastChild())
 519         return false;
 520 
 521     if (!downcast&lt;HTMLDivElement&gt;(*node).hasAttributes())
 522         return true;
 523 
 524     return false;
 525 }
 526 
 527 void CompositeEditCommand::insertNodeBefore(Ref&lt;Node&gt;&amp;&amp; insertChild, Node&amp; refChild, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 528 {
 529     applyCommandToComposite(InsertNodeBeforeCommand::create(WTFMove(insertChild), refChild, shouldAssumeContentIsAlwaysEditable, editingAction()));
 530 }
 531 
 532 void CompositeEditCommand::insertNodeAfter(Ref&lt;Node&gt;&amp;&amp; insertChild, Node&amp; refChild)
 533 {
 534     ContainerNode* parent = refChild.parentNode();
 535     if (!parent)
 536         return;
 537 
 538     ASSERT(!parent-&gt;isShadowRoot());
 539     if (parent-&gt;lastChild() == &amp;refChild)
 540         appendNode(WTFMove(insertChild), *parent);
 541     else {
 542         ASSERT(refChild.nextSibling());
 543         insertNodeBefore(WTFMove(insertChild), *refChild.nextSibling());
 544     }
 545 }
 546 
 547 void CompositeEditCommand::insertNodeAt(Ref&lt;Node&gt;&amp;&amp; insertChild, const Position&amp; editingPosition)
 548 {
 549     ASSERT(isEditablePosition(editingPosition));
 550     // For editing positions like [table, 0], insert before the table,
 551     // likewise for replaced elements, brs, etc.
 552     Position p = editingPosition.parentAnchoredEquivalent();
 553     Node* refChild = p.deprecatedNode();
 554     int offset = p.deprecatedEditingOffset();
 555 
 556     if (canHaveChildrenForEditing(*refChild)) {
 557         Node* child = refChild-&gt;firstChild();
 558         for (int i = 0; child &amp;&amp; i &lt; offset; i++)
 559             child = child-&gt;nextSibling();
 560         if (child)
 561             insertNodeBefore(WTFMove(insertChild), *child);
 562         else
 563             appendNode(WTFMove(insertChild), downcast&lt;ContainerNode&gt;(*refChild));
 564     } else if (caretMinOffset(*refChild) &gt;= offset)
 565         insertNodeBefore(WTFMove(insertChild), *refChild);
 566     else if (is&lt;Text&gt;(*refChild) &amp;&amp; caretMaxOffset(*refChild) &gt; offset) {
 567         splitTextNode(downcast&lt;Text&gt;(*refChild), offset);
 568 
 569         // Mutation events (bug 22634) from the text node insertion may have removed the refChild
 570         if (!refChild-&gt;isConnected())
 571             return;
 572         insertNodeBefore(WTFMove(insertChild), *refChild);
 573     } else
 574         insertNodeAfter(WTFMove(insertChild), *refChild);
 575 }
 576 
 577 void CompositeEditCommand::appendNode(Ref&lt;Node&gt;&amp;&amp; node, Ref&lt;ContainerNode&gt;&amp;&amp; parent)
 578 {
 579     ASSERT(canHaveChildrenForEditing(parent));
 580     applyCommandToComposite(AppendNodeCommand::create(WTFMove(parent), WTFMove(node), editingAction()));
 581 }
 582 
 583 void CompositeEditCommand::removeChildrenInRange(Node&amp; node, unsigned from, unsigned to)
 584 {
 585     Vector&lt;Ref&lt;Node&gt;&gt; children;
 586     Node* child = node.traverseToChildAt(from);
 587     for (unsigned i = from; child &amp;&amp; i &lt; to; i++, child = child-&gt;nextSibling())
 588         children.append(*child);
 589 
 590     for (auto&amp; child : children)
 591         removeNode(child);
 592 }
 593 
 594 void CompositeEditCommand::removeNode(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 595 {
 596     if (!node.nonShadowBoundaryParentNode())
 597         return;
 598     applyCommandToComposite(RemoveNodeCommand::create(node, shouldAssumeContentIsAlwaysEditable, editingAction()));
 599 }
 600 
 601 void CompositeEditCommand::removeNodePreservingChildren(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 602 {
 603     applyCommandToComposite(RemoveNodePreservingChildrenCommand::create(node, shouldAssumeContentIsAlwaysEditable, editingAction()));
 604 }
 605 
 606 void CompositeEditCommand::removeNodeAndPruneAncestors(Node&amp; node)
 607 {
 608     RefPtr&lt;ContainerNode&gt; parent = node.parentNode();
 609     removeNode(node);
 610     prune(parent.get());
 611 }
 612 
 613 void CompositeEditCommand::moveRemainingSiblingsToNewParent(Node* node, Node* pastLastNodeToMove, Element&amp; newParent)
 614 {
 615     NodeVector nodesToRemove;
 616     Ref&lt;Element&gt; protectedNewParent = newParent;
 617 
 618     for (; node &amp;&amp; node != pastLastNodeToMove; node = node-&gt;nextSibling())
 619         nodesToRemove.append(*node);
 620 
 621     for (auto&amp; nodeToRemove : nodesToRemove) {
 622         removeNode(nodeToRemove);
 623         appendNode(WTFMove(nodeToRemove), newParent);
 624     }
 625 }
 626 
 627 void CompositeEditCommand::updatePositionForNodeRemovalPreservingChildren(Position&amp; position, Node&amp; node)
 628 {
 629     int offset = (position.anchorType() == Position::PositionIsOffsetInAnchor) ? position.offsetInContainerNode() : 0;
 630     updatePositionForNodeRemoval(position, node);
 631     if (offset)
 632         position.moveToOffset(offset);
 633 }
 634 
 635 HTMLElement* CompositeEditCommand::replaceElementWithSpanPreservingChildrenAndAttributes(HTMLElement&amp; element)
 636 {
 637     // It would also be possible to implement all of ReplaceNodeWithSpanCommand
 638     // as a series of existing smaller edit commands.  Someone who wanted to
 639     // reduce the number of edit commands could do so here.
 640     auto command = ReplaceNodeWithSpanCommand::create(element);
 641     auto* commandPtr = command.ptr();
 642     applyCommandToComposite(WTFMove(command));
 643     // Returning a raw pointer here is OK because the command is retained by
 644     // applyCommandToComposite (thus retaining the span), and the span is also
 645     // in the DOM tree, and thus alive whie it has a parent.
 646     ASSERT(commandPtr-&gt;spanElement()-&gt;isConnected());
 647     return commandPtr-&gt;spanElement();
 648 }
 649 
 650 void CompositeEditCommand::prune(Node* node)
 651 {
 652     if (auto* highestNodeToRemove = highestNodeToRemoveInPruning(node))
 653         removeNode(*highestNodeToRemove);
 654 }
 655 
 656 void CompositeEditCommand::splitTextNode(Text&amp; node, unsigned offset)
 657 {
 658     applyCommandToComposite(SplitTextNodeCommand::create(node, offset));
 659 }
 660 
 661 void CompositeEditCommand::splitElement(Element&amp; element, Node&amp; atChild)
 662 {
 663     applyCommandToComposite(SplitElementCommand::create(element, atChild));
 664 }
 665 
 666 void CompositeEditCommand::mergeIdenticalElements(Element&amp; first, Element&amp; second)
 667 {
 668     Ref&lt;Element&gt; protectedFirst = first;
 669     Ref&lt;Element&gt; protectedSecond = second;
 670     ASSERT(!first.isDescendantOf(&amp;second) &amp;&amp; &amp;second != &amp;first);
 671     if (first.nextSibling() != &amp;second) {
 672         removeNode(second);
 673         insertNodeAfter(second, first);
 674     }
 675     applyCommandToComposite(MergeIdenticalElementsCommand::create(first, second));
 676 }
 677 
 678 void CompositeEditCommand::wrapContentsInDummySpan(Element&amp; element)
 679 {
 680     applyCommandToComposite(WrapContentsInDummySpanCommand::create(element));
 681 }
 682 
 683 void CompositeEditCommand::splitTextNodeContainingElement(Text&amp; text, unsigned offset)
 684 {
 685     applyCommandToComposite(SplitTextNodeContainingElementCommand::create(text, offset));
 686 }
 687 
 688 void CompositeEditCommand::inputText(const String&amp; text, bool selectInsertedText)
 689 {
 690     unsigned offset = 0;
 691     unsigned length = text.length();
 692 
 693     RefPtr&lt;ContainerNode&gt; scope;
 694     unsigned startIndex = indexForVisiblePosition(endingSelection().visibleStart(), scope);
 695 
 696     size_t newline;
 697     do {
 698         newline = text.find(&#39;\n&#39;, offset);
 699         if (newline != offset) {
 700             int substringLength = newline == notFound ? length - offset : newline - offset;
 701             applyCommandToComposite(InsertTextCommand::create(document(), text.substring(offset, substringLength), false));
 702         }
 703         if (newline != notFound) {
 704             VisiblePosition caret(endingSelection().visibleStart());
 705             if (enclosingNodeOfType(caret.deepEquivalent(), &amp;isMailBlockquote)) {
 706                 // FIXME: Breaking a blockquote when the caret is just after a space will collapse the
 707                 // space. Modify startIndex or length to compensate for this so that the ending selection
 708                 // will be positioned correctly.
 709                 // &lt;rdar://problem/9914462&gt; breaking a Mail blockquote just after a space collapses the space
 710                 if (caret.previous().characterAfter() == &#39; &#39;) {
 711                     if (!offset &amp;&amp; !startIndex)
 712                         startIndex--;
 713                     else if (!length)
 714                         length--;
 715                 }
 716                 applyCommandToComposite(BreakBlockquoteCommand::create(document()));
 717             } else
 718                 insertLineBreak();
 719         }
 720 
 721         offset = newline + 1;
 722     } while (newline != notFound &amp;&amp; offset != length);
 723 
 724     if (selectInsertedText)
 725         setEndingSelection(VisibleSelection(visiblePositionForIndex(startIndex, scope.get()), visiblePositionForIndex(startIndex + length, scope.get())));
 726 }
 727 
 728 void CompositeEditCommand::insertTextIntoNode(Text&amp; node, unsigned offset, const String&amp; text)
 729 {
 730     if (!text.isEmpty())
 731         applyCommandToComposite(InsertIntoTextNodeCommand::create(node, offset, text, editingAction()));
 732 }
 733 
 734 void CompositeEditCommand::deleteTextFromNode(Text&amp; node, unsigned offset, unsigned count)
 735 {
 736     applyCommandToComposite(DeleteFromTextNodeCommand::create(node, offset, count, editingAction()));
 737 }
 738 
 739 void CompositeEditCommand::replaceTextInNode(Text&amp; node, unsigned offset, unsigned count, const String&amp; replacementText)
 740 {
 741     applyCommandToComposite(DeleteFromTextNodeCommand::create(node, offset, count));
 742     if (!replacementText.isEmpty())
 743         applyCommandToComposite(InsertIntoTextNodeCommand::create(node, offset, replacementText, editingAction()));
 744 }
 745 
 746 Position CompositeEditCommand::replaceSelectedTextInNode(const String&amp; text)
 747 {
 748     Position start = endingSelection().start();
 749     Position end = endingSelection().end();
 750     if (start.containerNode() != end.containerNode() || !start.containerNode()-&gt;isTextNode() || isTabSpanTextNode(start.containerNode()))
 751         return Position();
 752 
 753     RefPtr&lt;Text&gt; textNode = start.containerText();
 754     replaceTextInNode(*textNode, start.offsetInContainerNode(), end.offsetInContainerNode() - start.offsetInContainerNode(), text);
 755 
 756     return Position(textNode.get(), start.offsetInContainerNode() + text.length());
 757 }
 758 
 759 static Vector&lt;RenderedDocumentMarker&gt; copyMarkers(const Vector&lt;RenderedDocumentMarker*&gt;&amp; markerPointers)
 760 {
 761     Vector&lt;RenderedDocumentMarker&gt; markers;
 762     markers.reserveInitialCapacity(markerPointers.size());
 763     for (auto&amp; markerPointer : markerPointers)
 764         markers.uncheckedAppend(*markerPointer);
 765 
 766     return markers;
 767 }
 768 
 769 void CompositeEditCommand::replaceTextInNodePreservingMarkers(Text&amp; node, unsigned offset, unsigned count, const String&amp; replacementText)
 770 {
 771     Ref&lt;Text&gt; protectedNode(node);
 772     DocumentMarkerController&amp; markerController = document().markers();
 773     auto markers = copyMarkers(markerController.markersInRange(Range::create(document(), &amp;node, offset, &amp;node, offset + count), DocumentMarker::allMarkers()));
 774     replaceTextInNode(node, offset, count, replacementText);
 775     auto newRange = Range::create(document(), &amp;node, offset, &amp;node, offset + replacementText.length());
 776     for (const auto&amp; marker : markers) {
 777 #if PLATFORM(IOS_FAMILY)
 778         if (marker.isDictation()) {
 779             markerController.addMarker(newRange, marker.type(), marker.description(), marker.alternatives(), marker.metadata());
 780             continue;
 781         }
 782 #endif
 783         markerController.addMarker(newRange, marker.type(), marker.description());
 784     }
 785 }
 786 
 787 Position CompositeEditCommand::positionOutsideTabSpan(const Position&amp; position)
 788 {
 789     if (!isTabSpanTextNode(position.anchorNode()))
 790         return position;
 791 
 792     switch (position.anchorType()) {
 793     case Position::PositionIsBeforeChildren:
 794     case Position::PositionIsAfterChildren:
 795         ASSERT_NOT_REACHED();
 796         return position;
 797     case Position::PositionIsOffsetInAnchor:
 798         break;
 799     case Position::PositionIsBeforeAnchor:
 800         return positionInParentBeforeNode(position.anchorNode());
 801     case Position::PositionIsAfterAnchor:
 802         return positionInParentAfterNode(position.anchorNode());
 803     }
 804 
 805     auto* tabSpan = tabSpanNode(position.containerNode());
 806 
 807     if (position.offsetInContainerNode() &lt;= caretMinOffset(*position.containerNode()))
 808         return positionInParentBeforeNode(tabSpan);
 809 
 810     if (position.offsetInContainerNode() &gt;= caretMaxOffset(*position.containerNode()))
 811         return positionInParentAfterNode(tabSpan);
 812 
 813     splitTextNodeContainingElement(downcast&lt;Text&gt;(*position.containerNode()), position.offsetInContainerNode());
 814     return positionInParentBeforeNode(tabSpan);
 815 }
 816 
 817 void CompositeEditCommand::insertNodeAtTabSpanPosition(Ref&lt;Node&gt;&amp;&amp; node, const Position&amp; pos)
 818 {
 819     // insert node before, after, or at split of tab span
 820     insertNodeAt(WTFMove(node), positionOutsideTabSpan(pos));
 821 }
 822 
 823 static EditAction deleteSelectionEditingActionForEditingAction(EditAction editingAction)
 824 {
 825     switch (editingAction) {
 826     case EditAction::Cut:
 827         return EditAction::Cut;
 828     default:
 829         return EditAction::Delete;
 830     }
 831 }
 832 
 833 void CompositeEditCommand::deleteSelection(bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup)
 834 {
 835     if (endingSelection().isRange())
 836         applyCommandToComposite(DeleteSelectionCommand::create(document(), smartDelete, mergeBlocksAfterDelete, replace, expandForSpecialElements, sanitizeMarkup, deleteSelectionEditingActionForEditingAction(editingAction())));
 837 }
 838 
 839 void CompositeEditCommand::deleteSelection(const VisibleSelection &amp;selection, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup)
 840 {
 841     if (selection.isRange())
 842         applyCommandToComposite(DeleteSelectionCommand::create(selection, smartDelete, mergeBlocksAfterDelete, replace, expandForSpecialElements, sanitizeMarkup));
 843 }
 844 
 845 void CompositeEditCommand::removeNodeAttribute(Element&amp; element, const QualifiedName&amp; attribute)
 846 {
 847     setNodeAttribute(element, attribute, nullAtom());
 848 }
 849 
 850 void CompositeEditCommand::setNodeAttribute(Element&amp; element, const QualifiedName&amp; attribute, const AtomicString&amp; value)
 851 {
 852     applyCommandToComposite(SetNodeAttributeCommand::create(element, attribute, value));
 853 }
 854 
 855 static inline bool containsOnlyDeprecatedEditingWhitespace(const String&amp; text)
 856 {
 857     for (unsigned i = 0; i &lt; text.length(); ++i) {
 858         if (!deprecatedIsEditingWhitespace(text[i]))
 859             return false;
 860     }
 861     return true;
 862 }
 863 
 864 bool CompositeEditCommand::shouldRebalanceLeadingWhitespaceFor(const String&amp; text) const
 865 {
 866     return containsOnlyDeprecatedEditingWhitespace(text);
 867 }
 868 
 869 bool CompositeEditCommand::canRebalance(const Position&amp; position) const
 870 {
 871     Node* node = position.containerNode();
 872     if (position.anchorType() != Position::PositionIsOffsetInAnchor || !is&lt;Text&gt;(node))
 873         return false;
 874 
 875     Text&amp; textNode = downcast&lt;Text&gt;(*node);
 876     if (!textNode.length())
 877         return false;
 878 
 879     node-&gt;document().updateStyleIfNeeded();
 880 
 881     RenderObject* renderer = textNode.renderer();
 882     if (renderer &amp;&amp; !renderer-&gt;style().collapseWhiteSpace())
 883         return false;
 884 
 885     return true;
 886 }
 887 
 888 // FIXME: Doesn&#39;t go into text nodes that contribute adjacent text (siblings, cousins, etc).
 889 void CompositeEditCommand::rebalanceWhitespaceAt(const Position&amp; position)
 890 {
 891     Node* node = position.containerNode();
 892     if (!canRebalance(position))
 893         return;
 894 
 895     // If the rebalance is for the single offset, and neither text[offset] nor text[offset - 1] are some form of whitespace, do nothing.
 896     int offset = position.deprecatedEditingOffset();
 897     String text = downcast&lt;Text&gt;(*node).data();
 898     if (!deprecatedIsEditingWhitespace(text[offset])) {
 899         offset--;
 900         if (offset &lt; 0 || !deprecatedIsEditingWhitespace(text[offset]))
 901             return;
 902     }
 903 
 904     rebalanceWhitespaceOnTextSubstring(downcast&lt;Text&gt;(*node), position.offsetInContainerNode(), position.offsetInContainerNode());
 905 }
 906 
 907 void CompositeEditCommand::rebalanceWhitespaceOnTextSubstring(Text&amp; textNode, int startOffset, int endOffset)
 908 {
 909     String text = textNode.data();
 910     ASSERT(!text.isEmpty());
 911 
 912     // Set upstream and downstream to define the extent of the whitespace surrounding text[offset].
 913     int upstream = startOffset;
 914     while (upstream &gt; 0 &amp;&amp; deprecatedIsEditingWhitespace(text[upstream - 1]))
 915         upstream--;
 916 
 917     int downstream = endOffset;
 918     while ((unsigned)downstream &lt; text.length() &amp;&amp; deprecatedIsEditingWhitespace(text[downstream]))
 919         downstream++;
 920 
 921     int length = downstream - upstream;
 922     if (!length)
 923         return;
 924 
 925     VisiblePosition visibleUpstreamPos(Position(&amp;textNode, upstream));
 926     VisiblePosition visibleDownstreamPos(Position(&amp;textNode, downstream));
 927 
 928     String string = text.substring(upstream, length);
 929     String rebalancedString = stringWithRebalancedWhitespace(string,
 930     // FIXME: Because of the problem mentioned at the top of this function, we must also use nbsps at the start/end of the string because
 931     // this function doesn&#39;t get all surrounding whitespace, just the whitespace in the current text node.
 932                                                              isStartOfParagraph(visibleUpstreamPos) || upstream == 0,
 933                                                              isEndOfParagraph(visibleDownstreamPos) || (unsigned)downstream == text.length());
 934 
 935     if (string != rebalancedString)
 936         replaceTextInNodePreservingMarkers(textNode, upstream, length, rebalancedString);
 937 }
 938 
 939 void CompositeEditCommand::prepareWhitespaceAtPositionForSplit(Position&amp; position)
 940 {
 941     Node* node = position.deprecatedNode();
 942     if (!is&lt;Text&gt;(node))
 943         return;
 944     Text&amp; textNode = downcast&lt;Text&gt;(*node);
 945 
 946     if (!textNode.length())
 947         return;
 948     RenderObject* renderer = textNode.renderer();
 949     if (renderer &amp;&amp; !renderer-&gt;style().collapseWhiteSpace())
 950         return;
 951 
 952     // Delete collapsed whitespace so that inserting nbsps doesn&#39;t uncollapse it.
 953     Position upstreamPos = position.upstream();
 954     deleteInsignificantText(position.upstream(), position.downstream());
 955     position = upstreamPos.downstream();
 956 
 957     VisiblePosition visiblePos(position);
 958     VisiblePosition previousVisiblePos(visiblePos.previous());
 959     Position previous(previousVisiblePos.deepEquivalent());
 960 
 961     if (deprecatedIsCollapsibleWhitespace(previousVisiblePos.characterAfter()) &amp;&amp; is&lt;Text&gt;(*previous.deprecatedNode()) &amp;&amp; !is&lt;HTMLBRElement&gt;(*previous.deprecatedNode()))
 962         replaceTextInNodePreservingMarkers(downcast&lt;Text&gt;(*previous.deprecatedNode()), previous.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
 963     if (deprecatedIsCollapsibleWhitespace(visiblePos.characterAfter()) &amp;&amp; is&lt;Text&gt;(*position.deprecatedNode()) &amp;&amp; !is&lt;HTMLBRElement&gt;(*position.deprecatedNode()))
 964         replaceTextInNodePreservingMarkers(downcast&lt;Text&gt;(*position.deprecatedNode()), position.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
 965 }
 966 
 967 void CompositeEditCommand::rebalanceWhitespace()
 968 {
 969     VisibleSelection selection = endingSelection();
 970     if (selection.isNone())
 971         return;
 972 
 973     rebalanceWhitespaceAt(selection.start());
 974     if (selection.isRange())
 975         rebalanceWhitespaceAt(selection.end());
 976 }
 977 
 978 void CompositeEditCommand::deleteInsignificantText(Text&amp; textNode, unsigned start, unsigned end)
 979 {
 980     if (start &gt;= end)
 981         return;
 982 
 983     document().updateLayout();
 984 
 985     RenderText* textRenderer = textNode.renderer();
 986     if (!textRenderer)
 987         return;
 988 
 989     Vector&lt;InlineTextBox*&gt; sortedTextBoxes;
 990     size_t sortedTextBoxesPosition = 0;
 991 
 992     for (InlineTextBox* textBox = textRenderer-&gt;firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())
 993         sortedTextBoxes.append(textBox);
 994 
 995     // If there is mixed directionality text, the boxes can be out of order,
 996     // (like Arabic with embedded LTR), so sort them first.
 997     if (textRenderer-&gt;containsReversedText())
 998         std::sort(sortedTextBoxes.begin(), sortedTextBoxes.end(), InlineTextBox::compareByStart);
 999     InlineTextBox* box = sortedTextBoxes.isEmpty() ? 0 : sortedTextBoxes[sortedTextBoxesPosition];
1000 
1001     if (!box) {
1002         // whole text node is empty
1003         removeNode(textNode);
1004         return;
1005     }
1006 
1007     unsigned length = textNode.length();
1008     if (start &gt;= length || end &gt; length)
1009         return;
1010 
1011     unsigned removed = 0;
1012     InlineTextBox* prevBox = nullptr;
1013     String str;
1014 
1015     // This loop structure works to process all gaps preceding a box,
1016     // and also will look at the gap after the last box.
1017     while (prevBox || box) {
1018         unsigned gapStart = prevBox ? prevBox-&gt;start() + prevBox-&gt;len() : 0;
1019         if (end &lt; gapStart)
1020             // No more chance for any intersections
1021             break;
1022 
1023         unsigned gapEnd = box ? box-&gt;start() : length;
1024         bool indicesIntersect = start &lt;= gapEnd &amp;&amp; end &gt;= gapStart;
1025         int gapLen = gapEnd - gapStart;
1026         if (indicesIntersect &amp;&amp; gapLen &gt; 0) {
1027             gapStart = std::max(gapStart, start);
1028             gapEnd = std::min(gapEnd, end);
1029             if (str.isNull())
1030                 str = textNode.data().substring(start, end - start);
1031             // remove text in the gap
1032             str.remove(gapStart - start - removed, gapLen);
1033             removed += gapLen;
1034         }
1035 
1036         prevBox = box;
1037         if (box) {
1038             if (++sortedTextBoxesPosition &lt; sortedTextBoxes.size())
1039                 box = sortedTextBoxes[sortedTextBoxesPosition];
1040             else
1041                 box = nullptr;
1042         }
1043     }
1044 
1045     if (!str.isNull()) {
1046         // Replace the text between start and end with our pruned version.
1047         if (!str.isEmpty())
1048             replaceTextInNode(textNode, start, end - start, str);
1049         else {
1050             // Assert that we are not going to delete all of the text in the node.
1051             // If we were, that should have been done above with the call to
1052             // removeNode and return.
1053             ASSERT(start &gt; 0 || end - start &lt; textNode.length());
1054             deleteTextFromNode(textNode, start, end - start);
1055         }
1056     }
1057 }
1058 
1059 void CompositeEditCommand::deleteInsignificantText(const Position&amp; start, const Position&amp; end)
1060 {
1061     if (start.isNull() || end.isNull())
1062         return;
1063 
1064     if (comparePositions(start, end) &gt;= 0)
1065         return;
1066 
1067     Vector&lt;Ref&lt;Text&gt;&gt; nodes;
1068     for (Node* node = start.deprecatedNode(); node; node = NodeTraversal::next(*node)) {
1069         if (is&lt;Text&gt;(*node))
1070             nodes.append(downcast&lt;Text&gt;(*node));
1071         if (node == end.deprecatedNode())
1072             break;
1073     }
1074 
1075     for (auto&amp; textNode : nodes) {
1076         int startOffset = textNode.ptr() == start.deprecatedNode() ? start.deprecatedEditingOffset() : 0;
1077         int endOffset = textNode.ptr() == end.deprecatedNode() ? end.deprecatedEditingOffset() : static_cast&lt;int&gt;(textNode-&gt;length());
1078         deleteInsignificantText(textNode, startOffset, endOffset);
1079     }
1080 }
1081 
1082 void CompositeEditCommand::deleteInsignificantTextDownstream(const Position&amp; pos)
1083 {
1084     Position end = VisiblePosition(pos, VP_DEFAULT_AFFINITY).next().deepEquivalent().downstream();
1085     deleteInsignificantText(pos, end);
1086 }
1087 
1088 Ref&lt;Element&gt; CompositeEditCommand::appendBlockPlaceholder(Ref&lt;Element&gt;&amp;&amp; container)
1089 {
1090     document().updateLayoutIgnorePendingStylesheets();
1091 
1092     // Should assert isBlockFlow || isInlineFlow when deletion improves. See 4244964.
1093     ASSERT(container-&gt;renderer());
1094 
1095     auto placeholder = createBlockPlaceholderElement(document());
1096     appendNode(placeholder.copyRef(), WTFMove(container));
1097     return placeholder;
1098 }
1099 
1100 RefPtr&lt;Node&gt; CompositeEditCommand::insertBlockPlaceholder(const Position&amp; pos)
1101 {
1102     if (pos.isNull())
1103         return nullptr;
1104 
1105     // Should assert isBlockFlow || isInlineFlow when deletion improves.  See 4244964.
1106     ASSERT(pos.deprecatedNode()-&gt;renderer());
1107 
1108     auto placeholder = createBlockPlaceholderElement(document());
1109     insertNodeAt(placeholder.copyRef(), pos);
1110     return WTFMove(placeholder);
1111 }
1112 
1113 RefPtr&lt;Node&gt; CompositeEditCommand::addBlockPlaceholderIfNeeded(Element* container)
1114 {
1115     if (!container)
1116         return nullptr;
1117 
1118     document().updateLayoutIgnorePendingStylesheets();
1119 
1120     auto* renderer = container-&gt;renderer();
1121     if (!is&lt;RenderBlockFlow&gt;(renderer))
1122         return nullptr;
1123 
1124     // Append the placeholder to make sure it follows any unrendered blocks.
1125     auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer);
1126     if (!blockFlow.height() || (blockFlow.isListItem() &amp;&amp; !blockFlow.firstChild()))
1127         return appendBlockPlaceholder(*container);
1128 
1129     return nullptr;
1130 }
1131 
1132 // Assumes that the position is at a placeholder and does the removal without much checking.
1133 void CompositeEditCommand::removePlaceholderAt(const Position&amp; p)
1134 {
1135     ASSERT(lineBreakExistsAtPosition(p));
1136 
1137     // We are certain that the position is at a line break, but it may be a br or a preserved newline.
1138     if (is&lt;HTMLBRElement&gt;(*p.anchorNode())) {
1139         removeNode(*p.anchorNode());
1140         return;
1141     }
1142 
1143     deleteTextFromNode(downcast&lt;Text&gt;(*p.anchorNode()), p.offsetInContainerNode(), 1);
1144 }
1145 
1146 Ref&lt;HTMLElement&gt; CompositeEditCommand::insertNewDefaultParagraphElementAt(const Position&amp; position)
1147 {
1148     auto paragraphElement = createDefaultParagraphElement(document());
1149     paragraphElement-&gt;appendChild(HTMLBRElement::create(document()));
1150     insertNodeAt(paragraphElement.copyRef(), position);
1151     return paragraphElement;
1152 }
1153 
1154 // If the paragraph is not entirely within it&#39;s own block, create one and move the paragraph into
1155 // it, and return that block.  Otherwise return 0.
1156 RefPtr&lt;Node&gt; CompositeEditCommand::moveParagraphContentsToNewBlockIfNecessary(const Position&amp; pos)
1157 {
1158     if (pos.isNull())
1159         return nullptr;
1160 
1161     document().updateLayoutIgnorePendingStylesheets();
1162 
1163     // It&#39;s strange that this function is responsible for verifying that pos has not been invalidated
1164     // by an earlier call to this function.  The caller, applyBlockStyle, should do this.
1165     VisiblePosition visiblePos(pos, VP_DEFAULT_AFFINITY);
1166     VisiblePosition visibleParagraphStart(startOfParagraph(visiblePos));
1167     VisiblePosition visibleParagraphEnd = endOfParagraph(visiblePos);
1168     VisiblePosition next = visibleParagraphEnd.next();
1169     VisiblePosition visibleEnd = next.isNotNull() ? next : visibleParagraphEnd;
1170 
1171     Position upstreamStart = visibleParagraphStart.deepEquivalent().upstream();
1172     Position upstreamEnd = visibleEnd.deepEquivalent().upstream();
1173 
1174     // If there are no VisiblePositions in the same block as pos then
1175     // upstreamStart will be outside the paragraph
1176     if (comparePositions(pos, upstreamStart) &lt; 0)
1177         return nullptr;
1178 
1179     // Perform some checks to see if we need to perform work in this function.
1180     if (isBlock(upstreamStart.deprecatedNode())) {
1181         // If the block is the root editable element, always move content to a new block,
1182         // since it is illegal to modify attributes on the root editable element for editing.
1183         if (upstreamStart.deprecatedNode() == editableRootForPosition(upstreamStart)) {
1184             // If the block is the root editable element and it contains no visible content, create a new
1185             // block but don&#39;t try and move content into it, since there&#39;s nothing for moveParagraphs to move.
1186             if (!Position::hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderElement&gt;(*upstreamStart.deprecatedNode()-&gt;renderer())))
1187                 return insertNewDefaultParagraphElementAt(upstreamStart);
1188         } else if (isBlock(upstreamEnd.deprecatedNode())) {
1189             if (!upstreamEnd.deprecatedNode()-&gt;isDescendantOf(upstreamStart.deprecatedNode())) {
1190                 // If the paragraph end is a descendant of paragraph start, then we need to run
1191                 // the rest of this function. If not, we can bail here.
1192                 return nullptr;
1193             }
1194         } else if (enclosingBlock(upstreamEnd.deprecatedNode()) != upstreamStart.deprecatedNode()) {
1195             // The visibleEnd. If it is an ancestor of the paragraph start, then
1196             // we can bail as we have a full block to work with.
1197             if (upstreamStart.deprecatedNode()-&gt;isDescendantOf(enclosingBlock(upstreamEnd.deprecatedNode())))
1198                 return nullptr;
1199         } else if (isEndOfEditableOrNonEditableContent(visibleEnd)) {
1200             // At the end of the editable region. We can bail here as well.
1201             return nullptr;
1202         }
1203     }
1204 
1205     // If upstreamStart is not editable, then we can bail here.
1206     if (!isEditablePosition(upstreamStart))
1207         return nullptr;
1208     auto newBlock = insertNewDefaultParagraphElementAt(upstreamStart);
1209 
1210     bool endWasBr = visibleParagraphEnd.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag);
1211 
1212     moveParagraphs(visibleParagraphStart, visibleParagraphEnd, VisiblePosition(firstPositionInNode(newBlock.ptr())));
1213 
1214     if (newBlock-&gt;lastChild() &amp;&amp; newBlock-&gt;lastChild()-&gt;hasTagName(brTag) &amp;&amp; !endWasBr)
1215         removeNode(*newBlock-&gt;lastChild());
1216 
1217     return WTFMove(newBlock);
1218 }
1219 
1220 void CompositeEditCommand::pushAnchorElementDown(Element&amp; anchorElement)
1221 {
1222     ASSERT(anchorElement.isLink());
1223 
1224     setEndingSelection(VisibleSelection::selectionFromContentsOfNode(&amp;anchorElement));
1225     applyStyledElement(anchorElement);
1226     // Clones of anchorElement have been pushed down, now remove it.
1227     if (anchorElement.isConnected())
1228         removeNodePreservingChildren(anchorElement);
1229 }
1230 
1231 // Clone the paragraph between start and end under blockElement,
1232 // preserving the hierarchy up to outerNode.
1233 
1234 void CompositeEditCommand::cloneParagraphUnderNewElement(const Position&amp; start, const Position&amp; end, Node* passedOuterNode, Element* blockElement)
1235 {
1236     ASSERT(comparePositions(start, end) &lt;= 0);
1237 
1238     // First we clone the outerNode
1239     RefPtr&lt;Node&gt; lastNode;
1240     RefPtr&lt;Node&gt; outerNode = passedOuterNode;
1241 
1242     if (outerNode-&gt;isRootEditableElement()) {
1243         lastNode = blockElement;
1244     } else {
1245         lastNode = outerNode-&gt;cloneNode(isRenderedTable(outerNode.get()));
1246         appendNode(*lastNode, *blockElement);
1247     }
1248 
1249     if (start.deprecatedNode() != outerNode &amp;&amp; lastNode-&gt;isElementNode() &amp;&amp; start.anchorNode()-&gt;isDescendantOf(outerNode.get())) {
1250         Vector&lt;RefPtr&lt;Node&gt;&gt; ancestors;
1251 
1252         // Insert each node from innerNode to outerNode (excluded) in a list.
1253         for (Node* n = start.deprecatedNode(); n &amp;&amp; n != outerNode; n = n-&gt;parentNode())
1254             ancestors.append(n);
1255 
1256         // Clone every node between start.deprecatedNode() and outerBlock.
1257 
1258         for (size_t i = ancestors.size(); i != 0; --i) {
1259             Node* item = ancestors[i - 1].get();
1260             auto child = item-&gt;cloneNode(isRenderedTable(item));
1261             appendNode(child.copyRef(), downcast&lt;Element&gt;(*lastNode));
1262             lastNode = WTFMove(child);
1263         }
1264     }
1265 
1266     // Handle the case of paragraphs with more than one node,
1267     // cloning all the siblings until end.deprecatedNode() is reached.
1268 
1269     if (start.deprecatedNode() != end.deprecatedNode() &amp;&amp; !start.deprecatedNode()-&gt;isDescendantOf(end.deprecatedNode())) {
1270         // If end is not a descendant of outerNode we need to
1271         // find the first common ancestor to increase the scope
1272         // of our nextSibling traversal.
1273         while (!end.deprecatedNode()-&gt;isDescendantOf(outerNode.get())) {
1274             outerNode = outerNode-&gt;parentNode();
1275         }
1276 
1277         RefPtr&lt;Node&gt; startNode = start.deprecatedNode();
1278         for (RefPtr&lt;Node&gt; node = NodeTraversal::nextSkippingChildren(*startNode, outerNode.get()); node; node = NodeTraversal::nextSkippingChildren(*node, outerNode.get())) {
1279             // Move lastNode up in the tree as much as node was moved up in the
1280             // tree by NodeTraversal::nextSkippingChildren, so that the relative depth between
1281             // node and the original start node is maintained in the clone.
1282             while (startNode-&gt;parentNode() != node-&gt;parentNode()) {
1283                 startNode = startNode-&gt;parentNode();
1284                 lastNode = lastNode-&gt;parentNode();
1285             }
1286 
1287             auto clonedNode = node-&gt;cloneNode(true);
1288             insertNodeAfter(clonedNode.copyRef(), *lastNode);
1289             lastNode = WTFMove(clonedNode);
1290             if (node == end.deprecatedNode() || end.deprecatedNode()-&gt;isDescendantOf(*node))
1291                 break;
1292         }
1293     }
1294 }
1295 
1296 
1297 // There are bugs in deletion when it removes a fully selected table/list.
1298 // It expands and removes the entire table/list, but will let content
1299 // before and after the table/list collapse onto one line.
1300 // Deleting a paragraph will leave a placeholder. Remove it (and prune
1301 // empty or unrendered parents).
1302 
1303 void CompositeEditCommand::cleanupAfterDeletion(VisiblePosition destination)
1304 {
1305     VisiblePosition caretAfterDelete = endingSelection().visibleStart();
1306     if (!caretAfterDelete.equals(destination) &amp;&amp; isStartOfParagraph(caretAfterDelete) &amp;&amp; isEndOfParagraph(caretAfterDelete)) {
1307         // Note: We want the rightmost candidate.
1308         Position position = caretAfterDelete.deepEquivalent().downstream();
1309         Node* node = position.deprecatedNode();
1310         ASSERT(node);
1311         // Normally deletion will leave a br as a placeholder.
1312         if (is&lt;HTMLBRElement&gt;(*node))
1313             removeNodeAndPruneAncestors(*node);
1314         // If the selection to move was empty and in an empty block that
1315         // doesn&#39;t require a placeholder to prop itself open (like a bordered
1316         // div or an li), remove it during the move (the list removal code
1317         // expects this behavior).
1318         else if (isBlock(node)) {
1319             // If caret position after deletion and destination position coincides,
1320             // node should not be removed.
1321             if (!position.rendersInDifferentPosition(destination.deepEquivalent())) {
1322                 prune(node);
1323                 return;
1324             }
1325             removeNodeAndPruneAncestors(*node);
1326         }
1327         else if (lineBreakExistsAtPosition(position)) {
1328             // There is a preserved &#39;\n&#39; at caretAfterDelete.
1329             // We can safely assume this is a text node.
1330             Text&amp; textNode = downcast&lt;Text&gt;(*node);
1331             if (textNode.length() == 1)
1332                 removeNodeAndPruneAncestors(textNode);
1333             else
1334                 deleteTextFromNode(textNode, position.deprecatedEditingOffset(), 1);
1335         }
1336     }
1337 }
1338 
1339 // This is a version of moveParagraph that preserves style by keeping the original markup
1340 // It is currently used only by IndentOutdentCommand but it is meant to be used in the
1341 // future by several other commands such as InsertList and the align commands.
1342 // The blockElement parameter is the element to move the paragraph to,
1343 // outerNode is the top element of the paragraph hierarchy.
1344 
1345 void CompositeEditCommand::moveParagraphWithClones(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, Element* blockElement, Node* outerNode)
1346 {
1347     if (startOfParagraphToMove.isNull() || endOfParagraphToMove.isNull())
1348         return;
1349 
1350     ASSERT(outerNode);
1351     ASSERT(blockElement);
1352 
1353     VisiblePosition beforeParagraph = startOfParagraphToMove.previous();
1354     VisiblePosition afterParagraph(endOfParagraphToMove.next());
1355 
1356     // We upstream() the end and downstream() the start so that we don&#39;t include collapsed whitespace in the move.
1357     // When we paste a fragment, spaces after the end and before the start are treated as though they were rendered.
1358     Position start = startOfParagraphToMove.deepEquivalent().downstream();
1359     Position end = startOfParagraphToMove == endOfParagraphToMove ? start : endOfParagraphToMove.deepEquivalent().upstream();
1360 
1361     cloneParagraphUnderNewElement(start, end, outerNode, blockElement);
1362 
1363     setEndingSelection(VisibleSelection(start, end, DOWNSTREAM));
1364     deleteSelection(false, false, false, false);
1365 
1366     // There are bugs in deletion when it removes a fully selected table/list.
1367     // It expands and removes the entire table/list, but will let content
1368     // before and after the table/list collapse onto one line.
1369 
1370     cleanupAfterDeletion();
1371 
1372     // Add a br if pruning an empty block level element caused a collapse.  For example:
1373     // foo^
1374     // &lt;div&gt;bar&lt;/div&gt;
1375     // baz
1376     // Imagine moving &#39;bar&#39; to ^.  &#39;bar&#39; will be deleted and its div pruned.  That would
1377     // cause &#39;baz&#39; to collapse onto the line with &#39;foobar&#39; unless we insert a br.
1378     // Must recononicalize these two VisiblePositions after the pruning above.
1379     beforeParagraph = VisiblePosition(beforeParagraph.deepEquivalent());
1380     afterParagraph = VisiblePosition(afterParagraph.deepEquivalent());
1381 
1382     if (beforeParagraph.isNotNull() &amp;&amp; !isRenderedTable(beforeParagraph.deepEquivalent().deprecatedNode())
1383         &amp;&amp; ((!isEndOfParagraph(beforeParagraph) &amp;&amp; !isStartOfParagraph(beforeParagraph)) || beforeParagraph == afterParagraph)
1384         &amp;&amp; isEditablePosition(beforeParagraph.deepEquivalent())) {
1385         // FIXME: Trim text between beforeParagraph and afterParagraph if they aren&#39;t equal.
1386         insertNodeAt(HTMLBRElement::create(document()), beforeParagraph.deepEquivalent());
1387     }
1388 }
1389 
1390 
1391 // This moves a paragraph preserving its style.
1392 void CompositeEditCommand::moveParagraph(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, const VisiblePosition&amp; destination, bool preserveSelection, bool preserveStyle)
1393 {
1394     ASSERT(isStartOfParagraph(startOfParagraphToMove));
1395     ASSERT(isEndOfParagraph(endOfParagraphToMove));
1396     moveParagraphs(startOfParagraphToMove, endOfParagraphToMove, destination, preserveSelection, preserveStyle);
1397 }
1398 
1399 void CompositeEditCommand::moveParagraphs(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, const VisiblePosition&amp; destination, bool preserveSelection, bool preserveStyle)
1400 {
1401     if (startOfParagraphToMove == destination)
1402         return;
1403 
1404     int startIndex = -1;
1405     int endIndex = -1;
1406     int destinationIndex = -1;
1407     bool originalIsDirectional = endingSelection().isDirectional();
1408     if (preserveSelection &amp;&amp; !endingSelection().isNone()) {
1409         VisiblePosition visibleStart = endingSelection().visibleStart();
1410         VisiblePosition visibleEnd = endingSelection().visibleEnd();
1411 
1412         bool startAfterParagraph = comparePositions(visibleStart, endOfParagraphToMove) &gt; 0;
1413         bool endBeforeParagraph = comparePositions(visibleEnd, startOfParagraphToMove) &lt; 0;
1414 
1415         if (!startAfterParagraph &amp;&amp; !endBeforeParagraph) {
1416             bool startInParagraph = comparePositions(visibleStart, startOfParagraphToMove) &gt;= 0;
1417             bool endInParagraph = comparePositions(visibleEnd, endOfParagraphToMove) &lt;= 0;
1418 
1419             startIndex = 0;
1420             if (startInParagraph) {
1421                 auto startRange = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), visibleStart.deepEquivalent().parentAnchoredEquivalent());
1422                 startIndex = TextIterator::rangeLength(startRange.ptr(), true);
1423             }
1424 
1425             endIndex = 0;
1426             if (endInParagraph) {
1427                 auto endRange = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), visibleEnd.deepEquivalent().parentAnchoredEquivalent());
1428                 endIndex = TextIterator::rangeLength(endRange.ptr(), true);
1429             }
1430         }
1431     }
1432 
1433     VisiblePosition beforeParagraph = startOfParagraphToMove.previous(CannotCrossEditingBoundary);
1434     VisiblePosition afterParagraph(endOfParagraphToMove.next(CannotCrossEditingBoundary));
1435 
1436     // We upstream() the end and downstream() the start so that we don&#39;t include collapsed whitespace in the move.
1437     // When we paste a fragment, spaces after the end and before the start are treated as though they were rendered.
1438     Position start = startOfParagraphToMove.deepEquivalent().downstream();
1439     Position end = endOfParagraphToMove.deepEquivalent().upstream();
1440 
1441     // start and end can&#39;t be used directly to create a Range; they are &quot;editing positions&quot;
1442     Position startRangeCompliant = start.parentAnchoredEquivalent();
1443     Position endRangeCompliant = end.parentAnchoredEquivalent();
1444     auto range = Range::create(document(), startRangeCompliant.deprecatedNode(), startRangeCompliant.deprecatedEditingOffset(), endRangeCompliant.deprecatedNode(), endRangeCompliant.deprecatedEditingOffset());
1445 
1446     // FIXME: This is an inefficient way to preserve style on nodes in the paragraph to move. It
1447     // shouldn&#39;t matter though, since moved paragraphs will usually be quite small.
1448     RefPtr&lt;DocumentFragment&gt; fragment;
1449     // This used to use a ternary for initialization, but that confused some versions of GCC, see bug 37912
1450     if (startOfParagraphToMove != endOfParagraphToMove)
1451         fragment = createFragmentFromMarkup(document(), serializePreservingVisualAppearance(range.get(), nullptr, AnnotateForInterchange::No, ConvertBlocksToInlines::Yes), emptyString());
1452 
1453     // A non-empty paragraph&#39;s style is moved when we copy and move it.  We don&#39;t move
1454     // anything if we&#39;re given an empty paragraph, but an empty paragraph can have style
1455     // too, &lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt; for example.  Save it so that we can preserve it later.
1456     RefPtr&lt;EditingStyle&gt; styleInEmptyParagraph;
1457 #if !PLATFORM(IOS_FAMILY)
1458     if (startOfParagraphToMove == endOfParagraphToMove &amp;&amp; preserveStyle) {
1459 #else
1460     if (startOfParagraphToMove == endOfParagraphToMove &amp;&amp; preserveStyle &amp;&amp; isRichlyEditablePosition(destination.deepEquivalent())) {
1461 #endif
1462         styleInEmptyParagraph = EditingStyle::create(startOfParagraphToMove.deepEquivalent());
1463         styleInEmptyParagraph-&gt;mergeTypingStyle(document());
1464         // The moved paragraph should assume the block style of the destination.
1465         styleInEmptyParagraph-&gt;removeBlockProperties();
1466     }
1467 
1468     // FIXME (5098931): We should add a new insert action &quot;WebViewInsertActionMoved&quot; and call shouldInsertFragment here.
1469 
1470     setEndingSelection(VisibleSelection(start, end, DOWNSTREAM));
1471     frame().editor().clearMisspellingsAndBadGrammar(endingSelection());
1472     deleteSelection(false, false, false, false);
1473 
1474     ASSERT(destination.deepEquivalent().anchorNode()-&gt;isConnected());
1475     cleanupAfterDeletion(destination);
1476     ASSERT(destination.deepEquivalent().anchorNode()-&gt;isConnected());
1477 
1478     // Add a br if pruning an empty block level element caused a collapse. For example:
1479     // foo^
1480     // &lt;div&gt;bar&lt;/div&gt;
1481     // baz
1482     // Imagine moving &#39;bar&#39; to ^. &#39;bar&#39; will be deleted and its div pruned. That would
1483     // cause &#39;baz&#39; to collapse onto the line with &#39;foobar&#39; unless we insert a br.
1484     // Must recononicalize these two VisiblePositions after the pruning above.
1485     beforeParagraph = VisiblePosition(beforeParagraph.deepEquivalent());
1486     afterParagraph = VisiblePosition(afterParagraph.deepEquivalent());
1487     if (beforeParagraph.isNotNull() &amp;&amp; ((!isStartOfParagraph(beforeParagraph) &amp;&amp; !isEndOfParagraph(beforeParagraph)) || beforeParagraph == afterParagraph)) {
1488         // FIXME: Trim text between beforeParagraph and afterParagraph if they aren&#39;t equal.
1489         insertNodeAt(HTMLBRElement::create(document()), beforeParagraph.deepEquivalent());
1490         // Need an updateLayout here in case inserting the br has split a text node.
1491         document().updateLayoutIgnorePendingStylesheets();
1492     }
1493 
1494     auto editableRoot = destination.rootEditableElement();
1495     RefPtr&lt;Range&gt; startToDestinationRange(Range::create(document(), firstPositionInNode(editableRoot), destination.deepEquivalent().parentAnchoredEquivalent()));
1496     destinationIndex = TextIterator::rangeLength(startToDestinationRange.get(), true);
1497 
1498     setEndingSelection(VisibleSelection(destination, originalIsDirectional));
1499     ASSERT(endingSelection().isCaretOrRange());
1500     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MovingParagraph };
1501     if (!preserveStyle)
1502         options.add(ReplaceSelectionCommand::MatchStyle);
1503     applyCommandToComposite(ReplaceSelectionCommand::create(document(), WTFMove(fragment), options));
1504 
1505     frame().editor().markMisspellingsAndBadGrammar(endingSelection());
1506 
1507     // If the selection is in an empty paragraph, restore styles from the old empty paragraph to the new empty paragraph.
1508     bool selectionIsEmptyParagraph = endingSelection().isCaret() &amp;&amp; isStartOfParagraph(endingSelection().visibleStart()) &amp;&amp; isEndOfParagraph(endingSelection().visibleStart());
1509     if (styleInEmptyParagraph &amp;&amp; selectionIsEmptyParagraph)
1510         applyStyle(styleInEmptyParagraph.get());
1511 
1512     if (preserveSelection &amp;&amp; startIndex != -1) {
1513         // Fragment creation (using createMarkup) incorrectly uses regular
1514         // spaces instead of nbsps for some spaces that were rendered (11475), which
1515         // causes spaces to be collapsed during the move operation.  This results
1516         // in a call to rangeFromLocationAndLength with a location past the end
1517         // of the document (which will return null).
1518         RefPtr&lt;Range&gt; start = TextIterator::rangeFromLocationAndLength(editableRoot, destinationIndex + startIndex, 0, true);
1519         RefPtr&lt;Range&gt; end = TextIterator::rangeFromLocationAndLength(editableRoot, destinationIndex + endIndex, 0, true);
1520         if (start &amp;&amp; end)
1521             setEndingSelection(VisibleSelection(start-&gt;startPosition(), end-&gt;startPosition(), DOWNSTREAM, originalIsDirectional));
1522     }
1523 }
1524 
1525 Optional&lt;VisibleSelection&gt; CompositeEditCommand::shouldBreakOutOfEmptyListItem() const
1526 {
1527     auto emptyListItem = enclosingEmptyListItem(endingSelection().visibleStart());
1528     if (!emptyListItem)
1529         return WTF::nullopt;
1530 
1531     auto listNode = emptyListItem-&gt;parentNode();
1532     // FIXME: Can&#39;t we do something better when the immediate parent wasn&#39;t a list node?
1533     if (!listNode
1534         || (!listNode-&gt;hasTagName(ulTag) &amp;&amp; !listNode-&gt;hasTagName(olTag))
1535         || !listNode-&gt;hasEditableStyle()
1536         || listNode == emptyListItem-&gt;rootEditableElement())
1537         return WTF::nullopt;
1538 
1539     return VisibleSelection(endingSelection().start().previous(BackwardDeletion), endingSelection().end());
1540 }
1541 
1542 // FIXME: Send an appropriate shouldDeleteRange call.
1543 bool CompositeEditCommand::breakOutOfEmptyListItem()
1544 {
1545     if (!shouldBreakOutOfEmptyListItem())
1546         return false;
1547 
1548     auto emptyListItem = enclosingEmptyListItem(endingSelection().visibleStart());
1549     auto listNode = emptyListItem-&gt;parentNode();
1550     auto style = EditingStyle::create(endingSelection().start());
1551     style-&gt;mergeTypingStyle(document());
1552 
1553     RefPtr&lt;Element&gt; newBlock;
1554     if (ContainerNode* blockEnclosingList = listNode-&gt;parentNode()) {
1555         if (is&lt;HTMLLIElement&gt;(*blockEnclosingList)) { // listNode is inside another list item
1556             if (visiblePositionAfterNode(*blockEnclosingList) == visiblePositionAfterNode(*listNode)) {
1557                 // If listNode appears at the end of the outer list item, then move listNode outside of this list item
1558                 // e.g. &lt;ul&gt;&lt;li&gt;hello &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; should become &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt; &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/ul&gt; after this section
1559                 // If listNode does NOT appear at the end, then we should consider it as a regular paragraph.
1560                 // e.g. &lt;ul&gt;&lt;li&gt; &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; hello&lt;/li&gt;&lt;/ul&gt; should become &lt;ul&gt;&lt;li&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt; hello&lt;/li&gt;&lt;/ul&gt; at the end
1561                 splitElement(downcast&lt;HTMLLIElement&gt;(*blockEnclosingList), *listNode);
1562                 removeNodePreservingChildren(*listNode-&gt;parentNode());
1563                 newBlock = HTMLLIElement::create(document());
1564             }
1565             // If listNode does NOT appear at the end of the outer list item, then behave as if in a regular paragraph.
1566         } else if (blockEnclosingList-&gt;hasTagName(olTag) || blockEnclosingList-&gt;hasTagName(ulTag))
1567             newBlock = HTMLLIElement::create(document());
1568     }
1569     if (!newBlock)
1570         newBlock = createDefaultParagraphElement(document());
1571 
1572     RefPtr&lt;Node&gt; previousListNode = emptyListItem-&gt;isElementNode() ? ElementTraversal::previousSibling(*emptyListItem): emptyListItem-&gt;previousSibling();
1573     RefPtr&lt;Node&gt; nextListNode = emptyListItem-&gt;isElementNode() ? ElementTraversal::nextSibling(*emptyListItem): emptyListItem-&gt;nextSibling();
1574     if (isListItem(nextListNode.get()) || isListHTMLElement(nextListNode.get())) {
1575         // If emptyListItem follows another list item or nested list, split the list node.
1576         if (isListItem(previousListNode.get()) || isListHTMLElement(previousListNode.get()))
1577             splitElement(downcast&lt;Element&gt;(*listNode), *emptyListItem);
1578 
1579         // If emptyListItem is followed by other list item or nested list, then insert newBlock before the list node.
1580         // Because we have splitted the element, emptyListItem is the first element in the list node.
1581         // i.e. insert newBlock before ul or ol whose first element is emptyListItem
1582         insertNodeBefore(*newBlock, *listNode);
1583         removeNode(*emptyListItem);
1584     } else {
1585         // When emptyListItem does not follow any list item or nested list, insert newBlock after the enclosing list node.
1586         // Remove the enclosing node if emptyListItem is the only child; otherwise just remove emptyListItem.
1587         insertNodeAfter(*newBlock, *listNode);
1588         removeNode(isListItem(previousListNode.get()) || isListHTMLElement(previousListNode.get()) ? *emptyListItem : *listNode);
1589     }
1590 
1591     appendBlockPlaceholder(*newBlock);
1592     setEndingSelection(VisibleSelection(firstPositionInNode(newBlock.get()), DOWNSTREAM, endingSelection().isDirectional()));
1593 
1594     style-&gt;prepareToApplyAt(endingSelection().start());
1595     if (!style-&gt;isEmpty())
1596         applyStyle(style.ptr());
1597 
1598     return true;
1599 }
1600 
1601 // If the caret is in an empty quoted paragraph, and either there is nothing before that
1602 // paragraph, or what is before is unquoted, and the user presses delete, unquote that paragraph.
1603 bool CompositeEditCommand::breakOutOfEmptyMailBlockquotedParagraph()
1604 {
1605     if (!endingSelection().isCaret())
1606         return false;
1607 
1608     VisiblePosition caret(endingSelection().visibleStart());
1609     Node* highestBlockquote = highestEnclosingNodeOfType(caret.deepEquivalent(), &amp;isMailBlockquote);
1610     if (!highestBlockquote)
1611         return false;
1612 
1613     if (!isStartOfParagraph(caret) || !isEndOfParagraph(caret))
1614         return false;
1615 
1616     VisiblePosition previous(caret.previous(CannotCrossEditingBoundary));
1617     // Only move forward if there&#39;s nothing before the caret, or if there&#39;s unquoted content before it.
1618     if (enclosingNodeOfType(previous.deepEquivalent(), &amp;isMailBlockquote))
1619         return false;
1620 
1621     auto br = HTMLBRElement::create(document());
1622     auto* brPtr = br.ptr();
1623     // We want to replace this quoted paragraph with an unquoted one, so insert a br
1624     // to hold the caret before the highest blockquote.
1625     insertNodeBefore(WTFMove(br), *highestBlockquote);
1626     VisiblePosition atBR(positionBeforeNode(brPtr));
1627     // If the br we inserted collapsed, for example foo&lt;br&gt;&lt;blockquote&gt;...&lt;/blockquote&gt;, insert
1628     // a second one.
1629     if (!isStartOfParagraph(atBR))
1630         insertNodeBefore(HTMLBRElement::create(document()), *brPtr);
1631     setEndingSelection(VisibleSelection(atBR, endingSelection().isDirectional()));
1632 
1633     // If this is an empty paragraph there must be a line break here.
1634     if (!lineBreakExistsAtVisiblePosition(caret))
1635         return false;
1636 
1637     Position caretPos(caret.deepEquivalent().downstream());
1638     // A line break is either a br or a preserved newline.
1639     ASSERT(caretPos.deprecatedNode()-&gt;hasTagName(brTag) || (caretPos.deprecatedNode()-&gt;isTextNode() &amp;&amp; caretPos.deprecatedNode()-&gt;renderer()-&gt;style().preserveNewline()));
1640 
1641     if (caretPos.deprecatedNode()-&gt;hasTagName(brTag))
1642         removeNodeAndPruneAncestors(*caretPos.deprecatedNode());
1643     else if (is&lt;Text&gt;(*caretPos.deprecatedNode())) {
1644         ASSERT(caretPos.deprecatedEditingOffset() == 0);
1645         Text&amp; textNode = downcast&lt;Text&gt;(*caretPos.deprecatedNode());
1646         ContainerNode* parentNode = textNode.parentNode();
1647         // The preserved newline must be the first thing in the node, since otherwise the previous
1648         // paragraph would be quoted, and we verified that it wasn&#39;t above.
1649         deleteTextFromNode(textNode, 0, 1);
1650         prune(parentNode);
1651     }
1652 
1653     return true;
1654 }
1655 
1656 // Operations use this function to avoid inserting content into an anchor when at the start or the end of
1657 // that anchor, as in NSTextView.
1658 // FIXME: This is only an approximation of NSTextViews insertion behavior, which varies depending on how
1659 // the caret was made.
1660 Position CompositeEditCommand::positionAvoidingSpecialElementBoundary(const Position&amp; original)
1661 {
1662     if (original.isNull())
1663         return original;
1664 
1665     VisiblePosition visiblePos(original);
1666     Element* enclosingAnchor = enclosingAnchorElement(original);
1667     Position result = original;
1668 
1669     if (!enclosingAnchor)
1670         return result;
1671 
1672     // Don&#39;t avoid block level anchors, because that would insert content into the wrong paragraph.
1673     if (enclosingAnchor &amp;&amp; !isBlock(enclosingAnchor)) {
1674         VisiblePosition firstInAnchor(firstPositionInNode(enclosingAnchor));
1675         VisiblePosition lastInAnchor(lastPositionInNode(enclosingAnchor));
1676         // If visually just after the anchor, insert *inside* the anchor unless it&#39;s the last
1677         // VisiblePosition in the document, to match NSTextView.
1678         if (visiblePos == lastInAnchor) {
1679             // Make sure anchors are pushed down before avoiding them so that we don&#39;t
1680             // also avoid structural elements like lists and blocks (5142012).
1681             if (original.deprecatedNode() != enclosingAnchor &amp;&amp; original.deprecatedNode()-&gt;parentNode() != enclosingAnchor) {
1682                 pushAnchorElementDown(*enclosingAnchor);
1683                 enclosingAnchor = enclosingAnchorElement(original);
1684                 if (!enclosingAnchor)
1685                     return original;
1686             }
1687             // Don&#39;t insert outside an anchor if doing so would skip over a line break.  It would
1688             // probably be safe to move the line break so that we could still avoid the anchor here.
1689             Position downstream(visiblePos.deepEquivalent().downstream());
1690             if (lineBreakExistsAtVisiblePosition(visiblePos) &amp;&amp; downstream.deprecatedNode()-&gt;isDescendantOf(enclosingAnchor))
1691                 return original;
1692 
1693             result = positionInParentAfterNode(enclosingAnchor);
1694         }
1695         // If visually just before an anchor, insert *outside* the anchor unless it&#39;s the first
1696         // VisiblePosition in a paragraph, to match NSTextView.
1697         if (visiblePos == firstInAnchor) {
1698             // Make sure anchors are pushed down before avoiding them so that we don&#39;t
1699             // also avoid structural elements like lists and blocks (5142012).
1700             if (original.deprecatedNode() != enclosingAnchor &amp;&amp; original.deprecatedNode()-&gt;parentNode() != enclosingAnchor) {
1701                 pushAnchorElementDown(*enclosingAnchor);
1702                 enclosingAnchor = enclosingAnchorElement(original);
1703             }
1704             if (!enclosingAnchor)
1705                 return original;
1706 
1707             result = positionInParentBeforeNode(enclosingAnchor);
1708         }
1709     }
1710 
1711     if (result.isNull() || !editableRootForPosition(result))
1712         result = original;
1713 
1714     return result;
1715 }
1716 
1717 // Splits the tree parent by parent until we reach the specified ancestor. We use VisiblePositions
1718 // to determine if the split is necessary. Returns the last split node.
1719 RefPtr&lt;Node&gt; CompositeEditCommand::splitTreeToNode(Node&amp; start, Node&amp; end, bool shouldSplitAncestor)
1720 {
1721     ASSERT(&amp;start != &amp;end);
1722 
1723     RefPtr&lt;Node&gt; adjustedEnd = &amp;end;
1724     if (shouldSplitAncestor &amp;&amp; adjustedEnd-&gt;parentNode())
1725         adjustedEnd = adjustedEnd-&gt;parentNode();
1726 
1727     ASSERT(adjustedEnd);
1728     RefPtr&lt;Node&gt; node;
1729     for (node = &amp;start; node &amp;&amp; node-&gt;parentNode() != adjustedEnd; node = node-&gt;parentNode()) {
1730         if (!is&lt;Element&gt;(*node-&gt;parentNode()))
1731             break;
1732         // Do not split a node when doing so introduces an empty node.
1733         VisiblePosition positionInParent = firstPositionInNode(node-&gt;parentNode());
1734         VisiblePosition positionInNode = firstPositionInOrBeforeNode(node.get());
1735         if (positionInParent != positionInNode)
1736             splitElement(downcast&lt;Element&gt;(*node-&gt;parentNode()), *node);
1737     }
1738 
1739     return node;
1740 }
1741 
1742 Ref&lt;Element&gt; createBlockPlaceholderElement(Document&amp; document)
1743 {
1744     return HTMLBRElement::create(document);
1745 }
1746 
1747 } // namespace WebCore
    </pre>
  </body>
</html>