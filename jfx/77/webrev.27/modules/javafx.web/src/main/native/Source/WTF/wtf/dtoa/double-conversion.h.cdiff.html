<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fast-dtoa.cc.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,365 ***</span>
  
  namespace WTF {
  namespace double_conversion {
  
  class DoubleToStringConverter {
<span class="line-modified">!     public:</span>
<span class="line-modified">!         // When calling ToFixed with a double &gt; 10^kMaxFixedDigitsBeforePoint</span>
<span class="line-modified">!         // or a requested_digits parameter &gt; kMaxFixedDigitsAfterPoint then the</span>
<span class="line-modified">!         // function returns false.</span>
<span class="line-modified">!         static const int kMaxFixedDigitsBeforePoint = 60;</span>
<span class="line-modified">!         static const int kMaxFixedDigitsAfterPoint = 60;</span>
  
<span class="line-modified">!         // When calling ToExponential with a requested_digits</span>
<span class="line-modified">!         // parameter &gt; kMaxExponentialDigits then the function returns false.</span>
<span class="line-modified">!         static const int kMaxExponentialDigits = 120;</span>
  
<span class="line-modified">!         // When calling ToPrecision with a requested_digits</span>
<span class="line-modified">!         // parameter &lt; kMinPrecisionDigits or requested_digits &gt; kMaxPrecisionDigits</span>
<span class="line-modified">!         // then the function returns false.</span>
<span class="line-modified">!         static const int kMinPrecisionDigits = 1;</span>
<span class="line-modified">!         static const int kMaxPrecisionDigits = 120;</span>
  
<span class="line-modified">!         enum Flags {</span>
<span class="line-modified">!             NO_FLAGS = 0,</span>
<span class="line-modified">!             EMIT_POSITIVE_EXPONENT_SIGN = 1,</span>
<span class="line-modified">!             EMIT_TRAILING_DECIMAL_POINT = 2,</span>
<span class="line-modified">!             EMIT_TRAILING_ZERO_AFTER_POINT = 4,</span>
<span class="line-modified">!             UNIQUE_ZERO = 8</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         // Flags should be a bit-or combination of the possible Flags-enum.</span>
<span class="line-modified">!         //  - NO_FLAGS: no special flags.</span>
<span class="line-modified">!         //  - EMIT_POSITIVE_EXPONENT_SIGN: when the number is converted into exponent</span>
<span class="line-modified">!         //    form, emits a &#39;+&#39; for positive exponents. Example: 1.2e+2.</span>
<span class="line-modified">!         //  - EMIT_TRAILING_DECIMAL_POINT: when the input number is an integer and is</span>
<span class="line-modified">!         //    converted into decimal format then a trailing decimal point is appended.</span>
<span class="line-modified">!         //    Example: 2345.0 is converted to &quot;2345.&quot;.</span>
<span class="line-modified">!         //  - EMIT_TRAILING_ZERO_AFTER_POINT: in addition to a trailing decimal point</span>
<span class="line-modified">!         //    emits a trailing &#39;0&#39;-character. This flag requires the</span>
<span class="line-modified">!         //    EXMIT_TRAILING_DECIMAL_POINT flag.</span>
<span class="line-modified">!         //    Example: 2345.0 is converted to &quot;2345.0&quot;.</span>
<span class="line-modified">!         //  - UNIQUE_ZERO: &quot;-0.0&quot; is converted to &quot;0.0&quot;.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Infinity symbol and nan_symbol provide the string representation for these</span>
<span class="line-modified">!         // special values. If the string is NULL and the special value is encountered</span>
<span class="line-modified">!         // then the conversion functions return false.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // The exponent_character is used in exponential representations. It is</span>
<span class="line-modified">!         // usually &#39;e&#39; or &#39;E&#39;.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // When converting to the shortest representation the converter will</span>
<span class="line-modified">!         // represent input numbers in decimal format if they are in the interval</span>
<span class="line-modified">!         // [10^decimal_in_shortest_low; 10^decimal_in_shortest_high[</span>
<span class="line-modified">!         //    (lower boundary included, greater boundary excluded).</span>
<span class="line-modified">!         // Example: with decimal_in_shortest_low = -6 and</span>
<span class="line-modified">!         //               decimal_in_shortest_high = 21:</span>
<span class="line-modified">!         //   ToShortest(0.000001)  -&gt; &quot;0.000001&quot;</span>
<span class="line-modified">!         //   ToShortest(0.0000001) -&gt; &quot;1e-7&quot;</span>
<span class="line-modified">!         //   ToShortest(111111111111111111111.0)  -&gt; &quot;111111111111111110000&quot;</span>
<span class="line-modified">!         //   ToShortest(100000000000000000000.0)  -&gt; &quot;100000000000000000000&quot;</span>
<span class="line-modified">!         //   ToShortest(1111111111111111111111.0) -&gt; &quot;1.1111111111111111e+21&quot;</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // When converting to precision mode the converter may add</span>
<span class="line-modified">!         // max_leading_padding_zeroes before returning the number in exponential</span>
<span class="line-modified">!         // format.</span>
<span class="line-modified">!         // Example with max_leading_padding_zeroes_in_precision_mode = 6.</span>
<span class="line-modified">!         //   ToPrecision(0.0000012345, 2) -&gt; &quot;0.0000012&quot;</span>
<span class="line-modified">!         //   ToPrecision(0.00000012345, 2) -&gt; &quot;1.2e-7&quot;</span>
<span class="line-modified">!         // Similarily the converter may add up to</span>
<span class="line-modified">!         // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid</span>
<span class="line-modified">!         // returning an exponential representation. A zero added by the</span>
<span class="line-modified">!         // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.</span>
<span class="line-modified">!         // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;230&quot;</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;230.&quot;  with EMIT_TRAILING_DECIMAL_POINT.</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;2.3e2&quot; with EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!         DoubleToStringConverter(int flags,</span>
<span class="line-modified">!                                 const char* infinity_symbol,</span>
<span class="line-modified">!                                 const char* nan_symbol,</span>
<span class="line-modified">!                                 char exponent_character,</span>
<span class="line-modified">!                                 int decimal_in_shortest_low,</span>
<span class="line-modified">!                                 int decimal_in_shortest_high,</span>
<span class="line-modified">!                                 int max_leading_padding_zeroes_in_precision_mode,</span>
<span class="line-modified">!                                 int max_trailing_padding_zeroes_in_precision_mode)</span>
<span class="line-modified">!         : flags_(flags),</span>
          infinity_symbol_(infinity_symbol),
          nan_symbol_(nan_symbol),
          exponent_character_(exponent_character),
          decimal_in_shortest_low_(decimal_in_shortest_low),
          decimal_in_shortest_high_(decimal_in_shortest_high),
          max_leading_padding_zeroes_in_precision_mode_(
<span class="line-modified">!                                                       max_leading_padding_zeroes_in_precision_mode),</span>
          max_trailing_padding_zeroes_in_precision_mode_(
<span class="line-modified">!                                                        max_trailing_padding_zeroes_in_precision_mode) {</span>
<span class="line-modified">!             // When &#39;trailing zero after the point&#39; is set, then &#39;trailing point&#39;</span>
<span class="line-modified">!             // must be set too.</span>
<span class="line-modified">!             ASSERT(((flags &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) ||</span>
<span class="line-modified">!                    !((flags &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0));</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Returns a converter following the EcmaScript specification.</span>
<span class="line-modified">!         WTF_EXPORT_PRIVATE static const DoubleToStringConverter&amp; EcmaScriptConverter();</span>
  
<span class="line-modified">!         // Computes the shortest string of digits that correctly represent the input</span>
<span class="line-modified">!         // number. Depending on decimal_in_shortest_low and decimal_in_shortest_high</span>
<span class="line-modified">!         // (see constructor) it then either returns a decimal representation, or an</span>
<span class="line-modified">!         // exponential representation.</span>
<span class="line-modified">!         // Example with decimal_in_shortest_low = -6,</span>
<span class="line-modified">!         //              decimal_in_shortest_high = 21,</span>
<span class="line-modified">!         //              EMIT_POSITIVE_EXPONENT_SIGN activated, and</span>
<span class="line-modified">!         //              EMIT_TRAILING_DECIMAL_POINT deactived:</span>
<span class="line-modified">!         //   ToShortest(0.000001)  -&gt; &quot;0.000001&quot;</span>
<span class="line-modified">!         //   ToShortest(0.0000001) -&gt; &quot;1e-7&quot;</span>
<span class="line-modified">!         //   ToShortest(111111111111111111111.0)  -&gt; &quot;111111111111111110000&quot;</span>
<span class="line-modified">!         //   ToShortest(100000000000000000000.0)  -&gt; &quot;100000000000000000000&quot;</span>
<span class="line-modified">!         //   ToShortest(1111111111111111111111.0) -&gt; &quot;1.1111111111111111e+21&quot;</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Note: the conversion may round the output if the returned string</span>
<span class="line-modified">!         // is accurate enough to uniquely identify the input-number.</span>
<span class="line-modified">!         // For example the most precise representation of the double 9e59 equals</span>
<span class="line-modified">!         // &quot;899999999999999918767229449717619953810131273674690656206848&quot;, but</span>
<span class="line-modified">!         // the converter will return the shorter (but still correct) &quot;9e59&quot;.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!         // except when the input value is special and no infinity_symbol or</span>
<span class="line-modified">!         // nan_symbol has been given to the constructor.</span>
    bool ToShortest(double value, StringBuilder* result_builder) const {
      return ToShortestIeeeNumber(value, result_builder, SHORTEST);
    }
  
    // Same as ToShortest, but for single-precision floats.
    bool ToShortestSingle(float value, StringBuilder* result_builder) const {
      return ToShortestIeeeNumber(value, result_builder, SHORTEST_SINGLE);
    }
  
  
<span class="line-modified">!         // Computes a decimal representation with a fixed number of digits after the</span>
<span class="line-modified">!         // decimal point. The last emitted digit is rounded.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Examples:</span>
<span class="line-modified">!         //   ToFixed(3.12, 1) -&gt; &quot;3.1&quot;</span>
<span class="line-modified">!         //   ToFixed(3.1415, 3) -&gt; &quot;3.142&quot;</span>
<span class="line-modified">!         //   ToFixed(1234.56789, 4) -&gt; &quot;1234.5679&quot;</span>
<span class="line-modified">!         //   ToFixed(1.23, 5) -&gt; &quot;1.23000&quot;</span>
<span class="line-modified">!         //   ToFixed(0.1, 4) -&gt; &quot;0.1000&quot;</span>
<span class="line-modified">!         //   ToFixed(1e30, 2) -&gt; &quot;1000000000000000019884624838656.00&quot;</span>
<span class="line-modified">!         //   ToFixed(0.1, 30) -&gt; &quot;0.100000000000000005551115123126&quot;</span>
<span class="line-modified">!         //   ToFixed(0.1, 17) -&gt; &quot;0.10000000000000001&quot;</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // If requested_digits equals 0, then the tail of the result depends on</span>
<span class="line-modified">!         // the EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!         // Examples, for requested_digits == 0,</span>
<span class="line-modified">!         //   let EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT be</span>
<span class="line-modified">!         //    - false and false: then 123.45 -&gt; 123</span>
<span class="line-modified">!         //                             0.678 -&gt; 1</span>
<span class="line-modified">!         //    - true and false: then 123.45 -&gt; 123.</span>
<span class="line-modified">!         //                            0.678 -&gt; 1.</span>
<span class="line-modified">!         //    - true and true: then 123.45 -&gt; 123.0</span>
<span class="line-modified">!         //                           0.678 -&gt; 1.0</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!         // except for the following cases:</span>
<span class="line-modified">!         //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!         //     been provided to the constructor,</span>
<span class="line-modified">!         //   - &#39;value&#39; &gt; 10^kMaxFixedDigitsBeforePoint, or</span>
<span class="line-modified">!         //   - &#39;requested_digits&#39; &gt; kMaxFixedDigitsAfterPoint.</span>
<span class="line-modified">!         // The last two conditions imply that the result will never contain more than</span>
<span class="line-modified">!         // 1 + kMaxFixedDigitsBeforePoint + 1 + kMaxFixedDigitsAfterPoint characters</span>
<span class="line-modified">!         // (one additional character for the sign, and one for the decimal point).</span>
<span class="line-modified">!         bool ToFixed(double value,</span>
<span class="line-modified">!                      int requested_digits,</span>
<span class="line-modified">!                      StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!         // Computes a representation in exponential format with requested_digits</span>
<span class="line-modified">!         // after the decimal point. The last emitted digit is rounded.</span>
<span class="line-modified">!         // If requested_digits equals -1, then the shortest exponential representation</span>
<span class="line-modified">!         // is computed.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Examples with EMIT_POSITIVE_EXPONENT_SIGN deactivated, and</span>
<span class="line-modified">!         //               exponent_character set to &#39;e&#39;.</span>
<span class="line-modified">!         //   ToExponential(3.12, 1) -&gt; &quot;3.1e0&quot;</span>
<span class="line-modified">!         //   ToExponential(5.0, 3) -&gt; &quot;5.000e0&quot;</span>
<span class="line-modified">!         //   ToExponential(0.001, 2) -&gt; &quot;1.00e-3&quot;</span>
<span class="line-modified">!         //   ToExponential(3.1415, -1) -&gt; &quot;3.1415e0&quot;</span>
<span class="line-modified">!         //   ToExponential(3.1415, 4) -&gt; &quot;3.1415e0&quot;</span>
<span class="line-modified">!         //   ToExponential(3.1415, 3) -&gt; &quot;3.142e0&quot;</span>
<span class="line-modified">!         //   ToExponential(123456789000000, 3) -&gt; &quot;1.235e14&quot;</span>
<span class="line-modified">!         //   ToExponential(1000000000000000019884624838656.0, -1) -&gt; &quot;1e30&quot;</span>
<span class="line-modified">!         //   ToExponential(1000000000000000019884624838656.0, 32) -&gt;</span>
<span class="line-modified">!         //                     &quot;1.00000000000000001988462483865600e30&quot;</span>
<span class="line-modified">!         //   ToExponential(1234, 0) -&gt; &quot;1e3&quot;</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!         // except for the following cases:</span>
<span class="line-modified">!         //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!         //     been provided to the constructor,</span>
<span class="line-modified">!         //   - &#39;requested_digits&#39; &gt; kMaxExponentialDigits.</span>
<span class="line-modified">!         // The last condition implies that the result will never contain more than</span>
<span class="line-modified">!         // kMaxExponentialDigits + 8 characters (the sign, the digit before the</span>
<span class="line-modified">!         // decimal point, the decimal point, the exponent character, the</span>
<span class="line-modified">!         // exponent&#39;s sign, and at most 3 exponent digits).</span>
<span class="line-modified">!         WTF_EXPORT_PRIVATE bool ToExponential(double value,</span>
<span class="line-modified">!                            int requested_digits,</span>
<span class="line-modified">!                            StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!         // Computes &#39;precision&#39; leading digits of the given &#39;value&#39; and returns them</span>
<span class="line-modified">!         // either in exponential or decimal format, depending on</span>
<span class="line-modified">!         // max_{leading|trailing}_padding_zeroes_in_precision_mode (given to the</span>
<span class="line-modified">!         // constructor).</span>
<span class="line-modified">!         // The last computed digit is rounded.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Example with max_leading_padding_zeroes_in_precision_mode = 6.</span>
<span class="line-modified">!         //   ToPrecision(0.0000012345, 2) -&gt; &quot;0.0000012&quot;</span>
<span class="line-modified">!         //   ToPrecision(0.00000012345, 2) -&gt; &quot;1.2e-7&quot;</span>
<span class="line-modified">!         // Similarily the converter may add up to</span>
<span class="line-modified">!         // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid</span>
<span class="line-modified">!         // returning an exponential representation. A zero added by the</span>
<span class="line-modified">!         // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.</span>
<span class="line-modified">!         // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;230&quot;</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;230.&quot;  with EMIT_TRAILING_DECIMAL_POINT.</span>
<span class="line-modified">!         //   ToPrecision(230.0, 2) -&gt; &quot;2.3e2&quot; with EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!         // Examples for max_trailing_padding_zeroes_in_precision_mode = 3, and no</span>
<span class="line-modified">!         //    EMIT_TRAILING_ZERO_AFTER_POINT:</span>
<span class="line-modified">!         //   ToPrecision(123450.0, 6) -&gt; &quot;123450&quot;</span>
<span class="line-modified">!         //   ToPrecision(123450.0, 5) -&gt; &quot;123450&quot;</span>
<span class="line-modified">!         //   ToPrecision(123450.0, 4) -&gt; &quot;123500&quot;</span>
<span class="line-modified">!         //   ToPrecision(123450.0, 3) -&gt; &quot;123000&quot;</span>
<span class="line-modified">!         //   ToPrecision(123450.0, 2) -&gt; &quot;1.2e5&quot;</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!         // except for the following cases:</span>
<span class="line-modified">!         //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!         //     been provided to the constructor,</span>
<span class="line-modified">!         //   - precision &lt; kMinPericisionDigits</span>
<span class="line-modified">!         //   - precision &gt; kMaxPrecisionDigits</span>
<span class="line-modified">!         // The last condition implies that the result will never contain more than</span>
<span class="line-modified">!         // kMaxPrecisionDigits + 7 characters (the sign, the decimal point, the</span>
<span class="line-modified">!         // exponent character, the exponent&#39;s sign, and at most 3 exponent digits).</span>
<span class="line-modified">!         bool ToPrecision(double value,</span>
<span class="line-modified">!                          int precision,</span>
<span class="line-modified">!                          StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!         enum DtoaMode {</span>
<span class="line-modified">!             // Produce the shortest correct representation.</span>
<span class="line-modified">!             // For example the output of 0.299999999999999988897 is (the less accurate</span>
<span class="line-modified">!             // but correct) 0.3.</span>
<span class="line-modified">!             SHORTEST,</span>
      // Same as SHORTEST, but for single-precision floats.
      SHORTEST_SINGLE,
<span class="line-modified">!             // Produce a fixed number of digits after the decimal point.</span>
<span class="line-modified">!             // For instance fixed(0.1, 4) becomes 0.1000</span>
<span class="line-modified">!             // If the input number is big, the output will be big.</span>
<span class="line-modified">!             FIXED,</span>
<span class="line-modified">!             // Fixed number of digits (independent of the decimal point).</span>
<span class="line-modified">!             PRECISION</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         // The maximal number of digits that are needed to emit a double in base 10.</span>
<span class="line-modified">!         // A higher precision can be achieved by using more digits, but the shortest</span>
<span class="line-modified">!         // accurate representation of any double will never use more digits than</span>
<span class="line-modified">!         // kBase10MaximalLength.</span>
<span class="line-modified">!         // Note that DoubleToAscii null-terminates its input. So the given buffer</span>
<span class="line-modified">!         // should be at least kBase10MaximalLength + 1 characters long.</span>
<span class="line-modified">!         static const int kBase10MaximalLength = 17;</span>
  
    // Converts the given double &#39;v&#39; to digit characters. &#39;v&#39; must not be NaN,
    // +Infinity, or -Infinity. In SHORTEST_SINGLE-mode this restriction also
    // applies to &#39;v&#39; after it has been casted to a single-precision float. That
    // is, in this mode static_cast&lt;float&gt;(v) must not be NaN, +Infinity or
    // -Infinity.
    //
<span class="line-modified">!         // The result should be interpreted as buffer * 10^(point-length).</span>
<span class="line-modified">!         //</span>
    // The digits are written to the buffer in the platform&#39;s charset, which is
    // often UTF-8 (with ASCII-range digits) but may be another charset, such
    // as EBCDIC.
    //
<span class="line-modified">!         // The output depends on the given mode:</span>
<span class="line-modified">!         //  - SHORTEST: produce the least amount of digits for which the internal</span>
<span class="line-modified">!         //   identity requirement is still satisfied. If the digits are printed</span>
<span class="line-modified">!         //   (together with the correct exponent) then reading this number will give</span>
<span class="line-modified">!         //   &#39;v&#39; again. The buffer will choose the representation that is closest to</span>
<span class="line-modified">!         //   &#39;v&#39;. If there are two at the same distance, than the one farther away</span>
<span class="line-modified">!         //   from 0 is chosen (halfway cases - ending with 5 - are rounded up).</span>
<span class="line-modified">!         //   In this mode the &#39;requested_digits&#39; parameter is ignored.</span>
    //  - SHORTEST_SINGLE: same as SHORTEST but with single-precision.
<span class="line-modified">!         //  - FIXED: produces digits necessary to print a given number with</span>
<span class="line-modified">!         //   &#39;requested_digits&#39; digits after the decimal point. The produced digits</span>
<span class="line-modified">!         //   might be too short in which case the caller has to fill the remainder</span>
<span class="line-modified">!         //   with &#39;0&#39;s.</span>
<span class="line-modified">!         //   Example: toFixed(0.001, 5) is allowed to return buffer=&quot;1&quot;, point=-2.</span>
<span class="line-modified">!         //   Halfway cases are rounded towards +/-Infinity (away from 0). The call</span>
<span class="line-modified">!         //   toFixed(0.15, 2) thus returns buffer=&quot;2&quot;, point=0.</span>
<span class="line-modified">!         //   The returned buffer may contain digits that would be truncated from the</span>
<span class="line-modified">!         //   shortest representation of the input.</span>
<span class="line-modified">!         //  - PRECISION: produces &#39;requested_digits&#39; where the first digit is not &#39;0&#39;.</span>
<span class="line-modified">!         //   Even though the length of produced digits usually equals</span>
<span class="line-modified">!         //   &#39;requested_digits&#39;, the function is allowed to return fewer digits, in</span>
<span class="line-modified">!         //   which case the caller has to fill the missing digits with &#39;0&#39;s.</span>
<span class="line-modified">!         //   Halfway cases are again rounded away from 0.</span>
<span class="line-modified">!         // DoubleToAscii expects the given buffer to be big enough to hold all</span>
<span class="line-modified">!         // digits and a terminating null-character. In SHORTEST-mode it expects a</span>
<span class="line-modified">!         // buffer of at least kBase10MaximalLength + 1. In all other modes the</span>
    // requested_digits parameter and the padding-zeroes limit the size of the
    // output. Don&#39;t forget the decimal point, the exponent character and the
    // terminating null-character when computing the maximal output size.
    // The given length is only used in debug mode to ensure the buffer is big
    // enough.
<span class="line-modified">!         static void DoubleToAscii(double v,</span>
<span class="line-modified">!                                   DtoaMode mode,</span>
<span class="line-modified">!                                   int requested_digits,</span>
<span class="line-modified">!                                   char* buffer,</span>
<span class="line-modified">!                                   int buffer_length,</span>
<span class="line-modified">!                                   bool* sign,</span>
<span class="line-modified">!                                   int* length,</span>
<span class="line-modified">!                                   int* point);</span>
  
<span class="line-modified">!     private:</span>
    // Implementation for ToShortest and ToShortestSingle.
    bool ToShortestIeeeNumber(double value,
                              StringBuilder* result_builder,
                              DtoaMode mode) const;
  
<span class="line-modified">!         // If the value is a special value (NaN or Infinity) constructs the</span>
<span class="line-modified">!         // corresponding string using the configured infinity/nan-symbol.</span>
<span class="line-modified">!         // If either of them is NULL or the value is not special then the</span>
<span class="line-modified">!         // function returns false.</span>
<span class="line-modified">!         bool HandleSpecialValues(double value, StringBuilder* result_builder) const;</span>
<span class="line-modified">!         // Constructs an exponential representation (i.e. 1.234e56).</span>
<span class="line-modified">!         // The given exponent assumes a decimal point after the first decimal digit.</span>
<span class="line-modified">!         void CreateExponentialRepresentation(const char* decimal_digits,</span>
<span class="line-modified">!                                              int length,</span>
<span class="line-modified">!                                              int exponent,</span>
<span class="line-modified">!                                              StringBuilder* result_builder) const;</span>
<span class="line-modified">!         // Creates a decimal representation (i.e 1234.5678).</span>
<span class="line-modified">!         void CreateDecimalRepresentation(const char* decimal_digits,</span>
<span class="line-modified">!                                          int length,</span>
<span class="line-modified">!                                          int decimal_point,</span>
<span class="line-modified">!                                          int digits_after_point,</span>
<span class="line-modified">!                                          StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!         const int flags_;</span>
<span class="line-modified">!         const char* const infinity_symbol_;</span>
<span class="line-modified">!         const char* const nan_symbol_;</span>
<span class="line-modified">!         const char exponent_character_;</span>
<span class="line-modified">!         const int decimal_in_shortest_low_;</span>
<span class="line-modified">!         const int decimal_in_shortest_high_;</span>
<span class="line-modified">!         const int max_leading_padding_zeroes_in_precision_mode_;</span>
<span class="line-modified">!         const int max_trailing_padding_zeroes_in_precision_mode_;</span>
  
    DC_DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);
  };
  
  
  class StringToDoubleConverter {
<span class="line-modified">!     public:</span>
<span class="line-modified">!         // Performs the conversion.</span>
<span class="line-modified">!         // The output parameter &#39;processed_characters_count&#39; is set to the number</span>
<span class="line-modified">!         // of characters that have been processed to read the number.</span>
    WTF_EXPORT_PRIVATE static double StringToDouble(const char* buffer,
                                                    size_t length,
                                                    size_t* processed_characters_count);
  
    // Same as StringToDouble above but for 16 bit characters.
<span class="line-new-header">--- 32,365 ---</span>
  
  namespace WTF {
  namespace double_conversion {
  
  class DoubleToStringConverter {
<span class="line-modified">!  public:</span>
<span class="line-modified">!   // When calling ToFixed with a double &gt; 10^kMaxFixedDigitsBeforePoint</span>
<span class="line-modified">!   // or a requested_digits parameter &gt; kMaxFixedDigitsAfterPoint then the</span>
<span class="line-modified">!   // function returns false.</span>
<span class="line-modified">!   static const int kMaxFixedDigitsBeforePoint = 60;</span>
<span class="line-modified">!   static const int kMaxFixedDigitsAfterPoint = 60;</span>
  
<span class="line-modified">!   // When calling ToExponential with a requested_digits</span>
<span class="line-modified">!   // parameter &gt; kMaxExponentialDigits then the function returns false.</span>
<span class="line-modified">!   static const int kMaxExponentialDigits = 120;</span>
  
<span class="line-modified">!   // When calling ToPrecision with a requested_digits</span>
<span class="line-modified">!   // parameter &lt; kMinPrecisionDigits or requested_digits &gt; kMaxPrecisionDigits</span>
<span class="line-modified">!   // then the function returns false.</span>
<span class="line-modified">!   static const int kMinPrecisionDigits = 1;</span>
<span class="line-modified">!   static const int kMaxPrecisionDigits = 120;</span>
  
<span class="line-modified">!   enum Flags {</span>
<span class="line-modified">!     NO_FLAGS = 0,</span>
<span class="line-modified">!     EMIT_POSITIVE_EXPONENT_SIGN = 1,</span>
<span class="line-modified">!     EMIT_TRAILING_DECIMAL_POINT = 2,</span>
<span class="line-modified">!     EMIT_TRAILING_ZERO_AFTER_POINT = 4,</span>
<span class="line-modified">!     UNIQUE_ZERO = 8</span>
<span class="line-modified">!   };</span>
  
<span class="line-modified">!   // Flags should be a bit-or combination of the possible Flags-enum.</span>
<span class="line-modified">!   //  - NO_FLAGS: no special flags.</span>
<span class="line-modified">!   //  - EMIT_POSITIVE_EXPONENT_SIGN: when the number is converted into exponent</span>
<span class="line-modified">!   //    form, emits a &#39;+&#39; for positive exponents. Example: 1.2e+2.</span>
<span class="line-modified">!   //  - EMIT_TRAILING_DECIMAL_POINT: when the input number is an integer and is</span>
<span class="line-modified">!   //    converted into decimal format then a trailing decimal point is appended.</span>
<span class="line-modified">!   //    Example: 2345.0 is converted to &quot;2345.&quot;.</span>
<span class="line-modified">!   //  - EMIT_TRAILING_ZERO_AFTER_POINT: in addition to a trailing decimal point</span>
<span class="line-modified">!   //    emits a trailing &#39;0&#39;-character. This flag requires the</span>
<span class="line-modified">!   //    EXMIT_TRAILING_DECIMAL_POINT flag.</span>
<span class="line-modified">!   //    Example: 2345.0 is converted to &quot;2345.0&quot;.</span>
<span class="line-modified">!   //  - UNIQUE_ZERO: &quot;-0.0&quot; is converted to &quot;0.0&quot;.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Infinity symbol and nan_symbol provide the string representation for these</span>
<span class="line-modified">!   // special values. If the string is NULL and the special value is encountered</span>
<span class="line-modified">!   // then the conversion functions return false.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // The exponent_character is used in exponential representations. It is</span>
<span class="line-modified">!   // usually &#39;e&#39; or &#39;E&#39;.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // When converting to the shortest representation the converter will</span>
<span class="line-modified">!   // represent input numbers in decimal format if they are in the interval</span>
<span class="line-modified">!   // [10^decimal_in_shortest_low; 10^decimal_in_shortest_high[</span>
<span class="line-modified">!   //    (lower boundary included, greater boundary excluded).</span>
<span class="line-modified">!   // Example: with decimal_in_shortest_low = -6 and</span>
<span class="line-modified">!   //               decimal_in_shortest_high = 21:</span>
<span class="line-modified">!   //   ToShortest(0.000001)  -&gt; &quot;0.000001&quot;</span>
<span class="line-modified">!   //   ToShortest(0.0000001) -&gt; &quot;1e-7&quot;</span>
<span class="line-modified">!   //   ToShortest(111111111111111111111.0)  -&gt; &quot;111111111111111110000&quot;</span>
<span class="line-modified">!   //   ToShortest(100000000000000000000.0)  -&gt; &quot;100000000000000000000&quot;</span>
<span class="line-modified">!   //   ToShortest(1111111111111111111111.0) -&gt; &quot;1.1111111111111111e+21&quot;</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // When converting to precision mode the converter may add</span>
<span class="line-modified">!   // max_leading_padding_zeroes before returning the number in exponential</span>
<span class="line-modified">!   // format.</span>
<span class="line-modified">!   // Example with max_leading_padding_zeroes_in_precision_mode = 6.</span>
<span class="line-modified">!   //   ToPrecision(0.0000012345, 2) -&gt; &quot;0.0000012&quot;</span>
<span class="line-modified">!   //   ToPrecision(0.00000012345, 2) -&gt; &quot;1.2e-7&quot;</span>
<span class="line-modified">!   // Similarily the converter may add up to</span>
<span class="line-modified">!   // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid</span>
<span class="line-modified">!   // returning an exponential representation. A zero added by the</span>
<span class="line-modified">!   // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.</span>
<span class="line-modified">!   // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;230&quot;</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;230.&quot;  with EMIT_TRAILING_DECIMAL_POINT.</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;2.3e2&quot; with EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!   DoubleToStringConverter(int flags,</span>
<span class="line-modified">!                           const char* infinity_symbol,</span>
<span class="line-modified">!                           const char* nan_symbol,</span>
<span class="line-modified">!                           char exponent_character,</span>
<span class="line-modified">!                           int decimal_in_shortest_low,</span>
<span class="line-modified">!                           int decimal_in_shortest_high,</span>
<span class="line-modified">!                           int max_leading_padding_zeroes_in_precision_mode,</span>
<span class="line-modified">!                           int max_trailing_padding_zeroes_in_precision_mode)</span>
<span class="line-modified">!       : flags_(flags),</span>
          infinity_symbol_(infinity_symbol),
          nan_symbol_(nan_symbol),
          exponent_character_(exponent_character),
          decimal_in_shortest_low_(decimal_in_shortest_low),
          decimal_in_shortest_high_(decimal_in_shortest_high),
          max_leading_padding_zeroes_in_precision_mode_(
<span class="line-modified">!             max_leading_padding_zeroes_in_precision_mode),</span>
          max_trailing_padding_zeroes_in_precision_mode_(
<span class="line-modified">!             max_trailing_padding_zeroes_in_precision_mode) {</span>
<span class="line-modified">!     // When &#39;trailing zero after the point&#39; is set, then &#39;trailing point&#39;</span>
<span class="line-modified">!     // must be set too.</span>
<span class="line-modified">!     ASSERT(((flags &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) ||</span>
<span class="line-modified">!         !((flags &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0));</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Returns a converter following the EcmaScript specification.</span>
<span class="line-modified">!   WTF_EXPORT_PRIVATE static const DoubleToStringConverter&amp; EcmaScriptConverter();</span>
  
<span class="line-modified">!   // Computes the shortest string of digits that correctly represent the input</span>
<span class="line-modified">!   // number. Depending on decimal_in_shortest_low and decimal_in_shortest_high</span>
<span class="line-modified">!   // (see constructor) it then either returns a decimal representation, or an</span>
<span class="line-modified">!   // exponential representation.</span>
<span class="line-modified">!   // Example with decimal_in_shortest_low = -6,</span>
<span class="line-modified">!   //              decimal_in_shortest_high = 21,</span>
<span class="line-modified">!   //              EMIT_POSITIVE_EXPONENT_SIGN activated, and</span>
<span class="line-modified">!   //              EMIT_TRAILING_DECIMAL_POINT deactived:</span>
<span class="line-modified">!   //   ToShortest(0.000001)  -&gt; &quot;0.000001&quot;</span>
<span class="line-modified">!   //   ToShortest(0.0000001) -&gt; &quot;1e-7&quot;</span>
<span class="line-modified">!   //   ToShortest(111111111111111111111.0)  -&gt; &quot;111111111111111110000&quot;</span>
<span class="line-modified">!   //   ToShortest(100000000000000000000.0)  -&gt; &quot;100000000000000000000&quot;</span>
<span class="line-modified">!   //   ToShortest(1111111111111111111111.0) -&gt; &quot;1.1111111111111111e+21&quot;</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Note: the conversion may round the output if the returned string</span>
<span class="line-modified">!   // is accurate enough to uniquely identify the input-number.</span>
<span class="line-modified">!   // For example the most precise representation of the double 9e59 equals</span>
<span class="line-modified">!   // &quot;899999999999999918767229449717619953810131273674690656206848&quot;, but</span>
<span class="line-modified">!   // the converter will return the shorter (but still correct) &quot;9e59&quot;.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!   // except when the input value is special and no infinity_symbol or</span>
<span class="line-modified">!   // nan_symbol has been given to the constructor.</span>
    bool ToShortest(double value, StringBuilder* result_builder) const {
      return ToShortestIeeeNumber(value, result_builder, SHORTEST);
    }
  
    // Same as ToShortest, but for single-precision floats.
    bool ToShortestSingle(float value, StringBuilder* result_builder) const {
      return ToShortestIeeeNumber(value, result_builder, SHORTEST_SINGLE);
    }
  
  
<span class="line-modified">!   // Computes a decimal representation with a fixed number of digits after the</span>
<span class="line-modified">!   // decimal point. The last emitted digit is rounded.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Examples:</span>
<span class="line-modified">!   //   ToFixed(3.12, 1) -&gt; &quot;3.1&quot;</span>
<span class="line-modified">!   //   ToFixed(3.1415, 3) -&gt; &quot;3.142&quot;</span>
<span class="line-modified">!   //   ToFixed(1234.56789, 4) -&gt; &quot;1234.5679&quot;</span>
<span class="line-modified">!   //   ToFixed(1.23, 5) -&gt; &quot;1.23000&quot;</span>
<span class="line-modified">!   //   ToFixed(0.1, 4) -&gt; &quot;0.1000&quot;</span>
<span class="line-modified">!   //   ToFixed(1e30, 2) -&gt; &quot;1000000000000000019884624838656.00&quot;</span>
<span class="line-modified">!   //   ToFixed(0.1, 30) -&gt; &quot;0.100000000000000005551115123126&quot;</span>
<span class="line-modified">!   //   ToFixed(0.1, 17) -&gt; &quot;0.10000000000000001&quot;</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // If requested_digits equals 0, then the tail of the result depends on</span>
<span class="line-modified">!   // the EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!   // Examples, for requested_digits == 0,</span>
<span class="line-modified">!   //   let EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT be</span>
<span class="line-modified">!   //    - false and false: then 123.45 -&gt; 123</span>
<span class="line-modified">!   //                             0.678 -&gt; 1</span>
<span class="line-modified">!   //    - true and false: then 123.45 -&gt; 123.</span>
<span class="line-modified">!   //                            0.678 -&gt; 1.</span>
<span class="line-modified">!   //    - true and true: then 123.45 -&gt; 123.0</span>
<span class="line-modified">!   //                           0.678 -&gt; 1.0</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!   // except for the following cases:</span>
<span class="line-modified">!   //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!   //     been provided to the constructor,</span>
<span class="line-modified">!   //   - &#39;value&#39; &gt; 10^kMaxFixedDigitsBeforePoint, or</span>
<span class="line-modified">!   //   - &#39;requested_digits&#39; &gt; kMaxFixedDigitsAfterPoint.</span>
<span class="line-modified">!   // The last two conditions imply that the result will never contain more than</span>
<span class="line-modified">!   // 1 + kMaxFixedDigitsBeforePoint + 1 + kMaxFixedDigitsAfterPoint characters</span>
<span class="line-modified">!   // (one additional character for the sign, and one for the decimal point).</span>
<span class="line-modified">!   bool ToFixed(double value,</span>
<span class="line-modified">!                int requested_digits,</span>
<span class="line-modified">!                StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!   // Computes a representation in exponential format with requested_digits</span>
<span class="line-modified">!   // after the decimal point. The last emitted digit is rounded.</span>
<span class="line-modified">!   // If requested_digits equals -1, then the shortest exponential representation</span>
<span class="line-modified">!   // is computed.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Examples with EMIT_POSITIVE_EXPONENT_SIGN deactivated, and</span>
<span class="line-modified">!   //               exponent_character set to &#39;e&#39;.</span>
<span class="line-modified">!   //   ToExponential(3.12, 1) -&gt; &quot;3.1e0&quot;</span>
<span class="line-modified">!   //   ToExponential(5.0, 3) -&gt; &quot;5.000e0&quot;</span>
<span class="line-modified">!   //   ToExponential(0.001, 2) -&gt; &quot;1.00e-3&quot;</span>
<span class="line-modified">!   //   ToExponential(3.1415, -1) -&gt; &quot;3.1415e0&quot;</span>
<span class="line-modified">!   //   ToExponential(3.1415, 4) -&gt; &quot;3.1415e0&quot;</span>
<span class="line-modified">!   //   ToExponential(3.1415, 3) -&gt; &quot;3.142e0&quot;</span>
<span class="line-modified">!   //   ToExponential(123456789000000, 3) -&gt; &quot;1.235e14&quot;</span>
<span class="line-modified">!   //   ToExponential(1000000000000000019884624838656.0, -1) -&gt; &quot;1e30&quot;</span>
<span class="line-modified">!   //   ToExponential(1000000000000000019884624838656.0, 32) -&gt;</span>
<span class="line-modified">!   //                     &quot;1.00000000000000001988462483865600e30&quot;</span>
<span class="line-modified">!   //   ToExponential(1234, 0) -&gt; &quot;1e3&quot;</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!   // except for the following cases:</span>
<span class="line-modified">!   //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!   //     been provided to the constructor,</span>
<span class="line-modified">!   //   - &#39;requested_digits&#39; &gt; kMaxExponentialDigits.</span>
<span class="line-modified">!   // The last condition implies that the result will never contain more than</span>
<span class="line-modified">!   // kMaxExponentialDigits + 8 characters (the sign, the digit before the</span>
<span class="line-modified">!   // decimal point, the decimal point, the exponent character, the</span>
<span class="line-modified">!   // exponent&#39;s sign, and at most 3 exponent digits).</span>
<span class="line-modified">!   WTF_EXPORT_PRIVATE bool ToExponential(double value,</span>
<span class="line-modified">!                                         int requested_digits,</span>
<span class="line-modified">!                                         StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!   // Computes &#39;precision&#39; leading digits of the given &#39;value&#39; and returns them</span>
<span class="line-modified">!   // either in exponential or decimal format, depending on</span>
<span class="line-modified">!   // max_{leading|trailing}_padding_zeroes_in_precision_mode (given to the</span>
<span class="line-modified">!   // constructor).</span>
<span class="line-modified">!   // The last computed digit is rounded.</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Example with max_leading_padding_zeroes_in_precision_mode = 6.</span>
<span class="line-modified">!   //   ToPrecision(0.0000012345, 2) -&gt; &quot;0.0000012&quot;</span>
<span class="line-modified">!   //   ToPrecision(0.00000012345, 2) -&gt; &quot;1.2e-7&quot;</span>
<span class="line-modified">!   // Similarily the converter may add up to</span>
<span class="line-modified">!   // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid</span>
<span class="line-modified">!   // returning an exponential representation. A zero added by the</span>
<span class="line-modified">!   // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.</span>
<span class="line-modified">!   // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;230&quot;</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;230.&quot;  with EMIT_TRAILING_DECIMAL_POINT.</span>
<span class="line-modified">!   //   ToPrecision(230.0, 2) -&gt; &quot;2.3e2&quot; with EMIT_TRAILING_ZERO_AFTER_POINT.</span>
<span class="line-modified">!   // Examples for max_trailing_padding_zeroes_in_precision_mode = 3, and no</span>
<span class="line-modified">!   //    EMIT_TRAILING_ZERO_AFTER_POINT:</span>
<span class="line-modified">!   //   ToPrecision(123450.0, 6) -&gt; &quot;123450&quot;</span>
<span class="line-modified">!   //   ToPrecision(123450.0, 5) -&gt; &quot;123450&quot;</span>
<span class="line-modified">!   //   ToPrecision(123450.0, 4) -&gt; &quot;123500&quot;</span>
<span class="line-modified">!   //   ToPrecision(123450.0, 3) -&gt; &quot;123000&quot;</span>
<span class="line-modified">!   //   ToPrecision(123450.0, 2) -&gt; &quot;1.2e5&quot;</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Returns true if the conversion succeeds. The conversion always succeeds</span>
<span class="line-modified">!   // except for the following cases:</span>
<span class="line-modified">!   //   - the input value is special and no infinity_symbol or nan_symbol has</span>
<span class="line-modified">!   //     been provided to the constructor,</span>
<span class="line-modified">!   //   - precision &lt; kMinPericisionDigits</span>
<span class="line-modified">!   //   - precision &gt; kMaxPrecisionDigits</span>
<span class="line-modified">!   // The last condition implies that the result will never contain more than</span>
<span class="line-modified">!   // kMaxPrecisionDigits + 7 characters (the sign, the decimal point, the</span>
<span class="line-modified">!   // exponent character, the exponent&#39;s sign, and at most 3 exponent digits).</span>
<span class="line-modified">!   bool ToPrecision(double value,</span>
<span class="line-modified">!                    int precision,</span>
<span class="line-modified">!                    StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!   enum DtoaMode {</span>
<span class="line-modified">!     // Produce the shortest correct representation.</span>
<span class="line-modified">!     // For example the output of 0.299999999999999988897 is (the less accurate</span>
<span class="line-modified">!     // but correct) 0.3.</span>
<span class="line-modified">!     SHORTEST,</span>
      // Same as SHORTEST, but for single-precision floats.
      SHORTEST_SINGLE,
<span class="line-modified">!     // Produce a fixed number of digits after the decimal point.</span>
<span class="line-modified">!     // For instance fixed(0.1, 4) becomes 0.1000</span>
<span class="line-modified">!     // If the input number is big, the output will be big.</span>
<span class="line-modified">!     FIXED,</span>
<span class="line-modified">!     // Fixed number of digits (independent of the decimal point).</span>
<span class="line-modified">!     PRECISION</span>
<span class="line-modified">!   };</span>
  
<span class="line-modified">!   // The maximal number of digits that are needed to emit a double in base 10.</span>
<span class="line-modified">!   // A higher precision can be achieved by using more digits, but the shortest</span>
<span class="line-modified">!   // accurate representation of any double will never use more digits than</span>
<span class="line-modified">!   // kBase10MaximalLength.</span>
<span class="line-modified">!   // Note that DoubleToAscii null-terminates its input. So the given buffer</span>
<span class="line-modified">!   // should be at least kBase10MaximalLength + 1 characters long.</span>
<span class="line-modified">!   static const int kBase10MaximalLength = 17;</span>
  
    // Converts the given double &#39;v&#39; to digit characters. &#39;v&#39; must not be NaN,
    // +Infinity, or -Infinity. In SHORTEST_SINGLE-mode this restriction also
    // applies to &#39;v&#39; after it has been casted to a single-precision float. That
    // is, in this mode static_cast&lt;float&gt;(v) must not be NaN, +Infinity or
    // -Infinity.
    //
<span class="line-modified">!   // The result should be interpreted as buffer * 10^(point-length).</span>
<span class="line-modified">!   //</span>
    // The digits are written to the buffer in the platform&#39;s charset, which is
    // often UTF-8 (with ASCII-range digits) but may be another charset, such
    // as EBCDIC.
    //
<span class="line-modified">!   // The output depends on the given mode:</span>
<span class="line-modified">!   //  - SHORTEST: produce the least amount of digits for which the internal</span>
<span class="line-modified">!   //   identity requirement is still satisfied. If the digits are printed</span>
<span class="line-modified">!   //   (together with the correct exponent) then reading this number will give</span>
<span class="line-modified">!   //   &#39;v&#39; again. The buffer will choose the representation that is closest to</span>
<span class="line-modified">!   //   &#39;v&#39;. If there are two at the same distance, than the one farther away</span>
<span class="line-modified">!   //   from 0 is chosen (halfway cases - ending with 5 - are rounded up).</span>
<span class="line-modified">!   //   In this mode the &#39;requested_digits&#39; parameter is ignored.</span>
    //  - SHORTEST_SINGLE: same as SHORTEST but with single-precision.
<span class="line-modified">!   //  - FIXED: produces digits necessary to print a given number with</span>
<span class="line-modified">!   //   &#39;requested_digits&#39; digits after the decimal point. The produced digits</span>
<span class="line-modified">!   //   might be too short in which case the caller has to fill the remainder</span>
<span class="line-modified">!   //   with &#39;0&#39;s.</span>
<span class="line-modified">!   //   Example: toFixed(0.001, 5) is allowed to return buffer=&quot;1&quot;, point=-2.</span>
<span class="line-modified">!   //   Halfway cases are rounded towards +/-Infinity (away from 0). The call</span>
<span class="line-modified">!   //   toFixed(0.15, 2) thus returns buffer=&quot;2&quot;, point=0.</span>
<span class="line-modified">!   //   The returned buffer may contain digits that would be truncated from the</span>
<span class="line-modified">!   //   shortest representation of the input.</span>
<span class="line-modified">!   //  - PRECISION: produces &#39;requested_digits&#39; where the first digit is not &#39;0&#39;.</span>
<span class="line-modified">!   //   Even though the length of produced digits usually equals</span>
<span class="line-modified">!   //   &#39;requested_digits&#39;, the function is allowed to return fewer digits, in</span>
<span class="line-modified">!   //   which case the caller has to fill the missing digits with &#39;0&#39;s.</span>
<span class="line-modified">!   //   Halfway cases are again rounded away from 0.</span>
<span class="line-modified">!   // DoubleToAscii expects the given buffer to be big enough to hold all</span>
<span class="line-modified">!   // digits and a terminating null-character. In SHORTEST-mode it expects a</span>
<span class="line-modified">!   // buffer of at least kBase10MaximalLength + 1. In all other modes the</span>
    // requested_digits parameter and the padding-zeroes limit the size of the
    // output. Don&#39;t forget the decimal point, the exponent character and the
    // terminating null-character when computing the maximal output size.
    // The given length is only used in debug mode to ensure the buffer is big
    // enough.
<span class="line-modified">!   static void DoubleToAscii(double v,</span>
<span class="line-modified">!                             DtoaMode mode,</span>
<span class="line-modified">!                             int requested_digits,</span>
<span class="line-modified">!                             char* buffer,</span>
<span class="line-modified">!                             int buffer_length,</span>
<span class="line-modified">!                             bool* sign,</span>
<span class="line-modified">!                             int* length,</span>
<span class="line-modified">!                             int* point);</span>
  
<span class="line-modified">!  private:</span>
    // Implementation for ToShortest and ToShortestSingle.
    bool ToShortestIeeeNumber(double value,
                              StringBuilder* result_builder,
                              DtoaMode mode) const;
  
<span class="line-modified">!   // If the value is a special value (NaN or Infinity) constructs the</span>
<span class="line-modified">!   // corresponding string using the configured infinity/nan-symbol.</span>
<span class="line-modified">!   // If either of them is NULL or the value is not special then the</span>
<span class="line-modified">!   // function returns false.</span>
<span class="line-modified">!   bool HandleSpecialValues(double value, StringBuilder* result_builder) const;</span>
<span class="line-modified">!   // Constructs an exponential representation (i.e. 1.234e56).</span>
<span class="line-modified">!   // The given exponent assumes a decimal point after the first decimal digit.</span>
<span class="line-modified">!   void CreateExponentialRepresentation(const char* decimal_digits,</span>
<span class="line-modified">!                                        int length,</span>
<span class="line-modified">!                                        int exponent,</span>
<span class="line-modified">!                                        StringBuilder* result_builder) const;</span>
<span class="line-modified">!   // Creates a decimal representation (i.e 1234.5678).</span>
<span class="line-modified">!   void CreateDecimalRepresentation(const char* decimal_digits,</span>
<span class="line-modified">!                                    int length,</span>
<span class="line-modified">!                                    int decimal_point,</span>
<span class="line-modified">!                                    int digits_after_point,</span>
<span class="line-modified">!                                    StringBuilder* result_builder) const;</span>
  
<span class="line-modified">!   const int flags_;</span>
<span class="line-modified">!   const char* const infinity_symbol_;</span>
<span class="line-modified">!   const char* const nan_symbol_;</span>
<span class="line-modified">!   const char exponent_character_;</span>
<span class="line-modified">!   const int decimal_in_shortest_low_;</span>
<span class="line-modified">!   const int decimal_in_shortest_high_;</span>
<span class="line-modified">!   const int max_leading_padding_zeroes_in_precision_mode_;</span>
<span class="line-modified">!   const int max_trailing_padding_zeroes_in_precision_mode_;</span>
  
    DC_DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);
  };
  
  
  class StringToDoubleConverter {
<span class="line-modified">!  public:</span>
<span class="line-modified">!   // Performs the conversion.</span>
<span class="line-modified">!   // The output parameter &#39;processed_characters_count&#39; is set to the number</span>
<span class="line-modified">!   // of characters that have been processed to read the number.</span>
    WTF_EXPORT_PRIVATE static double StringToDouble(const char* buffer,
                                                    size_t length,
                                                    size_t* processed_characters_count);
  
    // Same as StringToDouble above but for 16 bit characters.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,13 ***</span>
    // Same as StringToFloat above but for 16 bit characters.
    WTF_EXPORT_PRIVATE static float StringToFloat(const uc16* buffer,
                                                  size_t length,
                                                  size_t* processed_characters_count);
  
<span class="line-modified">!     private:</span>
    DC_DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);
  };
  
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
  
  #endif  // DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_
<span class="line-new-header">--- 408,13 ---</span>
    // Same as StringToFloat above but for 16 bit characters.
    WTF_EXPORT_PRIVATE static float StringToFloat(const uc16* buffer,
                                                  size_t length,
                                                  size_t* processed_characters_count);
  
<span class="line-modified">!  private:</span>
    DC_DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);
  };
  
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
  
  #endif  // DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_
</pre>
<center><a href="double-conversion.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fast-dtoa.cc.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>