<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  67 #include &quot;XMLNames.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/IsoMallocInlines.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/StdLibExtras.h&gt;
  72 #include &lt;wtf/text/CString.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLElement);
  77 
  78 using namespace HTMLNames;
  79 
  80 Ref&lt;HTMLElement&gt; HTMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  81 {
  82     return adoptRef(*new HTMLElement(tagName, document));
  83 }
  84 
  85 String HTMLElement::nodeName() const
  86 {
<span class="line-modified">  87     // FIXME: Would be nice to have an AtomicString lookup based off uppercase</span>
  88     // ASCII characters that does not have to copy the string on a hit in the hash.
  89     if (document().isHTMLDocument()) {
  90         if (LIKELY(!tagQName().hasPrefix()))
  91             return tagQName().localNameUpper();
  92         return Element::nodeName().convertToASCIIUppercase();
  93     }
  94     return Element::nodeName();
  95 }
  96 
  97 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  98 {
  99     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 100         return CSSValuePlaintext;
 101     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 102     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 103     return CSSValueIsolate;
 104 }
 105 
<span class="line-modified"> 106 unsigned HTMLElement::parseBorderWidthAttribute(const AtomicString&amp; value) const</span>
 107 {
 108     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 109         return optionalBorderWidth.value();
 110 
 111     return hasTagName(tableTag) ? 1 : 0;
 112 }
 113 
<span class="line-modified"> 114 void HTMLElement::applyBorderAttributeToStyle(const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 115 {
 116     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 118 }
 119 
<span class="line-modified"> 120 void HTMLElement::mapLanguageAttributeToLocale(const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 121 {
 122     if (!value.isEmpty()) {
 123         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 124         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 125     } else {
 126         // The empty string means the language is explicitly unknown.
 127         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 128     }
 129 }
 130 
 131 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 132 {
 133     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 134         return true;
 135     return StyledElement::isPresentationAttribute(name);
 136 }
 137 
<span class="line-modified"> 138 static bool isLTROrRTLIgnoringCase(const AtomicString&amp; dirAttributeValue)</span>
 139 {
 140     return equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;);
 141 }
 142 
 143 enum class ContentEditableType {
 144     Inherit,
 145     True,
 146     False,
 147     PlaintextOnly
 148 };
 149 
<span class="line-modified"> 150 static inline ContentEditableType contentEditableType(const AtomicString&amp; value)</span>
 151 {
 152     if (value.isNull())
 153         return ContentEditableType::Inherit;
 154     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
 155         return ContentEditableType::True;
 156     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 157         return ContentEditableType::False;
 158     if (equalLettersIgnoringASCIICase(value, &quot;plaintext-only&quot;))
 159         return ContentEditableType::PlaintextOnly;
 160 
 161     return ContentEditableType::Inherit;
 162 }
 163 
 164 static ContentEditableType contentEditableType(const HTMLElement&amp; element)
 165 {
 166     return contentEditableType(element.attributeWithoutSynchronization(contenteditableAttr));
 167 }
 168 
<span class="line-modified"> 169 void HTMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 170 {
 171     if (name == alignAttr) {
 172         if (equalLettersIgnoringASCIICase(value, &quot;middle&quot;))
 173             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, CSSValueCenter);
 174         else
 175             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, value);
 176     } else if (name == contenteditableAttr) {
 177         CSSValueID userModifyValue = CSSValueReadWrite;
 178         switch (contentEditableType(value)) {
 179         case ContentEditableType::Inherit:
 180             return;
 181         case ContentEditableType::False:
 182             userModifyValue = CSSValueReadOnly;
 183             break;
 184         case ContentEditableType::PlaintextOnly:
 185             userModifyValue = CSSValueReadWritePlaintextOnly;
 186             FALLTHROUGH;
 187         case ContentEditableType::True:
 188             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
 189             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitNbspMode, CSSValueSpace);
</pre>
<hr />
<pre>
 210                 addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
 211             if (!hasTagName(bdiTag) &amp;&amp; !hasTagName(bdoTag) &amp;&amp; !hasTagName(outputTag))
 212                 addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, CSSValueEmbed);
 213         }
 214     } else if (name.matches(XMLNames::langAttr))
 215         mapLanguageAttributeToLocale(value, style);
 216     else if (name == langAttr) {
 217         // xml:lang has a higher priority than lang.
 218         if (!hasAttributeWithoutSynchronization(XMLNames::langAttr))
 219             mapLanguageAttributeToLocale(value, style);
 220     } else
 221         StyledElement::collectStyleForPresentationAttribute(name, value, style);
 222 }
 223 
 224 HTMLElement::EventHandlerNameMap HTMLElement::createEventHandlerNameMap()
 225 {
 226     EventHandlerNameMap map;
 227 
 228     static const QualifiedName* const table[] = {
 229         &amp;onabortAttr.get(),
<span class="line-removed"> 230         &amp;onaccessiblecontextmenuAttr.get(),</span>
<span class="line-removed"> 231         &amp;onaccessibleclickAttr.get(),</span>
<span class="line-removed"> 232         &amp;onaccessibledecrementAttr.get(),</span>
<span class="line-removed"> 233         &amp;onaccessibledismissAttr.get(),</span>
<span class="line-removed"> 234         &amp;onaccessiblefocusAttr.get(),</span>
<span class="line-removed"> 235         &amp;onaccessibleincrementAttr.get(),</span>
<span class="line-removed"> 236         &amp;onaccessiblescrollintoviewAttr.get(),</span>
<span class="line-removed"> 237         &amp;onaccessiblesetvalueAttr.get(),</span>
<span class="line-removed"> 238         &amp;onaccessibleselectAttr.get(),</span>
 239         &amp;onanimationendAttr.get(),
 240         &amp;onanimationiterationAttr.get(),
 241         &amp;onanimationstartAttr.get(),
 242         &amp;onanimationcancelAttr.get(),
 243         &amp;onautocompleteAttr.get(),
 244         &amp;onautocompleteerrorAttr.get(),
 245         &amp;onbeforecopyAttr.get(),
 246         &amp;onbeforecutAttr.get(),
 247         &amp;onbeforeinputAttr.get(),
 248         &amp;onbeforeloadAttr.get(),
 249         &amp;onbeforepasteAttr.get(),
 250         &amp;onblurAttr.get(),
 251         &amp;oncanplayAttr.get(),
 252         &amp;oncanplaythroughAttr.get(),
 253         &amp;onchangeAttr.get(),
 254         &amp;onclickAttr.get(),
 255         &amp;oncontextmenuAttr.get(),
 256         &amp;oncopyAttr.get(),
 257         &amp;oncutAttr.get(),
 258         &amp;ondblclickAttr.get(),
 259         &amp;ondragAttr.get(),
 260         &amp;ondragendAttr.get(),
 261         &amp;ondragenterAttr.get(),
 262         &amp;ondragleaveAttr.get(),
 263         &amp;ondragoverAttr.get(),
 264         &amp;ondragstartAttr.get(),
 265         &amp;ondropAttr.get(),
 266         &amp;ondurationchangeAttr.get(),
 267         &amp;onemptiedAttr.get(),
 268         &amp;onendedAttr.get(),
 269         &amp;onerrorAttr.get(),
 270         &amp;onfocusAttr.get(),
 271         &amp;onfocusinAttr.get(),
 272         &amp;onfocusoutAttr.get(),
 273         &amp;ongesturechangeAttr.get(),
 274         &amp;ongestureendAttr.get(),
 275         &amp;ongesturestartAttr.get(),

 276         &amp;oninputAttr.get(),
 277         &amp;oninvalidAttr.get(),
 278         &amp;onkeydownAttr.get(),
 279         &amp;onkeypressAttr.get(),
 280         &amp;onkeyupAttr.get(),
 281         &amp;onloadAttr.get(),
 282         &amp;onloadeddataAttr.get(),
 283         &amp;onloadedmetadataAttr.get(),
 284         &amp;onloadstartAttr.get(),

 285         &amp;onmousedownAttr.get(),
 286         &amp;onmouseenterAttr.get(),
 287         &amp;onmouseleaveAttr.get(),
 288         &amp;onmousemoveAttr.get(),
 289         &amp;onmouseoutAttr.get(),
 290         &amp;onmouseoverAttr.get(),
 291         &amp;onmouseupAttr.get(),
 292         &amp;onmousewheelAttr.get(),
 293         &amp;onpasteAttr.get(),
 294         &amp;onpauseAttr.get(),
 295         &amp;onplayAttr.get(),
 296         &amp;onplayingAttr.get(),








 297         &amp;onprogressAttr.get(),
 298         &amp;onratechangeAttr.get(),
 299         &amp;onresetAttr.get(),
 300         &amp;onresizeAttr.get(),
 301         &amp;onscrollAttr.get(),
 302         &amp;onsearchAttr.get(),
 303         &amp;onseekedAttr.get(),
 304         &amp;onseekingAttr.get(),
 305         &amp;onselectAttr.get(),
 306         &amp;onselectstartAttr.get(),
 307         &amp;onstalledAttr.get(),
 308         &amp;onsubmitAttr.get(),
 309         &amp;onsuspendAttr.get(),
 310         &amp;ontimeupdateAttr.get(),
 311         &amp;ontoggleAttr.get(),
 312         &amp;ontouchcancelAttr.get(),
 313         &amp;ontouchendAttr.get(),
 314         &amp;ontouchforcechangeAttr.get(),
 315         &amp;ontouchmoveAttr.get(),
 316         &amp;ontouchstartAttr.get(),
</pre>
<hr />
<pre>
 329         &amp;onwebkitkeyerrorAttr.get(),
 330         &amp;onwebkitkeymessageAttr.get(),
 331         &amp;onwebkitmouseforcechangedAttr.get(),
 332         &amp;onwebkitmouseforcedownAttr.get(),
 333         &amp;onwebkitmouseforcewillbeginAttr.get(),
 334         &amp;onwebkitmouseforceupAttr.get(),
 335         &amp;onwebkitneedkeyAttr.get(),
 336         &amp;onwebkitplaybacktargetavailabilitychangedAttr.get(),
 337         &amp;onwebkitpresentationmodechangedAttr.get(),
 338         &amp;onwebkitwillrevealbottomAttr.get(),
 339         &amp;onwebkitwillrevealleftAttr.get(),
 340         &amp;onwebkitwillrevealrightAttr.get(),
 341         &amp;onwebkitwillrevealtopAttr.get(),
 342         &amp;onwheelAttr.get(),
 343     };
 344 
 345     populateEventHandlerNameMap(map, table);
 346 
 347     struct UnusualMapping {
 348         const QualifiedName&amp; attributeName;
<span class="line-modified"> 349         const AtomicString&amp; eventName;</span>
 350     };
 351 
 352     const UnusualMapping unusualPairsTable[] = {
 353         { onwebkitanimationendAttr, eventNames().webkitAnimationEndEvent },
 354         { onwebkitanimationiterationAttr, eventNames().webkitAnimationIterationEvent },
 355         { onwebkitanimationstartAttr, eventNames().webkitAnimationStartEvent },
 356         { onwebkittransitionendAttr, eventNames().webkitTransitionEndEvent },
 357     };
 358 
 359     for (auto&amp; entry : unusualPairsTable)
 360         map.add(entry.attributeName.localName().impl(), entry.eventName);
 361 
 362     return map;
 363 }
 364 
 365 void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const table[], size_t tableSize)
 366 {
 367     for (size_t i = 0; i &lt; tableSize; ++i) {
 368         auto* entry = table[i];
 369 
 370         // FIXME: Would be nice to check these against the actual event names in eventNames().
 371         // Not obvious how to do that simply, though.
 372         auto&amp; attributeName = entry-&gt;localName();
 373 
 374         // Remove the &quot;on&quot; prefix. Requires some memory allocation and computing a hash, but by not
 375         // using pointers from eventNames(), the passed-in table can be initialized at compile time.
<span class="line-modified"> 376         AtomicString eventName = attributeName.string().substring(2);</span>
 377 
 378         map.add(attributeName.impl(), WTFMove(eventName));
 379     }
 380 }
 381 
<span class="line-modified"> 382 const AtomicString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp; map)</span>
 383 {
 384     ASSERT(!attributeName.localName().isNull());
 385 
 386     // Event handler attributes have no namespace.
 387     if (!attributeName.namespaceURI().isNull())
 388         return nullAtom();
 389 
 390     // Fast early return for names that don&#39;t start with &quot;on&quot;.
<span class="line-modified"> 391     AtomicStringImpl&amp; localName = *attributeName.localName().impl();</span>
 392     if (localName.length() &lt; 3 || localName[0] != &#39;o&#39; || localName[1] != &#39;n&#39;)
 393         return nullAtom();
 394 
 395     auto it = map.find(&amp;localName);
 396     return it == map.end() ? nullAtom() : it-&gt;value;
 397 }
 398 
<span class="line-modified"> 399 const AtomicString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName)</span>
 400 {
 401     static NeverDestroyed&lt;EventHandlerNameMap&gt; map = createEventHandlerNameMap();
 402     return eventNameForEventHandlerAttribute(attributeName, map.get());
 403 }
 404 
 405 Node::Editability HTMLElement::editabilityFromContentEditableAttr(const Node&amp; node)
 406 {
 407     if (auto* startElement = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement()) {
 408         for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*startElement)) {
 409             switch (contentEditableType(element)) {
 410             case ContentEditableType::True:
 411                 return Editability::CanEditRichly;
 412             case ContentEditableType::PlaintextOnly:
 413                 return Editability::CanEditPlainText;
 414             case ContentEditableType::False:
 415                 return Editability::ReadOnly;
 416             case ContentEditableType::Inherit:
 417                 break;
 418             }
 419         }
 420     }
 421 
 422     auto containingShadowRoot = makeRefPtr(node.containingShadowRoot());
 423     if (containingShadowRoot &amp;&amp; containingShadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
 424         return Editability::ReadOnly;
 425 
 426     auto&amp; document = node.document();
 427     if (is&lt;HTMLDocument&gt;(document))
 428         return downcast&lt;HTMLDocument&gt;(document).inDesignMode() ? Editability::CanEditRichly : Editability::ReadOnly;
 429 
 430     return Editability::ReadOnly;
 431 }
 432 
 433 bool HTMLElement::matchesReadWritePseudoClass() const
 434 {
 435     return editabilityFromContentEditableAttr(*this) != Editability::ReadOnly;
 436 }
 437 
<span class="line-modified"> 438 void HTMLElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 439 {
 440     if (name == dirAttr) {
 441         dirAttributeChanged(value);
 442         return;
 443     }
 444 
 445     if (name == tabindexAttr) {
 446         if (value.isEmpty())
 447             clearTabIndexExplicitlyIfNeeded();
 448         else if (auto optionalTabIndex = parseHTMLInteger(value))
 449             setTabIndexExplicitly(optionalTabIndex.value());
 450         return;
 451     }
 452 
 453     if (name == inputmodeAttr) {
 454         auto&amp; document = this-&gt;document();
 455         if (this == document.focusedElement()) {
 456             if (auto* page = document.page())
 457                 page-&gt;chrome().client().focusedElementDidChangeInputMode(*this, canonicalInputMode());
 458         }
</pre>
<hr />
<pre>
 485             fragment-&gt;appendChild(Text::create(document, text.substring(start, i - start)));
 486 
 487         if (i == length)
 488             break;
 489 
 490         fragment-&gt;appendChild(HTMLBRElement::create(document));
 491         // Make sure \r\n doesn&#39;t result in two line breaks.
 492         if (c == &#39;\r&#39; &amp;&amp; i + 1 &lt; length &amp;&amp; text[i + 1] == &#39;\n&#39;)
 493             ++i;
 494 
 495         start = i + 1; // Character after line break.
 496     }
 497 
 498     return fragment;
 499 }
 500 
 501 // Returns the conforming &#39;dir&#39; value associated with the state the attribute is in (in its canonical case), if any,
 502 // or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is
 503 // not in a defined state (e.g. the attribute is missing and there is no missing value default).
 504 // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#limited-to-only-known-values
<span class="line-modified"> 505 static inline const AtomicString&amp; toValidDirValue(const AtomicString&amp; value)</span>
 506 {
<span class="line-modified"> 507     static NeverDestroyed&lt;AtomicString&gt; ltrValue(&quot;ltr&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified"> 508     static NeverDestroyed&lt;AtomicString&gt; rtlValue(&quot;rtl&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified"> 509     static NeverDestroyed&lt;AtomicString&gt; autoValue(&quot;auto&quot;, AtomicString::ConstructFromLiteral);</span>
 510     if (equalLettersIgnoringASCIICase(value, &quot;ltr&quot;))
 511         return ltrValue;
 512     if (equalLettersIgnoringASCIICase(value, &quot;rtl&quot;))
 513         return rtlValue;
 514     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 515         return autoValue;
 516     return nullAtom();
 517 }
 518 
<span class="line-modified"> 519 const AtomicString&amp; HTMLElement::dir() const</span>
 520 {
 521     return toValidDirValue(attributeWithoutSynchronization(dirAttr));
 522 }
 523 
<span class="line-modified"> 524 void HTMLElement::setDir(const AtomicString&amp; value)</span>
 525 {
 526     setAttributeWithoutSynchronization(dirAttr, value);
 527 }
 528 
 529 ExceptionOr&lt;void&gt; HTMLElement::setInnerText(const String&amp; text)
 530 {
 531     // FIXME: This doesn&#39;t take whitespace collapsing into account at all.
 532 
 533     if (!text.contains(&#39;\n&#39;) &amp;&amp; !text.contains(&#39;\r&#39;)) {
 534         if (text.isEmpty())
 535             replaceAllChildren(nullptr);
 536         else
 537             replaceAllChildren(document().createTextNode(text));
 538         return { };
 539     }
 540 
 541     // FIXME: Do we need to be able to detect preserveNewline style even when there&#39;s no renderer?
 542     // FIXME: Can the renderer be out of date here? Do we need to call updateStyleIfNeeded?
 543     // For example, for the contents of textarea elements that are display:none?
 544     auto* r = renderer();
</pre>
<hr />
<pre>
 582         return Exception { HierarchyRequestError };
 583 
 584     auto replaceResult = parent-&gt;replaceChild(*newChild, *this);
 585     if (replaceResult.hasException())
 586         return replaceResult.releaseException();
 587 
 588     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
 589     if (is&lt;Text&gt;(node)) {
 590         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
 591         if (result.hasException())
 592             return result.releaseException();
 593     }
 594     if (is&lt;Text&gt;(prev)) {
 595         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
 596         if (result.hasException())
 597             return result.releaseException();
 598     }
 599     return { };
 600 }
 601 
<span class="line-modified"> 602 void HTMLElement::applyAlignmentAttributeToStyle(const AtomicString&amp; alignment, MutableStyleProperties&amp; style)</span>
 603 {
 604     // Vertical alignment with respect to the current baseline of the text
 605     // right or left means floating images.
 606     CSSValueID floatValue = CSSValueInvalid;
 607     CSSValueID verticalAlignValue = CSSValueInvalid;
 608 
 609     if (equalLettersIgnoringASCIICase(alignment, &quot;absmiddle&quot;))
 610         verticalAlignValue = CSSValueMiddle;
 611     else if (equalLettersIgnoringASCIICase(alignment, &quot;absbottom&quot;))
 612         verticalAlignValue = CSSValueBottom;
 613     else if (equalLettersIgnoringASCIICase(alignment, &quot;left&quot;)) {
 614         floatValue = CSSValueLeft;
 615         verticalAlignValue = CSSValueTop;
 616     } else if (equalLettersIgnoringASCIICase(alignment, &quot;right&quot;)) {
 617         floatValue = CSSValueRight;
 618         verticalAlignValue = CSSValueTop;
 619     } else if (equalLettersIgnoringASCIICase(alignment, &quot;top&quot;))
 620         verticalAlignValue = CSSValueTop;
 621     else if (equalLettersIgnoringASCIICase(alignment, &quot;middle&quot;))
 622         verticalAlignValue = CSSValueWebkitBaselineMiddle;
</pre>
<hr />
<pre>
 645 }
 646 
 647 String HTMLElement::contentEditable() const
 648 {
 649     switch (contentEditableType(*this)) {
 650     case ContentEditableType::Inherit:
 651         return &quot;inherit&quot;_s;
 652     case ContentEditableType::True:
 653         return &quot;true&quot;_s;
 654     case ContentEditableType::False:
 655         return &quot;false&quot;_s;
 656     case ContentEditableType::PlaintextOnly:
 657         return &quot;plaintext-only&quot;_s;
 658     }
 659     return &quot;inherit&quot;_s;
 660 }
 661 
 662 ExceptionOr&lt;void&gt; HTMLElement::setContentEditable(const String&amp; enabled)
 663 {
 664     if (equalLettersIgnoringASCIICase(enabled, &quot;true&quot;))
<span class="line-modified"> 665         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral));</span>
 666     else if (equalLettersIgnoringASCIICase(enabled, &quot;false&quot;))
<span class="line-modified"> 667         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));</span>
 668     else if (equalLettersIgnoringASCIICase(enabled, &quot;plaintext-only&quot;))
<span class="line-modified"> 669         setAttributeWithoutSynchronization(contenteditableAttr, AtomicString(&quot;plaintext-only&quot;, AtomicString::ConstructFromLiteral));</span>
 670     else if (equalLettersIgnoringASCIICase(enabled, &quot;inherit&quot;))
 671         removeAttribute(contenteditableAttr);
 672     else
 673         return Exception { SyntaxError };
 674     return { };
 675 }
 676 
 677 bool HTMLElement::draggable() const
 678 {
 679     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;true&quot;);
 680 }
 681 
 682 void HTMLElement::setDraggable(bool value)
 683 {
 684     setAttributeWithoutSynchronization(draggableAttr, value
<span class="line-modified"> 685         ? AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral)</span>
<span class="line-modified"> 686         : AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));</span>
 687 }
 688 
 689 bool HTMLElement::spellcheck() const
 690 {
 691     return isSpellCheckingEnabled();
 692 }
 693 
 694 void HTMLElement::setSpellcheck(bool enable)
 695 {
 696     setAttributeWithoutSynchronization(spellcheckAttr, enable
<span class="line-modified"> 697         ? AtomicString(&quot;true&quot;, AtomicString::ConstructFromLiteral)</span>
<span class="line-modified"> 698         : AtomicString(&quot;false&quot;, AtomicString::ConstructFromLiteral));</span>
 699 }
 700 
 701 void HTMLElement::click()
 702 {
 703     simulateClick(*this, nullptr, SendNoEvents, DoNotShowPressedLook, SimulatedClickSource::Bindings);
 704 }
 705 
 706 void HTMLElement::accessKeyAction(bool sendMouseEvents)
 707 {
 708     dispatchSimulatedClick(nullptr, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 709 }
 710 
 711 String HTMLElement::title() const
 712 {
 713     return attributeWithoutSynchronization(titleAttr);
 714 }
 715 
<span class="line-removed"> 716 int HTMLElement::tabIndex() const</span>
<span class="line-removed"> 717 {</span>
<span class="line-removed"> 718     if (supportsFocus())</span>
<span class="line-removed"> 719         return Element::tabIndex();</span>
<span class="line-removed"> 720     return -1;</span>
<span class="line-removed"> 721 }</span>
<span class="line-removed"> 722 </span>
 723 bool HTMLElement::translate() const
 724 {
 725     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
<span class="line-modified"> 726         const AtomicString&amp; value = element.attributeWithoutSynchronization(translateAttr);</span>
 727         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 728             return true;
 729         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 730             return false;
 731     }
 732     // Default on the root element is translate=yes.
 733     return true;
 734 }
 735 
 736 void HTMLElement::setTranslate(bool enable)
 737 {
 738     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 739 }
 740 
 741 bool HTMLElement::rendererIsNeeded(const RenderStyle&amp; style)
 742 {
 743     if (hasTagName(noscriptTag)) {
 744         RefPtr&lt;Frame&gt; frame = document().frame();
 745         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 746             return false;
 747     } else if (hasTagName(noembedTag)) {
 748         RefPtr&lt;Frame&gt; frame = document().frame();
 749         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 750             return false;
 751     }
 752     return StyledElement::rendererIsNeeded(style);
 753 }
 754 
 755 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 756 {
 757     return RenderElement::createFor(*this, WTFMove(style));
 758 }
 759 
 760 HTMLFormElement* HTMLElement::form() const
 761 {
 762     return HTMLFormElement::findClosestFormAncestor(*this);
 763 }
 764 










 765 static inline bool elementAffectsDirectionality(const Node&amp; node)
 766 {
 767     if (!is&lt;HTMLElement&gt;(node))
 768         return false;
 769     const HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 770     return is&lt;HTMLBDIElement&gt;(element) || element.hasAttributeWithoutSynchronization(dirAttr);
 771 }
 772 
 773 static void setHasDirAutoFlagRecursively(Node* firstNode, bool flag, Node* lastNode = nullptr)
 774 {
 775     firstNode-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 776 
 777     RefPtr&lt;Node&gt; node = firstNode-&gt;firstChild();
 778 
 779     while (node) {
 780         if (node-&gt;selfOrAncestorHasDirAutoAttribute() == flag)
 781             return;
 782 
 783         if (elementAffectsDirectionality(*node)) {
 784             if (node == lastNode)
 785                 return;
 786             node = NodeTraversal::nextSkippingChildren(*node, firstNode);
 787             continue;
 788         }
 789         node-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 790         if (node == lastNode)
 791             return;
 792         node = NodeTraversal::next(*node, firstNode);
 793     }
 794 }
 795 
 796 void HTMLElement::childrenChanged(const ChildChange&amp; change)
 797 {
 798     StyledElement::childrenChanged(change);
 799     adjustDirectionalityIfNeededAfterChildrenChanged(change.previousSiblingElement, change.type);
 800 }
 801 
 802 bool HTMLElement::hasDirectionAuto() const
 803 {
<span class="line-modified"> 804     const AtomicString&amp; direction = attributeWithoutSynchronization(dirAttr);</span>
 805     return (hasTagName(bdiTag) &amp;&amp; direction.isNull()) || equalLettersIgnoringASCIICase(direction, &quot;auto&quot;);
 806 }
 807 
 808 TextDirection HTMLElement::directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const
 809 {
 810     if (!(selfOrAncestorHasDirAutoAttribute() &amp;&amp; hasDirectionAuto())) {
 811         isAuto = false;
 812         return TextDirection::LTR;
 813     }
 814 
 815     isAuto = true;
 816     return directionality();
 817 }
 818 
 819 TextDirection HTMLElement::directionality(Node** strongDirectionalityTextNode) const
 820 {
 821     if (isTextField()) {
 822         HTMLTextFormControlElement&amp; textElement = downcast&lt;HTMLTextFormControlElement&gt;(const_cast&lt;HTMLElement&amp;&gt;(*this));
 823         bool hasStrongDirectionality;
 824         UCharDirection textDirection = textElement.value().defaultWritingDirection(&amp;hasStrongDirectionality);
</pre>
<hr />
<pre>
 844                 continue;
 845             }
 846         }
 847 
 848         if (node-&gt;isTextNode()) {
 849             bool hasStrongDirectionality;
 850             UCharDirection textDirection = node-&gt;textContent(true).defaultWritingDirection(&amp;hasStrongDirectionality);
 851             if (hasStrongDirectionality) {
 852                 if (strongDirectionalityTextNode)
 853                     *strongDirectionalityTextNode = node.get();
 854                 return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 855             }
 856         }
 857         node = NodeTraversal::next(*node, this);
 858     }
 859     if (strongDirectionalityTextNode)
 860         *strongDirectionalityTextNode = nullptr;
 861     return TextDirection::LTR;
 862 }
 863 
<span class="line-modified"> 864 void HTMLElement::dirAttributeChanged(const AtomicString&amp; value)</span>
 865 {
 866     RefPtr&lt;Element&gt; parent = parentElement();
 867 
 868     if (is&lt;HTMLElement&gt;(parent) &amp;&amp; parent-&gt;selfOrAncestorHasDirAutoAttribute())
 869         downcast&lt;HTMLElement&gt;(*parent).adjustDirectionalityIfNeededAfterChildAttributeChanged(this);
 870 
 871     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 872         calculateAndAdjustDirectionality();
 873 }
 874 
 875 void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)
 876 {
 877     ASSERT(selfOrAncestorHasDirAutoAttribute());
 878     Node* strongDirectionalityTextNode;
 879     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 880     setHasDirAutoFlagRecursively(child, false);
 881     if (!renderer() || renderer()-&gt;style().direction() == textDirection)
 882         return;
 883     for (auto&amp; elementToAdjust : elementLineage(this)) {
 884         if (elementAffectsDirectionality(elementToAdjust)) {
</pre>
<hr />
<pre>
1049 }
1050 
1051 bool HTMLElement::canBeActuallyDisabled() const
1052 {
1053     return is&lt;HTMLButtonElement&gt;(*this)
1054         || is&lt;HTMLInputElement&gt;(*this)
1055         || is&lt;HTMLSelectElement&gt;(*this)
1056         || is&lt;HTMLTextAreaElement&gt;(*this)
1057         || is&lt;HTMLOptGroupElement&gt;(*this)
1058         || is&lt;HTMLOptionElement&gt;(*this)
1059         || is&lt;HTMLFieldSetElement&gt;(*this);
1060 }
1061 
1062 bool HTMLElement::isActuallyDisabled() const
1063 {
1064     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1065 }
1066 
1067 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)
1068 
<span class="line-modified">1069 const AtomicString&amp; HTMLElement::autocapitalize() const</span>
1070 {
1071     return stringForAutocapitalizeType(autocapitalizeType());
1072 }
1073 
1074 AutocapitalizeType HTMLElement::autocapitalizeType() const
1075 {
1076     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1077 }
1078 
<span class="line-modified">1079 void HTMLElement::setAutocapitalize(const AtomicString&amp; value)</span>
1080 {
1081     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1082 }
1083 
1084 bool HTMLElement::shouldAutocorrect() const
1085 {
1086     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1087     // Unrecognized values fall back to &quot;on&quot;.
1088     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1089 }
1090 
1091 void HTMLElement::setAutocorrect(bool autocorrect)
1092 {
<span class="line-modified">1093     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomicString(&quot;on&quot;, AtomicString::ConstructFromLiteral) : AtomicString(&quot;off&quot;, AtomicString::ConstructFromLiteral));</span>
1094 }
1095 
1096 #endif
1097 
1098 InputMode HTMLElement::canonicalInputMode() const
1099 {
<span class="line-modified">1100     return inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));</span>





1101 }
1102 
<span class="line-modified">1103 const AtomicString&amp; HTMLElement::inputMode() const</span>
1104 {
1105     return stringForInputMode(canonicalInputMode());
1106 }
1107 
<span class="line-modified">1108 void HTMLElement::setInputMode(const AtomicString&amp; value)</span>
1109 {
1110     setAttributeWithoutSynchronization(inputmodeAttr, value);
1111 }
1112 
1113 } // namespace WebCore
1114 
1115 #ifndef NDEBUG
1116 
1117 // For use in the debugger
1118 void dumpInnerHTML(WebCore::HTMLElement*);
1119 
1120 void dumpInnerHTML(WebCore::HTMLElement* element)
1121 {
1122     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1123 }
1124 
1125 #endif
</pre>
</td>
<td>
<hr />
<pre>
  67 #include &quot;XMLNames.h&quot;
  68 #include &quot;markup.h&quot;
  69 #include &lt;wtf/IsoMallocInlines.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/StdLibExtras.h&gt;
  72 #include &lt;wtf/text/CString.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLElement);
  77 
  78 using namespace HTMLNames;
  79 
  80 Ref&lt;HTMLElement&gt; HTMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  81 {
  82     return adoptRef(*new HTMLElement(tagName, document));
  83 }
  84 
  85 String HTMLElement::nodeName() const
  86 {
<span class="line-modified">  87     // FIXME: Would be nice to have an AtomString lookup based off uppercase</span>
  88     // ASCII characters that does not have to copy the string on a hit in the hash.
  89     if (document().isHTMLDocument()) {
  90         if (LIKELY(!tagQName().hasPrefix()))
  91             return tagQName().localNameUpper();
  92         return Element::nodeName().convertToASCIIUppercase();
  93     }
  94     return Element::nodeName();
  95 }
  96 
  97 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  98 {
  99     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 100         return CSSValuePlaintext;
 101     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 102     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 103     return CSSValueIsolate;
 104 }
 105 
<span class="line-modified"> 106 unsigned HTMLElement::parseBorderWidthAttribute(const AtomString&amp; value) const</span>
 107 {
 108     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 109         return optionalBorderWidth.value();
 110 
 111     return hasTagName(tableTag) ? 1 : 0;
 112 }
 113 
<span class="line-modified"> 114 void HTMLElement::applyBorderAttributeToStyle(const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 115 {
 116     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 118 }
 119 
<span class="line-modified"> 120 void HTMLElement::mapLanguageAttributeToLocale(const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 121 {
 122     if (!value.isEmpty()) {
 123         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 124         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 125     } else {
 126         // The empty string means the language is explicitly unknown.
 127         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 128     }
 129 }
 130 
 131 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 132 {
 133     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 134         return true;
 135     return StyledElement::isPresentationAttribute(name);
 136 }
 137 
<span class="line-modified"> 138 static bool isLTROrRTLIgnoringCase(const AtomString&amp; dirAttributeValue)</span>
 139 {
 140     return equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;);
 141 }
 142 
 143 enum class ContentEditableType {
 144     Inherit,
 145     True,
 146     False,
 147     PlaintextOnly
 148 };
 149 
<span class="line-modified"> 150 static inline ContentEditableType contentEditableType(const AtomString&amp; value)</span>
 151 {
 152     if (value.isNull())
 153         return ContentEditableType::Inherit;
 154     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
 155         return ContentEditableType::True;
 156     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 157         return ContentEditableType::False;
 158     if (equalLettersIgnoringASCIICase(value, &quot;plaintext-only&quot;))
 159         return ContentEditableType::PlaintextOnly;
 160 
 161     return ContentEditableType::Inherit;
 162 }
 163 
 164 static ContentEditableType contentEditableType(const HTMLElement&amp; element)
 165 {
 166     return contentEditableType(element.attributeWithoutSynchronization(contenteditableAttr));
 167 }
 168 
<span class="line-modified"> 169 void HTMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 170 {
 171     if (name == alignAttr) {
 172         if (equalLettersIgnoringASCIICase(value, &quot;middle&quot;))
 173             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, CSSValueCenter);
 174         else
 175             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, value);
 176     } else if (name == contenteditableAttr) {
 177         CSSValueID userModifyValue = CSSValueReadWrite;
 178         switch (contentEditableType(value)) {
 179         case ContentEditableType::Inherit:
 180             return;
 181         case ContentEditableType::False:
 182             userModifyValue = CSSValueReadOnly;
 183             break;
 184         case ContentEditableType::PlaintextOnly:
 185             userModifyValue = CSSValueReadWritePlaintextOnly;
 186             FALLTHROUGH;
 187         case ContentEditableType::True:
 188             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
 189             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitNbspMode, CSSValueSpace);
</pre>
<hr />
<pre>
 210                 addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
 211             if (!hasTagName(bdiTag) &amp;&amp; !hasTagName(bdoTag) &amp;&amp; !hasTagName(outputTag))
 212                 addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, CSSValueEmbed);
 213         }
 214     } else if (name.matches(XMLNames::langAttr))
 215         mapLanguageAttributeToLocale(value, style);
 216     else if (name == langAttr) {
 217         // xml:lang has a higher priority than lang.
 218         if (!hasAttributeWithoutSynchronization(XMLNames::langAttr))
 219             mapLanguageAttributeToLocale(value, style);
 220     } else
 221         StyledElement::collectStyleForPresentationAttribute(name, value, style);
 222 }
 223 
 224 HTMLElement::EventHandlerNameMap HTMLElement::createEventHandlerNameMap()
 225 {
 226     EventHandlerNameMap map;
 227 
 228     static const QualifiedName* const table[] = {
 229         &amp;onabortAttr.get(),









 230         &amp;onanimationendAttr.get(),
 231         &amp;onanimationiterationAttr.get(),
 232         &amp;onanimationstartAttr.get(),
 233         &amp;onanimationcancelAttr.get(),
 234         &amp;onautocompleteAttr.get(),
 235         &amp;onautocompleteerrorAttr.get(),
 236         &amp;onbeforecopyAttr.get(),
 237         &amp;onbeforecutAttr.get(),
 238         &amp;onbeforeinputAttr.get(),
 239         &amp;onbeforeloadAttr.get(),
 240         &amp;onbeforepasteAttr.get(),
 241         &amp;onblurAttr.get(),
 242         &amp;oncanplayAttr.get(),
 243         &amp;oncanplaythroughAttr.get(),
 244         &amp;onchangeAttr.get(),
 245         &amp;onclickAttr.get(),
 246         &amp;oncontextmenuAttr.get(),
 247         &amp;oncopyAttr.get(),
 248         &amp;oncutAttr.get(),
 249         &amp;ondblclickAttr.get(),
 250         &amp;ondragAttr.get(),
 251         &amp;ondragendAttr.get(),
 252         &amp;ondragenterAttr.get(),
 253         &amp;ondragleaveAttr.get(),
 254         &amp;ondragoverAttr.get(),
 255         &amp;ondragstartAttr.get(),
 256         &amp;ondropAttr.get(),
 257         &amp;ondurationchangeAttr.get(),
 258         &amp;onemptiedAttr.get(),
 259         &amp;onendedAttr.get(),
 260         &amp;onerrorAttr.get(),
 261         &amp;onfocusAttr.get(),
 262         &amp;onfocusinAttr.get(),
 263         &amp;onfocusoutAttr.get(),
 264         &amp;ongesturechangeAttr.get(),
 265         &amp;ongestureendAttr.get(),
 266         &amp;ongesturestartAttr.get(),
<span class="line-added"> 267         &amp;ongotpointercaptureAttr.get(),</span>
 268         &amp;oninputAttr.get(),
 269         &amp;oninvalidAttr.get(),
 270         &amp;onkeydownAttr.get(),
 271         &amp;onkeypressAttr.get(),
 272         &amp;onkeyupAttr.get(),
 273         &amp;onloadAttr.get(),
 274         &amp;onloadeddataAttr.get(),
 275         &amp;onloadedmetadataAttr.get(),
 276         &amp;onloadstartAttr.get(),
<span class="line-added"> 277         &amp;onlostpointercaptureAttr.get(),</span>
 278         &amp;onmousedownAttr.get(),
 279         &amp;onmouseenterAttr.get(),
 280         &amp;onmouseleaveAttr.get(),
 281         &amp;onmousemoveAttr.get(),
 282         &amp;onmouseoutAttr.get(),
 283         &amp;onmouseoverAttr.get(),
 284         &amp;onmouseupAttr.get(),
 285         &amp;onmousewheelAttr.get(),
 286         &amp;onpasteAttr.get(),
 287         &amp;onpauseAttr.get(),
 288         &amp;onplayAttr.get(),
 289         &amp;onplayingAttr.get(),
<span class="line-added"> 290         &amp;onpointerdownAttr.get(),</span>
<span class="line-added"> 291         &amp;onpointermoveAttr.get(),</span>
<span class="line-added"> 292         &amp;onpointerupAttr.get(),</span>
<span class="line-added"> 293         &amp;onpointercancelAttr.get(),</span>
<span class="line-added"> 294         &amp;onpointeroverAttr.get(),</span>
<span class="line-added"> 295         &amp;onpointeroutAttr.get(),</span>
<span class="line-added"> 296         &amp;onpointerenterAttr.get(),</span>
<span class="line-added"> 297         &amp;onpointerleaveAttr.get(),</span>
 298         &amp;onprogressAttr.get(),
 299         &amp;onratechangeAttr.get(),
 300         &amp;onresetAttr.get(),
 301         &amp;onresizeAttr.get(),
 302         &amp;onscrollAttr.get(),
 303         &amp;onsearchAttr.get(),
 304         &amp;onseekedAttr.get(),
 305         &amp;onseekingAttr.get(),
 306         &amp;onselectAttr.get(),
 307         &amp;onselectstartAttr.get(),
 308         &amp;onstalledAttr.get(),
 309         &amp;onsubmitAttr.get(),
 310         &amp;onsuspendAttr.get(),
 311         &amp;ontimeupdateAttr.get(),
 312         &amp;ontoggleAttr.get(),
 313         &amp;ontouchcancelAttr.get(),
 314         &amp;ontouchendAttr.get(),
 315         &amp;ontouchforcechangeAttr.get(),
 316         &amp;ontouchmoveAttr.get(),
 317         &amp;ontouchstartAttr.get(),
</pre>
<hr />
<pre>
 330         &amp;onwebkitkeyerrorAttr.get(),
 331         &amp;onwebkitkeymessageAttr.get(),
 332         &amp;onwebkitmouseforcechangedAttr.get(),
 333         &amp;onwebkitmouseforcedownAttr.get(),
 334         &amp;onwebkitmouseforcewillbeginAttr.get(),
 335         &amp;onwebkitmouseforceupAttr.get(),
 336         &amp;onwebkitneedkeyAttr.get(),
 337         &amp;onwebkitplaybacktargetavailabilitychangedAttr.get(),
 338         &amp;onwebkitpresentationmodechangedAttr.get(),
 339         &amp;onwebkitwillrevealbottomAttr.get(),
 340         &amp;onwebkitwillrevealleftAttr.get(),
 341         &amp;onwebkitwillrevealrightAttr.get(),
 342         &amp;onwebkitwillrevealtopAttr.get(),
 343         &amp;onwheelAttr.get(),
 344     };
 345 
 346     populateEventHandlerNameMap(map, table);
 347 
 348     struct UnusualMapping {
 349         const QualifiedName&amp; attributeName;
<span class="line-modified"> 350         const AtomString&amp; eventName;</span>
 351     };
 352 
 353     const UnusualMapping unusualPairsTable[] = {
 354         { onwebkitanimationendAttr, eventNames().webkitAnimationEndEvent },
 355         { onwebkitanimationiterationAttr, eventNames().webkitAnimationIterationEvent },
 356         { onwebkitanimationstartAttr, eventNames().webkitAnimationStartEvent },
 357         { onwebkittransitionendAttr, eventNames().webkitTransitionEndEvent },
 358     };
 359 
 360     for (auto&amp; entry : unusualPairsTable)
 361         map.add(entry.attributeName.localName().impl(), entry.eventName);
 362 
 363     return map;
 364 }
 365 
 366 void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const table[], size_t tableSize)
 367 {
 368     for (size_t i = 0; i &lt; tableSize; ++i) {
 369         auto* entry = table[i];
 370 
 371         // FIXME: Would be nice to check these against the actual event names in eventNames().
 372         // Not obvious how to do that simply, though.
 373         auto&amp; attributeName = entry-&gt;localName();
 374 
 375         // Remove the &quot;on&quot; prefix. Requires some memory allocation and computing a hash, but by not
 376         // using pointers from eventNames(), the passed-in table can be initialized at compile time.
<span class="line-modified"> 377         AtomString eventName = attributeName.string().substring(2);</span>
 378 
 379         map.add(attributeName.impl(), WTFMove(eventName));
 380     }
 381 }
 382 
<span class="line-modified"> 383 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp; map)</span>
 384 {
 385     ASSERT(!attributeName.localName().isNull());
 386 
 387     // Event handler attributes have no namespace.
 388     if (!attributeName.namespaceURI().isNull())
 389         return nullAtom();
 390 
 391     // Fast early return for names that don&#39;t start with &quot;on&quot;.
<span class="line-modified"> 392     AtomStringImpl&amp; localName = *attributeName.localName().impl();</span>
 393     if (localName.length() &lt; 3 || localName[0] != &#39;o&#39; || localName[1] != &#39;n&#39;)
 394         return nullAtom();
 395 
 396     auto it = map.find(&amp;localName);
 397     return it == map.end() ? nullAtom() : it-&gt;value;
 398 }
 399 
<span class="line-modified"> 400 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName)</span>
 401 {
 402     static NeverDestroyed&lt;EventHandlerNameMap&gt; map = createEventHandlerNameMap();
 403     return eventNameForEventHandlerAttribute(attributeName, map.get());
 404 }
 405 
 406 Node::Editability HTMLElement::editabilityFromContentEditableAttr(const Node&amp; node)
 407 {
 408     if (auto* startElement = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement()) {
 409         for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*startElement)) {
 410             switch (contentEditableType(element)) {
 411             case ContentEditableType::True:
 412                 return Editability::CanEditRichly;
 413             case ContentEditableType::PlaintextOnly:
 414                 return Editability::CanEditPlainText;
 415             case ContentEditableType::False:
 416                 return Editability::ReadOnly;
 417             case ContentEditableType::Inherit:
 418                 break;
 419             }
 420         }
 421     }
 422 
 423     auto containingShadowRoot = makeRefPtr(node.containingShadowRoot());
 424     if (containingShadowRoot &amp;&amp; containingShadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
 425         return Editability::ReadOnly;
 426 
 427     auto&amp; document = node.document();
 428     if (is&lt;HTMLDocument&gt;(document))
 429         return downcast&lt;HTMLDocument&gt;(document).inDesignMode() ? Editability::CanEditRichly : Editability::ReadOnly;
 430 
 431     return Editability::ReadOnly;
 432 }
 433 
 434 bool HTMLElement::matchesReadWritePseudoClass() const
 435 {
 436     return editabilityFromContentEditableAttr(*this) != Editability::ReadOnly;
 437 }
 438 
<span class="line-modified"> 439 void HTMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 440 {
 441     if (name == dirAttr) {
 442         dirAttributeChanged(value);
 443         return;
 444     }
 445 
 446     if (name == tabindexAttr) {
 447         if (value.isEmpty())
 448             clearTabIndexExplicitlyIfNeeded();
 449         else if (auto optionalTabIndex = parseHTMLInteger(value))
 450             setTabIndexExplicitly(optionalTabIndex.value());
 451         return;
 452     }
 453 
 454     if (name == inputmodeAttr) {
 455         auto&amp; document = this-&gt;document();
 456         if (this == document.focusedElement()) {
 457             if (auto* page = document.page())
 458                 page-&gt;chrome().client().focusedElementDidChangeInputMode(*this, canonicalInputMode());
 459         }
</pre>
<hr />
<pre>
 486             fragment-&gt;appendChild(Text::create(document, text.substring(start, i - start)));
 487 
 488         if (i == length)
 489             break;
 490 
 491         fragment-&gt;appendChild(HTMLBRElement::create(document));
 492         // Make sure \r\n doesn&#39;t result in two line breaks.
 493         if (c == &#39;\r&#39; &amp;&amp; i + 1 &lt; length &amp;&amp; text[i + 1] == &#39;\n&#39;)
 494             ++i;
 495 
 496         start = i + 1; // Character after line break.
 497     }
 498 
 499     return fragment;
 500 }
 501 
 502 // Returns the conforming &#39;dir&#39; value associated with the state the attribute is in (in its canonical case), if any,
 503 // or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is
 504 // not in a defined state (e.g. the attribute is missing and there is no missing value default).
 505 // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#limited-to-only-known-values
<span class="line-modified"> 506 static inline const AtomString&amp; toValidDirValue(const AtomString&amp; value)</span>
 507 {
<span class="line-modified"> 508     static NeverDestroyed&lt;AtomString&gt; ltrValue(&quot;ltr&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified"> 509     static NeverDestroyed&lt;AtomString&gt; rtlValue(&quot;rtl&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified"> 510     static NeverDestroyed&lt;AtomString&gt; autoValue(&quot;auto&quot;, AtomString::ConstructFromLiteral);</span>
 511     if (equalLettersIgnoringASCIICase(value, &quot;ltr&quot;))
 512         return ltrValue;
 513     if (equalLettersIgnoringASCIICase(value, &quot;rtl&quot;))
 514         return rtlValue;
 515     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 516         return autoValue;
 517     return nullAtom();
 518 }
 519 
<span class="line-modified"> 520 const AtomString&amp; HTMLElement::dir() const</span>
 521 {
 522     return toValidDirValue(attributeWithoutSynchronization(dirAttr));
 523 }
 524 
<span class="line-modified"> 525 void HTMLElement::setDir(const AtomString&amp; value)</span>
 526 {
 527     setAttributeWithoutSynchronization(dirAttr, value);
 528 }
 529 
 530 ExceptionOr&lt;void&gt; HTMLElement::setInnerText(const String&amp; text)
 531 {
 532     // FIXME: This doesn&#39;t take whitespace collapsing into account at all.
 533 
 534     if (!text.contains(&#39;\n&#39;) &amp;&amp; !text.contains(&#39;\r&#39;)) {
 535         if (text.isEmpty())
 536             replaceAllChildren(nullptr);
 537         else
 538             replaceAllChildren(document().createTextNode(text));
 539         return { };
 540     }
 541 
 542     // FIXME: Do we need to be able to detect preserveNewline style even when there&#39;s no renderer?
 543     // FIXME: Can the renderer be out of date here? Do we need to call updateStyleIfNeeded?
 544     // For example, for the contents of textarea elements that are display:none?
 545     auto* r = renderer();
</pre>
<hr />
<pre>
 583         return Exception { HierarchyRequestError };
 584 
 585     auto replaceResult = parent-&gt;replaceChild(*newChild, *this);
 586     if (replaceResult.hasException())
 587         return replaceResult.releaseException();
 588 
 589     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
 590     if (is&lt;Text&gt;(node)) {
 591         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
 592         if (result.hasException())
 593             return result.releaseException();
 594     }
 595     if (is&lt;Text&gt;(prev)) {
 596         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
 597         if (result.hasException())
 598             return result.releaseException();
 599     }
 600     return { };
 601 }
 602 
<span class="line-modified"> 603 void HTMLElement::applyAlignmentAttributeToStyle(const AtomString&amp; alignment, MutableStyleProperties&amp; style)</span>
 604 {
 605     // Vertical alignment with respect to the current baseline of the text
 606     // right or left means floating images.
 607     CSSValueID floatValue = CSSValueInvalid;
 608     CSSValueID verticalAlignValue = CSSValueInvalid;
 609 
 610     if (equalLettersIgnoringASCIICase(alignment, &quot;absmiddle&quot;))
 611         verticalAlignValue = CSSValueMiddle;
 612     else if (equalLettersIgnoringASCIICase(alignment, &quot;absbottom&quot;))
 613         verticalAlignValue = CSSValueBottom;
 614     else if (equalLettersIgnoringASCIICase(alignment, &quot;left&quot;)) {
 615         floatValue = CSSValueLeft;
 616         verticalAlignValue = CSSValueTop;
 617     } else if (equalLettersIgnoringASCIICase(alignment, &quot;right&quot;)) {
 618         floatValue = CSSValueRight;
 619         verticalAlignValue = CSSValueTop;
 620     } else if (equalLettersIgnoringASCIICase(alignment, &quot;top&quot;))
 621         verticalAlignValue = CSSValueTop;
 622     else if (equalLettersIgnoringASCIICase(alignment, &quot;middle&quot;))
 623         verticalAlignValue = CSSValueWebkitBaselineMiddle;
</pre>
<hr />
<pre>
 646 }
 647 
 648 String HTMLElement::contentEditable() const
 649 {
 650     switch (contentEditableType(*this)) {
 651     case ContentEditableType::Inherit:
 652         return &quot;inherit&quot;_s;
 653     case ContentEditableType::True:
 654         return &quot;true&quot;_s;
 655     case ContentEditableType::False:
 656         return &quot;false&quot;_s;
 657     case ContentEditableType::PlaintextOnly:
 658         return &quot;plaintext-only&quot;_s;
 659     }
 660     return &quot;inherit&quot;_s;
 661 }
 662 
 663 ExceptionOr&lt;void&gt; HTMLElement::setContentEditable(const String&amp; enabled)
 664 {
 665     if (equalLettersIgnoringASCIICase(enabled, &quot;true&quot;))
<span class="line-modified"> 666         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral));</span>
 667     else if (equalLettersIgnoringASCIICase(enabled, &quot;false&quot;))
<span class="line-modified"> 668         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 669     else if (equalLettersIgnoringASCIICase(enabled, &quot;plaintext-only&quot;))
<span class="line-modified"> 670         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;plaintext-only&quot;, AtomString::ConstructFromLiteral));</span>
 671     else if (equalLettersIgnoringASCIICase(enabled, &quot;inherit&quot;))
 672         removeAttribute(contenteditableAttr);
 673     else
 674         return Exception { SyntaxError };
 675     return { };
 676 }
 677 
 678 bool HTMLElement::draggable() const
 679 {
 680     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;true&quot;);
 681 }
 682 
 683 void HTMLElement::setDraggable(bool value)
 684 {
 685     setAttributeWithoutSynchronization(draggableAttr, value
<span class="line-modified"> 686         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)</span>
<span class="line-modified"> 687         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 688 }
 689 
 690 bool HTMLElement::spellcheck() const
 691 {
 692     return isSpellCheckingEnabled();
 693 }
 694 
 695 void HTMLElement::setSpellcheck(bool enable)
 696 {
 697     setAttributeWithoutSynchronization(spellcheckAttr, enable
<span class="line-modified"> 698         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)</span>
<span class="line-modified"> 699         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));</span>
 700 }
 701 
 702 void HTMLElement::click()
 703 {
 704     simulateClick(*this, nullptr, SendNoEvents, DoNotShowPressedLook, SimulatedClickSource::Bindings);
 705 }
 706 
 707 void HTMLElement::accessKeyAction(bool sendMouseEvents)
 708 {
 709     dispatchSimulatedClick(nullptr, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 710 }
 711 
 712 String HTMLElement::title() const
 713 {
 714     return attributeWithoutSynchronization(titleAttr);
 715 }
 716 







 717 bool HTMLElement::translate() const
 718 {
 719     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
<span class="line-modified"> 720         const AtomString&amp; value = element.attributeWithoutSynchronization(translateAttr);</span>
 721         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 722             return true;
 723         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 724             return false;
 725     }
 726     // Default on the root element is translate=yes.
 727     return true;
 728 }
 729 
 730 void HTMLElement::setTranslate(bool enable)
 731 {
 732     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 733 }
 734 
 735 bool HTMLElement::rendererIsNeeded(const RenderStyle&amp; style)
 736 {
 737     if (hasTagName(noscriptTag)) {
 738         RefPtr&lt;Frame&gt; frame = document().frame();
 739         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 740             return false;
 741     } else if (hasTagName(noembedTag)) {
 742         RefPtr&lt;Frame&gt; frame = document().frame();
 743         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 744             return false;
 745     }
 746     return StyledElement::rendererIsNeeded(style);
 747 }
 748 
 749 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 750 {
 751     return RenderElement::createFor(*this, WTFMove(style));
 752 }
 753 
 754 HTMLFormElement* HTMLElement::form() const
 755 {
 756     return HTMLFormElement::findClosestFormAncestor(*this);
 757 }
 758 
<span class="line-added"> 759 FormNamedItem* HTMLElement::asFormNamedItem()</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     return nullptr;</span>
<span class="line-added"> 762 }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764 FormAssociatedElement* HTMLElement::asFormAssociatedElement()</span>
<span class="line-added"> 765 {</span>
<span class="line-added"> 766     return nullptr;</span>
<span class="line-added"> 767 }</span>
<span class="line-added"> 768 </span>
 769 static inline bool elementAffectsDirectionality(const Node&amp; node)
 770 {
 771     if (!is&lt;HTMLElement&gt;(node))
 772         return false;
 773     const HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 774     return is&lt;HTMLBDIElement&gt;(element) || element.hasAttributeWithoutSynchronization(dirAttr);
 775 }
 776 
 777 static void setHasDirAutoFlagRecursively(Node* firstNode, bool flag, Node* lastNode = nullptr)
 778 {
 779     firstNode-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 780 
 781     RefPtr&lt;Node&gt; node = firstNode-&gt;firstChild();
 782 
 783     while (node) {
 784         if (node-&gt;selfOrAncestorHasDirAutoAttribute() == flag)
 785             return;
 786 
 787         if (elementAffectsDirectionality(*node)) {
 788             if (node == lastNode)
 789                 return;
 790             node = NodeTraversal::nextSkippingChildren(*node, firstNode);
 791             continue;
 792         }
 793         node-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 794         if (node == lastNode)
 795             return;
 796         node = NodeTraversal::next(*node, firstNode);
 797     }
 798 }
 799 
 800 void HTMLElement::childrenChanged(const ChildChange&amp; change)
 801 {
 802     StyledElement::childrenChanged(change);
 803     adjustDirectionalityIfNeededAfterChildrenChanged(change.previousSiblingElement, change.type);
 804 }
 805 
 806 bool HTMLElement::hasDirectionAuto() const
 807 {
<span class="line-modified"> 808     const AtomString&amp; direction = attributeWithoutSynchronization(dirAttr);</span>
 809     return (hasTagName(bdiTag) &amp;&amp; direction.isNull()) || equalLettersIgnoringASCIICase(direction, &quot;auto&quot;);
 810 }
 811 
 812 TextDirection HTMLElement::directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const
 813 {
 814     if (!(selfOrAncestorHasDirAutoAttribute() &amp;&amp; hasDirectionAuto())) {
 815         isAuto = false;
 816         return TextDirection::LTR;
 817     }
 818 
 819     isAuto = true;
 820     return directionality();
 821 }
 822 
 823 TextDirection HTMLElement::directionality(Node** strongDirectionalityTextNode) const
 824 {
 825     if (isTextField()) {
 826         HTMLTextFormControlElement&amp; textElement = downcast&lt;HTMLTextFormControlElement&gt;(const_cast&lt;HTMLElement&amp;&gt;(*this));
 827         bool hasStrongDirectionality;
 828         UCharDirection textDirection = textElement.value().defaultWritingDirection(&amp;hasStrongDirectionality);
</pre>
<hr />
<pre>
 848                 continue;
 849             }
 850         }
 851 
 852         if (node-&gt;isTextNode()) {
 853             bool hasStrongDirectionality;
 854             UCharDirection textDirection = node-&gt;textContent(true).defaultWritingDirection(&amp;hasStrongDirectionality);
 855             if (hasStrongDirectionality) {
 856                 if (strongDirectionalityTextNode)
 857                     *strongDirectionalityTextNode = node.get();
 858                 return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 859             }
 860         }
 861         node = NodeTraversal::next(*node, this);
 862     }
 863     if (strongDirectionalityTextNode)
 864         *strongDirectionalityTextNode = nullptr;
 865     return TextDirection::LTR;
 866 }
 867 
<span class="line-modified"> 868 void HTMLElement::dirAttributeChanged(const AtomString&amp; value)</span>
 869 {
 870     RefPtr&lt;Element&gt; parent = parentElement();
 871 
 872     if (is&lt;HTMLElement&gt;(parent) &amp;&amp; parent-&gt;selfOrAncestorHasDirAutoAttribute())
 873         downcast&lt;HTMLElement&gt;(*parent).adjustDirectionalityIfNeededAfterChildAttributeChanged(this);
 874 
 875     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 876         calculateAndAdjustDirectionality();
 877 }
 878 
 879 void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)
 880 {
 881     ASSERT(selfOrAncestorHasDirAutoAttribute());
 882     Node* strongDirectionalityTextNode;
 883     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 884     setHasDirAutoFlagRecursively(child, false);
 885     if (!renderer() || renderer()-&gt;style().direction() == textDirection)
 886         return;
 887     for (auto&amp; elementToAdjust : elementLineage(this)) {
 888         if (elementAffectsDirectionality(elementToAdjust)) {
</pre>
<hr />
<pre>
1053 }
1054 
1055 bool HTMLElement::canBeActuallyDisabled() const
1056 {
1057     return is&lt;HTMLButtonElement&gt;(*this)
1058         || is&lt;HTMLInputElement&gt;(*this)
1059         || is&lt;HTMLSelectElement&gt;(*this)
1060         || is&lt;HTMLTextAreaElement&gt;(*this)
1061         || is&lt;HTMLOptGroupElement&gt;(*this)
1062         || is&lt;HTMLOptionElement&gt;(*this)
1063         || is&lt;HTMLFieldSetElement&gt;(*this);
1064 }
1065 
1066 bool HTMLElement::isActuallyDisabled() const
1067 {
1068     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1069 }
1070 
1071 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)
1072 
<span class="line-modified">1073 const AtomString&amp; HTMLElement::autocapitalize() const</span>
1074 {
1075     return stringForAutocapitalizeType(autocapitalizeType());
1076 }
1077 
1078 AutocapitalizeType HTMLElement::autocapitalizeType() const
1079 {
1080     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1081 }
1082 
<span class="line-modified">1083 void HTMLElement::setAutocapitalize(const AtomString&amp; value)</span>
1084 {
1085     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1086 }
1087 
1088 bool HTMLElement::shouldAutocorrect() const
1089 {
1090     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1091     // Unrecognized values fall back to &quot;on&quot;.
1092     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1093 }
1094 
1095 void HTMLElement::setAutocorrect(bool autocorrect)
1096 {
<span class="line-modified">1097     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomString(&quot;on&quot;, AtomString::ConstructFromLiteral) : AtomString(&quot;off&quot;, AtomString::ConstructFromLiteral));</span>
1098 }
1099 
1100 #endif
1101 
1102 InputMode HTMLElement::canonicalInputMode() const
1103 {
<span class="line-modified">1104     auto mode = inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));</span>
<span class="line-added">1105     if (mode == InputMode::Unspecified) {</span>
<span class="line-added">1106         if (document().quirks().needsInputModeNoneImplicitly(*this))</span>
<span class="line-added">1107             return InputMode::None;</span>
<span class="line-added">1108     }</span>
<span class="line-added">1109     return mode;</span>
1110 }
1111 
<span class="line-modified">1112 const AtomString&amp; HTMLElement::inputMode() const</span>
1113 {
1114     return stringForInputMode(canonicalInputMode());
1115 }
1116 
<span class="line-modified">1117 void HTMLElement::setInputMode(const AtomString&amp; value)</span>
1118 {
1119     setAttributeWithoutSynchronization(inputmodeAttr, value);
1120 }
1121 
1122 } // namespace WebCore
1123 
1124 #ifndef NDEBUG
1125 
1126 // For use in the debugger
1127 void dumpInnerHTML(WebCore::HTMLElement*);
1128 
1129 void dumpInnerHTML(WebCore::HTMLElement* element)
1130 {
1131     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1132 }
1133 
1134 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>