<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;ContainerNodeAlgorithms.h&quot;
  39 #include &quot;CustomElementReactionQueue.h&quot;
  40 #include &quot;CustomElementRegistry.h&quot;
  41 #include &quot;DOMRect.h&quot;
  42 #include &quot;DOMRectList.h&quot;
  43 #include &quot;DOMTokenList.h&quot;
  44 #include &quot;DOMWindow.h&quot;
  45 #include &quot;DocumentSharedObjectPool.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;ElementRareData.h&quot;
  50 #include &quot;EventDispatcher.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FocusEvent.h&quot;
  55 #include &quot;Frame.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;

  58 #include &quot;HTMLBodyElement.h&quot;
  59 #include &quot;HTMLCanvasElement.h&quot;
  60 #include &quot;HTMLCollection.h&quot;
  61 #include &quot;HTMLDocument.h&quot;
  62 #include &quot;HTMLHtmlElement.h&quot;
  63 #include &quot;HTMLLabelElement.h&quot;
  64 #include &quot;HTMLNameCollection.h&quot;
  65 #include &quot;HTMLObjectElement.h&quot;
  66 #include &quot;HTMLOptGroupElement.h&quot;
  67 #include &quot;HTMLOptionElement.h&quot;
  68 #include &quot;HTMLParserIdioms.h&quot;
  69 #include &quot;HTMLSelectElement.h&quot;
  70 #include &quot;HTMLTemplateElement.h&quot;
  71 #include &quot;IdChangeInvalidation.h&quot;
  72 #include &quot;IdTargetObserverRegistry.h&quot;
  73 #include &quot;InspectorInstrumentation.h&quot;
  74 #include &quot;JSLazyEventListener.h&quot;
  75 #include &quot;KeyboardEvent.h&quot;
  76 #include &quot;KeyframeEffect.h&quot;
  77 #include &quot;MutationObserverInterestGroup.h&quot;
  78 #include &quot;MutationRecord.h&quot;
  79 #include &quot;NodeRenderStyle.h&quot;
  80 #include &quot;PlatformWheelEvent.h&quot;
  81 #include &quot;PointerCaptureController.h&quot;

  82 #include &quot;PointerLockController.h&quot;
  83 #include &quot;RenderFragmentContainer.h&quot;
  84 #include &quot;RenderLayer.h&quot;
  85 #include &quot;RenderLayerBacking.h&quot;
  86 #include &quot;RenderLayerCompositor.h&quot;
  87 #include &quot;RenderListBox.h&quot;
  88 #include &quot;RenderTheme.h&quot;
  89 #include &quot;RenderTreeUpdater.h&quot;
  90 #include &quot;RenderView.h&quot;
  91 #include &quot;RenderWidget.h&quot;
  92 #include &quot;RuntimeEnabledFeatures.h&quot;
  93 #include &quot;SVGDocumentExtensions.h&quot;
  94 #include &quot;SVGElement.h&quot;
  95 #include &quot;SVGNames.h&quot;
  96 #include &quot;SVGSVGElement.h&quot;
  97 #include &quot;ScriptDisallowedScope.h&quot;
  98 #include &quot;ScrollIntoViewOptions.h&quot;
  99 #include &quot;ScrollLatchingState.h&quot;
 100 #include &quot;SelectorQuery.h&quot;
 101 #include &quot;Settings.h&quot;
</pre>
<hr />
<pre>
 150     return attrNodeListMap().add(&amp;element, Vector&lt;RefPtr&lt;Attr&gt;&gt;()).iterator-&gt;value;
 151 }
 152 
 153 static void removeAttrNodeListForElement(Element&amp; element)
 154 {
 155     ASSERT(element.hasSyntheticAttrChildNodes());
 156     ASSERT(attrNodeListMap().contains(&amp;element));
 157     attrNodeListMap().remove(&amp;element);
 158     element.setHasSyntheticAttrChildNodes(false);
 159 }
 160 
 161 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const QualifiedName&amp; name)
 162 {
 163     for (auto&amp; node : attrNodeList) {
 164         if (node-&gt;qualifiedName().matches(name))
 165             return node.get();
 166     }
 167     return nullptr;
 168 }
 169 
<span class="line-modified"> 170 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)</span>
 171 {
<span class="line-modified"> 172     const AtomicString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;</span>
 173     for (auto&amp; node : attrNodeList) {
 174         if (node-&gt;qualifiedName().localName() == caseAdjustedName)
 175             return node.get();
 176     }
 177     return nullptr;
 178 }
 179 
 180 Ref&lt;Element&gt; Element::create(const QualifiedName&amp; tagName, Document&amp; document)
 181 {
 182     return adoptRef(*new Element(tagName, document, CreateElement));
 183 }
 184 
 185 Element::Element(const QualifiedName&amp; tagName, Document&amp; document, ConstructionType type)
 186     : ContainerNode(document, type)
 187     , m_tagName(tagName)
 188 {
 189 }
 190 
 191 Element::~Element()
 192 {
 193     ASSERT(!beforePseudoElement());
 194     ASSERT(!afterPseudoElement());
 195 
 196 #if ENABLE(INTERSECTION_OBSERVER)
 197     disconnectFromIntersectionObservers();
 198 #endif
 199 




 200     removeShadowRoot();
 201 
 202     if (hasSyntheticAttrChildNodes())
 203         detachAllAttrNodesFromElement();
 204 







 205     if (hasPendingResources()) {
 206         document().accessSVGExtensions().removeElementFromPendingResources(*this);
 207         ASSERT(!hasPendingResources());
 208     }
 209 }
 210 
 211 inline ElementRareData* Element::elementRareData() const
 212 {
 213     ASSERT_WITH_SECURITY_IMPLICATION(hasRareData());
 214     return static_cast&lt;ElementRareData*&gt;(rareData());
 215 }
 216 
 217 inline ElementRareData&amp; Element::ensureElementRareData()
 218 {
 219     return static_cast&lt;ElementRareData&amp;&gt;(ensureRareData());
 220 }
 221 
 222 void Element::clearTabIndexExplicitlyIfNeeded()
 223 {
 224     if (hasRareData())
 225         elementRareData()-&gt;clearTabIndexExplicitly();
 226 }
 227 
 228 void Element::setTabIndexExplicitly(int tabIndex)
 229 {
 230     ensureElementRareData().setTabIndexExplicitly(tabIndex);
 231 }
 232 
<span class="line-modified"> 233 bool Element::tabIndexSetExplicitly() const</span>
 234 {
<span class="line-modified"> 235     return hasRareData() &amp;&amp; elementRareData()-&gt;tabIndexSetExplicitly();</span>







 236 }
 237 
 238 bool Element::supportsFocus() const
 239 {
<span class="line-modified"> 240     return tabIndexSetExplicitly();</span>
 241 }
 242 
 243 RefPtr&lt;Element&gt; Element::focusDelegate()
 244 {
 245     return this;
 246 }
 247 
<span class="line-modified"> 248 int Element::tabIndex() const</span>
 249 {
<span class="line-modified"> 250     return hasRareData() ? elementRareData()-&gt;tabIndex() : 0;</span>





 251 }
 252 
<span class="line-modified"> 253 void Element::setTabIndex(int value)</span>
 254 {
 255     setIntegralAttribute(tabindexAttr, value);
 256 }
 257 
 258 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 259 {
<span class="line-modified"> 260     return isFocusable() &amp;&amp; tabIndex() &gt;= 0;</span>
 261 }
 262 
 263 bool Element::isMouseFocusable() const
 264 {
 265     return isFocusable();
 266 }
 267 
 268 bool Element::shouldUseInputMethod()
 269 {
 270     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 271 }
 272 
 273 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 274 {
 275     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 276 }
 277 
<span class="line-modified"> 278 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomicString&amp; eventType, int detail, Element* relatedTarget)</span>









 279 {
 280     if (isDisabledFormControl())
 281         return false;
 282 
 283     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
 284         return false;
 285 
 286     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
 287 
 288     if (mouseEvent-&gt;type().isEmpty())
 289         return true; // Shouldn&#39;t happen.
 290 

























 291     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 292     dispatchEvent(mouseEvent);
<span class="line-modified"> 293     bool didNotSwallowEvent = !mouseEvent-&gt;defaultPrevented() &amp;&amp; !mouseEvent-&gt;defaultHandled();</span>

 294 
 295     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 296         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 297         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 298         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 299         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 300         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 301             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 302             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 303             Event::IsComposed::Yes,
 304             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 305             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 306             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 307 
 308         if (mouseEvent-&gt;defaultHandled())
 309             doubleClickEvent-&gt;setDefaultHandled();
 310 
 311         dispatchEvent(doubleClickEvent);
 312         if (doubleClickEvent-&gt;defaultHandled() || doubleClickEvent-&gt;defaultPrevented())
 313             return false;
</pre>
<hr />
<pre>
 412         return false;
 413 
 414     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 415     return true;
 416 }
 417 
 418 void Element::setBooleanAttribute(const QualifiedName&amp; name, bool value)
 419 {
 420     if (value)
 421         setAttribute(name, emptyAtom());
 422     else
 423         removeAttribute(name);
 424 }
 425 
 426 NamedNodeMap&amp; Element::attributes() const
 427 {
 428     ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
 429     if (NamedNodeMap* attributeMap = rareData.attributeMap())
 430         return *attributeMap;
 431 
<span class="line-modified"> 432     rareData.setAttributeMap(std::make_unique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));</span>
 433     return *rareData.attributeMap();
 434 }
 435 
 436 Node::NodeType Element::nodeType() const
 437 {
 438     return ELEMENT_NODE;
 439 }
 440 
 441 bool Element::hasAttribute(const QualifiedName&amp; name) const
 442 {
 443     return hasAttributeNS(name.namespaceURI(), name.localName());
 444 }
 445 
 446 void Element::synchronizeAllAttributes() const
 447 {
 448     if (!elementData())
 449         return;
 450     if (elementData()-&gt;styleAttributeIsDirty()) {
 451         ASSERT(isStyledElement());
 452         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 453     }
 454 
<span class="line-modified"> 455     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {</span>
<span class="line-modified"> 456         ASSERT(isSVGElement());</span>
<span class="line-removed"> 457         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(anyQName());</span>
<span class="line-removed"> 458     }</span>
 459 }
 460 
 461 ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
 462 {
 463     if (!elementData())
 464         return;
 465     if (UNLIKELY(name == styleAttr &amp;&amp; elementData()-&gt;styleAttributeIsDirty())) {
 466         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 467         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 468         return;
 469     }
 470 
<span class="line-modified"> 471     if (UNLIKELY(elementData()-&gt;animatedSVGAttributesAreDirty())) {</span>
<span class="line-modified"> 472         ASSERT(isSVGElement());</span>
<span class="line-removed"> 473         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(name);</span>
<span class="line-removed"> 474     }</span>
 475 }
 476 
<span class="line-modified"> 477 static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomicString&amp; attributeLocalName)</span>
 478 {
 479     if (shouldIgnoreAttributeCase(element))
 480         return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
 481     return attributeLocalName == styleAttr-&gt;localName();
 482 }
 483 
<span class="line-modified"> 484 ALWAYS_INLINE void Element::synchronizeAttribute(const AtomicString&amp; localName) const</span>
 485 {
 486     // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
 487     // e.g when called from DOM API.
 488     if (!elementData())
 489         return;
 490     if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
 491         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 492         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 493         return;
 494     }
<span class="line-modified"> 495     if (elementData()-&gt;animatedSVGAttributesAreDirty()) {</span>
<span class="line-modified"> 496         // We&#39;re not passing a namespace argument on purpose. SVGNames::*Attr are defined w/o namespaces as well.</span>
<span class="line-modified"> 497         ASSERT_WITH_SECURITY_IMPLICATION(isSVGElement());</span>
<span class="line-removed"> 498         downcast&lt;SVGElement&gt;(*this).synchronizeAnimatedSVGAttribute(QualifiedName(nullAtom(), localName, nullAtom()));</span>
<span class="line-removed"> 499     }</span>
 500 }
 501 
<span class="line-modified"> 502 const AtomicString&amp; Element::getAttribute(const QualifiedName&amp; name) const</span>
 503 {
 504     if (!elementData())
 505         return nullAtom();
 506     synchronizeAttribute(name);
 507     if (const Attribute* attribute = findAttributeByName(name))
 508         return attribute-&gt;value();
 509     return nullAtom();
 510 }
 511 
 512 Vector&lt;String&gt; Element::getAttributeNames() const
 513 {
 514     Vector&lt;String&gt; attributesVector;
 515     if (!hasAttributes())
 516         return attributesVector;
 517 
 518     auto attributes = attributesIterator();
 519     attributesVector.reserveInitialCapacity(attributes.attributeCount());
 520     for (auto&amp; attribute : attributes)
 521         attributesVector.uncheckedAppend(attribute.name().toString());
 522     return attributesVector;
 523 }
 524 
 525 bool Element::isFocusable() const
 526 {
 527     if (!isConnected() || !supportsFocus())
 528         return false;
 529 
 530     if (!renderer()) {
 531         // If the node is in a display:none tree it might say it needs style recalc but
 532         // the whole document is actually up to date.
<span class="line-modified"> 533         ASSERT(!needsStyleRecalc() || !document().childNeedsStyleRecalc());</span>

 534 
 535         // Elements in canvas fallback content are not rendered, but they are allowed to be
 536         // focusable as long as their canvas is displayed and visible.
 537         if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
 538             return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
 539     }
 540 
 541     // FIXME: Even if we are not visible, we might have a child that is visible.
 542     // Hyatt wants to fix that some day with a &quot;has visible content&quot; flag or the like.
 543     if (!renderer() || renderer()-&gt;style().visibility() != Visibility::Visible)
 544         return false;
 545 
 546     return true;
 547 }
 548 
 549 bool Element::isUserActionElementInActiveChain() const
 550 {
 551     ASSERT(isUserActionElement());
 552     return document().userActionElements().isInActiveChain(*this);
 553 }
</pre>
<hr />
<pre>
 641     auto* style = renderOrDisplayContentsStyle();
 642     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 643         invalidateStyleForSubtree();
 644 
 645     if (!renderer()) {
 646         // When setting hover to false, the style needs to be recalc&#39;d even when
 647         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 648         // if a nil renderer would prevent this element from recalculating its
 649         // style, it would never go back to its normal style and remain
 650         // stuck in its hovered style).
 651         if (!flag &amp;&amp; !style)
 652             invalidateStyleForSubtree();
 653 
 654         return;
 655     }
 656 
 657     if (style-&gt;hasAppearance())
 658         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
 659 }
 660 
<span class="line-modified"> 661 // FIXME(webkit.org/b/161611): Take into account orientation/direction.</span>
<span class="line-removed"> 662 inline ScrollAlignment toScrollAlignment(Optional&lt;ScrollLogicalPosition&gt; position, bool isVertical)</span>
 663 {
<span class="line-modified"> 664     switch (position.valueOr(isVertical ? ScrollLogicalPosition::Start : ScrollLogicalPosition::Nearest)) {</span>
<span class="line-modified"> 665     case ScrollLogicalPosition::Start:</span>
<span class="line-modified"> 666         return isVertical ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignLeftAlways;</span>













 667     case ScrollLogicalPosition::Center:
 668         return ScrollAlignment::alignCenterAlways;
<span class="line-modified"> 669     case ScrollLogicalPosition::End:</span>
<span class="line-modified"> 670         return isVertical ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignRightAlways;</span>
























































 671     case ScrollLogicalPosition::Nearest:
 672         return ScrollAlignment::alignToEdgeIfNeeded;
 673     default:
 674         ASSERT_NOT_REACHED();
 675         return ScrollAlignment::alignToEdgeIfNeeded;
 676     }
 677 }
 678 
 679 void Element::scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg)
 680 {
 681     document().updateLayoutIgnorePendingStylesheets();
 682 
 683     if (!renderer())
 684         return;
 685 
 686     bool insideFixed;
 687     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 688 
 689     // FIXME(webkit.org/b/188043): Support ScrollBehavior.
 690     ScrollIntoViewOptions options;
 691     if (arg) {
 692         auto value = arg.value();
 693         if (WTF::holds_alternative&lt;ScrollIntoViewOptions&gt;(value))
 694             options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
 695         else if (!WTF::get&lt;bool&gt;(value))
 696             options.blockPosition = ScrollLogicalPosition::End;
 697     }
 698 
<span class="line-modified"> 699     ScrollAlignment alignX = toScrollAlignment(options.inlinePosition, false);</span>
<span class="line-modified"> 700     ScrollAlignment alignY = toScrollAlignment(options.blockPosition, true);</span>
<span class="line-modified"> 701     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, alignX, alignY, ShouldAllowCrossOriginScrolling::No });</span>









 702 }
 703 
 704 void Element::scrollIntoView(bool alignToTop)
 705 {
 706     document().updateLayoutIgnorePendingStylesheets();
 707 
 708     if (!renderer())
 709         return;
 710 
 711     bool insideFixed;
 712     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 713     // Align to the top / bottom and to the closest edge.
 714     if (alignToTop)
 715         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
 716     else
 717         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignBottomAlways, ShouldAllowCrossOriginScrolling::No });
 718 }
 719 
 720 void Element::scrollIntoViewIfNeeded(bool centerIfNeeded)
 721 {
</pre>
<hr />
<pre>
 776         // invoke scroll() on window with options as the only argument, and terminate these steps.
 777         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 778         auto window = makeRefPtr(document().domWindow());
 779         if (!window)
 780             return;
 781 
 782         window-&gt;scrollTo(options);
 783         return;
 784     }
 785 
 786     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 787     // or the element has no overflow, terminate these steps.
 788     RenderBox* renderer = renderBox();
 789     if (!renderer || !renderer-&gt;hasOverflowClip())
 790         return;
 791 
 792     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 793         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 794         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 795     );
<span class="line-modified"> 796     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), clamping);</span>
<span class="line-modified"> 797     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), clamping);</span>
 798 }
 799 
 800 void Element::scrollTo(double x, double y)
 801 {
 802     scrollTo({ x, y });
 803 }
 804 
 805 void Element::scrollByUnits(int units, ScrollGranularity granularity)
 806 {
 807     document().updateLayoutIgnorePendingStylesheets();
 808 
 809     auto* renderer = this-&gt;renderer();
 810     if (!renderer)
 811         return;
 812 
 813     if (!renderer-&gt;hasOverflowClip())
 814         return;
 815 
 816     ScrollDirection direction = ScrollDown;
 817     if (units &lt; 0) {
</pre>
<hr />
<pre>
1098             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().y(), *frame);
1099         return 0;
1100     }
1101 
1102     if (RenderBox* renderer = renderBox())
1103         return adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer);
1104     return 0;
1105 }
1106 
1107 void Element::setScrollLeft(int newLeft)
1108 {
1109     document().updateLayoutIgnorePendingStylesheets();
1110 
1111     if (document().scrollingElement() == this) {
1112         if (auto* frame = documentFrameWithNonNullView())
1113             frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
1114         return;
1115     }
1116 
1117     if (auto* renderer = renderBox()) {
<span class="line-modified">1118         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()));</span>
1119         if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">1120             scrollableArea-&gt;setScrolledProgrammatically(true);</span>
1121     }
1122 }
1123 
1124 void Element::setScrollTop(int newTop)
1125 {
1126     document().updateLayoutIgnorePendingStylesheets();
1127 
1128     if (document().scrollingElement() == this) {
1129         if (auto* frame = documentFrameWithNonNullView())
1130             frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
1131         return;
1132     }
1133 
1134     if (auto* renderer = renderBox()) {
<span class="line-modified">1135         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()));</span>
1136         if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">1137             scrollableArea-&gt;setScrolledProgrammatically(true);</span>
1138     }
1139 }
1140 
1141 int Element::scrollWidth()
1142 {
1143     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1144 
1145     if (document().scrollingElement() == this) {
1146         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1147         document().updateLayoutIgnorePendingStylesheets();
1148         if (auto* frame = documentFrameWithNonNullView())
1149             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsWidth(), *frame);
1150         return 0;
1151     }
1152 
1153     if (auto* renderer = renderBox())
1154         return adjustForAbsoluteZoom(renderer-&gt;scrollWidth(), *renderer);
1155     return 0;
1156 }
1157 
</pre>
<hr />
<pre>
1372 
1373     RenderObject* renderer = this-&gt;renderer();
1374     Vector&lt;FloatQuad&gt; quads;
1375 
1376     if (auto pair = listBoxElementBoundingBox(*this)) {
1377         renderer = pair.value().first;
1378         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1379     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1380         renderBoxModelObject-&gt;absoluteQuads(quads);
1381 
1382     // FIXME: Handle SVG elements.
1383     // FIXME: Handle table/inline-table with a caption.
1384 
1385     if (quads.isEmpty())
1386         return DOMRectList::create();
1387 
1388     document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
1389     return DOMRectList::create(quads);
1390 }
1391 
<span class="line-modified">1392 FloatRect Element::boundingClientRect()</span>
1393 {
<span class="line-removed">1394     document().updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">1395 </span>
1396     RenderObject* renderer = this-&gt;renderer();
1397     Vector&lt;FloatQuad&gt; quads;
1398     if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
1399         // Get the bounding rectangle from the SVG model.
1400         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1401         FloatRect localRect;
1402         if (svgElement.getBoundingBox(localRect))
1403             quads.append(renderer-&gt;localToAbsoluteQuad(localRect));
1404     } else if (auto pair = listBoxElementBoundingBox(*this)) {
1405         renderer = pair.value().first;
1406         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1407     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1408         renderBoxModelObject-&gt;absoluteQuads(quads);
1409 
1410     if (quads.isEmpty())
<span class="line-modified">1411         return { };</span>
1412 
1413     FloatRect result = quads[0].boundingBox();
1414     for (size_t i = 1; i &lt; quads.size(); ++i)
1415         result.unite(quads[i].boundingBox());
1416 











1417     document().convertAbsoluteToClientRect(result, renderer-&gt;style());
1418     return result;
1419 }
1420 
1421 Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
1422 {
1423     return DOMRect::create(boundingClientRect());
1424 }
1425 
1426 // Note that this is not web-exposed, and does not use the same coordinate system as getBoundingClientRect() and friends.
1427 IntRect Element::clientRect() const
1428 {
1429     if (RenderObject* renderer = this-&gt;renderer())
1430         return document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
1431     return IntRect();
1432 }
1433 
1434 IntRect Element::screenRect() const
1435 {
1436     if (RenderObject* renderer = this-&gt;renderer())
1437         return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
1438     return IntRect();
1439 }
1440 
<span class="line-modified">1441 const AtomicString&amp; Element::getAttribute(const AtomicString&amp; qualifiedName) const</span>
1442 {
1443     if (!elementData())
1444         return nullAtom();
1445     synchronizeAttribute(qualifiedName);
1446     if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
1447         return attribute-&gt;value();
1448     return nullAtom();
1449 }
1450 
<span class="line-modified">1451 const AtomicString&amp; Element::getAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const</span>
1452 {
1453     return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
1454 }
1455 
1456 // https://dom.spec.whatwg.org/#dom-element-toggleattribute
<span class="line-modified">1457 ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomicString&amp; qualifiedName, Optional&lt;bool&gt; force)</span>
1458 {
1459     if (!Document::isValidName(qualifiedName))
1460         return Exception { InvalidCharacterError };
1461 
1462     synchronizeAttribute(qualifiedName);
1463 
1464     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1465     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1466     if (index == ElementData::attributeNotFound) {
1467         if (!force || *force) {
1468             setAttributeInternal(index, QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() }, emptyString(), NotInSynchronizationOfLazyAttribute);
1469             return true;
1470         }
1471         return false;
1472     }
1473 
1474     if (!force || !*force) {
1475         removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
1476         return false;
1477     }
1478     return true;
1479 }
1480 
<span class="line-modified">1481 ExceptionOr&lt;void&gt; Element::setAttribute(const AtomicString&amp; qualifiedName, const AtomicString&amp; value)</span>
1482 {
1483     if (!Document::isValidName(qualifiedName))
1484         return Exception { InvalidCharacterError };
1485 
1486     synchronizeAttribute(qualifiedName);
1487     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1488     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1489     auto name = index != ElementData::attributeNotFound ? attributeAt(index).name() : QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() };
1490     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1491 
1492     return { };
1493 }
1494 
<span class="line-modified">1495 void Element::setAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
1496 {
1497     synchronizeAttribute(name);
1498     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1499     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1500 }
1501 
<span class="line-modified">1502 void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
1503 {
1504     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1505     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1506 }
1507 
<span class="line-modified">1508 void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
1509 {
1510     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1511     setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
1512 }
1513 
<span class="line-modified">1514 inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomicString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
1515 {
1516     if (newValue.isNull()) {
1517         if (index != ElementData::attributeNotFound)
1518             removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
1519         return;
1520     }
1521 
1522     if (index == ElementData::attributeNotFound) {
1523         addAttributeInternal(name, newValue, inSynchronizationOfLazyAttribute);
1524         return;
1525     }
1526 
1527     if (inSynchronizationOfLazyAttribute) {
1528         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1529         return;
1530     }
1531 
1532     const Attribute&amp; attribute = attributeAt(index);
1533     QualifiedName attributeName = attribute.name();
<span class="line-modified">1534     AtomicString oldValue = attribute.value();</span>
1535 
1536     willModifyAttribute(attributeName, oldValue, newValue);
1537 
1538     if (newValue != oldValue) {
1539         Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
1540         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1541     }
1542 
1543     didModifyAttribute(attributeName, oldValue, newValue);
1544 }
1545 
<span class="line-modified">1546 static inline AtomicString makeIdForStyleResolution(const AtomicString&amp; value, bool inQuirksMode)</span>
1547 {
1548     if (inQuirksMode)
1549         return value.convertToASCIILowercase();
1550     return value;
1551 }
1552 
<span class="line-modified">1553 void Element::attributeChanged(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason)</span>
1554 {
1555     bool valueIsSameAsBefore = oldValue == newValue;
1556 
1557     if (!valueIsSameAsBefore) {
1558         if (name == HTMLNames::accesskeyAttr)
1559             document().invalidateAccessKeyCache();
1560         else if (name == HTMLNames::classAttr)
1561             classAttributeChanged(newValue);
1562         else if (name == HTMLNames::idAttr) {
<span class="line-modified">1563             AtomicString oldId = elementData()-&gt;idForStyleResolution();</span>
<span class="line-modified">1564             AtomicString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());</span>
1565             if (newId != oldId) {
1566                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1567                 elementData()-&gt;setIdForStyleResolution(newId);
1568             }
1569 
1570             if (!oldValue.isEmpty())
1571                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1572             if (!newValue.isEmpty())
1573                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1574         } else if (name == HTMLNames::nameAttr)
1575             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1576         else if (name == HTMLNames::pseudoAttr) {
1577             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1578                 invalidateStyleForSubtree();
1579         } else if (name == HTMLNames::slotAttr) {
1580             if (auto* parent = parentElement()) {
1581                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1582                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1583             }
1584         }
</pre>
<hr />
<pre>
1598 
1599     if (AXObjectCache* cache = document().existingAXObjectCache())
1600         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1601 }
1602 
1603 template &lt;typename CharacterType&gt;
1604 static inline bool classStringHasClassName(const CharacterType* characters, unsigned length)
1605 {
1606     ASSERT(length &gt; 0);
1607 
1608     unsigned i = 0;
1609     do {
1610         if (isNotHTMLSpace(characters[i]))
1611             break;
1612         ++i;
1613     } while (i &lt; length);
1614 
1615     return i &lt; length;
1616 }
1617 
<span class="line-modified">1618 static inline bool classStringHasClassName(const AtomicString&amp; newClassString)</span>
1619 {
1620     unsigned length = newClassString.length();
1621 
1622     if (!length)
1623         return false;
1624 
1625     if (newClassString.is8Bit())
1626         return classStringHasClassName(newClassString.characters8(), length);
1627     return classStringHasClassName(newClassString.characters16(), length);
1628 }
1629 
<span class="line-modified">1630 void Element::classAttributeChanged(const AtomicString&amp; newClassString)</span>
1631 {
1632     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1633     if (!elementData())
1634         ensureUniqueElementData();
1635 
1636     bool shouldFoldCase = document().inQuirksMode();
1637     bool newStringHasClasses = classStringHasClassName(newClassString);
1638 
1639     auto oldClassNames = elementData()-&gt;classNames();
1640     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1641     {
1642         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1643         elementData()-&gt;setClassNames(newClassNames);
1644     }
1645 
1646     if (hasRareData()) {
1647         if (auto* classList = elementRareData()-&gt;classList())
1648             classList-&gt;associatedAttributeValueChanged(newClassString);
1649     }
1650 }
1651 
1652 URL Element::absoluteLinkURL() const
1653 {
1654     if (!isLink())
1655         return URL();
1656 
<span class="line-modified">1657     AtomicString linkAttribute;</span>
1658     if (hasTagName(SVGNames::aTag))
1659         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1660     else
1661         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1662 
1663     if (linkAttribute.isEmpty())
1664         return URL();
1665 
1666     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1667 }
1668 
1669 #if ENABLE(TOUCH_EVENTS)
1670 bool Element::allowsDoubleTapGesture() const
1671 {
1672 #if ENABLE(POINTER_EVENTS)
1673     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1674         return false;
1675 #endif
1676 
1677     Element* parent = parentElement();
</pre>
<hr />
<pre>
1855     other.synchronizeAllAttributes();
1856     if (elementData() == other.elementData())
1857         return true;
1858     if (elementData())
1859         return elementData()-&gt;isEquivalent(other.elementData());
1860     if (other.elementData())
1861         return other.elementData()-&gt;isEquivalent(elementData());
1862     return true;
1863 }
1864 
1865 String Element::nodeName() const
1866 {
1867     return m_tagName.toString();
1868 }
1869 
1870 String Element::nodeNamePreservingCase() const
1871 {
1872     return m_tagName.toString();
1873 }
1874 
<span class="line-modified">1875 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomicString&amp; prefix)</span>
1876 {
1877     auto result = checkSetPrefix(prefix);
1878     if (result.hasException())
1879         return result.releaseException();
1880 
1881     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
1882     return { };
1883 }
1884 
<span class="line-modified">1885 const AtomicString&amp; Element::imageSourceURL() const</span>
1886 {
1887     return attributeWithoutSynchronization(srcAttr);
1888 }
1889 
1890 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
1891 {
1892     return style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;
1893 }
1894 
1895 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1896 {
1897     return RenderElement::createFor(*this, WTFMove(style));
1898 }
1899 
1900 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1901 {
1902     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1903 
1904 #if ENABLE(FULLSCREEN_API)
1905     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
1906         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
1907 #endif
1908 
1909     if (parentNode() == &amp;parentOfInsertedTree) {
1910         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
1911             shadowRoot-&gt;hostChildElementDidChange(*this);
1912     }
1913 
1914     if (!parentOfInsertedTree.isInTreeScope())
1915         return InsertedIntoAncestorResult::Done;
1916 
1917     bool becomeConnected = insertionType.connectedToDocument;
1918     TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
1919     HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
1920     if (!insertionType.treeScopeChanged)
1921         newScope = nullptr;
1922 
<span class="line-modified">1923     const AtomicString&amp; idValue = getIdAttribute();</span>
1924     if (!idValue.isNull()) {
1925         if (newScope)
1926             updateIdForTreeScope(*newScope, nullAtom(), idValue);
1927         if (newDocument)
1928             updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
1929     }
1930 
<span class="line-modified">1931     const AtomicString&amp; nameValue = getNameAttribute();</span>
1932     if (!nameValue.isNull()) {
1933         if (newScope)
1934             updateNameForTreeScope(*newScope, nullAtom(), nameValue);
1935         if (newDocument)
1936             updateNameForDocument(*newDocument, nullAtom(), nameValue);
1937     }
1938 
1939     if (newScope &amp;&amp; hasTagName(labelTag)) {
1940         if (newScope-&gt;shouldCacheLabelsByForAttribute())
1941             updateLabel(*newScope, nullAtom(), attributeWithoutSynchronization(forAttr));
1942     }
1943 
1944     if (becomeConnected) {
1945         if (UNLIKELY(isCustomElementUpgradeCandidate())) {
1946             ASSERT(isConnected());
1947             CustomElementReactionQueue::enqueueElementUpgradeIfDefined(*this);
1948         }
1949         if (UNLIKELY(isDefinedCustomElement()))
1950             CustomElementReactionQueue::enqueueConnectedCallbackIfNeeded(*this);
1951     }
1952 
1953     if (UNLIKELY(hasTagName(articleTag) &amp;&amp; newDocument))
1954         newDocument-&gt;registerArticleElement(*this);
1955 
1956     return InsertedIntoAncestorResult::Done;
1957 }
1958 
1959 void Element::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1960 {
1961 #if ENABLE(FULLSCREEN_API)
1962     if (containsFullScreenElement())
1963         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
1964 #endif
1965 #if ENABLE(POINTER_LOCK)
1966     if (document().page())
1967         document().page()-&gt;pointerLockController().elementRemoved(*this);
1968 #endif




1969 
1970     setSavedLayerScrollPosition(ScrollPosition());
1971 
1972     if (oldParentOfRemovedTree.isInTreeScope()) {
1973         TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
1974         Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
1975         HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
1976         if (!removalType.treeScopeChanged)
1977             oldScope = nullptr;
1978 
<span class="line-modified">1979         const AtomicString&amp; idValue = getIdAttribute();</span>
1980         if (!idValue.isNull()) {
1981             if (oldScope)
1982                 updateIdForTreeScope(*oldScope, idValue, nullAtom());
1983             if (oldHTMLDocument)
1984                 updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
1985         }
1986 
<span class="line-modified">1987         const AtomicString&amp; nameValue = getNameAttribute();</span>
1988         if (!nameValue.isNull()) {
1989             if (oldScope)
1990                 updateNameForTreeScope(*oldScope, nameValue, nullAtom());
1991             if (oldHTMLDocument)
1992                 updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
1993         }
1994 
1995         if (oldScope &amp;&amp; hasTagName(labelTag)) {
1996             if (oldScope-&gt;shouldCacheLabelsByForAttribute())
1997                 updateLabel(*oldScope, attributeWithoutSynchronization(forAttr), nullAtom());
1998         }
1999 
2000         if (oldDocument) {
2001             if (oldDocument-&gt;cssTarget() == this)
2002                 oldDocument-&gt;setCSSTarget(nullptr);
2003             if (UNLIKELY(hasTagName(articleTag)))
2004                 oldDocument-&gt;unregisterArticleElement(*this);
2005         }
2006 
2007         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
</pre>
<hr />
<pre>
2014     }
2015 
2016     clearBeforePseudoElement();
2017     clearAfterPseudoElement();
2018 
2019     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2020 
2021     if (hasPendingResources())
2022         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2023 
2024     RefPtr&lt;Frame&gt; frame = document().frame();
2025     if (auto* timeline = document().existingTimeline())
2026         timeline-&gt;elementWasRemoved(*this);
2027     if (frame)
2028         frame-&gt;animation().cancelAnimations(*this);
2029 
2030 #if PLATFORM(MAC)
2031     if (frame &amp;&amp; frame-&gt;page())
2032         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2033 #endif





2034 }
2035 
2036 ShadowRoot* Element::shadowRoot() const
2037 {
2038     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2039 }
2040 
2041 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2042 {
2043     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2044     ASSERT(!shadowRoot());
2045 
2046     ShadowRoot&amp; shadowRoot = newShadowRoot;
2047     {
2048         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2049         if (renderer())
2050             RenderTreeUpdater::tearDownRenderers(*this);
2051 
2052         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2053 
</pre>
<hr />
<pre>
2071 
2072 void Element::removeShadowRoot()
2073 {
2074     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2075     if (!oldRoot)
2076         return;
2077 
2078     InspectorInstrumentation::willPopShadowRoot(*this, *oldRoot);
2079     document().adjustFocusedNodeOnNodeRemoval(*oldRoot);
2080 
2081     ASSERT(!oldRoot-&gt;renderer());
2082 
2083     elementRareData()-&gt;clearShadowRoot();
2084 
2085     oldRoot-&gt;setHost(nullptr);
2086     oldRoot-&gt;setParentTreeScope(document());
2087 }
2088 
2089 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2090 {
<span class="line-modified">2091     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; tagNames = [] {</span>
2092         static const HTMLQualifiedName* const tagList[] = {
2093             &amp;articleTag.get(),
2094             &amp;asideTag.get(),
2095             &amp;blockquoteTag.get(),
2096             &amp;bodyTag.get(),
2097             &amp;divTag.get(),
2098             &amp;footerTag.get(),
2099             &amp;h1Tag.get(),
2100             &amp;h2Tag.get(),
2101             &amp;h3Tag.get(),
2102             &amp;h4Tag.get(),
2103             &amp;h5Tag.get(),
2104             &amp;h6Tag.get(),
2105             &amp;headerTag.get(),
2106             &amp;navTag.get(),
2107             &amp;pTag.get(),
2108             &amp;sectionTag.get(),
2109             &amp;spanTag.get()
2110         };
<span class="line-modified">2111         HashSet&lt;AtomicString&gt; set;</span>
2112         for (auto&amp; name : tagList)
2113             set.add(name-&gt;localName());
2114         return set;
2115     }();
2116 
2117     if (!is&lt;HTMLElement&gt;(element))
2118         return false;
2119 
2120     const auto&amp; localName = element.localName();
2121     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2122 }
2123 
2124 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2125 {
2126     if (!canAttachAuthorShadowRoot(*this))
2127         return Exception { NotSupportedError };
2128     if (shadowRoot())
2129         return Exception { InvalidStateError };
2130     if (init.mode == ShadowRootMode::UserAgent)
2131         return Exception { TypeError };
</pre>
<hr />
<pre>
2152     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2153     return shadowRoot();
2154 }
2155 
2156 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2157 {
2158     if (auto shadow = userAgentShadowRoot())
2159         return *shadow;
2160     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2161     ShadowRoot&amp; shadow = newShadow;
2162     addShadowRoot(WTFMove(newShadow));
2163     return shadow;
2164 }
2165 
2166 void Element::setIsDefinedCustomElement(JSCustomElementInterface&amp; elementInterface)
2167 {
2168     clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
2169     setFlag(IsCustomElement);
2170     auto&amp; data = ensureElementRareData();
2171     if (!data.customElementReactionQueue())
<span class="line-modified">2172         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
2173     invalidateStyleForSubtree();
2174     InspectorInstrumentation::didChangeCustomElementState(*this);
2175 }
2176 
2177 void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
2178 {
2179     ASSERT(isUndefinedCustomElement());
2180     ASSERT(getFlag(IsEditingTextOrUndefinedCustomElementFlag));
2181     clearFlag(IsCustomElement);
2182 
2183     if (hasRareData()) {
2184         // Clear the queue instead of deleting it since this function can be called inside CustomElementReactionQueue::invokeAll during upgrades.
2185         if (auto* queue = elementRareData()-&gt;customElementReactionQueue())
2186             queue-&gt;clear();
2187     }
2188     InspectorInstrumentation::didChangeCustomElementState(*this);
2189 }
2190 
2191 void Element::setIsCustomElementUpgradeCandidate()
2192 {
2193     ASSERT(!getFlag(IsCustomElement));
2194     setFlag(IsCustomElement);
2195     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2196     InspectorInstrumentation::didChangeCustomElementState(*this);
2197 }
2198 
2199 void Element::enqueueToUpgrade(JSCustomElementInterface&amp; elementInterface)
2200 {
2201     ASSERT(!isDefinedCustomElement() &amp;&amp; !isFailedCustomElement());
2202     setFlag(IsCustomElement);
2203     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2204     InspectorInstrumentation::didChangeCustomElementState(*this);
2205 
2206     auto&amp; data = ensureElementRareData();
2207     bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
2208     if (!alreadyScheduledToUpgrade)
<span class="line-modified">2209         data.setCustomElementReactionQueue(std::make_unique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
2210     data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
2211 }
2212 
2213 CustomElementReactionQueue* Element::reactionQueue() const
2214 {
2215     ASSERT(isDefinedCustomElement() || isCustomElementUpgradeCandidate());
2216     if (!hasRareData())
2217         return nullptr;
2218     return elementRareData()-&gt;customElementReactionQueue();
2219 }
2220 
<span class="line-modified">2221 const AtomicString&amp; Element::shadowPseudoId() const</span>
2222 {
2223     return pseudo();
2224 }
2225 
2226 bool Element::childTypeAllowed(NodeType type) const
2227 {
2228     switch (type) {
2229     case ELEMENT_NODE:
2230     case TEXT_NODE:
2231     case COMMENT_NODE:
2232     case PROCESSING_INSTRUCTION_NODE:
2233     case CDATA_SECTION_NODE:
2234         return true;
2235     default:
2236         break;
2237     }
2238     return false;
2239 }
2240 
2241 static void checkForEmptyStyleChange(Element&amp; element)
</pre>
<hr />
<pre>
2359         case ElementInserted:
2360         case ElementRemoved:
2361             // For elements, we notify shadowRoot in Element::insertedIntoAncestor and Element::removedFromAncestor.
2362             break;
2363         case AllChildrenRemoved:
2364         case AllChildrenReplaced:
2365             shadowRoot-&gt;didRemoveAllChildrenOfShadowHost();
2366             break;
2367         case TextInserted:
2368         case TextRemoved:
2369         case TextChanged:
2370             shadowRoot-&gt;didChangeDefaultSlot();
2371             break;
2372         case NonContentsChildInserted:
2373         case NonContentsChildRemoved:
2374             break;
2375         }
2376     }
2377 }
2378 
<span class="line-modified">2379 void Element::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue)</span>
2380 {
2381     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
2382 }
2383 
2384 void Element::removeAllEventListeners()
2385 {
2386     ContainerNode::removeAllEventListeners();
2387     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2388         shadowRoot-&gt;removeAllEventListeners();
2389 }
2390 
2391 void Element::beginParsingChildren()
2392 {
2393     clearIsParsingChildrenFinished();
2394 }
2395 
2396 void Element::finishParsingChildren()
2397 {
2398     ContainerNode::finishParsingChildren();
2399     setIsParsingChildrenFinished();
</pre>
<hr />
<pre>
2433     ASSERT(hasSyntheticAttrChildNodes());
2434     return *attrNodeListForElement(*this);
2435 }
2436 
2437 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2438 {
2439     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2440     if (attrNode.ownerElement() == this)
2441         return;
2442 
2443     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2444 
2445     attrNode.attachToElement(*this);
2446     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2447 }
2448 
2449 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
2450 {
2451     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2452     if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">2453         return WTFMove(oldAttrNode);</span>
2454 
2455     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2456     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2457     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2458         return Exception { InUseAttributeError };
2459 
2460     {
2461         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2462         synchronizeAllAttributes();
2463     }
2464 
2465     auto&amp; elementData = ensureUniqueElementData();
2466 
2467     auto existingAttributeIndex = elementData.findAttributeIndexByName(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2468 
2469     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2470     // before making changes to attrNode&#39;s Element connections.
2471     auto attrNodeValue = attrNode.value();
2472 
2473     if (existingAttributeIndex == ElementData::attributeNotFound) {
2474         attachAttributeNodeIfNeeded(attrNode);
2475         setAttributeInternal(elementData.findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2476     } else {
2477         const Attribute&amp; attribute = attributeAt(existingAttributeIndex);
2478         if (oldAttrNode)
2479             detachAttrNodeFromElementWithValue(oldAttrNode.get(), attribute.value());
2480         else
2481             oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), attribute.value());
2482 
2483         attachAttributeNodeIfNeeded(attrNode);
2484 
2485         if (attribute.name().matches(attrNode.qualifiedName()))
2486             setAttributeInternal(existingAttributeIndex, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2487         else {
2488             removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2489             setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2490         }
2491     }
2492 
<span class="line-modified">2493     return WTFMove(oldAttrNode);</span>
2494 }
2495 
2496 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
2497 {
2498     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
2499     if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">2500         return WTFMove(oldAttrNode);</span>
2501 
2502     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2503     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2504     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2505         return Exception { InUseAttributeError };
2506 
2507     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2508     // before making changes to attrNode&#39;s Element connections.
2509     auto attrNodeValue = attrNode.value();
2510     unsigned index = 0;
2511     {
2512         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2513         synchronizeAllAttributes();
2514         auto&amp; elementData = ensureUniqueElementData();
2515 
2516         index = elementData.findAttributeIndexByName(attrNode.qualifiedName());
2517 
2518         if (index != ElementData::attributeNotFound) {
2519             if (oldAttrNode)
2520                 detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData.attributeAt(index).value());
2521             else
2522                 oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), elementData.attributeAt(index).value());
2523         }
2524     }
2525 
2526     attachAttributeNodeIfNeeded(attrNode);
2527     setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2528 
<span class="line-modified">2529     return WTFMove(oldAttrNode);</span>
2530 }
2531 
2532 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
2533 {
2534     if (attr.ownerElement() != this)
2535         return Exception { NotFoundError };
2536 
2537     ASSERT(&amp;document() == &amp;attr.document());
2538 
2539     synchronizeAllAttributes();
2540 
2541     if (!m_elementData)
2542         return Exception { NotFoundError };
2543 
2544     auto existingAttributeIndex = m_elementData-&gt;findAttributeIndexByName(attr.qualifiedName());
2545     if (existingAttributeIndex == ElementData::attributeNotFound)
2546         return Exception { NotFoundError };
2547 
2548     Ref&lt;Attr&gt; oldAttrNode { attr };
2549 
2550     detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
2551     removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2552 
<span class="line-modified">2553     return WTFMove(oldAttrNode);</span>
2554 }
2555 
<span class="line-modified">2556 ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName)</span>
2557 {
2558     auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
2559     if (parseResult.hasException())
2560         return parseResult.releaseException();
2561     QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
2562     if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
2563         return Exception { NamespaceError };
<span class="line-modified">2564     return WTFMove(parsedAttributeName);</span>
2565 }
2566 
<span class="line-modified">2567 ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName, const AtomicString&amp; value)</span>
2568 {
2569     auto result = parseAttributeName(namespaceURI, qualifiedName);
2570     if (result.hasException())
2571         return result.releaseException();
2572     setAttribute(result.releaseReturnValue(), value);
2573     return { };
2574 }
2575 
2576 void Element::removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2577 {
2578     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
2579 
2580     UniqueElementData&amp; elementData = ensureUniqueElementData();
2581 
2582     QualifiedName name = elementData.attributeAt(index).name();
<span class="line-modified">2583     AtomicString valueBeingRemoved = elementData.attributeAt(index).value();</span>
2584 
2585     if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
2586         detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
2587 
2588     if (inSynchronizationOfLazyAttribute) {
2589         elementData.removeAttribute(index);
2590         return;
2591     }
2592 
2593     ASSERT(!valueBeingRemoved.isNull());
2594     willModifyAttribute(name, valueBeingRemoved, nullAtom());
2595     {
2596         Style::AttributeChangeInvalidation styleInvalidation(*this, name, valueBeingRemoved, nullAtom());
2597         elementData.removeAttribute(index);
2598     }
2599 
2600     didRemoveAttribute(name, valueBeingRemoved);
2601 }
2602 
<span class="line-modified">2603 void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomicString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
2604 {
2605     if (inSynchronizationOfLazyAttribute) {
2606         ensureUniqueElementData().addAttribute(name, value);
2607         return;
2608     }
2609 
2610     willModifyAttribute(name, nullAtom(), value);
2611     {
2612         Style::AttributeChangeInvalidation styleInvalidation(*this, name, nullAtom(), value);
2613         ensureUniqueElementData().addAttribute(name, value);
2614     }
2615     didAddAttribute(name, value);
2616 }
2617 
<span class="line-modified">2618 bool Element::removeAttribute(const AtomicString&amp; qualifiedName)</span>
2619 {
2620     if (!elementData())
2621         return false;
2622 
<span class="line-modified">2623     AtomicString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;</span>
2624     unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
2625     if (index == ElementData::attributeNotFound) {
2626         if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
2627             downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
2628         return false;
2629     }
2630 
2631     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
2632     return true;
2633 }
2634 
<span class="line-modified">2635 bool Element::removeAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)</span>
2636 {
2637     return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
2638 }
2639 
<span class="line-modified">2640 RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomicString&amp; qualifiedName)</span>
2641 {
2642     if (!elementData())
2643         return nullptr;
2644     synchronizeAttribute(qualifiedName);
2645     const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2646     if (!attribute)
2647         return nullptr;
2648     return ensureAttr(attribute-&gt;name());
2649 }
2650 
<span class="line-modified">2651 RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName)</span>
2652 {
2653     if (!elementData())
2654         return 0;
2655     QualifiedName qName(nullAtom(), localName, namespaceURI);
2656     synchronizeAttribute(qName);
2657     const Attribute* attribute = elementData()-&gt;findAttributeByName(qName);
2658     if (!attribute)
2659         return 0;
2660     return ensureAttr(attribute-&gt;name());
2661 }
2662 
<span class="line-modified">2663 bool Element::hasAttribute(const AtomicString&amp; qualifiedName) const</span>
2664 {
2665     if (!elementData())
2666         return false;
2667     synchronizeAttribute(qualifiedName);
2668     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2669 }
2670 
<span class="line-modified">2671 bool Element::hasAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const</span>
2672 {
2673     if (!elementData())
2674         return false;
2675     QualifiedName qName(nullAtom(), localName, namespaceURI);
2676     synchronizeAttribute(qName);
2677     return elementData()-&gt;findAttributeByName(qName);
2678 }
2679 
2680 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2681 {
2682     if (!isConnected())
2683         return;
2684 
2685     if (document().focusedElement() == this) {
2686         if (document().page())
2687             document().page()-&gt;chrome().client().elementDidRefocus(*this);
2688 
2689         return;
2690     }
2691 
2692     // If the stylesheets have already been loaded we can reliably check isFocusable.
2693     // If not, we continue and set the focused node on the focus controller below so
2694     // that it can be updated soon after attach.
2695     if (document().haveStylesheetsLoaded()) {
2696         document().updateStyleIfNeeded();
2697         if (!isFocusable())
2698             return;
2699     }
2700 
2701     if (!supportsFocus())
2702         return;
2703 
2704     RefPtr&lt;Node&gt; protect;
2705     if (Page* page = document().page()) {




2706         // Focus and change event handlers can cause us to lose our last ref.
2707         // If a focus event handler changes the focus to a different node it
2708         // does not make sense to continue and update appearence.
2709         protect = this;
2710         if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))
2711             return;
2712     }
2713 
2714     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
2715 #if PLATFORM(IOS_FAMILY)
2716     // Focusing a form element triggers animation in UIKit to scroll to the right position.
2717     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
2718     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
2719     bool isFormControl = is&lt;HTMLFormControlElement&gt;(*this);
2720     if (isFormControl)
2721         revealMode = SelectionRevealMode::RevealUpToMainFrame;
2722 #endif
2723 
2724     auto target = focusAppearanceUpdateTarget();
2725     if (!target)
</pre>
<hr />
<pre>
2734 }
2735 
2736 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
2737 {
2738     if (isRootEditableElement()) {
2739         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
2740         RefPtr&lt;Frame&gt; frame = document().frame();
2741         if (!frame)
2742             return;
2743 
2744         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
2745         if (this == frame-&gt;selection().selection().rootEditableElement())
2746             return;
2747 
2748         // FIXME: We should restore the previous selection if there is one.
2749         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
2750 
2751         if (frame-&gt;selection().shouldChangeSelection(newSelection)) {
2752             frame-&gt;selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions(), Element::defaultFocusTextStateChangeIntent());
2753             frame-&gt;selection().revealSelection(revealMode);

2754         }
2755     }
2756 
2757     if (RefPtr&lt;FrameView&gt; view = document().view())
2758         view-&gt;scheduleScrollToFocusedElement(revealMode);
2759 }
2760 
2761 void Element::blur()
2762 {
2763     if (treeScope().focusedElementInScope() == this) {
2764         if (Frame* frame = document().frame())
2765             frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *frame);
2766         else
2767             document().setFocusedElement(nullptr);
2768     }
2769 }
2770 
<span class="line-modified">2771 void Element::dispatchFocusInEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)</span>
2772 {
2773     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2774     ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
2775     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2776 }
2777 
<span class="line-modified">2778 void Element::dispatchFocusOutEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)</span>
2779 {
2780     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2781     ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
2782     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2783 }
2784 
2785 void Element::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection)
2786 {
2787     if (auto* page = document().page())
2788         page-&gt;chrome().client().elementDidFocus(*this);
2789     dispatchEvent(FocusEvent::create(eventNames().focusEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2790 }
2791 
2792 void Element::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
2793 {
2794     if (auto* page = document().page())
2795         page-&gt;chrome().client().elementDidBlur(*this);
2796     dispatchEvent(FocusEvent::create(eventNames().blurEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2797 }
2798 
</pre>
<hr />
<pre>
2901         return textContent(true);
2902 
2903     return plainText(rangeOfContents(*this).ptr());
2904 }
2905 
2906 String Element::outerText()
2907 {
2908     // Getting outerText is the same as getting innerText, only
2909     // setting is different. You would think this should get the plain
2910     // text for the outer range, but this is wrong, &lt;br&gt; for instance
2911     // would return different values for inner and outer text by such
2912     // a rule, but it doesn&#39;t in WinIE, and we want to match that.
2913     return innerText();
2914 }
2915 
2916 String Element::title() const
2917 {
2918     return String();
2919 }
2920 
<span class="line-modified">2921 const AtomicString&amp; Element::pseudo() const</span>
2922 {
2923     return attributeWithoutSynchronization(pseudoAttr);
2924 }
2925 
<span class="line-modified">2926 void Element::setPseudo(const AtomicString&amp; value)</span>
2927 {
2928     setAttributeWithoutSynchronization(pseudoAttr, value);
2929 }
2930 
2931 LayoutSize Element::minimumSizeForResizing() const
2932 {
2933     return hasRareData() ? elementRareData()-&gt;minimumSizeForResizing() : defaultMinimumSizeForResizing();
2934 }
2935 
2936 void Element::setMinimumSizeForResizing(const LayoutSize&amp; size)
2937 {
2938     if (!hasRareData() &amp;&amp; size == defaultMinimumSizeForResizing())
2939         return;
2940     ensureElementRareData().setMinimumSizeForResizing(size);
2941 }
2942 
2943 void Element::willBecomeFullscreenElement()
2944 {
2945     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
2946         child.ancestorWillEnterFullscreen();
</pre>
<hr />
<pre>
3047         if (auto* cachedPseudoStyle = style-&gt;getCachedPseudoStyle(pseudoElementSpecifier))
3048             return cachedPseudoStyle;
3049         return &amp;resolvePseudoElementStyle(pseudoElementSpecifier);
3050     }
3051 
3052     return style;
3053 }
3054 
3055 bool Element::needsStyleInvalidation() const
3056 {
3057     if (!inRenderedDocument())
3058         return false;
3059     if (styleValidity() &gt;= Style::Validity::SubtreeInvalid)
3060         return false;
3061     if (document().hasPendingFullStyleRebuild())
3062         return false;
3063 
3064     return true;
3065 }
3066 
<span class="line-removed">3067 void Element::setStyleAffectedByEmpty()</span>
<span class="line-removed">3068 {</span>
<span class="line-removed">3069     ensureElementRareData().setStyleAffectedByEmpty(true);</span>
<span class="line-removed">3070 }</span>
<span class="line-removed">3071 </span>
<span class="line-removed">3072 void Element::setStyleAffectedByFocusWithin()</span>
<span class="line-removed">3073 {</span>
<span class="line-removed">3074     ensureElementRareData().setStyleAffectedByFocusWithin(true);</span>
<span class="line-removed">3075 }</span>
<span class="line-removed">3076 </span>
<span class="line-removed">3077 void Element::setStyleAffectedByActive()</span>
<span class="line-removed">3078 {</span>
<span class="line-removed">3079     ensureElementRareData().setStyleAffectedByActive(true);</span>
<span class="line-removed">3080 }</span>
<span class="line-removed">3081 </span>
<span class="line-removed">3082 void Element::setChildrenAffectedByDrag()</span>
<span class="line-removed">3083 {</span>
<span class="line-removed">3084     ensureElementRareData().setChildrenAffectedByDrag(true);</span>
<span class="line-removed">3085 }</span>
<span class="line-removed">3086 </span>
<span class="line-removed">3087 void Element::setChildrenAffectedByForwardPositionalRules()</span>
<span class="line-removed">3088 {</span>
<span class="line-removed">3089     ensureElementRareData().setChildrenAffectedByForwardPositionalRules(true);</span>
<span class="line-removed">3090 }</span>
<span class="line-removed">3091 </span>
<span class="line-removed">3092 void Element::setDescendantsAffectedByForwardPositionalRules()</span>
<span class="line-removed">3093 {</span>
<span class="line-removed">3094     ensureElementRareData().setDescendantsAffectedByForwardPositionalRules(true);</span>
<span class="line-removed">3095 }</span>
<span class="line-removed">3096 </span>
<span class="line-removed">3097 void Element::setChildrenAffectedByBackwardPositionalRules()</span>
<span class="line-removed">3098 {</span>
<span class="line-removed">3099     ensureElementRareData().setChildrenAffectedByBackwardPositionalRules(true);</span>
<span class="line-removed">3100 }</span>
<span class="line-removed">3101 </span>
<span class="line-removed">3102 void Element::setDescendantsAffectedByBackwardPositionalRules()</span>
<span class="line-removed">3103 {</span>
<span class="line-removed">3104     ensureElementRareData().setDescendantsAffectedByBackwardPositionalRules(true);</span>
<span class="line-removed">3105 }</span>
<span class="line-removed">3106 </span>
<span class="line-removed">3107 void Element::setChildrenAffectedByPropertyBasedBackwardPositionalRules()</span>
<span class="line-removed">3108 {</span>
<span class="line-removed">3109     ensureElementRareData().setChildrenAffectedByPropertyBasedBackwardPositionalRules(true);</span>
<span class="line-removed">3110 }</span>
<span class="line-removed">3111 </span>
3112 void Element::setChildIndex(unsigned index)
3113 {
3114     ElementRareData&amp; rareData = ensureElementRareData();
3115     rareData.setChildIndex(index);
3116 }
3117 
3118 bool Element::hasFlagsSetDuringStylingOfChildren() const
3119 {
<span class="line-modified">3120     if (childrenAffectedByHover() || childrenAffectedByFirstChildRules() || childrenAffectedByLastChildRules())</span>
<span class="line-modified">3121         return true;</span>
<span class="line-modified">3122 </span>
<span class="line-modified">3123     if (!hasRareData())</span>
<span class="line-modified">3124         return false;</span>
<span class="line-modified">3125     return rareDataStyleAffectedByActive()</span>
<span class="line-modified">3126         || rareDataChildrenAffectedByDrag()</span>
<span class="line-modified">3127         || rareDataChildrenAffectedByForwardPositionalRules()</span>
<span class="line-modified">3128         || rareDataDescendantsAffectedByForwardPositionalRules()</span>
<span class="line-modified">3129         || rareDataChildrenAffectedByBackwardPositionalRules()</span>
<span class="line-removed">3130         || rareDataDescendantsAffectedByBackwardPositionalRules()</span>
<span class="line-removed">3131         || rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules();</span>
<span class="line-removed">3132 }</span>
<span class="line-removed">3133 </span>
<span class="line-removed">3134 bool Element::rareDataStyleAffectedByEmpty() const</span>
<span class="line-removed">3135 {</span>
<span class="line-removed">3136     ASSERT(hasRareData());</span>
<span class="line-removed">3137     return elementRareData()-&gt;styleAffectedByEmpty();</span>
<span class="line-removed">3138 }</span>
<span class="line-removed">3139 </span>
<span class="line-removed">3140 bool Element::rareDataStyleAffectedByFocusWithin() const</span>
<span class="line-removed">3141 {</span>
<span class="line-removed">3142     ASSERT(hasRareData());</span>
<span class="line-removed">3143     return elementRareData()-&gt;styleAffectedByFocusWithin();</span>
<span class="line-removed">3144 }</span>
<span class="line-removed">3145 </span>
<span class="line-removed">3146 bool Element::rareDataStyleAffectedByActive() const</span>
<span class="line-removed">3147 {</span>
<span class="line-removed">3148     ASSERT(hasRareData());</span>
<span class="line-removed">3149     return elementRareData()-&gt;styleAffectedByActive();</span>
<span class="line-removed">3150 }</span>
<span class="line-removed">3151 </span>
<span class="line-removed">3152 bool Element::rareDataChildrenAffectedByDrag() const</span>
<span class="line-removed">3153 {</span>
<span class="line-removed">3154     ASSERT(hasRareData());</span>
<span class="line-removed">3155     return elementRareData()-&gt;childrenAffectedByDrag();</span>
<span class="line-removed">3156 }</span>
<span class="line-removed">3157 </span>
<span class="line-removed">3158 bool Element::rareDataChildrenAffectedByForwardPositionalRules() const</span>
<span class="line-removed">3159 {</span>
<span class="line-removed">3160     ASSERT(hasRareData());</span>
<span class="line-removed">3161     return elementRareData()-&gt;childrenAffectedByForwardPositionalRules();</span>
<span class="line-removed">3162 }</span>
<span class="line-removed">3163 </span>
<span class="line-removed">3164 bool Element::rareDataDescendantsAffectedByForwardPositionalRules() const</span>
<span class="line-removed">3165 {</span>
<span class="line-removed">3166     ASSERT(hasRareData());</span>
<span class="line-removed">3167     return elementRareData()-&gt;descendantsAffectedByForwardPositionalRules();</span>
<span class="line-removed">3168 }</span>
<span class="line-removed">3169 </span>
<span class="line-removed">3170 bool Element::rareDataChildrenAffectedByBackwardPositionalRules() const</span>
<span class="line-removed">3171 {</span>
<span class="line-removed">3172     ASSERT(hasRareData());</span>
<span class="line-removed">3173     return elementRareData()-&gt;childrenAffectedByBackwardPositionalRules();</span>
<span class="line-removed">3174 }</span>
<span class="line-removed">3175 </span>
<span class="line-removed">3176 bool Element::rareDataDescendantsAffectedByBackwardPositionalRules() const</span>
<span class="line-removed">3177 {</span>
<span class="line-removed">3178     ASSERT(hasRareData());</span>
<span class="line-removed">3179     return elementRareData()-&gt;descendantsAffectedByBackwardPositionalRules();</span>
<span class="line-removed">3180 }</span>
<span class="line-removed">3181 </span>
<span class="line-removed">3182 bool Element::rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules() const</span>
<span class="line-removed">3183 {</span>
<span class="line-removed">3184     ASSERT(hasRareData());</span>
<span class="line-removed">3185     return elementRareData()-&gt;childrenAffectedByPropertyBasedBackwardPositionalRules();</span>
3186 }
3187 
3188 unsigned Element::rareDataChildIndex() const
3189 {
3190     ASSERT(hasRareData());
3191     return elementRareData()-&gt;childIndex();
3192 }
3193 
<span class="line-modified">3194 AtomicString Element::computeInheritedLanguage() const</span>
3195 {
3196     if (const ElementData* elementData = this-&gt;elementData()) {
3197         if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3198             return attribute-&gt;value();
3199     }
3200 
3201     // The language property is inherited, so we iterate over the parents to find the first language.
3202     const Node* currentNode = this;
3203     while ((currentNode = currentNode-&gt;parentNode())) {
3204         if (is&lt;Element&gt;(*currentNode)) {
3205             if (const ElementData* elementData = downcast&lt;Element&gt;(*currentNode).elementData()) {
3206                 if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3207                     return attribute-&gt;value();
3208             }
3209         } else if (is&lt;Document&gt;(*currentNode)) {
3210             // checking the MIME content-language
3211             return downcast&lt;Document&gt;(*currentNode).contentLanguage();
3212         }
3213     }
3214 
</pre>
<hr />
<pre>
3320     auto query = document().selectorQueryForString(selector);
3321     if (query.hasException())
3322         return query.releaseException();
3323     return query.releaseReturnValue().closest(*this);
3324 }
3325 
3326 bool Element::shouldAppearIndeterminate() const
3327 {
3328     return false;
3329 }
3330 
3331 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3332 {
3333     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3334 }
3335 
3336 DOMTokenList&amp; Element::classList()
3337 {
3338     ElementRareData&amp; data = ensureElementRareData();
3339     if (!data.classList())
<span class="line-modified">3340         data.setClassList(std::make_unique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));</span>
3341     return *data.classList();
3342 }
3343 
3344 DatasetDOMStringMap&amp; Element::dataset()
3345 {
3346     ElementRareData&amp; data = ensureElementRareData();
3347     if (!data.dataset())
<span class="line-modified">3348         data.setDataset(std::make_unique&lt;DatasetDOMStringMap&gt;(*this));</span>
3349     return *data.dataset();
3350 }
3351 
3352 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3353 {
3354 #if !ASSERT_DISABLED
3355     if (elementData()) {
3356         if (const Attribute* attribute = findAttributeByName(name))
3357             ASSERT(isURLAttribute(*attribute));
3358     }
3359 #endif
3360     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3361 }
3362 
3363 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3364 {
3365 #if !ASSERT_DISABLED
3366     if (elementData()) {
3367         if (const Attribute* attribute = findAttributeByName(name))
3368             ASSERT(isURLAttribute(*attribute));
3369     }
3370 #endif
3371     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3372     if (value.isEmpty())
3373         return URL();
3374     return document().completeURL(value);
3375 }
3376 
3377 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3378 {
3379     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3380 }
3381 
3382 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3383 {
<span class="line-modified">3384     setAttribute(attributeName, AtomicString::number(value));</span>
3385 }
3386 
3387 unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
3388 {
3389     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3390 }
3391 
3392 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3393 {
<span class="line-modified">3394     setAttribute(attributeName, AtomicString::number(limitToOnlyHTMLNonNegative(value)));</span>
3395 }
3396 
3397 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3398 {
3399     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3400     if (child.isSVGElement()) {
3401         ASSERT(!isSVGElement());
3402         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3403         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3404     }
3405     return true;
3406 }
3407 
<span class="line-modified">3408 #if ENABLE(FULLSCREEN_API) || ENABLE(POINTER_EVENTS)</span>
3409 static Element* parentCrossingFrameBoundaries(const Element* element)
3410 {
3411     ASSERT(element);
3412     if (auto* parent = element-&gt;parentElementInComposedTree())
3413         return parent;
3414     return element-&gt;document().ownerElement();
3415 }
<span class="line-removed">3416 #endif</span>
3417 
<span class="line-removed">3418 #if ENABLE(FULLSCREEN_API)</span>
3419 void Element::webkitRequestFullscreen()
3420 {
<span class="line-modified">3421     document().requestFullScreenForElement(this, Document::EnforceIFrameAllowFullScreenRequirement);</span>
3422 }
3423 
3424 bool Element::containsFullScreenElement() const
3425 {
3426     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3427 }
3428 
3429 void Element::setContainsFullScreenElement(bool flag)
3430 {
3431     ensureElementRareData().setContainsFullScreenElement(flag);
3432     invalidateStyleAndLayerComposition();
3433 }
3434 
3435 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3436 {
3437     Element* element = this;
3438     while ((element = parentCrossingFrameBoundaries(element)))
3439         element-&gt;setContainsFullScreenElement(flag);
3440 }
3441 #endif
</pre>
<hr />
<pre>
3474 #if ENABLE(INTERSECTION_OBSERVER)
3475 void Element::disconnectFromIntersectionObservers()
3476 {
3477     auto* observerData = intersectionObserverData();
3478     if (!observerData)
3479         return;
3480 
3481     for (const auto&amp; registration : observerData-&gt;registrations)
3482         registration.observer-&gt;targetDestroyed(*this);
3483     observerData-&gt;registrations.clear();
3484 
3485     for (const auto&amp; observer : observerData-&gt;observers)
3486         observer-&gt;rootDestroyed();
3487     observerData-&gt;observers.clear();
3488 }
3489 
3490 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3491 {
3492     auto&amp; rareData = ensureElementRareData();
3493     if (!rareData.intersectionObserverData())
<span class="line-modified">3494         rareData.setIntersectionObserverData(std::make_unique&lt;IntersectionObserverData&gt;());</span>
3495     return *rareData.intersectionObserverData();
3496 }
3497 
3498 IntersectionObserverData* Element::intersectionObserverData()
3499 {
3500     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3501 }
3502 #endif
3503 


























3504 SpellcheckAttributeState Element::spellcheckAttributeState() const
3505 {
<span class="line-modified">3506     const AtomicString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
3507     if (value.isNull())
3508         return SpellcheckAttributeDefault;
3509     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
3510         return SpellcheckAttributeTrue;
3511     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
3512         return SpellcheckAttributeFalse;
3513     return SpellcheckAttributeDefault;
3514 }
3515 
3516 bool Element::isSpellCheckingEnabled() const
3517 {
3518     for (const Element* element = this; element; element = element-&gt;parentOrShadowHostElement()) {
3519         switch (element-&gt;spellcheckAttributeState()) {
3520         case SpellcheckAttributeTrue:
3521             return true;
3522         case SpellcheckAttributeFalse:
3523             return false;
3524         case SpellcheckAttributeDefault:
3525             break;
3526         }
3527     }
3528 
3529     return true;
3530 }
3531 
3532 #ifndef NDEBUG
3533 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3534 {
3535     if (name == HTMLNames::styleAttr)
3536         return false;
3537 
3538     if (isSVGElement())
<span class="line-modified">3539         return !downcast&lt;SVGElement&gt;(*this).isAnimatableAttribute(name);</span>
3540 
3541     return true;
3542 }
3543 #endif
3544 
3545 #if DUMP_NODE_STATISTICS
3546 bool Element::hasNamedNodeMap() const
3547 {
3548     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3549 }
3550 #endif
3551 
<span class="line-modified">3552 inline void Element::updateName(const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
3553 {
3554     if (!isInTreeScope())
3555         return;
3556 
3557     if (oldName == newName)
3558         return;
3559 
3560     updateNameForTreeScope(treeScope(), oldName, newName);
3561 
3562     if (!isConnected())
3563         return;
3564     if (!is&lt;HTMLDocument&gt;(document()))
3565         return;
3566     updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
3567 }
3568 
<span class="line-modified">3569 void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
3570 {
3571     ASSERT(oldName != newName);
3572 
3573     if (!oldName.isEmpty())
3574         scope.removeElementByName(*oldName.impl(), *this);
3575     if (!newName.isEmpty())
3576         scope.addElementByName(*newName.impl(), *this);
3577 }
3578 
<span class="line-modified">3579 void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldName, const AtomicString&amp; newName)</span>
3580 {
3581     ASSERT(oldName != newName);
3582 
3583     if (isInShadowTree())
3584         return;
3585 
3586     if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">3587         const AtomicString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
3588         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3589             document.removeWindowNamedItem(*oldName.impl(), *this);
3590         if (!newName.isEmpty() &amp;&amp; newName != id)
3591             document.addWindowNamedItem(*newName.impl(), *this);
3592     }
3593 
3594     if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">3595         const AtomicString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
3596         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3597             document.removeDocumentNamedItem(*oldName.impl(), *this);
3598         if (!newName.isEmpty() &amp;&amp; newName != id)
3599             document.addDocumentNamedItem(*newName.impl(), *this);
3600     }
3601 }
3602 
<span class="line-modified">3603 inline void Element::updateId(const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)</span>
3604 {
3605     if (!isInTreeScope())
3606         return;
3607 
3608     if (oldId == newId)
3609         return;
3610 
3611     updateIdForTreeScope(treeScope(), oldId, newId, notifyObservers);
3612 
3613     if (!isConnected())
3614         return;
3615     if (!is&lt;HTMLDocument&gt;(document()))
3616         return;
3617     updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
3618 }
3619 
<span class="line-modified">3620 void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers notifyObservers)</span>
3621 {
3622     ASSERT(isInTreeScope());
3623     ASSERT(oldId != newId);
3624 
3625     if (!oldId.isEmpty())
3626         scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3627     if (!newId.isEmpty())
3628         scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3629 }
3630 
<span class="line-modified">3631 void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomicString&amp; oldId, const AtomicString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)</span>
3632 {
3633     ASSERT(isConnected());
3634     ASSERT(oldId != newId);
3635 
3636     if (isInShadowTree())
3637         return;
3638 
3639     if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">3640         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
3641         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3642             document.removeWindowNamedItem(*oldId.impl(), *this);
3643         if (!newId.isEmpty() &amp;&amp; newId != name)
3644             document.addWindowNamedItem(*newId.impl(), *this);
3645     }
3646 
3647     if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">3648         const AtomicString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
3649         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3650             document.removeDocumentNamedItem(*oldId.impl(), *this);
3651         if (!newId.isEmpty() &amp;&amp; newId != name)
3652             document.addDocumentNamedItem(*newId.impl(), *this);
3653     }
3654 }
3655 
<span class="line-modified">3656 void Element::updateLabel(TreeScope&amp; scope, const AtomicString&amp; oldForAttributeValue, const AtomicString&amp; newForAttributeValue)</span>
3657 {
3658     ASSERT(hasTagName(labelTag));
3659 
3660     if (!isConnected())
3661         return;
3662 
3663     if (oldForAttributeValue == newForAttributeValue)
3664         return;
3665 
3666     if (!oldForAttributeValue.isEmpty())
3667         scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3668     if (!newForAttributeValue.isEmpty())
3669         scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3670 }
3671 
<span class="line-modified">3672 void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
3673 {
3674     if (name == HTMLNames::idAttr)
3675         updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3676     else if (name == HTMLNames::nameAttr)
3677         updateName(oldValue, newValue);
3678     else if (name == HTMLNames::forAttr &amp;&amp; hasTagName(labelTag)) {
3679         if (treeScope().shouldCacheLabelsByForAttribute())
3680             updateLabel(treeScope(), oldValue, newValue);
3681     }
3682 
3683     if (auto recipients = MutationObserverInterestGroup::createForAttributesMutation(*this, name))
3684         recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
3685 
3686     InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
3687 }
3688 
<span class="line-modified">3689 void Element::didAddAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
3690 {
3691     attributeChanged(name, nullAtom(), value);
<span class="line-modified">3692     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), value);</span>
3693     dispatchSubtreeModifiedEvent();
3694 }
3695 
<span class="line-modified">3696 void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
3697 {
3698     attributeChanged(name, oldValue, newValue);
<span class="line-modified">3699     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.localName(), newValue);</span>
3700     // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
3701 }
3702 
<span class="line-modified">3703 void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomicString&amp; oldValue)</span>
3704 {
3705     attributeChanged(name, oldValue, nullAtom());
<span class="line-modified">3706     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.localName());</span>
3707     dispatchSubtreeModifiedEvent();
3708 }
3709 
3710 IntPoint Element::savedLayerScrollPosition() const
3711 {
3712     return hasRareData() ? elementRareData()-&gt;savedLayerScrollPosition() : IntPoint();
3713 }
3714 
3715 void Element::setSavedLayerScrollPosition(const IntPoint&amp; position)
3716 {
3717     if (position.isZero() &amp;&amp; !hasRareData())
3718         return;
3719     ensureElementRareData().setSavedLayerScrollPosition(position);
3720 }
3721 
<span class="line-modified">3722 RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomicString&amp; localName, bool shouldIgnoreAttributeCase)</span>
3723 {
3724     if (auto* attrNodeList = attrNodeListForElement(*this))
3725         return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
3726     return nullptr;
3727 }
3728 
3729 RefPtr&lt;Attr&gt; Element::attrIfExists(const QualifiedName&amp; name)
3730 {
3731     if (auto* attrNodeList = attrNodeListForElement(*this))
3732         return findAttrNodeInList(*attrNodeList, name);
3733     return nullptr;
3734 }
3735 
3736 Ref&lt;Attr&gt; Element::ensureAttr(const QualifiedName&amp; name)
3737 {
3738     auto&amp; attrNodeList = ensureAttrNodeListForElement(*this);
3739     RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(attrNodeList, name);
3740     if (!attrNode) {
3741         attrNode = Attr::create(*this, name);
3742         attrNode-&gt;setTreeScopeRecursively(treeScope());
3743         attrNodeList.append(attrNode);
3744     }
3745     return attrNode.releaseNonNull();
3746 }
3747 
<span class="line-modified">3748 void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomicString&amp; value)</span>
3749 {
3750     ASSERT(hasSyntheticAttrChildNodes());
3751     attrNode-&gt;detachFromElementWithValue(value);
3752 
3753     auto&amp; attrNodeList = *attrNodeListForElement(*this);
3754     bool found = attrNodeList.removeFirstMatching([attrNode](auto&amp; attribute) {
3755         return attribute-&gt;qualifiedName() == attrNode-&gt;qualifiedName();
3756     });
3757     ASSERT_UNUSED(found, found);
3758     if (attrNodeList.isEmpty())
3759         removeAttrNodeListForElement(*this);
3760 }
3761 
3762 void Element::detachAllAttrNodesFromElement()
3763 {
3764     auto* attrNodeList = attrNodeListForElement(*this);
3765     ASSERT(attrNodeList);
3766 
3767     for (const Attribute&amp; attribute : attributesIterator()) {
3768         if (RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(*attrNodeList, attribute.name()))
</pre>
<hr />
<pre>
3774 
3775 void Element::resetComputedStyle()
3776 {
3777     if (!hasRareData() || !elementRareData()-&gt;computedStyle())
3778         return;
3779 
3780     auto reset = [](Element&amp; element) {
3781         if (!element.hasRareData() || !element.elementRareData()-&gt;computedStyle())
3782             return;
3783         if (element.hasCustomStyleResolveCallbacks())
3784             element.willResetComputedStyle();
3785         element.elementRareData()-&gt;resetComputedStyle();
3786     };
3787     reset(*this);
3788     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
3789         reset(child);
3790 }
3791 
3792 void Element::resetStyleRelations()
3793 {



3794     if (!hasRareData())
3795         return;
3796     elementRareData()-&gt;resetStyleRelations();
3797 }
3798 
3799 void Element::clearHoverAndActiveStatusBeforeDetachingRenderer()
3800 {
3801     if (!isUserActionElement())
3802         return;
3803     if (hovered())
3804         document().hoveredElementDidDetach(*this);
3805     if (isInActiveChain())
3806         document().elementInActiveChainDidDetach(*this);
3807     document().userActionElements().clearActiveAndHovered(*this);
3808 }
3809 
3810 void Element::willRecalcStyle(Style::Change)
3811 {
3812     ASSERT(hasCustomStyleResolveCallbacks());
3813 }
</pre>
<hr />
<pre>
3846 {
3847     ASSERT(hasCustomStyleResolveCallbacks());
3848     return WTF::nullopt;
3849 }
3850 
3851 void Element::cloneAttributesFromElement(const Element&amp; other)
3852 {
3853     if (hasSyntheticAttrChildNodes())
3854         detachAllAttrNodesFromElement();
3855 
3856     other.synchronizeAllAttributes();
3857     if (!other.m_elementData) {
3858         m_elementData = nullptr;
3859         return;
3860     }
3861 
3862     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
3863     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
3864     ASSERT(!isConnected());
3865 
<span class="line-modified">3866     const AtomicString&amp; oldID = getIdAttribute();</span>
<span class="line-modified">3867     const AtomicString&amp; newID = other.getIdAttribute();</span>
3868 
3869     if (!oldID.isNull() || !newID.isNull())
3870         updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3871 
<span class="line-modified">3872     const AtomicString&amp; oldName = getNameAttribute();</span>
<span class="line-modified">3873     const AtomicString&amp; newName = other.getNameAttribute();</span>
3874 
3875     if (!oldName.isNull() || !newName.isNull())
3876         updateName(oldName, newName);
3877 
3878     // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
3879     // We can only do this if there is no CSSOM wrapper for other&#39;s inline style, and there are no presentation attributes.
3880     if (is&lt;UniqueElementData&gt;(*other.m_elementData)
3881         &amp;&amp; !other.m_elementData-&gt;presentationAttributeStyle()
3882         &amp;&amp; (!other.m_elementData-&gt;inlineStyle() || !other.m_elementData-&gt;inlineStyle()-&gt;hasCSSOMWrapper()))
3883         const_cast&lt;Element&amp;&gt;(other).m_elementData = downcast&lt;UniqueElementData&gt;(*other.m_elementData).makeShareableCopy();
3884 
3885     if (!other.m_elementData-&gt;isUnique())
3886         m_elementData = other.m_elementData;
3887     else
3888         m_elementData = other.m_elementData-&gt;makeUniqueCopy();
3889 
3890     for (const Attribute&amp; attribute : attributesIterator())
3891         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedByCloning);
3892 }
3893 
</pre>
<hr />
<pre>
4055 }
4056 
4057 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup)
4058 {
4059     return insertAdjacentHTML(where, markup, nullptr);
4060 }
4061 
4062 ExceptionOr&lt;void&gt; Element::insertAdjacentText(const String&amp; where, const String&amp; text)
4063 {
4064     auto result = insertAdjacent(where, document().createTextNode(text));
4065     if (result.hasException())
4066         return result.releaseException();
4067     return { };
4068 }
4069 
4070 Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
4071 {
4072     if (!isLink())
4073         return nullptr;
4074 
<span class="line-modified">4075     const AtomicString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);</span>
4076     if (href.isNull())
4077         return nullptr;
4078 
4079     Document&amp; document = this-&gt;document();
4080     URL url = document.completeURL(href);
4081     if (!url.isValid())
4082         return nullptr;
4083 
4084     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4085         outAnchorName = url.fragmentIdentifier();
4086         return document.findAnchor(outAnchorName);
4087     }
4088 
4089     return nullptr;
4090 }
4091 
4092 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::ExecState&amp; state, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)
4093 {
4094     String id = &quot;&quot;;
4095     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
</pre>
<hr />
<pre>
4100             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4101         else {
4102             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4103             id = keyframeEffectOptions.id;
4104             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4105         }
4106         keyframeEffectOptions = keyframeEffectOptionsVariant;
4107     }
4108 
4109     auto keyframeEffectResult = KeyframeEffect::create(state, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));
4110     if (keyframeEffectResult.hasException())
4111         return keyframeEffectResult.releaseException();
4112 
4113     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4114     animation-&gt;setId(id);
4115 
4116     auto animationPlayResult = animation-&gt;play();
4117     if (animationPlayResult.hasException())
4118         return animationPlayResult.releaseException();
4119 
<span class="line-modified">4120     return WTFMove(animation);</span>
4121 }
4122 
4123 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()
4124 {
4125     // FIXME: Filter and order the list as specified (webkit.org/b/179535).
4126 
4127     // For the list of animations to be current, we need to account for any pending CSS changes,
4128     // such as updates to CSS Animations and CSS Transitions.
4129     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4130     document().updateStyleIfNeeded();
4131 
4132     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4133     if (auto timeline = document().existingTimeline()) {
4134         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4135             if (animation-&gt;isRelevant())
4136                 animations.append(animation);
4137         }
4138     }
4139     return animations;
4140 }
4141 









4142 #if ENABLE(CSS_TYPED_OM)
4143 StylePropertyMap* Element::attributeStyleMap()
4144 {
4145     if (!hasRareData())
4146         return nullptr;
4147     return elementRareData()-&gt;attributeStyleMap();
4148 }
4149 
4150 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4151 {
4152     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4153 }
4154 #endif
4155 
<span class="line-removed">4156 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">4157 OptionSet&lt;TouchAction&gt; Element::computedTouchActions() const</span>
<span class="line-removed">4158 {</span>
<span class="line-removed">4159     OptionSet&lt;TouchAction&gt; computedTouchActions = TouchAction::Auto;</span>
<span class="line-removed">4160     for (auto* element = this; element; element = parentCrossingFrameBoundaries(element)) {</span>
<span class="line-removed">4161         auto* renderer = element-&gt;renderer();</span>
<span class="line-removed">4162         if (!renderer)</span>
<span class="line-removed">4163             continue;</span>
<span class="line-removed">4164 </span>
<span class="line-removed">4165         auto touchActions = renderer-&gt;style().touchActions();</span>
<span class="line-removed">4166 </span>
<span class="line-removed">4167         // Once we&#39;ve encountered touch-action: none, we know that this will be the computed value.</span>
<span class="line-removed">4168         if (touchActions == TouchAction::None)</span>
<span class="line-removed">4169             return touchActions;</span>
<span class="line-removed">4170 </span>
<span class="line-removed">4171         // If the computed touch-action so far was &quot;auto&quot;, we can just use the current element&#39;s touch-action.</span>
<span class="line-removed">4172         if (computedTouchActions == TouchAction::Auto) {</span>
<span class="line-removed">4173             computedTouchActions = touchActions;</span>
<span class="line-removed">4174             continue;</span>
<span class="line-removed">4175         }</span>
<span class="line-removed">4176 </span>
<span class="line-removed">4177         // If the current element has touch-action: auto or the same touch-action as the computed touch-action,</span>
<span class="line-removed">4178         // we need to keep going up the ancestry chain.</span>
<span class="line-removed">4179         if (touchActions == TouchAction::Auto || touchActions == computedTouchActions)</span>
<span class="line-removed">4180             continue;</span>
<span class="line-removed">4181 </span>
<span class="line-removed">4182         // Now, the element&#39;s touch-action and the computed touch-action are different and are neither &quot;auto&quot; nor &quot;none&quot;.</span>
<span class="line-removed">4183         if (computedTouchActions == TouchAction::Manipulation) {</span>
<span class="line-removed">4184             // If the computed touch-action is &quot;manipulation&quot;, we can take the current element&#39;s touch-action as the newly</span>
<span class="line-removed">4185             // computed touch-action.</span>
<span class="line-removed">4186             computedTouchActions = touchActions;</span>
<span class="line-removed">4187         } else if (touchActions == TouchAction::Manipulation) {</span>
<span class="line-removed">4188             // Otherwise, we have a restricted computed touch-action so far. If the current element&#39;s touch-action is &quot;manipulation&quot;</span>
<span class="line-removed">4189             // then we can just keep going and leave the computed touch-action untouched.</span>
<span class="line-removed">4190             continue;</span>
<span class="line-removed">4191         }</span>
<span class="line-removed">4192 </span>
<span class="line-removed">4193         // In any other case, we have competing restrictive touch-action values that can only yield &quot;none&quot;.</span>
<span class="line-removed">4194         return TouchAction::None;</span>
<span class="line-removed">4195     }</span>
<span class="line-removed">4196     return computedTouchActions;</span>
<span class="line-removed">4197 }</span>
<span class="line-removed">4198 </span>
<span class="line-removed">4199 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-removed">4200 ScrollingNodeID Element::nearestScrollingNodeIDUsingTouchOverflowScrolling() const</span>
<span class="line-removed">4201 {</span>
<span class="line-removed">4202     if (!renderer())</span>
<span class="line-removed">4203         return 0;</span>
<span class="line-removed">4204 </span>
<span class="line-removed">4205     // We are not interested in the root, so check that we also have a valid parent.</span>
<span class="line-removed">4206     for (auto* layer = renderer()-&gt;enclosingLayer(); layer &amp;&amp; layer-&gt;parent(); layer = layer-&gt;parent()) {</span>
<span class="line-removed">4207         if (layer-&gt;isComposited()) {</span>
<span class="line-removed">4208             if (auto scrollingNodeID = layer-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))</span>
<span class="line-removed">4209                 return scrollingNodeID;</span>
<span class="line-removed">4210         }</span>
<span class="line-removed">4211     }</span>
<span class="line-removed">4212 </span>
<span class="line-removed">4213     return 0;</span>
<span class="line-removed">4214 }</span>
<span class="line-removed">4215 #endif</span>
<span class="line-removed">4216 #endif</span>
<span class="line-removed">4217 </span>
4218 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;ContainerNodeAlgorithms.h&quot;
  39 #include &quot;CustomElementReactionQueue.h&quot;
  40 #include &quot;CustomElementRegistry.h&quot;
  41 #include &quot;DOMRect.h&quot;
  42 #include &quot;DOMRectList.h&quot;
  43 #include &quot;DOMTokenList.h&quot;
  44 #include &quot;DOMWindow.h&quot;
  45 #include &quot;DocumentSharedObjectPool.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;Editing.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;ElementRareData.h&quot;
  50 #include &quot;EventDispatcher.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FocusEvent.h&quot;
  55 #include &quot;Frame.h&quot;
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
<span class="line-added">  58 #include &quot;FullscreenManager.h&quot;</span>
  59 #include &quot;HTMLBodyElement.h&quot;
  60 #include &quot;HTMLCanvasElement.h&quot;
  61 #include &quot;HTMLCollection.h&quot;
  62 #include &quot;HTMLDocument.h&quot;
  63 #include &quot;HTMLHtmlElement.h&quot;
  64 #include &quot;HTMLLabelElement.h&quot;
  65 #include &quot;HTMLNameCollection.h&quot;
  66 #include &quot;HTMLObjectElement.h&quot;
  67 #include &quot;HTMLOptGroupElement.h&quot;
  68 #include &quot;HTMLOptionElement.h&quot;
  69 #include &quot;HTMLParserIdioms.h&quot;
  70 #include &quot;HTMLSelectElement.h&quot;
  71 #include &quot;HTMLTemplateElement.h&quot;
  72 #include &quot;IdChangeInvalidation.h&quot;
  73 #include &quot;IdTargetObserverRegistry.h&quot;
  74 #include &quot;InspectorInstrumentation.h&quot;
  75 #include &quot;JSLazyEventListener.h&quot;
  76 #include &quot;KeyboardEvent.h&quot;
  77 #include &quot;KeyframeEffect.h&quot;
  78 #include &quot;MutationObserverInterestGroup.h&quot;
  79 #include &quot;MutationRecord.h&quot;
  80 #include &quot;NodeRenderStyle.h&quot;
  81 #include &quot;PlatformWheelEvent.h&quot;
  82 #include &quot;PointerCaptureController.h&quot;
<span class="line-added">  83 #include &quot;PointerEvent.h&quot;</span>
  84 #include &quot;PointerLockController.h&quot;
  85 #include &quot;RenderFragmentContainer.h&quot;
  86 #include &quot;RenderLayer.h&quot;
  87 #include &quot;RenderLayerBacking.h&quot;
  88 #include &quot;RenderLayerCompositor.h&quot;
  89 #include &quot;RenderListBox.h&quot;
  90 #include &quot;RenderTheme.h&quot;
  91 #include &quot;RenderTreeUpdater.h&quot;
  92 #include &quot;RenderView.h&quot;
  93 #include &quot;RenderWidget.h&quot;
  94 #include &quot;RuntimeEnabledFeatures.h&quot;
  95 #include &quot;SVGDocumentExtensions.h&quot;
  96 #include &quot;SVGElement.h&quot;
  97 #include &quot;SVGNames.h&quot;
  98 #include &quot;SVGSVGElement.h&quot;
  99 #include &quot;ScriptDisallowedScope.h&quot;
 100 #include &quot;ScrollIntoViewOptions.h&quot;
 101 #include &quot;ScrollLatchingState.h&quot;
 102 #include &quot;SelectorQuery.h&quot;
 103 #include &quot;Settings.h&quot;
</pre>
<hr />
<pre>
 152     return attrNodeListMap().add(&amp;element, Vector&lt;RefPtr&lt;Attr&gt;&gt;()).iterator-&gt;value;
 153 }
 154 
 155 static void removeAttrNodeListForElement(Element&amp; element)
 156 {
 157     ASSERT(element.hasSyntheticAttrChildNodes());
 158     ASSERT(attrNodeListMap().contains(&amp;element));
 159     attrNodeListMap().remove(&amp;element);
 160     element.setHasSyntheticAttrChildNodes(false);
 161 }
 162 
 163 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const QualifiedName&amp; name)
 164 {
 165     for (auto&amp; node : attrNodeList) {
 166         if (node-&gt;qualifiedName().matches(name))
 167             return node.get();
 168     }
 169     return nullptr;
 170 }
 171 
<span class="line-modified"> 172 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomString&amp; localName, bool shouldIgnoreAttributeCase)</span>
 173 {
<span class="line-modified"> 174     const AtomString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;</span>
 175     for (auto&amp; node : attrNodeList) {
 176         if (node-&gt;qualifiedName().localName() == caseAdjustedName)
 177             return node.get();
 178     }
 179     return nullptr;
 180 }
 181 
 182 Ref&lt;Element&gt; Element::create(const QualifiedName&amp; tagName, Document&amp; document)
 183 {
 184     return adoptRef(*new Element(tagName, document, CreateElement));
 185 }
 186 
 187 Element::Element(const QualifiedName&amp; tagName, Document&amp; document, ConstructionType type)
 188     : ContainerNode(document, type)
 189     , m_tagName(tagName)
 190 {
 191 }
 192 
 193 Element::~Element()
 194 {
 195     ASSERT(!beforePseudoElement());
 196     ASSERT(!afterPseudoElement());
 197 
 198 #if ENABLE(INTERSECTION_OBSERVER)
 199     disconnectFromIntersectionObservers();
 200 #endif
 201 
<span class="line-added"> 202 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added"> 203     disconnectFromResizeObservers();</span>
<span class="line-added"> 204 #endif</span>
<span class="line-added"> 205 </span>
 206     removeShadowRoot();
 207 
 208     if (hasSyntheticAttrChildNodes())
 209         detachAllAttrNodesFromElement();
 210 
<span class="line-added"> 211 #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added"> 212     if (hasRareData()) {</span>
<span class="line-added"> 213         if (auto* map = elementRareData()-&gt;attributeStyleMap())</span>
<span class="line-added"> 214             map-&gt;clearElement();</span>
<span class="line-added"> 215     }</span>
<span class="line-added"> 216 #endif</span>
<span class="line-added"> 217 </span>
 218     if (hasPendingResources()) {
 219         document().accessSVGExtensions().removeElementFromPendingResources(*this);
 220         ASSERT(!hasPendingResources());
 221     }
 222 }
 223 
 224 inline ElementRareData* Element::elementRareData() const
 225 {
 226     ASSERT_WITH_SECURITY_IMPLICATION(hasRareData());
 227     return static_cast&lt;ElementRareData*&gt;(rareData());
 228 }
 229 
 230 inline ElementRareData&amp; Element::ensureElementRareData()
 231 {
 232     return static_cast&lt;ElementRareData&amp;&gt;(ensureRareData());
 233 }
 234 
 235 void Element::clearTabIndexExplicitlyIfNeeded()
 236 {
 237     if (hasRareData())
 238         elementRareData()-&gt;clearTabIndexExplicitly();
 239 }
 240 
 241 void Element::setTabIndexExplicitly(int tabIndex)
 242 {
 243     ensureElementRareData().setTabIndexExplicitly(tabIndex);
 244 }
 245 
<span class="line-modified"> 246 Optional&lt;int&gt; Element::tabIndexSetExplicitly() const</span>
 247 {
<span class="line-modified"> 248     if (!hasRareData())</span>
<span class="line-added"> 249         return WTF::nullopt;</span>
<span class="line-added"> 250     return elementRareData()-&gt;tabIndex();</span>
<span class="line-added"> 251 }</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253 int Element::defaultTabIndex() const</span>
<span class="line-added"> 254 {</span>
<span class="line-added"> 255     return -1;</span>
 256 }
 257 
 258 bool Element::supportsFocus() const
 259 {
<span class="line-modified"> 260     return !!tabIndexSetExplicitly();</span>
 261 }
 262 
 263 RefPtr&lt;Element&gt; Element::focusDelegate()
 264 {
 265     return this;
 266 }
 267 
<span class="line-modified"> 268 int Element::tabIndexForBindings() const</span>
 269 {
<span class="line-modified"> 270     auto defaultIndex = defaultTabIndex();</span>
<span class="line-added"> 271     ASSERT(!defaultIndex || defaultIndex == -1);</span>
<span class="line-added"> 272     // FIXME: supportsFocus() check shouldn&#39;t be here.</span>
<span class="line-added"> 273     if (!defaultIndex || supportsFocus())</span>
<span class="line-added"> 274         return tabIndexSetExplicitly().valueOr(0);</span>
<span class="line-added"> 275     return defaultIndex;</span>
 276 }
 277 
<span class="line-modified"> 278 void Element::setTabIndexForBindings(int value)</span>
 279 {
 280     setIntegralAttribute(tabindexAttr, value);
 281 }
 282 
 283 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 284 {
<span class="line-modified"> 285     return isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0;</span>
 286 }
 287 
 288 bool Element::isMouseFocusable() const
 289 {
 290     return isFocusable();
 291 }
 292 
 293 bool Element::shouldUseInputMethod()
 294 {
 295     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 296 }
 297 
 298 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 299 {
 300     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 301 }
 302 
<span class="line-modified"> 303 #if ENABLE(POINTER_EVENTS) &amp;&amp; !ENABLE(TOUCH_EVENTS)</span>
<span class="line-added"> 304 static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)</span>
<span class="line-added"> 305 {</span>
<span class="line-added"> 306     // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events</span>
<span class="line-added"> 307     const auto&amp; type = mouseEvent.type();</span>
<span class="line-added"> 308     return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;</span>
<span class="line-added"> 309 }</span>
<span class="line-added"> 310 #endif</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>
 313 {
 314     if (isDisabledFormControl())
 315         return false;
 316 
 317     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
 318         return false;
 319 
 320     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
 321 
 322     if (mouseEvent-&gt;type().isEmpty())
 323         return true; // Shouldn&#39;t happen.
 324 
<span class="line-added"> 325     bool didNotSwallowEvent = true;</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 328     if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {</span>
<span class="line-added"> 329         if (auto* page = document().page()) {</span>
<span class="line-added"> 330             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();</span>
<span class="line-added"> 331 #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-added"> 332             if (mouseEvent-&gt;type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="line-added"> 333                 return false;</span>
<span class="line-added"> 334 #else</span>
<span class="line-added"> 335             if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {</span>
<span class="line-added"> 336                 pointerCaptureController.dispatchEvent(*pointerEvent, this);</span>
<span class="line-added"> 337                 if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))</span>
<span class="line-added"> 338                     return false;</span>
<span class="line-added"> 339                 if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {</span>
<span class="line-added"> 340                     didNotSwallowEvent = false;</span>
<span class="line-added"> 341                     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)</span>
<span class="line-added"> 342                         return false;</span>
<span class="line-added"> 343                 }</span>
<span class="line-added"> 344             }</span>
<span class="line-added"> 345 #endif</span>
<span class="line-added"> 346         }</span>
<span class="line-added"> 347     }</span>
<span class="line-added"> 348 #endif</span>
<span class="line-added"> 349 </span>
 350     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 351     dispatchEvent(mouseEvent);
<span class="line-modified"> 352     if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())</span>
<span class="line-added"> 353         didNotSwallowEvent = false;</span>
 354 
 355     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 356         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 357         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 358         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 359         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 360         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 361             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 362             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 363             Event::IsComposed::Yes,
 364             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 365             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 366             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 367 
 368         if (mouseEvent-&gt;defaultHandled())
 369             doubleClickEvent-&gt;setDefaultHandled();
 370 
 371         dispatchEvent(doubleClickEvent);
 372         if (doubleClickEvent-&gt;defaultHandled() || doubleClickEvent-&gt;defaultPrevented())
 373             return false;
</pre>
<hr />
<pre>
 472         return false;
 473 
 474     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 475     return true;
 476 }
 477 
 478 void Element::setBooleanAttribute(const QualifiedName&amp; name, bool value)
 479 {
 480     if (value)
 481         setAttribute(name, emptyAtom());
 482     else
 483         removeAttribute(name);
 484 }
 485 
 486 NamedNodeMap&amp; Element::attributes() const
 487 {
 488     ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
 489     if (NamedNodeMap* attributeMap = rareData.attributeMap())
 490         return *attributeMap;
 491 
<span class="line-modified"> 492     rareData.setAttributeMap(makeUnique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));</span>
 493     return *rareData.attributeMap();
 494 }
 495 
 496 Node::NodeType Element::nodeType() const
 497 {
 498     return ELEMENT_NODE;
 499 }
 500 
 501 bool Element::hasAttribute(const QualifiedName&amp; name) const
 502 {
 503     return hasAttributeNS(name.namespaceURI(), name.localName());
 504 }
 505 
 506 void Element::synchronizeAllAttributes() const
 507 {
 508     if (!elementData())
 509         return;
 510     if (elementData()-&gt;styleAttributeIsDirty()) {
 511         ASSERT(isStyledElement());
 512         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 513     }
 514 
<span class="line-modified"> 515     if (isSVGElement())</span>
<span class="line-modified"> 516         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAllAttributes();</span>


 517 }
 518 
 519 ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
 520 {
 521     if (!elementData())
 522         return;
 523     if (UNLIKELY(name == styleAttr &amp;&amp; elementData()-&gt;styleAttributeIsDirty())) {
 524         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 525         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 526         return;
 527     }
 528 
<span class="line-modified"> 529     if (isSVGElement())</span>
<span class="line-modified"> 530         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(name);</span>


 531 }
 532 
<span class="line-modified"> 533 static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomString&amp; attributeLocalName)</span>
 534 {
 535     if (shouldIgnoreAttributeCase(element))
 536         return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
 537     return attributeLocalName == styleAttr-&gt;localName();
 538 }
 539 
<span class="line-modified"> 540 ALWAYS_INLINE void Element::synchronizeAttribute(const AtomString&amp; localName) const</span>
 541 {
 542     // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
 543     // e.g when called from DOM API.
 544     if (!elementData())
 545         return;
 546     if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
 547         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 548         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 549         return;
 550     }
<span class="line-modified"> 551 </span>
<span class="line-modified"> 552     if (isSVGElement())</span>
<span class="line-modified"> 553         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(QualifiedName(nullAtom(), localName, nullAtom()));</span>


 554 }
 555 
<span class="line-modified"> 556 const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name) const</span>
 557 {
 558     if (!elementData())
 559         return nullAtom();
 560     synchronizeAttribute(name);
 561     if (const Attribute* attribute = findAttributeByName(name))
 562         return attribute-&gt;value();
 563     return nullAtom();
 564 }
 565 
 566 Vector&lt;String&gt; Element::getAttributeNames() const
 567 {
 568     Vector&lt;String&gt; attributesVector;
 569     if (!hasAttributes())
 570         return attributesVector;
 571 
 572     auto attributes = attributesIterator();
 573     attributesVector.reserveInitialCapacity(attributes.attributeCount());
 574     for (auto&amp; attribute : attributes)
 575         attributesVector.uncheckedAppend(attribute.name().toString());
 576     return attributesVector;
 577 }
 578 
 579 bool Element::isFocusable() const
 580 {
 581     if (!isConnected() || !supportsFocus())
 582         return false;
 583 
 584     if (!renderer()) {
 585         // If the node is in a display:none tree it might say it needs style recalc but
 586         // the whole document is actually up to date.
<span class="line-modified"> 587         // FIXME: We should be able to assert !needsStyleRecalc() || !document().childNeedsStyleRecalc()</span>
<span class="line-added"> 588         // but it hits too frequently on websites like Gmail and Microsoft Exchange.</span>
 589 
 590         // Elements in canvas fallback content are not rendered, but they are allowed to be
 591         // focusable as long as their canvas is displayed and visible.
 592         if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
 593             return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
 594     }
 595 
 596     // FIXME: Even if we are not visible, we might have a child that is visible.
 597     // Hyatt wants to fix that some day with a &quot;has visible content&quot; flag or the like.
 598     if (!renderer() || renderer()-&gt;style().visibility() != Visibility::Visible)
 599         return false;
 600 
 601     return true;
 602 }
 603 
 604 bool Element::isUserActionElementInActiveChain() const
 605 {
 606     ASSERT(isUserActionElement());
 607     return document().userActionElements().isInActiveChain(*this);
 608 }
</pre>
<hr />
<pre>
 696     auto* style = renderOrDisplayContentsStyle();
 697     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 698         invalidateStyleForSubtree();
 699 
 700     if (!renderer()) {
 701         // When setting hover to false, the style needs to be recalc&#39;d even when
 702         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 703         // if a nil renderer would prevent this element from recalculating its
 704         // style, it would never go back to its normal style and remain
 705         // stuck in its hovered style).
 706         if (!flag &amp;&amp; !style)
 707             invalidateStyleForSubtree();
 708 
 709         return;
 710     }
 711 
 712     if (style-&gt;hasAppearance())
 713         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
 714 }
 715 
<span class="line-modified"> 716 inline ScrollAlignment toScrollAlignmentForInlineDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode, bool isLTR)</span>

 717 {
<span class="line-modified"> 718     switch (position.valueOr(ScrollLogicalPosition::Nearest)) {</span>
<span class="line-modified"> 719     case ScrollLogicalPosition::Start: {</span>
<span class="line-modified"> 720         switch (writingMode) {</span>
<span class="line-added"> 721         case TopToBottomWritingMode:</span>
<span class="line-added"> 722         case BottomToTopWritingMode: {</span>
<span class="line-added"> 723             return isLTR ? ScrollAlignment::alignLeftAlways : ScrollAlignment::alignRightAlways;</span>
<span class="line-added"> 724         }</span>
<span class="line-added"> 725         case LeftToRightWritingMode:</span>
<span class="line-added"> 726         case RightToLeftWritingMode: {</span>
<span class="line-added"> 727             return isLTR ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignBottomAlways;</span>
<span class="line-added"> 728         }</span>
<span class="line-added"> 729         default:</span>
<span class="line-added"> 730             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 731             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added"> 732         }</span>
<span class="line-added"> 733     }</span>
 734     case ScrollLogicalPosition::Center:
 735         return ScrollAlignment::alignCenterAlways;
<span class="line-modified"> 736     case ScrollLogicalPosition::End: {</span>
<span class="line-modified"> 737         switch (writingMode) {</span>
<span class="line-added"> 738         case TopToBottomWritingMode:</span>
<span class="line-added"> 739         case BottomToTopWritingMode: {</span>
<span class="line-added"> 740             return isLTR ? ScrollAlignment::alignRightAlways : ScrollAlignment::alignLeftAlways;</span>
<span class="line-added"> 741         }</span>
<span class="line-added"> 742         case LeftToRightWritingMode:</span>
<span class="line-added"> 743         case RightToLeftWritingMode: {</span>
<span class="line-added"> 744             return isLTR ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignTopAlways;</span>
<span class="line-added"> 745         }</span>
<span class="line-added"> 746         default:</span>
<span class="line-added"> 747             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 748             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added"> 749         }</span>
<span class="line-added"> 750     }</span>
<span class="line-added"> 751     case ScrollLogicalPosition::Nearest:</span>
<span class="line-added"> 752         return ScrollAlignment::alignToEdgeIfNeeded;</span>
<span class="line-added"> 753     default:</span>
<span class="line-added"> 754         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 755         return ScrollAlignment::alignToEdgeIfNeeded;</span>
<span class="line-added"> 756     }</span>
<span class="line-added"> 757 }</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759 inline ScrollAlignment toScrollAlignmentForBlockDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode)</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     switch (position.valueOr(ScrollLogicalPosition::Start)) {</span>
<span class="line-added"> 762     case ScrollLogicalPosition::Start: {</span>
<span class="line-added"> 763         switch (writingMode) {</span>
<span class="line-added"> 764         case TopToBottomWritingMode:</span>
<span class="line-added"> 765             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added"> 766         case BottomToTopWritingMode:</span>
<span class="line-added"> 767             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added"> 768         case LeftToRightWritingMode:</span>
<span class="line-added"> 769             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added"> 770         case RightToLeftWritingMode:</span>
<span class="line-added"> 771             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added"> 772         default:</span>
<span class="line-added"> 773             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 774             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added"> 775         }</span>
<span class="line-added"> 776     }</span>
<span class="line-added"> 777     case ScrollLogicalPosition::Center:</span>
<span class="line-added"> 778         return ScrollAlignment::alignCenterAlways;</span>
<span class="line-added"> 779     case ScrollLogicalPosition::End: {</span>
<span class="line-added"> 780         switch (writingMode) {</span>
<span class="line-added"> 781         case TopToBottomWritingMode:</span>
<span class="line-added"> 782             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added"> 783         case BottomToTopWritingMode:</span>
<span class="line-added"> 784             return ScrollAlignment::alignTopAlways;</span>
<span class="line-added"> 785         case LeftToRightWritingMode:</span>
<span class="line-added"> 786             return ScrollAlignment::alignRightAlways;</span>
<span class="line-added"> 787         case RightToLeftWritingMode:</span>
<span class="line-added"> 788             return ScrollAlignment::alignLeftAlways;</span>
<span class="line-added"> 789         default:</span>
<span class="line-added"> 790             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 791             return ScrollAlignment::alignBottomAlways;</span>
<span class="line-added"> 792         }</span>
<span class="line-added"> 793     }</span>
 794     case ScrollLogicalPosition::Nearest:
 795         return ScrollAlignment::alignToEdgeIfNeeded;
 796     default:
 797         ASSERT_NOT_REACHED();
 798         return ScrollAlignment::alignToEdgeIfNeeded;
 799     }
 800 }
 801 
 802 void Element::scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg)
 803 {
 804     document().updateLayoutIgnorePendingStylesheets();
 805 
 806     if (!renderer())
 807         return;
 808 
 809     bool insideFixed;
 810     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 811 
 812     // FIXME(webkit.org/b/188043): Support ScrollBehavior.
 813     ScrollIntoViewOptions options;
 814     if (arg) {
 815         auto value = arg.value();
 816         if (WTF::holds_alternative&lt;ScrollIntoViewOptions&gt;(value))
 817             options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
 818         else if (!WTF::get&lt;bool&gt;(value))
 819             options.blockPosition = ScrollLogicalPosition::End;
 820     }
 821 
<span class="line-modified"> 822     auto writingMode = renderer()-&gt;style().writingMode();</span>
<span class="line-modified"> 823     ScrollAlignment alignX = toScrollAlignmentForInlineDirection(options.inlinePosition, writingMode, renderer()-&gt;style().isLeftToRightDirection());</span>
<span class="line-modified"> 824     ScrollAlignment alignY = toScrollAlignmentForBlockDirection(options.blockPosition, writingMode);</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826     bool isHorizontal = renderer()-&gt;style().isHorizontalWritingMode();</span>
<span class="line-added"> 827     ScrollRectToVisibleOptions visibleOptions {</span>
<span class="line-added"> 828         SelectionRevealMode::Reveal,</span>
<span class="line-added"> 829         isHorizontal ? alignX : alignY,</span>
<span class="line-added"> 830         isHorizontal ? alignY : alignX,</span>
<span class="line-added"> 831         ShouldAllowCrossOriginScrolling::No</span>
<span class="line-added"> 832     };</span>
<span class="line-added"> 833     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, visibleOptions);</span>
 834 }
 835 
 836 void Element::scrollIntoView(bool alignToTop)
 837 {
 838     document().updateLayoutIgnorePendingStylesheets();
 839 
 840     if (!renderer())
 841         return;
 842 
 843     bool insideFixed;
 844     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 845     // Align to the top / bottom and to the closest edge.
 846     if (alignToTop)
 847         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
 848     else
 849         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignBottomAlways, ShouldAllowCrossOriginScrolling::No });
 850 }
 851 
 852 void Element::scrollIntoViewIfNeeded(bool centerIfNeeded)
 853 {
</pre>
<hr />
<pre>
 908         // invoke scroll() on window with options as the only argument, and terminate these steps.
 909         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 910         auto window = makeRefPtr(document().domWindow());
 911         if (!window)
 912             return;
 913 
 914         window-&gt;scrollTo(options);
 915         return;
 916     }
 917 
 918     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 919     // or the element has no overflow, terminate these steps.
 920     RenderBox* renderer = renderBox();
 921     if (!renderer || !renderer-&gt;hasOverflowClip())
 922         return;
 923 
 924     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 925         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 926         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 927     );
<span class="line-modified"> 928     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);</span>
<span class="line-modified"> 929     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);</span>
 930 }
 931 
 932 void Element::scrollTo(double x, double y)
 933 {
 934     scrollTo({ x, y });
 935 }
 936 
 937 void Element::scrollByUnits(int units, ScrollGranularity granularity)
 938 {
 939     document().updateLayoutIgnorePendingStylesheets();
 940 
 941     auto* renderer = this-&gt;renderer();
 942     if (!renderer)
 943         return;
 944 
 945     if (!renderer-&gt;hasOverflowClip())
 946         return;
 947 
 948     ScrollDirection direction = ScrollDown;
 949     if (units &lt; 0) {
</pre>
<hr />
<pre>
1230             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().y(), *frame);
1231         return 0;
1232     }
1233 
1234     if (RenderBox* renderer = renderBox())
1235         return adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer);
1236     return 0;
1237 }
1238 
1239 void Element::setScrollLeft(int newLeft)
1240 {
1241     document().updateLayoutIgnorePendingStylesheets();
1242 
1243     if (document().scrollingElement() == this) {
1244         if (auto* frame = documentFrameWithNonNullView())
1245             frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
1246         return;
1247     }
1248 
1249     if (auto* renderer = renderBox()) {
<span class="line-modified">1250         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);</span>
1251         if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">1252             scrollableArea-&gt;setScrollShouldClearLatchedState(true);</span>
1253     }
1254 }
1255 
1256 void Element::setScrollTop(int newTop)
1257 {
1258     document().updateLayoutIgnorePendingStylesheets();
1259 
1260     if (document().scrollingElement() == this) {
1261         if (auto* frame = documentFrameWithNonNullView())
1262             frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
1263         return;
1264     }
1265 
1266     if (auto* renderer = renderBox()) {
<span class="line-modified">1267         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);</span>
1268         if (auto* scrollableArea = renderer-&gt;layer())
<span class="line-modified">1269             scrollableArea-&gt;setScrollShouldClearLatchedState(true);</span>
1270     }
1271 }
1272 
1273 int Element::scrollWidth()
1274 {
1275     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1276 
1277     if (document().scrollingElement() == this) {
1278         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1279         document().updateLayoutIgnorePendingStylesheets();
1280         if (auto* frame = documentFrameWithNonNullView())
1281             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsWidth(), *frame);
1282         return 0;
1283     }
1284 
1285     if (auto* renderer = renderBox())
1286         return adjustForAbsoluteZoom(renderer-&gt;scrollWidth(), *renderer);
1287     return 0;
1288 }
1289 
</pre>
<hr />
<pre>
1504 
1505     RenderObject* renderer = this-&gt;renderer();
1506     Vector&lt;FloatQuad&gt; quads;
1507 
1508     if (auto pair = listBoxElementBoundingBox(*this)) {
1509         renderer = pair.value().first;
1510         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1511     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1512         renderBoxModelObject-&gt;absoluteQuads(quads);
1513 
1514     // FIXME: Handle SVG elements.
1515     // FIXME: Handle table/inline-table with a caption.
1516 
1517     if (quads.isEmpty())
1518         return DOMRectList::create();
1519 
1520     document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
1521     return DOMRectList::create(quads);
1522 }
1523 
<span class="line-modified">1524 Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; Element::boundingAbsoluteRectWithoutLayout()</span>
1525 {


1526     RenderObject* renderer = this-&gt;renderer();
1527     Vector&lt;FloatQuad&gt; quads;
1528     if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
1529         // Get the bounding rectangle from the SVG model.
1530         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1531         FloatRect localRect;
1532         if (svgElement.getBoundingBox(localRect))
1533             quads.append(renderer-&gt;localToAbsoluteQuad(localRect));
1534     } else if (auto pair = listBoxElementBoundingBox(*this)) {
1535         renderer = pair.value().first;
1536         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1537     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1538         renderBoxModelObject-&gt;absoluteQuads(quads);
1539 
1540     if (quads.isEmpty())
<span class="line-modified">1541         return WTF::nullopt;</span>
1542 
1543     FloatRect result = quads[0].boundingBox();
1544     for (size_t i = 1; i &lt; quads.size(); ++i)
1545         result.unite(quads[i].boundingBox());
1546 
<span class="line-added">1547     return std::make_pair(renderer, result);</span>
<span class="line-added">1548 }</span>
<span class="line-added">1549 </span>
<span class="line-added">1550 FloatRect Element::boundingClientRect()</span>
<span class="line-added">1551 {</span>
<span class="line-added">1552     document().updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">1553     auto pair = boundingAbsoluteRectWithoutLayout();</span>
<span class="line-added">1554     if (!pair)</span>
<span class="line-added">1555         return { };</span>
<span class="line-added">1556     RenderObject* renderer = pair-&gt;first;</span>
<span class="line-added">1557     FloatRect result = pair-&gt;second;</span>
1558     document().convertAbsoluteToClientRect(result, renderer-&gt;style());
1559     return result;
1560 }
1561 
1562 Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
1563 {
1564     return DOMRect::create(boundingClientRect());
1565 }
1566 
1567 // Note that this is not web-exposed, and does not use the same coordinate system as getBoundingClientRect() and friends.
1568 IntRect Element::clientRect() const
1569 {
1570     if (RenderObject* renderer = this-&gt;renderer())
1571         return document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
1572     return IntRect();
1573 }
1574 
1575 IntRect Element::screenRect() const
1576 {
1577     if (RenderObject* renderer = this-&gt;renderer())
1578         return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
1579     return IntRect();
1580 }
1581 
<span class="line-modified">1582 const AtomString&amp; Element::getAttribute(const AtomString&amp; qualifiedName) const</span>
1583 {
1584     if (!elementData())
1585         return nullAtom();
1586     synchronizeAttribute(qualifiedName);
1587     if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
1588         return attribute-&gt;value();
1589     return nullAtom();
1590 }
1591 
<span class="line-modified">1592 const AtomString&amp; Element::getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const</span>
1593 {
1594     return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
1595 }
1596 
1597 // https://dom.spec.whatwg.org/#dom-element-toggleattribute
<span class="line-modified">1598 ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force)</span>
1599 {
1600     if (!Document::isValidName(qualifiedName))
1601         return Exception { InvalidCharacterError };
1602 
1603     synchronizeAttribute(qualifiedName);
1604 
1605     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1606     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1607     if (index == ElementData::attributeNotFound) {
1608         if (!force || *force) {
1609             setAttributeInternal(index, QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() }, emptyString(), NotInSynchronizationOfLazyAttribute);
1610             return true;
1611         }
1612         return false;
1613     }
1614 
1615     if (!force || !*force) {
1616         removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
1617         return false;
1618     }
1619     return true;
1620 }
1621 
<span class="line-modified">1622 ExceptionOr&lt;void&gt; Element::setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value)</span>
1623 {
1624     if (!Document::isValidName(qualifiedName))
1625         return Exception { InvalidCharacterError };
1626 
1627     synchronizeAttribute(qualifiedName);
1628     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1629     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1630     auto name = index != ElementData::attributeNotFound ? attributeAt(index).name() : QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() };
1631     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1632 
1633     return { };
1634 }
1635 
<span class="line-modified">1636 void Element::setAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
1637 {
1638     synchronizeAttribute(name);
1639     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1640     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1641 }
1642 
<span class="line-modified">1643 void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomString&amp; value)</span>
1644 {
1645     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1646     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1647 }
1648 
<span class="line-modified">1649 void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
1650 {
1651     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1652     setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
1653 }
1654 
<span class="line-modified">1655 inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
1656 {
1657     if (newValue.isNull()) {
1658         if (index != ElementData::attributeNotFound)
1659             removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
1660         return;
1661     }
1662 
1663     if (index == ElementData::attributeNotFound) {
1664         addAttributeInternal(name, newValue, inSynchronizationOfLazyAttribute);
1665         return;
1666     }
1667 
1668     if (inSynchronizationOfLazyAttribute) {
1669         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1670         return;
1671     }
1672 
1673     const Attribute&amp; attribute = attributeAt(index);
1674     QualifiedName attributeName = attribute.name();
<span class="line-modified">1675     AtomString oldValue = attribute.value();</span>
1676 
1677     willModifyAttribute(attributeName, oldValue, newValue);
1678 
1679     if (newValue != oldValue) {
1680         Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
1681         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1682     }
1683 
1684     didModifyAttribute(attributeName, oldValue, newValue);
1685 }
1686 
<span class="line-modified">1687 static inline AtomString makeIdForStyleResolution(const AtomString&amp; value, bool inQuirksMode)</span>
1688 {
1689     if (inQuirksMode)
1690         return value.convertToASCIILowercase();
1691     return value;
1692 }
1693 
<span class="line-modified">1694 void Element::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)</span>
1695 {
1696     bool valueIsSameAsBefore = oldValue == newValue;
1697 
1698     if (!valueIsSameAsBefore) {
1699         if (name == HTMLNames::accesskeyAttr)
1700             document().invalidateAccessKeyCache();
1701         else if (name == HTMLNames::classAttr)
1702             classAttributeChanged(newValue);
1703         else if (name == HTMLNames::idAttr) {
<span class="line-modified">1704             AtomString oldId = elementData()-&gt;idForStyleResolution();</span>
<span class="line-modified">1705             AtomString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());</span>
1706             if (newId != oldId) {
1707                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1708                 elementData()-&gt;setIdForStyleResolution(newId);
1709             }
1710 
1711             if (!oldValue.isEmpty())
1712                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1713             if (!newValue.isEmpty())
1714                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1715         } else if (name == HTMLNames::nameAttr)
1716             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1717         else if (name == HTMLNames::pseudoAttr) {
1718             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1719                 invalidateStyleForSubtree();
1720         } else if (name == HTMLNames::slotAttr) {
1721             if (auto* parent = parentElement()) {
1722                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1723                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1724             }
1725         }
</pre>
<hr />
<pre>
1739 
1740     if (AXObjectCache* cache = document().existingAXObjectCache())
1741         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1742 }
1743 
1744 template &lt;typename CharacterType&gt;
1745 static inline bool classStringHasClassName(const CharacterType* characters, unsigned length)
1746 {
1747     ASSERT(length &gt; 0);
1748 
1749     unsigned i = 0;
1750     do {
1751         if (isNotHTMLSpace(characters[i]))
1752             break;
1753         ++i;
1754     } while (i &lt; length);
1755 
1756     return i &lt; length;
1757 }
1758 
<span class="line-modified">1759 static inline bool classStringHasClassName(const AtomString&amp; newClassString)</span>
1760 {
1761     unsigned length = newClassString.length();
1762 
1763     if (!length)
1764         return false;
1765 
1766     if (newClassString.is8Bit())
1767         return classStringHasClassName(newClassString.characters8(), length);
1768     return classStringHasClassName(newClassString.characters16(), length);
1769 }
1770 
<span class="line-modified">1771 void Element::classAttributeChanged(const AtomString&amp; newClassString)</span>
1772 {
1773     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1774     if (!elementData())
1775         ensureUniqueElementData();
1776 
1777     bool shouldFoldCase = document().inQuirksMode();
1778     bool newStringHasClasses = classStringHasClassName(newClassString);
1779 
1780     auto oldClassNames = elementData()-&gt;classNames();
1781     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1782     {
1783         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1784         elementData()-&gt;setClassNames(newClassNames);
1785     }
1786 
1787     if (hasRareData()) {
1788         if (auto* classList = elementRareData()-&gt;classList())
1789             classList-&gt;associatedAttributeValueChanged(newClassString);
1790     }
1791 }
1792 
1793 URL Element::absoluteLinkURL() const
1794 {
1795     if (!isLink())
1796         return URL();
1797 
<span class="line-modified">1798     AtomString linkAttribute;</span>
1799     if (hasTagName(SVGNames::aTag))
1800         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1801     else
1802         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1803 
1804     if (linkAttribute.isEmpty())
1805         return URL();
1806 
1807     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1808 }
1809 
1810 #if ENABLE(TOUCH_EVENTS)
1811 bool Element::allowsDoubleTapGesture() const
1812 {
1813 #if ENABLE(POINTER_EVENTS)
1814     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1815         return false;
1816 #endif
1817 
1818     Element* parent = parentElement();
</pre>
<hr />
<pre>
1996     other.synchronizeAllAttributes();
1997     if (elementData() == other.elementData())
1998         return true;
1999     if (elementData())
2000         return elementData()-&gt;isEquivalent(other.elementData());
2001     if (other.elementData())
2002         return other.elementData()-&gt;isEquivalent(elementData());
2003     return true;
2004 }
2005 
2006 String Element::nodeName() const
2007 {
2008     return m_tagName.toString();
2009 }
2010 
2011 String Element::nodeNamePreservingCase() const
2012 {
2013     return m_tagName.toString();
2014 }
2015 
<span class="line-modified">2016 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomString&amp; prefix)</span>
2017 {
2018     auto result = checkSetPrefix(prefix);
2019     if (result.hasException())
2020         return result.releaseException();
2021 
2022     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
2023     return { };
2024 }
2025 
<span class="line-modified">2026 const AtomString&amp; Element::imageSourceURL() const</span>
2027 {
2028     return attributeWithoutSynchronization(srcAttr);
2029 }
2030 
2031 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
2032 {
2033     return style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;
2034 }
2035 
2036 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
2037 {
2038     return RenderElement::createFor(*this, WTFMove(style));
2039 }
2040 
2041 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
2042 {
2043     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
2044 
2045 #if ENABLE(FULLSCREEN_API)
2046     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
2047         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
2048 #endif
2049 
2050     if (parentNode() == &amp;parentOfInsertedTree) {
2051         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
2052             shadowRoot-&gt;hostChildElementDidChange(*this);
2053     }
2054 
2055     if (!parentOfInsertedTree.isInTreeScope())
2056         return InsertedIntoAncestorResult::Done;
2057 
2058     bool becomeConnected = insertionType.connectedToDocument;
2059     TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
2060     HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
2061     if (!insertionType.treeScopeChanged)
2062         newScope = nullptr;
2063 
<span class="line-modified">2064     const AtomString&amp; idValue = getIdAttribute();</span>
2065     if (!idValue.isNull()) {
2066         if (newScope)
2067             updateIdForTreeScope(*newScope, nullAtom(), idValue);
2068         if (newDocument)
2069             updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
2070     }
2071 
<span class="line-modified">2072     const AtomString&amp; nameValue = getNameAttribute();</span>
2073     if (!nameValue.isNull()) {
2074         if (newScope)
2075             updateNameForTreeScope(*newScope, nullAtom(), nameValue);
2076         if (newDocument)
2077             updateNameForDocument(*newDocument, nullAtom(), nameValue);
2078     }
2079 
2080     if (newScope &amp;&amp; hasTagName(labelTag)) {
2081         if (newScope-&gt;shouldCacheLabelsByForAttribute())
2082             updateLabel(*newScope, nullAtom(), attributeWithoutSynchronization(forAttr));
2083     }
2084 
2085     if (becomeConnected) {
2086         if (UNLIKELY(isCustomElementUpgradeCandidate())) {
2087             ASSERT(isConnected());
2088             CustomElementReactionQueue::enqueueElementUpgradeIfDefined(*this);
2089         }
2090         if (UNLIKELY(isDefinedCustomElement()))
2091             CustomElementReactionQueue::enqueueConnectedCallbackIfNeeded(*this);
2092     }
2093 
2094     if (UNLIKELY(hasTagName(articleTag) &amp;&amp; newDocument))
2095         newDocument-&gt;registerArticleElement(*this);
2096 
2097     return InsertedIntoAncestorResult::Done;
2098 }
2099 
2100 void Element::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
2101 {
2102 #if ENABLE(FULLSCREEN_API)
2103     if (containsFullScreenElement())
2104         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
2105 #endif
2106 #if ENABLE(POINTER_LOCK)
2107     if (document().page())
2108         document().page()-&gt;pointerLockController().elementRemoved(*this);
2109 #endif
<span class="line-added">2110 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2111     if (document().page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled())</span>
<span class="line-added">2112         document().page()-&gt;pointerCaptureController().elementWasRemoved(*this);</span>
<span class="line-added">2113 #endif</span>
2114 
2115     setSavedLayerScrollPosition(ScrollPosition());
2116 
2117     if (oldParentOfRemovedTree.isInTreeScope()) {
2118         TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
2119         Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
2120         HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
2121         if (!removalType.treeScopeChanged)
2122             oldScope = nullptr;
2123 
<span class="line-modified">2124         const AtomString&amp; idValue = getIdAttribute();</span>
2125         if (!idValue.isNull()) {
2126             if (oldScope)
2127                 updateIdForTreeScope(*oldScope, idValue, nullAtom());
2128             if (oldHTMLDocument)
2129                 updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
2130         }
2131 
<span class="line-modified">2132         const AtomString&amp; nameValue = getNameAttribute();</span>
2133         if (!nameValue.isNull()) {
2134             if (oldScope)
2135                 updateNameForTreeScope(*oldScope, nameValue, nullAtom());
2136             if (oldHTMLDocument)
2137                 updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
2138         }
2139 
2140         if (oldScope &amp;&amp; hasTagName(labelTag)) {
2141             if (oldScope-&gt;shouldCacheLabelsByForAttribute())
2142                 updateLabel(*oldScope, attributeWithoutSynchronization(forAttr), nullAtom());
2143         }
2144 
2145         if (oldDocument) {
2146             if (oldDocument-&gt;cssTarget() == this)
2147                 oldDocument-&gt;setCSSTarget(nullptr);
2148             if (UNLIKELY(hasTagName(articleTag)))
2149                 oldDocument-&gt;unregisterArticleElement(*this);
2150         }
2151 
2152         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
</pre>
<hr />
<pre>
2159     }
2160 
2161     clearBeforePseudoElement();
2162     clearAfterPseudoElement();
2163 
2164     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2165 
2166     if (hasPendingResources())
2167         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2168 
2169     RefPtr&lt;Frame&gt; frame = document().frame();
2170     if (auto* timeline = document().existingTimeline())
2171         timeline-&gt;elementWasRemoved(*this);
2172     if (frame)
2173         frame-&gt;animation().cancelAnimations(*this);
2174 
2175 #if PLATFORM(MAC)
2176     if (frame &amp;&amp; frame-&gt;page())
2177         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2178 #endif
<span class="line-added">2179 </span>
<span class="line-added">2180     if (hasRareData() &amp;&amp; elementRareData()-&gt;hasElementIdentifier()) {</span>
<span class="line-added">2181         document().identifiedElementWasRemovedFromDocument(*this);</span>
<span class="line-added">2182         elementRareData()-&gt;setHasElementIdentifier(false);</span>
<span class="line-added">2183     }</span>
2184 }
2185 
2186 ShadowRoot* Element::shadowRoot() const
2187 {
2188     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2189 }
2190 
2191 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2192 {
2193     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2194     ASSERT(!shadowRoot());
2195 
2196     ShadowRoot&amp; shadowRoot = newShadowRoot;
2197     {
2198         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2199         if (renderer())
2200             RenderTreeUpdater::tearDownRenderers(*this);
2201 
2202         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2203 
</pre>
<hr />
<pre>
2221 
2222 void Element::removeShadowRoot()
2223 {
2224     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2225     if (!oldRoot)
2226         return;
2227 
2228     InspectorInstrumentation::willPopShadowRoot(*this, *oldRoot);
2229     document().adjustFocusedNodeOnNodeRemoval(*oldRoot);
2230 
2231     ASSERT(!oldRoot-&gt;renderer());
2232 
2233     elementRareData()-&gt;clearShadowRoot();
2234 
2235     oldRoot-&gt;setHost(nullptr);
2236     oldRoot-&gt;setParentTreeScope(document());
2237 }
2238 
2239 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2240 {
<span class="line-modified">2241     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {</span>
2242         static const HTMLQualifiedName* const tagList[] = {
2243             &amp;articleTag.get(),
2244             &amp;asideTag.get(),
2245             &amp;blockquoteTag.get(),
2246             &amp;bodyTag.get(),
2247             &amp;divTag.get(),
2248             &amp;footerTag.get(),
2249             &amp;h1Tag.get(),
2250             &amp;h2Tag.get(),
2251             &amp;h3Tag.get(),
2252             &amp;h4Tag.get(),
2253             &amp;h5Tag.get(),
2254             &amp;h6Tag.get(),
2255             &amp;headerTag.get(),
2256             &amp;navTag.get(),
2257             &amp;pTag.get(),
2258             &amp;sectionTag.get(),
2259             &amp;spanTag.get()
2260         };
<span class="line-modified">2261         HashSet&lt;AtomString&gt; set;</span>
2262         for (auto&amp; name : tagList)
2263             set.add(name-&gt;localName());
2264         return set;
2265     }();
2266 
2267     if (!is&lt;HTMLElement&gt;(element))
2268         return false;
2269 
2270     const auto&amp; localName = element.localName();
2271     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2272 }
2273 
2274 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2275 {
2276     if (!canAttachAuthorShadowRoot(*this))
2277         return Exception { NotSupportedError };
2278     if (shadowRoot())
2279         return Exception { InvalidStateError };
2280     if (init.mode == ShadowRootMode::UserAgent)
2281         return Exception { TypeError };
</pre>
<hr />
<pre>
2302     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2303     return shadowRoot();
2304 }
2305 
2306 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2307 {
2308     if (auto shadow = userAgentShadowRoot())
2309         return *shadow;
2310     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2311     ShadowRoot&amp; shadow = newShadow;
2312     addShadowRoot(WTFMove(newShadow));
2313     return shadow;
2314 }
2315 
2316 void Element::setIsDefinedCustomElement(JSCustomElementInterface&amp; elementInterface)
2317 {
2318     clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
2319     setFlag(IsCustomElement);
2320     auto&amp; data = ensureElementRareData();
2321     if (!data.customElementReactionQueue())
<span class="line-modified">2322         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
2323     invalidateStyleForSubtree();
2324     InspectorInstrumentation::didChangeCustomElementState(*this);
2325 }
2326 
2327 void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
2328 {
2329     ASSERT(isUndefinedCustomElement());
2330     ASSERT(getFlag(IsEditingTextOrUndefinedCustomElementFlag));
2331     clearFlag(IsCustomElement);
2332 
2333     if (hasRareData()) {
2334         // Clear the queue instead of deleting it since this function can be called inside CustomElementReactionQueue::invokeAll during upgrades.
2335         if (auto* queue = elementRareData()-&gt;customElementReactionQueue())
2336             queue-&gt;clear();
2337     }
2338     InspectorInstrumentation::didChangeCustomElementState(*this);
2339 }
2340 
2341 void Element::setIsCustomElementUpgradeCandidate()
2342 {
2343     ASSERT(!getFlag(IsCustomElement));
2344     setFlag(IsCustomElement);
2345     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2346     InspectorInstrumentation::didChangeCustomElementState(*this);
2347 }
2348 
2349 void Element::enqueueToUpgrade(JSCustomElementInterface&amp; elementInterface)
2350 {
2351     ASSERT(!isDefinedCustomElement() &amp;&amp; !isFailedCustomElement());
2352     setFlag(IsCustomElement);
2353     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2354     InspectorInstrumentation::didChangeCustomElementState(*this);
2355 
2356     auto&amp; data = ensureElementRareData();
2357     bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
2358     if (!alreadyScheduledToUpgrade)
<span class="line-modified">2359         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));</span>
2360     data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
2361 }
2362 
2363 CustomElementReactionQueue* Element::reactionQueue() const
2364 {
2365     ASSERT(isDefinedCustomElement() || isCustomElementUpgradeCandidate());
2366     if (!hasRareData())
2367         return nullptr;
2368     return elementRareData()-&gt;customElementReactionQueue();
2369 }
2370 
<span class="line-modified">2371 const AtomString&amp; Element::shadowPseudoId() const</span>
2372 {
2373     return pseudo();
2374 }
2375 
2376 bool Element::childTypeAllowed(NodeType type) const
2377 {
2378     switch (type) {
2379     case ELEMENT_NODE:
2380     case TEXT_NODE:
2381     case COMMENT_NODE:
2382     case PROCESSING_INSTRUCTION_NODE:
2383     case CDATA_SECTION_NODE:
2384         return true;
2385     default:
2386         break;
2387     }
2388     return false;
2389 }
2390 
2391 static void checkForEmptyStyleChange(Element&amp; element)
</pre>
<hr />
<pre>
2509         case ElementInserted:
2510         case ElementRemoved:
2511             // For elements, we notify shadowRoot in Element::insertedIntoAncestor and Element::removedFromAncestor.
2512             break;
2513         case AllChildrenRemoved:
2514         case AllChildrenReplaced:
2515             shadowRoot-&gt;didRemoveAllChildrenOfShadowHost();
2516             break;
2517         case TextInserted:
2518         case TextRemoved:
2519         case TextChanged:
2520             shadowRoot-&gt;didChangeDefaultSlot();
2521             break;
2522         case NonContentsChildInserted:
2523         case NonContentsChildRemoved:
2524             break;
2525         }
2526     }
2527 }
2528 
<span class="line-modified">2529 void Element::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue)</span>
2530 {
2531     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
2532 }
2533 
2534 void Element::removeAllEventListeners()
2535 {
2536     ContainerNode::removeAllEventListeners();
2537     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2538         shadowRoot-&gt;removeAllEventListeners();
2539 }
2540 
2541 void Element::beginParsingChildren()
2542 {
2543     clearIsParsingChildrenFinished();
2544 }
2545 
2546 void Element::finishParsingChildren()
2547 {
2548     ContainerNode::finishParsingChildren();
2549     setIsParsingChildrenFinished();
</pre>
<hr />
<pre>
2583     ASSERT(hasSyntheticAttrChildNodes());
2584     return *attrNodeListForElement(*this);
2585 }
2586 
2587 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2588 {
2589     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2590     if (attrNode.ownerElement() == this)
2591         return;
2592 
2593     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2594 
2595     attrNode.attachToElement(*this);
2596     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2597 }
2598 
2599 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
2600 {
2601     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2602     if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">2603         return oldAttrNode;</span>
2604 
2605     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2606     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2607     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2608         return Exception { InUseAttributeError };
2609 
2610     {
2611         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2612         synchronizeAllAttributes();
2613     }
2614 
2615     auto&amp; elementData = ensureUniqueElementData();
2616 
2617     auto existingAttributeIndex = elementData.findAttributeIndexByName(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2618 
2619     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2620     // before making changes to attrNode&#39;s Element connections.
2621     auto attrNodeValue = attrNode.value();
2622 
2623     if (existingAttributeIndex == ElementData::attributeNotFound) {
2624         attachAttributeNodeIfNeeded(attrNode);
2625         setAttributeInternal(elementData.findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2626     } else {
2627         const Attribute&amp; attribute = attributeAt(existingAttributeIndex);
2628         if (oldAttrNode)
2629             detachAttrNodeFromElementWithValue(oldAttrNode.get(), attribute.value());
2630         else
2631             oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), attribute.value());
2632 
2633         attachAttributeNodeIfNeeded(attrNode);
2634 
2635         if (attribute.name().matches(attrNode.qualifiedName()))
2636             setAttributeInternal(existingAttributeIndex, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2637         else {
2638             removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2639             setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2640         }
2641     }
2642 
<span class="line-modified">2643     return oldAttrNode;</span>
2644 }
2645 
2646 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
2647 {
2648     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
2649     if (oldAttrNode.get() == &amp;attrNode)
<span class="line-modified">2650         return oldAttrNode;</span>
2651 
2652     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2653     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2654     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2655         return Exception { InUseAttributeError };
2656 
2657     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2658     // before making changes to attrNode&#39;s Element connections.
2659     auto attrNodeValue = attrNode.value();
2660     unsigned index = 0;
2661     {
2662         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2663         synchronizeAllAttributes();
2664         auto&amp; elementData = ensureUniqueElementData();
2665 
2666         index = elementData.findAttributeIndexByName(attrNode.qualifiedName());
2667 
2668         if (index != ElementData::attributeNotFound) {
2669             if (oldAttrNode)
2670                 detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData.attributeAt(index).value());
2671             else
2672                 oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), elementData.attributeAt(index).value());
2673         }
2674     }
2675 
2676     attachAttributeNodeIfNeeded(attrNode);
2677     setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2678 
<span class="line-modified">2679     return oldAttrNode;</span>
2680 }
2681 
2682 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
2683 {
2684     if (attr.ownerElement() != this)
2685         return Exception { NotFoundError };
2686 
2687     ASSERT(&amp;document() == &amp;attr.document());
2688 
2689     synchronizeAllAttributes();
2690 
2691     if (!m_elementData)
2692         return Exception { NotFoundError };
2693 
2694     auto existingAttributeIndex = m_elementData-&gt;findAttributeIndexByName(attr.qualifiedName());
2695     if (existingAttributeIndex == ElementData::attributeNotFound)
2696         return Exception { NotFoundError };
2697 
2698     Ref&lt;Attr&gt; oldAttrNode { attr };
2699 
2700     detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
2701     removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2702 
<span class="line-modified">2703     return oldAttrNode;</span>
2704 }
2705 
<span class="line-modified">2706 ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName)</span>
2707 {
2708     auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
2709     if (parseResult.hasException())
2710         return parseResult.releaseException();
2711     QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
2712     if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
2713         return Exception { NamespaceError };
<span class="line-modified">2714     return parsedAttributeName;</span>
2715 }
2716 
<span class="line-modified">2717 ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value)</span>
2718 {
2719     auto result = parseAttributeName(namespaceURI, qualifiedName);
2720     if (result.hasException())
2721         return result.releaseException();
2722     setAttribute(result.releaseReturnValue(), value);
2723     return { };
2724 }
2725 
2726 void Element::removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2727 {
2728     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
2729 
2730     UniqueElementData&amp; elementData = ensureUniqueElementData();
2731 
2732     QualifiedName name = elementData.attributeAt(index).name();
<span class="line-modified">2733     AtomString valueBeingRemoved = elementData.attributeAt(index).value();</span>
2734 
2735     if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
2736         detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
2737 
2738     if (inSynchronizationOfLazyAttribute) {
2739         elementData.removeAttribute(index);
2740         return;
2741     }
2742 
2743     ASSERT(!valueBeingRemoved.isNull());
2744     willModifyAttribute(name, valueBeingRemoved, nullAtom());
2745     {
2746         Style::AttributeChangeInvalidation styleInvalidation(*this, name, valueBeingRemoved, nullAtom());
2747         elementData.removeAttribute(index);
2748     }
2749 
2750     didRemoveAttribute(name, valueBeingRemoved);
2751 }
2752 
<span class="line-modified">2753 void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)</span>
2754 {
2755     if (inSynchronizationOfLazyAttribute) {
2756         ensureUniqueElementData().addAttribute(name, value);
2757         return;
2758     }
2759 
2760     willModifyAttribute(name, nullAtom(), value);
2761     {
2762         Style::AttributeChangeInvalidation styleInvalidation(*this, name, nullAtom(), value);
2763         ensureUniqueElementData().addAttribute(name, value);
2764     }
2765     didAddAttribute(name, value);
2766 }
2767 
<span class="line-modified">2768 bool Element::removeAttribute(const AtomString&amp; qualifiedName)</span>
2769 {
2770     if (!elementData())
2771         return false;
2772 
<span class="line-modified">2773     AtomString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;</span>
2774     unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
2775     if (index == ElementData::attributeNotFound) {
2776         if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
2777             downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
2778         return false;
2779     }
2780 
2781     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
2782     return true;
2783 }
2784 
<span class="line-modified">2785 bool Element::removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)</span>
2786 {
2787     return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
2788 }
2789 
<span class="line-modified">2790 RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomString&amp; qualifiedName)</span>
2791 {
2792     if (!elementData())
2793         return nullptr;
2794     synchronizeAttribute(qualifiedName);
2795     const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2796     if (!attribute)
2797         return nullptr;
2798     return ensureAttr(attribute-&gt;name());
2799 }
2800 
<span class="line-modified">2801 RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)</span>
2802 {
2803     if (!elementData())
2804         return 0;
2805     QualifiedName qName(nullAtom(), localName, namespaceURI);
2806     synchronizeAttribute(qName);
2807     const Attribute* attribute = elementData()-&gt;findAttributeByName(qName);
2808     if (!attribute)
2809         return 0;
2810     return ensureAttr(attribute-&gt;name());
2811 }
2812 
<span class="line-modified">2813 bool Element::hasAttribute(const AtomString&amp; qualifiedName) const</span>
2814 {
2815     if (!elementData())
2816         return false;
2817     synchronizeAttribute(qualifiedName);
2818     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2819 }
2820 
<span class="line-modified">2821 bool Element::hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const</span>
2822 {
2823     if (!elementData())
2824         return false;
2825     QualifiedName qName(nullAtom(), localName, namespaceURI);
2826     synchronizeAttribute(qName);
2827     return elementData()-&gt;findAttributeByName(qName);
2828 }
2829 
2830 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2831 {
2832     if (!isConnected())
2833         return;
2834 
2835     if (document().focusedElement() == this) {
2836         if (document().page())
2837             document().page()-&gt;chrome().client().elementDidRefocus(*this);
2838 
2839         return;
2840     }
2841 
2842     // If the stylesheets have already been loaded we can reliably check isFocusable.
2843     // If not, we continue and set the focused node on the focus controller below so
2844     // that it can be updated soon after attach.
2845     if (document().haveStylesheetsLoaded()) {
2846         document().updateStyleIfNeeded();
2847         if (!isFocusable())
2848             return;
2849     }
2850 
2851     if (!supportsFocus())
2852         return;
2853 
2854     RefPtr&lt;Node&gt; protect;
2855     if (Page* page = document().page()) {
<span class="line-added">2856         auto&amp; frame = *document().frame();</span>
<span class="line-added">2857         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document().topDocument().securityOrigin().canAccess(document().securityOrigin()))</span>
<span class="line-added">2858             return;</span>
<span class="line-added">2859 </span>
2860         // Focus and change event handlers can cause us to lose our last ref.
2861         // If a focus event handler changes the focus to a different node it
2862         // does not make sense to continue and update appearence.
2863         protect = this;
2864         if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))
2865             return;
2866     }
2867 
2868     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
2869 #if PLATFORM(IOS_FAMILY)
2870     // Focusing a form element triggers animation in UIKit to scroll to the right position.
2871     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
2872     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
2873     bool isFormControl = is&lt;HTMLFormControlElement&gt;(*this);
2874     if (isFormControl)
2875         revealMode = SelectionRevealMode::RevealUpToMainFrame;
2876 #endif
2877 
2878     auto target = focusAppearanceUpdateTarget();
2879     if (!target)
</pre>
<hr />
<pre>
2888 }
2889 
2890 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
2891 {
2892     if (isRootEditableElement()) {
2893         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
2894         RefPtr&lt;Frame&gt; frame = document().frame();
2895         if (!frame)
2896             return;
2897 
2898         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
2899         if (this == frame-&gt;selection().selection().rootEditableElement())
2900             return;
2901 
2902         // FIXME: We should restore the previous selection if there is one.
2903         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
2904 
2905         if (frame-&gt;selection().shouldChangeSelection(newSelection)) {
2906             frame-&gt;selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions(), Element::defaultFocusTextStateChangeIntent());
2907             frame-&gt;selection().revealSelection(revealMode);
<span class="line-added">2908             return;</span>
2909         }
2910     }
2911 
2912     if (RefPtr&lt;FrameView&gt; view = document().view())
2913         view-&gt;scheduleScrollToFocusedElement(revealMode);
2914 }
2915 
2916 void Element::blur()
2917 {
2918     if (treeScope().focusedElementInScope() == this) {
2919         if (Frame* frame = document().frame())
2920             frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *frame);
2921         else
2922             document().setFocusedElement(nullptr);
2923     }
2924 }
2925 
<span class="line-modified">2926 void Element::dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)</span>
2927 {
2928     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2929     ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
2930     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2931 }
2932 
<span class="line-modified">2933 void Element::dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)</span>
2934 {
2935     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2936     ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
2937     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2938 }
2939 
2940 void Element::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection)
2941 {
2942     if (auto* page = document().page())
2943         page-&gt;chrome().client().elementDidFocus(*this);
2944     dispatchEvent(FocusEvent::create(eventNames().focusEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
2945 }
2946 
2947 void Element::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
2948 {
2949     if (auto* page = document().page())
2950         page-&gt;chrome().client().elementDidBlur(*this);
2951     dispatchEvent(FocusEvent::create(eventNames().blurEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
2952 }
2953 
</pre>
<hr />
<pre>
3056         return textContent(true);
3057 
3058     return plainText(rangeOfContents(*this).ptr());
3059 }
3060 
3061 String Element::outerText()
3062 {
3063     // Getting outerText is the same as getting innerText, only
3064     // setting is different. You would think this should get the plain
3065     // text for the outer range, but this is wrong, &lt;br&gt; for instance
3066     // would return different values for inner and outer text by such
3067     // a rule, but it doesn&#39;t in WinIE, and we want to match that.
3068     return innerText();
3069 }
3070 
3071 String Element::title() const
3072 {
3073     return String();
3074 }
3075 
<span class="line-modified">3076 const AtomString&amp; Element::pseudo() const</span>
3077 {
3078     return attributeWithoutSynchronization(pseudoAttr);
3079 }
3080 
<span class="line-modified">3081 void Element::setPseudo(const AtomString&amp; value)</span>
3082 {
3083     setAttributeWithoutSynchronization(pseudoAttr, value);
3084 }
3085 
3086 LayoutSize Element::minimumSizeForResizing() const
3087 {
3088     return hasRareData() ? elementRareData()-&gt;minimumSizeForResizing() : defaultMinimumSizeForResizing();
3089 }
3090 
3091 void Element::setMinimumSizeForResizing(const LayoutSize&amp; size)
3092 {
3093     if (!hasRareData() &amp;&amp; size == defaultMinimumSizeForResizing())
3094         return;
3095     ensureElementRareData().setMinimumSizeForResizing(size);
3096 }
3097 
3098 void Element::willBecomeFullscreenElement()
3099 {
3100     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
3101         child.ancestorWillEnterFullscreen();
</pre>
<hr />
<pre>
3202         if (auto* cachedPseudoStyle = style-&gt;getCachedPseudoStyle(pseudoElementSpecifier))
3203             return cachedPseudoStyle;
3204         return &amp;resolvePseudoElementStyle(pseudoElementSpecifier);
3205     }
3206 
3207     return style;
3208 }
3209 
3210 bool Element::needsStyleInvalidation() const
3211 {
3212     if (!inRenderedDocument())
3213         return false;
3214     if (styleValidity() &gt;= Style::Validity::SubtreeInvalid)
3215         return false;
3216     if (document().hasPendingFullStyleRebuild())
3217         return false;
3218 
3219     return true;
3220 }
3221 













































3222 void Element::setChildIndex(unsigned index)
3223 {
3224     ElementRareData&amp; rareData = ensureElementRareData();
3225     rareData.setChildIndex(index);
3226 }
3227 
3228 bool Element::hasFlagsSetDuringStylingOfChildren() const
3229 {
<span class="line-modified">3230     return styleAffectedByActive()</span>
<span class="line-modified">3231         || childrenAffectedByHover()</span>
<span class="line-modified">3232         || childrenAffectedByFirstChildRules()</span>
<span class="line-modified">3233         || childrenAffectedByLastChildRules()</span>
<span class="line-modified">3234         || childrenAffectedByDrag()</span>
<span class="line-modified">3235         || childrenAffectedByForwardPositionalRules()</span>
<span class="line-modified">3236         || descendantsAffectedByForwardPositionalRules()</span>
<span class="line-modified">3237         || childrenAffectedByBackwardPositionalRules()</span>
<span class="line-modified">3238         || descendantsAffectedByBackwardPositionalRules()</span>
<span class="line-modified">3239         || childrenAffectedByPropertyBasedBackwardPositionalRules();</span>
























































3240 }
3241 
3242 unsigned Element::rareDataChildIndex() const
3243 {
3244     ASSERT(hasRareData());
3245     return elementRareData()-&gt;childIndex();
3246 }
3247 
<span class="line-modified">3248 AtomString Element::computeInheritedLanguage() const</span>
3249 {
3250     if (const ElementData* elementData = this-&gt;elementData()) {
3251         if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3252             return attribute-&gt;value();
3253     }
3254 
3255     // The language property is inherited, so we iterate over the parents to find the first language.
3256     const Node* currentNode = this;
3257     while ((currentNode = currentNode-&gt;parentNode())) {
3258         if (is&lt;Element&gt;(*currentNode)) {
3259             if (const ElementData* elementData = downcast&lt;Element&gt;(*currentNode).elementData()) {
3260                 if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3261                     return attribute-&gt;value();
3262             }
3263         } else if (is&lt;Document&gt;(*currentNode)) {
3264             // checking the MIME content-language
3265             return downcast&lt;Document&gt;(*currentNode).contentLanguage();
3266         }
3267     }
3268 
</pre>
<hr />
<pre>
3374     auto query = document().selectorQueryForString(selector);
3375     if (query.hasException())
3376         return query.releaseException();
3377     return query.releaseReturnValue().closest(*this);
3378 }
3379 
3380 bool Element::shouldAppearIndeterminate() const
3381 {
3382     return false;
3383 }
3384 
3385 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3386 {
3387     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3388 }
3389 
3390 DOMTokenList&amp; Element::classList()
3391 {
3392     ElementRareData&amp; data = ensureElementRareData();
3393     if (!data.classList())
<span class="line-modified">3394         data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));</span>
3395     return *data.classList();
3396 }
3397 
3398 DatasetDOMStringMap&amp; Element::dataset()
3399 {
3400     ElementRareData&amp; data = ensureElementRareData();
3401     if (!data.dataset())
<span class="line-modified">3402         data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));</span>
3403     return *data.dataset();
3404 }
3405 
3406 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3407 {
3408 #if !ASSERT_DISABLED
3409     if (elementData()) {
3410         if (const Attribute* attribute = findAttributeByName(name))
3411             ASSERT(isURLAttribute(*attribute));
3412     }
3413 #endif
3414     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3415 }
3416 
3417 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3418 {
3419 #if !ASSERT_DISABLED
3420     if (elementData()) {
3421         if (const Attribute* attribute = findAttributeByName(name))
3422             ASSERT(isURLAttribute(*attribute));
3423     }
3424 #endif
3425     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3426     if (value.isEmpty())
3427         return URL();
3428     return document().completeURL(value);
3429 }
3430 
3431 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3432 {
3433     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3434 }
3435 
3436 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3437 {
<span class="line-modified">3438     setAttribute(attributeName, AtomString::number(value));</span>
3439 }
3440 
3441 unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
3442 {
3443     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3444 }
3445 
3446 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3447 {
<span class="line-modified">3448     setAttribute(attributeName, AtomString::number(limitToOnlyHTMLNonNegative(value)));</span>
3449 }
3450 
3451 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3452 {
3453     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3454     if (child.isSVGElement()) {
3455         ASSERT(!isSVGElement());
3456         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3457         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3458     }
3459     return true;
3460 }
3461 
<span class="line-modified">3462 #if ENABLE(FULLSCREEN_API)</span>
3463 static Element* parentCrossingFrameBoundaries(const Element* element)
3464 {
3465     ASSERT(element);
3466     if (auto* parent = element-&gt;parentElementInComposedTree())
3467         return parent;
3468     return element-&gt;document().ownerElement();
3469 }

3470 

3471 void Element::webkitRequestFullscreen()
3472 {
<span class="line-modified">3473     document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::EnforceIFrameAllowFullscreenRequirement);</span>
3474 }
3475 
3476 bool Element::containsFullScreenElement() const
3477 {
3478     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3479 }
3480 
3481 void Element::setContainsFullScreenElement(bool flag)
3482 {
3483     ensureElementRareData().setContainsFullScreenElement(flag);
3484     invalidateStyleAndLayerComposition();
3485 }
3486 
3487 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3488 {
3489     Element* element = this;
3490     while ((element = parentCrossingFrameBoundaries(element)))
3491         element-&gt;setContainsFullScreenElement(flag);
3492 }
3493 #endif
</pre>
<hr />
<pre>
3526 #if ENABLE(INTERSECTION_OBSERVER)
3527 void Element::disconnectFromIntersectionObservers()
3528 {
3529     auto* observerData = intersectionObserverData();
3530     if (!observerData)
3531         return;
3532 
3533     for (const auto&amp; registration : observerData-&gt;registrations)
3534         registration.observer-&gt;targetDestroyed(*this);
3535     observerData-&gt;registrations.clear();
3536 
3537     for (const auto&amp; observer : observerData-&gt;observers)
3538         observer-&gt;rootDestroyed();
3539     observerData-&gt;observers.clear();
3540 }
3541 
3542 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3543 {
3544     auto&amp; rareData = ensureElementRareData();
3545     if (!rareData.intersectionObserverData())
<span class="line-modified">3546         rareData.setIntersectionObserverData(makeUnique&lt;IntersectionObserverData&gt;());</span>
3547     return *rareData.intersectionObserverData();
3548 }
3549 
3550 IntersectionObserverData* Element::intersectionObserverData()
3551 {
3552     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3553 }
3554 #endif
3555 
<span class="line-added">3556 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">3557 void Element::disconnectFromResizeObservers()</span>
<span class="line-added">3558 {</span>
<span class="line-added">3559     auto* observerData = resizeObserverData();</span>
<span class="line-added">3560     if (!observerData)</span>
<span class="line-added">3561         return;</span>
<span class="line-added">3562 </span>
<span class="line-added">3563     for (const auto&amp; observer : observerData-&gt;observers)</span>
<span class="line-added">3564         observer-&gt;targetDestroyed(*this);</span>
<span class="line-added">3565     observerData-&gt;observers.clear();</span>
<span class="line-added">3566 }</span>
<span class="line-added">3567 </span>
<span class="line-added">3568 ResizeObserverData&amp; Element::ensureResizeObserverData()</span>
<span class="line-added">3569 {</span>
<span class="line-added">3570     auto&amp; rareData = ensureElementRareData();</span>
<span class="line-added">3571     if (!rareData.resizeObserverData())</span>
<span class="line-added">3572         rareData.setResizeObserverData(makeUnique&lt;ResizeObserverData&gt;());</span>
<span class="line-added">3573     return *rareData.resizeObserverData();</span>
<span class="line-added">3574 }</span>
<span class="line-added">3575 </span>
<span class="line-added">3576 ResizeObserverData* Element::resizeObserverData()</span>
<span class="line-added">3577 {</span>
<span class="line-added">3578     return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;</span>
<span class="line-added">3579 }</span>
<span class="line-added">3580 #endif</span>
<span class="line-added">3581 </span>
3582 SpellcheckAttributeState Element::spellcheckAttributeState() const
3583 {
<span class="line-modified">3584     const AtomString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
3585     if (value.isNull())
3586         return SpellcheckAttributeDefault;
3587     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
3588         return SpellcheckAttributeTrue;
3589     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
3590         return SpellcheckAttributeFalse;
3591     return SpellcheckAttributeDefault;
3592 }
3593 
3594 bool Element::isSpellCheckingEnabled() const
3595 {
3596     for (const Element* element = this; element; element = element-&gt;parentOrShadowHostElement()) {
3597         switch (element-&gt;spellcheckAttributeState()) {
3598         case SpellcheckAttributeTrue:
3599             return true;
3600         case SpellcheckAttributeFalse:
3601             return false;
3602         case SpellcheckAttributeDefault:
3603             break;
3604         }
3605     }
3606 
3607     return true;
3608 }
3609 
3610 #ifndef NDEBUG
3611 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3612 {
3613     if (name == HTMLNames::styleAttr)
3614         return false;
3615 
3616     if (isSVGElement())
<span class="line-modified">3617         return !downcast&lt;SVGElement&gt;(*this).isAnimatedPropertyAttribute(name);</span>
3618 
3619     return true;
3620 }
3621 #endif
3622 
3623 #if DUMP_NODE_STATISTICS
3624 bool Element::hasNamedNodeMap() const
3625 {
3626     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3627 }
3628 #endif
3629 
<span class="line-modified">3630 inline void Element::updateName(const AtomString&amp; oldName, const AtomString&amp; newName)</span>
3631 {
3632     if (!isInTreeScope())
3633         return;
3634 
3635     if (oldName == newName)
3636         return;
3637 
3638     updateNameForTreeScope(treeScope(), oldName, newName);
3639 
3640     if (!isConnected())
3641         return;
3642     if (!is&lt;HTMLDocument&gt;(document()))
3643         return;
3644     updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
3645 }
3646 
<span class="line-modified">3647 void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldName, const AtomString&amp; newName)</span>
3648 {
3649     ASSERT(oldName != newName);
3650 
3651     if (!oldName.isEmpty())
3652         scope.removeElementByName(*oldName.impl(), *this);
3653     if (!newName.isEmpty())
3654         scope.addElementByName(*newName.impl(), *this);
3655 }
3656 
<span class="line-modified">3657 void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomString&amp; oldName, const AtomString&amp; newName)</span>
3658 {
3659     ASSERT(oldName != newName);
3660 
3661     if (isInShadowTree())
3662         return;
3663 
3664     if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">3665         const AtomString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
3666         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3667             document.removeWindowNamedItem(*oldName.impl(), *this);
3668         if (!newName.isEmpty() &amp;&amp; newName != id)
3669             document.addWindowNamedItem(*newName.impl(), *this);
3670     }
3671 
3672     if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
<span class="line-modified">3673         const AtomString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();</span>
3674         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3675             document.removeDocumentNamedItem(*oldName.impl(), *this);
3676         if (!newName.isEmpty() &amp;&amp; newName != id)
3677             document.addDocumentNamedItem(*newName.impl(), *this);
3678     }
3679 }
3680 
<span class="line-modified">3681 inline void Element::updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)</span>
3682 {
3683     if (!isInTreeScope())
3684         return;
3685 
3686     if (oldId == newId)
3687         return;
3688 
3689     updateIdForTreeScope(treeScope(), oldId, newId, notifyObservers);
3690 
3691     if (!isConnected())
3692         return;
3693     if (!is&lt;HTMLDocument&gt;(document()))
3694         return;
3695     updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
3696 }
3697 
<span class="line-modified">3698 void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)</span>
3699 {
3700     ASSERT(isInTreeScope());
3701     ASSERT(oldId != newId);
3702 
3703     if (!oldId.isEmpty())
3704         scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3705     if (!newId.isEmpty())
3706         scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3707 }
3708 
<span class="line-modified">3709 void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)</span>
3710 {
3711     ASSERT(isConnected());
3712     ASSERT(oldId != newId);
3713 
3714     if (isInShadowTree())
3715         return;
3716 
3717     if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">3718         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
3719         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3720             document.removeWindowNamedItem(*oldId.impl(), *this);
3721         if (!newId.isEmpty() &amp;&amp; newId != name)
3722             document.addWindowNamedItem(*newId.impl(), *this);
3723     }
3724 
3725     if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
<span class="line-modified">3726         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();</span>
3727         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3728             document.removeDocumentNamedItem(*oldId.impl(), *this);
3729         if (!newId.isEmpty() &amp;&amp; newId != name)
3730             document.addDocumentNamedItem(*newId.impl(), *this);
3731     }
3732 }
3733 
<span class="line-modified">3734 void Element::updateLabel(TreeScope&amp; scope, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue)</span>
3735 {
3736     ASSERT(hasTagName(labelTag));
3737 
3738     if (!isConnected())
3739         return;
3740 
3741     if (oldForAttributeValue == newForAttributeValue)
3742         return;
3743 
3744     if (!oldForAttributeValue.isEmpty())
3745         scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3746     if (!newForAttributeValue.isEmpty())
3747         scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3748 }
3749 
<span class="line-modified">3750 void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
3751 {
3752     if (name == HTMLNames::idAttr)
3753         updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3754     else if (name == HTMLNames::nameAttr)
3755         updateName(oldValue, newValue);
3756     else if (name == HTMLNames::forAttr &amp;&amp; hasTagName(labelTag)) {
3757         if (treeScope().shouldCacheLabelsByForAttribute())
3758             updateLabel(treeScope(), oldValue, newValue);
3759     }
3760 
3761     if (auto recipients = MutationObserverInterestGroup::createForAttributesMutation(*this, name))
3762         recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
3763 
3764     InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
3765 }
3766 
<span class="line-modified">3767 void Element::didAddAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
3768 {
3769     attributeChanged(name, nullAtom(), value);
<span class="line-modified">3770     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), value);</span>
3771     dispatchSubtreeModifiedEvent();
3772 }
3773 
<span class="line-modified">3774 void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
3775 {
3776     attributeChanged(name, oldValue, newValue);
<span class="line-modified">3777     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), newValue);</span>
3778     // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
3779 }
3780 
<span class="line-modified">3781 void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue)</span>
3782 {
3783     attributeChanged(name, oldValue, nullAtom());
<span class="line-modified">3784     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.toString());</span>
3785     dispatchSubtreeModifiedEvent();
3786 }
3787 
3788 IntPoint Element::savedLayerScrollPosition() const
3789 {
3790     return hasRareData() ? elementRareData()-&gt;savedLayerScrollPosition() : IntPoint();
3791 }
3792 
3793 void Element::setSavedLayerScrollPosition(const IntPoint&amp; position)
3794 {
3795     if (position.isZero() &amp;&amp; !hasRareData())
3796         return;
3797     ensureElementRareData().setSavedLayerScrollPosition(position);
3798 }
3799 
<span class="line-modified">3800 RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase)</span>
3801 {
3802     if (auto* attrNodeList = attrNodeListForElement(*this))
3803         return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
3804     return nullptr;
3805 }
3806 
3807 RefPtr&lt;Attr&gt; Element::attrIfExists(const QualifiedName&amp; name)
3808 {
3809     if (auto* attrNodeList = attrNodeListForElement(*this))
3810         return findAttrNodeInList(*attrNodeList, name);
3811     return nullptr;
3812 }
3813 
3814 Ref&lt;Attr&gt; Element::ensureAttr(const QualifiedName&amp; name)
3815 {
3816     auto&amp; attrNodeList = ensureAttrNodeListForElement(*this);
3817     RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(attrNodeList, name);
3818     if (!attrNode) {
3819         attrNode = Attr::create(*this, name);
3820         attrNode-&gt;setTreeScopeRecursively(treeScope());
3821         attrNodeList.append(attrNode);
3822     }
3823     return attrNode.releaseNonNull();
3824 }
3825 
<span class="line-modified">3826 void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomString&amp; value)</span>
3827 {
3828     ASSERT(hasSyntheticAttrChildNodes());
3829     attrNode-&gt;detachFromElementWithValue(value);
3830 
3831     auto&amp; attrNodeList = *attrNodeListForElement(*this);
3832     bool found = attrNodeList.removeFirstMatching([attrNode](auto&amp; attribute) {
3833         return attribute-&gt;qualifiedName() == attrNode-&gt;qualifiedName();
3834     });
3835     ASSERT_UNUSED(found, found);
3836     if (attrNodeList.isEmpty())
3837         removeAttrNodeListForElement(*this);
3838 }
3839 
3840 void Element::detachAllAttrNodesFromElement()
3841 {
3842     auto* attrNodeList = attrNodeListForElement(*this);
3843     ASSERT(attrNodeList);
3844 
3845     for (const Attribute&amp; attribute : attributesIterator()) {
3846         if (RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(*attrNodeList, attribute.name()))
</pre>
<hr />
<pre>
3852 
3853 void Element::resetComputedStyle()
3854 {
3855     if (!hasRareData() || !elementRareData()-&gt;computedStyle())
3856         return;
3857 
3858     auto reset = [](Element&amp; element) {
3859         if (!element.hasRareData() || !element.elementRareData()-&gt;computedStyle())
3860             return;
3861         if (element.hasCustomStyleResolveCallbacks())
3862             element.willResetComputedStyle();
3863         element.elementRareData()-&gt;resetComputedStyle();
3864     };
3865     reset(*this);
3866     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
3867         reset(child);
3868 }
3869 
3870 void Element::resetStyleRelations()
3871 {
<span class="line-added">3872     // FIXME: Make this code more consistent.</span>
<span class="line-added">3873     clearFlag(StyleAffectedByFocusWithinFlag);</span>
<span class="line-added">3874     clearStyleFlags();</span>
3875     if (!hasRareData())
3876         return;
3877     elementRareData()-&gt;resetStyleRelations();
3878 }
3879 
3880 void Element::clearHoverAndActiveStatusBeforeDetachingRenderer()
3881 {
3882     if (!isUserActionElement())
3883         return;
3884     if (hovered())
3885         document().hoveredElementDidDetach(*this);
3886     if (isInActiveChain())
3887         document().elementInActiveChainDidDetach(*this);
3888     document().userActionElements().clearActiveAndHovered(*this);
3889 }
3890 
3891 void Element::willRecalcStyle(Style::Change)
3892 {
3893     ASSERT(hasCustomStyleResolveCallbacks());
3894 }
</pre>
<hr />
<pre>
3927 {
3928     ASSERT(hasCustomStyleResolveCallbacks());
3929     return WTF::nullopt;
3930 }
3931 
3932 void Element::cloneAttributesFromElement(const Element&amp; other)
3933 {
3934     if (hasSyntheticAttrChildNodes())
3935         detachAllAttrNodesFromElement();
3936 
3937     other.synchronizeAllAttributes();
3938     if (!other.m_elementData) {
3939         m_elementData = nullptr;
3940         return;
3941     }
3942 
3943     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
3944     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
3945     ASSERT(!isConnected());
3946 
<span class="line-modified">3947     const AtomString&amp; oldID = getIdAttribute();</span>
<span class="line-modified">3948     const AtomString&amp; newID = other.getIdAttribute();</span>
3949 
3950     if (!oldID.isNull() || !newID.isNull())
3951         updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3952 
<span class="line-modified">3953     const AtomString&amp; oldName = getNameAttribute();</span>
<span class="line-modified">3954     const AtomString&amp; newName = other.getNameAttribute();</span>
3955 
3956     if (!oldName.isNull() || !newName.isNull())
3957         updateName(oldName, newName);
3958 
3959     // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
3960     // We can only do this if there is no CSSOM wrapper for other&#39;s inline style, and there are no presentation attributes.
3961     if (is&lt;UniqueElementData&gt;(*other.m_elementData)
3962         &amp;&amp; !other.m_elementData-&gt;presentationAttributeStyle()
3963         &amp;&amp; (!other.m_elementData-&gt;inlineStyle() || !other.m_elementData-&gt;inlineStyle()-&gt;hasCSSOMWrapper()))
3964         const_cast&lt;Element&amp;&gt;(other).m_elementData = downcast&lt;UniqueElementData&gt;(*other.m_elementData).makeShareableCopy();
3965 
3966     if (!other.m_elementData-&gt;isUnique())
3967         m_elementData = other.m_elementData;
3968     else
3969         m_elementData = other.m_elementData-&gt;makeUniqueCopy();
3970 
3971     for (const Attribute&amp; attribute : attributesIterator())
3972         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedByCloning);
3973 }
3974 
</pre>
<hr />
<pre>
4136 }
4137 
4138 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup)
4139 {
4140     return insertAdjacentHTML(where, markup, nullptr);
4141 }
4142 
4143 ExceptionOr&lt;void&gt; Element::insertAdjacentText(const String&amp; where, const String&amp; text)
4144 {
4145     auto result = insertAdjacent(where, document().createTextNode(text));
4146     if (result.hasException())
4147         return result.releaseException();
4148     return { };
4149 }
4150 
4151 Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
4152 {
4153     if (!isLink())
4154         return nullptr;
4155 
<span class="line-modified">4156     const AtomString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);</span>
4157     if (href.isNull())
4158         return nullptr;
4159 
4160     Document&amp; document = this-&gt;document();
4161     URL url = document.completeURL(href);
4162     if (!url.isValid())
4163         return nullptr;
4164 
4165     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4166         outAnchorName = url.fragmentIdentifier();
4167         return document.findAnchor(outAnchorName);
4168     }
4169 
4170     return nullptr;
4171 }
4172 
4173 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::ExecState&amp; state, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)
4174 {
4175     String id = &quot;&quot;;
4176     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
</pre>
<hr />
<pre>
4181             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4182         else {
4183             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4184             id = keyframeEffectOptions.id;
4185             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4186         }
4187         keyframeEffectOptions = keyframeEffectOptionsVariant;
4188     }
4189 
4190     auto keyframeEffectResult = KeyframeEffect::create(state, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));
4191     if (keyframeEffectResult.hasException())
4192         return keyframeEffectResult.releaseException();
4193 
4194     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4195     animation-&gt;setId(id);
4196 
4197     auto animationPlayResult = animation-&gt;play();
4198     if (animationPlayResult.hasException())
4199         return animationPlayResult.releaseException();
4200 
<span class="line-modified">4201     return animation;</span>
4202 }
4203 
4204 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()
4205 {
4206     // FIXME: Filter and order the list as specified (webkit.org/b/179535).
4207 
4208     // For the list of animations to be current, we need to account for any pending CSS changes,
4209     // such as updates to CSS Animations and CSS Transitions.
4210     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4211     document().updateStyleIfNeeded();
4212 
4213     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4214     if (auto timeline = document().existingTimeline()) {
4215         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4216             if (animation-&gt;isRelevant())
4217                 animations.append(animation);
4218         }
4219     }
4220     return animations;
4221 }
4222 
<span class="line-added">4223 ElementIdentifier Element::createElementIdentifier()</span>
<span class="line-added">4224 {</span>
<span class="line-added">4225     auto&amp; rareData = ensureElementRareData();</span>
<span class="line-added">4226     ASSERT(!rareData.hasElementIdentifier());</span>
<span class="line-added">4227 </span>
<span class="line-added">4228     rareData.setHasElementIdentifier(true);</span>
<span class="line-added">4229     return ElementIdentifier::generate();</span>
<span class="line-added">4230 }</span>
<span class="line-added">4231 </span>
4232 #if ENABLE(CSS_TYPED_OM)
4233 StylePropertyMap* Element::attributeStyleMap()
4234 {
4235     if (!hasRareData())
4236         return nullptr;
4237     return elementRareData()-&gt;attributeStyleMap();
4238 }
4239 
4240 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4241 {
4242     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4243 }
4244 #endif
4245 






























































4246 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>