<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  81 #include &quot;WebGLDebugRendererInfo.h&quot;
  82 #include &quot;WebGLDebugShaders.h&quot;
  83 #include &quot;WebGLDepthTexture.h&quot;
  84 #include &quot;WebGLDrawBuffers.h&quot;
  85 #include &quot;WebGLFramebuffer.h&quot;
  86 #include &quot;WebGLLoseContext.h&quot;
  87 #include &quot;WebGLProgram.h&quot;
  88 #include &quot;WebGLRenderbuffer.h&quot;
  89 #include &quot;WebGLRenderingContext.h&quot;
  90 #include &quot;WebGLShader.h&quot;
  91 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  92 #include &quot;WebGLTexture.h&quot;
  93 #include &quot;WebGLUniformLocation.h&quot;
  94 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  95 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  96 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  98 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  99 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 100 #include &lt;wtf/CheckedArithmetic.h&gt;

 101 #include &lt;wtf/HexNumber.h&gt;


 102 #include &lt;wtf/StdLibExtras.h&gt;
 103 #include &lt;wtf/UniqueArray.h&gt;
 104 #include &lt;wtf/text/CString.h&gt;
 105 #include &lt;wtf/text/StringBuilder.h&gt;
 106 
 107 namespace WebCore {
 108 


 109 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 110 const int maxGLErrorsAllowedToConsole = 256;
 111 static const Seconds checkContextLossHandlingDelay { 3_s };
 112 
 113 namespace {
 114 
<span class="line-removed"> 115     Platform3DObject objectOrZero(WebGLObject* object)</span>
<span class="line-removed"> 116     {</span>
<span class="line-removed"> 117         return object ? object-&gt;object() : 0;</span>
<span class="line-removed"> 118     }</span>
<span class="line-removed"> 119 </span>
 120     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
 121     {
 122         if (value &lt; min)
 123             value = min;
 124         if (value &gt; max)
 125             value = max;
 126         return value;
 127     }
 128 
 129     // Return true if a character belongs to the ASCII subset as defined in
 130     // GLSL ES 1.0 spec section 3.1.
 131     bool validateCharacter(unsigned char c)
 132     {
 133         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 134         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 135             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 136             return true;
 137         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 138         // are also valid.
 139         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
</pre>
<hr />
<pre>
 545         }
 546 
 547         Document&amp; topDocument = document.topDocument();
 548         Page* page = topDocument.page();
 549         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 550 
 551         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 552             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 553 
 554             if (policy == WebGLBlockCreation) {
 555                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 556                 return nullptr;
 557             }
 558 
 559             if (policy == WebGLPendingCreation) {
 560                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 561                 isPendingPolicyResolution = true;
 562             }
 563         }
 564 
<span class="line-removed"> 565         if (frame-&gt;settings().forceSoftwareWebGLRendering())</span>
<span class="line-removed"> 566             attributes.forceSoftwareRenderer = true;</span>
<span class="line-removed"> 567 </span>
 568         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
 569             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)
 570                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
 571             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;
 572         }
 573 
 574         if (page)
 575             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 576 
 577         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 578     }
 579 
 580     attributes.noExtensions = true;
 581     attributes.shareResources = false;
 582 
 583     attributes.initialPowerPreference = attributes.powerPreference;
 584 
 585 
 586 #if ENABLE(WEBGL2)
 587     if (type == &quot;webgl2&quot;)
</pre>
<hr />
<pre>
 642     , m_isPendingPolicyResolution(true)
 643     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 644 {
 645     registerWithWebGLStateTracker();
 646     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 647 }
 648 
 649 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)
 650     : GPUBasedCanvasRenderingContext(canvas)
 651     , m_context(WTFMove(context))
 652     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 653     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 654     , m_generatedImageCache(4)
 655     , m_attributes(attributes)
 656     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 657     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 658 {
 659     m_contextGroup = WebGLContextGroup::create();
 660     m_contextGroup-&gt;addContext(*this);
 661 
<span class="line-modified"> 662     m_context-&gt;setWebGLContext(this);</span>
 663 
 664     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
 665 
 666     setupFlags();
 667     initializeNewContext();
 668     registerWithWebGLStateTracker();
 669     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 670 
 671     addActivityStateChangeObserverIfNecessary();
 672 }
 673 
 674 WebGLCanvas WebGLRenderingContextBase::canvas()
 675 {
 676     auto&amp; base = canvasBase();
 677     if (is&lt;OffscreenCanvas&gt;(base))
 678         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 679     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 680 }
 681 
<span class="line-removed"> 682 HTMLCanvasElement* WebGLRenderingContextBase::htmlCanvas()</span>
<span class="line-removed"> 683 {</span>
<span class="line-removed"> 684     auto&amp; base = canvasBase();</span>
<span class="line-removed"> 685     if (!is&lt;HTMLCanvasElement&gt;(base))</span>
<span class="line-removed"> 686         return nullptr;</span>
<span class="line-removed"> 687     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);</span>
<span class="line-removed"> 688 }</span>
<span class="line-removed"> 689 </span>
 690 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 691 {
 692     auto&amp; base = canvasBase();
 693     if (!is&lt;OffscreenCanvas&gt;(base))
 694         return nullptr;
 695     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 696 }
 697 
 698 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 699 // and to discard temporary GL contexts (e.g. feature detection).
 700 void WebGLRenderingContextBase::checkForContextLossHandling()
 701 {
 702     auto canvas = htmlCanvas();
 703     if (!canvas)
 704         return;
 705 
 706     if (!canvas-&gt;renderer())
 707         return;
 708 
 709     auto* page = canvas-&gt;document().page();
</pre>
<hr />
<pre>
 785     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);
 786 
 787     // These two values from EXT_draw_buffers are lazily queried.
 788     m_maxDrawBuffers = 0;
 789     m_maxColorAttachments = 0;
 790 
 791     m_backDrawBuffer = GraphicsContext3D::BACK;
 792     m_drawBuffersWebGLRequirementsChecked = false;
 793     m_drawBuffersSupported = false;
 794 
 795     m_vertexAttribValue.resize(m_maxVertexAttribs);
 796 
 797     if (!isGLES2NPOTStrict())
 798         createFallbackBlackTextures1x1();
 799 
 800     IntSize canvasSize = clampedCanvasSize();
 801     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 802     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 803     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
 804 
<span class="line-modified"> 805     m_context-&gt;setContextLostCallback(std::make_unique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified"> 806     m_context-&gt;setErrorMessageCallback(std::make_unique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
 807 }
 808 
 809 void WebGLRenderingContextBase::setupFlags()
 810 {
 811     ASSERT(m_context);
 812 
 813     auto canvas = htmlCanvas();
 814     if (canvas) {
 815         if (Page* page = canvas-&gt;document().page())
 816             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 817     }
 818 
 819     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 820     if (m_isGLES2Compliant) {
 821         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
 822         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);
 823     } else {
 824         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
 825         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);
 826     }
</pre>
<hr />
<pre>
 874     m_boundVertexArrayObject = nullptr;
 875     m_vertexAttrib0Buffer = nullptr;
 876     m_currentProgram = nullptr;
 877     m_framebufferBinding = nullptr;
 878     m_readFramebufferBinding = nullptr;
 879     m_renderbufferBinding = nullptr;
 880 
 881     for (auto&amp; textureUnit : m_textureUnits) {
 882         textureUnit.texture2DBinding = nullptr;
 883         textureUnit.textureCubeMapBinding = nullptr;
 884     }
 885 
 886     m_blackTexture2D = nullptr;
 887     m_blackTextureCubeMap = nullptr;
 888 
 889     if (!m_isPendingPolicyResolution) {
 890         detachAndRemoveAllObjects();
 891         destroyGraphicsContext3D();
 892         m_contextGroup-&gt;removeContext(*this);
 893     }











 894 }
 895 
 896 void WebGLRenderingContextBase::destroyGraphicsContext3D()
 897 {
 898     if (m_isPendingPolicyResolution)
 899         return;
 900 
 901     removeActivityStateChangeObserver();
 902 
 903     if (m_context) {

 904         m_context-&gt;setContextLostCallback(nullptr);
 905         m_context-&gt;setErrorMessageCallback(nullptr);
 906         m_context = nullptr;
 907     }
 908 }
 909 
 910 void WebGLRenderingContextBase::markContextChanged()
 911 {
 912     if (m_framebufferBinding)
 913         return;
 914 
 915     m_context-&gt;markContextChanged();
 916 
 917     m_layerCleared = false;
 918 
 919     auto* canvas = htmlCanvas();
 920     if (!canvas)
 921         return;
 922 
 923     RenderBox* renderBox = canvas-&gt;renderBox();
</pre>
<hr />
<pre>
1063 
1064 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1065 {
1066     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1067 }
1068 
1069 void WebGLRenderingContextBase::reshape(int width, int height)
1070 {
1071     if (isContextLostOrPending())
1072         return;
1073 
1074     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1075     // know if the underlying FBO uses textures or renderbuffers.
1076     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);
1077     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);
1078     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
1079     width = clamp(width, 1, maxWidth);
1080     height = clamp(height, 1, maxHeight);
1081 
1082     if (m_needsUpdate) {
<span class="line-modified">1083         auto* canvas = htmlCanvas();</span>
<span class="line-removed">1084         if (canvas) {</span>
<span class="line-removed">1085             RenderBox* renderBox = htmlCanvas()-&gt;renderBox();</span>
<span class="line-removed">1086             if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())</span>
<span class="line-removed">1087                 renderBox-&gt;contentChanged(CanvasChanged);</span>
<span class="line-removed">1088         }</span>
1089         m_needsUpdate = false;
1090     }
1091 
1092     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1093     // clear (and this matches what reshape will do).
1094     m_context-&gt;reshape(width, height);
1095 
1096     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1097     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));
1098     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1099         m_unrenderableTextureUnits.add(m_activeTextureUnit);
1100     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));
1101     if (m_framebufferBinding)
1102       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
1103 }
1104 
1105 int WebGLRenderingContextBase::drawingBufferWidth() const
1106 {
1107     if (isContextLost())
1108         return 0;
</pre>
<hr />
<pre>
1553     m_colorMask[2] = blue;
1554     m_colorMask[3] = alpha;
1555     m_context-&gt;colorMask(red, green, blue, alpha);
1556 }
1557 
1558 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1559 {
1560     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1561         return;
1562     m_context-&gt;compileShader(objectOrZero(shader));
1563     GC3Dint value;
1564     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);
1565     shader-&gt;setValid(value);
1566 
1567     auto* canvas = htmlCanvas();
1568 
1569     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1570         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1571 
1572         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<span class="line-modified">1573             canvas-&gt;document().addConsoleMessage(std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
1574     }
1575 }
1576 
1577 void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
1578 {
1579     if (isContextLostOrPending())
1580         return;
1581     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1582         return;
1583 
1584     if (!validateCompressedTexFormat(internalformat)) {
1585         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);
1586         return;
1587     }
1588     if (border) {
1589         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);
1590         return;
1591     }
1592     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1593         return;
</pre>
<hr />
<pre>
1713             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1714             if (!zero) {
1715                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);
1716                 return;
1717             }
1718             memset(zero.get(), 0, size);
1719         }
1720         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1721         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1722             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1723     } else
1724         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1725 }
1726 
1727 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1728 {
1729     if (isContextLostOrPending())
1730         return nullptr;
1731     auto buffer = WebGLBuffer::create(*this);
1732     addSharedObject(buffer.get());
<span class="line-modified">1733     return WTFMove(buffer);</span>
1734 }
1735 
1736 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1737 {
1738     if (isContextLostOrPending())
1739         return nullptr;
1740     auto buffer = WebGLFramebuffer::create(*this);
1741     addContextObject(buffer.get());
<span class="line-modified">1742     return WTFMove(buffer);</span>
1743 }
1744 
1745 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1746 {
1747     if (isContextLostOrPending())
1748         return nullptr;
1749     auto texture = WebGLTexture::create(*this);
1750     addSharedObject(texture.get());
<span class="line-modified">1751     return WTFMove(texture);</span>
1752 }
1753 
1754 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1755 {
1756     if (isContextLostOrPending())
1757         return nullptr;
1758     auto program = WebGLProgram::create(*this);
1759     addSharedObject(program.get());
1760 
1761     InspectorInstrumentation::didCreateProgram(*this, program.get());
1762 
<span class="line-modified">1763     return WTFMove(program);</span>
1764 }
1765 
1766 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1767 {
1768     if (isContextLostOrPending())
1769         return nullptr;
1770     auto buffer = WebGLRenderbuffer::create(*this);
1771     addSharedObject(buffer.get());
<span class="line-modified">1772     return WTFMove(buffer);</span>
1773 }
1774 
1775 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
1776 {
1777     if (isContextLostOrPending())
1778         return nullptr;
1779     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {
1780         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);
1781         return nullptr;
1782     }
1783 
1784     auto shader = WebGLShader::create(*this, type);
1785     addSharedObject(shader.get());
<span class="line-modified">1786     return WTFMove(shader);</span>
1787 }
1788 
1789 void WebGLRenderingContextBase::cullFace(GC3Denum mode)
1790 {
1791     if (isContextLostOrPending())
1792         return;
1793     m_context-&gt;cullFace(mode);
1794 }
1795 
1796 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1797 {
1798     if (isContextLostOrPending() || !object)
1799         return false;
1800     if (!object-&gt;validate(contextGroup(), *this)) {
1801         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);
1802         return false;
1803     }
1804     if (object-&gt;isDeleted())
1805         return false;
1806     if (object-&gt;object())
</pre>
<hr />
<pre>
2029         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);
2030         break;
2031     case GraphicsContext3D::UNSIGNED_SHORT:
2032         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);
2033         break;
2034     case GraphicsContext3D::UNSIGNED_BYTE:
2035         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);
2036         break;
2037     }
2038 
2039     // Then set the maxiumum index in the index array and make sure it is valid.
2040     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2041     if (!checkedNumElementsRequired)
2042         return false;
2043     numElementsRequired = checkedNumElementsRequired.value();
2044     return true;
2045 }
2046 
2047 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2048 {

2049     if (!m_currentProgram)
2050         return false;
2051 
2052     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2053     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2054         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2055             return false;
2056     }
2057 
2058     if (!elementCount)
2059         return true;
2060 
2061     // Look in each consumed vertex attrib (by the current program).
2062     bool sawNonInstancedAttrib = false;
2063     bool sawEnabledAttrib = false;
2064     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2065     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2066         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2067         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2068             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
</pre>
<hr />
<pre>
2096         return false;
2097 
2098     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2099 
2100     // Guard against access into non-existent buffers.
2101     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2102         return false;
2103 
2104     if (elementCount &amp;&amp; sawEnabledAttrib) {
2105         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2106             if (usingSimulatedArrayBuffer) {
2107                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2108                 if (state.enabled &amp;&amp; state.isBound()) {
2109                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2110                         return !!state.bufferBinding-&gt;byteLength();
2111                 }
2112             }
2113             return false;
2114         }
2115     }

2116 
2117     return true;
2118 }
2119 
2120 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2121 {
2122     if (!object || !object-&gt;object()) {
2123         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);
2124         return false;
2125     }
2126     if (!object-&gt;validate(contextGroup(), *this)) {
2127         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);
2128         return false;
2129     }
2130     return true;
2131 }
2132 
2133 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)
2134 {
2135     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
</pre>
<hr />
<pre>
2612     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
2613     if (pname == GraphicsContext3D::BUFFER_SIZE)
2614         return value;
2615     return static_cast&lt;unsigned&gt;(value);
2616 }
2617 
2618 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2619 {
2620     if (isContextLostOrPending())
2621         return WTF::nullopt;
2622 
2623     // Also, we need to enforce requested values of &quot;false&quot; for depth
2624     // and stencil, regardless of the properties of the underlying
2625     // GraphicsContext3D.
2626 
2627     auto attributes = m_context-&gt;getContextAttributes();
2628     if (!m_attributes.depth)
2629         attributes.depth = false;
2630     if (!m_attributes.stencil)
2631         attributes.stencil = false;
<span class="line-modified">2632     return WTFMove(attributes);</span>
2633 }
2634 
2635 GC3Denum WebGLRenderingContextBase::getError()
2636 {
2637     if (m_isPendingPolicyResolution)
2638         return GraphicsContext3D::NO_ERROR;
2639     return m_context-&gt;getError();
2640 }
2641 
2642 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)
2643 {
2644     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2645         return nullptr;
2646 
2647     GC3Dint value = 0;
2648     switch (pname) {
2649     case GraphicsContext3D::DELETE_STATUS:
2650         return program-&gt;isDeleted();
2651     case GraphicsContext3D::VALIDATE_STATUS:
2652         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2653         return static_cast&lt;bool&gt;(value);
2654     case GraphicsContext3D::LINK_STATUS:
2655         return program-&gt;getLinkStatus();
2656     case GraphicsContext3D::ATTACHED_SHADERS:
2657         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2658         return value;
2659     case GraphicsContext3D::ACTIVE_ATTRIBUTES:
2660     case GraphicsContext3D::ACTIVE_UNIFORMS:



2661         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);

2662         return value;
2663     default:
2664         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
2665         return nullptr;
2666     }
2667 }
2668 
2669 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2670 {
2671     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2672         return String();
2673     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2674 }
2675 
2676 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)
2677 {
2678     if (isContextLostOrPending())
2679         return nullptr;
2680     if (target != GraphicsContext3D::RENDERBUFFER) {
2681         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);
</pre>
<hr />
<pre>
2928     case GraphicsContext3D::INT: {
2929         GC3Dint value[4] = {0};
2930         if (m_isRobustnessEXTSupported)
2931             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2932         else
2933             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2934         if (length == 1)
2935             return value[0];
2936         return Int32Array::tryCreate(value, length);
2937     }
2938     case GraphicsContext3D::BOOL: {
2939         GC3Dint value[4] = {0};
2940         if (m_isRobustnessEXTSupported)
2941             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2942         else
2943             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2944         if (length &gt; 1) {
2945             Vector&lt;bool&gt; vector(length);
2946             for (unsigned j = 0; j &lt; length; j++)
2947                 vector[j] = value[j];
<span class="line-modified">2948             return WTFMove(vector);</span>
2949         }
2950         return static_cast&lt;bool&gt;(value[0]);
2951     }
2952     default:
2953         notImplemented();
2954     }
2955 
2956     // If we get here, something went wrong in our unfortunately complex logic above
2957     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);
2958     return nullptr;
2959 }
2960 
2961 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2962 {
2963     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2964         return nullptr;
2965     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
2966         return nullptr;
2967     if (!validateString(&quot;getUniformLocation&quot;, name))
2968         return nullptr;
2969     if (isPrefixReserved(name))
2970         return nullptr;
2971     if (!program-&gt;getLinkStatus()) {
2972         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);
2973         return nullptr;
2974     }
2975     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
2976     if (uniformLocation == -1)
2977         return nullptr;
2978 
2979     GC3Dint activeUniforms = 0;



2980     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);

2981     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {
2982         ActiveInfo info;
2983         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
2984             return nullptr;
2985         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
2986         if (info.name.endsWith(&quot;[0]&quot;))
2987             info.name = info.name.left(info.name.length() - 3);
2988         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
2989         for (GC3Dint index = 0; index &lt; info.size; ++index) {
2990             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
2991 
2992             if (name == uniformName || name == info.name)
2993                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
2994         }
2995     }
2996     return nullptr;
2997 }
2998 
2999 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)
3000 {
</pre>
<hr />
<pre>
3174     if (isContextLostOrPending())
3175         return;
3176     m_context-&gt;lineWidth(width);
3177 }
3178 
3179 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3180 {
3181     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3182         return;
3183 
3184     program-&gt;increaseLinkCount();
3185 }
3186 
3187 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3188 {
3189     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3190         return false;
3191 
3192     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
3193     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<span class="line-modified">3194     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid() || !m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get())) || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
3195         program-&gt;setLinkStatus(false);
3196         return false;
3197     }
3198 








3199     m_context-&gt;linkProgram(objectOrZero(program));
3200     return true;
3201 }
3202 
3203 void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
3204 {
3205     if (isContextLostOrPending())
3206         return;
3207     switch (pname) {
3208     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:
3209         m_unpackFlipY = param;
3210         break;
3211     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
3212         m_unpackPremultiplyAlpha = param;
3213         break;
3214     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:
3215         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)
3216             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);
3217         else {
3218             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);
</pre>
<hr />
<pre>
3418 
3419 void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)
3420 {
3421     if (isContextLostOrPending())
3422         return;
3423     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3424     // taint the origin using the WebGL API.
3425     ASSERT(canvasBase().originClean());
3426 
3427     GC3Denum internalFormat = 0;
3428     if (m_framebufferBinding) {
3429         const char* reason = &quot;framebuffer incomplete&quot;;
3430         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
3431             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);
3432             return;
3433         }
3434         // FIXME: readBuffer() should affect this
3435         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3436     } else {
3437         if (m_attributes.alpha)
<span class="line-removed">3438             internalFormat = GraphicsContext3D::RGB8;</span>
<span class="line-removed">3439         else</span>
3440             internalFormat = GraphicsContext3D::RGBA8;


3441     }
3442 
3443     if (!internalFormat) {
3444         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3445         return;
3446     }
3447 
3448     if (isWebGL1()) {
3449         switch (format) {
3450         case GraphicsContext3D::ALPHA:
3451         case GraphicsContext3D::RGB:
3452         case GraphicsContext3D::RGBA:
3453             break;
3454         default:
3455             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);
3456             return;
3457         }
3458         switch (type) {
3459         case GraphicsContext3D::UNSIGNED_BYTE:
3460         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
3461         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
3462         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
3463             break;






3464         default:
3465             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3466             return;
3467         }
<span class="line-modified">3468         if (format != GraphicsContext3D::RGBA || type != GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="line-modified">3469             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE&quot;);</span>
3470             return;
3471         }
3472     }
3473 
3474     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3475     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3476     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
3477         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3478         return;
3479     }
3480 
<span class="line-modified">3481 #define INTERNAL_FORMAT_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">3482         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3483             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3484             return; \</span>
<span class="line-modified">3485         } \</span>
<span class="line-removed">3486         if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-removed">3487             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-removed">3488             return; \</span>
<span class="line-removed">3489         } \</span>
<span class="line-removed">3490         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">3491             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">3492             return; \</span>
<span class="line-removed">3493         } \</span>
<span class="line-removed">3494         break;</span>
3495 
<span class="line-modified">3496 #define INTERNAL_FORMAT_INTEGER_CHECK(themeMacro, typeMacro, pixelTypeMacro) case InternalFormatTheme::themeMacro: \</span>
<span class="line-modified">3497         if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3498             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3499             return; \</span>
<span class="line-modified">3500         } \</span>
<span class="line-modified">3501         if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">3502             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3503             return; \</span>
<span class="line-modified">3504         } \</span>
<span class="line-modified">3505         if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-removed">3506             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-removed">3507             return; \</span>
<span class="line-removed">3508         } \</span>
<span class="line-removed">3509         break;</span>
3510 
<span class="line-modified">3511 #define PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-modified">3512         if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-modified">3513             &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-modified">3514             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3515             return; \</span>
<span class="line-modified">3516         } \</span>
<span class="line-modified">3517         if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-modified">3518             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-modified">3519             return; \</span>
<span class="line-modified">3520         } \</span>
<span class="line-modified">3521         break;</span>











3522 
3523     switch (internalFormatTheme) {
<span class="line-modified">3524     INTERNAL_FORMAT_CHECK        (NormalizedFixedPoint      , UNSIGNED_BYTE, TypeUint8  );</span>
<span class="line-modified">3525     INTERNAL_FORMAT_CHECK        (SignedNormalizedFixedPoint, BYTE         , TypeInt8   );</span>
<span class="line-modified">3526     INTERNAL_FORMAT_CHECK        (FloatingPoint             , FLOAT        , TypeFloat32);</span>
<span class="line-modified">3527     INTERNAL_FORMAT_INTEGER_CHECK(SignedInteger             , INT          , TypeInt32  );</span>
<span class="line-modified">3528     INTERNAL_FORMAT_INTEGER_CHECK(UnsignedInteger           , UNSIGNED_INT , TypeUint32 );</span>














3529     case InternalFormatTheme::Packed:
3530         switch (internalFormat) {
<span class="line-modified">3531         PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3532         PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3533         PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3534         PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">3535         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">3536         PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">3537         PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
3538         }
3539         break;
3540     case InternalFormatTheme::None:
3541         ASSERT_NOT_REACHED();
3542     }

3543 #undef INTERNAL_FORMAT_CHECK
3544 #undef INTERNAL_FORMAT_INTEGER_CHECK
<span class="line-modified">3545 #undef PACKED_INTERNAL_FORMAT_CHECK</span>
3546 
3547     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3548     unsigned totalBytesRequired = 0;
3549     unsigned padding = 0;
3550     if (!m_isRobustnessEXTSupported) {
3551         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);
3552         if (error != GraphicsContext3D::NO_ERROR) {
3553             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3554             return;
3555         }
3556         if (pixels.byteLength() &lt; totalBytesRequired) {
3557             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);
3558             return;
3559         }
3560     }
3561 
3562     clearIfComposited();
3563     void* data = pixels.baseAddress();
3564 
3565     if (m_isRobustnessEXTSupported)
</pre>
<hr />
<pre>
4981     default:
4982         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
4983         return;
4984     }
4985     if (index &gt;= m_maxVertexAttribs) {
4986         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);
4987         return;
4988     }
4989     if (size &lt; 1 || size &gt; 4) {
4990         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);
4991         return;
4992     }
4993     if (stride &lt; 0 || stride &gt; 255) {
4994         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);
4995         return;
4996     }
4997     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
4998         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
4999         return;
5000     }
<span class="line-modified">5001     if (!m_boundArrayBuffer) {</span>
5002         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
5003         return;
5004     }
5005     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5006     auto typeSize = sizeInBytes(type);
5007     if (!typeSize) {
5008         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5009         return;
5010     }
5011     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {
5012         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
5013         return;
5014     }
5015     GC3Dsizei bytesPerElement = size * typeSize;
5016 
<span class="line-modified">5017     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), *m_boundArrayBuffer);</span>
5018     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
5019 }
5020 
5021 void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
5022 {
5023     if (isContextLostOrPending())
5024         return;
5025     if (!validateSize(&quot;viewport&quot;, width, height))
5026         return;
5027     m_context-&gt;viewport(x, y, width, height);
5028 }
5029 
5030 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5031 {
5032     if (isContextLostOrPending()) {
5033         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);
5034         return;
5035     }
5036 
5037     m_contextGroup-&gt;loseContextGroup(mode);
5038 }
5039 
<span class="line-removed">5040 void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-removed">5041 {</span>
<span class="line-removed">5042     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-removed">5043     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-removed">5044     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-removed">5045     forceLostContext(SyntheticLostContext);</span>
<span class="line-removed">5046     destroyGraphicsContext3D();</span>
<span class="line-removed">5047 }</span>
<span class="line-removed">5048 </span>
5049 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5050 {
5051     if (isContextLost())
5052         return;
5053 
5054     m_contextLost = true;
5055     m_contextLostMode = mode;
5056 
5057     if (mode == RealLostContext) {
5058         // Inform the embedder that a lost context was received. In response, the embedder might
5059         // decide to take action such as asking the user for permission to use WebGL again.
5060         auto* canvas = htmlCanvas();
5061         if (canvas) {
5062             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5063                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5064         }
5065     }
5066 
5067     detachAndRemoveAllObjects();
5068 
</pre>
<hr />
<pre>
5756     case GraphicsContext3D::EQUAL:
5757     case GraphicsContext3D::NOTEQUAL:
5758     case GraphicsContext3D::ALWAYS:
5759         return true;
5760     default:
5761         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);
5762         return false;
5763     }
5764 }
5765 
5766 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5767 {
5768     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5769         return;
5770 
5771     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5772 
5773     // Error messages can occur during function calls, so show stack traces for them.
5774     if (level == MessageLevel::Error) {
5775         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<span class="line-modified">5776         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
5777     } else
<span class="line-modified">5778         consoleMessage = std::make_unique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
5779 
5780     auto* canvas = htmlCanvas();
5781     if (canvas)
5782         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5783 
5784     --m_numGLErrorsToConsoleAllowed;
5785     if (!m_numGLErrorsToConsoleAllowed)
5786         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5787 }
5788 
5789 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)
5790 {
5791     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5792          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))
5793         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5794             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {
5795         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);
5796         return false;
5797     }
5798     return true;
</pre>
<hr />
<pre>
6203 
6204     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));
6205     if (!context) {
6206         if (m_contextLostMode == RealLostContext)
6207             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6208         else
6209             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
6210             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);
6211         return;
6212     }
6213 
6214     m_context = context;
6215     addActivityStateChangeObserverIfNecessary();
6216     m_contextLost = false;
6217     setupFlags();
6218     initializeNewContext();
6219     initializeVertexArrayObjects();
6220     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6221 }
6222 
<span class="line-removed">6223 void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="line-removed">6224 {</span>
<span class="line-removed">6225     auto* canvas = htmlCanvas();</span>
<span class="line-removed">6226     if (!canvas)</span>
<span class="line-removed">6227         return;</span>
<span class="line-removed">6228 </span>
<span class="line-removed">6229     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-removed">6230 }</span>
<span class="line-removed">6231 </span>
6232 void WebGLRenderingContextBase::simulateContextChanged()
6233 {
6234     if (m_context)
6235         m_context-&gt;simulateContextChanged();
6236 }
6237 
6238 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6239 {
6240     if (text.isNull())
6241         return WTF::emptyString();
6242     return text;
6243 }
6244 
6245 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6246     : m_buffers(capacity)
6247 {
6248 }
6249 
6250 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6251 {
</pre>
<hr />
<pre>
6491 }
6492 
6493 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6494 {
6495     if (!m_context)
6496         return;
6497 
6498     auto changed = oldActivityState ^ newActivityState;
6499     if (changed &amp; ActivityState::IsVisible)
6500         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6501 }
6502 
6503 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6504 {
6505     if (!m_context)
6506         return;
6507 
6508     m_context-&gt;setFailNextGPUStatusCheck();
6509 }
6510 






























6511 } // namespace WebCore
6512 
6513 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
  81 #include &quot;WebGLDebugRendererInfo.h&quot;
  82 #include &quot;WebGLDebugShaders.h&quot;
  83 #include &quot;WebGLDepthTexture.h&quot;
  84 #include &quot;WebGLDrawBuffers.h&quot;
  85 #include &quot;WebGLFramebuffer.h&quot;
  86 #include &quot;WebGLLoseContext.h&quot;
  87 #include &quot;WebGLProgram.h&quot;
  88 #include &quot;WebGLRenderbuffer.h&quot;
  89 #include &quot;WebGLRenderingContext.h&quot;
  90 #include &quot;WebGLShader.h&quot;
  91 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  92 #include &quot;WebGLTexture.h&quot;
  93 #include &quot;WebGLUniformLocation.h&quot;
  94 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  95 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  96 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  98 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  99 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 100 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-added"> 101 #include &lt;wtf/HashMap.h&gt;</span>
 102 #include &lt;wtf/HexNumber.h&gt;
<span class="line-added"> 103 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
<span class="line-added"> 104 #include &lt;wtf/Lock.h&gt;</span>
 105 #include &lt;wtf/StdLibExtras.h&gt;
 106 #include &lt;wtf/UniqueArray.h&gt;
 107 #include &lt;wtf/text/CString.h&gt;
 108 #include &lt;wtf/text/StringBuilder.h&gt;
 109 
 110 namespace WebCore {
 111 
<span class="line-added"> 112 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);</span>
<span class="line-added"> 113 </span>
 114 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 115 const int maxGLErrorsAllowedToConsole = 256;
 116 static const Seconds checkContextLossHandlingDelay { 3_s };
 117 
 118 namespace {
 119 





 120     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
 121     {
 122         if (value &lt; min)
 123             value = min;
 124         if (value &gt; max)
 125             value = max;
 126         return value;
 127     }
 128 
 129     // Return true if a character belongs to the ASCII subset as defined in
 130     // GLSL ES 1.0 spec section 3.1.
 131     bool validateCharacter(unsigned char c)
 132     {
 133         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 134         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 135             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 136             return true;
 137         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 138         // are also valid.
 139         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
</pre>
<hr />
<pre>
 545         }
 546 
 547         Document&amp; topDocument = document.topDocument();
 548         Page* page = topDocument.page();
 549         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 550 
 551         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 552             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 553 
 554             if (policy == WebGLBlockCreation) {
 555                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 556                 return nullptr;
 557             }
 558 
 559             if (policy == WebGLPendingCreation) {
 560                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 561                 isPendingPolicyResolution = true;
 562             }
 563         }
 564 



 565         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
 566             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)
 567                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
 568             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;
 569         }
 570 
 571         if (page)
 572             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 573 
 574         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 575     }
 576 
 577     attributes.noExtensions = true;
 578     attributes.shareResources = false;
 579 
 580     attributes.initialPowerPreference = attributes.powerPreference;
 581 
 582 
 583 #if ENABLE(WEBGL2)
 584     if (type == &quot;webgl2&quot;)
</pre>
<hr />
<pre>
 639     , m_isPendingPolicyResolution(true)
 640     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 641 {
 642     registerWithWebGLStateTracker();
 643     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 644 }
 645 
 646 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)
 647     : GPUBasedCanvasRenderingContext(canvas)
 648     , m_context(WTFMove(context))
 649     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 650     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 651     , m_generatedImageCache(4)
 652     , m_attributes(attributes)
 653     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 654     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 655 {
 656     m_contextGroup = WebGLContextGroup::create();
 657     m_contextGroup-&gt;addContext(*this);
 658 
<span class="line-modified"> 659     m_context-&gt;addClient(*this);</span>
 660 
 661     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
 662 
 663     setupFlags();
 664     initializeNewContext();
 665     registerWithWebGLStateTracker();
 666     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 667 
 668     addActivityStateChangeObserverIfNecessary();
 669 }
 670 
 671 WebGLCanvas WebGLRenderingContextBase::canvas()
 672 {
 673     auto&amp; base = canvasBase();
 674     if (is&lt;OffscreenCanvas&gt;(base))
 675         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 676     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 677 }
 678 








 679 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 680 {
 681     auto&amp; base = canvasBase();
 682     if (!is&lt;OffscreenCanvas&gt;(base))
 683         return nullptr;
 684     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 685 }
 686 
 687 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 688 // and to discard temporary GL contexts (e.g. feature detection).
 689 void WebGLRenderingContextBase::checkForContextLossHandling()
 690 {
 691     auto canvas = htmlCanvas();
 692     if (!canvas)
 693         return;
 694 
 695     if (!canvas-&gt;renderer())
 696         return;
 697 
 698     auto* page = canvas-&gt;document().page();
</pre>
<hr />
<pre>
 774     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);
 775 
 776     // These two values from EXT_draw_buffers are lazily queried.
 777     m_maxDrawBuffers = 0;
 778     m_maxColorAttachments = 0;
 779 
 780     m_backDrawBuffer = GraphicsContext3D::BACK;
 781     m_drawBuffersWebGLRequirementsChecked = false;
 782     m_drawBuffersSupported = false;
 783 
 784     m_vertexAttribValue.resize(m_maxVertexAttribs);
 785 
 786     if (!isGLES2NPOTStrict())
 787         createFallbackBlackTextures1x1();
 788 
 789     IntSize canvasSize = clampedCanvasSize();
 790     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 791     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 792     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
 793 
<span class="line-modified"> 794     m_context-&gt;setContextLostCallback(makeUnique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified"> 795     m_context-&gt;setErrorMessageCallback(makeUnique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
 796 }
 797 
 798 void WebGLRenderingContextBase::setupFlags()
 799 {
 800     ASSERT(m_context);
 801 
 802     auto canvas = htmlCanvas();
 803     if (canvas) {
 804         if (Page* page = canvas-&gt;document().page())
 805             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 806     }
 807 
 808     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 809     if (m_isGLES2Compliant) {
 810         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
 811         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);
 812     } else {
 813         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
 814         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);
 815     }
</pre>
<hr />
<pre>
 863     m_boundVertexArrayObject = nullptr;
 864     m_vertexAttrib0Buffer = nullptr;
 865     m_currentProgram = nullptr;
 866     m_framebufferBinding = nullptr;
 867     m_readFramebufferBinding = nullptr;
 868     m_renderbufferBinding = nullptr;
 869 
 870     for (auto&amp; textureUnit : m_textureUnits) {
 871         textureUnit.texture2DBinding = nullptr;
 872         textureUnit.textureCubeMapBinding = nullptr;
 873     }
 874 
 875     m_blackTexture2D = nullptr;
 876     m_blackTextureCubeMap = nullptr;
 877 
 878     if (!m_isPendingPolicyResolution) {
 879         detachAndRemoveAllObjects();
 880         destroyGraphicsContext3D();
 881         m_contextGroup-&gt;removeContext(*this);
 882     }
<span class="line-added"> 883 </span>
<span class="line-added"> 884     {</span>
<span class="line-added"> 885         LockHolder lock(WebGLProgram::instancesMutex());</span>
<span class="line-added"> 886         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-added"> 887             if (entry.value == this) {</span>
<span class="line-added"> 888                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.</span>
<span class="line-added"> 889                 // Only remove the association with a WebGL context.</span>
<span class="line-added"> 890                 entry.value = nullptr;</span>
<span class="line-added"> 891             }</span>
<span class="line-added"> 892         }</span>
<span class="line-added"> 893     }</span>
 894 }
 895 
 896 void WebGLRenderingContextBase::destroyGraphicsContext3D()
 897 {
 898     if (m_isPendingPolicyResolution)
 899         return;
 900 
 901     removeActivityStateChangeObserver();
 902 
 903     if (m_context) {
<span class="line-added"> 904         m_context-&gt;removeClient(*this);</span>
 905         m_context-&gt;setContextLostCallback(nullptr);
 906         m_context-&gt;setErrorMessageCallback(nullptr);
 907         m_context = nullptr;
 908     }
 909 }
 910 
 911 void WebGLRenderingContextBase::markContextChanged()
 912 {
 913     if (m_framebufferBinding)
 914         return;
 915 
 916     m_context-&gt;markContextChanged();
 917 
 918     m_layerCleared = false;
 919 
 920     auto* canvas = htmlCanvas();
 921     if (!canvas)
 922         return;
 923 
 924     RenderBox* renderBox = canvas-&gt;renderBox();
</pre>
<hr />
<pre>
1064 
1065 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1066 {
1067     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1068 }
1069 
1070 void WebGLRenderingContextBase::reshape(int width, int height)
1071 {
1072     if (isContextLostOrPending())
1073         return;
1074 
1075     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1076     // know if the underlying FBO uses textures or renderbuffers.
1077     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);
1078     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);
1079     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
1080     width = clamp(width, 1, maxWidth);
1081     height = clamp(height, 1, maxHeight);
1082 
1083     if (m_needsUpdate) {
<span class="line-modified">1084         notifyCanvasContentChanged();</span>





1085         m_needsUpdate = false;
1086     }
1087 
1088     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1089     // clear (and this matches what reshape will do).
1090     m_context-&gt;reshape(width, height);
1091 
1092     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1093     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));
1094     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1095         m_unrenderableTextureUnits.add(m_activeTextureUnit);
1096     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));
1097     if (m_framebufferBinding)
1098       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
1099 }
1100 
1101 int WebGLRenderingContextBase::drawingBufferWidth() const
1102 {
1103     if (isContextLost())
1104         return 0;
</pre>
<hr />
<pre>
1549     m_colorMask[2] = blue;
1550     m_colorMask[3] = alpha;
1551     m_context-&gt;colorMask(red, green, blue, alpha);
1552 }
1553 
1554 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1555 {
1556     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1557         return;
1558     m_context-&gt;compileShader(objectOrZero(shader));
1559     GC3Dint value;
1560     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);
1561     shader-&gt;setValid(value);
1562 
1563     auto* canvas = htmlCanvas();
1564 
1565     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1566         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1567 
1568         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<span class="line-modified">1569             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
1570     }
1571 }
1572 
1573 void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
1574 {
1575     if (isContextLostOrPending())
1576         return;
1577     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1578         return;
1579 
1580     if (!validateCompressedTexFormat(internalformat)) {
1581         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);
1582         return;
1583     }
1584     if (border) {
1585         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);
1586         return;
1587     }
1588     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1589         return;
</pre>
<hr />
<pre>
1709             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1710             if (!zero) {
1711                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);
1712                 return;
1713             }
1714             memset(zero.get(), 0, size);
1715         }
1716         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1717         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1718             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1719     } else
1720         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1721 }
1722 
1723 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1724 {
1725     if (isContextLostOrPending())
1726         return nullptr;
1727     auto buffer = WebGLBuffer::create(*this);
1728     addSharedObject(buffer.get());
<span class="line-modified">1729     return buffer;</span>
1730 }
1731 
1732 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1733 {
1734     if (isContextLostOrPending())
1735         return nullptr;
1736     auto buffer = WebGLFramebuffer::create(*this);
1737     addContextObject(buffer.get());
<span class="line-modified">1738     return buffer;</span>
1739 }
1740 
1741 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1742 {
1743     if (isContextLostOrPending())
1744         return nullptr;
1745     auto texture = WebGLTexture::create(*this);
1746     addSharedObject(texture.get());
<span class="line-modified">1747     return texture;</span>
1748 }
1749 
1750 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1751 {
1752     if (isContextLostOrPending())
1753         return nullptr;
1754     auto program = WebGLProgram::create(*this);
1755     addSharedObject(program.get());
1756 
1757     InspectorInstrumentation::didCreateProgram(*this, program.get());
1758 
<span class="line-modified">1759     return program;</span>
1760 }
1761 
1762 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1763 {
1764     if (isContextLostOrPending())
1765         return nullptr;
1766     auto buffer = WebGLRenderbuffer::create(*this);
1767     addSharedObject(buffer.get());
<span class="line-modified">1768     return buffer;</span>
1769 }
1770 
1771 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
1772 {
1773     if (isContextLostOrPending())
1774         return nullptr;
1775     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {
1776         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);
1777         return nullptr;
1778     }
1779 
1780     auto shader = WebGLShader::create(*this, type);
1781     addSharedObject(shader.get());
<span class="line-modified">1782     return shader;</span>
1783 }
1784 
1785 void WebGLRenderingContextBase::cullFace(GC3Denum mode)
1786 {
1787     if (isContextLostOrPending())
1788         return;
1789     m_context-&gt;cullFace(mode);
1790 }
1791 
1792 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1793 {
1794     if (isContextLostOrPending() || !object)
1795         return false;
1796     if (!object-&gt;validate(contextGroup(), *this)) {
1797         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);
1798         return false;
1799     }
1800     if (object-&gt;isDeleted())
1801         return false;
1802     if (object-&gt;object())
</pre>
<hr />
<pre>
2025         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);
2026         break;
2027     case GraphicsContext3D::UNSIGNED_SHORT:
2028         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);
2029         break;
2030     case GraphicsContext3D::UNSIGNED_BYTE:
2031         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);
2032         break;
2033     }
2034 
2035     // Then set the maxiumum index in the index array and make sure it is valid.
2036     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2037     if (!checkedNumElementsRequired)
2038         return false;
2039     numElementsRequired = checkedNumElementsRequired.value();
2040     return true;
2041 }
2042 
2043 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2044 {
<span class="line-added">2045 #if !USE(ANGLE)</span>
2046     if (!m_currentProgram)
2047         return false;
2048 
2049     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2050     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2051         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2052             return false;
2053     }
2054 
2055     if (!elementCount)
2056         return true;
2057 
2058     // Look in each consumed vertex attrib (by the current program).
2059     bool sawNonInstancedAttrib = false;
2060     bool sawEnabledAttrib = false;
2061     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2062     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2063         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2064         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2065             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
</pre>
<hr />
<pre>
2093         return false;
2094 
2095     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2096 
2097     // Guard against access into non-existent buffers.
2098     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2099         return false;
2100 
2101     if (elementCount &amp;&amp; sawEnabledAttrib) {
2102         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2103             if (usingSimulatedArrayBuffer) {
2104                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2105                 if (state.enabled &amp;&amp; state.isBound()) {
2106                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2107                         return !!state.bufferBinding-&gt;byteLength();
2108                 }
2109             }
2110             return false;
2111         }
2112     }
<span class="line-added">2113 #endif</span>
2114 
2115     return true;
2116 }
2117 
2118 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2119 {
2120     if (!object || !object-&gt;object()) {
2121         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);
2122         return false;
2123     }
2124     if (!object-&gt;validate(contextGroup(), *this)) {
2125         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);
2126         return false;
2127     }
2128     return true;
2129 }
2130 
2131 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)
2132 {
2133     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
</pre>
<hr />
<pre>
2610     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
2611     if (pname == GraphicsContext3D::BUFFER_SIZE)
2612         return value;
2613     return static_cast&lt;unsigned&gt;(value);
2614 }
2615 
2616 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2617 {
2618     if (isContextLostOrPending())
2619         return WTF::nullopt;
2620 
2621     // Also, we need to enforce requested values of &quot;false&quot; for depth
2622     // and stencil, regardless of the properties of the underlying
2623     // GraphicsContext3D.
2624 
2625     auto attributes = m_context-&gt;getContextAttributes();
2626     if (!m_attributes.depth)
2627         attributes.depth = false;
2628     if (!m_attributes.stencil)
2629         attributes.stencil = false;
<span class="line-modified">2630     return attributes;</span>
2631 }
2632 
2633 GC3Denum WebGLRenderingContextBase::getError()
2634 {
2635     if (m_isPendingPolicyResolution)
2636         return GraphicsContext3D::NO_ERROR;
2637     return m_context-&gt;getError();
2638 }
2639 
2640 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)
2641 {
2642     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2643         return nullptr;
2644 
2645     GC3Dint value = 0;
2646     switch (pname) {
2647     case GraphicsContext3D::DELETE_STATUS:
2648         return program-&gt;isDeleted();
2649     case GraphicsContext3D::VALIDATE_STATUS:
2650         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2651         return static_cast&lt;bool&gt;(value);
2652     case GraphicsContext3D::LINK_STATUS:
2653         return program-&gt;getLinkStatus();
2654     case GraphicsContext3D::ATTACHED_SHADERS:
2655         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2656         return value;
2657     case GraphicsContext3D::ACTIVE_ATTRIBUTES:
2658     case GraphicsContext3D::ACTIVE_UNIFORMS:
<span class="line-added">2659 #if USE(ANGLE)</span>
<span class="line-added">2660         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="line-added">2661 #else</span>
2662         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
<span class="line-added">2663 #endif // USE(ANGLE)</span>
2664         return value;
2665     default:
2666         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
2667         return nullptr;
2668     }
2669 }
2670 
2671 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2672 {
2673     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2674         return String();
2675     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2676 }
2677 
2678 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)
2679 {
2680     if (isContextLostOrPending())
2681         return nullptr;
2682     if (target != GraphicsContext3D::RENDERBUFFER) {
2683         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);
</pre>
<hr />
<pre>
2930     case GraphicsContext3D::INT: {
2931         GC3Dint value[4] = {0};
2932         if (m_isRobustnessEXTSupported)
2933             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2934         else
2935             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2936         if (length == 1)
2937             return value[0];
2938         return Int32Array::tryCreate(value, length);
2939     }
2940     case GraphicsContext3D::BOOL: {
2941         GC3Dint value[4] = {0};
2942         if (m_isRobustnessEXTSupported)
2943             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2944         else
2945             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2946         if (length &gt; 1) {
2947             Vector&lt;bool&gt; vector(length);
2948             for (unsigned j = 0; j &lt; length; j++)
2949                 vector[j] = value[j];
<span class="line-modified">2950             return vector;</span>
2951         }
2952         return static_cast&lt;bool&gt;(value[0]);
2953     }
2954     default:
2955         notImplemented();
2956     }
2957 
2958     // If we get here, something went wrong in our unfortunately complex logic above
2959     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);
2960     return nullptr;
2961 }
2962 
2963 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2964 {
2965     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2966         return nullptr;
2967     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
2968         return nullptr;
2969     if (!validateString(&quot;getUniformLocation&quot;, name))
2970         return nullptr;
2971     if (isPrefixReserved(name))
2972         return nullptr;
2973     if (!program-&gt;getLinkStatus()) {
2974         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);
2975         return nullptr;
2976     }
2977     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
2978     if (uniformLocation == -1)
2979         return nullptr;
2980 
2981     GC3Dint activeUniforms = 0;
<span class="line-added">2982 #if USE(ANGLE)</span>
<span class="line-added">2983     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
<span class="line-added">2984 #else</span>
2985     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);
<span class="line-added">2986 #endif</span>
2987     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {
2988         ActiveInfo info;
2989         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
2990             return nullptr;
2991         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
2992         if (info.name.endsWith(&quot;[0]&quot;))
2993             info.name = info.name.left(info.name.length() - 3);
2994         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
2995         for (GC3Dint index = 0; index &lt; info.size; ++index) {
2996             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
2997 
2998             if (name == uniformName || name == info.name)
2999                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3000         }
3001     }
3002     return nullptr;
3003 }
3004 
3005 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)
3006 {
</pre>
<hr />
<pre>
3180     if (isContextLostOrPending())
3181         return;
3182     m_context-&gt;lineWidth(width);
3183 }
3184 
3185 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3186 {
3187     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3188         return;
3189 
3190     program-&gt;increaseLinkCount();
3191 }
3192 
3193 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3194 {
3195     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3196         return false;
3197 
3198     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
3199     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<span class="line-modified">3200     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {</span>
3201         program-&gt;setLinkStatus(false);
3202         return false;
3203     }
3204 
<span class="line-added">3205 #if !USE(ANGLE)</span>
<span class="line-added">3206     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))</span>
<span class="line-added">3207         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
<span class="line-added">3208         program-&gt;setLinkStatus(false);</span>
<span class="line-added">3209         return false;</span>
<span class="line-added">3210     }</span>
<span class="line-added">3211 #endif</span>
<span class="line-added">3212 </span>
3213     m_context-&gt;linkProgram(objectOrZero(program));
3214     return true;
3215 }
3216 
3217 void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
3218 {
3219     if (isContextLostOrPending())
3220         return;
3221     switch (pname) {
3222     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:
3223         m_unpackFlipY = param;
3224         break;
3225     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
3226         m_unpackPremultiplyAlpha = param;
3227         break;
3228     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:
3229         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)
3230             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);
3231         else {
3232             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);
</pre>
<hr />
<pre>
3432 
3433 void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)
3434 {
3435     if (isContextLostOrPending())
3436         return;
3437     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3438     // taint the origin using the WebGL API.
3439     ASSERT(canvasBase().originClean());
3440 
3441     GC3Denum internalFormat = 0;
3442     if (m_framebufferBinding) {
3443         const char* reason = &quot;framebuffer incomplete&quot;;
3444         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
3445             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);
3446             return;
3447         }
3448         // FIXME: readBuffer() should affect this
3449         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3450     } else {
3451         if (m_attributes.alpha)


3452             internalFormat = GraphicsContext3D::RGBA8;
<span class="line-added">3453         else</span>
<span class="line-added">3454             internalFormat = GraphicsContext3D::RGB8;</span>
3455     }
3456 
3457     if (!internalFormat) {
3458         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3459         return;
3460     }
3461 
3462     if (isWebGL1()) {
3463         switch (format) {
3464         case GraphicsContext3D::ALPHA:
3465         case GraphicsContext3D::RGB:
3466         case GraphicsContext3D::RGBA:
3467             break;
3468         default:
3469             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);
3470             return;
3471         }
3472         switch (type) {
3473         case GraphicsContext3D::UNSIGNED_BYTE:
3474         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
3475         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
3476         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
3477             break;
<span class="line-added">3478         case GraphicsContext3D::FLOAT:</span>
<span class="line-added">3479             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {</span>
<span class="line-added">3480                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
<span class="line-added">3481                 return;</span>
<span class="line-added">3482             }</span>
<span class="line-added">3483             break;</span>
3484         default:
3485             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3486             return;
3487         }
<span class="line-modified">3488         if (format != GraphicsContext3D::RGBA || (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::FLOAT)) {</span>
<span class="line-modified">3489             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
3490             return;
3491         }
3492     }
3493 
3494     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3495     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3496     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
3497         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3498         return;
3499     }
3500 
<span class="line-modified">3501 #define CHECK_COMPONENT_COUNT \</span>
<span class="line-modified">3502     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-modified">3503         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-modified">3504         return; \</span>
<span class="line-modified">3505     }</span>









3506 
<span class="line-modified">3507 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">3508     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3509         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3510         return; \</span>
<span class="line-modified">3511     } \</span>
<span class="line-modified">3512     if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-modified">3513         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3514         return; \</span>
<span class="line-modified">3515     } \</span>
<span class="line-modified">3516     CHECK_COMPONENT_COUNT</span>




3517 
<span class="line-modified">3518 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">3519     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3520         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3521         return; \</span>
<span class="line-modified">3522     } \</span>
<span class="line-modified">3523     if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">3524         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3525         return; \</span>
<span class="line-modified">3526     } \</span>
<span class="line-modified">3527     CHECK_COMPONENT_COUNT</span>
<span class="line-modified">3528 </span>
<span class="line-added">3529 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-added">3530     if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-added">3531         &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-added">3532         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-added">3533         return; \</span>
<span class="line-added">3534     } \</span>
<span class="line-added">3535     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-added">3536         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-added">3537         return; \</span>
<span class="line-added">3538     } \</span>
<span class="line-added">3539     break;</span>
3540 
3541     switch (internalFormatTheme) {
<span class="line-modified">3542     case InternalFormatTheme::NormalizedFixedPoint:</span>
<span class="line-modified">3543         if (type == GraphicsContext3D::FLOAT) {</span>
<span class="line-modified">3544             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-modified">3545         } else {</span>
<span class="line-modified">3546             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);</span>
<span class="line-added">3547         }</span>
<span class="line-added">3548         break;</span>
<span class="line-added">3549     case InternalFormatTheme::SignedNormalizedFixedPoint:</span>
<span class="line-added">3550         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);</span>
<span class="line-added">3551         break;</span>
<span class="line-added">3552     case InternalFormatTheme::FloatingPoint:</span>
<span class="line-added">3553         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-added">3554         break;</span>
<span class="line-added">3555     case InternalFormatTheme::SignedInteger:</span>
<span class="line-added">3556         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);</span>
<span class="line-added">3557         break;</span>
<span class="line-added">3558     case InternalFormatTheme::UnsignedInteger:</span>
<span class="line-added">3559         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);</span>
<span class="line-added">3560         break;</span>
3561     case InternalFormatTheme::Packed:
3562         switch (internalFormat) {
<span class="line-modified">3563             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3564             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3565             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3566             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">3567             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">3568             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">3569             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
3570         }
3571         break;
3572     case InternalFormatTheme::None:
3573         ASSERT_NOT_REACHED();
3574     }
<span class="line-added">3575 #undef CHECK_COMPONENT_COUNT</span>
3576 #undef INTERNAL_FORMAT_CHECK
3577 #undef INTERNAL_FORMAT_INTEGER_CHECK
<span class="line-modified">3578 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK</span>
3579 
3580     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3581     unsigned totalBytesRequired = 0;
3582     unsigned padding = 0;
3583     if (!m_isRobustnessEXTSupported) {
3584         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);
3585         if (error != GraphicsContext3D::NO_ERROR) {
3586             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3587             return;
3588         }
3589         if (pixels.byteLength() &lt; totalBytesRequired) {
3590             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);
3591             return;
3592         }
3593     }
3594 
3595     clearIfComposited();
3596     void* data = pixels.baseAddress();
3597 
3598     if (m_isRobustnessEXTSupported)
</pre>
<hr />
<pre>
5014     default:
5015         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5016         return;
5017     }
5018     if (index &gt;= m_maxVertexAttribs) {
5019         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);
5020         return;
5021     }
5022     if (size &lt; 1 || size &gt; 4) {
5023         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);
5024         return;
5025     }
5026     if (stride &lt; 0 || stride &gt; 255) {
5027         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);
5028         return;
5029     }
5030     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
5031         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
5032         return;
5033     }
<span class="line-modified">5034     if (!m_boundArrayBuffer &amp;&amp; offset) {</span>
5035         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
5036         return;
5037     }
5038     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5039     auto typeSize = sizeInBytes(type);
5040     if (!typeSize) {
5041         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5042         return;
5043     }
5044     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {
5045         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
5046         return;
5047     }
5048     GC3Dsizei bytesPerElement = size * typeSize;
5049 
<span class="line-modified">5050     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), m_boundArrayBuffer.get());</span>
5051     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
5052 }
5053 
5054 void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
5055 {
5056     if (isContextLostOrPending())
5057         return;
5058     if (!validateSize(&quot;viewport&quot;, width, height))
5059         return;
5060     m_context-&gt;viewport(x, y, width, height);
5061 }
5062 
5063 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5064 {
5065     if (isContextLostOrPending()) {
5066         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);
5067         return;
5068     }
5069 
5070     m_contextGroup-&gt;loseContextGroup(mode);
5071 }
5072 









5073 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5074 {
5075     if (isContextLost())
5076         return;
5077 
5078     m_contextLost = true;
5079     m_contextLostMode = mode;
5080 
5081     if (mode == RealLostContext) {
5082         // Inform the embedder that a lost context was received. In response, the embedder might
5083         // decide to take action such as asking the user for permission to use WebGL again.
5084         auto* canvas = htmlCanvas();
5085         if (canvas) {
5086             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5087                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5088         }
5089     }
5090 
5091     detachAndRemoveAllObjects();
5092 
</pre>
<hr />
<pre>
5780     case GraphicsContext3D::EQUAL:
5781     case GraphicsContext3D::NOTEQUAL:
5782     case GraphicsContext3D::ALWAYS:
5783         return true;
5784     default:
5785         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);
5786         return false;
5787     }
5788 }
5789 
5790 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5791 {
5792     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5793         return;
5794 
5795     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5796 
5797     // Error messages can occur during function calls, so show stack traces for them.
5798     if (level == MessageLevel::Error) {
5799         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<span class="line-modified">5800         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
5801     } else
<span class="line-modified">5802         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
5803 
5804     auto* canvas = htmlCanvas();
5805     if (canvas)
5806         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5807 
5808     --m_numGLErrorsToConsoleAllowed;
5809     if (!m_numGLErrorsToConsoleAllowed)
5810         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5811 }
5812 
5813 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)
5814 {
5815     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5816          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))
5817         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5818             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {
5819         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);
5820         return false;
5821     }
5822     return true;
</pre>
<hr />
<pre>
6227 
6228     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));
6229     if (!context) {
6230         if (m_contextLostMode == RealLostContext)
6231             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6232         else
6233             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
6234             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);
6235         return;
6236     }
6237 
6238     m_context = context;
6239     addActivityStateChangeObserverIfNecessary();
6240     m_contextLost = false;
6241     setupFlags();
6242     initializeNewContext();
6243     initializeVertexArrayObjects();
6244     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6245 }
6246 









6247 void WebGLRenderingContextBase::simulateContextChanged()
6248 {
6249     if (m_context)
6250         m_context-&gt;simulateContextChanged();
6251 }
6252 
6253 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6254 {
6255     if (text.isNull())
6256         return WTF::emptyString();
6257     return text;
6258 }
6259 
6260 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6261     : m_buffers(capacity)
6262 {
6263 }
6264 
6265 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6266 {
</pre>
<hr />
<pre>
6506 }
6507 
6508 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6509 {
6510     if (!m_context)
6511         return;
6512 
6513     auto changed = oldActivityState ^ newActivityState;
6514     if (changed &amp; ActivityState::IsVisible)
6515         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6516 }
6517 
6518 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6519 {
6520     if (!m_context)
6521         return;
6522 
6523     m_context-&gt;setFailNextGPUStatusCheck();
6524 }
6525 
<span class="line-added">6526 void WebGLRenderingContextBase::didComposite()</span>
<span class="line-added">6527 {</span>
<span class="line-added">6528     if (UNLIKELY(callTracingActive()))</span>
<span class="line-added">6529         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);</span>
<span class="line-added">6530 }</span>
<span class="line-added">6531 </span>
<span class="line-added">6532 void WebGLRenderingContextBase::forceContextLost()</span>
<span class="line-added">6533 {</span>
<span class="line-added">6534     forceLostContext(WebGLRenderingContextBase::RealLostContext);</span>
<span class="line-added">6535 }</span>
<span class="line-added">6536 </span>
<span class="line-added">6537 void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-added">6538 {</span>
<span class="line-added">6539     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-added">6540     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-added">6541     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-added">6542     forceLostContext(SyntheticLostContext);</span>
<span class="line-added">6543     destroyGraphicsContext3D();</span>
<span class="line-added">6544 }</span>
<span class="line-added">6545 </span>
<span class="line-added">6546 void WebGLRenderingContextBase::dispatchContextChangedNotification()</span>
<span class="line-added">6547 {</span>
<span class="line-added">6548     auto* canvas = htmlCanvas();</span>
<span class="line-added">6549     if (!canvas)</span>
<span class="line-added">6550         return;</span>
<span class="line-added">6551 </span>
<span class="line-added">6552     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-added">6553 }</span>
<span class="line-added">6554 </span>
<span class="line-added">6555 </span>
6556 } // namespace WebCore
6557 
6558 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLRenderingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>