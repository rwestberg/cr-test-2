<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   6  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
  32 #include &quot;ApplicationStateChangeListener.h&quot;
  33 #include &quot;Attr.h&quot;
  34 #include &quot;BeforeUnloadEvent.h&quot;
  35 #include &quot;CDATASection.h&quot;
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSStyleDeclaration.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CachedCSSStyleSheet.h&quot;
  41 #include &quot;CachedFrame.h&quot;
  42 #include &quot;CachedResourceLoader.h&quot;
  43 #include &quot;CanvasRenderingContext2D.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;Comment.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ComposedTreeIterator.h&quot;
  49 #include &quot;CompositionEvent.h&quot;
  50 #include &quot;ConstantPropertyMap.h&quot;
  51 #include &quot;ContentSecurityPolicy.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;CustomElementReactionQueue.h&quot;
  54 #include &quot;CustomElementRegistry.h&quot;
  55 #include &quot;CustomEvent.h&quot;
  56 #include &quot;DOMImplementation.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DateComponents.h&quot;
  59 #include &quot;DebugPageOverlays.h&quot;
  60 #include &quot;DocumentAnimationScheduler.h&quot;
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;Editing.h&quot;
  67 #include &quot;Editor.h&quot;
  68 #include &quot;ElementIterator.h&quot;
  69 #include &quot;EventHandler.h&quot;
  70 #include &quot;ExtensionStyleSheets.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;FocusEvent.h&quot;
  73 #include &quot;FontFaceSet.h&quot;
  74 #include &quot;FormController.h&quot;
  75 #include &quot;Frame.h&quot;
  76 #include &quot;FrameLoader.h&quot;
  77 #include &quot;FrameLoaderClient.h&quot;
  78 #include &quot;FrameView.h&quot;
  79 #include &quot;GenericCachedHTMLCollection.h&quot;
  80 #include &quot;HTMLAllCollection.h&quot;
  81 #include &quot;HTMLAnchorElement.h&quot;
  82 #include &quot;HTMLAttachmentElement.h&quot;
  83 #include &quot;HTMLBaseElement.h&quot;
  84 #include &quot;HTMLBodyElement.h&quot;
  85 #include &quot;HTMLCanvasElement.h&quot;
  86 #include &quot;HTMLDocument.h&quot;
  87 #include &quot;HTMLElementFactory.h&quot;
  88 #include &quot;HTMLFormControlElement.h&quot;
  89 #include &quot;HTMLFrameOwnerElement.h&quot;
  90 #include &quot;HTMLFrameSetElement.h&quot;
  91 #include &quot;HTMLHeadElement.h&quot;
  92 #include &quot;HTMLHtmlElement.h&quot;
  93 #include &quot;HTMLImageElement.h&quot;
  94 #include &quot;HTMLInputElement.h&quot;
  95 #include &quot;HTMLLinkElement.h&quot;
  96 #include &quot;HTMLMediaElement.h&quot;
  97 #include &quot;HTMLNameCollection.h&quot;
  98 #include &quot;HTMLParserIdioms.h&quot;
  99 #include &quot;HTMLPictureElement.h&quot;
 100 #include &quot;HTMLPlugInElement.h&quot;
 101 #include &quot;HTMLScriptElement.h&quot;
 102 #include &quot;HTMLStyleElement.h&quot;
 103 #include &quot;HTMLTitleElement.h&quot;
 104 #include &quot;HTMLUnknownElement.h&quot;
 105 #include &quot;HTTPHeaderNames.h&quot;
 106 #include &quot;HTTPParsers.h&quot;
 107 #include &quot;HashChangeEvent.h&quot;
 108 #include &quot;History.h&quot;
 109 #include &quot;HitTestResult.h&quot;
 110 #include &quot;ImageBitmapRenderingContext.h&quot;
 111 #include &quot;ImageLoader.h&quot;
 112 #include &quot;InspectorInstrumentation.h&quot;
 113 #include &quot;IntersectionObserver.h&quot;
 114 #include &quot;JSCustomElementInterface.h&quot;
 115 #include &quot;JSDOMPromiseDeferred.h&quot;
 116 #include &quot;JSLazyEventListener.h&quot;
 117 #include &quot;KeyboardEvent.h&quot;
 118 #include &quot;KeyframeEffect.h&quot;
 119 #include &quot;LayoutDisallowedScope.h&quot;
 120 #include &quot;LibWebRTCProvider.h&quot;
 121 #include &quot;LoaderStrategy.h&quot;
 122 #include &quot;Logging.h&quot;
 123 #include &quot;MediaCanStartListener.h&quot;
 124 #include &quot;MediaProducer.h&quot;
 125 #include &quot;MediaQueryList.h&quot;
 126 #include &quot;MediaQueryMatcher.h&quot;
 127 #include &quot;MessageEvent.h&quot;
 128 #include &quot;Microtasks.h&quot;
 129 #include &quot;MouseEventWithHitTestResults.h&quot;
 130 #include &quot;MutationEvent.h&quot;
 131 #include &quot;NameNodeList.h&quot;
 132 #include &quot;NavigationDisabler.h&quot;
 133 #include &quot;NavigationScheduler.h&quot;
 134 #include &quot;NestingLevelIncrementer.h&quot;
 135 #include &quot;NodeIterator.h&quot;
 136 #include &quot;NodeRareData.h&quot;
 137 #include &quot;NodeWithIndex.h&quot;
 138 #include &quot;OriginAccessEntry.h&quot;
 139 #include &quot;OverflowEvent.h&quot;
 140 #include &quot;PageConsoleClient.h&quot;
 141 #include &quot;PageGroup.h&quot;
 142 #include &quot;PageTransitionEvent.h&quot;
 143 #include &quot;PaintWorkletGlobalScope.h&quot;
 144 #include &quot;PlatformLocale.h&quot;
 145 #include &quot;PlatformMediaSessionManager.h&quot;
 146 #include &quot;PlatformScreen.h&quot;
 147 #include &quot;PlatformStrategies.h&quot;
 148 #include &quot;PlugInsResources.h&quot;
 149 #include &quot;PluginDocument.h&quot;
 150 #include &quot;PointerLockController.h&quot;
 151 #include &quot;PolicyChecker.h&quot;
 152 #include &quot;PopStateEvent.h&quot;
 153 #include &quot;ProcessingInstruction.h&quot;
 154 #include &quot;PublicSuffix.h&quot;
 155 #include &quot;Quirks.h&quot;
 156 #include &quot;RealtimeMediaSourceCenter.h&quot;
 157 #include &quot;RenderChildIterator.h&quot;
 158 #include &quot;RenderInline.h&quot;
 159 #include &quot;RenderLayerCompositor.h&quot;
 160 #include &quot;RenderLineBreak.h&quot;
 161 #include &quot;RenderTreeUpdater.h&quot;
 162 #include &quot;RenderView.h&quot;
 163 #include &quot;RenderWidget.h&quot;
 164 #include &quot;RequestAnimationFrameCallback.h&quot;
 165 #include &quot;ResourceLoadObserver.h&quot;
 166 #include &quot;RuntimeApplicationChecks.h&quot;
 167 #include &quot;RuntimeEnabledFeatures.h&quot;
 168 #include &quot;SVGDocumentExtensions.h&quot;
 169 #include &quot;SVGElement.h&quot;
 170 #include &quot;SVGElementFactory.h&quot;
 171 #include &quot;SVGNames.h&quot;
 172 #include &quot;SVGSVGElement.h&quot;
 173 #include &quot;SVGTitleElement.h&quot;
 174 #include &quot;SVGUseElement.h&quot;
 175 #include &quot;SVGZoomEvent.h&quot;
 176 #include &quot;SWClientConnection.h&quot;
 177 #include &quot;SchemeRegistry.h&quot;
 178 #include &quot;ScopedEventQueue.h&quot;
 179 #include &quot;ScriptController.h&quot;
 180 #include &quot;ScriptDisallowedScope.h&quot;
 181 #include &quot;ScriptModuleLoader.h&quot;
 182 #include &quot;ScriptRunner.h&quot;
 183 #include &quot;ScriptSourceCode.h&quot;
 184 #include &quot;ScriptState.h&quot;
 185 #include &quot;ScriptedAnimationController.h&quot;
 186 #include &quot;ScrollbarTheme.h&quot;
 187 #include &quot;ScrollingCoordinator.h&quot;
 188 #include &quot;SecurityOrigin.h&quot;
 189 #include &quot;SecurityOriginData.h&quot;
 190 #include &quot;SecurityOriginPolicy.h&quot;
 191 #include &quot;SecurityPolicy.h&quot;
 192 #include &quot;SegmentedString.h&quot;
 193 #include &quot;SelectorQuery.h&quot;
 194 #include &quot;ServiceWorkerClientData.h&quot;
 195 #include &quot;ServiceWorkerProvider.h&quot;
 196 #include &quot;Settings.h&quot;
 197 #include &quot;ShadowRoot.h&quot;
 198 #include &quot;SocketProvider.h&quot;
 199 #include &quot;StorageEvent.h&quot;
 200 #include &quot;StringCallback.h&quot;
 201 #include &quot;StyleColor.h&quot;
 202 #include &quot;StyleProperties.h&quot;
 203 #include &quot;StyleResolveForDocument.h&quot;
 204 #include &quot;StyleResolver.h&quot;
 205 #include &quot;StyleScope.h&quot;
 206 #include &quot;StyleSheetContents.h&quot;
 207 #include &quot;StyleSheetList.h&quot;
 208 #include &quot;StyleTreeResolver.h&quot;
 209 #include &quot;SubresourceLoader.h&quot;
 210 #include &quot;TextAutoSizing.h&quot;
 211 #include &quot;TextEvent.h&quot;
 212 #include &quot;TextNodeTraversal.h&quot;
 213 #include &quot;TouchAction.h&quot;
 214 #include &quot;TransformSource.h&quot;
 215 #include &quot;TreeWalker.h&quot;
 216 #include &quot;UndoManager.h&quot;
 217 #include &quot;UserGestureIndicator.h&quot;
 218 #include &quot;ValidationMessageClient.h&quot;
 219 #include &quot;VisibilityChangeClient.h&quot;
 220 #include &quot;VisitedLinkState.h&quot;
 221 #include &quot;WebAnimation.h&quot;
 222 #include &quot;WheelEvent.h&quot;
 223 #include &quot;WindowFeatures.h&quot;
 224 #include &quot;Worklet.h&quot;
 225 #include &quot;XMLDocument.h&quot;
 226 #include &quot;XMLDocumentParser.h&quot;
 227 #include &quot;XMLNSNames.h&quot;
 228 #include &quot;XMLNames.h&quot;
 229 #include &quot;XPathEvaluator.h&quot;
 230 #include &quot;XPathExpression.h&quot;
 231 #include &quot;XPathNSResolver.h&quot;
 232 #include &quot;XPathResult.h&quot;
 233 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 234 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 235 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 236 #include &lt;JavaScriptCore/VM.h&gt;
 237 #include &lt;ctime&gt;
 238 #include &lt;wtf/IsoMallocInlines.h&gt;
 239 #include &lt;wtf/Language.h&gt;
 240 #include &lt;wtf/NeverDestroyed.h&gt;
 241 #include &lt;wtf/SetForScope.h&gt;
 242 #include &lt;wtf/SystemTracing.h&gt;
 243 #include &lt;wtf/UUID.h&gt;
 244 #include &lt;wtf/text/StringBuffer.h&gt;
 245 #include &lt;wtf/text/TextStream.h&gt;
 246 
 247 #if PLATFORM(JAVA)
 248 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 249 #endif
 250 
 251 #if ENABLE(DEVICE_ORIENTATION)
 252 #include &quot;DeviceMotionEvent.h&quot;
 253 #include &quot;DeviceOrientationEvent.h&quot;
 254 #endif
 255 
 256 #if ENABLE(FULLSCREEN_API)
 257 #include &quot;RenderFullScreen.h&quot;
 258 #endif
 259 
 260 #if ENABLE(INDEXED_DATABASE)
 261 #include &quot;IDBConnectionProxy.h&quot;
 262 #include &quot;IDBOpenDBRequest.h&quot;
 263 #endif
 264 
 265 #if PLATFORM(IOS_FAMILY)
 266 #include &quot;CSSFontSelector.h&quot;
 267 #include &quot;DeviceMotionClientIOS.h&quot;
 268 #include &quot;DeviceMotionController.h&quot;
 269 #include &quot;DeviceOrientationClientIOS.h&quot;
 270 #include &quot;DeviceOrientationController.h&quot;
 271 #include &quot;Geolocation.h&quot;
 272 #include &quot;Navigator.h&quot;
 273 #include &quot;NavigatorGeolocation.h&quot;
 274 #include &quot;WKContentObservation.h&quot;
 275 #include &quot;WKContentObservationInternal.h&quot;
 276 #endif
 277 
 278 #if ENABLE(IOS_GESTURE_EVENTS)
 279 #include &quot;GestureEvent.h&quot;
 280 #endif
 281 
 282 #if ENABLE(MATHML)
 283 #include &quot;MathMLElement.h&quot;
 284 #include &quot;MathMLElementFactory.h&quot;
 285 #include &quot;MathMLNames.h&quot;
 286 #endif
 287 
 288 #if ENABLE(MEDIA_SESSION)
 289 #include &quot;MediaSession.h&quot;
 290 #endif
 291 
 292 #if USE(QUICK_LOOK)
 293 #include &quot;QuickLook.h&quot;
 294 #endif
 295 
 296 #if ENABLE(TOUCH_EVENTS)
 297 #include &quot;TouchEvent.h&quot;
 298 #endif
 299 
 300 #if ENABLE(VIDEO_TRACK)
 301 #include &quot;CaptionUserPreferences.h&quot;
 302 #endif
 303 
 304 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 305 #include &quot;MediaPlaybackTargetClient.h&quot;
 306 #endif
 307 
 308 #if ENABLE(XSLT)
 309 #include &quot;XSLTProcessor.h&quot;
 310 #endif
 311 
 312 #if ENABLE(MEDIA_STREAM)
 313 #include &quot;MediaStream.h&quot;
 314 #include &quot;MediaStreamRegistry.h&quot;
 315 #endif
 316 
 317 #if ENABLE(WEBGL)
 318 #include &quot;WebGLRenderingContext.h&quot;
 319 #endif
 320 #if ENABLE(WEBGL2)
 321 #include &quot;WebGL2RenderingContext.h&quot;
 322 #endif
 323 #if ENABLE(WEBGPU)
 324 #include &quot;WebGPURenderingContext.h&quot;
 325 #endif
 326 #if ENABLE(WEBMETAL)
 327 #include &quot;WebMetalRenderingContext.h&quot;
 328 #endif
 329 
 330 namespace WebCore {
 331 
 332 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 333 
 334 using namespace HTMLNames;
 335 using namespace PAL;
 336 using namespace WTF::Unicode;
 337 
 338 static const unsigned cMaxWriteRecursionDepth = 21;
 339 bool Document::hasEverCreatedAnAXObjectCache = false;
 340 
 341 unsigned ScriptDisallowedScope::LayoutAssertionDisableScope::s_layoutAssertionDisableCount = 0;
 342 
 343 struct FrameFlatteningLayoutDisallower {
 344     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 345         : m_frameView(frameView)
 346         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 347     {
 348         if (m_disallowLayout)
 349             m_frameView.startDisallowingLayout();
 350     }
 351 
 352     ~FrameFlatteningLayoutDisallower()
 353     {
 354         if (m_disallowLayout)
 355             m_frameView.endDisallowingLayout();
 356     }
 357 
 358 private:
 359     FrameView&amp; m_frameView;
 360     bool m_disallowLayout { false };
 361 };
 362 
 363 // DOM Level 2 says (letters added):
 364 //
 365 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 366 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 367 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 368 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 369 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 370 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 371 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 372 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 373 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 374 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 375 //
 376 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 377 
 378 static inline bool isValidNameStart(UChar32 c)
 379 {
 380     // rule (e) above
 381     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 382         return true;
 383 
 384     // rule (i) above
 385     if (c == &#39;:&#39; || c == &#39;_&#39;)
 386         return true;
 387 
 388     // rules (a) and (f) above
 389     if (!(U_GET_GC_MASK(c) &amp; (U_GC_LL_MASK | U_GC_LU_MASK | U_GC_LO_MASK | U_GC_LT_MASK | U_GC_NL_MASK)))
 390         return false;
 391 
 392     // rule (c) above
 393     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 394         return false;
 395 
 396     // rule (d) above
 397 #if PLATFORM(JAVA) // todo tav old code not using icu
 398     DecompositionType decompType = decompositionType(c);
 399     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 400         return false;
 401 #else
 402     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 403     if (type == U_DT_FONT || type == U_DT_COMPAT)
 404         return false;
 405 #endif
 406 
 407     return true;
 408 }
 409 
 410 static inline bool isValidNamePart(UChar32 c)
 411 {
 412     // rules (a), (e), and (i) above
 413     if (isValidNameStart(c))
 414         return true;
 415 
 416     // rules (g) and (h) above
 417     if (c == 0x00B7 || c == 0x0387)
 418         return true;
 419 
 420     // rule (j) above
 421     if (c == &#39;-&#39; || c == &#39;.&#39;)
 422         return true;
 423 
 424     // rules (b) and (f) above
 425     if (!(U_GET_GC_MASK(c) &amp; (U_GC_M_MASK | U_GC_LM_MASK | U_GC_ND_MASK)))
 426         return false;
 427 
 428     // rule (c) above
 429     if (c &gt;= 0xF900 &amp;&amp; c &lt; 0xFFFE)
 430         return false;
 431 
 432     // rule (d) above
 433 #if PLATFORM(JAVA) // todo tav old code not using icu
 434     DecompositionType decompType = decompositionType(c);
 435     if (decompType == DecompositionFont || decompType == DecompositionCompat)
 436         return false;
 437 #else
 438     int type = u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE);
 439     if (type == U_DT_FONT || type == U_DT_COMPAT)
 440         return false;
 441 #endif
 442 
 443     return true;
 444 }
 445 
 446 static Widget* widgetForElement(Element* focusedElement)
 447 {
 448     if (!focusedElement)
 449         return nullptr;
 450     auto* renderer = focusedElement-&gt;renderer();
 451     if (!is&lt;RenderWidget&gt;(renderer))
 452         return nullptr;
 453     return downcast&lt;RenderWidget&gt;(*renderer).widget();
 454 }
 455 
 456 static bool acceptsEditingFocus(const Element&amp; element)
 457 {
 458     ASSERT(element.hasEditableStyle());
 459 
 460     auto* root = element.rootEditableElement();
 461     Frame* frame = element.document().frame();
 462     if (!frame || !root)
 463         return false;
 464 
 465     return frame-&gt;editor().shouldBeginEditing(rangeOfContents(*root).ptr());
 466 }
 467 
 468 static bool canAccessAncestor(const SecurityOrigin&amp; activeSecurityOrigin, Frame* targetFrame)
 469 {
 470     // targetFrame can be 0 when we&#39;re trying to navigate a top-level frame
 471     // that has a 0 opener.
 472     if (!targetFrame)
 473         return false;
 474 
 475     const bool isLocalActiveOrigin = activeSecurityOrigin.isLocal();
 476     for (Frame* ancestorFrame = targetFrame; ancestorFrame; ancestorFrame = ancestorFrame-&gt;tree().parent()) {
 477         Document* ancestorDocument = ancestorFrame-&gt;document();
 478         // FIXME: Should be an ASSERT? Frames should alway have documents.
 479         if (!ancestorDocument)
 480             return true;
 481 
 482         const SecurityOrigin&amp; ancestorSecurityOrigin = ancestorDocument-&gt;securityOrigin();
 483         if (activeSecurityOrigin.canAccess(ancestorSecurityOrigin))
 484             return true;
 485 
 486         // Allow file URL descendant navigation even when allowFileAccessFromFileURLs is false.
 487         // FIXME: It&#39;s a bit strange to special-case local origins here. Should we be doing
 488         // something more general instead?
 489         if (isLocalActiveOrigin &amp;&amp; ancestorSecurityOrigin.isLocal())
 490             return true;
 491     }
 492 
 493     return false;
 494 }
 495 
 496 static void printNavigationErrorMessage(Frame&amp; frame, const URL&amp; activeURL, const char* reason)
 497 {
 498     String message = &quot;Unsafe JavaScript attempt to initiate navigation for frame with URL &#39;&quot; + frame.document()-&gt;url().string() + &quot;&#39; from frame with URL &#39;&quot; + activeURL.string() + &quot;&#39;. &quot; + reason + &quot;\n&quot;;
 499 
 500     // FIXME: should we print to the console of the document performing the navigation instead?
 501     frame.document()-&gt;domWindow()-&gt;printErrorMessage(message);
 502 }
 503 
 504 uint64_t Document::s_globalTreeVersion = 0;
 505 
 506 auto Document::allDocumentsMap() -&gt; DocumentsMap&amp;
 507 {
 508     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 509     return documents;
 510 }
 511 
 512 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 513 {
 514     return allDocumentsMap().values();
 515 }
 516 
 517 static inline int currentOrientation(Frame* frame)
 518 {
 519 #if ENABLE(ORIENTATION_EVENTS)
 520     if (frame)
 521         return frame-&gt;orientation();
 522 #else
 523     UNUSED_PARAM(frame);
 524 #endif
 525     return 0;
 526 }
 527 
 528 Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)
 529     : ContainerNode(*this, CreateDocument)
 530     , TreeScope(*this)
 531     , FrameDestructionObserver(frame)
 532 #if ENABLE(IOS_TOUCH_EVENTS)
 533     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 534 #endif
 535     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 536     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 537     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 538     , m_domTreeVersion(++s_globalTreeVersion)
 539     , m_styleScope(std::make_unique&lt;Style::Scope&gt;(*this))
 540     , m_extensionStyleSheets(std::make_unique&lt;ExtensionStyleSheets&gt;(*this))
 541     , m_visitedLinkState(std::make_unique&lt;VisitedLinkState&gt;(*this))
 542     , m_markers(std::make_unique&lt;DocumentMarkerController&gt;(*this))
 543     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 544     , m_documentCreationTime(MonotonicTime::now())
 545     , m_scriptRunner(std::make_unique&lt;ScriptRunner&gt;(*this))
 546     , m_moduleLoader(std::make_unique&lt;ScriptModuleLoader&gt;(*this))
 547 #if ENABLE(XSLT)
 548     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 549 #endif
 550     , m_xmlVersion(&quot;1.0&quot;_s)
 551     , m_constantPropertyMap(std::make_unique&lt;ConstantPropertyMap&gt;(*this))
 552     , m_documentClasses(documentClasses)
 553     , m_eventQueue(*this)
 554 #if ENABLE(INTERSECTION_OBSERVER)
 555     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 556 #endif
 557     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 558 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
 559     , m_deviceMotionClient(std::make_unique&lt;DeviceMotionClientIOS&gt;())
 560     , m_deviceMotionController(std::make_unique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
 561     , m_deviceOrientationClient(std::make_unique&lt;DeviceOrientationClientIOS&gt;())
 562     , m_deviceOrientationController(std::make_unique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 563 #endif
 564     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 565     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 566     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 567     , m_fontSelector(CSSFontSelector::create(*this))
 568     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 569     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 570     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 571     , m_isSynthesized(constructionFlags &amp; Synthesized)
 572     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 573     , m_orientationNotifier(currentOrientation(frame))
 574     , m_identifier(DocumentIdentifier::generate())
 575     , m_undoManager(UndoManager::create(*this))
 576 {
 577     auto addResult = allDocumentsMap().add(m_identifier, this);
 578     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 579 
 580     // We depend on the url getting immediately set in subframes, but we
 581     // also depend on the url NOT getting immediately set in opened windows.
 582     // See fast/dom/early-frame-url.html
 583     // and fast/dom/location-new-window-no-crash.html, respectively.
 584     // FIXME: Can/should we unify this behavior?
 585     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 586         setURL(url);
 587 
 588     m_cachedResourceLoader-&gt;setDocument(this);
 589 
 590     resetLinkColor();
 591     resetVisitedLinkColor();
 592     resetActiveLinkColor();
 593 
 594     initSecurityContext();
 595     initDNSPrefetch();
 596 
 597     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 598 
 599     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 600         nodeListAndCollectionCount = 0;
 601 
 602     InspectorInstrumentation::addEventListenersToNode(*this);
 603 }
 604 
 605 #if ENABLE(FULLSCREEN_API)
 606 
 607 static bool isAttributeOnAllOwners(const WebCore::QualifiedName&amp; attribute, const WebCore::QualifiedName&amp; prefixedAttribute, const HTMLFrameOwnerElement* owner)
 608 {
 609     if (!owner)
 610         return true;
 611     do {
 612         if (!(owner-&gt;hasAttribute(attribute) || owner-&gt;hasAttribute(prefixedAttribute)))
 613             return false;
 614     } while ((owner = owner-&gt;document().ownerElement()));
 615     return true;
 616 }
 617 
 618 #endif
 619 
 620 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 621 {
 622     auto document = adoptRef(*new Document(nullptr, URL()));
 623     document-&gt;setContextDocument(contextDocument);
 624     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 625     return document;
 626 }
 627 
 628 Document::~Document()
 629 {
 630     if (m_logger)
 631         m_logger-&gt;removeObserver(*this);
 632 
 633     ASSERT(allDocumentsMap().contains(m_identifier));
 634     allDocumentsMap().remove(m_identifier);
 635     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 636     removeFromContextsMap();
 637 
 638     ASSERT(!renderView());
 639     ASSERT(m_pageCacheState != InPageCache);
 640     ASSERT(m_ranges.isEmpty());
 641     ASSERT(!m_parentTreeScope);
 642     ASSERT(!m_disabledFieldsetElementsCount);
 643     ASSERT(m_inDocumentShadowRoots.isEmpty());
 644 
 645 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 646     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 647     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 648 #endif
 649 
 650     if (m_templateDocument)
 651         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 652 
 653     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 654     if (m_domWindow)
 655         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 656 
 657     m_scriptRunner = nullptr;
 658     m_moduleLoader = nullptr;
 659 
 660     removeAllEventListeners();
 661 
 662     // Currently we believe that Document can never outlive the parser.
 663     // Although the Document may be replaced synchronously, DocumentParsers
 664     // generally keep at least one reference to an Element which would in turn
 665     // has a reference to the Document.  If you hit this ASSERT, then that
 666     // assumption is wrong.  DocumentParser::detach() should ensure that even
 667     // if the DocumentParser outlives the Document it won&#39;t cause badness.
 668     ASSERT(!m_parser || m_parser-&gt;refCount() == 1);
 669     detachParser();
 670 
 671     if (this == &amp;topDocument())
 672         clearAXObjectCache();
 673 
 674     m_decoder = nullptr;
 675 
 676     if (m_styleSheetList)
 677         m_styleSheetList-&gt;detach();
 678 
 679     extensionStyleSheets().detachFromDocument();
 680 
 681     styleScope().clearResolver(); // We need to destroy CSSFontSelector before destroying m_cachedResourceLoader.
 682     m_fontSelector-&gt;clearDocument();
 683     m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 684 
 685     // It&#39;s possible for multiple Documents to end up referencing the same CachedResourceLoader (e.g., SVGImages
 686     // load the initial empty document and the SVGDocument with the same DocumentLoader).
 687     if (m_cachedResourceLoader-&gt;document() == this)
 688         m_cachedResourceLoader-&gt;setDocument(nullptr);
 689 
 690 #if ENABLE(VIDEO)
 691     stopAllMediaPlayback();
 692 #endif
 693 
 694     // We must call clearRareData() here since a Document class inherits TreeScope
 695     // as well as Node. See a comment on TreeScope.h for the reason.
 696     if (hasRareData())
 697         clearRareData();
 698 
 699     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 700     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 701     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 702 
 703     for (unsigned count : m_nodeListAndCollectionCounts)
 704         ASSERT_UNUSED(count, !count);
 705 }
 706 
 707 void Document::removedLastRef()
 708 {
 709     ASSERT(!m_deletionHasBegun);
 710     if (m_referencingNodeCount) {
 711         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 712         // until after removeDetachedChildren returns, so we protect ourselves.
 713         incrementReferencingNodeCount();
 714 
 715         RELEASE_ASSERT(!hasLivingRenderTree());
 716         // We must make sure not to be retaining any of our children through
 717         // these extra pointers or we will create a reference cycle.
 718         m_focusedElement = nullptr;
 719         m_hoveredElement = nullptr;
 720         m_activeElement = nullptr;
 721         m_titleElement = nullptr;
 722         m_documentElement = nullptr;
 723         m_focusNavigationStartingNode = nullptr;
 724         m_userActionElements.clear();
 725 #if ENABLE(FULLSCREEN_API)
 726         m_fullScreenElement = nullptr;
 727         m_fullScreenElementStack.clear();
 728 #endif
 729         m_associatedFormControls.clear();
 730 
 731         m_fontSelector-&gt;clearDocument();
 732         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 733 
 734         detachParser();
 735 
 736         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 737         // so tear down scope information up front to avoid having
 738         // stale references in the map.
 739 
 740         destroyTreeScopeData();
 741         removeDetachedChildren();
 742         m_formController = nullptr;
 743 
 744         m_markers-&gt;detach();
 745 
 746         m_cssCanvasElements.clear();
 747 
 748         commonTeardown();
 749 
 750 #ifndef NDEBUG
 751         // We need to do this right now since selfOnlyDeref() can delete this.
 752         m_inRemovedLastRefFunction = false;
 753 #endif
 754         decrementReferencingNodeCount();
 755     } else {
 756 #ifndef NDEBUG
 757         m_inRemovedLastRefFunction = false;
 758         m_deletionHasBegun = true;
 759 #endif
 760         m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
 761         delete this;
 762     }
 763 }
 764 
 765 void Document::commonTeardown()
 766 {
 767     if (svgExtensions())
 768         accessSVGExtensions().pauseAnimations();
 769 
 770     clearScriptedAnimationController();
 771 }
 772 
 773 Element* Document::elementForAccessKey(const String&amp; key)
 774 {
 775     if (key.isEmpty())
 776         return nullptr;
 777     if (!m_accessKeyCache)
 778         buildAccessKeyCache();
 779     return m_accessKeyCache-&gt;get(key);
 780 }
 781 
 782 void Document::buildAccessKeyCache()
 783 {
 784     m_accessKeyCache = std::make_unique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 785         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 786         for (auto&amp; node : composedTreeDescendants(*this)) {
 787             if (!is&lt;Element&gt;(node))
 788                 continue;
 789             auto&amp; element = downcast&lt;Element&gt;(node);
 790             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 791             if (key.isEmpty())
 792                 continue;
 793             map.add(key, &amp;element);
 794     }
 795         return map;
 796     }());
 797 }
 798 
 799 void Document::invalidateAccessKeyCacheSlowCase()
 800 {
 801     m_accessKeyCache = nullptr;
 802 }
 803 
 804 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 805 {
 806     if (selectorString.isEmpty())
 807         return Exception { SyntaxError };
 808     if (!m_selectorQueryCache)
 809         m_selectorQueryCache = std::make_unique&lt;SelectorQueryCache&gt;();
 810     return m_selectorQueryCache-&gt;add(selectorString, *this);
 811 }
 812 
 813 void Document::clearSelectorQueryCache()
 814 {
 815     m_selectorQueryCache = nullptr;
 816 }
 817 
 818 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 819 {
 820     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 821     // the policy defined elsewhere.
 822     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 823         return;
 824 
 825     m_referrerPolicy = referrerPolicy;
 826 }
 827 
 828 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 829 {
 830     if (!m_mediaQueryMatcher)
 831         m_mediaQueryMatcher = MediaQueryMatcher::create(*this);
 832     return *m_mediaQueryMatcher;
 833 }
 834 
 835 void Document::setCompatibilityMode(DocumentCompatibilityMode mode)
 836 {
 837     if (m_compatibilityModeLocked || mode == m_compatibilityMode)
 838         return;
 839     bool wasInQuirksMode = inQuirksMode();
 840     m_compatibilityMode = mode;
 841 
 842     clearSelectorQueryCache();
 843 
 844     if (inQuirksMode() != wasInQuirksMode) {
 845         // All user stylesheets have to reparse using the different mode.
 846         extensionStyleSheets().clearPageUserSheet();
 847         extensionStyleSheets().invalidateInjectedStyleSheetCache();
 848     }
 849 }
 850 
 851 String Document::compatMode() const
 852 {
 853     return inQuirksMode() ? &quot;BackCompat&quot; : &quot;CSS1Compat&quot;;
 854 }
 855 
 856 void Document::resetLinkColor()
 857 {
 858     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 859 }
 860 
 861 void Document::resetVisitedLinkColor()
 862 {
 863     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 864 }
 865 
 866 void Document::resetActiveLinkColor()
 867 {
 868     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 869 }
 870 
 871 DOMImplementation&amp; Document::implementation()
 872 {
 873     if (!m_implementation)
 874         m_implementation = std::make_unique&lt;DOMImplementation&gt;(*this);
 875     return *m_implementation;
 876 }
 877 
 878 bool Document::hasManifest() const
 879 {
 880     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 881 }
 882 
 883 DocumentType* Document::doctype() const
 884 {
 885     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 886         if (is&lt;DocumentType&gt;(node))
 887             return downcast&lt;DocumentType&gt;(node);
 888     }
 889     return nullptr;
 890 }
 891 
 892 void Document::childrenChanged(const ChildChange&amp; change)
 893 {
 894     ContainerNode::childrenChanged(change);
 895 
 896     // FIXME: Chrome::didReceiveDocType() used to be called only when the doctype changed. We need to check the
 897     // impact of calling this systematically. If the overhead is negligible, we need to rename didReceiveDocType,
 898     // otherwise, we need to detect the doc type changes before updating the viewport.
 899     if (Page* page = this-&gt;page())
 900         page-&gt;chrome().didReceiveDocType(*frame());
 901 
 902     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 903     if (newDocumentElement == m_documentElement)
 904         return;
 905     m_documentElement = newDocumentElement;
 906     // The root style used for media query matching depends on the document element.
 907     styleScope().clearResolver();
 908 }
 909 
 910 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 911 {
 912     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 913         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 914         return HTMLUnknownElement::create(name, document);
 915 
 916     auto element = HTMLElement::create(name, document);
 917     element-&gt;setIsCustomElementUpgradeCandidate();
 918     return element;
 919 }
 920 
 921 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomicString&amp; localName)
 922 {
 923     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 924 }
 925 
 926 static inline bool isValidHTMLElementName(const AtomicString&amp; localName)
 927 {
 928     return Document::isValidName(localName);
 929 }
 930 
 931 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 932 {
 933     return Document::isValidName(name.localName());
 934 }
 935 
 936 template&lt;typename NameType&gt;
 937 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 938 {
 939     auto element = HTMLElementFactory::createKnownElement(name, document);
 940     if (LIKELY(element))
 941         return Ref&lt;Element&gt; { element.releaseNonNull() };
 942 
 943     if (auto* window = document.domWindow()) {
 944         auto* registry = window-&gt;customElementRegistry();
 945         if (UNLIKELY(registry)) {
 946             if (auto* elementInterface = registry-&gt;findInterface(name))
 947                 return elementInterface-&gt;constructElementWithFallback(document, name);
 948         }
 949     }
 950 
 951     if (UNLIKELY(!isValidHTMLElementName(name)))
 952         return Exception { InvalidCharacterError };
 953 
 954     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 955 }
 956 
 957 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomicString&amp; name)
 958 {
 959     if (isHTMLDocument())
 960         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 961 
 962     if (isXHTMLDocument())
 963         return createHTMLElementWithNameValidation(*this, name);
 964 
 965     if (!isValidName(name))
 966         return Exception { InvalidCharacterError };
 967 
 968     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
 969 }
 970 
 971 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
 972 {
 973     return DocumentFragment::create(document());
 974 }
 975 
 976 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
 977 {
 978     return Text::create(*this, data);
 979 }
 980 
 981 Ref&lt;Comment&gt; Document::createComment(const String&amp; data)
 982 {
 983     return Comment::create(*this, data);
 984 }
 985 
 986 ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; Document::createCDATASection(const String&amp; data)
 987 {
 988     if (isHTMLDocument())
 989         return Exception { NotSupportedError };
 990     return CDATASection::create(*this, data);
 991 }
 992 
 993 ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; Document::createProcessingInstruction(const String&amp; target, const String&amp; data)
 994 {
 995     if (!isValidName(target))
 996         return Exception { InvalidCharacterError };
 997 
 998     if (data.contains(&quot;?&gt;&quot;))
 999         return Exception { InvalidCharacterError };
1000 
1001     return ProcessingInstruction::create(*this, target, data);
1002 }
1003 
1004 Ref&lt;Text&gt; Document::createEditingTextNode(const String&amp; text)
1005 {
1006     return Text::createEditingText(*this, text);
1007 }
1008 
1009 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1010 {
1011     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1012     return propertySet-&gt;ensureCSSStyleDeclaration();
1013 }
1014 
1015 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1016 {
1017     switch (nodeToImport.nodeType()) {
1018     case DOCUMENT_FRAGMENT_NODE:
1019         if (nodeToImport.isShadowRoot())
1020             break;
1021         FALLTHROUGH;
1022     case ELEMENT_NODE:
1023     case TEXT_NODE:
1024     case CDATA_SECTION_NODE:
1025     case PROCESSING_INSTRUCTION_NODE:
1026     case COMMENT_NODE:
1027         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1028 
1029     case ATTRIBUTE_NODE:
1030         // FIXME: This will &quot;Attr::normalize&quot; child nodes of Attr.
1031         return Ref&lt;Node&gt; { Attr::create(*this, QualifiedName(nullAtom(), downcast&lt;Attr&gt;(nodeToImport).name(), nullAtom()), downcast&lt;Attr&gt;(nodeToImport).value()) };
1032 
1033     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1034     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1035         break;
1036     }
1037 
1038     return Exception { NotSupportedError };
1039 }
1040 
1041 
1042 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1043 {
1044     EventQueueScope scope;
1045 
1046     switch (source.nodeType()) {
1047     case DOCUMENT_NODE:
1048         return Exception { NotSupportedError };
1049     case ATTRIBUTE_NODE: {
1050         auto&amp; attr = downcast&lt;Attr&gt;(source);
1051         if (auto* element = attr.ownerElement()) {
1052             auto result = element-&gt;removeAttributeNode(attr);
1053             if (result.hasException())
1054                 return result.releaseException();
1055         }
1056         break;
1057     }
1058     default:
1059         if (source.isShadowRoot()) {
1060             // ShadowRoot cannot disconnect itself from the host node.
1061             return Exception { HierarchyRequestError };
1062         }
1063         if (is&lt;HTMLFrameOwnerElement&gt;(source)) {
1064             auto&amp; frameOwnerElement = downcast&lt;HTMLFrameOwnerElement&gt;(source);
1065             if (frame() &amp;&amp; frame()-&gt;tree().isDescendantOf(frameOwnerElement.contentFrame()))
1066                 return Exception { HierarchyRequestError };
1067         }
1068         auto result = source.remove();
1069         if (result.hasException())
1070             return result.releaseException();
1071         RELEASE_ASSERT(!source.isConnected());
1072         RELEASE_ASSERT(!source.parentNode());
1073     }
1074 
1075     source.setTreeScopeRecursively(*this);
1076 
1077     return Ref&lt;Node&gt; { source };
1078 }
1079 
1080 bool Document::hasValidNamespaceForElements(const QualifiedName&amp; qName)
1081 {
1082     // These checks are from DOM Core Level 2, createElementNS
1083     // http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-DocCrElNS
1084     if (!qName.prefix().isEmpty() &amp;&amp; qName.namespaceURI().isNull()) // createElementNS(null, &quot;html:div&quot;)
1085         return false;
1086     if (qName.prefix() == xmlAtom() &amp;&amp; qName.namespaceURI() != XMLNames::xmlNamespaceURI) // createElementNS(&quot;http://www.example.com&quot;, &quot;xml:lang&quot;)
1087         return false;
1088 
1089     // Required by DOM Level 3 Core and unspecified by DOM Level 2 Core:
1090     // http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-DocCrElNS
1091     // createElementNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;foo:bar&quot;), createElementNS(null, &quot;xmlns:bar&quot;), createElementNS(null, &quot;xmlns&quot;)
1092     if (qName.prefix() == xmlnsAtom() || (qName.prefix().isEmpty() &amp;&amp; qName.localName() == xmlnsAtom()))
1093         return qName.namespaceURI() == XMLNSNames::xmlnsNamespaceURI;
1094     return qName.namespaceURI() != XMLNSNames::xmlnsNamespaceURI;
1095 }
1096 
1097 bool Document::hasValidNamespaceForAttributes(const QualifiedName&amp; qName)
1098 {
1099     return hasValidNamespaceForElements(qName);
1100 }
1101 
1102 static Ref&lt;HTMLElement&gt; createFallbackHTMLElement(Document&amp; document, const QualifiedName&amp; name)
1103 {
1104     if (auto* window = document.domWindow()) {
1105         auto* registry = window-&gt;customElementRegistry();
1106         if (UNLIKELY(registry)) {
1107             if (auto* elementInterface = registry-&gt;findInterface(name)) {
1108                 auto element = HTMLElement::create(name, document);
1109                 element-&gt;enqueueToUpgrade(*elementInterface);
1110                 return element;
1111             }
1112         }
1113     }
1114     // FIXME: Should we also check the equality of prefix between the custom element and name?
1115     return createUpgradeCandidateElement(document, name);
1116 }
1117 
1118 // FIXME: This should really be in a possible ElementFactory class.
1119 Ref&lt;Element&gt; Document::createElement(const QualifiedName&amp; name, bool createdByParser)
1120 {
1121     RefPtr&lt;Element&gt; element;
1122 
1123     // FIXME: Use registered namespaces and look up in a hash to find the right factory.
1124     if (name.namespaceURI() == xhtmlNamespaceURI) {
1125         element = HTMLElementFactory::createKnownElement(name, *this, nullptr, createdByParser);
1126         if (UNLIKELY(!element))
1127             element = createFallbackHTMLElement(*this, name);
1128     } else if (name.namespaceURI() == SVGNames::svgNamespaceURI)
1129         element = SVGElementFactory::createElement(name, *this, createdByParser);
1130 #if ENABLE(MATHML)
1131     else if (name.namespaceURI() == MathMLNames::mathmlNamespaceURI)
1132         element = MathMLElementFactory::createElement(name, *this, createdByParser);
1133 #endif
1134 
1135     if (element)
1136         m_sawElementsInKnownNamespaces = true;
1137     else
1138         element = Element::create(name, document());
1139 
1140     // &lt;image&gt; uses imgTag so we need a special rule.
1141     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1142 
1143     return element.releaseNonNull();
1144 }
1145 
1146 // https://html.spec.whatwg.org/#valid-custom-element-name
1147 
1148 struct UnicodeCodePointRange {
1149     UChar32 minimum;
1150     UChar32 maximum;
1151 };
1152 
1153 #if !ASSERT_DISABLED
1154 
1155 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1156 {
1157     ASSERT(a.minimum &lt;= a.maximum);
1158     ASSERT(b.minimum &lt;= b.maximum);
1159     return a.maximum &lt; b.minimum;
1160 }
1161 
1162 #endif
1163 
1164 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1165 {
1166     ASSERT(a.minimum &lt;= a.maximum);
1167     return a.maximum &lt; b;
1168 }
1169 
1170 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1171 {
1172     ASSERT(b.minimum &lt;= b.maximum);
1173     return a &lt; b.minimum;
1174 }
1175 
1176 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1177 {
1178     static const UnicodeCodePointRange ranges[] = {
1179         { &#39;-&#39;, &#39;.&#39; },
1180         { &#39;0&#39;, &#39;9&#39; },
1181         { &#39;_&#39;, &#39;_&#39; },
1182         { &#39;a&#39;, &#39;z&#39; },
1183         { 0xB7, 0xB7 },
1184         { 0xC0, 0xD6 },
1185         { 0xD8, 0xF6 },
1186         { 0xF8, 0x37D },
1187         { 0x37F, 0x1FFF },
1188         { 0x200C, 0x200D },
1189         { 0x203F, 0x2040 },
1190         { 0x2070, 0x218F },
1191         { 0x2C00, 0x2FEF },
1192         { 0x3001, 0xD7FF },
1193         { 0xF900, 0xFDCF },
1194         { 0xFDF0, 0xFFFD },
1195         { 0x10000, 0xEFFFF },
1196     };
1197 
1198     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1199     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1200 }
1201 
1202 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomicString&amp; localName)
1203 {
1204     if (!isASCIILower(localName[0]))
1205         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1206 
1207     bool containsHyphen = false;
1208     for (auto character : StringView(localName).codePoints()) {
1209         if (isASCIIUpper(character))
1210             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1211         if (!isPotentialCustomElementNameCharacter(character))
1212             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1213         if (character == &#39;-&#39;)
1214             containsHyphen = true;
1215     }
1216 
1217     if (!containsHyphen)
1218         return CustomElementNameValidationStatus::ContainsNoHyphen;
1219 
1220 #if ENABLE(MATHML)
1221     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1222 #else
1223     static NeverDestroyed&lt;const AtomicString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomicString::ConstructFromLiteral);
1224 #endif
1225 
1226     if (localName == SVGNames::color_profileTag-&gt;localName()
1227         || localName == SVGNames::font_faceTag-&gt;localName()
1228         || localName == SVGNames::font_face_formatTag-&gt;localName()
1229         || localName == SVGNames::font_face_nameTag-&gt;localName()
1230         || localName == SVGNames::font_face_srcTag-&gt;localName()
1231         || localName == SVGNames::font_face_uriTag-&gt;localName()
1232         || localName == SVGNames::missing_glyphTag-&gt;localName()
1233         || localName == annotationXmlLocalName)
1234         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1235 
1236     return CustomElementNameValidationStatus::Valid;
1237 }
1238 
1239 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)
1240 {
1241     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1242     if (parseResult.hasException())
1243         return parseResult.releaseException();
1244     QualifiedName parsedName { parseResult.releaseReturnValue() };
1245     if (!hasValidNamespaceForElements(parsedName))
1246         return Exception { NamespaceError };
1247 
1248     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1249         return createHTMLElementWithNameValidation(*this, parsedName);
1250 
1251     return createElement(parsedName, false);
1252 }
1253 
1254 void Document::setReadyState(ReadyState readyState)
1255 {
1256     if (readyState == m_readyState)
1257         return;
1258 
1259     switch (readyState) {
1260     case Loading:
1261         if (!m_documentTiming.domLoading)
1262             m_documentTiming.domLoading = MonotonicTime::now();
1263         break;
1264     case Interactive:
1265         if (!m_documentTiming.domInteractive)
1266             m_documentTiming.domInteractive = MonotonicTime::now();
1267         break;
1268     case Complete:
1269         if (!m_documentTiming.domComplete)
1270             m_documentTiming.domComplete = MonotonicTime::now();
1271         break;
1272     }
1273 
1274     m_readyState = readyState;
1275     dispatchEvent(Event::create(eventNames().readystatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1276 
1277     if (settings().suppressesIncrementalRendering())
1278         setVisualUpdatesAllowed(readyState);
1279 }
1280 
1281 void Document::setVisualUpdatesAllowed(ReadyState readyState)
1282 {
1283     ASSERT(settings().suppressesIncrementalRendering());
1284     switch (readyState) {
1285     case Loading:
1286         ASSERT(!m_visualUpdatesSuppressionTimer.isActive());
1287         ASSERT(m_visualUpdatesAllowed);
1288         setVisualUpdatesAllowed(false);
1289         break;
1290     case Interactive:
1291         ASSERT(m_visualUpdatesSuppressionTimer.isActive() || m_visualUpdatesAllowed);
1292         break;
1293     case Complete:
1294         if (m_visualUpdatesSuppressionTimer.isActive()) {
1295             ASSERT(!m_visualUpdatesAllowed);
1296 
1297             if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1298                 return;
1299 
1300             setVisualUpdatesAllowed(true);
1301         } else
1302             ASSERT(m_visualUpdatesAllowed);
1303         break;
1304     }
1305 }
1306 
1307 void Document::setVisualUpdatesAllowed(bool visualUpdatesAllowed)
1308 {
1309     if (m_visualUpdatesAllowed == visualUpdatesAllowed)
1310         return;
1311 
1312     m_visualUpdatesAllowed = visualUpdatesAllowed;
1313 
1314     if (visualUpdatesAllowed)
1315         m_visualUpdatesSuppressionTimer.stop();
1316     else
1317         m_visualUpdatesSuppressionTimer.startOneShot(1_s * settings().incrementalRenderingSuppressionTimeoutInSeconds());
1318 
1319     if (!visualUpdatesAllowed)
1320         return;
1321 
1322     RefPtr&lt;FrameView&gt; frameView = view();
1323     bool needsLayout = frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout());
1324     if (needsLayout)
1325         updateLayout();
1326 
1327     if (Page* page = this-&gt;page()) {
1328         if (frame()-&gt;isMainFrame()) {
1329             frameView-&gt;addPaintPendingMilestones(DidFirstPaintAfterSuppressedIncrementalRendering);
1330             if (page-&gt;requestedLayoutMilestones() &amp; DidFirstLayoutAfterSuppressedIncrementalRendering)
1331                 frame()-&gt;loader().didReachLayoutMilestone(DidFirstLayoutAfterSuppressedIncrementalRendering);
1332         }
1333     }
1334 
1335     if (frameView)
1336         frameView-&gt;updateCompositingLayersAfterLayout();
1337 
1338     if (RenderView* renderView = this-&gt;renderView())
1339         renderView-&gt;repaintViewAndCompositedLayers();
1340 
1341     if (Frame* frame = this-&gt;frame())
1342         frame-&gt;loader().forcePageTransitionIfNeeded();
1343 }
1344 
1345 void Document::visualUpdatesSuppressionTimerFired()
1346 {
1347     ASSERT(!m_visualUpdatesAllowed);
1348 
1349     // If the client is extending the visual update suppression period explicitly, the
1350     // watchdog should not re-enable visual updates itself, but should wait for the client.
1351     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1352         return;
1353 
1354     setVisualUpdatesAllowed(true);
1355 }
1356 
1357 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1358 {
1359     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1360     // both of which we can determine by looking at the timer.
1361 
1362     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1363         setVisualUpdatesAllowed(true);
1364 }
1365 
1366 String Document::characterSetWithUTF8Fallback() const
1367 {
1368     AtomicString name = encoding();
1369     if (!name.isNull())
1370         return name;
1371     return UTF8Encoding().domName();
1372 }
1373 
1374 String Document::defaultCharsetForLegacyBindings() const
1375 {
1376     if (!frame())
1377         UTF8Encoding().domName();
1378     return settings().defaultTextEncodingName();
1379 }
1380 
1381 void Document::setCharset(const String&amp; charset)
1382 {
1383     if (!decoder())
1384         return;
1385     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1386 }
1387 
1388 void Document::setContentLanguage(const String&amp; language)
1389 {
1390     if (m_contentLanguage == language)
1391         return;
1392     m_contentLanguage = language;
1393 
1394     // Recalculate style so language is used when selecting the initial font.
1395     m_styleScope-&gt;didChangeStyleSheetEnvironment();
1396 }
1397 
1398 ExceptionOr&lt;void&gt; Document::setXMLVersion(const String&amp; version)
1399 {
1400     if (!XMLDocumentParser::supportsXMLVersion(version))
1401         return Exception { NotSupportedError };
1402 
1403     m_xmlVersion = version;
1404     return { };
1405 }
1406 
1407 void Document::setXMLStandalone(bool standalone)
1408 {
1409     m_xmlStandalone = standalone ? StandaloneStatus::Standalone : StandaloneStatus::NotStandalone;
1410 }
1411 
1412 void Document::setDocumentURI(const String&amp; uri)
1413 {
1414     // This property is read-only from JavaScript, but writable from Objective-C.
1415     m_documentURI = uri;
1416     updateBaseURL();
1417 }
1418 
1419 void Document::setContent(const String&amp; content)
1420 {
1421     open();
1422     // FIXME: This should probably use insert(), but that&#39;s (intentionally)
1423     // not implemented for the XML parser as it&#39;s normally synonymous with
1424     // document.write(). append() will end up yielding, but close() will
1425     // pump the tokenizer syncrhonously and finish the parse.
1426     m_parser-&gt;append(content.impl());
1427     close();
1428 }
1429 
1430 String Document::suggestedMIMEType() const
1431 {
1432     if (isXHTMLDocument())
1433         return &quot;application/xhtml+xml&quot;_s;
1434     if (isSVGDocument())
1435         return &quot;image/svg+xml&quot;_s;
1436     if (xmlStandalone())
1437         return &quot;text/xml&quot;_s;
1438     if (isHTMLDocument())
1439         return &quot;text/html&quot;_s;
1440     if (DocumentLoader* loader = this-&gt;loader())
1441         return loader-&gt;responseMIMEType();
1442     return String();
1443 }
1444 
1445 void Document::overrideMIMEType(const String&amp; mimeType)
1446 {
1447     m_overriddenMIMEType = mimeType;
1448 }
1449 
1450 String Document::contentType() const
1451 {
1452     if (!m_overriddenMIMEType.isNull())
1453         return m_overriddenMIMEType;
1454 
1455     if (DocumentLoader* documentLoader = loader())
1456         return documentLoader-&gt;currentContentType();
1457 
1458     String mimeType = suggestedMIMEType();
1459     if (!mimeType.isNull())
1460         return mimeType;
1461 
1462     return &quot;application/xml&quot;_s;
1463 }
1464 
1465 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(int x, int y)
1466 {
1467     return caretRangeFromPoint(LayoutPoint(x, y));
1468 }
1469 
1470 RefPtr&lt;Range&gt; Document::caretRangeFromPoint(const LayoutPoint&amp; clientPoint)
1471 {
1472     if (!hasLivingRenderTree())
1473         return nullptr;
1474 
1475     LayoutPoint localPoint;
1476     Node* node = nodeFromPoint(clientPoint, &amp;localPoint);
1477     if (!node)
1478         return nullptr;
1479 
1480     RenderObject* renderer = node-&gt;renderer();
1481     if (!renderer)
1482         return nullptr;
1483     Position rangeCompliantPosition = renderer-&gt;positionForPoint(localPoint).parentAnchoredEquivalent();
1484     if (rangeCompliantPosition.isNull())
1485         return nullptr;
1486 
1487     unsigned offset = rangeCompliantPosition.offsetInContainerNode();
1488     node = &amp;retargetToScope(*rangeCompliantPosition.containerNode());
1489     if (node != rangeCompliantPosition.containerNode())
1490         offset = 0;
1491 
1492     return Range::create(*this, node, offset, node, offset);
1493 }
1494 
1495 bool Document::isBodyPotentiallyScrollable(HTMLBodyElement&amp; body)
1496 {
1497     // See https://www.w3.org/TR/cssom-view-1/#potentially-scrollable.
1498     // An element is potentially scrollable if all of the following conditions are true:
1499     // - The element has an associated CSS layout box.
1500     // - The element is not the HTML body element, or it is and the root element&#39;s used value of the
1501     //   overflow-x or overflow-y properties is not visible.
1502     // - The element&#39;s used value of the overflow-x or overflow-y properties is not visible.
1503     //
1504     // FIXME: We should use RenderObject::hasOverflowClip() instead of Element::computedStyle() but
1505     // the used values are currently not correctly updated. See https://webkit.org/b/182292.
1506     return body.renderer()
1507         &amp;&amp; documentElement()-&gt;computedStyle()
1508         &amp;&amp; !documentElement()-&gt;computedStyle()-&gt;isOverflowVisible()
1509         &amp;&amp; body.computedStyle()
1510         &amp;&amp; !body.computedStyle()-&gt;isOverflowVisible();
1511 }
1512 
1513 Element* Document::scrollingElementForAPI()
1514 {
1515     if (inQuirksMode() &amp;&amp; settings().CSSOMViewScrollingAPIEnabled())
1516         updateLayoutIgnorePendingStylesheets();
1517     return scrollingElement();
1518 }
1519 
1520 Element* Document::scrollingElement()
1521 {
1522     if (settings().CSSOMViewScrollingAPIEnabled()) {
1523         // See https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement.
1524         // The scrollingElement attribute, on getting, must run these steps:
1525         // 1. If the Document is in quirks mode, follow these substeps:
1526         if (inQuirksMode()) {
1527             auto* firstBody = body();
1528             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1529             // HTML body element and abort these steps.
1530             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1531                 return firstBody;
1532 
1533             // 2. Return null and abort these steps.
1534             return nullptr;
1535         }
1536 
1537         // 2. If there is a root element, return the root element and abort these steps.
1538         // 3. Return null.
1539         return documentElement();
1540     }
1541 
1542     return body();
1543 }
1544 
1545 template&lt;typename CharacterType&gt; static inline String canonicalizedTitle(Document&amp; document, const String&amp; title)
1546 {
1547     // FIXME: Compiling a separate copy of this for LChar and UChar is likely unnecessary.
1548     // FIXME: Missing an optimized case for when title is fine as-is. This unnecessarily allocates
1549     // and keeps around a new copy, and it&#39;s even the less optimal type of StringImpl with a separate buffer.
1550     // Could probably just use StringBuilder instead.
1551 
1552     auto* characters = title.characters&lt;CharacterType&gt;();
1553     unsigned length = title.length();
1554 
1555     StringBuffer&lt;CharacterType&gt; buffer { length };
1556     unsigned bufferLength = 0;
1557 
1558     auto* decoder = document.decoder();
1559     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1560 
1561     // Collapse runs of HTML spaces into single space characters.
1562     // Strip leading and trailing spaces.
1563     // Replace backslashes with currency symbols.
1564     bool previousCharacterWasHTMLSpace = false;
1565     for (unsigned i = 0; i &lt; length; ++i) {
1566         auto character = characters[i];
1567         if (isHTMLSpace(character))
1568             previousCharacterWasHTMLSpace = true;
1569         else {
1570             if (character == &#39;\\&#39;)
1571                 character = backslashAsCurrencySymbol;
1572             if (previousCharacterWasHTMLSpace &amp;&amp; bufferLength)
1573                 buffer[bufferLength++] = &#39; &#39;;
1574             buffer[bufferLength++] = character;
1575             previousCharacterWasHTMLSpace = false;
1576         }
1577     }
1578     if (!bufferLength)
1579         return { };
1580 
1581     buffer.shrink(bufferLength);
1582     return String::adopt(WTFMove(buffer));
1583 }
1584 
1585 void Document::updateTitle(const StringWithDirection&amp; title)
1586 {
1587     if (m_rawTitle == title)
1588         return;
1589 
1590     m_rawTitle = title;
1591     m_title = title;
1592 
1593     if (!m_title.string.isEmpty()) {
1594         if (m_title.string.is8Bit())
1595             m_title.string = canonicalizedTitle&lt;LChar&gt;(*this, m_title.string);
1596         else
1597             m_title.string = canonicalizedTitle&lt;UChar&gt;(*this, m_title.string);
1598     }
1599 
1600     if (auto* loader = this-&gt;loader())
1601         loader-&gt;setTitle(m_title);
1602 }
1603 
1604 void Document::updateTitleFromTitleElement()
1605 {
1606     if (!m_titleElement) {
1607         updateTitle({ });
1608         return;
1609     }
1610 
1611     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1612         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1613     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1614         // FIXME: Does the SVG title element have a text direction?
1615         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1616     }
1617 }
1618 
1619 void Document::setTitle(const String&amp; title)
1620 {
1621     auto* element = documentElement();
1622     if (is&lt;SVGSVGElement&gt;(element)) {
1623         if (!m_titleElement) {
1624             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1625             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1626         }
1627         m_titleElement-&gt;setTextContent(title);
1628     } else if (is&lt;HTMLElement&gt;(element)) {
1629         if (!m_titleElement) {
1630             auto* headElement = head();
1631             if (!headElement)
1632                 return;
1633             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1634             headElement-&gt;appendChild(*m_titleElement);
1635         }
1636         m_titleElement-&gt;setTextContent(title);
1637     }
1638 }
1639 
1640 template&lt;typename&gt; struct TitleTraits;
1641 
1642 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1643     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1644     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1645 };
1646 
1647 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1648     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1649     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1650 };
1651 
1652 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1653 {
1654     using Traits = TitleTraits&lt;TitleElement&gt;;
1655 
1656     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
1657         ASSERT(oldTitleElement == Traits::findTitleElement(document));
1658         return oldTitleElement;
1659     }
1660 
1661     if (oldTitleElement)
1662         return Traits::findTitleElement(document);
1663 
1664     // Optimized common case: We have no title element yet.
1665     // We can figure out which title element should be used without searching.
1666     bool isEligible = Traits::isInEligibleLocation(downcast&lt;TitleElement&gt;(changingTitleElement));
1667     auto* newTitleElement = isEligible ? &amp;changingTitleElement : nullptr;
1668     ASSERT(newTitleElement == Traits::findTitleElement(document));
1669     return newTitleElement;
1670 }
1671 
1672 void Document::updateTitleElement(Element&amp; changingTitleElement)
1673 {
1674     // Most documents use HTML title rules.
1675     // Documents with SVG document elements use SVG title rules.
1676     auto selectTitleElement = is&lt;SVGSVGElement&gt;(documentElement())
1677         ? selectNewTitleElement&lt;SVGTitleElement&gt; : selectNewTitleElement&lt;HTMLTitleElement&gt;;
1678     auto newTitleElement = selectTitleElement(*this, m_titleElement.get(), changingTitleElement);
1679     if (m_titleElement == newTitleElement)
1680         return;
1681     m_titleElement = newTitleElement;
1682     updateTitleFromTitleElement();
1683 }
1684 
1685 void Document::titleElementAdded(Element&amp; titleElement)
1686 {
1687     if (m_titleElement == &amp;titleElement)
1688         return;
1689 
1690     updateTitleElement(titleElement);
1691 }
1692 
1693 void Document::titleElementRemoved(Element&amp; titleElement)
1694 {
1695     if (m_titleElement != &amp;titleElement)
1696         return;
1697 
1698     updateTitleElement(titleElement);
1699 }
1700 
1701 void Document::titleElementTextChanged(Element&amp; titleElement)
1702 {
1703     if (m_titleElement != &amp;titleElement)
1704         return;
1705 
1706     updateTitleFromTitleElement();
1707 }
1708 
1709 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1710 {
1711     m_visibilityStateCallbackClients.add(&amp;client);
1712 }
1713 
1714 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1715 {
1716     m_visibilityStateCallbackClients.remove(&amp;client);
1717 }
1718 
1719 void Document::visibilityStateChanged()
1720 {
1721     enqueueDocumentEvent(Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
1722     for (auto* client : m_visibilityStateCallbackClients)
1723         client-&gt;visibilityStateChanged();
1724 
1725     notifyMediaCaptureOfVisibilityChanged();
1726 }
1727 
1728 VisibilityState Document::visibilityState() const
1729 {
1730     // The visibility of the document is inherited from the visibility of the
1731     // page. If there is no page associated with the document, we will assume
1732     // that the page is hidden, as specified by the spec:
1733     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1734     if (!m_frame || !m_frame-&gt;page())
1735         return VisibilityState::Hidden;
1736     return m_frame-&gt;page()-&gt;visibilityState();
1737 }
1738 
1739 bool Document::hidden() const
1740 {
1741     return visibilityState() != VisibilityState::Visible;
1742 }
1743 
1744 #if ENABLE(VIDEO)
1745 
1746 void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1747 {
1748     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);
1749 }
1750 
1751 void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1752 {
1753     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);
1754 }
1755 
1756 void Document::allowsMediaDocumentInlinePlaybackChanged()
1757 {
1758     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)
1759         element-&gt;allowsMediaDocumentInlinePlaybackChanged();
1760 }
1761 
1762 void Document::stopAllMediaPlayback()
1763 {
1764     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1765         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(this);
1766 }
1767 
1768 void Document::suspendAllMediaPlayback()
1769 {
1770     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1771         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1772 }
1773 
1774 void Document::resumeAllMediaPlayback()
1775 {
1776     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1777         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1778 }
1779 #endif
1780 
1781 String Document::nodeName() const
1782 {
1783     return &quot;#document&quot;_s;
1784 }
1785 
1786 Node::NodeType Document::nodeType() const
1787 {
1788     return DOCUMENT_NODE;
1789 }
1790 
1791 FormController&amp; Document::formController()
1792 {
1793     if (!m_formController)
1794         m_formController = std::make_unique&lt;FormController&gt;();
1795     return *m_formController;
1796 }
1797 
1798 Vector&lt;String&gt; Document::formElementsState() const
1799 {
1800     if (!m_formController)
1801         return Vector&lt;String&gt;();
1802     return m_formController-&gt;formElementsState();
1803 }
1804 
1805 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1806 {
1807     if (!stateVector.size() &amp;&amp; !m_formController)
1808         return;
1809     formController().setStateForNewFormElements(stateVector);
1810 }
1811 
1812 FrameView* Document::view() const
1813 {
1814     return m_frame ? m_frame-&gt;view() : nullptr;
1815 }
1816 
1817 Page* Document::page() const
1818 {
1819     return m_frame ? m_frame-&gt;page() : nullptr;
1820 }
1821 
1822 Ref&lt;Range&gt; Document::createRange()
1823 {
1824     return Range::create(*this);
1825 }
1826 
1827 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1828 {
1829     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1830 }
1831 
1832 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1833 {
1834     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1835 }
1836 
1837 void Document::scheduleFullStyleRebuild()
1838 {
1839     m_needsFullStyleRebuild = true;
1840     scheduleStyleRecalc();
1841 }
1842 
1843 void Document::scheduleStyleRecalc()
1844 {
1845     ASSERT(!m_renderView || !inHitTesting());
1846 
1847     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)
1848         return;
1849 
1850     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1851 
1852 #if PLATFORM(IOS_FAMILY)
1853     if (WKIsObservingStyleRecalcScheduling()) {
1854         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: register this style recalc schedule and observe when it fires.&quot;);
1855         WKSetObservedContentChange(WKContentIndeterminateChange);
1856     }
1857 #endif
1858 
1859     auto shouldThrottleStyleRecalc = [&amp;] {
1860         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1861             return false;
1862         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1863             return false;
1864         return true;
1865     };
1866 
1867     if (shouldThrottleStyleRecalc())
1868         return;
1869 
1870     m_styleRecalcTimer.startOneShot(0_s);
1871 
1872     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1873 }
1874 
1875 void Document::unscheduleStyleRecalc()
1876 {
1877     ASSERT(!childNeedsStyleRecalc());
1878 
1879     m_styleRecalcTimer.stop();
1880     m_needsFullStyleRebuild = false;
1881 }
1882 
1883 bool Document::hasPendingStyleRecalc() const
1884 {
1885     return needsStyleRecalc() &amp;&amp; !m_inStyleRecalc;
1886 }
1887 
1888 bool Document::hasPendingFullStyleRebuild() const
1889 {
1890     return hasPendingStyleRecalc() &amp;&amp; m_needsFullStyleRebuild;
1891 }
1892 
1893 void Document::resolveStyle(ResolveStyleType type)
1894 {
1895     ASSERT(!view() || !view()-&gt;isPainting());
1896 
1897     // NOTE: XSL code seems to be the only client stumbling in here without a RenderView.
1898     if (!m_renderView)
1899         return;
1900 
1901     FrameView&amp; frameView = m_renderView-&gt;frameView();
1902     Ref&lt;FrameView&gt; protect(frameView);
1903     if (frameView.isPainting())
1904         return;
1905 
1906     if (m_inStyleRecalc)
1907         return; // Guard against re-entrancy. -dwh
1908 
1909     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1910 
1911     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1912     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1913 
1914     // FIXME: Do this update per tree scope.
1915     {
1916         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1917         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1918         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1919         for (auto&amp; element : elements)
1920             element-&gt;updateShadowTree();
1921     }
1922 
1923     // FIXME: We should update style on our ancestor chain before proceeding (especially for seamless),
1924     // however doing so currently causes several tests to crash, as Frame::setDocument calls Document::attach
1925     // before setting the DOMWindow on the Frame, or the SecurityOrigin on the document. The attach, in turn
1926     // resolves style (here) and then when we resolve style on the parent chain, we may end up
1927     // re-attaching our containing iframe, which when asked HTMLFrameElementBase::isURLAllowed
1928     // hits a null-dereference due to security code always assuming the document has a SecurityOrigin.
1929 
1930     {
1931         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1932         styleScope().flushPendingUpdate();
1933         frameView.willRecalcStyle();
1934     }
1935 
1936     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);
1937 
1938     bool updatedCompositingLayers = false;
1939     {
1940         Style::PostResolutionCallbackDisabler disabler(*this);
1941         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1942         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1943 
1944         m_inStyleRecalc = true;
1945 
1946         if (m_needsFullStyleRebuild)
1947             type = ResolveStyleType::Rebuild;
1948 
1949         if (type == ResolveStyleType::Rebuild) {
1950             // This may get set again during style resolve.
1951             m_hasNodesWithNonFinalStyle = false;
1952             m_hasNodesWithMissingStyle = false;
1953 
1954             auto documentStyle = Style::resolveForDocument(*this);
1955 
1956             // Inserting the pictograph font at the end of the font fallback list is done by the
1957             // font selector, so set a font selector if needed.
1958             if (settings().fontFallbackPrefersPictographs())
1959                 documentStyle.fontCascade().update(&amp;fontSelector());
1960 
1961             auto documentChange = Style::determineChange(documentStyle, m_renderView-&gt;style());
1962             if (documentChange != Style::NoChange)
1963                 renderView()-&gt;setStyle(WTFMove(documentStyle));
1964 
1965             if (auto* documentElement = this-&gt;documentElement())
1966                 documentElement-&gt;invalidateStyleForSubtree();
1967         }
1968 
1969         Style::TreeResolver resolver(*this);
1970         auto styleUpdate = resolver.resolve();
1971 
1972         m_lastStyleUpdateSizeForTesting = styleUpdate ? styleUpdate-&gt;size() : 0;
1973 
1974         setHasValidStyle();
1975         clearChildNeedsStyleRecalc();
1976         unscheduleStyleRecalc();
1977 
1978         m_inStyleRecalc = false;
1979 
1980         if (styleUpdate) {
1981             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
1982 
1983             RenderTreeUpdater updater(*this);
1984             updater.commit(WTFMove(styleUpdate));
1985 
1986             frameView.styleDidChange();
1987         }
1988 
1989         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
1990 
1991         if (m_renderView-&gt;needsLayout())
1992             frameView.layoutContext().scheduleLayout();
1993 
1994         // Usually this is handled by post-layout.
1995         if (!frameView.needsLayout()) {
1996             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
1997             if (m_needsForcedIntersectionObservationUpdate)
1998                 page()-&gt;scheduleForcedIntersectionObservationUpdate(*this);
1999         }
2000 
2001         // As a result of the style recalculation, the currently hovered element might have been
2002         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
2003         // to check if any other elements ended up under the mouse pointer due to re-layout.
2004         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
2005             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
2006 
2007         ++m_styleRecalcCount;
2008         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
2009     }
2010 
2011     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.
2012     if (m_closeAfterStyleRecalc) {
2013         m_closeAfterStyleRecalc = false;
2014         implicitClose();
2015     }
2016 
2017     InspectorInstrumentation::didRecalculateStyle(cookie);
2018 
2019     // Some animated images may now be inside the viewport due to style recalc,
2020     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2021     // check if they need to be resumed after layout.
2022     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2023         frameView.viewportContentsChanged();
2024 
2025     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2026         frameView.scrollToFragment(m_url);
2027 }
2028 
2029 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2030 {
2031     ASSERT(!m_inRenderTreeUpdate);
2032     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2033 
2034     auto textUpdate = std::make_unique&lt;Style::Update&gt;(*this);
2035     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2036 
2037     RenderTreeUpdater renderTreeUpdater(*this);
2038     renderTreeUpdater.commit(WTFMove(textUpdate));
2039 }
2040 
2041 bool Document::needsStyleRecalc() const
2042 {
2043     if (pageCacheState() != NotInPageCache)
2044         return false;
2045 
2046     if (m_needsFullStyleRebuild)
2047         return true;
2048 
2049     if (childNeedsStyleRecalc())
2050         return true;
2051 
2052     if (styleScope().hasPendingUpdate())
2053         return true;
2054 
2055     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.
2056     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2057         return true;
2058 
2059     return false;
2060 }
2061 
2062 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2063 {
2064     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2065     auto* frameView = document.view();
2066     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2067     bool isAssertionDisabled = ScriptDisallowedScope::LayoutAssertionDisableScope::shouldDisable();
2068     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess() || isAssertionDisabled;
2069 }
2070 
2071 bool Document::updateStyleIfNeeded()
2072 {
2073     RefPtr&lt;FrameView&gt; frameView = view();
2074     {
2075         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2076         ASSERT(isMainThread());
2077         ASSERT(!frameView || !frameView-&gt;isPainting());
2078 
2079         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2080             return false;
2081 
2082         styleScope().flushPendingUpdate();
2083 
2084         if (!needsStyleRecalc())
2085             return false;
2086     }
2087 
2088 #if PLATFORM(IOS_FAMILY)
2089     auto observingContentChange = WKShouldObserveNextStyleRecalc();
2090     if (observingContentChange) {
2091         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: start observing content change.&quot;);
2092         WKSetShouldObserveNextStyleRecalc(false);
2093         WKStartObservingContentChanges();
2094     }
2095 #endif
2096     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2097     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2098 
2099     resolveStyle();
2100 
2101 #if PLATFORM(IOS_FAMILY)
2102     if (observingContentChange) {
2103         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: stop observing content change.&quot;);
2104         WKStopObservingContentChanges();
2105 
2106         auto inDeterminedState = WKObservedContentChange() == WKContentVisibilityChange || !WebThreadCountOfObservedDOMTimers();
2107         if (inDeterminedState) {
2108             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: notify the pending synthetic click handler.&quot;);
2109             if (auto* page = this-&gt;page())
2110                 page-&gt;chrome().client().observedContentChange(*frame());
2111         } else {
2112             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: can&#39;t decided it yet.&quot;);
2113         }
2114     }
2115 #endif
2116     return true;
2117 }
2118 
2119 void Document::updateLayout()
2120 {
2121     ASSERT(isMainThread());
2122 
2123     RefPtr&lt;FrameView&gt; frameView = view();
2124     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2125         // View layout should not be re-entrant.
2126         ASSERT_NOT_REACHED();
2127         return;
2128     }
2129     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2130 
2131     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2132 
2133     if (HTMLFrameOwnerElement* owner = ownerElement())
2134         owner-&gt;document().updateLayout();
2135 
2136     updateStyleIfNeeded();
2137 
2138     StackStats::LayoutCheckPoint layoutCheckPoint;
2139 
2140     // Only do a layout if changes have occurred that make it necessary.
2141     if (frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2142         frameView-&gt;layoutContext().layout();
2143 }
2144 
2145 void Document::updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks runPostLayoutTasks)
2146 {
2147     bool oldIgnore = m_ignorePendingStylesheets;
2148 
2149     if (!haveStylesheetsLoaded()) {
2150         m_ignorePendingStylesheets = true;
2151         // FIXME: This should just invalidate elements with missing styles.
2152         if (m_hasNodesWithMissingStyle)
2153             scheduleFullStyleRebuild();
2154     }
2155 
2156     updateLayout();
2157 
2158     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2159         view()-&gt;flushAnyPendingPostLayoutTasks();
2160 
2161     m_ignorePendingStylesheets = oldIgnore;
2162 }
2163 
2164 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2165 {
2166     ASSERT(&amp;element.document() == this);
2167     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2168     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2169 
2170     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2171     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2172 
2173     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2174     auto&amp; resolver = element.styleResolver();
2175 
2176     if (pseudoElementSpecifier != PseudoId::None)
2177         return resolver.pseudoStyleForElement(element, PseudoStyleRequest(pseudoElementSpecifier), *parentStyle);
2178 
2179     auto elementStyle = resolver.styleForElement(element, parentStyle);
2180     if (elementStyle.relations) {
2181         Style::Update emptyUpdate(*this);
2182         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2183     }
2184 
2185     return WTFMove(elementStyle.renderStyle);
2186 }
2187 
2188 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2189 {
2190     ASSERT(isMainThread());
2191 
2192     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2193     if (!haveStylesheetsLoaded()) {
2194         updateLayoutIgnorePendingStylesheets();
2195         return true;
2196     }
2197 
2198     // Check for re-entrancy and assert (same code that is in updateLayout()).
2199     RefPtr&lt;FrameView&gt; frameView = view();
2200     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2201         // View layout should not be re-entrant.
2202         ASSERT_NOT_REACHED();
2203         return true;
2204     }
2205 
2206     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2207 
2208     // Mimic the structure of updateLayout(), but at each step, see if we have been forced into doing a full
2209     // layout.
2210     bool requireFullLayout = false;
2211     if (HTMLFrameOwnerElement* owner = ownerElement()) {
2212         if (owner-&gt;document().updateLayoutIfDimensionsOutOfDate(*owner))
2213             requireFullLayout = true;
2214     }
2215 
2216     updateStyleIfNeeded();
2217 
2218     RenderObject* renderer = element.renderer();
2219     if (!renderer || renderer-&gt;needsLayout()) {
2220         // If we don&#39;t have a renderer or if the renderer needs layout for any reason, give up.
2221         requireFullLayout = true;
2222     }
2223 
2224     // Turn off this optimization for input elements with shadow content.
2225     if (is&lt;HTMLInputElement&gt;(element))
2226         requireFullLayout = true;
2227 
2228     bool isVertical = renderer &amp;&amp; !renderer-&gt;isHorizontalWritingMode();
2229     bool checkingLogicalWidth = ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; isVertical);
2230     bool checkingLogicalHeight = ((dimensionsCheck &amp; HeightDimensionsCheck) &amp;&amp; !isVertical) || ((dimensionsCheck &amp; WidthDimensionsCheck) &amp;&amp; isVertical);
2231     bool hasSpecifiedLogicalHeight = renderer &amp;&amp; renderer-&gt;style().logicalMinHeight() == Length(0, Fixed) &amp;&amp; renderer-&gt;style().logicalHeight().isFixed() &amp;&amp; renderer-&gt;style().logicalMaxHeight().isAuto();
2232 
2233     if (!requireFullLayout) {
2234         RenderBox* previousBox = nullptr;
2235         RenderBox* currentBox = nullptr;
2236 
2237         // Check our containing block chain. If anything in the chain needs a layout, then require a full layout.
2238         for (RenderObject* currRenderer = element.renderer(); currRenderer &amp;&amp; !currRenderer-&gt;isRenderView(); currRenderer = currRenderer-&gt;container()) {
2239 
2240             // Require the entire container chain to be boxes.
2241             if (!is&lt;RenderBox&gt;(currRenderer)) {
2242                 requireFullLayout = true;
2243                 break;
2244             }
2245 
2246             previousBox = currentBox;
2247             currentBox = downcast&lt;RenderBox&gt;(currRenderer);
2248 
2249             // If a box needs layout for itself or if a box has changed children and sizes its width to
2250             // its content, then require a full layout.
2251             if (currentBox-&gt;selfNeedsLayout() ||
2252                 (checkingLogicalWidth &amp;&amp; currRenderer-&gt;needsLayout() &amp;&amp; currentBox-&gt;sizesLogicalWidthToFitContent(MainOrPreferredSize))) {
2253                 requireFullLayout = true;
2254                 break;
2255             }
2256 
2257             // If a block contains floats and the child&#39;s height isn&#39;t specified, then
2258             // give up also, since our height could end up being influenced by the floats.
2259             if (checkingLogicalHeight &amp;&amp; !hasSpecifiedLogicalHeight &amp;&amp; currentBox-&gt;isRenderBlockFlow()) {
2260                 RenderBlockFlow* currentBlockFlow = downcast&lt;RenderBlockFlow&gt;(currentBox);
2261                 if (currentBlockFlow-&gt;containsFloats() &amp;&amp; previousBox &amp;&amp; !previousBox-&gt;isFloatingOrOutOfFlowPositioned()) {
2262                     requireFullLayout = true;
2263                     break;
2264                 }
2265             }
2266 
2267             if (!currentBox-&gt;isRenderBlockFlow() || currentBox-&gt;enclosingFragmentedFlow() || currentBox-&gt;isWritingModeRoot()) {
2268                 // FIXME: For now require only block flows all the way back to the root. This limits the optimization
2269                 // for now, and we&#39;ll expand it in future patches to apply to more and more scenarios.
2270                 // Disallow columns from having the optimization.
2271                 // Give up if the writing mode changes at all in the containing block chain.
2272                 requireFullLayout = true;
2273                 break;
2274             }
2275 
2276             if (currRenderer == frameView-&gt;layoutContext().subtreeLayoutRoot())
2277                 break;
2278         }
2279     }
2280 
2281     StackStats::LayoutCheckPoint layoutCheckPoint;
2282 
2283     // Only do a layout if changes have occurred that make it necessary.
2284     if (requireFullLayout &amp;&amp; frameView &amp;&amp; renderView() &amp;&amp; (frameView-&gt;layoutContext().isLayoutPending() || renderView()-&gt;needsLayout()))
2285         frameView-&gt;layoutContext().layout();
2286 
2287     return requireFullLayout;
2288 }
2289 
2290 bool Document::isPageBoxVisible(int pageIndex)
2291 {
2292     updateStyleIfNeeded();
2293     std::unique_ptr&lt;RenderStyle&gt; pageStyle(styleScope().resolver().styleForPage(pageIndex));
2294     return pageStyle-&gt;visibility() != Visibility::Hidden; // display property doesn&#39;t apply to @page.
2295 }
2296 
2297 void Document::pageSizeAndMarginsInPixels(int pageIndex, IntSize&amp; pageSize, int&amp; marginTop, int&amp; marginRight, int&amp; marginBottom, int&amp; marginLeft)
2298 {
2299     updateStyleIfNeeded();
2300     auto style = styleScope().resolver().styleForPage(pageIndex);
2301 
2302     int width = pageSize.width();
2303     int height = pageSize.height();
2304     switch (style-&gt;pageSizeType()) {
2305     case PAGE_SIZE_AUTO:
2306         break;
2307     case PAGE_SIZE_AUTO_LANDSCAPE:
2308         if (width &lt; height)
2309             std::swap(width, height);
2310         break;
2311     case PAGE_SIZE_AUTO_PORTRAIT:
2312         if (width &gt; height)
2313             std::swap(width, height);
2314         break;
2315     case PAGE_SIZE_RESOLVED: {
2316         auto&amp; size = style-&gt;pageSize();
2317         ASSERT(size.width.isFixed());
2318         ASSERT(size.height.isFixed());
2319         width = valueForLength(size.width, 0);
2320         height = valueForLength(size.height, 0);
2321         break;
2322     }
2323     default:
2324         ASSERT_NOT_REACHED();
2325     }
2326     pageSize = IntSize(width, height);
2327 
2328     // The percentage is calculated with respect to the width even for margin top and bottom.
2329     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2330     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2331     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2332     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2333     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2334 }
2335 
2336 StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
2337 {
2338     if (!m_userAgentShadowTreeStyleResolver)
2339         m_userAgentShadowTreeStyleResolver = std::make_unique&lt;StyleResolver&gt;(*this);
2340     return *m_userAgentShadowTreeStyleResolver;
2341 }
2342 
2343 void Document::fontsNeedUpdate(FontSelector&amp;)
2344 {
2345     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2346 }
2347 
2348 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2349 {
2350     if (auto* resolver = styleScope().resolverIfExists())
2351         resolver-&gt;invalidateMatchedPropertiesCache();
2352     if (pageCacheState() != NotInPageCache || !renderView())
2353         return;
2354     scheduleFullStyleRebuild();
2355 }
2356 
2357 void Document::didClearStyleResolver()
2358 {
2359     m_userAgentShadowTreeStyleResolver = nullptr;
2360 }
2361 
2362 void Document::setIsResolvingTreeStyle(bool value)
2363 {
2364     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2365     m_isResolvingTreeStyle = value;
2366 }
2367 
2368 void Document::createRenderTree()
2369 {
2370     ASSERT(!renderView());
2371     ASSERT(m_pageCacheState != InPageCache);
2372     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2373 
2374     if (m_isNonRenderedPlaceholder)
2375         return;
2376 
2377     // FIXME: It would be better if we could pass the resolved document style directly here.
2378     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2379     Node::setRenderer(m_renderView.get());
2380 
2381     renderView()-&gt;setIsInWindow(true);
2382 
2383     resolveStyle(ResolveStyleType::Rebuild);
2384 }
2385 
2386 void Document::didBecomeCurrentDocumentInFrame()
2387 {
2388     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2389     // If so, then m_frame could become 0, and we need to do something about that.
2390 
2391     m_frame-&gt;script().updateDocument();
2392 
2393     if (!hasLivingRenderTree())
2394         createRenderTree();
2395 
2396     dispatchDisabledAdaptationsDidChangeForMainFrame();
2397     updateViewportArguments();
2398 
2399     // FIXME: Doing this only for the main frame is insufficient.
2400     // Changing a subframe can also change the wheel event handler count.
2401     // FIXME: Doing this only when a document goes into the frame is insufficient.
2402     // Removing a document can also change the wheel event handler count.
2403     // FIXME: Doing this every time is a waste. If the current document and its
2404     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2405     // unless the documents they are replacing had wheel event handlers.
2406     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2407         wheelEventHandlersChanged();
2408 
2409     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2410     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
2411     // page cache, or simply newly created).
2412     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2413         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2414             if (auto* timeline = existingTimeline())
2415                 timeline-&gt;suspendAnimations();
2416         } else
2417             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2418         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2419     } else {
2420         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2421         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2422             if (auto* timeline = existingTimeline())
2423                 timeline-&gt;resumeAnimations();
2424         } else
2425             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2426     }
2427 }
2428 
2429 void Document::frameDestroyed()
2430 {
2431     // detachFromFrame() must be called before destroying the Frame.
2432     RELEASE_ASSERT(!m_frame);
2433 
2434     if (auto* window = domWindow())
2435         window-&gt;frameDestroyed();
2436 
2437     FrameDestructionObserver::frameDestroyed();
2438 }
2439 
2440 void Document::willDetachPage()
2441 {
2442     FrameDestructionObserver::willDetachPage();
2443 
2444     if (domWindow() &amp;&amp; frame())
2445         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2446 }
2447 
2448 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2449 {
2450     RELEASE_ASSERT(cachedFrame.document() == this);
2451     ASSERT(cachedFrame.view());
2452     ASSERT(m_pageCacheState == Document::InPageCache);
2453     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2454 }
2455 
2456 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2457 {
2458     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2459     RELEASE_ASSERT(cachedFrame.document() == this);
2460     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2461     ASSERT(m_pageCacheState == Document::InPageCache);
2462     detachFromFrame();
2463 }
2464 
2465 void Document::destroyRenderTree()
2466 {
2467     ASSERT(hasLivingRenderTree());
2468     ASSERT(frame());
2469     ASSERT(frame()-&gt;document() == this);
2470     ASSERT(page());
2471 
2472     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2473     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2474 
2475     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2476 
2477     if (this == &amp;topDocument())
2478         clearAXObjectCache();
2479 
2480     documentWillBecomeInactive();
2481 
2482     if (view())
2483         view()-&gt;willDestroyRenderTree();
2484 
2485     if (m_documentElement)
2486         RenderTreeUpdater::tearDownRenderers(*m_documentElement);
2487 
2488     clearChildNeedsStyleRecalc();
2489 
2490     unscheduleStyleRecalc();
2491 
2492     // FIXME: RenderObject::view() uses m_renderView and we can&#39;t null it before destruction is completed
2493     {
2494         RenderTreeBuilder builder(*m_renderView);
2495         // FIXME: This is a workaround for leftover content (see webkit.org/b/182547).
2496         while (m_renderView-&gt;firstChild())
2497             builder.destroy(*m_renderView-&gt;firstChild());
2498         m_renderView-&gt;destroy();
2499     }
2500     m_renderView.release();
2501 
2502     Node::setRenderer(nullptr);
2503 
2504 #if ENABLE(TEXT_AUTOSIZING)
2505     m_textAutoSizing = nullptr;
2506 #endif
2507 
2508     if (view())
2509         view()-&gt;didDestroyRenderTree();
2510 }
2511 
2512 void Document::prepareForDestruction()
2513 {
2514     if (m_hasPreparedForDestruction)
2515         return;
2516 
2517     if (m_frame)
2518         m_frame-&gt;animation().detachFromDocument(this);
2519 
2520 #if USE(LIBWEBRTC)
2521     // FIXME: This should be moved to Modules/mediastream.
2522     if (LibWebRTCProvider::webRTCAvailable()) {
2523         if (auto* page = this-&gt;page())
2524             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2525     }
2526 #endif
2527 
2528 #if ENABLE(SERVICE_WORKER)
2529     setActiveServiceWorker(nullptr);
2530     setServiceWorkerConnection(nullptr);
2531 #endif
2532 
2533 #if ENABLE(IOS_TOUCH_EVENTS)
2534     clearTouchEventHandlersAndListeners();
2535 #endif
2536 
2537     m_undoManager-&gt;removeAllItems();
2538 
2539 #if HAVE(ACCESSIBILITY)
2540     if (this != &amp;topDocument()) {
2541         // Let the ax cache know that this subframe goes out of scope.
2542         if (auto* cache = existingAXObjectCache())
2543             cache-&gt;prepareForDocumentDestruction(*this);
2544     }
2545 #endif
2546 
2547     {
2548         NavigationDisabler navigationDisabler(m_frame);
2549         disconnectDescendantFrames();
2550     }
2551 
2552     if (m_domWindow &amp;&amp; m_frame)
2553         m_domWindow-&gt;willDetachDocumentFromFrame();
2554 
2555     styleScope().clearResolver();
2556 
2557     if (hasLivingRenderTree())
2558         destroyRenderTree();
2559 
2560     if (is&lt;PluginDocument&gt;(*this))
2561         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2562 
2563 #if ENABLE(POINTER_LOCK)
2564     if (page())
2565         page()-&gt;pointerLockController().documentDetached(*this);
2566 #endif
2567 
2568     if (auto* page = this-&gt;page()) {
2569         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2570             validationMessageClient-&gt;documentDetached(*this);
2571     }
2572 
2573     InspectorInstrumentation::documentDetached(*this);
2574 
2575     stopActiveDOMObjects();
2576     m_eventQueue.close();
2577 #if ENABLE(FULLSCREEN_API)
2578     m_fullScreenChangeEventTargetQueue.clear();
2579     m_fullScreenErrorEventTargetQueue.clear();
2580 #endif
2581 
2582     commonTeardown();
2583 
2584 #if ENABLE(TOUCH_EVENTS)
2585     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2586         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2587 #endif
2588 
2589     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2590         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2591 
2592     if (m_mediaQueryMatcher)
2593         m_mediaQueryMatcher-&gt;documentDestroyed();
2594 
2595 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2596     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2597         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2598             removePlaybackTargetPickerClient(*client);
2599     }
2600 #endif
2601 
2602     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2603 
2604     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2605         m_mediaState = MediaProducer::IsNotPlaying;
2606         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2607     }
2608 
2609     detachFromFrame();
2610 
2611     if (m_timeline) {
2612         m_timeline-&gt;detachFromDocument();
2613         m_timeline = nullptr;
2614     }
2615 
2616 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
2617     if (m_animationScheduler) {
2618         m_animationScheduler-&gt;detachFromDocument();
2619         m_animationScheduler = nullptr;
2620     }
2621 #endif
2622 
2623 #if ENABLE(CSS_PAINTING_API)
2624     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2625         scope-&gt;prepareForDestruction();
2626     m_paintWorkletGlobalScopes.clear();
2627 #endif
2628 
2629     m_hasPreparedForDestruction = true;
2630 
2631     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame
2632     // was removed in an onpagehide event handler fired when the top-level frame is
2633     // about to enter the page cache.
2634     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);
2635 }
2636 
2637 void Document::removeAllEventListeners()
2638 {
2639     EventTarget::removeAllEventListeners();
2640 
2641     if (m_domWindow)
2642         m_domWindow-&gt;removeAllEventListeners();
2643 
2644 #if ENABLE(IOS_TOUCH_EVENTS)
2645     clearTouchEventHandlersAndListeners();
2646 #endif
2647     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2648         node-&gt;removeAllEventListeners();
2649 
2650 #if ENABLE(TOUCH_EVENTS)
2651     m_touchEventTargets = nullptr;
2652 #endif
2653     m_wheelEventTargets = nullptr;
2654 }
2655 
2656 void Document::suspendDeviceMotionAndOrientationUpdates()
2657 {
2658     if (m_areDeviceMotionAndOrientationUpdatesSuspended)
2659         return;
2660     m_areDeviceMotionAndOrientationUpdatesSuspended = true;
2661 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2662     if (m_deviceMotionController)
2663         m_deviceMotionController-&gt;suspendUpdates();
2664     if (m_deviceOrientationController)
2665         m_deviceOrientationController-&gt;suspendUpdates();
2666 #endif
2667 }
2668 
2669 void Document::resumeDeviceMotionAndOrientationUpdates()
2670 {
2671     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2672         return;
2673     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2674 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2675     if (m_deviceMotionController)
2676         m_deviceMotionController-&gt;resumeUpdates();
2677     if (m_deviceOrientationController)
2678         m_deviceOrientationController-&gt;resumeUpdates();
2679 #endif
2680 }
2681 
2682 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2683 {
2684     // Bypass this policy when the world is known, and it not the normal world.
2685     auto&amp; callFrame = *commonVM().topCallFrame;
2686     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();
2687 }
2688 
2689 void Document::platformSuspendOrStopActiveDOMObjects()
2690 {
2691 #if PLATFORM(IOS_FAMILY)
2692     if (WebThreadCountOfObservedDOMTimers() &gt; 0) {
2693         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document::platformSuspendOrStopActiveDOMObjects: remove registered timers.&quot;);
2694         if (auto* frame = this-&gt;frame()) {
2695             if (auto* page = frame-&gt;page())
2696                 page-&gt;chrome().client().clearContentChangeObservers(*frame);
2697         }
2698     }
2699 #endif
2700 }
2701 
2702 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2703 {
2704     ScriptExecutionContext::suspendActiveDOMObjects(why);
2705     suspendDeviceMotionAndOrientationUpdates();
2706     platformSuspendOrStopActiveDOMObjects();
2707 }
2708 
2709 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2710 {
2711     ScriptExecutionContext::resumeActiveDOMObjects(why);
2712     resumeDeviceMotionAndOrientationUpdates();
2713     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2714 }
2715 
2716 void Document::stopActiveDOMObjects()
2717 {
2718     ScriptExecutionContext::stopActiveDOMObjects();
2719     platformSuspendOrStopActiveDOMObjects();
2720 }
2721 
2722 void Document::clearAXObjectCache()
2723 {
2724     ASSERT(&amp;topDocument() == this);
2725     // Clear the cache member variable before calling delete because attempts
2726     // are made to access it during destruction.
2727     m_axObjectCache = nullptr;
2728 }
2729 
2730 AXObjectCache* Document::existingAXObjectCacheSlow() const
2731 {
2732     ASSERT(hasEverCreatedAnAXObjectCache);
2733     return topDocument().m_axObjectCache.get();
2734 }
2735 
2736 AXObjectCache* Document::axObjectCache() const
2737 {
2738     if (!AXObjectCache::accessibilityEnabled())
2739         return nullptr;
2740 
2741     // The only document that actually has a AXObjectCache is the top-level
2742     // document.  This is because we need to be able to get from any WebCoreAXObject
2743     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2744     // lookups across nested webareas (i.e. multiple documents).
2745     Document&amp; topDocument = this-&gt;topDocument();
2746 
2747     // If the document has already been detached, do not make a new axObjectCache.
2748     if (!topDocument.hasLivingRenderTree())
2749         return nullptr;
2750 
2751     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2752     if (!topDocument.m_axObjectCache) {
2753         topDocument.m_axObjectCache = std::make_unique&lt;AXObjectCache&gt;(topDocument);
2754         hasEverCreatedAnAXObjectCache = true;
2755     }
2756     return topDocument.m_axObjectCache.get();
2757 }
2758 
2759 void Document::setVisuallyOrdered()
2760 {
2761     m_visuallyOrdered = true;
2762     if (renderView())
2763         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2764 }
2765 
2766 Ref&lt;DocumentParser&gt; Document::createParser()
2767 {
2768     // FIXME: this should probably pass the frame instead
2769     return XMLDocumentParser::create(*this, view());
2770 }
2771 
2772 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2773 {
2774     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2775 }
2776 
2777 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomicString&amp; name, const String&amp; features)
2778 {
2779     if (!m_domWindow)
2780         return Exception { InvalidAccessError };
2781 
2782     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2783 }
2784 
2785 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2786 {
2787     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2788         return Exception { InvalidStateError };
2789 
2790     auto result = open(responsibleDocument);
2791     if (UNLIKELY(result.hasException()))
2792         return result.releaseException();
2793 
2794     return *this;
2795 }
2796 
2797 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2798 {
2799     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2800         return Exception { SecurityError };
2801 
2802     if (m_ignoreOpensDuringUnloadCount)
2803         return { };
2804 
2805     if (m_frame) {
2806         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2807             if (parser-&gt;isParsing()) {
2808                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2809                 if (parser-&gt;isExecutingScript())
2810                     return { };
2811 
2812                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2813                     return { };
2814             }
2815         }
2816 
2817         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2818             m_frame-&gt;loader().policyChecker().stopCheck();
2819         if (m_frame-&gt;loader().state() == FrameStateProvisional)
2820             m_frame-&gt;loader().stopAllLoaders();
2821     }
2822 
2823     removeAllEventListeners();
2824 
2825     if (responsibleDocument &amp;&amp; isFullyActive()) {
2826         auto newURL = responsibleDocument-&gt;url();
2827         if (responsibleDocument != this)
2828             newURL.removeFragmentIdentifier();
2829         setURL(newURL);
2830         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2831         if (responsibleDocument != this)
2832             newCookieURL.removeFragmentIdentifier();
2833         setCookieURL(newCookieURL);
2834         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2835     }
2836 
2837     implicitOpen();
2838     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2839         parser-&gt;setWasCreatedByScript(true);
2840 
2841     if (m_frame)
2842         m_frame-&gt;loader().didExplicitOpen();
2843 
2844     return { };
2845 }
2846 
2847 // https://html.spec.whatwg.org/#fully-active
2848 bool Document::isFullyActive() const
2849 {
2850     auto* frame = this-&gt;frame();
2851     if (!frame || frame-&gt;document() != this)
2852         return false;
2853 
2854     if (frame-&gt;isMainFrame())
2855         return true;
2856 
2857     auto* parentFrame = frame-&gt;tree().parent();
2858     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2859 }
2860 
2861 void Document::detachParser()
2862 {
2863     if (!m_parser)
2864         return;
2865     m_parser-&gt;detach();
2866     m_parser = nullptr;
2867 }
2868 
2869 void Document::cancelParsing()
2870 {
2871     if (!m_parser)
2872         return;
2873 
2874     // We have to clear the parser to avoid possibly triggering
2875     // the onload handler when closing as a side effect of a cancel-style
2876     // change, such as opening a new document or closing the window while
2877     // still parsing
2878     detachParser();
2879     explicitClose();
2880 }
2881 
2882 void Document::implicitOpen()
2883 {
2884     removeChildren();
2885 
2886     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2887 
2888     cancelParsing();
2889     m_parser = createParser();
2890 
2891     if (hasActiveParserYieldToken())
2892         m_parser-&gt;didBeginYieldingParser();
2893 
2894     setParsing(true);
2895     setReadyState(Loading);
2896 }
2897 
2898 HTMLBodyElement* Document::body() const
2899 {
2900     auto* element = documentElement();
2901     if (!is&lt;HTMLHtmlElement&gt;(element))
2902         return nullptr;
2903     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2904 }
2905 
2906 HTMLElement* Document::bodyOrFrameset() const
2907 {
2908     // Return the first body or frameset child of the html element.
2909     auto* element = documentElement();
2910     if (!is&lt;HTMLHtmlElement&gt;(element))
2911         return nullptr;
2912     for (auto&amp; child : childrenOfType&lt;HTMLElement&gt;(*element)) {
2913         if (is&lt;HTMLBodyElement&gt;(child) || is&lt;HTMLFrameSetElement&gt;(child))
2914             return &amp;child;
2915     }
2916     return nullptr;
2917 }
2918 
2919 ExceptionOr&lt;void&gt; Document::setBodyOrFrameset(RefPtr&lt;HTMLElement&gt;&amp;&amp; newBody)
2920 {
2921     if (!is&lt;HTMLBodyElement&gt;(newBody) &amp;&amp; !is&lt;HTMLFrameSetElement&gt;(newBody))
2922         return Exception { HierarchyRequestError };
2923 
2924     auto* currentBody = bodyOrFrameset();
2925     if (newBody == currentBody)
2926         return { };
2927 
2928     if (!m_documentElement)
2929         return Exception { HierarchyRequestError };
2930 
2931     if (currentBody)
2932         return m_documentElement-&gt;replaceChild(*newBody, *currentBody);
2933     return m_documentElement-&gt;appendChild(*newBody);
2934 }
2935 
2936 Location* Document::location() const
2937 {
2938     auto* window = domWindow();
2939     return window ? &amp;window-&gt;location() : nullptr;
2940 }
2941 
2942 HTMLHeadElement* Document::head()
2943 {
2944     if (auto element = documentElement())
2945         return childrenOfType&lt;HTMLHeadElement&gt;(*element).first();
2946     return nullptr;
2947 }
2948 
2949 ExceptionOr&lt;void&gt; Document::closeForBindings()
2950 {
2951     // FIXME: We should follow the specification more closely:
2952     //        http://www.whatwg.org/specs/web-apps/current-work/#dom-document-close
2953 
2954     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2955         return Exception { InvalidStateError };
2956 
2957     close();
2958     return { };
2959 }
2960 
2961 void Document::close()
2962 {
2963     if (!scriptableDocumentParser() || !scriptableDocumentParser()-&gt;wasCreatedByScript() || !scriptableDocumentParser()-&gt;isParsing())
2964         return;
2965 
2966     explicitClose();
2967 }
2968 
2969 void Document::explicitClose()
2970 {
2971     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2972         parser-&gt;finish();
2973 
2974     if (!m_frame) {
2975         // Because we have no frame, we don&#39;t know if all loading has completed,
2976         // so we just call implicitClose() immediately. FIXME: This might fire
2977         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
2978         implicitClose();
2979         return;
2980     }
2981 
2982     checkCompleted();
2983 }
2984 
2985 void Document::implicitClose()
2986 {
2987     // If we&#39;re in the middle of recalcStyle, we need to defer the close until the style information is accurate and all elements are re-attached.
2988     if (m_inStyleRecalc) {
2989         m_closeAfterStyleRecalc = true;
2990         return;
2991     }
2992 
2993     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
2994     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
2995 
2996     if (!doload)
2997         return;
2998 
2999     // Call to dispatchWindowLoadEvent can blow us from underneath.
3000     Ref&lt;Document&gt; protectedThis(*this);
3001 
3002     m_processingLoadEvent = true;
3003 
3004     ScriptableDocumentParser* parser = scriptableDocumentParser();
3005     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
3006 
3007     // We have to clear the parser, in case someone document.write()s from the
3008     // onLoad event handler, as in Radar 3206524.
3009     detachParser();
3010 
3011     // FIXME: We kick off the icon loader when the Document is done parsing.
3012     // There are earlier opportunities we could start it:
3013     //  -When the &lt;head&gt; finishes parsing
3014     //  -When any new HTMLLinkElement is inserted into the document
3015     // But those add a dynamic component to the favicon that has UI
3016     // ramifications, and we need to decide what is the Right Thing To Do(tm)
3017     RefPtr&lt;Frame&gt; f = frame();
3018     if (f) {
3019 #if ENABLE(XSLT)
3020         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
3021         applyPendingXSLTransformsNowIfScheduled();
3022 #endif
3023 
3024         if (auto* documentLoader = loader())
3025             documentLoader-&gt;startIconLoading();
3026 
3027         f-&gt;animation().startAnimationsIfNotSuspended(this);
3028 
3029         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
3030         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
3031         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
3032         ImageLoader::dispatchPendingBeforeLoadEvents();
3033         ImageLoader::dispatchPendingLoadEvents();
3034         ImageLoader::dispatchPendingErrorEvents();
3035         HTMLLinkElement::dispatchPendingLoadEvents();
3036         HTMLStyleElement::dispatchPendingLoadEvents();
3037 
3038         // To align the HTML load event and the SVGLoad event for the outermost &lt;svg&gt; element, fire it from
3039         // here, instead of doing it from SVGElement::finishedParsingChildren (if externalResourcesRequired=&quot;false&quot;,
3040         // which is the default, for =&#39;true&#39; its fired at a later time, once all external resources finished loading).
3041         if (svgExtensions())
3042             accessSVGExtensions().dispatchSVGLoadEventToOutermostSVGElements();
3043     }
3044 
3045     dispatchWindowLoadEvent();
3046     dispatchPageshowEvent(PageshowEventNotPersisted);
3047     if (m_pendingStateObject)
3048         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
3049 
3050     if (f)
3051         f-&gt;loader().dispatchOnloadEvents();
3052 
3053     // An event handler may have removed the frame
3054     if (!frame()) {
3055         m_processingLoadEvent = false;
3056         return;
3057     }
3058 
3059     // Make sure both the initial layout and reflow happen after the onload
3060     // fires. This will improve onload scores, and other browsers do it.
3061     // If they wanna cheat, we can too. -dwh
3062 
3063     if (frame()-&gt;navigationScheduler().locationChangePending() &amp;&amp; timeSinceDocumentCreation() &lt; settings().layoutInterval()) {
3064         // Just bail out. Before or during the onload we were shifted to another page.
3065         // The old i-Bench suite does this. When this happens don&#39;t bother painting or laying out.
3066         m_processingLoadEvent = false;
3067         view()-&gt;layoutContext().unscheduleLayout();
3068         return;
3069     }
3070 
3071     frame()-&gt;loader().checkCallImplicitClose();
3072 
3073     // We used to force a synchronous display and flush here.  This really isn&#39;t
3074     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3075     // (if your platform is syncing flushes and limiting them to 60fps).
3076     m_overMinimumLayoutThreshold = true;
3077     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3078         updateStyleIfNeeded();
3079 
3080         // Always do a layout after loading if needed.
3081         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3082             view()-&gt;layoutContext().layout();
3083     }
3084 
3085     m_processingLoadEvent = false;
3086 
3087 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3088     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3089         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3090         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3091         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3092         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3093         //
3094         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3095         // catch new AND page history loads, and that uses AXLoadComplete
3096 
3097         axObjectCache()-&gt;getOrCreate(renderView());
3098         if (this == &amp;topDocument())
3099             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3100         else {
3101             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3102             // in an iframe that just finished loading, post AXLayoutComplete instead.
3103             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3104         }
3105     }
3106 #endif
3107 
3108     if (svgExtensions())
3109         accessSVGExtensions().startAnimations();
3110 }
3111 
3112 void Document::setParsing(bool b)
3113 {
3114     m_bParsing = b;
3115 
3116     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
3117         m_sharedObjectPool = std::make_unique&lt;DocumentSharedObjectPool&gt;();
3118 
3119     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3120         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3121 }
3122 
3123 bool Document::shouldScheduleLayout()
3124 {
3125     if (!documentElement())
3126         return false;
3127     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3128         return true;
3129     if (!bodyOrFrameset())
3130         return false;
3131     if (styleScope().hasPendingSheetsBeforeBody())
3132         return false;
3133     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3134         return false;
3135 
3136     return true;
3137 }
3138 
3139 bool Document::isLayoutTimerActive()
3140 {
3141     return view() &amp;&amp; view()-&gt;layoutContext().isLayoutPending() &amp;&amp; !minimumLayoutDelay();
3142 }
3143 
3144 Seconds Document::minimumLayoutDelay()
3145 {
3146     if (m_overMinimumLayoutThreshold)
3147         return 0_s;
3148 
3149     auto elapsed = timeSinceDocumentCreation();
3150     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3151 
3152     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3153     return std::max(0_s, settings().layoutInterval() - elapsed);
3154 }
3155 
3156 Seconds Document::timeSinceDocumentCreation() const
3157 {
3158     return MonotonicTime::now() - m_documentCreationTime;
3159 }
3160 
3161 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3162 {
3163     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3164 
3165     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3166     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3167 
3168     if (m_writeRecursionIsTooDeep)
3169         return { };
3170 
3171     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3172     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3173         return { };
3174 
3175     if (!hasInsertionPoint) {
3176         auto result = open(responsibleDocument);
3177         if (UNLIKELY(result.hasException()))
3178             return result.releaseException();
3179     }
3180 
3181     ASSERT(m_parser);
3182     m_parser-&gt;insert(WTFMove(text));
3183     return { };
3184 }
3185 
3186 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3187 {
3188     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3189         return Exception { InvalidStateError };
3190 
3191     SegmentedString text;
3192     for (auto&amp; string : strings)
3193         text.append(WTFMove(string));
3194 
3195     return write(responsibleDocument, WTFMove(text));
3196 }
3197 
3198 ExceptionOr&lt;void&gt; Document::writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp; strings)
3199 {
3200     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
3201         return Exception { InvalidStateError };
3202 
3203     SegmentedString text;
3204     for (auto&amp; string : strings)
3205         text.append(WTFMove(string));
3206 
3207     text.append(&quot;\n&quot;_s);
3208     return write(responsibleDocument, WTFMove(text));
3209 }
3210 
3211 Seconds Document::minimumDOMTimerInterval() const
3212 {
3213     auto* page = this-&gt;page();
3214     if (!page)
3215         return ScriptExecutionContext::minimumDOMTimerInterval();
3216     return page-&gt;settings().minimumDOMTimerInterval();
3217 }
3218 
3219 void Document::setTimerThrottlingEnabled(bool shouldThrottle)
3220 {
3221     if (m_isTimerThrottlingEnabled == shouldThrottle)
3222         return;
3223 
3224     m_isTimerThrottlingEnabled = shouldThrottle;
3225     didChangeTimerAlignmentInterval();
3226 }
3227 
3228 Seconds Document::domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const
3229 {
3230     auto alignmentInterval = ScriptExecutionContext::domTimerAlignmentInterval(hasReachedMaxNestingLevel);
3231     if (!hasReachedMaxNestingLevel)
3232         return alignmentInterval;
3233 
3234     // Apply Document-level DOMTimer throttling only if timers have reached their maximum nesting level as the Page may still be visible.
3235     if (m_isTimerThrottlingEnabled)
3236         alignmentInterval = std::max(alignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
3237 
3238     if (Page* page = this-&gt;page())
3239         alignmentInterval = std::max(alignmentInterval, page-&gt;domTimerAlignmentInterval());
3240 
3241     if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
3242         alignmentInterval = std::max(alignmentInterval, DOMTimer::nonInteractedCrossOriginFrameAlignmentInterval());
3243 
3244     return alignmentInterval;
3245 }
3246 
3247 EventTarget* Document::errorEventTarget()
3248 {
3249     return m_domWindow.get();
3250 }
3251 
3252 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3253 {
3254     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3255 }
3256 
3257 void Document::setURL(const URL&amp; url)
3258 {
3259     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3260     if (newURL == m_url)
3261         return;
3262 
3263     m_url = newURL;
3264     m_documentURI = m_url.string();
3265     updateBaseURL();
3266 }
3267 
3268 void Document::updateBaseURL()
3269 {
3270     URL oldBaseURL = m_baseURL;
3271     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3272     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3273     // from the Document interface otherwise.
3274     if (!m_baseElementURL.isEmpty())
3275         m_baseURL = m_baseElementURL;
3276     else if (!m_baseURLOverride.isEmpty())
3277         m_baseURL = m_baseURLOverride;
3278     else {
3279         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3280         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3281         // and DOM 3 Core does not specify how it should be resolved.
3282         m_baseURL = URL({ }, documentURI());
3283     }
3284 
3285     clearSelectorQueryCache();
3286 
3287     if (!m_baseURL.isValid())
3288         m_baseURL = URL();
3289 
3290     if (!equalIgnoringFragmentIdentifier(oldBaseURL, m_baseURL)) {
3291         // Base URL change changes any relative visited links.
3292         // FIXME: There are other URLs in the tree that would need to be re-evaluated on dynamic base URL change. Style should be invalidated too.
3293         for (auto&amp; anchor : descendantsOfType&lt;HTMLAnchorElement&gt;(*this))
3294             anchor.invalidateCachedVisitedLinkHash();
3295     }
3296 }
3297 
3298 void Document::setBaseURLOverride(const URL&amp; url)
3299 {
3300     m_baseURLOverride = url;
3301     updateBaseURL();
3302 }
3303 
3304 void Document::processBaseElement()
3305 {
3306     // Find the first href attribute in a base element and the first target attribute in a base element.
3307     const AtomicString* href = nullptr;
3308     const AtomicString* target = nullptr;
3309     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3310     for (auto&amp; base : baseDescendants) {
3311         if (!href) {
3312             const AtomicString&amp; value = base.attributeWithoutSynchronization(hrefAttr);
3313             if (!value.isNull()) {
3314                 href = &amp;value;
3315                 if (target)
3316                     break;
3317             }
3318         }
3319         if (!target) {
3320             const AtomicString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3321             if (!value.isNull()) {
3322                 target = &amp;value;
3323                 if (href)
3324                     break;
3325             }
3326         }
3327     }
3328 
3329     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3330     URL baseElementURL;
3331     if (href) {
3332         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3333         if (!strippedHref.isEmpty())
3334             baseElementURL = URL(url(), strippedHref);
3335     }
3336     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3337         m_baseElementURL = baseElementURL;
3338         updateBaseURL();
3339     }
3340 
3341     m_baseTarget = target ? *target : nullAtom();
3342 }
3343 
3344 String Document::userAgent(const URL&amp; url) const
3345 {
3346     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3347 }
3348 
3349 void Document::disableEval(const String&amp; errorMessage)
3350 {
3351     if (!frame())
3352         return;
3353 
3354     frame()-&gt;script().disableEval(errorMessage);
3355 }
3356 
3357 void Document::disableWebAssembly(const String&amp; errorMessage)
3358 {
3359     if (!frame())
3360         return;
3361 
3362     frame()-&gt;script().disableWebAssembly(errorMessage);
3363 }
3364 
3365 #if ENABLE(INDEXED_DATABASE)
3366 IDBClient::IDBConnectionProxy* Document::idbConnectionProxy()
3367 {
3368     if (!m_idbConnectionProxy) {
3369         Page* currentPage = page();
3370         if (!currentPage)
3371             return nullptr;
3372         m_idbConnectionProxy = &amp;currentPage-&gt;idbConnection().proxy();
3373     }
3374     return m_idbConnectionProxy.get();
3375 }
3376 #endif
3377 
3378 SocketProvider* Document::socketProvider()
3379 {
3380     return m_socketProvider.get();
3381 }
3382 
3383 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3384 {
3385     if (!m_frame)
3386         return false;
3387 
3388     // FIXME: We shouldn&#39;t call this function without a target frame, but
3389     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3390     // returning true when supplied with a 0 targetFrame.
3391     if (!targetFrame)
3392         return true;
3393 
3394     if (!canNavigateInternal(*targetFrame))
3395         return false;
3396 
3397     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
3398         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin and the user has never interacted with the frame.&quot;_s);
3399         return false;
3400     }
3401 
3402     return true;
3403 }
3404 
3405 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3406 {
3407     ASSERT(m_frame);
3408 
3409     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3410 
3411     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3412     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3413         return true;
3414 
3415     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3416     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3417         return true;
3418 
3419     // iii. A sandboxed frame can always navigate its descendants.
3420     if (isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().isDescendantOf(m_frame))
3421         return true;
3422 
3423     // From https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-navigate.
3424     // 1. If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A&#39;s active document&#39;s active sandboxing
3425     // flag set has its sandboxed navigation browsing context flag set, then abort these steps negatively.
3426     if (m_frame != &amp;targetFrame &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.tree().parent() &amp;&amp; !targetFrame.tree().isDescendantOf(m_frame)) {
3427         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is therefore disallowed from navigating its ancestors.&quot;_s);
3428         return false;
3429     }
3430 
3431     // 2. Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:
3432     if (m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top()) {
3433         bool triggeredByUserActivation = UserGestureIndicator::processingUserGesture();
3434         // 1. If this algorithm is triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then abort these steps negatively.
3435         if (triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigationByUserActivation)) {
3436             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation-by-user-activation&#39; flag is not set and navigation is not triggered by user activation.&quot;_s);
3437             return false;
3438         }
3439         // 2. Otherwise, If this algorithm is not triggered by user activation and A&#39;s active document&#39;s active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then abort these steps negatively.
3440         if (!triggeredByUserActivation &amp;&amp; isSandboxed(SandboxTopNavigation)) {
3441             printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation of the top-level window is sandboxed, but the &#39;allow-top-navigation&#39; flag is not set.&quot;_s);
3442             return false;
3443         }
3444     }
3445 
3446     // 3. Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A&#39;s Document&#39;s active sandboxing flag set has its
3447     // sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then abort these steps negatively.
3448     if (!targetFrame.tree().parent() &amp;&amp; m_frame != &amp;targetFrame &amp;&amp; &amp;targetFrame != &amp;m_frame-&gt;tree().top() &amp;&amp; isSandboxed(SandboxNavigation) &amp;&amp; targetFrame.loader().opener() != m_frame) {
3449         printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is sandboxed, and is not allowed to navigate this popup.&quot;_s);
3450         return false;
3451     }
3452 
3453     // 4. Otherwise, terminate positively!
3454 
3455     // This is the normal case. A document can navigate its descendant frames,
3456     // or, more generally, a document can navigate a frame if the document is
3457     // in the same origin as any of that frame&#39;s ancestors (in the frame
3458     // hierarchy).
3459     //
3460     // See http://www.adambarth.com/papers/2008/barth-jackson-mitchell.pdf for
3461     // historical information about this security check.
3462     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3463         return true;
3464 
3465     // Top-level frames are easier to navigate than other frames because they
3466     // display their URLs in the address bar (in most browsers). However, there
3467     // are still some restrictions on navigation to avoid nuisance attacks.
3468     // Specifically, a document can navigate a top-level frame if that frame
3469     // opened the document or if the document is the same-origin with any of
3470     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3471     //
3472     // In both of these cases, the document performing the navigation is in
3473     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3474     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3475     // document from navigating arbitrary, unrelated top-level frames.
3476     if (!targetFrame.tree().parent()) {
3477         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3478             return true;
3479 
3480         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3481             return true;
3482     }
3483 
3484     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3485     return false;
3486 }
3487 
3488 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3489 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3490 {
3491     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3492         return false;
3493 
3494     // Only prevent top frame navigations by subframes.
3495     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3496         return false;
3497 
3498     // Only prevent navigations by subframes that the user has not interacted with.
3499     if (m_frame-&gt;hasHadUserInteraction())
3500         return false;
3501 
3502     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3503     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3504     if (sandboxFlags() != SandboxNone)
3505         return false;
3506 
3507     // Only prevent navigations by third-party iframes.
3508     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3509         return false;
3510 
3511     // Only prevent cross-site navigations.
3512     auto* targetDocument = targetFrame.document();
3513     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || registrableDomainsAreEqual(targetDocument-&gt;url(), destinationURL)))
3514         return false;
3515 
3516     return true;
3517 }
3518 
3519 void Document::didRemoveAllPendingStylesheet()
3520 {
3521     if (auto* parser = scriptableDocumentParser())
3522         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3523 }
3524 
3525 bool Document::usesStyleBasedEditability() const
3526 {
3527     if (m_hasElementUsingStyleBasedEditability)
3528         return true;
3529 
3530     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3531     ASSERT(!m_inStyleRecalc);
3532 
3533     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3534     styleScope.flushPendingUpdate();
3535     return styleScope.usesStyleBasedEditability();
3536 }
3537 
3538 void Document::setHasElementUsingStyleBasedEditability()
3539 {
3540     m_hasElementUsingStyleBasedEditability = true;
3541 }
3542 
3543 void Document::processHttpEquiv(const String&amp; equiv, const String&amp; content, bool isInDocumentHead)
3544 {
3545     ASSERT(!equiv.isNull());
3546     ASSERT(!content.isNull());
3547 
3548     HttpEquivPolicy policy = httpEquivPolicy();
3549     if (policy != HttpEquivPolicy::Enabled) {
3550         String reason;
3551         switch (policy) {
3552         case HttpEquivPolicy::Enabled:
3553             ASSERT_NOT_REACHED();
3554             break;
3555         case HttpEquivPolicy::DisabledBySettings:
3556             reason = &quot;by the embedder.&quot;;
3557             break;
3558         case HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox:
3559             reason = &quot;for documents with Content-Disposition: attachment.&quot;;
3560             break;
3561         }
3562         String message = &quot;http-equiv &#39;&quot; + equiv + &quot;&#39; is disabled &quot; + reason;
3563         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3564         return;
3565     }
3566 
3567     Frame* frame = this-&gt;frame();
3568     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3569     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3570 
3571     HTTPHeaderName headerName;
3572     if (!findHTTPHeaderName(equiv, headerName))
3573         return;
3574 
3575     switch (headerName) {
3576     case HTTPHeaderName::DefaultStyle:
3577         // The preferred style set has been overridden as per section
3578         // 14.3.2 of the HTML4.0 specification.  We need to update the
3579         // sheet used variable and then update our style selector.
3580         // For more info, see the test at:
3581         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3582         // -dwh
3583         styleScope().setPreferredStylesheetSetName(content);
3584         break;
3585 
3586     case HTTPHeaderName::Refresh: {
3587         double delay;
3588         String urlString;
3589         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3590             URL completedURL;
3591             if (urlString.isEmpty())
3592                 completedURL = m_url;
3593             else
3594                 completedURL = completeURL(urlString);
3595             if (!WTF::protocolIsJavaScript(completedURL))
3596                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3597             else {
3598                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3599                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3600             }
3601         }
3602 
3603         break;
3604     }
3605 
3606     case HTTPHeaderName::SetCookie:
3607         if (isHTMLDocument())
3608             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Set-Cookie meta tag is obsolete and was ignored. Use the HTTP header Set-Cookie or document.cookie instead.&quot;_s);
3609         break;
3610 
3611     case HTTPHeaderName::ContentLanguage:
3612         setContentLanguage(content);
3613         break;
3614 
3615     case HTTPHeaderName::XDNSPrefetchControl:
3616         parseDNSPrefetchControlHeader(content);
3617         break;
3618 
3619     case HTTPHeaderName::XFrameOptions:
3620         if (frame) {
3621             FrameLoader&amp; frameLoader = frame-&gt;loader();
3622             unsigned long requestIdentifier = 0;
3623             if (frameLoader.activeDocumentLoader() &amp;&amp; frameLoader.activeDocumentLoader()-&gt;mainResourceLoader())
3624                 requestIdentifier = frameLoader.activeDocumentLoader()-&gt;mainResourceLoader()-&gt;identifier();
3625 
3626             String message = &quot;The X-Frame-Option &#39;&quot; + content + &quot;&#39; supplied in a &lt;meta&gt; element was ignored. X-Frame-Options may only be provided by an HTTP header sent with the document.&quot;;
3627             addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, requestIdentifier);
3628         }
3629         break;
3630 
3631     case HTTPHeaderName::ContentSecurityPolicy:
3632         if (isInDocumentHead)
3633             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3634         break;
3635 
3636     case HTTPHeaderName::XWebKitCSP:
3637         if (isInDocumentHead)
3638             contentSecurityPolicy()-&gt;didReceiveHeader(content, ContentSecurityPolicyHeaderType::PrefixedEnforce, ContentSecurityPolicy::PolicyFrom::HTTPEquivMeta, referrer(), httpStatusCode);
3639         break;
3640 
3641     default:
3642         break;
3643     }
3644 }
3645 
3646 void Document::processDisabledAdaptations(const String&amp; disabledAdaptationsString)
3647 {
3648     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3649     if (m_disabledAdaptations == disabledAdaptations)
3650         return;
3651 
3652     m_disabledAdaptations = disabledAdaptations;
3653     dispatchDisabledAdaptationsDidChangeForMainFrame();
3654 }
3655 
3656 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3657 {
3658     if (!frame()-&gt;isMainFrame())
3659         return;
3660 
3661     if (!page())
3662         return;
3663 
3664     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3665 }
3666 
3667 void Document::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)
3668 {
3669     if (viewportArguments == m_overrideViewportArguments)
3670         return;
3671 
3672     m_overrideViewportArguments = viewportArguments;
3673     updateViewportArguments();
3674 }
3675 
3676 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3677 {
3678     ASSERT(!features.isNull());
3679 
3680     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3681 
3682     if (origin &lt; m_viewportArguments.type)
3683         return;
3684 
3685     m_viewportArguments = ViewportArguments(origin);
3686 
3687     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3688 
3689     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3690         setViewportFeature(m_viewportArguments, *this, key, value);
3691     });
3692 
3693     updateViewportArguments();
3694 }
3695 
3696 void Document::updateViewportArguments()
3697 {
3698     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3699 #ifndef NDEBUG
3700         m_didDispatchViewportPropertiesChanged = true;
3701 #endif
3702         page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_overrideViewportArguments ? m_overrideViewportArguments.value() : m_viewportArguments);
3703         page()-&gt;chrome().didReceiveDocType(*frame());
3704     }
3705 }
3706 
3707 #if ENABLE(DARK_MODE_CSS)
3708 static bool isColorSchemeSeparator(UChar character)
3709 {
3710     return isASCIISpace(character) || character == &#39;,&#39;;
3711 }
3712 
3713 static void processColorSchemes(StringView colorSchemes, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3714 {
3715     unsigned length = colorSchemes.length();
3716     for (unsigned i = 0; i &lt; length; ) {
3717         // Skip to first non-separator.
3718         while (i &lt; length &amp;&amp; isColorSchemeSeparator(colorSchemes[i]))
3719             ++i;
3720         unsigned keyBegin = i;
3721 
3722         // Skip to first separator.
3723         while (i &lt; length &amp;&amp; !isColorSchemeSeparator(colorSchemes[i]))
3724             ++i;
3725         unsigned keyEnd = i;
3726 
3727         if (keyBegin == keyEnd)
3728             continue;
3729 
3730         callback(colorSchemes.substring(keyBegin, keyEnd - keyBegin));
3731     }
3732 }
3733 
3734 void Document::processSupportedColorSchemes(const String&amp; colorSchemes)
3735 {
3736     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;
3737     bool allowsTransformations = true;
3738     bool autoEncountered = false;
3739 
3740     processColorSchemes(colorSchemes, [&amp;](StringView key) {
3741         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3742             supportedColorSchemes = { };
3743             allowsTransformations = true;
3744             autoEncountered = true;
3745             return;
3746         }
3747 
3748         if (autoEncountered)
3749             return;
3750 
3751         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3752             supportedColorSchemes.add(ColorSchemes::Light);
3753         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3754             supportedColorSchemes.add(ColorSchemes::Dark);
3755         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3756             allowsTransformations = false;
3757     });
3758 
3759     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3760     if (supportedColorSchemes.isEmpty() &amp;&amp; !allowsTransformations)
3761         supportedColorSchemes.add(ColorSchemes::Light);
3762 
3763     m_supportedColorSchemes = supportedColorSchemes;
3764     m_allowsColorSchemeTransformations = allowsTransformations;
3765 
3766     if (auto* frameView = view())
3767         frameView-&gt;recalculateBaseBackgroundColor();
3768 
3769     if (auto* page = this-&gt;page())
3770         page-&gt;updateStyleAfterChangeInEnvironment();
3771 }
3772 #endif
3773 
3774 #if PLATFORM(IOS_FAMILY)
3775 
3776 void Document::processFormatDetection(const String&amp; features)
3777 {
3778     // FIXME: Find a better place for this function.
3779     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3780         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3781             m_isTelephoneNumberParsingAllowed = false;
3782     });
3783 }
3784 
3785 void Document::processWebAppOrientations()
3786 {
3787     if (Page* page = this-&gt;page())
3788         page-&gt;chrome().client().webAppOrientationsUpdated();
3789 }
3790 
3791 #endif
3792 
3793 void Document::processReferrerPolicy(const String&amp; policy, ReferrerPolicySource source)
3794 {
3795     ASSERT(!policy.isNull());
3796 
3797     // Documents in a Content-Disposition: attachment sandbox should never send a Referer header,
3798     // even if the document has a meta tag saying otherwise.
3799     if (shouldEnforceContentDispositionAttachmentSandbox())
3800         return;
3801 
3802 #if USE(QUICK_LOOK)
3803     if (shouldEnforceQuickLookSandbox())
3804         return;
3805 #endif
3806 
3807     auto referrerPolicy = parseReferrerPolicy(policy, source);
3808     if (!referrerPolicy) {
3809         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3810         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3811         return;
3812     }
3813     setReferrerPolicy(referrerPolicy.value());
3814 }
3815 
3816 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3817 {
3818     if (!hasLivingRenderTree())
3819         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3820 
3821     HitTestResult result(documentPoint);
3822     hitTest(request, result);
3823 
3824     if (!request.readOnly())
3825         updateHoverActiveState(request, result.targetElement());
3826 
3827     return MouseEventWithHitTestResults(event, result);
3828 }
3829 
3830 // DOM Section 1.1.1
3831 bool Document::childTypeAllowed(NodeType type) const
3832 {
3833     switch (type) {
3834     case ATTRIBUTE_NODE:
3835     case CDATA_SECTION_NODE:
3836     case DOCUMENT_FRAGMENT_NODE:
3837     case DOCUMENT_NODE:
3838     case TEXT_NODE:
3839         return false;
3840     case COMMENT_NODE:
3841     case PROCESSING_INSTRUCTION_NODE:
3842         return true;
3843     case DOCUMENT_TYPE_NODE:
3844     case ELEMENT_NODE:
3845         // Documents may contain no more than one of each of these.
3846         // (One Element and one DocumentType.)
3847         for (Node* c = firstChild(); c; c = c-&gt;nextSibling())
3848             if (c-&gt;nodeType() == type)
3849                 return false;
3850         return true;
3851     }
3852     return false;
3853 }
3854 
3855 bool Document::canAcceptChild(const Node&amp; newChild, const Node* refChild, AcceptChildOperation operation) const
3856 {
3857     if (operation == AcceptChildOperation::Replace &amp;&amp; refChild-&gt;nodeType() == newChild.nodeType())
3858         return true;
3859 
3860     switch (newChild.nodeType()) {
3861     case ATTRIBUTE_NODE:
3862     case CDATA_SECTION_NODE:
3863     case DOCUMENT_NODE:
3864     case TEXT_NODE:
3865         return false;
3866     case COMMENT_NODE:
3867     case PROCESSING_INSTRUCTION_NODE:
3868         return true;
3869     case DOCUMENT_FRAGMENT_NODE: {
3870         bool hasSeenElementChild = false;
3871         for (auto* node = downcast&lt;DocumentFragment&gt;(newChild).firstChild(); node; node = node-&gt;nextSibling()) {
3872             if (is&lt;Element&gt;(*node)) {
3873                 if (hasSeenElementChild)
3874                     return false;
3875                 hasSeenElementChild = true;
3876             }
3877             if (!canAcceptChild(*node, refChild, operation))
3878                 return false;
3879         }
3880         break;
3881     }
3882     case DOCUMENT_TYPE_NODE: {
3883         auto* existingDocType = childrenOfType&lt;DocumentType&gt;(*this).first();
3884         if (operation == AcceptChildOperation::Replace) {
3885             //  parent has a doctype child that is not child, or an element is preceding child.
3886             if (existingDocType &amp;&amp; existingDocType != refChild)
3887                 return false;
3888             if (refChild-&gt;previousElementSibling())
3889                 return false;
3890         } else {
3891             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3892             if (existingDocType)
3893                 return false;
3894             if ((refChild &amp;&amp; refChild-&gt;previousElementSibling()) || (!refChild &amp;&amp; firstElementChild()))
3895                 return false;
3896         }
3897         break;
3898     }
3899     case ELEMENT_NODE: {
3900         auto* existingElementChild = firstElementChild();
3901         if (operation == AcceptChildOperation::Replace) {
3902             if (existingElementChild &amp;&amp; existingElementChild != refChild)
3903                 return false;
3904             for (auto* child = refChild-&gt;nextSibling(); child; child = child-&gt;nextSibling()) {
3905                 if (is&lt;DocumentType&gt;(*child))
3906                     return false;
3907             }
3908         } else {
3909             ASSERT(operation == AcceptChildOperation::InsertOrAdd);
3910             if (existingElementChild)
3911                 return false;
3912             for (auto* child = refChild; child; child = child-&gt;nextSibling()) {
3913                 if (is&lt;DocumentType&gt;(*child))
3914                     return false;
3915             }
3916         }
3917         break;
3918     }
3919     }
3920     return true;
3921 }
3922 
3923 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3924 {
3925     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3926     clone-&gt;cloneDataFromDocument(*this);
3927     switch (type) {
3928     case CloningOperation::OnlySelf:
3929     case CloningOperation::SelfWithTemplateContent:
3930         break;
3931     case CloningOperation::Everything:
3932         cloneChildNodes(clone);
3933         break;
3934     }
3935     return WTFMove(clone);
3936 }
3937 
3938 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
3939 {
3940     if (isXMLDocument()) {
3941         if (isXHTMLDocument())
3942             return XMLDocument::createXHTML(nullptr, url());
3943         return XMLDocument::create(nullptr, url());
3944     }
3945     return create(url());
3946 }
3947 
3948 void Document::cloneDataFromDocument(const Document&amp; other)
3949 {
3950     ASSERT(m_url == other.url());
3951     m_baseURL = other.baseURL();
3952     m_baseURLOverride = other.baseURLOverride();
3953     m_documentURI = other.documentURI();
3954 
3955     setCompatibilityMode(other.m_compatibilityMode);
3956     setContextDocument(other.contextDocument());
3957     setSecurityOriginPolicy(other.securityOriginPolicy());
3958     overrideMIMEType(other.contentType());
3959     setDecoder(other.decoder());
3960 }
3961 
3962 StyleSheetList&amp; Document::styleSheets()
3963 {
3964     if (!m_styleSheetList)
3965         m_styleSheetList = StyleSheetList::create(*this);
3966     return *m_styleSheetList;
3967 }
3968 
3969 void Document::evaluateMediaQueryList()
3970 {
3971     if (m_mediaQueryMatcher)
3972         m_mediaQueryMatcher-&gt;styleResolverChanged();
3973 
3974     checkViewportDependentPictures();
3975     checkAppearanceDependentPictures();
3976 }
3977 
3978 void Document::checkViewportDependentPictures()
3979 {
3980     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;
3981     HashSet&lt;HTMLPictureElement*&gt;::iterator end = m_viewportDependentPictures.end();
3982     for (HashSet&lt;HTMLPictureElement*&gt;::iterator it = m_viewportDependentPictures.begin(); it != end; ++it) {
3983         if ((*it)-&gt;viewportChangeAffectedPicture())
3984             changedPictures.append(*it);
3985     }
3986     for (auto* picture : changedPictures)
3987         picture-&gt;sourcesChanged();
3988 }
3989 
3990 void Document::checkAppearanceDependentPictures()
3991 {
3992     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;
3993     for (auto* picture : m_appearanceDependentPictures) {
3994         if (picture-&gt;appearanceChangeAffectedPicture())
3995             changedPictures.append(picture);
3996     }
3997 
3998     for (auto* picture : changedPictures)
3999         picture-&gt;sourcesChanged();
4000 }
4001 
4002 void Document::updateViewportUnitsOnResize()
4003 {
4004     if (!hasStyleWithViewportUnits())
4005         return;
4006 
4007     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();
4008 
4009     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
4010     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
4011         auto* renderer = element-&gt;renderer();
4012         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
4013             element-&gt;invalidateStyle();
4014     }
4015 }
4016 
4017 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
4018 {
4019     m_audioProducers.add(&amp;audioProducer);
4020     updateIsPlayingMedia();
4021 }
4022 
4023 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
4024 {
4025     m_audioProducers.remove(&amp;audioProducer);
4026     updateIsPlayingMedia();
4027 }
4028 
4029 void Document::noteUserInteractionWithMediaElement()
4030 {
4031     if (m_userHasInteractedWithMediaElement)
4032         return;
4033 
4034     if (!topDocument().userDidInteractWithPage())
4035         return;
4036 
4037     m_userHasInteractedWithMediaElement = true;
4038     updateIsPlayingMedia();
4039 }
4040 
4041 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4042 {
4043     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4044     for (auto* audioProducer : m_audioProducers)
4045         state |= audioProducer-&gt;mediaState();
4046 
4047 #if ENABLE(MEDIA_SESSION)
4048     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4049         if (sourceElement-&gt;isPlaying())
4050             state |= MediaProducer::IsSourceElementPlaying;
4051 
4052         if (auto* session = sourceElement-&gt;session()) {
4053             if (auto* controls = session-&gt;controls()) {
4054                 if (controls-&gt;previousTrackEnabled())
4055                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4056                 if (controls-&gt;nextTrackEnabled())
4057                     state |= MediaProducer::IsNextTrackControlEnabled;
4058             }
4059         }
4060     }
4061 #endif
4062 
4063     if (m_userHasInteractedWithMediaElement)
4064         state |= MediaProducer::HasUserInteractedWithMediaElement;
4065 
4066     if (state == m_mediaState)
4067         return;
4068 
4069 #if ENABLE(MEDIA_STREAM)
4070     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4071 #endif
4072 
4073     m_mediaState = state;
4074 
4075     if (page())
4076         page()-&gt;updateIsPlayingMedia(sourceElementID);
4077 
4078 #if ENABLE(MEDIA_STREAM)
4079     if (captureStateChanged)
4080         mediaStreamCaptureStateChanged();
4081 #endif
4082 }
4083 
4084 void Document::pageMutedStateDidChange()
4085 {
4086     for (auto* audioProducer : m_audioProducers)
4087         audioProducer-&gt;pageMutedStateDidChange();
4088 }
4089 
4090 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4091 {
4092     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4093         return node.isDescendantOf(container);
4094 
4095     return &amp;node == &amp;container || node.isDescendantOf(container);
4096 }
4097 
4098 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4099 {
4100     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.
4101         return;
4102 
4103     Element* focusedElement = node.treeScope().focusedElementInScope();
4104     if (!focusedElement)
4105         return;
4106 
4107     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4108         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4109         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4110         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4111         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4112         // Set the focus navigation starting node to the previous focused element so that
4113         // we can fallback to the siblings or parent node for the next search.
4114         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4115         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4116         setFocusNavigationStartingNode(focusedElement);
4117     }
4118 }
4119 
4120 void Document::hoveredElementDidDetach(Element&amp; element)
4121 {
4122     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4123         return;
4124 
4125     m_hoveredElement = element.parentElement();
4126     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4127         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4128     if (frame())
4129         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4130 }
4131 
4132 void Document::elementInActiveChainDidDetach(Element&amp; element)
4133 {
4134     if (!m_activeElement || &amp;element != m_activeElement)
4135         return;
4136 
4137     m_activeElement = element.parentElement();
4138     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4139         m_activeElement = m_activeElement-&gt;parentElement();
4140 }
4141 
4142 #if ENABLE(DASHBOARD_SUPPORT)
4143 const Vector&lt;AnnotatedRegionValue&gt;&amp; Document::annotatedRegions() const
4144 {
4145     return m_annotatedRegions;
4146 }
4147 
4148 void Document::setAnnotatedRegions(const Vector&lt;AnnotatedRegionValue&gt;&amp; regions)
4149 {
4150     m_annotatedRegions = regions;
4151     setAnnotatedRegionsDirty(false);
4152 }
4153 
4154 void Document::updateAnnotatedRegions()
4155 {
4156     if (!hasAnnotatedRegions())
4157         return;
4158 
4159     Vector&lt;AnnotatedRegionValue&gt; newRegions;
4160     renderBox()-&gt;collectAnnotatedRegions(newRegions); // FIXME.
4161     if (newRegions == annotatedRegions())
4162         return;
4163 
4164     setAnnotatedRegions(newRegions);
4165 
4166     if (Page* page = this-&gt;page())
4167         page-&gt;chrome().client().annotatedRegionsChanged();
4168 }
4169 #endif
4170 
4171 void Document::invalidateRenderingDependentRegions(AnnotationsAction annotationsAction)
4172 {
4173 #if ENABLE(DASHBOARD_SUPPORT)
4174     // FIXME: we don&#39;t have a good invalidation/update policy for Dashboard regions. They get eagerly updated
4175     // on forced layouts, and don&#39;t need to be.
4176     if (annotationsAction == AnnotationsAction::Update)
4177         updateAnnotatedRegions();
4178     else
4179         setAnnotatedRegionsDirty();
4180 #else
4181     UNUSED_PARAM(annotationsAction);
4182 #endif
4183 
4184 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4185     setTouchEventRegionsNeedUpdate();
4186 #endif
4187 
4188 #if ENABLE(POINTER_EVENTS)
4189     if (auto* page = this-&gt;page()) {
4190         if (auto* frameView = view()) {
4191             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4192                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4193         }
4194     }
4195 #endif
4196 }
4197 
4198 void Document::invalidateScrollbarDependentRegions()
4199 {
4200 #if ENABLE(DASHBOARD_SUPPORT)
4201     if (hasAnnotatedRegions())
4202         setAnnotatedRegionsDirty();
4203 #endif
4204 }
4205 
4206 void Document::updateZOrderDependentRegions()
4207 {
4208 #if ENABLE(DASHBOARD_SUPPORT)
4209     if (annotatedRegionsDirty())
4210         updateAnnotatedRegions();
4211 #endif
4212 }
4213 
4214 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4215 {
4216     RefPtr&lt;Element&gt; newFocusedElement = element;
4217     // Make sure newFocusedElement is actually in this document
4218     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4219         return true;
4220 
4221     if (m_focusedElement == newFocusedElement)
4222         return true;
4223 
4224     if (pageCacheState() != NotInPageCache)
4225         return false;
4226 
4227     bool focusChangeBlocked = false;
4228     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4229 
4230     // Remove focus from the existing focus node (if any)
4231     if (oldFocusedElement) {
4232         oldFocusedElement-&gt;setFocus(false);
4233         setFocusNavigationStartingNode(nullptr);
4234 
4235         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4236             // Dispatch a change event for form control elements that have been edited.
4237             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4238                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4239                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4240                     formControlElement.dispatchFormControlChangeEvent();
4241             }
4242 
4243             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4244             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
4245 
4246             if (m_focusedElement) {
4247                 // handler shifted focus
4248                 focusChangeBlocked = true;
4249                 newFocusedElement = nullptr;
4250             }
4251 
4252             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().focusoutEvent, newFocusedElement.copyRef()); // DOM level 3 name for the bubbling blur event.
4253             // FIXME: We should remove firing DOMFocusOutEvent event when we are sure no content depends
4254             // on it, probably when &lt;rdar://problem/8503958&gt; is resolved.
4255             oldFocusedElement-&gt;dispatchFocusOutEvent(eventNames().DOMFocusOutEvent, newFocusedElement.copyRef()); // DOM level 2 name for compatibility.
4256 
4257             if (m_focusedElement) {
4258                 // handler shifted focus
4259                 focusChangeBlocked = true;
4260                 newFocusedElement = nullptr;
4261             }
4262         } else {
4263             // Match the order in HTMLTextFormControlElement::dispatchBlurEvent.
4264             if (is&lt;HTMLInputElement&gt;(*oldFocusedElement))
4265                 downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).endEditing();
4266             if (page())
4267                 page()-&gt;chrome().client().elementDidBlur(*oldFocusedElement);
4268             ASSERT(!m_focusedElement);
4269         }
4270 
4271         if (oldFocusedElement-&gt;isRootEditableElement())
4272             frame()-&gt;editor().didEndEditing();
4273 
4274         if (view()) {
4275             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4276                 oldWidget-&gt;setFocus(false);
4277             else
4278                 view()-&gt;setFocus(false);
4279         }
4280 
4281         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4282             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4283             // FIXME: This could be done asynchronusly.
4284             // Updating style may dispatch events due to PostResolutionCallback
4285             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4286                 updateStyleIfNeeded();
4287             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4288         }
4289     }
4290 
4291     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
4292         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4293             // delegate blocks focus change
4294             focusChangeBlocked = true;
4295             goto SetFocusedNodeDone;
4296         }
4297         // Set focus on the new node
4298         m_focusedElement = newFocusedElement;
4299         setFocusNavigationStartingNode(m_focusedElement.get());
4300 
4301         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4302         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4303 
4304         if (m_focusedElement != newFocusedElement) {
4305             // handler shifted focus
4306             focusChangeBlocked = true;
4307             goto SetFocusedNodeDone;
4308         }
4309 
4310         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4311 
4312         if (m_focusedElement != newFocusedElement) {
4313             // handler shifted focus
4314             focusChangeBlocked = true;
4315             goto SetFocusedNodeDone;
4316         }
4317 
4318         // FIXME: We should remove firing DOMFocusInEvent event when we are sure no content depends
4319         // on it, probably when &lt;rdar://problem/8503958&gt; is m.
4320         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().DOMFocusInEvent, oldFocusedElement.copyRef()); // DOM level 2 for compatibility.
4321 
4322         if (m_focusedElement != newFocusedElement) {
4323             // handler shifted focus
4324             focusChangeBlocked = true;
4325             goto SetFocusedNodeDone;
4326         }
4327 
4328         m_focusedElement-&gt;setFocus(true);
4329 
4330         // The setFocus call triggers a blur and a focus event. Event handlers could cause the focused element to be cleared.
4331         if (m_focusedElement != newFocusedElement) {
4332             // handler shifted focus
4333             focusChangeBlocked = true;
4334             goto SetFocusedNodeDone;
4335         }
4336 
4337         if (m_focusedElement-&gt;isRootEditableElement())
4338             frame()-&gt;editor().didBeginEditing();
4339 
4340         // eww, I suck. set the qt focus correctly
4341         // ### find a better place in the code for this
4342         if (view()) {
4343             Widget* focusWidget = widgetForElement(m_focusedElement.get());
4344             if (focusWidget) {
4345                 // Make sure a widget has the right size before giving it focus.
4346                 // Otherwise, we are testing edge cases of the Widget code.
4347                 // Specifically, in WebCore this does not work well for text fields.
4348                 updateLayout();
4349                 // Re-get the widget in case updating the layout changed things.
4350                 focusWidget = widgetForElement(m_focusedElement.get());
4351             }
4352             if (focusWidget)
4353                 focusWidget-&gt;setFocus(true);
4354             else if (auto* frameView = view())
4355                 frameView-&gt;setFocus(true);
4356         }
4357     }
4358 
4359     if (!focusChangeBlocked &amp;&amp; m_focusedElement) {
4360         // Create the AXObject cache in a focus change because GTK relies on it.
4361         if (AXObjectCache* cache = axObjectCache())
4362             cache-&gt;deferFocusedUIElementChangeIfNeeded(oldFocusedElement.get(), newFocusedElement.get());
4363     }
4364 
4365     if (!focusChangeBlocked &amp;&amp; page())
4366         page()-&gt;chrome().focusedElementChanged(m_focusedElement.get());
4367 
4368 SetFocusedNodeDone:
4369     // Updating style may dispatch events due to PostResolutionCallback
4370     // FIXME: Why is synchronous style update needed here at all?
4371     if (eventsMode == FocusRemovalEventsMode::Dispatch)
4372         updateStyleIfNeeded();
4373     return !focusChangeBlocked;
4374 }
4375 
4376 static bool shouldResetFocusNavigationStartingNode(Node&amp; node)
4377 {
4378     // Setting focus navigation starting node to the following nodes means that we should start
4379     // the search from the beginning of the document.
4380     return is&lt;HTMLHtmlElement&gt;(node) || is&lt;HTMLDocument&gt;(node);
4381 }
4382 
4383 void Document::setFocusNavigationStartingNode(Node* node)
4384 {
4385     if (!m_frame)
4386         return;
4387 
4388     m_focusNavigationStartingNodeIsRemoved = false;
4389     if (!node || shouldResetFocusNavigationStartingNode(*node)) {
4390         m_focusNavigationStartingNode = nullptr;
4391         return;
4392     }
4393 
4394     ASSERT(!node || node != this);
4395     m_focusNavigationStartingNode = node;
4396 }
4397 
4398 Element* Document::focusNavigationStartingNode(FocusDirection direction) const
4399 {
4400     if (m_focusedElement) {
4401         if (!m_focusNavigationStartingNode || !m_focusNavigationStartingNode-&gt;isDescendantOf(m_focusedElement.get()))
4402             return m_focusedElement.get();
4403     }
4404 
4405     if (!m_focusNavigationStartingNode)
4406         return nullptr;
4407 
4408     Node* node = m_focusNavigationStartingNode.get();
4409 
4410     // When the node was removed from the document tree. This case is not specified in the spec:
4411     // https://html.spec.whatwg.org/multipage/interaction.html#sequential-focus-navigation-starting-point
4412     // Current behaivor is to move the sequential navigation node to / after (based on the focus direction)
4413     // the previous sibling of the removed node.
4414     if (m_focusNavigationStartingNodeIsRemoved) {
4415         Node* nextNode = NodeTraversal::next(*node);
4416         if (!nextNode)
4417             nextNode = node;
4418         if (direction == FocusDirectionForward)
4419             return ElementTraversal::previous(*nextNode);
4420         if (is&lt;Element&gt;(*nextNode))
4421             return downcast&lt;Element&gt;(nextNode);
4422         return ElementTraversal::next(*nextNode);
4423     }
4424 
4425     if (is&lt;Element&gt;(*node))
4426         return downcast&lt;Element&gt;(node);
4427     if (Element* elementBeforeNextFocusableElement = direction == FocusDirectionForward ? ElementTraversal::previous(*node) : ElementTraversal::next(*node))
4428         return elementBeforeNextFocusableElement;
4429     return node-&gt;parentOrShadowHostElement();
4430 }
4431 
4432 void Document::setCSSTarget(Element* targetNode)
4433 {
4434     if (m_cssTarget)
4435         m_cssTarget-&gt;invalidateStyleForSubtree();
4436     m_cssTarget = targetNode;
4437     if (targetNode)
4438         targetNode-&gt;invalidateStyleForSubtree();
4439 }
4440 
4441 void Document::registerNodeListForInvalidation(LiveNodeList&amp; list)
4442 {
4443     m_nodeListAndCollectionCounts[list.invalidationType()]++;
4444     if (!list.isRootedAtDocument())
4445         return;
4446     ASSERT(!list.isRegisteredForInvalidationAtDocument());
4447     list.setRegisteredForInvalidationAtDocument(true);
4448     m_listsInvalidatedAtDocument.add(&amp;list);
4449 }
4450 
4451 void Document::unregisterNodeListForInvalidation(LiveNodeList&amp; list)
4452 {
4453     m_nodeListAndCollectionCounts[list.invalidationType()]--;
4454     if (!list.isRegisteredForInvalidationAtDocument())
4455         return;
4456 
4457     list.setRegisteredForInvalidationAtDocument(false);
4458     ASSERT(m_listsInvalidatedAtDocument.contains(&amp;list));
4459     m_listsInvalidatedAtDocument.remove(&amp;list);
4460 }
4461 
4462 void Document::registerCollection(HTMLCollection&amp; collection)
4463 {
4464     m_nodeListAndCollectionCounts[collection.invalidationType()]++;
4465     if (collection.isRootedAtDocument())
4466         m_collectionsInvalidatedAtDocument.add(&amp;collection);
4467 }
4468 
4469 void Document::unregisterCollection(HTMLCollection&amp; collection)
4470 {
4471     ASSERT(m_nodeListAndCollectionCounts[collection.invalidationType()]);
4472     m_nodeListAndCollectionCounts[collection.invalidationType()]--;
4473     if (!collection.isRootedAtDocument())
4474         return;
4475 
4476     m_collectionsInvalidatedAtDocument.remove(&amp;collection);
4477 }
4478 
4479 void Document::collectionCachedIdNameMap(const HTMLCollection&amp; collection)
4480 {
4481     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4482     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]++;
4483 }
4484 
4485 void Document::collectionWillClearIdNameMap(const HTMLCollection&amp; collection)
4486 {
4487     ASSERT_UNUSED(collection, collection.hasNamedElementCache());
4488     ASSERT(m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]);
4489     m_nodeListAndCollectionCounts[InvalidateOnIdNameAttrChange]--;
4490 }
4491 
4492 void Document::attachNodeIterator(NodeIterator&amp; iterator)
4493 {
4494     m_nodeIterators.add(&amp;iterator);
4495 }
4496 
4497 void Document::detachNodeIterator(NodeIterator&amp; iterator)
4498 {
4499     // The node iterator can be detached without having been attached if its root node didn&#39;t have a document
4500     // when the iterator was created, but has it now.
4501     m_nodeIterators.remove(&amp;iterator);
4502 }
4503 
4504 void Document::moveNodeIteratorsToNewDocumentSlowCase(Node&amp; node, Document&amp; newDocument)
4505 {
4506     ASSERT(!m_nodeIterators.isEmpty());
4507     for (auto* iterator : copyToVector(m_nodeIterators)) {
4508         if (&amp;iterator-&gt;root() == &amp;node) {
4509             detachNodeIterator(*iterator);
4510             newDocument.attachNodeIterator(*iterator);
4511         }
4512     }
4513 }
4514 
4515 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4516 {
4517     for (auto* range : m_ranges)
4518         range-&gt;nodeChildrenChanged(container);
4519 }
4520 
4521 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4522 {
4523     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4524 
4525     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4526     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4527 
4528 #if ENABLE(FULLSCREEN_API)
4529     adjustFullScreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4530 #endif
4531 
4532     for (auto* range : m_ranges)
4533         range-&gt;nodeChildrenWillBeRemoved(container);
4534 
4535     for (auto* it : m_nodeIterators) {
4536         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4537             it-&gt;nodeWillBeRemoved(*n);
4538     }
4539 
4540     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4541         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4542             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4543             frame-&gt;selection().nodeWillBeRemoved(*n);
4544             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4545         }
4546     }
4547 
4548     if (m_markers-&gt;hasMarkers()) {
4549         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4550             m_markers-&gt;removeMarkers(*textNode);
4551     }
4552 }
4553 
4554 void Document::nodeWillBeRemoved(Node&amp; node)
4555 {
4556     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4557 
4558     adjustFocusedNodeOnNodeRemoval(node);
4559     adjustFocusNavigationNodeOnNodeRemoval(node);
4560 
4561 #if ENABLE(FULLSCREEN_API)
4562     adjustFullScreenElementOnNodeRemoval(node);
4563 #endif
4564 
4565     for (auto* it : m_nodeIterators)
4566         it-&gt;nodeWillBeRemoved(node);
4567 
4568     for (auto* range : m_ranges)
4569         range-&gt;nodeWillBeRemoved(node);
4570 
4571     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4572         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4573         frame-&gt;selection().nodeWillBeRemoved(node);
4574         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4575     }
4576 
4577     if (is&lt;Text&gt;(node))
4578         m_markers-&gt;removeMarkers(node);
4579 
4580 #if ENABLE(POINTER_EVENTS)
4581     if (m_touchActionElements &amp;&amp; is&lt;Element&gt;(node))
4582         m_touchActionElements-&gt;remove(&amp;downcast&lt;Element&gt;(node));
4583 #endif
4584 }
4585 
4586 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4587 {
4588     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4589 }
4590 
4591 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4592 {
4593     if (!m_focusNavigationStartingNode)
4594         return;
4595 
4596     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4597         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4598         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4599         m_focusNavigationStartingNodeIsRemoved = true;
4600     }
4601 }
4602 
4603 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4604 {
4605     if (!m_ranges.isEmpty()) {
4606         for (auto* range : m_ranges)
4607             range-&gt;textInserted(text, offset, length);
4608     }
4609 
4610     // Update the markers for spelling and grammar checking.
4611     m_markers-&gt;shiftMarkers(text, offset, length);
4612 }
4613 
4614 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4615 {
4616     if (!m_ranges.isEmpty()) {
4617         for (auto* range : m_ranges)
4618             range-&gt;textRemoved(text, offset, length);
4619     }
4620 
4621     // Update the markers for spelling and grammar checking.
4622     m_markers-&gt;removeMarkers(text, offset, length);
4623     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4624 }
4625 
4626 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4627 {
4628     if (!m_ranges.isEmpty()) {
4629         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4630         for (auto* range : m_ranges)
4631             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
4632     }
4633 
4634     // FIXME: This should update markers for spelling and grammar checking.
4635 }
4636 
4637 void Document::textNodeSplit(Text&amp; oldNode)
4638 {
4639     for (auto* range : m_ranges)
4640         range-&gt;textNodeSplit(oldNode);
4641 
4642     // FIXME: This should update markers for spelling and grammar checking.
4643 }
4644 
4645 void Document::createDOMWindow()
4646 {
4647     ASSERT(m_frame);
4648     ASSERT(!m_domWindow);
4649 
4650     m_domWindow = DOMWindow::create(*this);
4651 
4652     ASSERT(m_domWindow-&gt;document() == this);
4653     ASSERT(m_domWindow-&gt;frame() == m_frame);
4654 
4655     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4656 }
4657 
4658 void Document::takeDOMWindowFrom(Document&amp; document)
4659 {
4660     ASSERT(m_frame);
4661     ASSERT(!m_domWindow);
4662     ASSERT(document.m_domWindow);
4663     // A valid DOMWindow is needed by CachedFrame for its documents.
4664     ASSERT(pageCacheState() == NotInPageCache);
4665 
4666     m_domWindow = WTFMove(document.m_domWindow);
4667     m_domWindow-&gt;didSecureTransitionTo(*this);
4668 
4669     ASSERT(m_domWindow-&gt;document() == this);
4670     ASSERT(m_domWindow-&gt;frame() == m_frame);
4671 }
4672 
4673 WindowProxy* Document::windowProxy() const
4674 {
4675     if (!m_frame)
4676         return nullptr;
4677     return &amp;m_frame-&gt;windowProxy();
4678 }
4679 
4680 Document&amp; Document::contextDocument() const
4681 {
4682     if (m_contextDocument)
4683         return *m_contextDocument.get();
4684     return const_cast&lt;Document&amp;&gt;(*this);
4685 }
4686 
4687 void Document::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4688 {
4689     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4690 }
4691 
4692 void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4693 {
4694     if (!m_domWindow)
4695         return;
4696     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4697 }
4698 
4699 void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4700 {
4701     if (!m_domWindow)
4702         return;
4703     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4704 }
4705 
4706 EventListener* Document::getWindowAttributeEventListener(const AtomicString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4707 {
4708     if (!m_domWindow)
4709         return nullptr;
4710     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4711 }
4712 
4713 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4714 {
4715     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4716     if (!m_domWindow)
4717         return;
4718     m_domWindow-&gt;dispatchEvent(event, target);
4719 }
4720 
4721 void Document::dispatchWindowLoadEvent()
4722 {
4723     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4724     if (!m_domWindow)
4725         return;
4726     m_domWindow-&gt;dispatchLoadEvent();
4727     m_loadEventFinished = true;
4728     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4729 }
4730 
4731 void Document::enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4732 {
4733     event-&gt;setTarget(m_domWindow.get());
4734     m_eventQueue.enqueueEvent(WTFMove(event));
4735 }
4736 
4737 void Document::enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp; event)
4738 {
4739     event-&gt;setTarget(this);
4740     m_eventQueue.enqueueEvent(WTFMove(event));
4741 }
4742 
4743 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4744 {
4745     m_eventQueue.enqueueEvent(WTFMove(event));
4746 }
4747 
4748 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4749 {
4750     // Please do *not* add new event classes to this function unless they are required
4751     // for compatibility with the DOM specification or some actual legacy web content.
4752 
4753     // This mechanism is superceded by use of event constructors.
4754     // That is what we should use for any new event classes.
4755 
4756     // The following strings are the ones from the DOM specification
4757     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4758 
4759     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4760         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4761     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4762         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4763     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4764         return Ref&lt;Event&gt; { CustomEvent::create() };
4765     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4766         return Event::createForBindings();
4767     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4768         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4769     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4770         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4771     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4772         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4773     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4774         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4775     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4776         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4777     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4778         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4779     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4780         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4781     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4782         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4783 
4784     // FIXME: Consider including support for these event classes even when device orientation
4785     // support is not enabled.
4786 #if ENABLE(DEVICE_ORIENTATION)
4787     if (equalLettersIgnoringASCIICase(type, &quot;devicemotionevent&quot;))
4788         return Ref&lt;Event&gt; { DeviceMotionEvent::createForBindings() };
4789     if (equalLettersIgnoringASCIICase(type, &quot;deviceorientationevent&quot;))
4790         return Ref&lt;Event&gt; { DeviceOrientationEvent::createForBindings() };
4791 #endif
4792 
4793 #if ENABLE(TOUCH_EVENTS)
4794     if (equalLettersIgnoringASCIICase(type, &quot;touchevent&quot;))
4795         return Ref&lt;Event&gt; { TouchEvent::createForBindings() };
4796 #endif
4797 
4798     // FIXME: Add support for &quot;dragevent&quot;, which the DOM specification calls for.
4799 
4800     // The following string comes from the SVG specification
4801     // &lt;http://www.w3.org/TR/SVG/script.html#InterfaceSVGZoomEvent&gt;
4802     // However, since there is no provision for initializing the event once it is created,
4803     // there is no practical value in this feature.
4804     // FIXME: Confirm there is no content depending on this and remove it.
4805 
4806     if (equalLettersIgnoringASCIICase(type, &quot;svgzoomevents&quot;))
4807         return Ref&lt;Event&gt; { SVGZoomEvent::createForBindings() };
4808 
4809     // The following strings are not part of the DOM specification and we would like to eliminate them.
4810     // However, we currently include them until we resolve any issues with backward compatibility.
4811     // FIXME: For each of the strings below, confirm that there is no content depending on it and remove
4812     // the string, remove the createForBindings function, and also consider removing the corresponding
4813     // init function for that class.
4814 
4815     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevents&quot;))
4816         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4817     if (equalLettersIgnoringASCIICase(type, &quot;mutationevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mutationevents&quot;))
4818         return Ref&lt;Event&gt; { MutationEvent::createForBindings() };
4819     if (equalLettersIgnoringASCIICase(type, &quot;overflowevent&quot;))
4820         return Ref&lt;Event&gt; { OverflowEvent::createForBindings() };
4821     if (equalLettersIgnoringASCIICase(type, &quot;popstateevent&quot;))
4822         return Ref&lt;Event&gt; { PopStateEvent::createForBindings() };
4823     if (equalLettersIgnoringASCIICase(type, &quot;wheelevent&quot;))
4824         return Ref&lt;Event&gt; { WheelEvent::createForBindings() };
4825 
4826     return Exception { NotSupportedError };
4827 }
4828 
4829 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4830 {
4831     switch (eventType) {
4832     case PlatformEvent::MouseForceChanged:
4833         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4834     case PlatformEvent::MouseForceDown:
4835         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4836     case PlatformEvent::MouseForceUp:
4837         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4838     case PlatformEvent::MouseScroll:
4839         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4840     default:
4841         return false;
4842     }
4843 }
4844 
4845 void Document::addListenerTypeIfNeeded(const AtomicString&amp; eventType)
4846 {
4847     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4848         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4849     else if (eventType == eventNames().DOMNodeInsertedEvent)
4850         addListenerType(DOMNODEINSERTED_LISTENER);
4851     else if (eventType == eventNames().DOMNodeRemovedEvent)
4852         addListenerType(DOMNODEREMOVED_LISTENER);
4853     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4854         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4855     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4856         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4857     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4858         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4859     else if (eventType == eventNames().overflowchangedEvent)
4860         addListenerType(OVERFLOWCHANGED_LISTENER);
4861     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4862         addListenerType(ANIMATIONSTART_LISTENER);
4863     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4864         addListenerType(ANIMATIONEND_LISTENER);
4865     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
4866         addListenerType(ANIMATIONITERATION_LISTENER);
4867     else if (eventType == eventNames().webkitTransitionEndEvent || eventType == eventNames().transitionendEvent)
4868         addListenerType(TRANSITIONEND_LISTENER);
4869     else if (eventType == eventNames().beforeloadEvent)
4870         addListenerType(BEFORELOAD_LISTENER);
4871     else if (eventType == eventNames().scrollEvent)
4872         addListenerType(SCROLL_LISTENER);
4873     else if (eventType == eventNames().webkitmouseforcewillbeginEvent)
4874         addListenerType(FORCEWILLBEGIN_LISTENER);
4875     else if (eventType == eventNames().webkitmouseforcechangedEvent)
4876         addListenerType(FORCECHANGED_LISTENER);
4877     else if (eventType == eventNames().webkitmouseforcedownEvent)
4878         addListenerType(FORCEDOWN_LISTENER);
4879     else if (eventType == eventNames().webkitmouseforceupEvent)
4880         addListenerType(FORCEUP_LISTENER);
4881     else if (eventType == eventNames().resizeEvent)
4882         addListenerType(RESIZE_LISTENER);
4883 }
4884 
4885 HTMLFrameOwnerElement* Document::ownerElement() const
4886 {
4887     if (!frame())
4888         return nullptr;
4889     return frame()-&gt;ownerElement();
4890 }
4891 
4892 // https://html.spec.whatwg.org/#cookie-averse-document-object
4893 bool Document::isCookieAverse() const
4894 {
4895     // A Document that has no browsing context is cookie-averse.
4896     if (!frame())
4897         return true;
4898 
4899     URL cookieURL = this-&gt;cookieURL();
4900 
4901     // This is not part of the specification but we have historically allowed cookies over file protocol
4902     // and some developers rely on this for testing.
4903     if (cookieURL.isLocalFile())
4904         return false;
4905 
4906     // A Document whose URL&#39;s scheme is not a network scheme is cookie-averse (https://fetch.spec.whatwg.org/#network-scheme).
4907     return !cookieURL.protocolIsInHTTPFamily() &amp;&amp; !cookieURL.protocolIs(&quot;ftp&quot;);
4908 }
4909 
4910 ExceptionOr&lt;String&gt; Document::cookie()
4911 {
4912     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
4913         return String();
4914 
4915     if (isCookieAverse())
4916         return String();
4917 
4918     if (!securityOrigin().canAccessCookies())
4919         return Exception { SecurityError };
4920 
4921     URL cookieURL = this-&gt;cookieURL();
4922     if (cookieURL.isEmpty())
4923         return String();
4924 
4925     if (!isDOMCookieCacheValid() &amp;&amp; page())
4926         setCachedDOMCookies(page()-&gt;cookieJar().cookies(*this, cookieURL));
4927 
4928     return String { cachedDOMCookies() };
4929 }
4930 
4931 ExceptionOr&lt;void&gt; Document::setCookie(const String&amp; value)
4932 {
4933     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
4934         return { };
4935 
4936     if (isCookieAverse())
4937         return { };
4938 
4939     if (!securityOrigin().canAccessCookies())
4940         return Exception { SecurityError };
4941 
4942     URL cookieURL = this-&gt;cookieURL();
4943     if (cookieURL.isEmpty())
4944         return { };
4945 
4946     invalidateDOMCookieCache();
4947     if (page())
4948         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
4949     return { };
4950 }
4951 
4952 String Document::referrer() const
4953 {
4954     if (frame())
4955         return frame()-&gt;loader().referrer();
4956     return String();
4957 }
4958 
4959 String Document::origin() const
4960 {
4961     return securityOrigin().toString();
4962 }
4963 
4964 String Document::domain() const
4965 {
4966     return securityOrigin().domain();
4967 }
4968 
4969 bool Document::domainIsRegisterable(const String&amp; newDomain) const
4970 {
4971     if (newDomain.isEmpty())
4972         return false;
4973 
4974     const String&amp; effectiveDomain = domain();
4975 
4976     // If the new domain is the same as the old domain, return true so that
4977     // we still call securityOrigin().setDomainForDOM. This will change the
4978     // security check behavior. For example, if a page loaded on port 8000
4979     // assigns its current domain using document.domain, the page will
4980     // allow other pages loaded on different ports in the same domain that
4981     // have also assigned to access this page.
4982     if (equalIgnoringASCIICase(effectiveDomain, newDomain))
4983         return true;
4984 
4985     // e.g. newDomain = webkit.org (10) and domain() = www.webkit.org (14)
4986     unsigned oldLength = effectiveDomain.length();
4987     unsigned newLength = newDomain.length();
4988     if (newLength &gt;= oldLength)
4989         return false;
4990 
4991     auto ipAddressSetting = settings().treatIPAddressAsDomain() ? OriginAccessEntry::TreatIPAddressAsDomain : OriginAccessEntry::TreatIPAddressAsIPAddress;
4992     OriginAccessEntry accessEntry { securityOrigin().protocol(), newDomain, OriginAccessEntry::AllowSubdomains, ipAddressSetting };
4993     if (!accessEntry.matchesOrigin(securityOrigin()))
4994         return false;
4995 
4996     if (effectiveDomain[oldLength - newLength - 1] != &#39;.&#39;)
4997         return false;
4998     if (StringView { effectiveDomain }.substring(oldLength - newLength) != newDomain)
4999         return false;
5000 
5001     auto potentialPublicSuffix = newDomain;
5002     if (potentialPublicSuffix.startsWith(&#39;.&#39;))
5003         potentialPublicSuffix.remove(0, 1);
5004 
5005 #if ENABLE(PUBLIC_SUFFIX_LIST)
5006     return !isPublicSuffix(potentialPublicSuffix);
5007 #else
5008     return true;
5009 #endif
5010 }
5011 
5012 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
5013 {
5014     if (!frame())
5015         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
5016 
5017     if (isSandboxed(SandboxDocumentDomain))
5018         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
5019 
5020     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
5021         return Exception { SecurityError };
5022 
5023     // FIXME: We should add logging indicating why a domain was not allowed.
5024 
5025     const String&amp; effectiveDomain = domain();
5026     if (effectiveDomain.isEmpty())
5027         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
5028 
5029     if (!domainIsRegisterable(newDomain))
5030         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
5031 
5032     securityOrigin().setDomainFromDOM(newDomain);
5033     return { };
5034 }
5035 
5036 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
5037 {
5038     m_overrideLastModified = lastModified;
5039 }
5040 
5041 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
5042 String Document::lastModified() const
5043 {
5044     Optional&lt;WallTime&gt; dateTime;
5045     if (m_overrideLastModified)
5046         dateTime = m_overrideLastModified;
5047     else if (loader())
5048         dateTime = loader()-&gt;response().lastModified();
5049 
5050     // FIXME: If this document came from the file system, the HTML specification tells
5051     // us to read the last modification date from the file system.
5052     if (!dateTime)
5053         dateTime = WallTime::now();
5054 
5055     auto ctime = dateTime.value().secondsSinceEpoch().secondsAs&lt;time_t&gt;();
5056     auto localDateTime = std::localtime(&amp;ctime);
5057     return makeString(pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mon + 1), &#39;/&#39;,
5058         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_mday), &#39;/&#39;,
5059         pad(&#39;0&#39;, 4, 1900 + localDateTime-&gt;tm_year), &#39; &#39;,
5060         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_hour), &#39;:&#39;,
5061         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_min), &#39;:&#39;,
5062         pad(&#39;0&#39;, 2, localDateTime-&gt;tm_sec));
5063 }
5064 
5065 void Document::setCookieURL(const URL&amp; url)
5066 {
5067     if (m_cookieURL == url)
5068         return;
5069     m_cookieURL = url;
5070     invalidateDOMCookieCache();
5071 }
5072 
5073 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
5074 {
5075     if (!isValidNameStart(characters[0]))
5076         return false;
5077 
5078     for (unsigned i = 1; i &lt; length; ++i) {
5079         if (!isValidNamePart(characters[i]))
5080             return false;
5081     }
5082 
5083     return true;
5084 }
5085 
5086 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
5087 {
5088     unsigned i = 0;
5089 
5090     UChar32 c;
5091     U16_NEXT(characters, i, length, c)
5092     if (!isValidNameStart(c))
5093         return false;
5094 
5095     while (i &lt; length) {
5096         U16_NEXT(characters, i, length, c)
5097         if (!isValidNamePart(c))
5098             return false;
5099     }
5100 
5101     return true;
5102 }
5103 
5104 template&lt;typename CharType&gt;
5105 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
5106 {
5107     CharType c = characters[0];
5108     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
5109         return false;
5110 
5111     for (unsigned i = 1; i &lt; length; ++i) {
5112         c = characters[i];
5113         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
5114             return false;
5115     }
5116 
5117     return true;
5118 }
5119 
5120 bool Document::isValidName(const String&amp; name)
5121 {
5122     unsigned length = name.length();
5123     if (!length)
5124         return false;
5125 
5126     if (name.is8Bit()) {
5127         const LChar* characters = name.characters8();
5128 
5129         if (isValidNameASCII(characters, length))
5130             return true;
5131 
5132         return isValidNameNonASCII(characters, length);
5133     }
5134 
5135     const UChar* characters = name.characters16();
5136 
5137     if (isValidNameASCII(characters, length))
5138         return true;
5139 
5140     return isValidNameNonASCII(characters, length);
5141 }
5142 
5143 ExceptionOr&lt;std::pair&lt;AtomicString, AtomicString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5144 {
5145     unsigned length = qualifiedName.length();
5146 
5147     if (!length)
5148         return Exception { InvalidCharacterError };
5149 
5150     bool nameStart = true;
5151     bool sawColon = false;
5152     unsigned colonPosition = 0;
5153 
5154     for (unsigned i = 0; i &lt; length; ) {
5155         UChar32 c;
5156         U16_NEXT(qualifiedName, i, length, c)
5157         if (c == &#39;:&#39;) {
5158             if (sawColon)
5159                 return Exception { InvalidCharacterError };
5160             nameStart = true;
5161             sawColon = true;
5162             colonPosition = i - 1;
5163         } else if (nameStart) {
5164             if (!isValidNameStart(c))
5165                 return Exception { InvalidCharacterError };
5166             nameStart = false;
5167         } else {
5168             if (!isValidNamePart(c))
5169                 return Exception { InvalidCharacterError };
5170         }
5171     }
5172 
5173     if (!sawColon)
5174         return std::pair&lt;AtomicString, AtomicString&gt; { { }, { qualifiedName } };
5175 
5176     if (!colonPosition || length - colonPosition &lt;= 1)
5177         return Exception { InvalidCharacterError };
5178 
5179     return std::pair&lt;AtomicString, AtomicString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomicString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomicString() };
5180 }
5181 
5182 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)
5183 {
5184     auto parseResult = parseQualifiedName(qualifiedName);
5185     if (parseResult.hasException())
5186         return parseResult.releaseException();
5187     auto parsedPieces = parseResult.releaseReturnValue();
5188     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5189 }
5190 
5191 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5192 {
5193     m_decoder = WTFMove(decoder);
5194 }
5195 
5196 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const
5197 {
5198     // Always return a null URL when passed a null string.
5199     // FIXME: Should we change the URL constructor to have this behavior?
5200     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5201     if (url.isNull())
5202         return URL();
5203     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5204     if (!m_decoder)
5205         return URL(baseURL, url);
5206     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5207 }
5208 
5209 URL Document::completeURL(const String&amp; url) const
5210 {
5211     return completeURL(url, m_baseURL);
5212 }
5213 
5214 PAL::SessionID Document::sessionID() const
5215 {
5216     if (m_sessionID.isValid())
5217         return m_sessionID;
5218 
5219     if (auto* page = this-&gt;page())
5220         m_sessionID = page-&gt;sessionID();
5221 
5222     return m_sessionID;
5223 }
5224 
5225 void Document::setPageCacheState(PageCacheState state)
5226 {
5227     if (m_pageCacheState == state)
5228         return;
5229 
5230     m_pageCacheState = state;
5231 
5232     FrameView* v = view();
5233     Page* page = this-&gt;page();
5234 
5235     switch (state) {
5236     case InPageCache:
5237         if (v) {
5238             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5239             // page cache and similar work that needs to occur when it comes out. This is where we do the work
5240             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5241             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5242             // called too early on in the process of a page exiting the cache for that work to be possible in this
5243             // function. It would be nice if there was more symmetry here.
5244             // https://bugs.webkit.org/show_bug.cgi?id=98698
5245             v-&gt;cacheCurrentScrollPosition();
5246             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5247                 v-&gt;resetScrollbarsAndClearContentsSize();
5248                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5249                     scrollingCoordinator-&gt;clearAllNodes();
5250             }
5251         }
5252 
5253 #if ENABLE(POINTER_LOCK)
5254         exitPointerLock();
5255 #endif
5256 
5257         styleScope().clearResolver();
5258         clearSelectorQueryCache();
5259         m_styleRecalcTimer.stop();
5260 
5261         clearSharedObjectPool();
5262         break;
5263     case NotInPageCache:
5264         if (childNeedsStyleRecalc())
5265             scheduleStyleRecalc();
5266         break;
5267     case AboutToEnterPageCache:
5268         break;
5269     }
5270 }
5271 
5272 void Document::documentWillBecomeInactive()
5273 {
5274     if (renderView())
5275         renderView()-&gt;setIsInWindow(false);
5276 }
5277 
5278 void Document::suspend(ReasonForSuspension reason)
5279 {
5280     if (m_isSuspended)
5281         return;
5282 
5283     documentWillBecomeInactive();
5284 
5285     for (auto* element : m_documentSuspensionCallbackElements)
5286         element-&gt;prepareForDocumentSuspension();
5287 
5288 #ifndef NDEBUG
5289     // Clear the update flag to be able to check if the viewport arguments update
5290     // is dispatched, after the document is restored from the page cache.
5291     m_didDispatchViewportPropertiesChanged = false;
5292 #endif
5293 
5294     ASSERT(page());
5295     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5296 
5297     if (RenderView* view = renderView()) {
5298         if (view-&gt;usesCompositing())
5299             view-&gt;compositor().cancelCompositingLayerUpdate();
5300     }
5301 
5302 #if USE(LIBWEBRTC)
5303     // FIXME: This should be moved to Modules/mediastream.
5304     if (LibWebRTCProvider::webRTCAvailable()) {
5305         if (auto* page = this-&gt;page())
5306             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5307     }
5308 #endif
5309 
5310 #if ENABLE(SERVICE_WORKER)
5311     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {
5312         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);
5313         setServiceWorkerConnection(nullptr);
5314     }
5315 #endif
5316 
5317     suspendScheduledTasks(reason);
5318 
5319     ASSERT(m_frame);
5320     m_frame-&gt;clearTimers();
5321 
5322     m_visualUpdatesAllowed = false;
5323     m_visualUpdatesSuppressionTimer.stop();
5324 
5325     m_isSuspended = true;
5326 }
5327 
5328 void Document::resume(ReasonForSuspension reason)
5329 {
5330     if (!m_isSuspended)
5331         return;
5332 
5333     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5334         element-&gt;resumeFromDocumentSuspension();
5335 
5336     if (renderView())
5337         renderView()-&gt;setIsInWindow(true);
5338 
5339     ASSERT(page());
5340     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5341 
5342     ASSERT(m_frame);
5343     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5344 
5345     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5346         if (auto* timeline = existingTimeline())
5347             timeline-&gt;resumeAnimations();
5348     } else
5349         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5350 
5351     resumeScheduledTasks(reason);
5352 
5353     m_visualUpdatesAllowed = true;
5354 
5355     m_isSuspended = false;
5356 
5357 #if ENABLE(SERVICE_WORKER)
5358     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {
5359         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);
5360         setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(sessionID()));
5361     }
5362 #endif
5363 }
5364 
5365 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5366 {
5367     m_documentSuspensionCallbackElements.add(&amp;element);
5368 }
5369 
5370 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5371 {
5372     m_documentSuspensionCallbackElements.remove(&amp;element);
5373 }
5374 
5375 void Document::mediaVolumeDidChange()
5376 {
5377     for (auto* element : m_mediaVolumeCallbackElements)
5378         element-&gt;mediaVolumeDidChange();
5379 }
5380 
5381 void Document::registerForMediaVolumeCallbacks(Element&amp; element)
5382 {
5383     m_mediaVolumeCallbackElements.add(&amp;element);
5384 }
5385 
5386 void Document::unregisterForMediaVolumeCallbacks(Element&amp; element)
5387 {
5388     m_mediaVolumeCallbackElements.remove(&amp;element);
5389 }
5390 
5391 bool Document::audioPlaybackRequiresUserGesture() const
5392 {
5393     if (DocumentLoader* loader = this-&gt;loader()) {
5394         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5395         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5396         if (policy != AutoplayPolicy::Default)
5397             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5398     }
5399 
5400     return settings().audioPlaybackRequiresUserGesture();
5401 }
5402 
5403 bool Document::videoPlaybackRequiresUserGesture() const
5404 {
5405     if (DocumentLoader* loader = this-&gt;loader()) {
5406         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5407         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5408         if (policy != AutoplayPolicy::Default)
5409             return policy == AutoplayPolicy::Deny;
5410     }
5411 
5412     return settings().videoPlaybackRequiresUserGesture();
5413 }
5414 
5415 void Document::storageBlockingStateDidChange()
5416 {
5417     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5418 }
5419 
5420 void Document::privateBrowsingStateDidChange()
5421 {
5422     m_sessionID = SessionID::emptySessionID();
5423     if (m_logger)
5424         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());
5425 
5426     for (auto* element : m_privateBrowsingStateChangedElements)
5427         element-&gt;privateBrowsingStateDidChange();
5428 
5429 #if ENABLE(SERVICE_WORKER)
5430     ASSERT(sessionID().isValid());
5431     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection &amp;&amp; sessionID().isValid())
5432         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID()));
5433 #endif
5434 }
5435 
5436 void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5437 {
5438     m_privateBrowsingStateChangedElements.add(&amp;element);
5439 }
5440 
5441 void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5442 {
5443     m_privateBrowsingStateChangedElements.remove(&amp;element);
5444 }
5445 
5446 #if ENABLE(VIDEO_TRACK)
5447 
5448 void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)
5449 {
5450     if (page())
5451         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5452 
5453     m_captionPreferencesChangedElements.add(&amp;element);
5454 }
5455 
5456 void Document::unregisterForCaptionPreferencesChangedCallbacks(Element&amp; element)
5457 {
5458     m_captionPreferencesChangedElements.remove(&amp;element);
5459 }
5460 
5461 void Document::captionPreferencesChanged()
5462 {
5463     for (auto* element : m_captionPreferencesChangedElements)
5464         element-&gt;captionPreferencesChanged();
5465 }
5466 
5467 #endif
5468 
5469 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
5470 
5471 void Document::registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)
5472 {
5473     m_pageScaleFactorChangedElements.add(&amp;element);
5474 }
5475 
5476 void Document::unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)
5477 {
5478     m_pageScaleFactorChangedElements.remove(&amp;element);
5479 }
5480 
5481 void Document::pageScaleFactorChangedAndStable()
5482 {
5483     for (HTMLMediaElement* mediaElement : m_pageScaleFactorChangedElements)
5484         mediaElement-&gt;pageScaleFactorChanged();
5485 }
5486 
5487 void Document::registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)
5488 {
5489     m_userInterfaceLayoutDirectionChangedElements.add(&amp;element);
5490 }
5491 
5492 void Document::unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)
5493 {
5494     m_userInterfaceLayoutDirectionChangedElements.remove(&amp;element);
5495 }
5496 
5497 void Document::userInterfaceLayoutDirectionChanged()
5498 {
5499     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)
5500         mediaElement-&gt;userInterfaceLayoutDirectionChanged();
5501 }
5502 
5503 #endif
5504 
5505 void Document::setShouldCreateRenderers(bool f)
5506 {
5507     m_createRenderers = f;
5508 }
5509 
5510 bool Document::shouldCreateRenderers()
5511 {
5512     return m_createRenderers;
5513 }
5514 
5515 // Support for Javascript execCommand, and related methods
5516 
5517 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5518 {
5519     RefPtr&lt;Frame&gt; frame = document-&gt;frame();
5520     if (!frame || frame-&gt;document() != document)
5521         return Editor::Command();
5522 
5523     document-&gt;updateStyleIfNeeded();
5524 
5525     return frame-&gt;editor().command(commandName,
5526         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5527 }
5528 
5529 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5530 {
5531     EventQueueScope eventQueueScope;
5532     return command(this, commandName, userInterface).execute(value);
5533 }
5534 
5535 bool Document::queryCommandEnabled(const String&amp; commandName)
5536 {
5537     return command(this, commandName).isEnabled();
5538 }
5539 
5540 bool Document::queryCommandIndeterm(const String&amp; commandName)
5541 {
5542     return command(this, commandName).state() == MixedTriState;
5543 }
5544 
5545 bool Document::queryCommandState(const String&amp; commandName)
5546 {
5547     return command(this, commandName).state() == TrueTriState;
5548 }
5549 
5550 bool Document::queryCommandSupported(const String&amp; commandName)
5551 {
5552     return command(this, commandName).isSupported();
5553 }
5554 
5555 String Document::queryCommandValue(const String&amp; commandName)
5556 {
5557     return command(this, commandName).value();
5558 }
5559 
5560 void Document::pushCurrentScript(HTMLScriptElement* newCurrentScript)
5561 {
5562     m_currentScriptStack.append(newCurrentScript);
5563 }
5564 
5565 void Document::popCurrentScript()
5566 {
5567     ASSERT(!m_currentScriptStack.isEmpty());
5568     m_currentScriptStack.removeLast();
5569 }
5570 
5571 bool Document::shouldDeferAsynchronousScriptsUntilParsingFinishes() const
5572 {
5573     return parsing() &amp;&amp; settings().shouldDeferAsynchronousScriptsUntilAfterDocumentLoad();
5574 }
5575 
5576 #if ENABLE(XSLT)
5577 
5578 void Document::scheduleToApplyXSLTransforms()
5579 {
5580     m_hasPendingXSLTransforms = true;
5581     if (!m_applyPendingXSLTransformsTimer.isActive())
5582         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
5583 }
5584 
5585 void Document::applyPendingXSLTransformsNowIfScheduled()
5586 {
5587     if (!m_hasPendingXSLTransforms)
5588         return;
5589     m_applyPendingXSLTransformsTimer.stop();
5590     applyPendingXSLTransformsTimerFired();
5591 }
5592 
5593 void Document::applyPendingXSLTransformsTimerFired()
5594 {
5595     if (parsing())
5596         return;
5597 
5598     m_hasPendingXSLTransforms = false;
5599     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
5600     for (auto&amp; processingInstruction : styleScope().collectXSLTransforms()) {
5601         ASSERT(processingInstruction-&gt;isXSL());
5602 
5603         // Don&#39;t apply XSL transforms to already transformed documents -- &lt;rdar://problem/4132806&gt;
5604         if (transformSourceDocument() || !processingInstruction-&gt;sheet())
5605             return;
5606 
5607         // If the Document has already been detached from the frame, or the frame is currently in the process of
5608         // changing to a new document, don&#39;t attempt to create a new Document from the XSLT.
5609         if (!frame() || frame()-&gt;documentIsBeingReplaced())
5610             return;
5611 
5612         auto processor = XSLTProcessor::create();
5613         processor-&gt;setXSLStyleSheet(downcast&lt;XSLStyleSheet&gt;(processingInstruction-&gt;sheet()));
5614         String resultMIMEType;
5615         String newSource;
5616         String resultEncoding;
5617         if (!processor-&gt;transformToString(*this, resultMIMEType, newSource, resultEncoding))
5618             continue;
5619         // FIXME: If the transform failed we should probably report an error (like Mozilla does).
5620         processor-&gt;createDocumentFromSource(newSource, resultEncoding, resultMIMEType, this, frame());
5621     }
5622 }
5623 
5624 void Document::setTransformSource(std::unique_ptr&lt;TransformSource&gt; source)
5625 {
5626     m_transformSource = WTFMove(source);
5627 }
5628 
5629 #endif
5630 
5631 void Document::setDesignMode(InheritedBool value)
5632 {
5633     m_designMode = value;
5634     for (Frame* frame = m_frame; frame &amp;&amp; frame-&gt;document(); frame = frame-&gt;tree().traverseNext(m_frame))
5635         frame-&gt;document()-&gt;scheduleFullStyleRebuild();
5636 }
5637 
5638 String Document::designMode() const
5639 {
5640     return inDesignMode() ? &quot;on&quot;_s : &quot;off&quot;_s;
5641 }
5642 
5643 void Document::setDesignMode(const String&amp; value)
5644 {
5645     InheritedBool mode;
5646     if (equalLettersIgnoringASCIICase(value, &quot;on&quot;))
5647         mode = on;
5648     else if (equalLettersIgnoringASCIICase(value, &quot;off&quot;))
5649         mode = off;
5650     else
5651         mode = inherit;
5652     setDesignMode(mode);
5653 }
5654 
5655 auto Document::getDesignMode() const -&gt; InheritedBool
5656 {
5657     return m_designMode;
5658 }
5659 
5660 bool Document::inDesignMode() const
5661 {
5662     for (const Document* d = this; d; d = d-&gt;parentDocument()) {
5663         if (d-&gt;m_designMode != inherit)
5664             return d-&gt;m_designMode;
5665     }
5666     return false;
5667 }
5668 
5669 Document* Document::parentDocument() const
5670 {
5671     if (!m_frame)
5672         return nullptr;
5673     Frame* parent = m_frame-&gt;tree().parent();
5674     if (!parent)
5675         return nullptr;
5676     return parent-&gt;document();
5677 }
5678 
5679 Document&amp; Document::topDocument() const
5680 {
5681     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5682     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5683     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5684         if (!m_frame)
5685             return const_cast&lt;Document&amp;&gt;(*this);
5686         // This should always be non-null.
5687         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5688         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5689     }
5690 
5691     Document* document = const_cast&lt;Document*&gt;(this);
5692     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5693         document = &amp;element-&gt;document();
5694     return *document;
5695 }
5696 
5697 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
5698 {
5699     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
5700 }
5701 
5702 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5703 {
5704     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5705     if (parseResult.hasException())
5706         return parseResult.releaseException();
5707     QualifiedName parsedName { parseResult.releaseReturnValue() };
5708     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5709         return Exception { NamespaceError };
5710     return Attr::create(*this, parsedName, emptyString());
5711 }
5712 
5713 const SVGDocumentExtensions* Document::svgExtensions()
5714 {
5715     return m_svgExtensions.get();
5716 }
5717 
5718 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5719 {
5720     if (!m_svgExtensions)
5721         m_svgExtensions = std::make_unique&lt;SVGDocumentExtensions&gt;(*this);
5722     return *m_svgExtensions;
5723 }
5724 
5725 void Document::addSVGUseElement(SVGUseElement&amp; element)
5726 {
5727     auto result = m_svgUseElements.add(&amp;element);
5728     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5729 }
5730 
5731 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5732 {
5733     m_svgUseElements.remove(&amp;element);
5734     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5735 }
5736 
5737 bool Document::hasSVGRootNode() const
5738 {
5739     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5740 }
5741 
5742 template &lt;CollectionType collectionType&gt;
5743 Ref&lt;HTMLCollection&gt; Document::ensureCachedCollection()
5744 {
5745     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;collectionType&gt;::traversalType&gt;&gt;(*this, collectionType);
5746 }
5747 
5748 Ref&lt;HTMLCollection&gt; Document::images()
5749 {
5750     return ensureCachedCollection&lt;DocImages&gt;();
5751 }
5752 
5753 Ref&lt;HTMLCollection&gt; Document::applets()
5754 {
5755     return ensureCachedCollection&lt;DocApplets&gt;();
5756 }
5757 
5758 Ref&lt;HTMLCollection&gt; Document::embeds()
5759 {
5760     return ensureCachedCollection&lt;DocEmbeds&gt;();
5761 }
5762 
5763 Ref&lt;HTMLCollection&gt; Document::plugins()
5764 {
5765     // This is an alias for embeds() required for the JS DOM bindings.
5766     return ensureCachedCollection&lt;DocEmbeds&gt;();
5767 }
5768 
5769 Ref&lt;HTMLCollection&gt; Document::scripts()
5770 {
5771     return ensureCachedCollection&lt;DocScripts&gt;();
5772 }
5773 
5774 Ref&lt;HTMLCollection&gt; Document::links()
5775 {
5776     return ensureCachedCollection&lt;DocLinks&gt;();
5777 }
5778 
5779 Ref&lt;HTMLCollection&gt; Document::forms()
5780 {
5781     return ensureCachedCollection&lt;DocForms&gt;();
5782 }
5783 
5784 Ref&lt;HTMLCollection&gt; Document::anchors()
5785 {
5786     return ensureCachedCollection&lt;DocAnchors&gt;();
5787 }
5788 
5789 Ref&lt;HTMLCollection&gt; Document::all()
5790 {
5791     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5792 }
5793 
5794 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomicString&amp; name)
5795 {
5796     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5797 }
5798 
5799 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomicString&amp; name)
5800 {
5801     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5802 }
5803 
5804 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomicString&amp; name)
5805 {
5806     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5807 }
5808 
5809 void Document::finishedParsing()
5810 {
5811     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5812     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5813     setParsing(false);
5814 
5815     Ref&lt;Document&gt; protectedThis(*this);
5816 
5817     scriptRunner().documentFinishedParsing();
5818 
5819     if (!m_documentTiming.domContentLoadedEventStart)
5820         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5821 
5822     // FIXME: Schdule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931
5823     MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();
5824 
5825     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5826 
5827     if (!m_documentTiming.domContentLoadedEventEnd)
5828         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5829 
5830     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5831 #if ENABLE(XSLT)
5832         applyPendingXSLTransformsNowIfScheduled();
5833 #endif
5834 
5835         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5836         // resource loads are complete. HTMLObjectElements can start loading their resources from
5837         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5838         // tag and then reach the end of the document without updating styles, we might not have yet
5839         // started the resource load and might fire the window load event too early. To avoid this
5840         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5841         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5842         updateStyleIfNeeded();
5843 
5844         frame-&gt;loader().finishedParsing();
5845         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5846     }
5847 
5848     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5849     // so that dynamically inserted content can also benefit from sharing optimizations.
5850     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5851     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5852     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5853     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5854 
5855     // Parser should have picked up all speculative preloads by now
5856     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
5857 }
5858 
5859 void Document::clearSharedObjectPool()
5860 {
5861     m_sharedObjectPool = nullptr;
5862     m_sharedObjectPoolClearTimer.stop();
5863 }
5864 
5865 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5866 
5867 // FIXME: Find a better place for this code.
5868 
5869 bool Document::isTelephoneNumberParsingEnabled() const
5870 {
5871     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5872 }
5873 
5874 bool Document::isTelephoneNumberParsingAllowed() const
5875 {
5876     return m_isTelephoneNumberParsingAllowed;
5877 }
5878 
5879 #endif
5880 
5881 String Document::originIdentifierForPasteboard()
5882 {
5883     auto origin = securityOrigin().toString();
5884     if (origin != &quot;null&quot;)
5885         return origin;
5886     if (!m_uniqueIdentifier)
5887         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5888     return m_uniqueIdentifier;
5889 }
5890 
5891 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5892 {
5893     if (!m_xpathEvaluator)
5894         m_xpathEvaluator = XPathEvaluator::create();
5895     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5896 }
5897 
5898 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)
5899 {
5900     if (!m_xpathEvaluator)
5901         m_xpathEvaluator = XPathEvaluator::create();
5902     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5903 }
5904 
5905 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5906 {
5907     if (!m_xpathEvaluator)
5908         m_xpathEvaluator = XPathEvaluator::create();
5909     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5910 }
5911 
5912 void Document::initSecurityContext()
5913 {
5914     if (haveInitializedSecurityOrigin()) {
5915         ASSERT(SecurityContext::securityOrigin());
5916         return;
5917     }
5918 
5919     if (!m_frame) {
5920         // No source for a security context.
5921         // This can occur via document.implementation.createDocument().
5922         setCookieURL(URL({ }, emptyString()));
5923         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5924         setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5925         return;
5926     }
5927 
5928     // In the common case, create the security context from the currently
5929     // loading URL with a fresh content security policy.
5930     setCookieURL(m_url);
5931     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5932     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5933 
5934     if (shouldEnforceContentDispositionAttachmentSandbox())
5935         applyContentDispositionAttachmentSandbox();
5936 
5937     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5938     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5939     if (!isSecurityOriginUnique)
5940         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5941 
5942     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5943     setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5944 
5945     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {
5946         // If this document was loaded with substituteData, then the document can
5947         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756
5948         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
5949         // discussion.
5950 
5951         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead
5952         // of &quot;loader()&quot; as the latter returns NULL while the document is being
5953         // constructed
5954         // DocumentLoader* documentLoader = loader();
5955         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();
5956         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())
5957             securityOrigin().grantLoadLocalResources();
5958     }
5959 
5960     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5961     if (!overrideContentSecurityPolicy.isNull())
5962         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5963 
5964 #if USE(QUICK_LOOK)
5965     if (shouldEnforceQuickLookSandbox())
5966         applyQuickLookSandbox();
5967 #endif
5968 
5969     if (shouldEnforceHTTP09Sandbox()) {
5970         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5971         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5972         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5973     }
5974 
5975     if (settings().needsStorageAccessFromFileURLsQuirk())
5976         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5977     if (!settings().webSecurityEnabled()) {
5978         // Web security is turned off. We should let this document access every other document. This is used primary by testing
5979         // harnesses for web sites.
5980         securityOrigin().grantUniversalAccess();
5981     } else if (securityOrigin().isLocal()) {
5982         if (settings().allowUniversalAccessFromFileURLs() || m_frame-&gt;loader().client().shouldForceUniversalAccessFromLocalURL(m_url)) {
5983             // Some clients want local URLs to have universal access, but that setting is dangerous for other clients.
5984             securityOrigin().grantUniversalAccess();
5985         } else if (!settings().allowFileAccessFromFileURLs()) {
5986             // Some clients want local URLs to have even tighter restrictions by default, and not be able to access other local files.
5987             // FIXME 81578: The naming of this is confusing. Files with restricted access to other local files
5988             // still can have other privileges that can be remembered, thereby not making them unique origins.
5989             securityOrigin().setEnforcesFilePathSeparation();
5990         }
5991     }
5992     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5993 
5994     Document* parentDocument = ownerElement() ? &amp;ownerElement()-&gt;document() : nullptr;
5995     if (parentDocument &amp;&amp; m_frame-&gt;loader().shouldTreatURLAsSrcdocDocument(url())) {
5996         m_isSrcdocDocument = true;
5997         setBaseURLOverride(parentDocument-&gt;baseURL());
5998     }
5999     if (parentDocument)
6000         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
6001 
6002     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
6003         return;
6004 
6005     // If we do not obtain a meaningful origin from the URL, then we try to
6006     // find one via the frame hierarchy.
6007     Frame* parentFrame = m_frame-&gt;tree().parent();
6008     Frame* openerFrame = m_frame-&gt;loader().opener();
6009 
6010     Frame* ownerFrame = parentFrame;
6011     if (!ownerFrame)
6012         ownerFrame = openerFrame;
6013 
6014     if (!ownerFrame) {
6015         didFailToInitializeSecurityOrigin();
6016         return;
6017     }
6018 
6019     Document* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr;
6020 
6021     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
6022     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
6023     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
6024     if (openerDocument)
6025         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
6026 
6027     if (isSandboxed(SandboxOrigin)) {
6028         // If we&#39;re supposed to inherit our security origin from our owner,
6029         // but we&#39;re also sandboxed, the only thing we inherit is the ability
6030         // to load local resources. This lets about:blank iframes in file://
6031         // URL documents load images and other resources from the file system.
6032         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
6033             securityOrigin().grantLoadLocalResources();
6034         return;
6035     }
6036 
6037     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
6038     // We alias the SecurityOrigins to match Firefox, see Bug 15313
6039     // https://bugs.webkit.org/show_bug.cgi?id=15313
6040     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
6041 }
6042 
6043 // FIXME: The current criterion is stricter than &lt;https://www.w3.org/TR/CSP3/#security-inherit-csp&gt; (Editor&#39;s Draft, 28 February 2019).
6044 bool Document::shouldInheritContentSecurityPolicy() const
6045 {
6046     ASSERT(m_frame);
6047     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
6048         return true;
6049     if (m_url.protocolIsData() || m_url.protocolIsBlob())
6050         return true;
6051     if (!isPluginDocument())
6052         return false;
6053     if (m_frame-&gt;tree().parent())
6054         return true;
6055     Frame* openerFrame = m_frame-&gt;loader().opener();
6056     if (!openerFrame)
6057         return false;
6058     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());
6059 }
6060 
6061 void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)
6062 {
6063     // 1. Inherit Upgrade Insecure Requests
6064     Frame* parentFrame = m_frame-&gt;tree().parent();
6065     if (parentFrame)
6066         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6067 
6068     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).
6069     if (!shouldInheritContentSecurityPolicy())
6070         return;
6071     ContentSecurityPolicy* ownerPolicy = nullptr;
6072     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
6073         ownerPolicy = previousPolicy;
6074     if (!ownerPolicy) {
6075     Frame* ownerFrame = parentFrame;
6076     if (!ownerFrame)
6077         ownerFrame = m_frame-&gt;loader().opener();
6078         if (ownerFrame)
6079             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
6080     }
6081     if (!ownerPolicy)
6082         return;
6083     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin
6084     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,
6085     // file, data) should inherit a policy.
6086     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())
6087         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);
6088     else
6089         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);
6090 }
6091 
6092 bool Document::isContextThread() const
6093 {
6094     return isMainThread();
6095 }
6096 
6097 bool Document::isSecureContext() const
6098 {
6099     if (!m_frame)
6100         return true;
6101     if (!securityOrigin().isPotentiallyTrustworthy())
6102         return false;
6103     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
6104         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
6105             return false;
6106     }
6107     return true;
6108 }
6109 
6110 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
6111 {
6112     Frame* f = frame();
6113     if (!f)
6114         return;
6115 
6116     setURL(url);
6117     f-&gt;loader().setOutgoingReferrer(url);
6118 
6119     if (DocumentLoader* documentLoader = loader())
6120         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
6121 }
6122 
6123 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6124 {
6125     if (!frame())
6126         return;
6127 
6128     // Per step 11 of section 6.5.9 (history traversal) of the HTML5 spec, we
6129     // defer firing of popstate until we&#39;re in the complete state.
6130     if (m_readyState == Complete)
6131         dispatchPopstateEvent(WTFMove(stateObject));
6132     else
6133         m_pendingStateObject = WTFMove(stateObject);
6134 }
6135 
6136 void Document::attachRange(Range&amp; range)
6137 {
6138     ASSERT(!m_ranges.contains(&amp;range));
6139     m_ranges.add(&amp;range);
6140 }
6141 
6142 void Document::detachRange(Range&amp; range)
6143 {
6144     // We don&#39;t ASSERT m_ranges.contains(&amp;range) to allow us to call this
6145     // unconditionally to fix: https://bugs.webkit.org/show_bug.cgi?id=26044
6146     m_ranges.remove(&amp;range);
6147 }
6148 
6149 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6150 {
6151     HTMLCanvasElement* element = getCSSCanvasElement(name);
6152     if (!element)
6153         return WTF::nullopt;
6154     element-&gt;setSize({ width, height });
6155     auto context = element-&gt;getContext(type);
6156     if (!context)
6157         return WTF::nullopt;
6158 
6159 #if ENABLE(WEBGL)
6160     if (is&lt;WebGLRenderingContext&gt;(*context))
6161         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6162 #endif
6163 #if ENABLE(WEBGL2)
6164     if (is&lt;WebGL2RenderingContext&gt;(*context))
6165         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6166 #endif
6167 #if ENABLE(WEBGPU)
6168     if (is&lt;WebGPURenderingContext&gt;(*context))
6169         return RenderingContext { RefPtr&lt;WebGPURenderingContext&gt; { &amp;downcast&lt;WebGPURenderingContext&gt;(*context) } };
6170 #endif
6171 #if ENABLE(WEBMETAL)
6172     if (is&lt;WebMetalRenderingContext&gt;(*context))
6173         return RenderingContext { RefPtr&lt;WebMetalRenderingContext&gt; { &amp;downcast&lt;WebMetalRenderingContext&gt;(*context) } };
6174 #endif
6175 
6176     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6177 }
6178 
6179 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6180 {
6181     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6182     if (!element)
6183         element = HTMLCanvasElement::create(*this);
6184     return element.get();
6185 }
6186 
6187 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6188 {
6189     for (const auto&amp; entry : m_cssCanvasElements) {
6190         if (entry.value.get() == &amp;canvasElement)
6191             return entry.key;
6192     }
6193     return String();
6194 }
6195 
6196 #if ENABLE(TEXT_AUTOSIZING)
6197 TextAutoSizing&amp; Document::textAutoSizing()
6198 {
6199     if (!m_textAutoSizing)
6200         m_textAutoSizing = std::make_unique&lt;TextAutoSizing&gt;();
6201     return *m_textAutoSizing;
6202 }
6203 #endif // ENABLE(TEXT_AUTOSIZING)
6204 
6205 void Document::initDNSPrefetch()
6206 {
6207     m_haveExplicitlyDisabledDNSPrefetch = false;
6208     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6209 
6210     // Inherit DNS prefetch opt-out from parent frame
6211     if (Document* parent = parentDocument()) {
6212         if (!parent-&gt;isDNSPrefetchEnabled())
6213             m_isDNSPrefetchEnabled = false;
6214     }
6215 }
6216 
6217 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6218 {
6219     if (!settings().dnsPrefetchingEnabled())
6220         return;
6221 
6222     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6223         m_isDNSPrefetchEnabled = true;
6224         return;
6225     }
6226 
6227     m_isDNSPrefetchEnabled = false;
6228     m_haveExplicitlyDisabledDNSPrefetch = true;
6229 }
6230 
6231 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6232 {
6233     if (!isContextThread()) {
6234         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6235         return;
6236     }
6237 
6238     if (Page* page = this-&gt;page())
6239         page-&gt;console().addMessage(WTFMove(consoleMessage));
6240 }
6241 
6242 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6243 {
6244     if (!isContextThread()) {
6245         postTask(AddConsoleMessageTask(source, level, message));
6246         return;
6247     }
6248 
6249     if (Page* page = this-&gt;page())
6250         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6251 
6252     if (m_consoleMessageListener)
6253         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6254 }
6255 
6256 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)
6257 {
6258     if (!isContextThread()) {
6259         postTask(AddConsoleMessageTask(source, level, message));
6260         return;
6261     }
6262 
6263     if (Page* page = this-&gt;page())
6264         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6265 }
6266 
6267 void Document::postTask(Task&amp;&amp; task)
6268 {
6269     callOnMainThread([documentReference = makeWeakPtr(*this), task = WTFMove(task)]() mutable {
6270         ASSERT(isMainThread());
6271 
6272         Document* document = documentReference.get();
6273         if (!document)
6274             return;
6275 
6276         Page* page = document-&gt;page();
6277         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6278             document-&gt;m_pendingTasks.append(WTFMove(task));
6279         else
6280             task.performTask(*document);
6281     });
6282 }
6283 
6284 void Document::pendingTasksTimerFired()
6285 {
6286     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6287     for (auto&amp; task : pendingTasks)
6288         task.performTask(*this);
6289 }
6290 
6291 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6292 {
6293     if (m_scheduledTasksAreSuspended) {
6294         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6295         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6296         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6297         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6298         return;
6299     }
6300 
6301     suspendScriptedAnimationControllerCallbacks();
6302     suspendActiveDOMObjects(reason);
6303     scriptRunner().suspend();
6304     m_pendingTasksTimer.stop();
6305 
6306 #if ENABLE(XSLT)
6307     m_applyPendingXSLTransformsTimer.stop();
6308 #endif
6309 
6310     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
6311     // (e.g. while displaying an alert).
6312     // It is not currently possible to suspend parser unless loading is deferred, because new data arriving from network
6313     // will trigger parsing, and leave the scheduler in an inconsistent state where it doesn&#39;t know whether it&#39;s suspended or not.
6314     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6315         m_parser-&gt;suspendScheduledTasks();
6316 
6317     m_scheduledTasksAreSuspended = true;
6318 }
6319 
6320 void Document::resumeScheduledTasks(ReasonForSuspension reason)
6321 {
6322     if (reasonForSuspendingActiveDOMObjects() != reason)
6323         return;
6324 
6325     ASSERT(m_scheduledTasksAreSuspended);
6326 
6327     if (reason == ReasonForSuspension::WillDeferLoading &amp;&amp; m_parser)
6328         m_parser-&gt;resumeScheduledTasks();
6329 
6330 #if ENABLE(XSLT)
6331     if (m_hasPendingXSLTransforms)
6332         m_applyPendingXSLTransformsTimer.startOneShot(0_s);
6333 #endif
6334 
6335     if (!m_pendingTasks.isEmpty())
6336         m_pendingTasksTimer.startOneShot(0_s);
6337     scriptRunner().resume();
6338     resumeActiveDOMObjects(reason);
6339     resumeScriptedAnimationControllerCallbacks();
6340 
6341     m_scheduledTasksAreSuspended = false;
6342 }
6343 
6344 void Document::suspendScriptedAnimationControllerCallbacks()
6345 {
6346     if (m_scriptedAnimationController)
6347         m_scriptedAnimationController-&gt;suspend();
6348 }
6349 
6350 void Document::resumeScriptedAnimationControllerCallbacks()
6351 {
6352     if (m_scriptedAnimationController)
6353         m_scriptedAnimationController-&gt;resume();
6354 }
6355 
6356 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6357 {
6358 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
6359     if (m_animationScheduler)
6360         m_animationScheduler-&gt;windowScreenDidChange(displayID);
6361 #endif
6362 
6363     if (RenderView* view = renderView()) {
6364         if (view-&gt;usesCompositing())
6365             view-&gt;compositor().windowScreenDidChange(displayID);
6366     }
6367 }
6368 
6369 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6370 {
6371     if (!m_decoder)
6372         return string;
6373     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6374 }
6375 
6376 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6377 {
6378     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6379     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6380 }
6381 
6382 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6383 {
6384     enqueueDocumentEvent(SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));
6385 }
6386 
6387 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6388 {
6389     enqueueWindowEvent(HashChangeEvent::create(oldURL, newURL));
6390 }
6391 
6392 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6393 {
6394     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6395 }
6396 
6397 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6398 {
6399     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6400     m_mediaCanStartListeners.add(&amp;listener);
6401 }
6402 
6403 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6404 {
6405     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6406     m_mediaCanStartListeners.remove(&amp;listener);
6407 }
6408 
6409 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
6410 {
6411     return m_mediaCanStartListeners.takeAny();
6412 }
6413 
6414 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6415 
6416 DeviceMotionController&amp; Document::deviceMotionController() const
6417 {
6418     return *m_deviceMotionController;
6419 }
6420 
6421 DeviceOrientationController&amp; Document::deviceOrientationController() const
6422 {
6423     return *m_deviceOrientationController;
6424 }
6425 
6426 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6427 {
6428     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6429     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6430 }
6431 
6432 #endif
6433 
6434 #if ENABLE(FULLSCREEN_API)
6435 
6436 bool Document::fullScreenIsAllowedForElement(Element&amp; element) const
6437 {
6438     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, element.document().ownerElement());
6439 }
6440 
6441 void Document::requestFullScreenForElement(Element* element, FullScreenCheckType checkType)
6442 {
6443     if (!element)
6444         element = documentElement();
6445 
6446     auto failedPreflights = [this](auto element) mutable {
6447         m_fullScreenErrorEventTargetQueue.append(WTFMove(element));
6448         m_fullScreenTaskQueue.enqueueTask([this] {
6449             dispatchFullScreenChangeEvents();
6450         });
6451     };
6452 
6453     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire
6454     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s
6455     // node document:
6456 
6457     // This algorithm is not allowed to show a pop-up:
6458     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:
6459     //   - an activation behavior is currently being processed whose click event was trusted, or
6460     //   - the event listener for a trusted click event is being handled.
6461     if (!UserGestureIndicator::processingUserGesture()) {
6462         failedPreflights(WTFMove(element));
6463         return;
6464     }
6465 
6466     // We do not allow pressing the Escape key as a user gesture to enter fullscreen since this is the key
6467     // to exit fullscreen.
6468     if (UserGestureIndicator::currentUserGesture()-&gt;gestureType() == UserGestureType::EscapeKey) {
6469         addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Escape key may not be used as a user gesture to enter fullscreen&quot;_s);
6470         failedPreflights(WTFMove(element));
6471         return;
6472     }
6473 
6474     // There is a previously-established user preference, security risk, or platform limitation.
6475     if (!page() || !page()-&gt;settings().fullScreenEnabled()) {
6476         failedPreflights(WTFMove(element));
6477         return;
6478     }
6479 
6480     bool hasKeyboardAccess = true;
6481     if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {
6482         // The new full screen API does not accept a &quot;flags&quot; parameter, so fall back to disallowing
6483         // keyboard input if the chrome client refuses to allow keyboard input.
6484         hasKeyboardAccess = false;
6485 
6486         if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {
6487             failedPreflights(WTFMove(element));
6488             return;
6489         }
6490     }
6491 
6492     m_fullScreenTaskQueue.enqueueTask([this, element = makeRefPtr(element), checkType, hasKeyboardAccess, failedPreflights] () mutable {
6493         // Don&#39;t allow fullscreen if document is hidden.
6494         if (hidden()) {
6495             failedPreflights(WTFMove(element));
6496             return;
6497         }
6498 
6499         // The context object is not in a document.
6500         if (!element-&gt;isConnected()) {
6501             failedPreflights(WTFMove(element));
6502             return;
6503         }
6504 
6505         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have
6506         // the fullscreen enabled flag set.
6507         if (checkType == EnforceIFrameAllowFullScreenRequirement &amp;&amp; !fullScreenIsAllowedForElement(*element)) {
6508             failedPreflights(WTFMove(element));
6509             return;
6510         }
6511 
6512         // The context object&#39;s node document fullscreen element stack is not empty and its top element
6513         // is not an ancestor of the context object.
6514         if (!m_fullScreenElementStack.isEmpty() &amp;&amp; !m_fullScreenElementStack.last()-&gt;contains(element.get())) {
6515             failedPreflights(WTFMove(element));
6516             return;
6517         }
6518 
6519         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.
6520         bool descendentHasNonEmptyStack = false;
6521         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
6522             if (descendant-&gt;document()-&gt;webkitFullscreenElement()) {
6523                 descendentHasNonEmptyStack = true;
6524                 break;
6525             }
6526         }
6527         if (descendentHasNonEmptyStack) {
6528             failedPreflights(WTFMove(element));
6529             return;
6530         }
6531 
6532         // 2. Let doc be element&#39;s node document. (i.e. &quot;this&quot;)
6533         Document* currentDoc = this;
6534 
6535         // 3. Let docs be all doc&#39;s ancestor browsing context&#39;s documents (if any) and doc.
6536         Deque&lt;Document*&gt; docs;
6537 
6538         do {
6539             docs.prepend(currentDoc);
6540             currentDoc = currentDoc-&gt;ownerElement() ? &amp;currentDoc-&gt;ownerElement()-&gt;document() : nullptr;
6541         } while (currentDoc);
6542 
6543         // 4. For each document in docs, run these substeps:
6544         Deque&lt;Document*&gt;::iterator current = docs.begin(), following = docs.begin();
6545 
6546         do {
6547             ++following;
6548 
6549             // 1. Let following document be the document after document in docs, or null if there is no
6550             // such document.
6551             Document* currentDoc = *current;
6552             Document* followingDoc = following != docs.end() ? *following : nullptr;
6553 
6554             // 2. If following document is null, push context object on document&#39;s fullscreen element
6555             // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute
6556             // set to true on the document.
6557             if (!followingDoc) {
6558                 currentDoc-&gt;pushFullscreenElementStack(*element);
6559                 addDocumentToFullScreenChangeEventQueue(*currentDoc);
6560                 continue;
6561             }
6562 
6563             // 3. Otherwise, if document&#39;s fullscreen element stack is either empty or its top element
6564             // is not following document&#39;s browsing context container,
6565             Element* topElement = currentDoc-&gt;webkitFullscreenElement();
6566             if (!topElement || topElement != followingDoc-&gt;ownerElement()) {
6567                 // ...push following document&#39;s browsing context container on document&#39;s fullscreen element
6568                 // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute
6569                 // set to true on document.
6570                 currentDoc-&gt;pushFullscreenElementStack(*followingDoc-&gt;ownerElement());
6571                 addDocumentToFullScreenChangeEventQueue(*currentDoc);
6572                 continue;
6573             }
6574 
6575             // 4. Otherwise, do nothing for this document. It stays the same.
6576         } while (++current != docs.end());
6577 
6578         // 5. Return, and run the remaining steps asynchronously.
6579         // 6. Optionally, perform some animation.
6580         m_areKeysEnabledInFullScreen = hasKeyboardAccess;
6581         m_fullScreenTaskQueue.enqueueTask([this, element = WTFMove(element)] {
6582             if (auto page = this-&gt;page())
6583                 page-&gt;chrome().client().enterFullScreenForElement(*element.get());
6584         });
6585 
6586         // 7. Optionally, display a message indicating how the user can exit displaying the context object fullscreen.
6587     });
6588 }
6589 
6590 void Document::webkitCancelFullScreen()
6591 {
6592     // The Mozilla &quot;cancelFullScreen()&quot; API behaves like the W3C &quot;fully exit fullscreen&quot; behavior, which
6593     // is defined as:
6594     // &quot;To fully exit fullscreen act as if the exitFullscreen() method was invoked on the top-level browsing
6595     // context&#39;s document and subsequently empty that document&#39;s fullscreen element stack.&quot;
6596     Document&amp; topDocument = this-&gt;topDocument();
6597     if (!topDocument.webkitFullscreenElement())
6598         return;
6599 
6600     // To achieve that aim, remove all the elements from the top document&#39;s stack except for the first before
6601     // calling webkitExitFullscreen():
6602     Vector&lt;RefPtr&lt;Element&gt;&gt; replacementFullscreenElementStack;
6603     replacementFullscreenElementStack.append(topDocument.webkitFullscreenElement());
6604     topDocument.m_fullScreenElementStack.swap(replacementFullscreenElementStack);
6605 
6606     topDocument.webkitExitFullscreen();
6607 }
6608 
6609 void Document::webkitExitFullscreen()
6610 {
6611     // The exitFullscreen() method must run these steps:
6612 
6613     // 1. Let doc be the context object. (i.e. &quot;this&quot;)
6614     Document* currentDoc = this;
6615 
6616     // 2. If doc&#39;s fullscreen element stack is empty, terminate these steps.
6617     if (m_fullScreenElementStack.isEmpty())
6618         return;
6619 
6620     // 3. Let descendants be all the doc&#39;s descendant browsing context&#39;s documents with a non-empty fullscreen
6621     // element stack (if any), ordered so that the child of the doc is last and the document furthest
6622     // away from the doc is first.
6623     Deque&lt;RefPtr&lt;Document&gt;&gt; descendants;
6624     for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
6625         if (descendant-&gt;document()-&gt;webkitFullscreenElement())
6626             descendants.prepend(descendant-&gt;document());
6627     }
6628 
6629     // 4. For each descendant in descendants, empty descendant&#39;s fullscreen element stack, and queue a
6630     // task to fire an event named fullscreenchange with its bubbles attribute set to true on descendant.
6631     for (auto&amp; document : descendants) {
6632         document-&gt;clearFullscreenElementStack();
6633         addDocumentToFullScreenChangeEventQueue(*document);
6634     }
6635 
6636     // 5. While doc is not null, run these substeps:
6637     Element* newTop = nullptr;
6638     while (currentDoc) {
6639         // 1. Pop the top element of doc&#39;s fullscreen element stack.
6640         currentDoc-&gt;popFullscreenElementStack();
6641 
6642         //    If doc&#39;s fullscreen element stack is non-empty and the element now at the top is either
6643         //    not in a document or its node document is not doc, repeat this substep.
6644         newTop = currentDoc-&gt;webkitFullscreenElement();
6645         if (newTop &amp;&amp; (!newTop-&gt;isConnected() || &amp;newTop-&gt;document() != currentDoc))
6646             continue;
6647 
6648         // 2. Queue a task to fire an event named fullscreenchange with its bubbles attribute set to true
6649         // on doc.
6650         addDocumentToFullScreenChangeEventQueue(*currentDoc);
6651 
6652         // 3. If doc&#39;s fullscreen element stack is empty and doc&#39;s browsing context has a browsing context
6653         // container, set doc to that browsing context container&#39;s node document.
6654         if (!newTop &amp;&amp; currentDoc-&gt;ownerElement()) {
6655             currentDoc = &amp;currentDoc-&gt;ownerElement()-&gt;document();
6656             continue;
6657         }
6658 
6659         // 4. Otherwise, set doc to null.
6660         currentDoc = nullptr;
6661     }
6662 
6663     // 6. Return, and run the remaining steps asynchronously.
6664     // 7. Optionally, perform some animation.
6665     m_fullScreenTaskQueue.enqueueTask([this, newTop = makeRefPtr(newTop), fullScreenElement = m_fullScreenElement] {
6666         auto* page = this-&gt;page();
6667         if (!page)
6668             return;
6669 
6670         // Only exit out of full screen window mode if there are no remaining elements in the
6671         // full screen stack.
6672         if (!newTop) {
6673             page-&gt;chrome().client().exitFullScreenForElement(fullScreenElement.get());
6674             return;
6675         }
6676 
6677         // Otherwise, notify the chrome of the new full screen element.
6678         page-&gt;chrome().client().enterFullScreenForElement(*newTop);
6679     });
6680 }
6681 
6682 bool Document::webkitFullscreenEnabled() const
6683 {
6684     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor
6685     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.
6686 
6687     // Top-level browsing contexts are implied to have their allowFullScreen attribute set.
6688     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, ownerElement());
6689 }
6690 
6691 static void unwrapFullScreenRenderer(RenderFullScreen* fullScreenRenderer, Element* fullScreenElement)
6692 {
6693     if (!fullScreenRenderer)
6694         return;
6695     bool requiresRenderTreeRebuild;
6696     fullScreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);
6697 
6698     if (requiresRenderTreeRebuild &amp;&amp; fullScreenElement &amp;&amp; fullScreenElement-&gt;parentElement())
6699         fullScreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();
6700 }
6701 
6702 void Document::webkitWillEnterFullScreen(Element&amp; element)
6703 {
6704     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)
6705         return;
6706 
6707     // Protect against being called after the document has been removed from the page.
6708     if (!page())
6709         return;
6710 
6711     ASSERT(page()-&gt;settings().fullScreenEnabled());
6712 
6713     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());
6714 
6715     element.willBecomeFullscreenElement();
6716 
6717     m_fullScreenElement = &amp;element;
6718 
6719 #if USE(NATIVE_FULLSCREEN_VIDEO)
6720     if (element.isMediaElement())
6721         return;
6722 #endif
6723 
6724     // Create a placeholder block for a the full-screen element, to keep the page from reflowing
6725     // when the element is removed from the normal flow.  Only do this for a RenderBox, as only
6726     // a box will have a frameRect.  The placeholder will be created in setFullScreenRenderer()
6727     // during layout.
6728     auto renderer = m_fullScreenElement-&gt;renderer();
6729     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);
6730     if (shouldCreatePlaceholder) {
6731         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();
6732         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());
6733     }
6734 
6735     if (m_fullScreenElement != documentElement() &amp;&amp; renderer)
6736         RenderFullScreen::wrapExistingRenderer(*renderer, *this);
6737 
6738     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
6739 
6740     resolveStyle(ResolveStyleType::Rebuild);
6741     dispatchFullScreenChangeEvents();
6742 }
6743 
6744 void Document::webkitDidEnterFullScreen()
6745 {
6746     if (!m_fullScreenElement)
6747         return;
6748 
6749     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)
6750         return;
6751 
6752     m_fullScreenElement-&gt;didBecomeFullscreenElement();
6753 }
6754 
6755 void Document::webkitWillExitFullScreen()
6756 {
6757     if (!m_fullScreenElement)
6758         return;
6759 
6760     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)
6761         return;
6762 
6763     m_fullScreenElement-&gt;willStopBeingFullscreenElement();
6764 }
6765 
6766 void Document::webkitDidExitFullScreen()
6767 {
6768     if (!m_fullScreenElement)
6769         return;
6770 
6771     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)
6772         return;
6773 
6774     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
6775 
6776     m_areKeysEnabledInFullScreen = false;
6777 
6778     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());
6779 
6780     m_fullScreenElement = nullptr;
6781     scheduleFullStyleRebuild();
6782 
6783     // When webkitCancelFullScreen is called, we call webkitExitFullScreen on the topDocument(). That
6784     // means that the events will be queued there. So if we have no events here, start the timer on
6785     // the exiting document.
6786     bool eventTargetQueuesEmpty = m_fullScreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullScreenErrorEventTargetQueue.isEmpty();
6787     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : *this;
6788 
6789     exitingDocument.dispatchFullScreenChangeEvents();
6790 }
6791 
6792 void Document::setFullScreenRenderer(RenderTreeBuilder&amp; builder, RenderFullScreen&amp; renderer)
6793 {
6794     if (&amp;renderer == m_fullScreenRenderer)
6795         return;
6796 
6797     if (m_savedPlaceholderRenderStyle)
6798         builder.createPlaceholderForFullScreen(renderer, WTFMove(m_savedPlaceholderRenderStyle), m_savedPlaceholderFrameRect);
6799     else if (m_fullScreenRenderer &amp;&amp; m_fullScreenRenderer-&gt;placeholder()) {
6800         auto* placeholder = m_fullScreenRenderer-&gt;placeholder();
6801         builder.createPlaceholderForFullScreen(renderer, RenderStyle::clonePtr(placeholder-&gt;style()), placeholder-&gt;frameRect());
6802     }
6803 
6804     if (m_fullScreenRenderer)
6805         builder.destroy(*m_fullScreenRenderer);
6806     ASSERT(!m_fullScreenRenderer);
6807 
6808     m_fullScreenRenderer = makeWeakPtr(renderer);
6809 }
6810 
6811 void Document::dispatchFullScreenChangeEvents()
6812 {
6813     // Since we dispatch events in this function, it&#39;s possible that the
6814     // document will be detached and GC&#39;d. We protect it here to make sure we
6815     // can finish the function successfully.
6816     Ref&lt;Document&gt; protectedThis(*this);
6817     Deque&lt;RefPtr&lt;Node&gt;&gt; changeQueue;
6818     m_fullScreenChangeEventTargetQueue.swap(changeQueue);
6819     Deque&lt;RefPtr&lt;Node&gt;&gt; errorQueue;
6820     m_fullScreenErrorEventTargetQueue.swap(errorQueue);
6821     dispatchFullScreenChangeOrErrorEvent(changeQueue, eventNames().webkitfullscreenchangeEvent, /* shouldNotifyMediaElement */ true);
6822     dispatchFullScreenChangeOrErrorEvent(errorQueue, eventNames().webkitfullscreenerrorEvent, /* shouldNotifyMediaElement */ false);
6823 }
6824 
6825 void Document::dispatchFullScreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp; queue, const AtomicString&amp; eventName, bool shouldNotifyMediaElement)
6826 {
6827     while (!queue.isEmpty()) {
6828         RefPtr&lt;Node&gt; node = queue.takeFirst();
6829         if (!node)
6830             node = documentElement();
6831         // The dispatchEvent below may have blown away our documentElement.
6832         if (!node)
6833             continue;
6834 
6835         // If the element was removed from our tree, also message the documentElement. Since we may
6836         // have a document hierarchy, check that node isn&#39;t in another document.
6837         if (!node-&gt;isConnected())
6838             queue.append(documentElement());
6839 
6840 #if ENABLE(VIDEO)
6841         if (shouldNotifyMediaElement &amp;&amp; is&lt;HTMLMediaElement&gt;(*node))
6842             downcast&lt;HTMLMediaElement&gt;(*node).enteredOrExitedFullscreen();
6843 #else
6844         UNUSED_PARAM(shouldNotifyMediaElement);
6845 #endif
6846         node-&gt;dispatchEvent(Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::No));
6847     }
6848 }
6849 
6850 void Document::fullScreenElementRemoved()
6851 {
6852     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
6853     webkitCancelFullScreen();
6854 }
6855 
6856 void Document::adjustFullScreenElementOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
6857 {
6858     if (!m_fullScreenElement)
6859         return;
6860 
6861     bool elementInSubtree = false;
6862     if (nodeRemoval == NodeRemoval::ChildrenOfNode)
6863         elementInSubtree = m_fullScreenElement-&gt;isDescendantOf(node);
6864     else
6865         elementInSubtree = (m_fullScreenElement == &amp;node) || m_fullScreenElement-&gt;isDescendantOf(node);
6866 
6867     if (elementInSubtree)
6868         fullScreenElementRemoved();
6869 }
6870 
6871 bool Document::isAnimatingFullScreen() const
6872 {
6873     return m_isAnimatingFullScreen;
6874 }
6875 
6876 void Document::setAnimatingFullScreen(bool flag)
6877 {
6878     if (m_isAnimatingFullScreen == flag)
6879         return;
6880     m_isAnimatingFullScreen = flag;
6881 
6882     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {
6883         m_fullScreenElement-&gt;invalidateStyleForSubtree();
6884         scheduleFullStyleRebuild();
6885     }
6886 }
6887 
6888 bool Document::areFullscreenControlsHidden() const
6889 {
6890     return m_areFullscreenControlsHidden;
6891 }
6892 
6893 void Document::setFullscreenControlsHidden(bool flag)
6894 {
6895     if (m_areFullscreenControlsHidden == flag)
6896         return;
6897     m_areFullscreenControlsHidden = flag;
6898 
6899     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {
6900         m_fullScreenElement-&gt;invalidateStyleForSubtree();
6901         scheduleFullStyleRebuild();
6902     }
6903 }
6904 
6905 void Document::clearFullscreenElementStack()
6906 {
6907     m_fullScreenElementStack.clear();
6908 }
6909 
6910 void Document::popFullscreenElementStack()
6911 {
6912     if (m_fullScreenElementStack.isEmpty())
6913         return;
6914 
6915     m_fullScreenElementStack.removeLast();
6916 }
6917 
6918 void Document::pushFullscreenElementStack(Element&amp; element)
6919 {
6920     m_fullScreenElementStack.append(&amp;element);
6921 }
6922 
6923 void Document::addDocumentToFullScreenChangeEventQueue(Document&amp; document)
6924 {
6925     Node* target = document.webkitFullscreenElement();
6926     if (!target)
6927         target = document.webkitCurrentFullScreenElement();
6928     if (!target)
6929         target = &amp;document;
6930     m_fullScreenChangeEventTargetQueue.append(target);
6931 }
6932 
6933 #endif
6934 
6935 #if ENABLE(POINTER_LOCK)
6936 
6937 void Document::exitPointerLock()
6938 {
6939     Page* page = this-&gt;page();
6940     if (!page)
6941         return;
6942     if (auto* target = page-&gt;pointerLockController().element()) {
6943         if (&amp;target-&gt;document() != this)
6944             return;
6945     }
6946     page-&gt;pointerLockController().requestPointerUnlock();
6947 }
6948 
6949 #endif
6950 
6951 void Document::decrementLoadEventDelayCount()
6952 {
6953     ASSERT(m_loadEventDelayCount);
6954     --m_loadEventDelayCount;
6955 
6956     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())
6957         m_loadEventDelayTimer.startOneShot(0_s);
6958 }
6959 
6960 void Document::loadEventDelayTimerFired()
6961 {
6962     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?
6963     // FIXME: Should this also call DocumentLoader::checkLoadComplete?
6964     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is
6965     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.
6966     Ref&lt;Document&gt; protectedThis(*this);
6967     checkCompleted();
6968     if (auto* frame = this-&gt;frame())
6969         frame-&gt;loader().checkLoadComplete();
6970 }
6971 
6972 void Document::checkCompleted()
6973 {
6974     if (auto* frame = this-&gt;frame())
6975         frame-&gt;loader().checkCompleted();
6976 }
6977 
6978 double Document::monotonicTimestamp() const
6979 {
6980     auto* loader = this-&gt;loader();
6981     if (!loader)
6982         return 0;
6983 
6984     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();
6985 }
6986 
6987 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
6988 {
6989     if (!m_scriptedAnimationController) {
6990         m_scriptedAnimationController = ScriptedAnimationController::create(*this);
6991 
6992         // It&#39;s possible that the Page may have suspended scripted animations before
6993         // we were created. We need to make sure that we don&#39;t start up the animation
6994         // controller on a background tab, for example.
6995         if (!page() || page()-&gt;scriptedAnimationsSuspended())
6996             m_scriptedAnimationController-&gt;suspend();
6997 
6998         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6999             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
7000 
7001         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
7002             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
7003     }
7004 
7005     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
7006 }
7007 
7008 void Document::cancelAnimationFrame(int id)
7009 {
7010     if (!m_scriptedAnimationController)
7011         return;
7012     m_scriptedAnimationController-&gt;cancelCallback(id);
7013 }
7014 
7015 void Document::clearScriptedAnimationController()
7016 {
7017     // FIXME: consider using ActiveDOMObject.
7018     if (m_scriptedAnimationController)
7019         m_scriptedAnimationController-&gt;clearDocumentPointer();
7020     m_scriptedAnimationController = nullptr;
7021 }
7022 
7023 void Document::wheelEventHandlersChanged()
7024 {
7025     Page* page = this-&gt;page();
7026     if (!page)
7027         return;
7028 
7029     if (FrameView* frameView = view()) {
7030         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
7031             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
7032     }
7033 
7034     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
7035     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
7036 }
7037 
7038 void Document::didAddWheelEventHandler(Node&amp; node)
7039 {
7040     if (!m_wheelEventTargets)
7041         m_wheelEventTargets = std::make_unique&lt;EventTargetSet&gt;();
7042 
7043     m_wheelEventTargets-&gt;add(&amp;node);
7044 
7045     wheelEventHandlersChanged();
7046 
7047     if (Frame* frame = this-&gt;frame())
7048         DebugPageOverlays::didChangeEventHandlers(*frame);
7049 }
7050 
7051 HttpEquivPolicy Document::httpEquivPolicy() const
7052 {
7053     if (shouldEnforceContentDispositionAttachmentSandbox())
7054         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
7055     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
7056         return HttpEquivPolicy::DisabledBySettings;
7057     return HttpEquivPolicy::Enabled;
7058 }
7059 
7060 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
7061 {
7062     switch (removal) {
7063     case EventHandlerRemoval::One:
7064         return handlerSet.remove(&amp;node);
7065     case EventHandlerRemoval::All:
7066         return handlerSet.removeAll(&amp;node);
7067     }
7068     return false;
7069 }
7070 
7071 void Document::didRemoveWheelEventHandler(Node&amp; node, EventHandlerRemoval removal)
7072 {
7073     if (!m_wheelEventTargets)
7074         return;
7075 
7076     if (!removeHandlerFromSet(*m_wheelEventTargets, node, removal))
7077         return;
7078 
7079     wheelEventHandlersChanged();
7080 
7081     if (Frame* frame = this-&gt;frame())
7082         DebugPageOverlays::didChangeEventHandlers(*frame);
7083 }
7084 
7085 unsigned Document::wheelEventHandlerCount() const
7086 {
7087     if (!m_wheelEventTargets)
7088         return 0;
7089 
7090     unsigned count = 0;
7091     for (auto&amp; handler : *m_wheelEventTargets)
7092         count += handler.value;
7093 
7094     return count;
7095 }
7096 
7097 void Document::didAddTouchEventHandler(Node&amp; handler)
7098 {
7099 #if ENABLE(TOUCH_EVENTS)
7100     if (!m_touchEventTargets)
7101         m_touchEventTargets = std::make_unique&lt;EventTargetSet&gt;();
7102 
7103     m_touchEventTargets-&gt;add(&amp;handler);
7104 
7105     if (Document* parent = parentDocument()) {
7106         parent-&gt;didAddTouchEventHandler(*this);
7107         return;
7108     }
7109 #else
7110     UNUSED_PARAM(handler);
7111 #endif
7112 }
7113 
7114 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
7115 {
7116 #if ENABLE(TOUCH_EVENTS)
7117     if (!m_touchEventTargets)
7118         return;
7119 
7120     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
7121 
7122     if (Document* parent = parentDocument())
7123         parent-&gt;didRemoveTouchEventHandler(*this);
7124 #else
7125     UNUSED_PARAM(handler);
7126     UNUSED_PARAM(removal);
7127 #endif
7128 }
7129 
7130 void Document::didRemoveEventTargetNode(Node&amp; handler)
7131 {
7132 #if ENABLE(TOUCH_EVENTS)
7133     if (m_touchEventTargets) {
7134         m_touchEventTargets-&gt;removeAll(&amp;handler);
7135         if ((&amp;handler == this || m_touchEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
7136             parentDocument()-&gt;didRemoveEventTargetNode(*this);
7137     }
7138 #endif
7139 
7140     if (m_wheelEventTargets) {
7141         m_wheelEventTargets-&gt;removeAll(&amp;handler);
7142         if ((&amp;handler == this || m_wheelEventTargets-&gt;isEmpty()) &amp;&amp; parentDocument())
7143             parentDocument()-&gt;didRemoveEventTargetNode(*this);
7144     }
7145 }
7146 
7147 unsigned Document::touchEventHandlerCount() const
7148 {
7149 #if ENABLE(TOUCH_EVENTS)
7150     if (!m_touchEventTargets)
7151         return 0;
7152 
7153     unsigned count = 0;
7154     for (auto&amp; handler : *m_touchEventTargets)
7155         count += handler.value;
7156 
7157     return count;
7158 #else
7159     return 0;
7160 #endif
7161 }
7162 
7163 LayoutRect Document::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
7164 {
7165     includesFixedPositionElements = false;
7166     if (RenderView* renderView = this-&gt;renderView())
7167         return renderView-&gt;documentRect();
7168 
7169     return LayoutRect();
7170 }
7171 
7172 Document::RegionFixedPair Document::absoluteEventRegionForNode(Node&amp; node)
7173 {
7174     Region region;
7175     LayoutRect rootRelativeBounds;
7176     bool insideFixedPosition = false;
7177 
7178     if (is&lt;Document&gt;(node)) {
7179         auto&amp; document = downcast&lt;Document&gt;(node);
7180         if (&amp;document == this)
7181             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
7182         else if (Element* element = document.ownerElement())
7183             rootRelativeBounds = element-&gt;absoluteEventHandlerBounds(insideFixedPosition);
7184     } else if (is&lt;Element&gt;(node)) {
7185         auto&amp; element = downcast&lt;Element&gt;(node);
7186         if (is&lt;HTMLBodyElement&gt;(element)) {
7187             // For the body, just use the document bounds.
7188             // The body may not cover this whole area, but it&#39;s OK for this region to be an overestimate.
7189             rootRelativeBounds = absoluteEventHandlerBounds(insideFixedPosition);
7190         } else
7191             rootRelativeBounds = element.absoluteEventHandlerBounds(insideFixedPosition);
7192     }
7193 
7194     if (!rootRelativeBounds.isEmpty())
7195         region.unite(Region(enclosingIntRect(rootRelativeBounds)));
7196 
7197     return RegionFixedPair(region, insideFixedPosition);
7198 }
7199 
7200 Document::RegionFixedPair Document::absoluteRegionForEventTargets(const EventTargetSet* targets)
7201 {
7202     LayoutDisallowedScope layoutDisallowedScope(LayoutDisallowedScope::Reason::ReentrancyAvoidance);
7203 
7204     if (!targets)
7205         return RegionFixedPair(Region(), false);
7206 
7207     Region targetRegion;
7208     bool insideFixedPosition = false;
7209 
7210     for (auto&amp; keyValuePair : *targets) {
7211         if (auto* node = keyValuePair.key) {
7212             auto targetRegionFixedPair = absoluteEventRegionForNode(*node);
7213             targetRegion.unite(targetRegionFixedPair.first);
7214             insideFixedPosition |= targetRegionFixedPair.second;
7215         }
7216     }
7217 
7218     return RegionFixedPair(targetRegion, insideFixedPosition);
7219 }
7220 
7221 void Document::updateLastHandledUserGestureTimestamp(MonotonicTime time)
7222 {
7223     m_lastHandledUserGestureTimestamp = time;
7224 
7225     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
7226         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
7227         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
7228     }
7229 
7230     // DOM Timer alignment may depend on the user having interacted with the document.
7231     didChangeTimerAlignmentInterval();
7232 
7233     if (HTMLFrameOwnerElement* element = ownerElement())
7234         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
7235 }
7236 
7237 bool Document::processingUserGestureForMedia() const
7238 {
7239     if (UserGestureIndicator::processingUserGestureForMedia())
7240         return true;
7241 
7242     if (settings().mediaUserGestureInheritsFromDocument())
7243         return topDocument().hasHadUserInteraction();
7244 
7245     auto* loader = this-&gt;loader();
7246     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
7247         return topDocument().hasHadUserInteraction();
7248 
7249     return false;
7250 }
7251 
7252 void Document::startTrackingStyleRecalcs()
7253 {
7254     m_styleRecalcCount = 0;
7255 }
7256 
7257 unsigned Document::styleRecalcCount() const
7258 {
7259     return m_styleRecalcCount;
7260 }
7261 
7262 DocumentLoader* Document::loader() const
7263 {
7264     if (!m_frame)
7265         return nullptr;
7266 
7267     DocumentLoader* loader = m_frame-&gt;loader().documentLoader();
7268     if (!loader)
7269         return nullptr;
7270 
7271     if (m_frame-&gt;document() != this)
7272         return nullptr;
7273 
7274     return loader;
7275 }
7276 
7277 #if ENABLE(CSS_DEVICE_ADAPTATION)
7278 
7279 IntSize Document::initialViewportSize() const
7280 {
7281     if (!view())
7282         return IntSize();
7283     return view()-&gt;initialViewportSize();
7284 }
7285 
7286 #endif
7287 
7288 Element* eventTargetElementForDocument(Document* document)
7289 {
7290     if (!document)
7291         return nullptr;
7292     Element* element = document-&gt;focusedElement();
7293     if (!element &amp;&amp; is&lt;PluginDocument&gt;(*document))
7294         element = downcast&lt;PluginDocument&gt;(*document).pluginElement();
7295     if (!element &amp;&amp; document-&gt;isHTMLDocument())
7296         element = document-&gt;bodyOrFrameset();
7297     if (!element)
7298         element = document-&gt;documentElement();
7299     return element;
7300 }
7301 
7302 void Document::convertAbsoluteToClientQuads(Vector&lt;FloatQuad&gt;&amp; quads, const RenderStyle&amp; style)
7303 {
7304     if (!view())
7305         return;
7306 
7307     const auto&amp; frameView = *view();
7308     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
7309     auto documentToClientOffset = frameView.documentToClientOffset();
7310 
7311     for (auto&amp; quad : quads) {
7312         if (inverseFrameScale != 1)
7313             quad.scale(inverseFrameScale);
7314 
7315         quad.move(documentToClientOffset);
7316     }
7317 }
7318 
7319 void Document::convertAbsoluteToClientRects(Vector&lt;FloatRect&gt;&amp; rects, const RenderStyle&amp; style)
7320 {
7321     if (!view())
7322         return;
7323 
7324     auto&amp; frameView = *view();
7325     float inverseFrameScale = frameView.absoluteToDocumentScaleFactor(style.effectiveZoom());
7326     auto documentToClientOffset = frameView.documentToClientOffset();
7327 
7328     for (auto&amp; rect : rects) {
7329         if (inverseFrameScale != 1)
7330             rect.scale(inverseFrameScale);
7331 
7332         rect.move(documentToClientOffset);
7333     }
7334 }
7335 
7336 void Document::convertAbsoluteToClientRect(FloatRect&amp; rect, const RenderStyle&amp; style)
7337 {
7338     if (!view())
7339         return;
7340 
7341     const auto&amp; frameView = *view();
7342     rect = frameView.absoluteToDocumentRect(rect, style.effectiveZoom());
7343     rect = frameView.documentToClientRect(rect);
7344 }
7345 
7346 bool Document::hasActiveParser()
7347 {
7348     return m_activeParserCount || (m_parser &amp;&amp; m_parser-&gt;processingData());
7349 }
7350 
7351 void Document::decrementActiveParserCount()
7352 {
7353     --m_activeParserCount;
7354     if (!frame())
7355         return;
7356 
7357     // FIXME: We should call DocumentLoader::checkLoadComplete as well here,
7358     // but it seems to cause http/tests/security/feed-urls-from-remote.html
7359     // to timeout on Mac WK1; see http://webkit.org/b/110554 and http://webkit.org/b/110401.
7360     frame()-&gt;loader().checkLoadComplete();
7361 }
7362 
7363 DocumentParserYieldToken::DocumentParserYieldToken(Document&amp; document)
7364     : m_document(makeWeakPtr(document))
7365 {
7366     if (++document.m_parserYieldTokenCount != 1)
7367         return;
7368 
7369     document.scriptRunner().didBeginYieldingParser();
7370     if (auto* parser = document.parser())
7371         parser-&gt;didBeginYieldingParser();
7372 }
7373 
7374 DocumentParserYieldToken::~DocumentParserYieldToken()
7375 {
7376     if (!m_document)
7377         return;
7378 
7379     ASSERT(m_document-&gt;m_parserYieldTokenCount);
7380     if (--m_document-&gt;m_parserYieldTokenCount)
7381         return;
7382 
7383     m_document-&gt;scriptRunner().didEndYieldingParser();
7384     if (auto* parser = m_document-&gt;parser())
7385         parser-&gt;didEndYieldingParser();
7386 }
7387 
7388 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
7389 {
7390     if (!elementA || !elementB)
7391         return nullptr;
7392 
7393     if (elementA == elementB)
7394         return elementA;
7395 
7396     HashSet&lt;Element*&gt; ancestorChain;
7397     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
7398         ancestorChain.add(element);
7399 
7400     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
7401         if (ancestorChain.contains(element))
7402             return element;
7403     }
7404     return nullptr;
7405 }
7406 
7407 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement)
7408 {
7409     ASSERT(!request.readOnly());
7410 
7411     Element* innerElementInDocument = innerElement;
7412     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
7413         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
7414         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
7415     }
7416 
7417     Element* oldActiveElement = m_activeElement.get();
7418     if (oldActiveElement &amp;&amp; !request.active()) {
7419         // We are clearing the :active chain because the mouse has been released.
7420         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
7421             currentElement-&gt;setActive(false);
7422             m_userActionElements.setInActiveChain(*currentElement, false);
7423         }
7424         m_activeElement = nullptr;
7425     } else {
7426         Element* newActiveElement = innerElementInDocument;
7427         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
7428             // We are setting the :active chain and freezing it. If future moves happen, they
7429             // will need to reference this chain.
7430             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
7431                 Element* element = curr-&gt;element();
7432                 if (!element || curr-&gt;isTextOrLineBreak())
7433                     continue;
7434                 m_userActionElements.setInActiveChain(*element, true);
7435             }
7436 
7437             m_activeElement = newActiveElement;
7438         }
7439     }
7440     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
7441     // nodes should remain :active until the mouse is released.
7442     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
7443 
7444     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
7445     // :hover/:active to only apply to elements that are in the :active chain that we froze
7446     // at the time the mouse went down.
7447     bool mustBeInActiveChain = request.active() &amp;&amp; request.move();
7448 
7449     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
7450 
7451     // A touch release does not set a new hover target; clearing the element we&#39;re working with
7452     // will clear the chain of hovered elements all the way to the top of the tree.
7453     if (request.touchRelease())
7454         innerElementInDocument = nullptr;
7455 
7456     // Check to see if the hovered Element has changed.
7457     // If it hasn&#39;t, we do not need to do anything.
7458     Element* newHoveredElement = innerElementInDocument;
7459     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
7460         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
7461 
7462     m_hoveredElement = newHoveredElement;
7463 
7464     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
7465 
7466     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
7467     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
7468 
7469     if (oldHoveredElement != newHoveredElement) {
7470         for (auto* element = oldHoveredElement.get(); element; element = element-&gt;parentElementInComposedTree()) {
7471             if (element == commonAncestor)
7472                 break;
7473             if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7474                 elementsToRemoveFromChain.append(element);
7475         }
7476         // Unset hovered nodes in sub frame documents if the old hovered node was a frame owner.
7477         if (is&lt;HTMLFrameOwnerElement&gt;(oldHoveredElement)) {
7478             if (auto* contentDocument = downcast&lt;HTMLFrameOwnerElement&gt;(*oldHoveredElement).contentDocument())
7479                 contentDocument-&gt;updateHoverActiveState(request, nullptr);
7480         }
7481     }
7482 
7483     for (auto* element = newHoveredElement; element; element = element-&gt;parentElementInComposedTree()) {
7484         if (!mustBeInActiveChain || element-&gt;isInActiveChain())
7485             elementsToAddToChain.append(element);
7486     }
7487 
7488     for (auto&amp; element : elementsToRemoveFromChain)
7489         element-&gt;setHovered(false);
7490 
7491     bool sawCommonAncestor = false;
7492     for (auto&amp; element : elementsToAddToChain) {
7493         if (allowActiveChanges)
7494             element-&gt;setActive(true);
7495         if (element == commonAncestor)
7496             sawCommonAncestor = true;
7497         if (!sawCommonAncestor) {
7498             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
7499             element-&gt;setHovered(true);
7500         }
7501     }
7502 }
7503 
7504 bool Document::haveStylesheetsLoaded() const
7505 {
7506     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
7507 }
7508 
7509 Locale&amp; Document::getCachedLocale(const AtomicString&amp; locale)
7510 {
7511     AtomicString localeKey = locale;
7512     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
7513         localeKey = defaultLanguage();
7514     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
7515     if (result.isNewEntry)
7516         result.iterator-&gt;value = Locale::create(localeKey);
7517     return *(result.iterator-&gt;value);
7518 }
7519 
7520 Document&amp; Document::ensureTemplateDocument()
7521 {
7522     if (const Document* document = templateDocument())
7523         return const_cast&lt;Document&amp;&gt;(*document);
7524 
7525     if (isHTMLDocument())
7526         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());
7527     else
7528         m_templateDocument = create(WTF::blankURL());
7529 
7530     m_templateDocument-&gt;setContextDocument(contextDocument());
7531     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
7532 
7533     return *m_templateDocument;
7534 }
7535 
7536 Ref&lt;FontFaceSet&gt; Document::fonts()
7537 {
7538     updateStyleIfNeeded();
7539     return fontSelector().fontFaceSet();
7540 }
7541 
7542 float Document::deviceScaleFactor() const
7543 {
7544     float deviceScaleFactor = 1.0;
7545     if (Page* documentPage = page())
7546         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
7547     return deviceScaleFactor;
7548 }
7549 
7550 bool Document::useSystemAppearance() const
7551 {
7552     bool useSystemAppearance = false;
7553     if (Page* documentPage = page())
7554         useSystemAppearance = documentPage-&gt;useSystemAppearance();
7555     return useSystemAppearance;
7556 }
7557 
7558 bool Document::useDarkAppearance(const RenderStyle* style) const
7559 {
7560 #if HAVE(OS_DARK_MODE_SUPPORT)
7561 #if ENABLE(DARK_MODE_CSS)
7562     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;
7563 
7564     // Use the style&#39;s supported color schemes, if supplied.
7565     if (style)
7566         supportedColorSchemes = style-&gt;supportedColorSchemes().colorSchemes();
7567 
7568     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
7569     if (supportedColorSchemes.isEmpty())
7570         supportedColorSchemes = m_supportedColorSchemes;
7571 
7572     if (supportedColorSchemes.contains(ColorSchemes::Dark) &amp;&amp; !supportedColorSchemes.contains(ColorSchemes::Light))
7573         return true;
7574 #else
7575     UNUSED_PARAM(style);
7576 #endif
7577 
7578     bool pageUsesDarkAppearance = false;
7579     if (Page* documentPage = page())
7580         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
7581 
7582     if (useSystemAppearance())
7583         return pageUsesDarkAppearance;
7584 
7585 #if ENABLE(DARK_MODE_CSS)
7586     if (supportedColorSchemes.contains(ColorSchemes::Dark))
7587         return pageUsesDarkAppearance;
7588 #endif
7589 #else
7590     UNUSED_PARAM(style);
7591 #endif
7592 
7593     return false;
7594 }
7595 
7596 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
7597 {
7598     OptionSet&lt;StyleColor::Options&gt; options;
7599     if (useSystemAppearance())
7600         options.add(StyleColor::Options::UseSystemAppearance);
7601     if (useDarkAppearance(style))
7602         options.add(StyleColor::Options::UseDarkAppearance);
7603     return options;
7604 }
7605 
7606 void Document::didAssociateFormControl(Element&amp; element)
7607 {
7608     auto* page = this-&gt;page();
7609     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7610         return;
7611     m_associatedFormControls.add(&amp;element);
7612     if (!m_didAssociateFormControlsTimer.isActive())
7613         m_didAssociateFormControlsTimer.startOneShot(0_s);
7614 }
7615 
7616 void Document::didAssociateFormControlsTimerFired()
7617 {
7618     auto vector = copyToVector(m_associatedFormControls);
7619     m_associatedFormControls.clear();
7620     if (auto* page = this-&gt;page())
7621         page-&gt;chrome().client().didAssociateFormControls(vector);
7622 }
7623 
7624 void Document::setCachedDOMCookies(const String&amp; cookies)
7625 {
7626     ASSERT(!isDOMCookieCacheValid());
7627     m_cachedDOMCookies = cookies;
7628     // The cookie cache is valid at most until we go back to the event loop.
7629     m_cookieCacheExpiryTimer.startOneShot(0_s);
7630 }
7631 
7632 void Document::invalidateDOMCookieCache()
7633 {
7634     m_cookieCacheExpiryTimer.stop();
7635     m_cachedDOMCookies = String();
7636 }
7637 
7638 void Document::didLoadResourceSynchronously()
7639 {
7640     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7641     // in this case, to be safe.
7642     invalidateDOMCookieCache();
7643 }
7644 
7645 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7646 {
7647     if (m_hasInjectedPlugInsScript)
7648         return;
7649 
7650     // Use the JS file provided by the Chrome client, or fallback to the default one.
7651     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7652     if (!jsString)
7653         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7654 
7655     frame()-&gt;script().evaluateInWorld(ScriptSourceCode(jsString), world);
7656 
7657     m_hasInjectedPlugInsScript = true;
7658 }
7659 
7660 #if ENABLE(WEB_CRYPTO)
7661 
7662 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7663 {
7664     Page* page = this-&gt;page();
7665     if (!page)
7666         return false;
7667     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7668 }
7669 
7670 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7671 {
7672     Page* page = this-&gt;page();
7673     if (!page)
7674         return false;
7675     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
7676 }
7677 
7678 #endif // ENABLE(WEB_CRYPTO)
7679 
7680 Element* Document::activeElement()
7681 {
7682     if (Element* element = treeScope().focusedElementInScope())
7683         return element;
7684     return bodyOrFrameset();
7685 }
7686 
7687 bool Document::hasFocus() const
7688 {
7689     Page* page = this-&gt;page();
7690     if (!page || !page-&gt;focusController().isActive())
7691         return false;
7692     if (Frame* focusedFrame = page-&gt;focusController().focusedFrame()) {
7693         if (focusedFrame-&gt;tree().isDescendantOf(frame()))
7694             return true;
7695     }
7696     return false;
7697 }
7698 
7699 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7700 
7701 static uint64_t nextPlaybackTargetClientContextId()
7702 {
7703     static uint64_t contextId = 0;
7704     return ++contextId;
7705 }
7706 
7707 void Document::addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7708 {
7709     Page* page = this-&gt;page();
7710     if (!page)
7711         return;
7712 
7713     // FIXME: change this back to an ASSERT once https://webkit.org/b/144970 is fixed.
7714     if (m_clientToIDMap.contains(&amp;client))
7715         return;
7716 
7717     uint64_t contextId = nextPlaybackTargetClientContextId();
7718     m_clientToIDMap.add(&amp;client, contextId);
7719     m_idToClientMap.add(contextId, &amp;client);
7720     page-&gt;addPlaybackTargetPickerClient(contextId);
7721 }
7722 
7723 void Document::removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp; client)
7724 {
7725     auto it = m_clientToIDMap.find(&amp;client);
7726     if (it == m_clientToIDMap.end())
7727         return;
7728 
7729     uint64_t clientId = it-&gt;value;
7730     m_idToClientMap.remove(clientId);
7731     m_clientToIDMap.remove(it);
7732 
7733     Page* page = this-&gt;page();
7734     if (!page)
7735         return;
7736     page-&gt;removePlaybackTargetPickerClient(clientId);
7737 }
7738 
7739 void Document::showPlaybackTargetPicker(MediaPlaybackTargetClient&amp; client, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
7740 {
7741     Page* page = this-&gt;page();
7742     if (!page)
7743         return;
7744 
7745     auto it = m_clientToIDMap.find(&amp;client);
7746     if (it == m_clientToIDMap.end())
7747         return;
7748 
7749     page-&gt;showPlaybackTargetPicker(it-&gt;value, view()-&gt;lastKnownMousePosition(), isVideo, routeSharingPolicy, routingContextUID);
7750 }
7751 
7752 void Document::playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp; client, MediaProducer::MediaStateFlags state)
7753 {
7754     Page* page = this-&gt;page();
7755     if (!page)
7756         return;
7757 
7758     auto it = m_clientToIDMap.find(&amp;client);
7759     if (it == m_clientToIDMap.end())
7760         return;
7761 
7762     page-&gt;playbackTargetPickerClientStateDidChange(it-&gt;value, state);
7763 }
7764 
7765 void Document::playbackTargetAvailabilityDidChange(uint64_t clientId, bool available)
7766 {
7767     auto it = m_idToClientMap.find(clientId);
7768     if (it == m_idToClientMap.end())
7769         return;
7770 
7771     it-&gt;value-&gt;externalOutputDeviceAvailableDidChange(available);
7772 }
7773 
7774 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7775 {
7776     auto it = m_idToClientMap.find(clientId);
7777     if (it == m_idToClientMap.end())
7778         return;
7779 
7780     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7781 }
7782 
7783 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7784 {
7785     auto it = m_idToClientMap.find(clientId);
7786     if (it == m_idToClientMap.end())
7787         return;
7788 
7789     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7790 }
7791 
7792 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7793 
7794 #if ENABLE(MEDIA_SESSION)
7795 
7796 MediaSession&amp; Document::defaultMediaSession()
7797 {
7798     if (!m_defaultMediaSession)
7799         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7800     return *m_defaultMediaSession;
7801 }
7802 
7803 #endif
7804 
7805 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7806 {
7807     if (DocumentLoader* documentLoader = loader())
7808         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7809 
7810     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7811 }
7812 
7813 bool Document::shouldEnforceHTTP09Sandbox() const
7814 {
7815     if (m_isSynthesized || !m_frame)
7816         return false;
7817     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7818     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7819 }
7820 
7821 #if USE(QUICK_LOOK)
7822 bool Document::shouldEnforceQuickLookSandbox() const
7823 {
7824     if (m_isSynthesized || !m_frame)
7825         return false;
7826     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7827     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7828 }
7829 
7830 void Document::applyQuickLookSandbox()
7831 {
7832     const URL&amp; responseURL = m_frame-&gt;loader().activeDocumentLoader()-&gt;responseURL();
7833     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7834 
7835     auto securityOrigin = SecurityOrigin::create(responseURL);
7836     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7837     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7838 
7839     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7840     RELEASE_ASSERT(contentSecurityPolicy());
7841     // The sandbox directive is only allowed if the policy is from an HTTP header.
7842     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7843 
7844     disableSandboxFlags(SandboxNavigation);
7845 
7846     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7847 }
7848 #endif
7849 
7850 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7851 {
7852     if (!settings().contentDispositionAttachmentSandboxEnabled())
7853         return false;
7854 
7855     if (m_isSynthesized)
7856         return false;
7857 
7858     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7859         return documentLoader-&gt;response().isAttachment();
7860     return false;
7861 }
7862 
7863 void Document::applyContentDispositionAttachmentSandbox()
7864 {
7865     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7866 
7867     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7868     if (!isMediaDocument())
7869         enforceSandboxFlags(SandboxAll);
7870     else
7871         enforceSandboxFlags(SandboxOrigin);
7872 }
7873 
7874 void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)
7875 {
7876     m_viewportDependentPictures.add(&amp;picture);
7877 }
7878 
7879 void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)
7880 {
7881     m_viewportDependentPictures.remove(&amp;picture);
7882 }
7883 
7884 void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7885 {
7886     m_appearanceDependentPictures.add(&amp;picture);
7887 }
7888 
7889 void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7890 {
7891     m_appearanceDependentPictures.remove(&amp;picture);
7892 }
7893 
7894 #if ENABLE(INTERSECTION_OBSERVER)
7895 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7896 {
7897     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7898     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7899 }
7900 
7901 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7902 {
7903     m_intersectionObservers.removeFirst(&amp;observer);
7904 }
7905 
7906 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7907 {
7908     FloatBoxExtent rootMarginFloatBox(
7909         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7910         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7911         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7912         floatValueForLength(rootMargin.left(), localRootBounds.width())
7913     );
7914 
7915     localRootBounds.expand(rootMarginFloatBox);
7916 }
7917 
7918 static Optional&lt;LayoutRect&gt; computeClippedRectInRootContentsSpace(const LayoutRect&amp; rect, const RenderElement* renderer)
7919 {
7920     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7921     Optional&lt;LayoutRect&gt; rectInFrameAbsoluteSpace = renderer-&gt;computeVisibleRectInContainer(rect, &amp;renderer-&gt;view(),  {false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7922     if (!rectInFrameAbsoluteSpace || renderer-&gt;frame().isMainFrame())
7923         return rectInFrameAbsoluteSpace;
7924 
7925     bool intersects = rectInFrameAbsoluteSpace-&gt;edgeInclusiveIntersect(renderer-&gt;view().frameView().layoutViewportRect());
7926     if (!intersects)
7927         return WTF::nullopt;
7928 
7929     LayoutRect rectInFrameViewSpace(renderer-&gt;view().frameView().contentsToView(snappedIntRect(*rectInFrameAbsoluteSpace)));
7930     auto* ownerRenderer = renderer-&gt;frame().ownerRenderer();
7931     if (!ownerRenderer)
7932         return WTF::nullopt;
7933 
7934     rectInFrameViewSpace.moveBy(ownerRenderer-&gt;contentBoxLocation());
7935     return computeClippedRectInRootContentsSpace(rectInFrameViewSpace, ownerRenderer);
7936 }
7937 
7938 struct IntersectionObservationState {
7939     FloatRect absoluteTargetRect;
7940     FloatRect absoluteRootBounds;
7941     FloatRect absoluteIntersectionRect;
7942     bool isIntersecting { false };
7943 };
7944 
7945 static Optional&lt;IntersectionObservationState&gt; computeIntersectionState(FrameView&amp; frameView, const IntersectionObserver&amp; observer, Element&amp; target, bool applyRootMargin)
7946 {
7947     auto* targetRenderer = target.renderer();
7948     if (!targetRenderer)
7949         return WTF::nullopt;
7950 
7951     FloatRect localRootBounds;
7952     RenderBlock* rootRenderer;
7953     if (observer.root()) {
7954         if (observer.trackingDocument() != &amp;target.document())
7955             return WTF::nullopt;
7956 
7957         if (!observer.root()-&gt;renderer() || !is&lt;RenderBlock&gt;(observer.root()-&gt;renderer()))
7958             return WTF::nullopt;
7959 
7960         rootRenderer = downcast&lt;RenderBlock&gt;(observer.root()-&gt;renderer());
7961         if (!rootRenderer-&gt;isContainingBlockAncestorFor(*targetRenderer))
7962             return WTF::nullopt;
7963 
7964         if (rootRenderer-&gt;hasOverflowClip())
7965             localRootBounds = rootRenderer-&gt;contentBoxRect();
7966         else
7967             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7968     } else {
7969         ASSERT(frameView.frame().isMainFrame());
7970         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7971         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7972             return WTF::nullopt;
7973         rootRenderer = frameView.renderView();
7974         localRootBounds = frameView.layoutViewportRect();
7975     }
7976 
7977     if (applyRootMargin)
7978         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7979 
7980     LayoutRect localTargetBounds;
7981     if (is&lt;RenderBox&gt;(*targetRenderer))
7982         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
7983     else if (is&lt;RenderInline&gt;(targetRenderer))
7984         localTargetBounds = downcast&lt;RenderInline&gt;(targetRenderer)-&gt;linesBoundingBox();
7985     else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7986         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7987 
7988     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7989     if (observer.root()) {
7990         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7991         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7992     } else
7993         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7994 
7995     FloatRect rootLocalIntersectionRect = localRootBounds;
7996 
7997     IntersectionObservationState intersectionState;
7998     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7999 
8000     if (intersectionState.isIntersecting) {
8001         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
8002         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
8003             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
8004         else {
8005             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
8006             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
8007         }
8008     }
8009 
8010     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
8011     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
8012     return intersectionState;
8013 }
8014 
8015 void Document::updateIntersectionObservations()
8016 {
8017     auto* frameView = view();
8018     if (!frameView)
8019         return;
8020 
8021     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
8022     if (needsLayout || hasPendingStyleRecalc())
8023         return;
8024 
8025     m_needsForcedIntersectionObservationUpdate = false;
8026 
8027     for (const auto&amp; observer : m_intersectionObservers) {
8028         bool needNotify = false;
8029         DOMHighResTimeStamp timestamp;
8030         if (!observer-&gt;createTimestamp(timestamp))
8031             continue;
8032         for (Element* target : observer-&gt;observationTargets()) {
8033             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
8034             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
8035                 return registration.observer.get() == observer;
8036             });
8037             ASSERT(index != notFound);
8038             auto&amp; registration = targetRegistrations[index];
8039 
8040             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
8041             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
8042 
8043             float intersectionRatio = 0;
8044             size_t thresholdIndex = 0;
8045             if (intersectionState) {
8046                 if (intersectionState-&gt;isIntersecting) {
8047                     float absTargetArea = intersectionState-&gt;absoluteTargetRect.area();
8048                     if (absTargetArea)
8049                         intersectionRatio = intersectionState-&gt;absoluteIntersectionRect.area() / absTargetArea;
8050                     else
8051                         intersectionRatio = 1;
8052 
8053                     auto&amp; thresholds = observer-&gt;thresholds();
8054                     while (thresholdIndex &lt; thresholds.size() &amp;&amp; thresholds[thresholdIndex] &lt;= intersectionRatio)
8055                         ++thresholdIndex;
8056                 }
8057             }
8058 
8059             if (!registration.previousThresholdIndex || thresholdIndex != registration.previousThresholdIndex) {
8060                 FloatRect targetBoundingClientRect;
8061                 FloatRect clientIntersectionRect;
8062                 FloatRect clientRootBounds;
8063                 if (intersectionState) {
8064                     auto* targetFrameView = target-&gt;document().view();
8065                     targetBoundingClientRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteTargetRect, target-&gt;renderer()-&gt;style().effectiveZoom());
8066                     auto* rootRenderer = observer-&gt;root() ? observer-&gt;root()-&gt;renderer() : frameView-&gt;renderView();
8067                     clientRootBounds = frameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteRootBounds, rootRenderer-&gt;style().effectiveZoom());
8068                     if (intersectionState-&gt;isIntersecting)
8069                         clientIntersectionRect = targetFrameView-&gt;absoluteToClientRect(intersectionState-&gt;absoluteIntersectionRect, target-&gt;renderer()-&gt;style().effectiveZoom());
8070                 }
8071 
8072                 Optional&lt;DOMRectInit&gt; reportedRootBounds;
8073                 if (isSameOriginObservation) {
8074                     reportedRootBounds = DOMRectInit({
8075                         clientRootBounds.x(),
8076                         clientRootBounds.y(),
8077                         clientRootBounds.width(),
8078                         clientRootBounds.height()
8079                     });
8080                 }
8081 
8082                 observer-&gt;appendQueuedEntry(IntersectionObserverEntry::create({
8083                     timestamp,
8084                     reportedRootBounds,
8085                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
8086                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
8087                     intersectionRatio,
8088                     target,
8089                     thresholdIndex &gt; 0,
8090                 }));
8091                 needNotify = true;
8092                 registration.previousThresholdIndex = thresholdIndex;
8093             }
8094         }
8095         if (needNotify)
8096             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
8097     }
8098 
8099     if (m_intersectionObserversWithPendingNotifications.size())
8100         m_intersectionObserversNotifyTimer.startOneShot(0_s);
8101 }
8102 
8103 void Document::scheduleForcedIntersectionObservationUpdate()
8104 {
8105     ASSERT(!m_intersectionObservers.isEmpty());
8106     if (m_needsForcedIntersectionObservationUpdate)
8107         return;
8108 
8109     m_needsForcedIntersectionObservationUpdate = true;
8110     if (auto* page = this-&gt;page())
8111         page-&gt;scheduleForcedIntersectionObservationUpdate(*this);
8112 }
8113 
8114 void Document::notifyIntersectionObserversTimerFired()
8115 {
8116     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
8117         if (observer)
8118             observer-&gt;notify();
8119     }
8120     m_intersectionObserversWithPendingNotifications.clear();
8121 }
8122 #endif
8123 
8124 const AtomicString&amp; Document::dir() const
8125 {
8126     auto* documentElement = this-&gt;documentElement();
8127     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
8128         return nullAtom();
8129     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
8130 }
8131 
8132 void Document::setDir(const AtomicString&amp; value)
8133 {
8134     auto* documentElement = this-&gt;documentElement();
8135     if (is&lt;HTMLHtmlElement&gt;(documentElement))
8136         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
8137 }
8138 
8139 DOMSelection* Document::getSelection()
8140 {
8141     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
8142 }
8143 
8144 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
8145 {
8146     ASSERT(shadowRoot.isConnected());
8147     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
8148     m_inDocumentShadowRoots.add(&amp;shadowRoot);
8149 }
8150 
8151 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
8152 {
8153     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
8154     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
8155 }
8156 
8157 void Document::orientationChanged(int orientation)
8158 {
8159     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
8160     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
8161     m_orientationNotifier.orientationChanged(orientation);
8162 }
8163 
8164 void Document::notifyMediaCaptureOfVisibilityChanged()
8165 {
8166 #if ENABLE(MEDIA_STREAM)
8167     if (!page())
8168         return;
8169 
8170     RealtimeMediaSourceCenter::singleton().setVideoCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());
8171 #endif
8172 }
8173 
8174 #if ENABLE(MEDIA_STREAM)
8175 void Document::stopMediaCapture()
8176 {
8177     MediaStreamRegistry::shared().forEach([this](MediaStream&amp; stream) {
8178         if (stream.document() == this)
8179             stream.endCaptureTracks();
8180     });
8181 }
8182 
8183 void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
8184 {
8185     m_mediaStreamStateChangeElements.add(&amp;element);
8186 }
8187 
8188 void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
8189 {
8190     m_mediaStreamStateChangeElements.remove(&amp;element);
8191 }
8192 
8193 void Document::mediaStreamCaptureStateChanged()
8194 {
8195     if (!MediaProducer::isCapturing(m_mediaState))
8196         return;
8197 
8198     for (auto* mediaElement : m_mediaStreamStateChangeElements)
8199         mediaElement-&gt;mediaStreamCaptureStarted();
8200 }
8201 
8202 void Document::setDeviceIDHashSalt(const String&amp; salt)
8203 {
8204     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
8205     m_idHashSalt = salt;
8206 }
8207 
8208 #endif
8209 
8210 void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
8211 {
8212     m_applicationStateChangeListeners.add(&amp;listener);
8213 }
8214 
8215 void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
8216 {
8217     m_applicationStateChangeListeners.remove(&amp;listener);
8218 }
8219 
8220 void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)
8221 {
8222     for (auto* listener : m_applicationStateChangeListeners)
8223         functor(*listener);
8224 }
8225 
8226 const AtomicString&amp; Document::bgColor() const
8227 {
8228     auto* bodyElement = body();
8229     if (!bodyElement)
8230         return emptyAtom();
8231     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
8232 }
8233 
8234 void Document::setBgColor(const String&amp; value)
8235 {
8236     if (auto* bodyElement = body())
8237         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
8238 }
8239 
8240 const AtomicString&amp; Document::fgColor() const
8241 {
8242     auto* bodyElement = body();
8243     if (!bodyElement)
8244         return emptyAtom();
8245     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
8246 }
8247 
8248 void Document::setFgColor(const String&amp; value)
8249 {
8250     if (auto* bodyElement = body())
8251         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
8252 }
8253 
8254 const AtomicString&amp; Document::alinkColor() const
8255 {
8256     auto* bodyElement = body();
8257     if (!bodyElement)
8258         return emptyAtom();
8259     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
8260 }
8261 
8262 void Document::setAlinkColor(const String&amp; value)
8263 {
8264     if (auto* bodyElement = body())
8265         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
8266 }
8267 
8268 const AtomicString&amp; Document::linkColorForBindings() const
8269 {
8270     auto* bodyElement = body();
8271     if (!bodyElement)
8272         return emptyAtom();
8273     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
8274 }
8275 
8276 void Document::setLinkColorForBindings(const String&amp; value)
8277 {
8278     if (auto* bodyElement = body())
8279         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
8280 }
8281 
8282 const AtomicString&amp; Document::vlinkColor() const
8283 {
8284     auto* bodyElement = body();
8285     if (!bodyElement)
8286         return emptyAtom();
8287     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
8288 }
8289 
8290 void Document::setVlinkColor(const String&amp; value)
8291 {
8292     if (auto* bodyElement = body())
8293         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
8294 }
8295 
8296 Logger&amp; Document::logger()
8297 {
8298     if (!m_logger) {
8299         m_logger = Logger::create(this);
8300         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());
8301         m_logger-&gt;addObserver(*this);
8302     }
8303 
8304     return *m_logger;
8305 }
8306 
8307 Optional&lt;uint64_t&gt; Document::pageID() const
8308 {
8309     return m_frame-&gt;loader().client().pageID();
8310 }
8311 
8312 void Document::hasStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
8313 {
8314     ASSERT(settings().storageAccessAPIEnabled());
8315 
8316 #if ENABLE(RESOURCE_LOAD_STATISTICS)
8317     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {
8318         promise-&gt;resolve&lt;IDLBoolean&gt;(true);
8319         return;
8320     }
8321 
8322     if (!m_frame || securityOrigin().isUnique()) {
8323         promise-&gt;resolve&lt;IDLBoolean&gt;(false);
8324         return;
8325     }
8326 
8327     if (m_frame-&gt;isMainFrame()) {
8328         promise-&gt;resolve&lt;IDLBoolean&gt;(true);
8329         return;
8330     }
8331 
8332     auto&amp; securityOrigin = this-&gt;securityOrigin();
8333     auto&amp; topSecurityOrigin = topDocument().securityOrigin();
8334     if (securityOrigin.equal(&amp;topSecurityOrigin)) {
8335         promise-&gt;resolve&lt;IDLBoolean&gt;(true);
8336         return;
8337     }
8338 
8339     auto frameID = m_frame-&gt;loader().client().frameID();
8340     auto pageID = m_frame-&gt;loader().client().pageID();
8341     if (!frameID || !pageID) {
8342         promise-&gt;reject();
8343         return;
8344     }
8345 
8346     if (Page* page = this-&gt;page()) {
8347         auto iframeHost = securityOrigin.host();
8348         auto topHost = topSecurityOrigin.host();
8349         page-&gt;chrome().client().hasStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool hasAccess) {
8350             Document* document = documentReference.get();
8351             if (!document)
8352                 return;
8353 
8354             promise-&gt;resolve&lt;IDLBoolean&gt;(hasAccess);
8355         });
8356         return;
8357     }
8358 #endif
8359 
8360     promise-&gt;reject();
8361 }
8362 
8363 void Document::requestStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
8364 {
8365     ASSERT(settings().storageAccessAPIEnabled());
8366 
8367 #if ENABLE(RESOURCE_LOAD_STATISTICS)
8368     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {
8369         promise-&gt;resolve();
8370         return;
8371     }
8372 
8373     if (!m_frame || securityOrigin().isUnique()) {
8374         promise-&gt;reject();
8375         return;
8376     }
8377 
8378     if (m_frame-&gt;isMainFrame()) {
8379         promise-&gt;resolve();
8380         return;
8381     }
8382 
8383     auto&amp; topDocument = this-&gt;topDocument();
8384     auto&amp; topSecurityOrigin = topDocument.securityOrigin();
8385     auto&amp; securityOrigin = this-&gt;securityOrigin();
8386     if (securityOrigin.equal(&amp;topSecurityOrigin)) {
8387         promise-&gt;resolve();
8388         return;
8389     }
8390 
8391     // If there is a sandbox, it has to allow the storage access API to be called.
8392     if (sandboxFlags() != SandboxNone &amp;&amp; isSandboxed(SandboxStorageAccessByUserActivation)) {
8393         promise-&gt;reject();
8394         return;
8395     }
8396 
8397     // The iframe has to be a direct child of the top document.
8398     if (&amp;topDocument != parentDocument()) {
8399         promise-&gt;reject();
8400         return;
8401     }
8402 
8403     if (!UserGestureIndicator::processingUserGesture()) {
8404         promise-&gt;reject();
8405         return;
8406     }
8407 
8408     auto iframeHost = securityOrigin.host();
8409     auto topHost = topSecurityOrigin.host();
8410 
8411     Page* page = this-&gt;page();
8412     auto frameID = m_frame-&gt;loader().client().frameID();
8413     auto pageID = m_frame-&gt;loader().client().pageID();
8414     if (!page || !frameID || !pageID) {
8415         promise-&gt;reject();
8416         return;
8417     }
8418 
8419     page-&gt;chrome().client().requestStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool wasGranted) mutable {
8420         Document* document = documentReference.get();
8421         if (!document)
8422             return;
8423 
8424         if (wasGranted) {
8425             document-&gt;setHasFrameSpecificStorageAccess(true);
8426             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = makeWeakPtr(*document)] () {
8427                 if (auto* document = documentReference.get())
8428                     document-&gt;enableTemporaryTimeUserGesture();
8429             }));
8430             promise-&gt;resolve();
8431             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = WTFMove(documentReference)] () {
8432                 if (auto* document = documentReference.get())
8433                     document-&gt;consumeTemporaryTimeUserGesture();
8434             }));
8435         } else
8436             promise-&gt;reject();
8437     });
8438 #else
8439     promise-&gt;reject();
8440 #endif
8441 }
8442 
8443 void Document::enableTemporaryTimeUserGesture()
8444 {
8445     m_temporaryUserGesture = std::make_unique&lt;UserGestureIndicator&gt;(ProcessingUserGesture, this);
8446 }
8447 
8448 void Document::consumeTemporaryTimeUserGesture()
8449 {
8450     m_temporaryUserGesture = nullptr;
8451 }
8452 
8453 void Document::registerArticleElement(Element&amp; article)
8454 {
8455     m_articleElements.add(&amp;article);
8456 }
8457 
8458 void Document::unregisterArticleElement(Element&amp; article)
8459 {
8460     m_articleElements.remove(&amp;article);
8461     if (m_mainArticleElement == &amp;article)
8462         m_mainArticleElement = nullptr;
8463 }
8464 
8465 void Document::updateMainArticleElementAfterLayout()
8466 {
8467     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
8468 
8469     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
8470     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
8471 
8472     // We consider an article to be main content if it is either:
8473     // 1. The only article element in the document.
8474     // 2. Much taller than the next tallest article, and also much larger than the viewport.
8475     const float minimumSecondTallestArticleHeightFactor = 4;
8476     const float minimumViewportAreaFactor = 5;
8477 
8478     m_mainArticleElement = nullptr;
8479 
8480     auto numberOfArticles = m_articleElements.size();
8481     if (!numberOfArticles || numberOfArticles &gt; maxNumberOfArticlesBeforeIgnoringMainContentArticle)
8482         return;
8483 
8484     Element* tallestArticle = nullptr;
8485     float tallestArticleHeight = 0;
8486     float tallestArticleWidth = 0;
8487     float secondTallestArticleHeight = 0;
8488 
8489     for (auto* article : m_articleElements) {
8490         auto* box = article-&gt;renderBox();
8491         float height = box ? box-&gt;height().toFloat() : 0;
8492         if (height &gt;= tallestArticleHeight) {
8493             secondTallestArticleHeight = tallestArticleHeight;
8494             tallestArticleHeight = height;
8495             tallestArticleWidth = box ? box-&gt;width().toFloat() : 0;
8496             tallestArticle = article;
8497         } else if (height &gt;= secondTallestArticleHeight)
8498             secondTallestArticleHeight = height;
8499     }
8500 
8501     if (numberOfArticles == 1) {
8502         m_mainArticleElement = tallestArticle;
8503         return;
8504     }
8505 
8506     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
8507         return;
8508 
8509     if (!view())
8510         return;
8511 
8512     auto viewportSize = view()-&gt;layoutViewportRect().size();
8513     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
8514         return;
8515 
8516     m_mainArticleElement = tallestArticle;
8517 }
8518 
8519 #if ENABLE(RESOURCE_LOAD_STATISTICS)
8520 bool Document::hasFrameSpecificStorageAccess() const
8521 {
8522     return m_frame &amp;&amp; m_frame-&gt;loader().client().hasFrameSpecificStorageAccess();
8523 }
8524 
8525 void Document::setHasFrameSpecificStorageAccess(bool value)
8526 {
8527     if (m_frame)
8528     m_frame-&gt;loader().client().setHasFrameSpecificStorageAccess(value);
8529 }
8530 
8531 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)
8532 {
8533     return m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction == primaryDomain;
8534 }
8535 
8536 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)
8537 {
8538     m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction = primaryDomain;
8539 }
8540 #endif
8541 
8542 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
8543 {
8544     m_consoleMessageListener = listener;
8545 }
8546 
8547 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
8548 DocumentAnimationScheduler&amp; Document::animationScheduler()
8549 {
8550     if (!m_animationScheduler)
8551         m_animationScheduler = DocumentAnimationScheduler::create(*this, page() ? page()-&gt;chrome().displayID() : 0);
8552 
8553     return *m_animationScheduler;
8554 }
8555 #endif
8556 
8557 DocumentTimeline&amp; Document::timeline()
8558 {
8559     if (!m_timeline)
8560         m_timeline = DocumentTimeline::create(*this);
8561 
8562     return *m_timeline;
8563 }
8564 
8565 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
8566 {
8567     // For the list of animations to be current, we need to account for any pending CSS changes,
8568     // such as updates to CSS Animations and CSS Transitions.
8569     updateStyleIfNeeded();
8570 
8571     if (m_timeline)
8572         return m_timeline-&gt;getAnimations();
8573     return { };
8574 }
8575 
8576 #if ENABLE(ATTACHMENT_ELEMENT)
8577 
8578 void Document::registerAttachmentIdentifier(const String&amp; identifier)
8579 {
8580     if (auto* frame = this-&gt;frame())
8581         frame-&gt;editor().registerAttachmentIdentifier(identifier);
8582 }
8583 
8584 void Document::didInsertAttachmentElement(HTMLAttachmentElement&amp; attachment)
8585 {
8586     auto identifier = attachment.uniqueIdentifier();
8587     auto previousIdentifier = identifier;
8588     bool previousIdentifierIsNotUnique = !previousIdentifier.isEmpty() &amp;&amp; m_attachmentIdentifierToElementMap.contains(previousIdentifier);
8589     if (identifier.isEmpty() || previousIdentifierIsNotUnique) {
8590         previousIdentifier = identifier;
8591         identifier = createCanonicalUUIDString();
8592         attachment.setUniqueIdentifier(identifier);
8593     }
8594 
8595     m_attachmentIdentifierToElementMap.set(identifier, attachment);
8596 
8597     if (auto* frame = this-&gt;frame()) {
8598         if (previousIdentifierIsNotUnique)
8599             frame-&gt;editor().cloneAttachmentData(previousIdentifier, identifier);
8600         frame-&gt;editor().didInsertAttachmentElement(attachment);
8601     }
8602 }
8603 
8604 void Document::didRemoveAttachmentElement(HTMLAttachmentElement&amp; attachment)
8605 {
8606     auto identifier = attachment.uniqueIdentifier();
8607     if (!identifier)
8608         return;
8609 
8610     m_attachmentIdentifierToElementMap.remove(identifier);
8611 
8612     if (frame())
8613         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
8614 }
8615 
8616 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
8617 {
8618     return m_attachmentIdentifierToElementMap.get(identifier);
8619 }
8620 
8621 #endif // ENABLE(ATTACHMENT_ELEMENT)
8622 
8623 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
8624 {
8625     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
8626     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
8627 
8628     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8629         return MessageSource::Media;
8630 
8631     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8632         return MessageSource::WebRTC;
8633 
8634     return MessageSource::Other;
8635 }
8636 
8637 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8638 {
8639     switch (level) {
8640     case WTFLogLevelAlways:
8641         return MessageLevel::Log;
8642     case WTFLogLevelError:
8643         return MessageLevel::Error;
8644         break;
8645     case WTFLogLevelWarning:
8646         return MessageLevel::Warning;
8647         break;
8648     case WTFLogLevelInfo:
8649         return MessageLevel::Info;
8650         break;
8651     case WTFLogLevelDebug:
8652         return MessageLevel::Debug;
8653         break;
8654     }
8655 
8656     ASSERT_NOT_REACHED();
8657     return MessageLevel::Log;
8658 }
8659 
8660 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8661 {
8662     if (!page())
8663         return;
8664 
8665     ASSERT(sessionID().isAlwaysOnLoggingAllowed());
8666 
8667     auto messageSource = messageSourceForWTFLogChannel(channel);
8668     if (messageSource == MessageSource::Other)
8669         return;
8670 
8671     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8672         if (!page())
8673             return;
8674 
8675         auto messageLevel = messageLevelFromWTFLogLevel(level);
8676         auto message = std::make_unique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8677 
8678         addConsoleMessage(WTFMove(message));
8679     });
8680 }
8681 
8682 #if ENABLE(SERVICE_WORKER)
8683 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8684 {
8685     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8686         return;
8687 
8688     if (m_serviceWorkerConnection)
8689         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8690 
8691     m_serviceWorkerConnection = serviceWorkerConnection;
8692 
8693     if (!m_serviceWorkerConnection)
8694         return;
8695 
8696     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8697     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8698 }
8699 #endif
8700 
8701 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8702 {
8703     Page* page = this-&gt;page();
8704     if (!page)
8705         return emptyString();
8706     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8707 }
8708 
8709 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8710 {
8711     return m_CSSRegisteredPropertySet.add(prop.name, std::make_unique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;
8712 }
8713 
8714 void Document::detachFromFrame()
8715 {
8716     observeFrame(nullptr);
8717 }
8718 
8719 void Document::frameWasDisconnectedFromOwner()
8720 {
8721     if (!frame())
8722         return;
8723 
8724     if (auto* window = domWindow())
8725         window-&gt;willDetachDocumentFromFrame();
8726 
8727     detachFromFrame();
8728 }
8729 
8730 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8731 {
8732     return hitTest(request, result.hitTestLocation(), result);
8733 }
8734 
8735 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8736 {
8737     Ref&lt;Document&gt; protectedThis(*this);
8738     updateLayout();
8739     if (!renderView())
8740         return false;
8741 
8742 #if !ASSERT_DISABLED
8743     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8744 #endif
8745 
8746     auto&amp; frameView = renderView()-&gt;frameView();
8747     Ref&lt;FrameView&gt; protector(frameView);
8748 
8749     FrameFlatteningLayoutDisallower disallower(frameView);
8750 
8751     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8752 
8753     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8754     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8755     // will always work so we need to check the ScrollView scrollbars in that case too.
8756     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8757         // FIXME: Consider if this test should be done unconditionally.
8758         if (request.allowsFrameScrollbars()) {
8759             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8760             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8761                 result.setScrollbar(frameScrollbar);
8762                 return true;
8763             }
8764         }
8765     }
8766     return resultLayer;
8767 }
8768 
8769 #if ENABLE(CSS_PAINTING_API)
8770 Worklet&amp; Document::ensurePaintWorklet()
8771 {
8772     if (!m_paintWorklet)
8773         m_paintWorklet = Worklet::create();
8774     return *m_paintWorklet;
8775 }
8776 
8777 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8778 {
8779     return m_paintWorkletGlobalScopes.get(name);
8780 }
8781 
8782 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8783 {
8784     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8785     ASSERT_UNUSED(addResult, addResult);
8786 }
8787 #endif
8788 
8789 #if ENABLE(POINTER_EVENTS)
8790 void Document::updateTouchActionElements(Element&amp; element, const RenderStyle&amp; style)
8791 {
8792     bool changed = false;
8793 
8794     if (style.touchActions() != TouchAction::Auto) {
8795         if (!m_touchActionElements)
8796             m_touchActionElements = std::make_unique&lt;HashSet&lt;RefPtr&lt;Element&gt;&gt;&gt;();
8797         changed |= m_touchActionElements-&gt;add(&amp;element).isNewEntry;
8798     } else if (m_touchActionElements)
8799         changed |= m_touchActionElements-&gt;remove(&amp;element);
8800 
8801 #if PLATFORM(IOS_FAMILY)
8802     if (!changed)
8803         return;
8804 
8805     Page* page = this-&gt;page();
8806     if (!page)
8807         return;
8808 
8809     if (FrameView* frameView = view()) {
8810         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
8811             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
8812     }
8813 #endif
8814 }
8815 #endif
8816 
8817 } // namespace WebCore
    </pre>
  </body>
</html>