<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/Optional.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright (C) 2011 - 2012 Andrzej Krzemienski.
   2 //
   3 // Use, modification, and distribution is subject to the Boost Software
   4 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   5 // http://www.boost.org/LICENSE_1_0.txt)
   6 //
   7 // The idea and interface is based on Boost.Optional library
   8 // authored by Fernando Luis Cacciola Carballal
   9 //
  10 // Boost Software License - Version 1.0 - August 17th, 2003
  11 //
  12 // Permission is hereby granted, free of charge, to any person or organization
  13 // obtaining a copy of the software and accompanying documentation covered by
  14 // this license (the &quot;Software&quot;) to use, reproduce, display, distribute,
  15 // execute, and transmit the Software, and to prepare derivative works of the
  16 // Software, and to permit third-parties to whom the Software is furnished to
  17 // do so, all subject to the following:
  18 //
  19 // The copyright notices in the Software and this entire statement, including
  20 // the above license grant, this restriction and the following disclaimer,
  21 // must be included in all copies of the Software, in whole or in part, and
  22 // all derivative works of the Software, unless such copies or derivative
  23 // works are solely in the form of machine-executable object code generated by
  24 // a source language processor.
  25 //
  26 // THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  27 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  28 // FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  29 // SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  30 // FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  31 // ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  32 // DEALINGS IN THE SOFTWARE.
  33 
  34 // Copied from https://github.com/akrzemi1/Optional (8456c3923776b33b4ae852734273fe934c3e4e61)
  35 
  36 // Modified to make it compile with exceptions disabled.
  37 
  38 #pragma once
  39 
  40 # include &lt;utility&gt;
  41 # include &lt;type_traits&gt;
  42 # include &lt;initializer_list&gt;
  43 # include &lt;cassert&gt;
  44 # include &lt;string&gt;
  45 # include &lt;stdexcept&gt;
  46 # include &lt;wtf/Assertions.h&gt;
  47 # include &lt;wtf/Compiler.h&gt;
  48 # include &lt;wtf/FastMalloc.h&gt;
  49 # include &lt;wtf/StdLibExtras.h&gt;
  50 
  51 # define TR2_OPTIONAL_REQUIRES(...) typename std::enable_if&lt;__VA_ARGS__::value, bool&gt;::type = false
  52 
  53 # if defined __GNUC__ // NOTE: GNUC is also defined for Clang
  54 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 8)
  55 #     define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
  56 #   elif (__GNUC__ &gt; 4)
  57 #     define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
  58 #   endif
  59 #
  60 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 7)
  61 #     define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
  62 #   elif (__GNUC__ &gt; 4)
  63 #     define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
  64 #   endif
  65 #
  66 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ == 8) &amp;&amp; (__GNUC_PATCHLEVEL__ &gt;= 1)
  67 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  68 #   elif (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 9)
  69 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  70 #   elif (__GNUC__ &gt; 4)
  71 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  72 #   endif
  73 # endif
  74 #
  75 # if defined __clang_major__
  76 #   if (__clang_major__ == 3 &amp;&amp; __clang_minor__ &gt;= 5)
  77 #     define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  78 #   elif (__clang_major__ &gt; 3)
  79 #     define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  80 #   endif
  81 #   if defined TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  82 #     define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
  83 #   elif (__clang_major__ == 3 &amp;&amp; __clang_minor__ == 4 &amp;&amp; __clang_patchlevel__ &gt;= 2)
  84 #     define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
  85 #   endif
  86 # endif
  87 #
  88 # if defined _MSC_VER
  89 #   if (_MSC_VER &gt;= 1900)
  90 #     define TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
  91 #   endif
  92 # endif
  93 
  94 # if defined __clang__
  95 #   if (__clang_major__ &gt; 2) || (__clang_major__ == 2) &amp;&amp; (__clang_minor__ &gt;= 9)
  96 #     define OPTIONAL_HAS_THIS_RVALUE_REFS 1
  97 #   else
  98 #     define OPTIONAL_HAS_THIS_RVALUE_REFS 0
  99 #   endif
 100 # elif defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
 101 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 1
 102 # elif defined TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
 103 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 1
 104 # else
 105 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 0
 106 # endif
 107 
 108 
 109 # if defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
 110 #   define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 1
 111 #   define OPTIONAL_CONSTEXPR_INIT_LIST constexpr
 112 # else
 113 #   define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 0
 114 #   define OPTIONAL_CONSTEXPR_INIT_LIST
 115 # endif
 116 
 117 # // In C++11 constexpr implies const, so we need to make non-const members also non-constexpr
 118 # if (defined __cplusplus) &amp;&amp; (__cplusplus == 201103L)
 119 #   define OPTIONAL_MUTABLE_CONSTEXPR
 120 # else
 121 #   define OPTIONAL_MUTABLE_CONSTEXPR constexpr
 122 # endif
 123 
 124 #if COMPILER_SUPPORTS(EXCEPTIONS)
 125 #define __THROW_EXCEPTION(__exception) throw __exception;
 126 #define __NOEXCEPT noexcept
 127 #define __NOEXCEPT_(__exception) noexcept(__exception)
 128 #else
 129 #define __THROW_EXCEPTION(__exception) do { (void)__exception; CRASH(); } while (0);
 130 #define __NOEXCEPT
 131 #define __NOEXCEPT_(...)
 132 #endif
 133 
 134 namespace WTF {
 135 namespace detail_ {
 136 
 137 // NOTE: All our target compilers support is_trivially_destructible.
 138 // // BEGIN workaround for missing is_trivially_destructible
 139 // # if defined TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
 140 //     // leave it: it is already there
 141 // # elif defined TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
 142 //     // leave it: it is already there
 143 // # elif defined TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
 144 //     // leave it: it is already there
 145 // # elif defined TR2_OPTIONAL_DISABLE_EMULATION_OF_TYPE_TRAITS
 146 //     // leave it: the user doesn&#39;t want it
 147 // # else
 148 //     template &lt;typename T&gt;
 149 //     using is_trivially_destructible = std::has_trivial_destructor&lt;T&gt;;
 150 // # endif
 151 // // END workaround for missing is_trivially_destructible
 152 
 153 #if COMPILER_SUPPORTS(EXCEPTIONS)
 154 # if defined(TR2_OPTIONAL_GCC_4_7_AND_HIGHER___) || defined(TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_) || defined(TR2_OPTIONAL_MSVC_2015_AND_HIGHER___)
 155     // leave it; our metafunctions are already defined.
 156     template &lt;typename T&gt;
 157     using is_nothrow_move_constructible = std::is_nothrow_move_constructible&lt;T&gt;;
 158     template &lt;typename T&gt;
 159     using is_nothrow_move_assignable = std::is_nothrow_move_assignable&lt;T&gt;;
 160 # elif defined TR2_OPTIONAL_DISABLE_EMULATION_OF_TYPE_TRAITS
 161     // leave it: the user doesn&#39;t want it
 162 # else
 163 
 164 
 165 // workaround for missing traits in GCC and CLANG
 166 template &lt;class T&gt;
 167 struct is_nothrow_move_constructible
 168 {
 169   constexpr static bool value = std::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value;
 170 };
 171 
 172 
 173 template &lt;class T, class U&gt;
 174 struct is_assignable
 175 {
 176   template &lt;class X, class Y&gt;
 177   constexpr static bool has_assign(...) { return false; }
 178 
 179   template &lt;class X, class Y, size_t S = sizeof((std::declval&lt;X&gt;() = std::declval&lt;Y&gt;(), true)) &gt;
 180   // the comma operator is necessary for the cases where operator= returns void
 181   constexpr static bool has_assign(bool) { return true; }
 182 
 183   constexpr static bool value = has_assign&lt;T, U&gt;(true);
 184 };
 185 
 186 
 187 template &lt;class T&gt;
 188 struct is_nothrow_move_assignable
 189 {
 190   template &lt;class X, bool has_any_move_assign&gt;
 191   struct has_nothrow_move_assign {
 192     constexpr static bool value = false;
 193   };
 194 
 195   template &lt;class X&gt;
 196   struct has_nothrow_move_assign&lt;X, true&gt; {
 197     constexpr static bool value = __NOEXCEPT_( std::declval&lt;X&amp;&gt;() = std::declval&lt;X&amp;&amp;&gt;() );
 198   };
 199 
 200   constexpr static bool value = has_nothrow_move_assign&lt;T, is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value&gt;::value;
 201 };
 202 // end workaround
 203 
 204 
 205 # endif
 206 #endif
 207 
 208 } // namespace detail_
 209 
 210 // 20.5.4, Optional for object types
 211 template &lt;class T&gt; class Optional;
 212 
 213 // 20.5.5, Optional for lvalue reference types
 214 template &lt;class T&gt; class Optional&lt;T&amp;&gt;;
 215 
 216 namespace detail_ {
 217 
 218 // workaround: std utility functions aren&#39;t constexpr yet
 219 template &lt;class T&gt; constexpr T&amp;&amp; constexpr_forward(typename std::remove_reference&lt;T&gt;::type&amp; t) __NOEXCEPT
 220 {
 221   return static_cast&lt;T&amp;&amp;&gt;(t);
 222 }
 223 
 224 template &lt;class T&gt; constexpr T&amp;&amp; constexpr_forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; t) __NOEXCEPT
 225 {
 226     static_assert(!std::is_lvalue_reference&lt;T&gt;::value, &quot;!!&quot;);
 227     return static_cast&lt;T&amp;&amp;&gt;(t);
 228 }
 229 
 230 template &lt;class T&gt; constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; constexpr_move(T&amp;&amp; t) __NOEXCEPT
 231 {
 232     return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
 233 }
 234 
 235 
 236 // static_addressof: a constexpr version of addressof
 237 template &lt;typename T&gt;
 238 struct has_overloaded_addressof
 239 {
 240   template &lt;class X&gt;
 241   constexpr static bool has_overload(...) { return false; }
 242 
 243   template &lt;class X, size_t S = sizeof(std::declval&lt;X&amp;&gt;().operator&amp;()) &gt;
 244   constexpr static bool has_overload(bool) { return true; }
 245 
 246   constexpr static bool value = has_overload&lt;T&gt;(true);
 247 };
 248 
 249 template &lt;typename T, TR2_OPTIONAL_REQUIRES(!has_overloaded_addressof&lt;T&gt;)&gt;
 250 constexpr T* static_addressof(T&amp; ref)
 251 {
 252   return &amp;ref;
 253 }
 254 
 255 template &lt;typename T, TR2_OPTIONAL_REQUIRES(has_overloaded_addressof&lt;T&gt;)&gt;
 256 T* static_addressof(T&amp; ref)
 257 {
 258   return std::addressof(ref);
 259 }
 260 
 261 
 262 // the call to convert&lt;A&gt;(b) has return type A and converts b to type A iff b decltype(b) is implicitly convertible to A
 263 template &lt;class U&gt;
 264 constexpr U convert(U v) { return v; }
 265 
 266 } // namespace detail
 267 
 268 
 269 constexpr struct trivial_init_t{} trivial_init{};
 270 
 271 
 272 // 20.5.7, Disengaged state indicator
 273 struct nullopt_t
 274 {
 275   struct init{};
 276   constexpr explicit nullopt_t(init){}
 277 };
 278 constexpr nullopt_t nullopt{nullopt_t::init()};
 279 
 280 
 281 template &lt;class T&gt;
 282 union storage_t
 283 {
 284   unsigned char dummy_;
 285   T value_;
 286 
 287   constexpr storage_t( trivial_init_t ) __NOEXCEPT : dummy_() {};
 288 
 289   template &lt;class... Args&gt;
 290   constexpr storage_t( Args&amp;&amp;... args ) : value_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 291 
 292   ~storage_t(){}
 293 };
 294 
 295 
 296 template &lt;class T&gt;
 297 union constexpr_storage_t
 298 {
 299     unsigned char dummy_;
 300     T value_;
 301 
 302     constexpr constexpr_storage_t( trivial_init_t ) __NOEXCEPT : dummy_() {};
 303 
 304     template &lt;class... Args&gt;
 305     constexpr constexpr_storage_t( Args&amp;&amp;... args ) : value_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 306 
 307     ~constexpr_storage_t() = default;
 308 };
 309 
 310 
 311 template &lt;class T&gt;
 312 struct Optional_base
 313 {
 314     bool init_;
 315     storage_t&lt;T&gt; storage_;
 316 
 317     constexpr Optional_base() __NOEXCEPT : init_(false), storage_(trivial_init) {};
 318 
 319     explicit constexpr Optional_base(const T&amp; v) : init_(true), storage_(v) {}
 320 
 321     explicit constexpr Optional_base(T&amp;&amp; v) : init_(true), storage_(detail_::constexpr_move(v)) {}
 322 
 323     template &lt;class... Args&gt; explicit Optional_base(std::in_place_t, Args&amp;&amp;... args)
 324         : init_(true), storage_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 325 
 326     template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 327     explicit Optional_base(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 328         : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}
 329 
 330     ~Optional_base() { if (init_) storage_.value_.T::~T(); }
 331 };
 332 
 333 
 334 template &lt;class T&gt;
 335 struct constexpr_Optional_base
 336 {
 337     bool init_;
 338     constexpr_storage_t&lt;T&gt; storage_;
 339 
 340     constexpr constexpr_Optional_base() __NOEXCEPT : init_(false), storage_(trivial_init) {};
 341 
 342     explicit constexpr constexpr_Optional_base(const T&amp; v) : init_(true), storage_(v) {}
 343 
 344     explicit constexpr constexpr_Optional_base(T&amp;&amp; v) : init_(true), storage_(detail_::constexpr_move(v)) {}
 345 
 346     template &lt;class... Args&gt; explicit constexpr constexpr_Optional_base(std::in_place_t, Args&amp;&amp;... args)
 347       : init_(true), storage_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 348 
 349     template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 350     OPTIONAL_CONSTEXPR_INIT_LIST explicit constexpr_Optional_base(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 351       : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}
 352 
 353     ~constexpr_Optional_base() = default;
 354 };
 355 
 356 template &lt;class T&gt;
 357 using OptionalBase = typename std::conditional&lt;
 358     std::is_trivially_destructible&lt;T&gt;::value,                          // if possible
 359     constexpr_Optional_base&lt;typename std::remove_const&lt;T&gt;::type&gt;, // use base with trivial destructor
 360     Optional_base&lt;typename std::remove_const&lt;T&gt;::type&gt;
 361 &gt;::type;
 362 
 363 
 364 
 365 template &lt;class T&gt;
 366 class Optional : private OptionalBase&lt;T&gt;
 367 {
 368   WTF_MAKE_FAST_ALLOCATED;
 369   static_assert( !std::is_same&lt;typename std::decay&lt;T&gt;::type, nullopt_t&gt;::value, &quot;bad T&quot; );
 370   static_assert( !std::is_same&lt;typename std::decay&lt;T&gt;::type, std::in_place_t&gt;::value, &quot;bad T&quot; );
 371 
 372 
 373   constexpr bool initialized() const __NOEXCEPT { return OptionalBase&lt;T&gt;::init_; }
 374   typename std::remove_const&lt;T&gt;::type* dataptr() {  return std::addressof(OptionalBase&lt;T&gt;::storage_.value_); }
 375   constexpr const T* dataptr() const { return detail_::static_addressof(OptionalBase&lt;T&gt;::storage_.value_); }
 376 
 377 # if OPTIONAL_HAS_THIS_RVALUE_REFS == 1
 378   constexpr const T&amp; contained_val() const&amp; { return OptionalBase&lt;T&gt;::storage_.value_; }
 379   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; contained_val() &amp;&amp; { return std::move(OptionalBase&lt;T&gt;::storage_.value_); }
 380   OPTIONAL_MUTABLE_CONSTEXPR T&amp; contained_val() &amp; { return OptionalBase&lt;T&gt;::storage_.value_; }
 381 # else
 382   constexpr const T&amp; contained_val() const { return OptionalBase&lt;T&gt;::storage_.value_; }
 383   T&amp; contained_val() { return OptionalBase&lt;T&gt;::storage_.value_; }
 384 # endif
 385 
 386   void clear() __NOEXCEPT {
 387     if (initialized()) dataptr()-&gt;T::~T();
 388     OptionalBase&lt;T&gt;::init_ = false;
 389   }
 390 
 391   template &lt;class... Args&gt;
 392   void initialize(Args&amp;&amp;... args) __NOEXCEPT_(__NOEXCEPT_(T(std::forward&lt;Args&gt;(args)...)))
 393   {
 394     ASSERT(!OptionalBase&lt;T&gt;::init_);
 395     ::new (static_cast&lt;void*&gt;(dataptr())) T(std::forward&lt;Args&gt;(args)...);
 396     OptionalBase&lt;T&gt;::init_ = true;
 397   }
 398 
 399   template &lt;class U, class... Args&gt;
 400   void initialize(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args) __NOEXCEPT_(__NOEXCEPT_(T(il, std::forward&lt;Args&gt;(args)...)))
 401   {
 402     ASSERT(!OptionalBase&lt;T&gt;::init_);
 403     ::new (static_cast&lt;void*&gt;(dataptr())) T(il, std::forward&lt;Args&gt;(args)...);
 404     OptionalBase&lt;T&gt;::init_ = true;
 405   }
 406 
 407 public:
 408   typedef T value_type;
 409 
 410   // 20.5.5.1, constructors
 411   constexpr Optional() __NOEXCEPT : OptionalBase&lt;T&gt;()  {};
 412   constexpr Optional(nullopt_t) __NOEXCEPT : OptionalBase&lt;T&gt;() {};
 413 
 414   Optional(const Optional&amp; rhs)
 415   : OptionalBase&lt;T&gt;()
 416   {
 417     if (rhs.initialized()) {
 418         ::new (static_cast&lt;void*&gt;(dataptr())) T(*rhs);
 419         OptionalBase&lt;T&gt;::init_ = true;
 420     }
 421   }
 422 
 423   Optional(Optional&amp;&amp; rhs) __NOEXCEPT_(detail_::is_nothrow_move_constructible&lt;T&gt;::value)
 424   : OptionalBase&lt;T&gt;()
 425   {
 426     if (rhs.initialized()) {
 427         ::new (static_cast&lt;void*&gt;(dataptr())) T(std::move(*rhs));
 428         OptionalBase&lt;T&gt;::init_ = true;
 429         rhs.clear();
 430     }
 431   }
 432 
 433   constexpr Optional(const T&amp; v) : OptionalBase&lt;T&gt;(v) {}
 434 
 435   constexpr Optional(T&amp;&amp; v) : OptionalBase&lt;T&gt;(detail_::constexpr_move(v)) {}
 436 
 437   template &lt;class... Args&gt;
 438   explicit constexpr Optional(std::in_place_t, Args&amp;&amp;... args)
 439       : OptionalBase&lt;T&gt;(std::in_place_t{}, detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 440 
 441   template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 442   OPTIONAL_CONSTEXPR_INIT_LIST explicit Optional(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 443       : OptionalBase&lt;T&gt;(std::in_place_t{}, il, detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 444 
 445   // 20.5.4.2, Destructor
 446   ~Optional() = default;
 447 
 448   // 20.5.4.3, assignment
 449   Optional&amp; operator=(nullopt_t) __NOEXCEPT
 450   {
 451     clear();
 452     return *this;
 453   }
 454 
 455   Optional&amp; operator=(const Optional&amp; rhs)
 456   {
 457     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) clear();
 458     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  initialize(*rhs);
 459     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  contained_val() = *rhs;
 460     return *this;
 461   }
 462 
 463   Optional&amp; operator=(Optional&amp;&amp; rhs)
 464   __NOEXCEPT_(detail_::is_nothrow_move_assignable&lt;T&gt;::value &amp;&amp; detail_::is_nothrow_move_constructible&lt;T&gt;::value)
 465   {
 466     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) clear();
 467     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  { initialize(std::move(*rhs)); rhs.clear(); }
 468     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  { contained_val() = std::move(*rhs); rhs.clear(); }
 469     return *this;
 470   }
 471 
 472   template &lt;class U&gt;
 473   auto operator=(U&amp;&amp; v)
 474   -&gt; typename std::enable_if
 475   &lt;
 476     std::is_same&lt;typename std::decay&lt;U&gt;::type, T&gt;::value,
 477     Optional&amp;
 478   &gt;::type
 479   {
 480     if (initialized()) { contained_val() = std::forward&lt;U&gt;(v); }
 481     else               { initialize(std::forward&lt;U&gt;(v));  }
 482     return *this;
 483   }
 484 
 485 
 486   template &lt;class... Args&gt;
 487   void emplace(Args&amp;&amp;... args)
 488   {
 489     clear();
 490     initialize(std::forward&lt;Args&gt;(args)...);
 491   }
 492 
 493   template &lt;class U, class... Args&gt;
 494   void emplace(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 495   {
 496     clear();
 497     initialize&lt;U, Args...&gt;(il, std::forward&lt;Args&gt;(args)...);
 498   }
 499 
 500   // 20.5.4.4, Swap
 501   void swap(Optional&lt;T&gt;&amp; rhs) __NOEXCEPT_(detail_::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; __NOEXCEPT_(swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;())))
 502   {
 503     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) { rhs.initialize(std::move(**this)); clear(); }
 504     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  { initialize(std::move(*rhs)); rhs.clear(); }
 505     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  { using std::swap; swap(**this, *rhs); }
 506   }
 507 
 508   // 20.5.4.5, Observers
 509 
 510   explicit constexpr operator bool() const __NOEXCEPT { return initialized(); }
 511   constexpr bool hasValue() const __NOEXCEPT { return initialized(); }
 512 
 513   constexpr T const* operator -&gt;() const {
 514     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 515     return dataptr();
 516   }
 517 
 518   OPTIONAL_MUTABLE_CONSTEXPR T* operator -&gt;() {
 519     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 520     return dataptr();
 521   }
 522 
 523   constexpr T const&amp; operator *() const&amp; {
 524     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 525     return contained_val();
 526   }
 527 
 528   OPTIONAL_MUTABLE_CONSTEXPR T&amp; operator *() &amp; {
 529     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 530     return contained_val();
 531   }
 532 
 533   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; operator *() &amp;&amp; {
 534     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 535     return detail_::constexpr_move(contained_val());
 536   }
 537 
 538   constexpr T const&amp; value() const&amp; {
 539     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 540     return contained_val();
 541   }
 542 
 543   OPTIONAL_MUTABLE_CONSTEXPR T&amp; value() &amp; {
 544     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 545     return contained_val();
 546   }
 547 
 548   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; value() &amp;&amp; {
 549     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 550     return std::move(contained_val());
 551   }
 552 
 553 # if OPTIONAL_HAS_THIS_RVALUE_REFS == 1
 554 
 555   template &lt;class V&gt;
 556   constexpr T valueOr(V&amp;&amp; v) const&amp;
 557   {
 558     return *this ? **this : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 559   }
 560 
 561   template &lt;class V&gt;
 562   OPTIONAL_MUTABLE_CONSTEXPR T valueOr(V&amp;&amp; v) &amp;&amp;
 563   {
 564     return *this ? detail_::constexpr_move(const_cast&lt;Optional&lt;T&gt;&amp;&gt;(*this).contained_val()) : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 565   }
 566 
 567 # else
 568 
 569   template &lt;class V&gt;
 570   constexpr T valueOr(V&amp;&amp; v) const
 571   {
 572     return *this ? **this : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 573   }
 574 
 575 # endif
 576 
 577   // 20.6.3.6, modifiers
 578   void reset() __NOEXCEPT { clear(); }
 579 };
 580 
 581 
 582 template &lt;class T&gt;
 583 class Optional&lt;T&amp;&gt;
 584 {
 585   WTF_MAKE_FAST_ALLOCATED;
 586   static_assert( !std::is_same&lt;T, nullopt_t&gt;::value, &quot;bad T&quot; );
 587   static_assert( !std::is_same&lt;T, std::in_place_t&gt;::value, &quot;bad T&quot; );
 588   T* ref;
 589 
 590 public:
 591 
 592   // 20.5.5.1, construction/destruction
 593   constexpr Optional() __NOEXCEPT : ref(nullptr) {}
 594 
 595   constexpr Optional(nullopt_t) __NOEXCEPT : ref(nullptr) {}
 596 
 597   constexpr Optional(T&amp; v) __NOEXCEPT : ref(detail_::static_addressof(v)) {}
 598 
 599   Optional(T&amp;&amp;) = delete;
 600 
 601   constexpr Optional(const Optional&amp; rhs) __NOEXCEPT : ref(rhs.ref) {}
 602 
 603   explicit constexpr Optional(std::in_place_t, T&amp; v) __NOEXCEPT : ref(detail_::static_addressof(v)) {}
 604 
 605   explicit Optional(std::in_place_t, T&amp;&amp;) = delete;
 606 
 607   ~Optional() = default;
 608 
 609   // 20.5.5.2, mutation
 610   Optional&amp; operator=(nullopt_t) __NOEXCEPT {
 611     ref = nullptr;
 612     return *this;
 613   }
 614 
 615   // Optional&amp; operator=(const Optional&amp; rhs) __NOEXCEPT {
 616     // ref = rhs.ref;
 617     // return *this;
 618   // }
 619 
 620   // Optional&amp; operator=(Optional&amp;&amp; rhs) __NOEXCEPT {
 621     // ref = rhs.ref;
 622     // return *this;
 623   // }
 624 
 625   template &lt;typename U&gt;
 626   auto operator=(U&amp;&amp; rhs) __NOEXCEPT
 627   -&gt; typename std::enable_if
 628   &lt;
 629     std::is_same&lt;typename std::decay&lt;U&gt;::type, Optional&lt;T&amp;&gt;&gt;::value,
 630     Optional&amp;
 631   &gt;::type
 632   {
 633     ref = rhs.ref;
 634     return *this;
 635   }
 636 
 637   template &lt;typename U&gt;
 638   auto operator=(U&amp;&amp; rhs) __NOEXCEPT
 639   -&gt; typename std::enable_if
 640   &lt;
 641     !std::is_same&lt;typename std::decay&lt;U&gt;::type, Optional&lt;T&amp;&gt;&gt;::value,
 642     Optional&amp;
 643   &gt;::type
 644   = delete;
 645 
 646   void emplace(T&amp; v) __NOEXCEPT {
 647     ref = detail_::static_addressof(v);
 648   }
 649 
 650   void emplace(T&amp;&amp;) = delete;
 651 
 652 
 653   void swap(Optional&lt;T&amp;&gt;&amp; rhs) __NOEXCEPT
 654   {
 655     std::swap(ref, rhs.ref);
 656   }
 657 
 658   // 20.5.5.3, observers
 659   constexpr T* operator-&gt;() const {
 660     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref);
 661     return ref;
 662   }
 663 
 664   constexpr T&amp; operator*() const {
 665     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref);
 666     return *ref;
 667   }
 668 
 669   constexpr T&amp; value() const {
 670     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref());
 671     return *ref;
 672   }
 673 
 674   explicit constexpr operator bool() const __NOEXCEPT {
 675     return ref != nullptr;
 676   }
 677 
 678   constexpr bool hasValue() const __NOEXCEPT {
 679     return ref != nullptr;
 680   }
 681 
 682   template &lt;class V&gt;
 683   constexpr typename std::decay&lt;T&gt;::type valueOr(V&amp;&amp; v) const
 684   {
 685     return *this ? **this : detail_::convert&lt;typename std::decay&lt;T&gt;::type&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 686   }
 687 
 688   // x.x.x.x, modifiers
 689   void reset() __NOEXCEPT { ref = nullptr; }
 690 };
 691 
 692 
 693 template &lt;class T&gt;
 694 class Optional&lt;T&amp;&amp;&gt;
 695 {
 696   static_assert( sizeof(T) == 0, &quot;Optional rvalue references disallowed&quot; );
 697 };
 698 
 699 
 700 // 20.5.8, Relational operators
 701 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 702 {
 703   return bool(x) != bool(y) ? false : bool(x) == false ? true : *x == *y;
 704 }
 705 
 706 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 707 {
 708   return !(x == y);
 709 }
 710 
 711 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 712 {
 713   return (!y) ? false : (!x) ? true : *x &lt; *y;
 714 }
 715 
 716 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 717 {
 718   return (y &lt; x);
 719 }
 720 
 721 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 722 {
 723   return !(y &lt; x);
 724 }
 725 
 726 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 727 {
 728   return !(x &lt; y);
 729 }
 730 
 731 
 732 // 20.5.9, Comparison with nullopt
 733 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 734 {
 735   return (!x);
 736 }
 737 
 738 template &lt;class T&gt; constexpr bool operator==(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 739 {
 740   return (!x);
 741 }
 742 
 743 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 744 {
 745   return bool(x);
 746 }
 747 
 748 template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 749 {
 750   return bool(x);
 751 }
 752 
 753 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp;, nullopt_t) __NOEXCEPT
 754 {
 755   return false;
 756 }
 757 
 758 template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 759 {
 760   return bool(x);
 761 }
 762 
 763 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 764 {
 765   return (!x);
 766 }
 767 
 768 template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const Optional&lt;T&gt;&amp;) __NOEXCEPT
 769 {
 770   return true;
 771 }
 772 
 773 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 774 {
 775   return bool(x);
 776 }
 777 
 778 template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const Optional&lt;T&gt;&amp;) __NOEXCEPT
 779 {
 780   return false;
 781 }
 782 
 783 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp;, nullopt_t) __NOEXCEPT
 784 {
 785   return true;
 786 }
 787 
 788 template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 789 {
 790   return (!x);
 791 }
 792 
 793 
 794 
 795 // 20.5.10, Comparison with T
 796 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 797 {
 798   return bool(x) ? *x == v : false;
 799 }
 800 
 801 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 802 {
 803   return bool(x) ? v == *x : false;
 804 }
 805 
 806 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 807 {
 808   return bool(x) ? *x != v : true;
 809 }
 810 
 811 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 812 {
 813   return bool(x) ? v != *x : true;
 814 }
 815 
 816 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 817 {
 818   return bool(x) ? *x &lt; v : true;
 819 }
 820 
 821 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 822 {
 823   return bool(x) ? v &gt; *x : true;
 824 }
 825 
 826 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 827 {
 828   return bool(x) ? *x &gt; v : false;
 829 }
 830 
 831 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 832 {
 833   return bool(x) ? v &lt; *x : false;
 834 }
 835 
 836 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 837 {
 838   return bool(x) ? *x &gt;= v : false;
 839 }
 840 
 841 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 842 {
 843   return bool(x) ? v &lt;= *x : false;
 844 }
 845 
 846 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 847 {
 848   return bool(x) ? *x &lt;= v : true;
 849 }
 850 
 851 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 852 {
 853   return bool(x) ? v &gt;= *x : true;
 854 }
 855 
 856 
 857 // Comparison of Optional&lt;T&amp;&gt; with T
 858 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 859 {
 860   return bool(x) ? *x == v : false;
 861 }
 862 
 863 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 864 {
 865   return bool(x) ? v == *x : false;
 866 }
 867 
 868 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 869 {
 870   return bool(x) ? *x != v : true;
 871 }
 872 
 873 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 874 {
 875   return bool(x) ? v != *x : true;
 876 }
 877 
 878 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 879 {
 880   return bool(x) ? *x &lt; v : true;
 881 }
 882 
 883 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 884 {
 885   return bool(x) ? v &gt; *x : true;
 886 }
 887 
 888 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 889 {
 890   return bool(x) ? *x &gt; v : false;
 891 }
 892 
 893 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 894 {
 895   return bool(x) ? v &lt; *x : false;
 896 }
 897 
 898 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 899 {
 900   return bool(x) ? *x &gt;= v : false;
 901 }
 902 
 903 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 904 {
 905   return bool(x) ? v &lt;= *x : false;
 906 }
 907 
 908 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 909 {
 910   return bool(x) ? *x &lt;= v : true;
 911 }
 912 
 913 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 914 {
 915   return bool(x) ? v &gt;= *x : true;
 916 }
 917 
 918 // Comparison of Optional&lt;T const&amp;&gt; with T
 919 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 920 {
 921   return bool(x) ? *x == v : false;
 922 }
 923 
 924 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 925 {
 926   return bool(x) ? v == *x : false;
 927 }
 928 
 929 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 930 {
 931   return bool(x) ? *x != v : true;
 932 }
 933 
 934 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 935 {
 936   return bool(x) ? v != *x : true;
 937 }
 938 
 939 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 940 {
 941   return bool(x) ? *x &lt; v : true;
 942 }
 943 
 944 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 945 {
 946   return bool(x) ? v &gt; *x : true;
 947 }
 948 
 949 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 950 {
 951   return bool(x) ? *x &gt; v : false;
 952 }
 953 
 954 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 955 {
 956   return bool(x) ? v &lt; *x : false;
 957 }
 958 
 959 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 960 {
 961   return bool(x) ? *x &gt;= v : false;
 962 }
 963 
 964 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 965 {
 966   return bool(x) ? v &lt;= *x : false;
 967 }
 968 
 969 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 970 {
 971   return bool(x) ? *x &lt;= v : true;
 972 }
 973 
 974 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 975 {
 976   return bool(x) ? v &gt;= *x : true;
 977 }
 978 
 979 
 980 // 20.5.12, Specialized algorithms
 981 template &lt;class T&gt;
 982 void swap(Optional&lt;T&gt;&amp; x, Optional&lt;T&gt;&amp; y) __NOEXCEPT_(__NOEXCEPT_(x.swap(y)))
 983 {
 984   x.swap(y);
 985 }
 986 
 987 
 988 template &lt;class T&gt;
 989 constexpr Optional&lt;typename std::decay&lt;T&gt;::type&gt; makeOptional(T&amp;&amp; v)
 990 {
 991   return Optional&lt;typename std::decay&lt;T&gt;::type&gt;(detail_::constexpr_forward&lt;T&gt;(v));
 992 }
 993 
 994 template &lt;class X&gt;
 995 constexpr Optional&lt;X&amp;&gt; makeOptional(std::reference_wrapper&lt;X&gt; v)
 996 {
 997   return Optional&lt;X&amp;&gt;(v.get());
 998 }
 999 
1000 } // namespace WTF
1001 
1002 namespace std
1003 {
1004   template &lt;typename T&gt;
1005   struct hash&lt;WTF::Optional&lt;T&gt;&gt;
1006   {
1007     typedef typename hash&lt;T&gt;::result_type result_type;
1008     typedef WTF::Optional&lt;T&gt; argument_type;
1009 
1010     constexpr result_type operator()(argument_type const&amp; arg) const {
1011       return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
1012     }
1013   };
1014 
1015   template &lt;typename T&gt;
1016   struct hash&lt;WTF::Optional&lt;T&amp;&gt;&gt;
1017   {
1018     typedef typename hash&lt;T&gt;::result_type result_type;
1019     typedef WTF::Optional&lt;T&amp;&gt; argument_type;
1020 
1021     constexpr result_type operator()(argument_type const&amp; arg) const {
1022       return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
1023     }
1024   };
1025 }
1026 
1027 # undef TR2_OPTIONAL_REQUIRES
1028 
1029 namespace WTF {
1030 
1031 // -- WebKit Additions --
1032 template &lt;class OptionalType, class Callback&gt;
1033 ALWAYS_INLINE
1034 auto valueOrCompute(OptionalType Optional, Callback callback) -&gt; typename OptionalType::value_type
1035 {
1036     if (Optional)
1037         return *Optional;
1038     return callback();
1039 }
1040 
1041 } // namespace WTF
1042 
1043 using WTF::Optional;
1044 using WTF::makeOptional;
1045 using WTF::valueOrCompute;
    </pre>
  </body>
</html>