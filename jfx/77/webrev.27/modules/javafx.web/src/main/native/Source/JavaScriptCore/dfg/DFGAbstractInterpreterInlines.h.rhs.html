<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
  36 #include &quot;GetByIdStatus.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;MathCommon.h&quot;
  42 #include &quot;NumberConstructor.h&quot;
  43 #include &quot;Operations.h&quot;
  44 #include &quot;PutByIdStatus.h&quot;
  45 #include &quot;StringObject.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  46 #include &quot;StructureCache.h&quot;</span>
  47 #include &quot;StructureRareDataInlines.h&quot;
  48 #include &lt;wtf/BooleanLattice.h&gt;
  49 #include &lt;wtf/CheckedArithmetic.h&gt;
  50 
  51 namespace JSC { namespace DFG {
  52 
  53 template&lt;typename AbstractStateType&gt;
  54 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  55     : m_codeBlock(graph.m_codeBlock)
  56     , m_graph(graph)
  57     , m_vm(m_graph.m_vm)
  58     , m_state(state)
  59 {
  60     if (m_graph.m_form == SSA)
<a name="3" id="anc3"></a><span class="line-modified">  61         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);</span>
  62 }
  63 
  64 template&lt;typename AbstractStateType&gt;
  65 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  66 {
  67 }
  68 
  69 template&lt;typename AbstractStateType&gt;
  70 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  71 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  72     Node* node, AbstractValue&amp; value)
  73 {
  74     JSValue childConst = value.value();
  75     if (childConst) {
  76         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))
  77             return DefinitelyTrue;
  78         return DefinitelyFalse;
  79     }
  80 
  81     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
  82     if (isCellSpeculation(value.m_type) &amp;&amp; !value.m_structure.isTop()) {
  83         bool allTrue = true;
  84         for (unsigned i = value.m_structure.size(); i--;) {
  85             RegisteredStructure structure = value.m_structure[i];
  86             if (structure-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
  87                 || structure-&gt;typeInfo().type() == StringType) {
  88                 allTrue = false;
  89                 break;
  90             }
  91         }
  92         if (allTrue)
  93             return DefinitelyTrue;
  94     }
  95 
  96     return UnknownBooleanResult;
  97 }
  98 
  99 template&lt;typename AbstractStateType&gt;
 100 void AbstractInterpreter&lt;AbstractStateType&gt;::startExecuting()
 101 {
 102     ASSERT(m_state.block());
 103     ASSERT(m_state.isValid());
 104 
 105     m_state.setClobberState(AbstractInterpreterClobberState::NotClobbered);
 106 }
 107 
 108 template&lt;typename AbstractStateType&gt;
 109 class AbstractInterpreterExecuteEdgesFunc {
 110 public:
 111     AbstractInterpreterExecuteEdgesFunc(AbstractInterpreter&lt;AbstractStateType&gt;&amp; interpreter)
 112         : m_interpreter(interpreter)
 113     {
 114     }
 115 
 116     // This func is manually written out so that we can put ALWAYS_INLINE on it.
 117     ALWAYS_INLINE void operator()(Edge&amp; edge) const
 118     {
 119         m_interpreter.filterEdgeByUse(edge);
 120     }
 121 
 122 private:
 123     AbstractInterpreter&lt;AbstractStateType&gt;&amp; m_interpreter;
 124 };
 125 
 126 template&lt;typename AbstractStateType&gt;
 127 void AbstractInterpreter&lt;AbstractStateType&gt;::executeEdges(Node* node)
 128 {
 129     m_graph.doToChildren(node, AbstractInterpreterExecuteEdgesFunc&lt;AbstractStateType&gt;(*this));
 130 }
 131 
 132 template&lt;typename AbstractStateType&gt;
 133 void AbstractInterpreter&lt;AbstractStateType&gt;::executeKnownEdgeTypes(Node* node)
 134 {
 135     // Some use kinds are required to not have checks, because we know somehow that the incoming
 136     // value will already have the type we want. In those cases, AI may not be smart enough to
 137     // prove that this is indeed the case. But the existance of the edge is enough to prove that
 138     // it is indeed the case. Taking advantage of this is not optional, since otherwise the DFG
 139     // and FTL backends may emit checks in a node that lacks a valid exit origin.
 140     m_graph.doToChildren(
 141         node,
 142         [&amp;] (Edge&amp; edge) {
 143             if (mayHaveTypeCheck(edge.useKind()))
 144                 return;
 145 
 146             filterEdgeByUse(edge);
 147         });
 148 }
 149 
 150 template&lt;typename AbstractStateType&gt;
 151 ALWAYS_INLINE void AbstractInterpreter&lt;AbstractStateType&gt;::filterByType(Edge&amp; edge, SpeculatedType type)
 152 {
 153     AbstractValue&amp; value = m_state.forNodeWithoutFastForward(edge);
 154     if (value.isType(type)) {
 155         m_state.setProofStatus(edge, IsProved);
 156         return;
 157     }
 158     m_state.setProofStatus(edge, NeedsCheck);
 159     m_state.fastForwardAndFilterUnproven(value, type);
 160 }
 161 
 162 template&lt;typename AbstractStateType&gt;
 163 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdge(Node* node, Edge edge)
 164 {
 165     if (!(m_state.forNodeWithoutFastForward(edge).m_type &amp; ~typeFilterFor(edge.useKind())))
 166         return;
 167 
 168     DFG_CRASH(m_graph, node, toCString(&quot;Edge verification error: &quot;, node, &quot;-&gt;&quot;, edge, &quot; was expected to have type &quot;, SpeculationDump(typeFilterFor(edge.useKind())), &quot; but has type &quot;, SpeculationDump(forNode(edge).m_type), &quot; (&quot;, forNode(edge).m_type, &quot;)&quot;).data(), AbstractInterpreterInvalidType, node-&gt;op(), edge-&gt;op(), edge.useKind(), forNode(edge).m_type);
 169 }
 170 
 171 template&lt;typename AbstractStateType&gt;
 172 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdges(Node* node)
 173 {
 174     DFG_NODE_DO_TO_CHILDREN(m_graph, node, verifyEdge);
 175 }
 176 
 177 enum class ToThisResult {
 178     Identity,
 179     Undefined,
 180     GlobalThis,
 181     Dynamic,
 182 };
 183 inline ToThisResult isToThisAnIdentity(VM&amp; vm, bool isStrictMode, AbstractValue&amp; valueForNode)
 184 {
 185     // We look at the type first since that will cover most cases and does not require iterating all the structures.
 186     if (isStrictMode) {
 187         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; SpecObjectOther))
 188             return ToThisResult::Identity;
 189     } else {
 190         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; (~SpecObject | SpecObjectOther)))
 191             return ToThisResult::Identity;
 192     }
 193 
 194     if (JSValue value = valueForNode.value()) {
 195         if (value.isCell()) {
 196             auto* toThisMethod = value.asCell()-&gt;classInfo(vm)-&gt;methodTable.toThis;
 197             if (toThisMethod == &amp;JSObject::toThis)
 198                 return ToThisResult::Identity;
 199             if (toThisMethod == &amp;JSScope::toThis) {
 200                 if (isStrictMode)
 201                     return ToThisResult::Undefined;
 202                 return ToThisResult::GlobalThis;
 203             }
 204         }
 205     }
 206 
 207     if ((isStrictMode || (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; ~SpecObject))) &amp;&amp; valueForNode.m_structure.isFinite()) {
 208         bool allStructuresAreJSScope = !valueForNode.m_structure.isClear();
 209         bool overridesToThis = false;
 210         valueForNode.m_structure.forEach([&amp;](RegisteredStructure structure) {
 211             TypeInfo type = structure-&gt;typeInfo();
 212             ASSERT(type.isObject() || type.type() == StringType || type.type() == SymbolType || type.type() == BigIntType);
 213             if (!isStrictMode)
 214                 ASSERT(type.isObject());
 215             // We don&#39;t need to worry about strings/symbols here since either:
 216             // 1) We are in strict mode and strings/symbols are not wrapped
 217             // 2) The AI has proven that the type of this is a subtype of object
 218             if (type.isObject() &amp;&amp; type.overridesToThis())
 219                 overridesToThis = true;
 220 
 221             // If all the structures are JSScope&#39;s ones, we know the details of JSScope::toThis() operation.
 222             allStructuresAreJSScope &amp;= structure-&gt;classInfo()-&gt;methodTable.toThis == JSScope::info()-&gt;methodTable.toThis;
 223         });
 224         if (!overridesToThis)
 225             return ToThisResult::Identity;
 226         if (allStructuresAreJSScope) {
 227             if (isStrictMode)
 228                 return ToThisResult::Undefined;
 229             return ToThisResult::GlobalThis;
 230         }
 231     }
 232 
 233     return ToThisResult::Dynamic;
 234 }
 235 
<a name="4" id="anc4"></a><span class="line-added"> 236 template&lt;typename AbstractStateType&gt;</span>
<span class="line-added"> 237 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantBinaryBitwiseOp(Node* node)</span>
<span class="line-added"> 238 {</span>
<span class="line-added"> 239     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 240     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 241     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-added"> 242         int32_t a = left.asInt32();</span>
<span class="line-added"> 243         int32_t b = right.asInt32();</span>
<span class="line-added"> 244         if (node-&gt;isBinaryUseKind(UntypedUse))</span>
<span class="line-added"> 245             didFoldClobberWorld();</span>
<span class="line-added"> 246         NodeType op = node-&gt;op();</span>
<span class="line-added"> 247         switch (op) {</span>
<span class="line-added"> 248         case ValueBitAnd:</span>
<span class="line-added"> 249         case ArithBitAnd:</span>
<span class="line-added"> 250             setConstant(node, JSValue(a &amp; b));</span>
<span class="line-added"> 251             break;</span>
<span class="line-added"> 252         case ValueBitOr:</span>
<span class="line-added"> 253         case ArithBitOr:</span>
<span class="line-added"> 254             setConstant(node, JSValue(a | b));</span>
<span class="line-added"> 255             break;</span>
<span class="line-added"> 256         case ValueBitXor:</span>
<span class="line-added"> 257         case ArithBitXor:</span>
<span class="line-added"> 258             setConstant(node, JSValue(a ^ b));</span>
<span class="line-added"> 259             break;</span>
<span class="line-added"> 260         case BitRShift:</span>
<span class="line-added"> 261             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-added"> 262             break;</span>
<span class="line-added"> 263         case ValueBitLShift:</span>
<span class="line-added"> 264         case ArithBitLShift:</span>
<span class="line-added"> 265             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));</span>
<span class="line-added"> 266             break;</span>
<span class="line-added"> 267         case BitURShift:</span>
<span class="line-added"> 268             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));</span>
<span class="line-added"> 269             break;</span>
<span class="line-added"> 270         default:</span>
<span class="line-added"> 271             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 272             break;</span>
<span class="line-added"> 273         }</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275         return true;</span>
<span class="line-added"> 276     }</span>
<span class="line-added"> 277 </span>
<span class="line-added"> 278     return false;</span>
<span class="line-added"> 279 }</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281 template&lt;typename AbstractStateType&gt;</span>
<span class="line-added"> 282 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantDivOp(Node* node)</span>
<span class="line-added"> 283 {</span>
<span class="line-added"> 284     JSValue left = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 285     JSValue right = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     if (left &amp;&amp; right) {</span>
<span class="line-added"> 288         NodeType op = node-&gt;op();</span>
<span class="line-added"> 289         bool isDivOperation = op == ValueDiv || op == ArithDiv;</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291         // Only possible case of ValueOp below is UntypedUse,</span>
<span class="line-added"> 292         // so we need to reflect clobberize rules.</span>
<span class="line-added"> 293         bool isClobbering = op == ValueDiv || op == ValueMod;</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295         if (left.isInt32() &amp;&amp; right.isInt32()) {</span>
<span class="line-added"> 296             double doubleResult;</span>
<span class="line-added"> 297             if (isDivOperation)</span>
<span class="line-added"> 298                 doubleResult = left.asNumber() / right.asNumber();</span>
<span class="line-added"> 299             else</span>
<span class="line-added"> 300                 doubleResult = fmod(left.asNumber(), right.asNumber());</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302             if (node-&gt;hasArithMode()) {</span>
<span class="line-added"> 303                 if (!shouldCheckOverflow(node-&gt;arithMode()))</span>
<span class="line-added"> 304                     doubleResult = toInt32(doubleResult);</span>
<span class="line-added"> 305                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))</span>
<span class="line-added"> 306                     doubleResult += 0; // Sanitizes zero.</span>
<span class="line-added"> 307             }</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309             JSValue valueResult = jsNumber(doubleResult);</span>
<span class="line-added"> 310             if (valueResult.isInt32()) {</span>
<span class="line-added"> 311                 if (isClobbering)</span>
<span class="line-added"> 312                     didFoldClobberWorld();</span>
<span class="line-added"> 313                 setConstant(node, valueResult);</span>
<span class="line-added"> 314                 return true;</span>
<span class="line-added"> 315             }</span>
<span class="line-added"> 316         } else if (left.isNumber() &amp;&amp; right.isNumber()) {</span>
<span class="line-added"> 317             if (isClobbering)</span>
<span class="line-added"> 318                 didFoldClobberWorld();</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320             if (isDivOperation)</span>
<span class="line-added"> 321                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-added"> 322             else</span>
<span class="line-added"> 323                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325             return true;</span>
<span class="line-added"> 326         }</span>
<span class="line-added"> 327     }</span>
<span class="line-added"> 328 </span>
<span class="line-added"> 329     return false;</span>
<span class="line-added"> 330 }</span>
<span class="line-added"> 331 </span>
 332 template&lt;typename AbstractStateType&gt;
 333 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 334 {
 335     verifyEdges(node);
 336 
 337     m_state.createValueForNode(node);
 338 
 339     switch (node-&gt;op()) {
 340     case JSConstant:
 341     case DoubleConstant:
 342     case Int52Constant: {
 343         setBuiltInConstant(node, *node-&gt;constant());
 344         break;
 345     }
 346 
 347     case LazyJSConstant: {
 348         LazyJSValue value = node-&gt;lazyJSValue();
 349         switch (value.kind()) {
 350         case LazyJSValue::KnownValue:
 351             setConstant(node, value.value()-&gt;value());
 352             break;
 353         case LazyJSValue::SingleCharacterString:
 354         case LazyJSValue::KnownStringImpl:
 355         case LazyJSValue::NewStringImpl:
 356             setTypeForNode(node, SpecString);
 357             break;
 358         }
 359         break;
 360     }
 361 
 362     case IdentityWithProfile:
 363     case Identity: {
 364         setForNode(node, forNode(node-&gt;child1()));
 365         if (forNode(node).value())
 366             m_state.setFoundConstants(true);
 367         break;
 368     }
 369 
 370     case ExtractCatchLocal:
 371     case ExtractOSREntryLocal: {
 372         makeBytecodeTopForNode(node);
 373         break;
 374     }
 375 
 376     case GetLocal: {
 377         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 378         AbstractValue value = m_state.operand(variableAccessData-&gt;local().offset());
 379         // The value in the local should already be checked.
 380         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
 381         if (value.value())
 382             m_state.setFoundConstants(true);
 383         setForNode(node, value);
 384         break;
 385     }
 386 
 387     case GetStack: {
 388         StackAccessData* data = node-&gt;stackAccessData();
 389         AbstractValue value = m_state.operand(data-&gt;local);
 390         // The value in the local should already be checked.
 391         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
 392         if (value.value())
 393             m_state.setFoundConstants(true);
 394         setForNode(node, value);
 395         break;
 396     }
 397 
 398     case SetLocal: {
 399         m_state.operand(node-&gt;local()) = forNode(node-&gt;child1());
 400         break;
 401     }
 402 
 403     case PutStack: {
 404         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());
 405         break;
 406     }
 407 
 408     case MovHint: {
 409         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 410         // in bytecode, but this code is just concerned with what is actually happening during
 411         // DFG execution.
 412         break;
 413     }
 414 
 415     case KillStack: {
 416         // This is just a hint telling us that the OSR state of the local is no longer inside the
 417         // flushed data.
 418         break;
 419     }
 420 
<a name="5" id="anc5"></a><span class="line-modified"> 421     case SetArgumentDefinitely:</span>
<span class="line-modified"> 422     case SetArgumentMaybe:</span>
<span class="line-modified"> 423         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means</span>
<span class="line-added"> 424         // that someone set the argument values out-of-band, and currently this always means setting to a</span>
 425         // non-clear value.
 426         ASSERT(!m_state.operand(node-&gt;local()).isClear());
 427         break;
 428 
 429     case InitializeEntrypointArguments: {
 430         unsigned entrypointIndex = node-&gt;entrypointIndex();
 431         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 432         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 433             AbstractValue&amp; value = m_state.argument(argument);
 434             switch (argumentFormats[argument]) {
 435             case FlushedInt32:
 436                 value.setNonCellType(SpecInt32Only);
 437                 break;
 438             case FlushedBoolean:
 439                 value.setNonCellType(SpecBoolean);
 440                 break;
 441             case FlushedCell:
 442                 value.setType(m_graph, SpecCellCheck);
 443                 break;
 444             case FlushedJSValue:
 445                 value.makeBytecodeTop();
 446                 break;
 447             default:
 448                 DFG_CRASH(m_graph, node, &quot;Bad flush format for argument&quot;);
 449                 break;
 450             }
 451         }
 452         break;
 453     }
 454 
 455     case LoadVarargs:
 456     case ForwardVarargs: {
 457         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 458         // itself into a straight-line sequence of GetStack/PutStack.
 459         // https://bugs.webkit.org/show_bug.cgi?id=143071
 460         switch (node-&gt;op()) {
 461         case LoadVarargs:
 462             clobberWorld();
 463             break;
 464         case ForwardVarargs:
 465             break;
 466         default:
 467             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 468             break;
 469         }
 470         LoadVarargsData* data = node-&gt;loadVarargsData();
 471         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 472         for (unsigned i = data-&gt;limit - 1; i--;)
 473             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();
 474         break;
 475     }
 476 
<a name="6" id="anc6"></a><span class="line-modified"> 477     case ValueBitNot: {</span>
<span class="line-modified"> 478         JSValue operand = forNode(node-&gt;child1()).value();</span>
<span class="line-modified"> 479         if (operand &amp;&amp; operand.isInt32()) {</span>
<span class="line-modified"> 480             didFoldClobberWorld();</span>
<span class="line-added"> 481             int32_t a = operand.asInt32();</span>
<span class="line-added"> 482             setConstant(node, JSValue(~a));</span>
 483             break;
 484         }
 485 
<a name="7" id="anc7"></a><span class="line-added"> 486         if (node-&gt;child1().useKind() == BigIntUse)</span>
<span class="line-added"> 487             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added"> 488         else {</span>
<span class="line-added"> 489             clobberWorld();</span>
<span class="line-added"> 490             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
<span class="line-added"> 491         }</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493         break;</span>
<span class="line-added"> 494     }</span>
<span class="line-added"> 495 </span>
<span class="line-added"> 496     case ArithBitNot: {</span>
 497         JSValue operand = forNode(node-&gt;child1()).value();
 498         if (operand &amp;&amp; operand.isInt32()) {
 499             int32_t a = operand.asInt32();
 500             setConstant(node, JSValue(~a));
 501             break;
 502         }
 503 
 504         setNonCellTypeForNode(node, SpecInt32Only);
 505         break;
 506     }
 507 
 508     case ValueBitXor:
 509     case ValueBitAnd:
 510     case ValueBitOr:
<a name="8" id="anc8"></a><span class="line-added"> 511     case ValueBitLShift: {</span>
<span class="line-added"> 512         if (handleConstantBinaryBitwiseOp(node))</span>
<span class="line-added"> 513             break;</span>
<span class="line-added"> 514 </span>
 515         if (node-&gt;binaryUseKind() == BigIntUse)
 516             setTypeForNode(node, SpecBigInt);
 517         else {
 518             clobberWorld();
<a name="9" id="anc9"></a><span class="line-modified"> 519             setTypeForNode(node, SpecInt32Only | SpecBigInt);</span>
 520         }
 521         break;
<a name="10" id="anc10"></a><span class="line-added"> 522     }</span>
 523 
 524     case ArithBitAnd:
 525     case ArithBitOr:
 526     case ArithBitXor:
 527     case BitRShift:
<a name="11" id="anc11"></a><span class="line-modified"> 528     case ArithBitLShift:</span>
 529     case BitURShift: {
 530         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 531             clobberWorld();
 532             setNonCellTypeForNode(node, SpecInt32Only);
 533             break;
 534         }
 535 
<a name="12" id="anc12"></a><span class="line-modified"> 536         if (handleConstantBinaryBitwiseOp(node))</span>



























 537             break;
<a name="13" id="anc13"></a>
 538 
 539         if (node-&gt;op() == ArithBitAnd
 540             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 541                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 542             setNonCellTypeForNode(node, SpecBoolInt32);
 543             break;
 544         }
 545 
 546         setNonCellTypeForNode(node, SpecInt32Only);
 547         break;
 548     }
 549 
 550     case UInt32ToNumber: {
 551         JSValue child = forNode(node-&gt;child1()).value();
 552         if (doesOverflow(node-&gt;arithMode())) {
 553             if (enableInt52()) {
 554                 if (child &amp;&amp; child.isAnyInt()) {
 555                     int64_t machineInt = child.asAnyInt();
 556                     setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
 557                     break;
 558                 }
<a name="14" id="anc14"></a><span class="line-modified"> 559                 setNonCellTypeForNode(node, SpecInt52Any);</span>
 560                 break;
 561             }
 562             if (child &amp;&amp; child.isInt32()) {
 563                 uint32_t value = child.asInt32();
 564                 setConstant(node, jsNumber(value));
 565                 break;
 566             }
 567             setNonCellTypeForNode(node, SpecAnyIntAsDouble);
 568             break;
 569         }
 570         if (child &amp;&amp; child.isInt32()) {
 571             int32_t value = child.asInt32();
 572             if (value &gt;= 0) {
 573                 setConstant(node, jsNumber(value));
 574                 break;
 575             }
 576         }
 577         setNonCellTypeForNode(node, SpecInt32Only);
 578         break;
 579     }
 580 
 581     case BooleanToNumber: {
 582         JSValue concreteValue = forNode(node-&gt;child1()).value();
 583         if (concreteValue) {
 584             if (concreteValue.isBoolean())
 585                 setConstant(node, jsNumber(concreteValue.asBoolean()));
 586             else
 587                 setConstant(node, *m_graph.freeze(concreteValue));
 588             break;
 589         }
 590         AbstractValue&amp; value = forNode(node);
 591         value = forNode(node-&gt;child1());
 592         if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
 593             m_state.setFoundConstants(true);
 594         if (value.m_type &amp; SpecBoolean) {
 595             value.merge(SpecBoolInt32);
 596             value.filter(~SpecBoolean);
 597         }
 598         break;
 599     }
 600 
 601     case DoubleAsInt32: {
 602         JSValue child = forNode(node-&gt;child1()).value();
 603         if (child &amp;&amp; child.isNumber()) {
 604             double asDouble = child.asNumber();
 605             int32_t asInt = JSC::toInt32(asDouble);
 606             if (bitwise_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(asInt)) == bitwise_cast&lt;int64_t&gt;(asDouble)) {
 607                 setConstant(node, JSValue(asInt));
 608                 break;
 609             }
 610         }
 611         setNonCellTypeForNode(node, SpecInt32Only);
 612         break;
 613     }
 614 
 615     case ValueToInt32: {
 616         JSValue child = forNode(node-&gt;child1()).value();
 617         if (child) {
 618             if (child.isNumber()) {
 619                 if (child.isInt32())
 620                     setConstant(node, child);
 621                 else
 622                     setConstant(node, JSValue(JSC::toInt32(child.asDouble())));
 623                 break;
 624             }
 625             if (child.isBoolean()) {
 626                 setConstant(node, jsNumber(child.asBoolean()));
 627                 break;
 628             }
 629             if (child.isUndefinedOrNull()) {
 630                 setConstant(node, jsNumber(0));
 631                 break;
 632             }
 633         }
 634 
 635         if (isBooleanSpeculation(forNode(node-&gt;child1()).m_type)) {
 636             setNonCellTypeForNode(node, SpecBoolInt32);
 637             break;
 638         }
 639 
 640         setNonCellTypeForNode(node, SpecInt32Only);
 641         break;
 642     }
 643 
 644     case DoubleRep: {
 645         JSValue child = forNode(node-&gt;child1()).value();
 646         if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
 647             setConstant(node, jsDoubleNumber(*number));
 648             break;
 649         }
 650 
 651         SpeculatedType type = forNode(node-&gt;child1()).m_type;
 652         switch (node-&gt;child1().useKind()) {
 653         case NotCellUse: {
 654             if (type &amp; SpecOther) {
 655                 type &amp;= ~SpecOther;
 656                 type |= SpecDoublePureNaN | SpecBoolInt32; // Null becomes zero, undefined becomes NaN.
 657             }
 658             if (type &amp; SpecBoolean) {
 659                 type &amp;= ~SpecBoolean;
 660                 type |= SpecBoolInt32; // True becomes 1, false becomes 0.
 661             }
 662             type &amp;= SpecBytecodeNumber;
 663             break;
 664         }
 665 
 666         case Int52RepUse:
 667         case NumberUse:
 668         case RealNumberUse:
 669             break;
 670 
 671         default:
 672             RELEASE_ASSERT_NOT_REACHED();
 673         }
 674         setNonCellTypeForNode(node, type);
 675         forNode(node).fixTypeForRepresentation(m_graph, node);
 676         break;
 677     }
 678 
 679     case Int52Rep: {
 680         JSValue child = forNode(node-&gt;child1()).value();
 681         if (child &amp;&amp; child.isAnyInt()) {
 682             setConstant(node, child);
 683             break;
 684         }
 685 
<a name="15" id="anc15"></a><span class="line-modified"> 686         setTypeForNode(node, forNode(node-&gt;child1()).m_type);</span>
<span class="line-added"> 687         forNode(node).fixTypeForRepresentation(m_graph, node);</span>
 688         break;
 689     }
 690 
 691     case ValueRep: {
 692         JSValue value = forNode(node-&gt;child1()).value();
 693         if (value) {
 694             setConstant(node, value);
 695             break;
 696         }
 697 
 698         setTypeForNode(node, forNode(node-&gt;child1()).m_type &amp; ~SpecDoubleImpureNaN);
 699         forNode(node).fixTypeForRepresentation(m_graph, node);
 700         break;
 701     }
 702 
 703     case ValueSub:
 704     case ValueAdd: {
 705         DFG_ASSERT(m_graph, node, node-&gt;binaryUseKind() == UntypedUse || node-&gt;binaryUseKind() == BigIntUse);
 706         if (node-&gt;binaryUseKind() == BigIntUse)
 707             setTypeForNode(node, SpecBigInt);
 708         else {
 709             clobberWorld();
 710             setTypeForNode(node, SpecString | SpecBytecodeNumber | SpecBigInt);
 711         }
 712         break;
 713     }
 714 
 715     case StrCat: {
 716         setTypeForNode(node, SpecString);
 717         break;
 718     }
 719 
 720     case ArithAdd: {
 721         JSValue left = forNode(node-&gt;child1()).value();
 722         JSValue right = forNode(node-&gt;child2()).value();
 723         switch (node-&gt;binaryUseKind()) {
 724         case Int32Use:
 725             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 726                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 727                     setConstant(node, jsNumber(left.asInt32() + right.asInt32()));
 728                     break;
 729                 }
 730                 JSValue result = jsNumber(left.asNumber() + right.asNumber());
 731                 if (result.isInt32()) {
 732                     setConstant(node, result);
 733                     break;
 734                 }
 735             }
 736             setNonCellTypeForNode(node, SpecInt32Only);
 737             break;
 738         case Int52RepUse:
 739             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 740                 JSValue result = jsNumber(left.asAnyInt() + right.asAnyInt());
 741                 if (result.isAnyInt()) {
 742                     setConstant(node, result);
 743                     break;
 744                 }
 745             }
<a name="16" id="anc16"></a><span class="line-modified"> 746             setNonCellTypeForNode(node, SpecInt52Any);</span>
 747             break;
 748         case DoubleRepUse:
 749             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 750                 setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
 751                 break;
 752             }
 753             setNonCellTypeForNode(node,
 754                 typeOfDoubleSum(
 755                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 756             break;
 757         default:
 758             RELEASE_ASSERT_NOT_REACHED();
 759             break;
 760         }
 761         break;
 762     }
 763 
 764     case AtomicsIsLockFree: {
 765         if (node-&gt;child1().useKind() != Int32Use)
 766             clobberWorld();
 767         setNonCellTypeForNode(node, SpecBoolInt32);
 768         break;
 769     }
 770 
 771     case ArithClz32: {
 772         JSValue operand = forNode(node-&gt;child1()).value();
 773         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
 774             switch (node-&gt;child1().useKind()) {
 775             case Int32Use:
 776             case KnownInt32Use:
 777                 break;
 778             default:
 779                 didFoldClobberWorld();
 780                 break;
 781             }
 782             uint32_t value = toUInt32(*number);
<a name="17" id="anc17"></a><span class="line-modified"> 783             setConstant(node, jsNumber(clz(value)));</span>
 784             break;
 785         }
 786         switch (node-&gt;child1().useKind()) {
 787         case Int32Use:
 788         case KnownInt32Use:
 789             break;
 790         default:
 791             clobberWorld();
 792             break;
 793         }
 794         setNonCellTypeForNode(node, SpecInt32Only);
 795         break;
 796     }
 797 
 798     case MakeRope: {
<a name="18" id="anc18"></a>
 799         unsigned numberOfRemovedChildren = 0;
<a name="19" id="anc19"></a>
 800         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 801             Edge&amp; edge = node-&gt;children.child(i);
 802             if (!edge)
 803                 break;
<a name="20" id="anc20"></a>

 804             JSValue childConstant = m_state.forNode(edge).value();
<a name="21" id="anc21"></a><span class="line-modified"> 805             if (!childConstant)</span>

 806                 continue;
<a name="22" id="anc22"></a><span class="line-modified"> 807             if (!childConstant.isString())</span>


 808                 continue;
<a name="23" id="anc23"></a><span class="line-modified"> 809             if (asString(childConstant)-&gt;length())</span>


 810                 continue;
<a name="24" id="anc24"></a>

 811             ++numberOfRemovedChildren;
 812         }
 813 
<a name="25" id="anc25"></a><span class="line-modified"> 814         if (numberOfRemovedChildren)</span>
 815             m_state.setFoundConstants(true);
<a name="26" id="anc26"></a>










 816         setForNode(node, m_vm.stringStructure.get());
 817         break;
 818     }
 819 
 820     case ArithSub: {
 821         JSValue left = forNode(node-&gt;child1()).value();
 822         JSValue right = forNode(node-&gt;child2()).value();
 823         switch (node-&gt;binaryUseKind()) {
 824         case Int32Use:
 825             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 826                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 827                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 828                     break;
 829                 }
 830                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 831                 if (result.isInt32()) {
 832                     setConstant(node, result);
 833                     break;
 834                 }
 835             }
 836             setNonCellTypeForNode(node, SpecInt32Only);
 837             break;
 838         case Int52RepUse:
 839             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 840                 JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
<a name="27" id="anc27"></a><span class="line-modified"> 841                 if (result.isAnyInt()) {</span>
 842                     setConstant(node, result);
 843                     break;
 844                 }
 845             }
<a name="28" id="anc28"></a><span class="line-modified"> 846             setNonCellTypeForNode(node, SpecInt52Any);</span>
 847             break;
 848         case DoubleRepUse:
 849             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 850                 setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
 851                 break;
 852             }
 853             setNonCellTypeForNode(node,
 854                 typeOfDoubleDifference(
 855                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 856             break;
 857         case UntypedUse:
 858             clobberWorld();
 859             setNonCellTypeForNode(node, SpecBytecodeNumber);
 860             break;
 861         default:
 862             RELEASE_ASSERT_NOT_REACHED();
 863             break;
 864         }
 865         break;
 866     }
 867 
 868     case ValueNegate: {
 869         clobberWorld();
 870         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 871         break;
 872     }
 873 
 874     case ArithNegate: {
 875         JSValue child = forNode(node-&gt;child1()).value();
 876         switch (node-&gt;child1().useKind()) {
 877         case Int32Use:
 878             if (child &amp;&amp; child.isInt32()) {
 879                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 880                     setConstant(node, jsNumber(-child.asInt32()));
 881                     break;
 882                 }
 883                 double doubleResult;
 884                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 885                     doubleResult = -child.asNumber();
 886                 else
 887                     doubleResult = 0 - child.asNumber();
 888                 JSValue valueResult = jsNumber(doubleResult);
 889                 if (valueResult.isInt32()) {
 890                     setConstant(node, valueResult);
 891                     break;
 892                 }
 893             }
 894             setNonCellTypeForNode(node, SpecInt32Only);
 895             break;
 896         case Int52RepUse:
 897             if (child &amp;&amp; child.isAnyInt()) {
 898                 double doubleResult;
 899                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 900                     doubleResult = -child.asNumber();
 901                 else
 902                     doubleResult = 0 - child.asNumber();
 903                 JSValue valueResult = jsNumber(doubleResult);
 904                 if (valueResult.isAnyInt()) {
 905                     setConstant(node, valueResult);
 906                     break;
 907                 }
 908             }
<a name="29" id="anc29"></a><span class="line-modified"> 909             setNonCellTypeForNode(node, SpecInt52Any);</span>
 910             break;
 911         case DoubleRepUse:
 912             if (child &amp;&amp; child.isNumber()) {
 913                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 914                 break;
 915             }
 916             setNonCellTypeForNode(node,
 917                 typeOfDoubleNegation(
 918                     forNode(node-&gt;child1()).m_type));
 919             break;
 920         default:
 921             RELEASE_ASSERT_NOT_REACHED();
 922             break;
 923         }
 924         break;
 925     }
 926 
<a name="30" id="anc30"></a><span class="line-added"> 927     case ValuePow: {</span>
<span class="line-added"> 928         JSValue childX = forNode(node-&gt;child1()).value();</span>
<span class="line-added"> 929         JSValue childY = forNode(node-&gt;child2()).value();</span>
<span class="line-added"> 930         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {</span>
<span class="line-added"> 931             // We need to call `didFoldClobberWorld` here because this path is only possible</span>
<span class="line-added"> 932             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be</span>
<span class="line-added"> 933             // cleared by `AbstractInterpreter::executeEffects`.</span>
<span class="line-added"> 934             didFoldClobberWorld();</span>
<span class="line-added"> 935             setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
<span class="line-added"> 936             break;</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         if (node-&gt;binaryUseKind() == BigIntUse)</span>
<span class="line-added"> 940             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added"> 941         else {</span>
<span class="line-added"> 942             clobberWorld();</span>
<span class="line-added"> 943             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added"> 944         }</span>
<span class="line-added"> 945         break;</span>
<span class="line-added"> 946     }</span>
<span class="line-added"> 947 </span>
 948     case ValueMul: {
 949         if (node-&gt;binaryUseKind() == BigIntUse)
 950             setTypeForNode(node, SpecBigInt);
 951         else {
 952             clobberWorld();
 953             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 954         }
 955         break;
 956     }
 957 
 958     case ArithMul: {
 959         JSValue left = forNode(node-&gt;child1()).value();
 960         JSValue right = forNode(node-&gt;child2()).value();
 961         switch (node-&gt;binaryUseKind()) {
 962         case Int32Use:
 963             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 964                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 965                     setConstant(node, jsNumber(left.asInt32() * right.asInt32()));
 966                     break;
 967                 }
 968                 double doubleResult = left.asNumber() * right.asNumber();
 969                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 970                     doubleResult += 0; // Sanitizes zero.
 971                 JSValue valueResult = jsNumber(doubleResult);
 972                 if (valueResult.isInt32()) {
 973                     setConstant(node, valueResult);
 974                     break;
 975                 }
 976             }
 977             setNonCellTypeForNode(node, SpecInt32Only);
 978             break;
 979         case Int52RepUse:
 980             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 981                 double doubleResult = left.asNumber() * right.asNumber();
 982                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 983                     doubleResult += 0;
 984                 JSValue valueResult = jsNumber(doubleResult);
 985                 if (valueResult.isAnyInt()) {
 986                     setConstant(node, valueResult);
 987                     break;
 988                 }
 989             }
<a name="31" id="anc31"></a><span class="line-modified"> 990             setNonCellTypeForNode(node, SpecInt52Any);</span>
 991             break;
 992         case DoubleRepUse:
 993             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 994                 setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
 995                 break;
 996             }
 997             setNonCellTypeForNode(node,
 998                 typeOfDoubleProduct(
 999                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1000             break;
1001         default:
1002             RELEASE_ASSERT_NOT_REACHED();
1003             break;
1004         }
1005         break;
1006     }
1007 
<a name="32" id="anc32"></a><span class="line-added">1008     case ValueMod:</span>
1009     case ValueDiv: {
<a name="33" id="anc33"></a><span class="line-added">1010         if (handleConstantDivOp(node))</span>
<span class="line-added">1011             break;</span>
<span class="line-added">1012 </span>
1013         if (node-&gt;binaryUseKind() == BigIntUse)
1014             setTypeForNode(node, SpecBigInt);
1015         else {
1016             clobberWorld();
1017             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
1018         }
1019         break;
1020     }
1021 
<a name="34" id="anc34"></a><span class="line-added">1022     case ArithMod:</span>
1023     case ArithDiv: {
<a name="35" id="anc35"></a><span class="line-modified">1024         if (handleConstantDivOp(node))</span>




























1025             break;
<a name="36" id="anc36"></a>


1026 
<a name="37" id="anc37"></a>


1027         switch (node-&gt;binaryUseKind()) {
1028         case Int32Use:
<a name="38" id="anc38"></a>











1029             setNonCellTypeForNode(node, SpecInt32Only);
1030             break;
1031         case DoubleRepUse:
<a name="39" id="anc39"></a><span class="line-modified">1032             if (node-&gt;op() == ArithDiv) {</span>
<span class="line-modified">1033                 setNonCellTypeForNode(node,</span>
<span class="line-modified">1034                     typeOfDoubleQuotient(</span>
<span class="line-added">1035                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
<span class="line-added">1036             } else {</span>
<span class="line-added">1037                 setNonCellTypeForNode(node,</span>
<span class="line-added">1038                     typeOfDoubleBinaryOp(</span>
<span class="line-added">1039                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));</span>
1040             }
<a name="40" id="anc40"></a><span class="line-modified">1041 </span>


1042             break;
1043         default:
1044             RELEASE_ASSERT_NOT_REACHED();
1045             break;
1046         }
1047         break;
1048     }
1049 
1050     case ArithMin: {
1051         JSValue left = forNode(node-&gt;child1()).value();
1052         JSValue right = forNode(node-&gt;child2()).value();
1053         switch (node-&gt;binaryUseKind()) {
1054         case Int32Use:
1055             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1056                 setConstant(node, jsNumber(std::min(left.asInt32(), right.asInt32())));
1057                 break;
1058             }
1059             setNonCellTypeForNode(node, SpecInt32Only);
1060             break;
1061         case DoubleRepUse:
1062             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1063                 double a = left.asNumber();
1064                 double b = right.asNumber();
1065                 setConstant(node, jsDoubleNumber(a &lt; b ? a : (b &lt;= a ? b : a + b)));
1066                 break;
1067             }
1068             setNonCellTypeForNode(node,
1069                 typeOfDoubleMinMax(
1070                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1071             break;
1072         default:
1073             RELEASE_ASSERT_NOT_REACHED();
1074             break;
1075         }
1076         break;
1077     }
1078 
1079     case ArithMax: {
1080         JSValue left = forNode(node-&gt;child1()).value();
1081         JSValue right = forNode(node-&gt;child2()).value();
1082         switch (node-&gt;binaryUseKind()) {
1083         case Int32Use:
1084             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1085                 setConstant(node, jsNumber(std::max(left.asInt32(), right.asInt32())));
1086                 break;
1087             }
1088             setNonCellTypeForNode(node, SpecInt32Only);
1089             break;
1090         case DoubleRepUse:
1091             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1092                 double a = left.asNumber();
1093                 double b = right.asNumber();
1094                 setConstant(node, jsDoubleNumber(a &gt; b ? a : (b &gt;= a ? b : a + b)));
1095                 break;
1096             }
1097             setNonCellTypeForNode(node,
1098                 typeOfDoubleMinMax(
1099                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1100             break;
1101         default:
1102             RELEASE_ASSERT_NOT_REACHED();
1103             break;
1104         }
1105         break;
1106     }
1107 
1108     case ArithAbs: {
1109         JSValue child = forNode(node-&gt;child1()).value();
1110         switch (node-&gt;child1().useKind()) {
1111         case Int32Use:
1112             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1113                 JSValue result = jsNumber(fabs(*number));
1114                 if (result.isInt32()) {
1115                     setConstant(node, result);
1116                     break;
1117                 }
1118             }
1119             setNonCellTypeForNode(node, SpecInt32Only);
1120             break;
1121         case DoubleRepUse:
1122             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1123                 setConstant(node, jsDoubleNumber(fabs(*number)));
1124                 break;
1125             }
1126             setNonCellTypeForNode(node, typeOfDoubleAbs(forNode(node-&gt;child1()).m_type));
1127             break;
1128         default:
1129             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1130             clobberWorld();
1131             setNonCellTypeForNode(node, SpecBytecodeNumber);
1132             break;
1133         }
1134         break;
1135     }
1136 
1137     case ArithPow: {
1138         JSValue childY = forNode(node-&gt;child2()).value();
1139         if (childY &amp;&amp; childY.isNumber()) {
1140             if (!childY.asNumber()) {
1141                 setConstant(node, jsDoubleNumber(1));
1142                 break;
1143             }
1144 
1145             JSValue childX = forNode(node-&gt;child1()).value();
1146             if (childX &amp;&amp; childX.isNumber()) {
1147                 setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
1148                 break;
1149             }
1150         }
1151         setNonCellTypeForNode(node, typeOfDoublePow(forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1152         break;
1153     }
1154 
1155     case ArithRandom: {
1156         setNonCellTypeForNode(node, SpecDoubleReal);
1157         break;
1158     }
1159 
1160     case ArithRound:
1161     case ArithFloor:
1162     case ArithCeil:
1163     case ArithTrunc: {
1164         JSValue operand = forNode(node-&gt;child1()).value();
1165         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
1166             if (node-&gt;child1().useKind() != DoubleRepUse)
1167                 didFoldClobberWorld();
1168 
1169             double roundedValue = 0;
1170             if (node-&gt;op() == ArithRound)
1171                 roundedValue = jsRound(*number);
1172             else if (node-&gt;op() == ArithFloor)
1173                 roundedValue = floor(*number);
1174             else if (node-&gt;op() == ArithCeil)
1175                 roundedValue = ceil(*number);
1176             else {
1177                 ASSERT(node-&gt;op() == ArithTrunc);
1178                 roundedValue = trunc(*number);
1179             }
1180 
1181             if (node-&gt;child1().useKind() == UntypedUse) {
1182                 setConstant(node, jsNumber(roundedValue));
1183                 break;
1184             }
1185             if (producesInteger(node-&gt;arithRoundingMode())) {
1186                 int32_t roundedValueAsInt32 = static_cast&lt;int32_t&gt;(roundedValue);
1187                 if (roundedValueAsInt32 == roundedValue) {
1188                     if (shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
1189                         if (roundedValueAsInt32 || !std::signbit(roundedValue)) {
1190                             setConstant(node, jsNumber(roundedValueAsInt32));
1191                             break;
1192                         }
1193                     } else {
1194                         setConstant(node, jsNumber(roundedValueAsInt32));
1195                         break;
1196                     }
1197                 }
1198             } else {
1199                 setConstant(node, jsDoubleNumber(roundedValue));
1200                 break;
1201             }
1202         }
1203         if (node-&gt;child1().useKind() == DoubleRepUse) {
1204             if (producesInteger(node-&gt;arithRoundingMode()))
1205                 setNonCellTypeForNode(node, SpecInt32Only);
1206             else if (node-&gt;child1().useKind() == DoubleRepUse)
1207                 setNonCellTypeForNode(node, typeOfDoubleRounding(forNode(node-&gt;child1()).m_type));
1208         } else {
1209             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1210             clobberWorld();
1211             setNonCellTypeForNode(node, SpecBytecodeNumber);
1212         }
1213         break;
1214     }
1215 
1216     case ArithSqrt:
1217         executeDoubleUnaryOpEffects(node, sqrt);
1218         break;
1219 
1220     case ArithFRound:
1221         executeDoubleUnaryOpEffects(node, [](double value) -&gt; double { return static_cast&lt;float&gt;(value); });
1222         break;
1223 
1224     case ArithUnary:
1225         executeDoubleUnaryOpEffects(node, arithUnaryFunction(node-&gt;arithUnaryType()));
1226         break;
1227 
1228     case LogicalNot: {
1229         switch (booleanResult(node, forNode(node-&gt;child1()))) {
1230         case DefinitelyTrue:
1231             setConstant(node, jsBoolean(false));
1232             break;
1233         case DefinitelyFalse:
1234             setConstant(node, jsBoolean(true));
1235             break;
1236         default:
1237             setNonCellTypeForNode(node, SpecBoolean);
1238             break;
1239         }
1240         break;
1241     }
1242 
1243     case MapHash: {
1244         if (JSValue key = forNode(node-&gt;child1()).value()) {
1245             if (Optional&lt;uint32_t&gt; hash = concurrentJSMapHash(key)) {
1246                 // Although C++ code uses uint32_t for the hash, the closest type in DFG IR is Int32
1247                 // and that&#39;s what MapHash returns. So, we have to cast to int32_t to avoid large
1248                 // unsigned values becoming doubles. This casting between signed and unsigned
1249                 // happens in the assembly code we emit when we don&#39;t constant fold this node.
1250                 setConstant(node, jsNumber(static_cast&lt;int32_t&gt;(*hash)));
1251                 break;
1252             }
1253         }
1254         setNonCellTypeForNode(node, SpecInt32Only);
1255         break;
1256     }
1257 
1258     case NormalizeMapKey: {
1259         if (JSValue key = forNode(node-&gt;child1()).value()) {
1260             setConstant(node, *m_graph.freeze(normalizeMapKey(key)));
1261             break;
1262         }
1263 
1264         SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
1265         if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
1266             m_state.setFoundConstants(true);
1267             forNode(node) = forNode(node-&gt;child1());
1268             break;
1269         }
1270 
1271         makeHeapTopForNode(node);
1272         break;
1273     }
1274 
1275     case StringValueOf: {
1276         clobberWorld();
1277         setTypeForNode(node, SpecString);
1278         break;
1279     }
1280 
1281     case StringSlice: {
1282         setTypeForNode(node, SpecString);
1283         break;
1284     }
1285 
1286     case ToLowerCase: {
1287         setTypeForNode(node, SpecString);
1288         break;
1289     }
1290 
1291     case LoadKeyFromMapBucket:
1292     case LoadValueFromMapBucket:
1293     case ExtractValueFromWeakMapGet:
1294         makeHeapTopForNode(node);
1295         break;
1296 
1297     case GetMapBucket:
1298     case GetMapBucketHead:
1299         if (node-&gt;child1().useKind() == MapObjectUse)
1300             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1301         else {
1302             ASSERT(node-&gt;child1().useKind() == SetObjectUse);
1303             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1304         }
1305         break;
1306 
1307     case GetMapBucketNext:
1308         if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
1309             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1310         else {
1311             ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
1312             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1313         }
1314         break;
1315 
1316     case SetAdd:
1317         setForNode(node, m_vm.hashMapBucketSetStructure.get());
1318         break;
1319 
1320     case MapSet:
1321         setForNode(node, m_vm.hashMapBucketMapStructure.get());
1322         break;
1323 
1324     case WeakSetAdd:
1325     case WeakMapSet:
1326         break;
1327 
1328     case WeakMapGet:
1329         makeBytecodeTopForNode(node);
1330         break;
1331 
1332     case IsEmpty:
1333     case IsUndefined:
1334     case IsUndefinedOrNull:
1335     case IsBoolean:
1336     case IsNumber:
1337     case NumberIsInteger:
1338     case IsObject:
1339     case IsObjectOrNull:
1340     case IsFunction:
1341     case IsCellWithType:
1342     case IsTypedArrayView: {
1343         AbstractValue child = forNode(node-&gt;child1());
1344         if (child.value()) {
1345             bool constantWasSet = true;
1346             switch (node-&gt;op()) {
1347             case IsCellWithType:
1348                 setConstant(node, jsBoolean(child.value().isCell() &amp;&amp; child.value().asCell()-&gt;type() == node-&gt;queriedType()));
1349                 break;
1350             case IsUndefined:
1351                 setConstant(node, jsBoolean(
1352                     child.value().isCell()
1353                     ? child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
1354                     : child.value().isUndefined()));
1355                 break;
1356             case IsUndefinedOrNull:
1357                 setConstant(node, jsBoolean(child.value().isUndefinedOrNull()));
1358                 break;
1359             case IsBoolean:
1360                 setConstant(node, jsBoolean(child.value().isBoolean()));
1361                 break;
1362             case IsNumber:
1363                 setConstant(node, jsBoolean(child.value().isNumber()));
1364                 break;
1365             case NumberIsInteger:
1366                 setConstant(node, jsBoolean(NumberConstructor::isIntegerImpl(child.value())));
1367                 break;
1368             case IsObject:
1369                 setConstant(node, jsBoolean(child.value().isObject()));
1370                 break;
1371             case IsObjectOrNull:
1372                 if (child.value().isObject()) {
1373                     JSObject* object = asObject(child.value());
1374                     if (object-&gt;type() == JSFunctionType)
1375                         setConstant(node, jsBoolean(false));
1376                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1377                         setConstant(node, jsBoolean(!child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))));
1378                     else {
1379                         // FIXME: This could just call getCallData.
1380                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1381                         constantWasSet = false;
1382                     }
1383                 } else
1384                     setConstant(node, jsBoolean(child.value().isNull()));
1385                 break;
1386             case IsFunction:
1387                 if (child.value().isObject()) {
1388                     JSObject* object = asObject(child.value());
1389                     if (object-&gt;type() == JSFunctionType)
1390                         setConstant(node, jsBoolean(true));
1391                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1392                         setConstant(node, jsBoolean(false));
1393                     else {
1394                         // FIXME: This could just call getCallData.
1395                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1396                         constantWasSet = false;
1397                     }
1398                 } else
1399                     setConstant(node, jsBoolean(false));
1400                 break;
1401             case IsEmpty:
1402                 setConstant(node, jsBoolean(child.value().isEmpty()));
1403                 break;
1404             case IsTypedArrayView:
1405                 setConstant(node, jsBoolean(child.value().isObject() &amp;&amp; isTypedView(child.value().getObject()-&gt;classInfo(m_vm)-&gt;typedArrayStorageType)));
1406                 break;
1407             default:
1408                 constantWasSet = false;
1409                 break;
1410             }
1411             if (constantWasSet)
1412                 break;
1413         }
1414 
1415         // FIXME: This code should really use AbstractValue::isType() and
1416         // AbstractValue::couldBeType().
1417         // https://bugs.webkit.org/show_bug.cgi?id=146870
1418 
1419         bool constantWasSet = false;
1420         switch (node-&gt;op()) {
1421         case IsEmpty: {
1422             if (child.m_type &amp;&amp; !(child.m_type &amp; SpecEmpty)) {
1423                 setConstant(node, jsBoolean(false));
1424                 constantWasSet = true;
1425                 break;
1426             }
1427 
1428             if (child.m_type &amp;&amp; !(child.m_type &amp; ~SpecEmpty)) {
1429                 setConstant(node, jsBoolean(true));
1430                 constantWasSet = true;
1431                 break;
1432             }
1433 
1434             break;
1435         }
1436         case IsUndefined:
1437             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1438             // https://bugs.webkit.org/show_bug.cgi?id=144456
1439 
1440             if (!(child.m_type &amp; (SpecOther | SpecObjectOther))) {
1441                 setConstant(node, jsBoolean(false));
1442                 constantWasSet = true;
1443                 break;
1444             }
1445 
1446             break;
1447         case IsUndefinedOrNull:
1448             if (!(child.m_type &amp; ~SpecOther)) {
1449                 setConstant(node, jsBoolean(true));
1450                 constantWasSet = true;
1451                 break;
1452             }
1453 
1454             if (!(child.m_type &amp; SpecOther)) {
1455                 setConstant(node, jsBoolean(false));
1456                 constantWasSet = true;
1457                 break;
1458             }
1459             break;
1460         case IsBoolean:
1461             if (!(child.m_type &amp; ~SpecBoolean)) {
1462                 setConstant(node, jsBoolean(true));
1463                 constantWasSet = true;
1464                 break;
1465             }
1466 
1467             if (!(child.m_type &amp; SpecBoolean)) {
1468                 setConstant(node, jsBoolean(false));
1469                 constantWasSet = true;
1470                 break;
1471             }
1472 
1473             break;
1474         case IsNumber:
1475             if (!(child.m_type &amp; ~SpecFullNumber)) {
1476                 setConstant(node, jsBoolean(true));
1477                 constantWasSet = true;
1478                 break;
1479             }
1480 
1481             if (!(child.m_type &amp; SpecFullNumber)) {
1482                 setConstant(node, jsBoolean(false));
1483                 constantWasSet = true;
1484                 break;
1485             }
1486 
1487             break;
1488 
1489         case NumberIsInteger:
1490             if (!(child.m_type &amp; ~SpecInt32Only)) {
1491                 setConstant(node, jsBoolean(true));
1492                 constantWasSet = true;
1493                 break;
1494             }
1495 
1496             if (!(child.m_type &amp; SpecFullNumber)) {
1497                 setConstant(node, jsBoolean(false));
1498                 constantWasSet = true;
1499                 break;
1500             }
1501 
1502             break;
1503 
1504         case IsObject:
1505             if (!(child.m_type &amp; ~SpecObject)) {
1506                 setConstant(node, jsBoolean(true));
1507                 constantWasSet = true;
1508                 break;
1509             }
1510 
1511             if (!(child.m_type &amp; SpecObject)) {
1512                 setConstant(node, jsBoolean(false));
1513                 constantWasSet = true;
1514                 break;
1515             }
1516 
1517             break;
1518         case IsObjectOrNull:
1519             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1520             // https://bugs.webkit.org/show_bug.cgi?id=144456
1521 
1522             // These expressions are complicated to parse. A helpful way to parse this is that
1523             // &quot;!(T &amp; ~S)&quot; means &quot;T is a subset of S&quot;. Conversely, &quot;!(T &amp; S)&quot; means &quot;T is a
1524             // disjoint set from S&quot;. Things like &quot;T - S&quot; means that, provided that S is a
1525             // subset of T, it&#39;s the &quot;set of all things in T but not in S&quot;. Things like &quot;T | S&quot;
1526             // mean the &quot;union of T and S&quot;.
1527 
1528             // Is the child&#39;s type an object that isn&#39;t an other-object (i.e. object that could
1529             // have masquaredes-as-undefined traps) and isn&#39;t a function?  Then: we should fold
1530             // this to true.
1531             if (!(child.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1532                 setConstant(node, jsBoolean(true));
1533                 constantWasSet = true;
1534                 break;
1535             }
1536 
1537             // Is the child&#39;s type definitely not either of: an object that isn&#39;t a function,
1538             // or either undefined or null?  Then: we should fold this to false.  This means
1539             // for example that if it&#39;s any non-function object, including those that have
1540             // masquerades-as-undefined traps, then we don&#39;t fold. It also means we won&#39;t fold
1541             // if it&#39;s undefined-or-null, since the type bits don&#39;t distinguish between
1542             // undefined (which should fold to false) and null (which should fold to true).
1543             if (!(child.m_type &amp; ((SpecObject - SpecFunction) | SpecOther))) {
1544                 setConstant(node, jsBoolean(false));
1545                 constantWasSet = true;
1546                 break;
1547             }
1548 
1549             break;
1550         case IsFunction:
1551             if (!(child.m_type &amp; ~SpecFunction)) {
1552                 setConstant(node, jsBoolean(true));
1553                 constantWasSet = true;
1554                 break;
1555             }
1556 
1557             if (!(child.m_type &amp; (SpecFunction | SpecObjectOther | SpecProxyObject))) {
1558                 setConstant(node, jsBoolean(false));
1559                 constantWasSet = true;
1560                 break;
1561             }
1562             break;
1563 
1564         case IsCellWithType:
1565             if (!(child.m_type &amp; ~node-&gt;speculatedTypeForQuery())) {
1566                 setConstant(node, jsBoolean(true));
1567                 constantWasSet = true;
1568                 break;
1569             }
1570             if (!(child.m_type &amp; node-&gt;speculatedTypeForQuery())) {
1571                 setConstant(node, jsBoolean(false));
1572                 constantWasSet = true;
1573                 break;
1574             }
1575             break;
1576 
1577         case IsTypedArrayView:
1578             if (!(child.m_type &amp; ~SpecTypedArrayView)) {
1579                 setConstant(node, jsBoolean(true));
1580                 constantWasSet = true;
1581                 break;
1582             }
1583             if (!(child.m_type &amp; SpecTypedArrayView)) {
1584                 setConstant(node, jsBoolean(false));
1585                 constantWasSet = true;
1586                 break;
1587             }
1588             break;
1589 
1590         default:
1591             break;
1592         }
1593         if (constantWasSet)
1594             break;
1595 
1596         setNonCellTypeForNode(node, SpecBoolean);
1597         break;
1598     }
1599 
1600     case TypeOf: {
1601         JSValue child = forNode(node-&gt;child1()).value();
1602         AbstractValue&amp; abstractChild = forNode(node-&gt;child1());
1603         if (child) {
1604             JSValue typeString = jsTypeStringForValue(m_vm, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic), child);
1605             setConstant(node, *m_graph.freeze(typeString));
1606             break;
1607         }
1608 
1609         if (isFullNumberSpeculation(abstractChild.m_type)) {
1610             setConstant(node, *m_graph.freeze(m_vm.smallStrings.numberString()));
1611             break;
1612         }
1613 
1614         if (isStringSpeculation(abstractChild.m_type)) {
1615             setConstant(node, *m_graph.freeze(m_vm.smallStrings.stringString()));
1616             break;
1617         }
1618 
1619         // FIXME: We could use the masquerades-as-undefined watchpoint here.
1620         // https://bugs.webkit.org/show_bug.cgi?id=144456
1621         if (!(abstractChild.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1622             setConstant(node, *m_graph.freeze(m_vm.smallStrings.objectString()));
1623             break;
1624         }
1625 
1626         if (isFunctionSpeculation(abstractChild.m_type)) {
1627             setConstant(node, *m_graph.freeze(m_vm.smallStrings.functionString()));
1628             break;
1629         }
1630 
1631         if (isBooleanSpeculation(abstractChild.m_type)) {
1632             setConstant(node, *m_graph.freeze(m_vm.smallStrings.booleanString()));
1633             break;
1634         }
1635 
1636         if (isSymbolSpeculation(abstractChild.m_type)) {
1637             setConstant(node, *m_graph.freeze(m_vm.smallStrings.symbolString()));
1638             break;
1639         }
1640 
1641         if (isBigIntSpeculation(abstractChild.m_type)) {
1642             setConstant(node, *m_graph.freeze(m_vm.smallStrings.bigintString()));
1643             break;
1644         }
1645 
1646         setTypeForNode(node, SpecStringIdent);
1647         break;
1648     }
1649 
1650     case CompareBelow:
1651     case CompareBelowEq: {
1652         JSValue leftConst = forNode(node-&gt;child1()).value();
1653         JSValue rightConst = forNode(node-&gt;child2()).value();
1654         if (leftConst &amp;&amp; rightConst) {
1655             if (leftConst.isInt32() &amp;&amp; rightConst.isInt32()) {
1656                 uint32_t a = static_cast&lt;uint32_t&gt;(leftConst.asInt32());
1657                 uint32_t b = static_cast&lt;uint32_t&gt;(rightConst.asInt32());
1658                 switch (node-&gt;op()) {
1659                 case CompareBelow:
1660                     setConstant(node, jsBoolean(a &lt; b));
1661                     break;
1662                 case CompareBelowEq:
1663                     setConstant(node, jsBoolean(a &lt;= b));
1664                     break;
1665                 default:
1666                     RELEASE_ASSERT_NOT_REACHED();
1667                     break;
1668                 }
1669                 break;
1670             }
1671         }
1672 
1673         if (node-&gt;child1() == node-&gt;child2()) {
1674             switch (node-&gt;op()) {
1675             case CompareBelow:
1676                 setConstant(node, jsBoolean(false));
1677                 break;
1678             case CompareBelowEq:
1679                 setConstant(node, jsBoolean(true));
1680                 break;
1681             default:
1682                 DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1683                 break;
1684             }
1685             break;
1686         }
1687         setNonCellTypeForNode(node, SpecBoolean);
1688         break;
1689     }
1690 
1691     case CompareLess:
1692     case CompareLessEq:
1693     case CompareGreater:
1694     case CompareGreaterEq:
1695     case CompareEq: {
1696         bool isClobbering = node-&gt;isBinaryUseKind(UntypedUse);
1697 
1698         if (isClobbering)
1699             didFoldClobberWorld();
1700 
1701         JSValue leftConst = forNode(node-&gt;child1()).value();
1702         JSValue rightConst = forNode(node-&gt;child2()).value();
1703         if (leftConst &amp;&amp; rightConst) {
1704             if (leftConst.isNumber() &amp;&amp; rightConst.isNumber()) {
1705                 double a = leftConst.asNumber();
1706                 double b = rightConst.asNumber();
1707                 switch (node-&gt;op()) {
1708                 case CompareLess:
1709                     setConstant(node, jsBoolean(a &lt; b));
1710                     break;
1711                 case CompareLessEq:
1712                     setConstant(node, jsBoolean(a &lt;= b));
1713                     break;
1714                 case CompareGreater:
1715                     setConstant(node, jsBoolean(a &gt; b));
1716                     break;
1717                 case CompareGreaterEq:
1718                     setConstant(node, jsBoolean(a &gt;= b));
1719                     break;
1720                 case CompareEq:
1721                     setConstant(node, jsBoolean(a == b));
1722                     break;
1723                 default:
1724                     RELEASE_ASSERT_NOT_REACHED();
1725                     break;
1726                 }
1727                 break;
1728             }
1729 
1730             if (leftConst.isString() &amp;&amp; rightConst.isString()) {
1731                 const StringImpl* a = asString(leftConst)-&gt;tryGetValueImpl();
1732                 const StringImpl* b = asString(rightConst)-&gt;tryGetValueImpl();
1733                 if (a &amp;&amp; b) {
1734                     bool result;
1735                     if (node-&gt;op() == CompareEq)
1736                         result = WTF::equal(a, b);
1737                     else if (node-&gt;op() == CompareLess)
1738                         result = codePointCompare(a, b) &lt; 0;
1739                     else if (node-&gt;op() == CompareLessEq)
1740                         result = codePointCompare(a, b) &lt;= 0;
1741                     else if (node-&gt;op() == CompareGreater)
1742                         result = codePointCompare(a, b) &gt; 0;
1743                     else if (node-&gt;op() == CompareGreaterEq)
1744                         result = codePointCompare(a, b) &gt;= 0;
1745                     else
1746                         RELEASE_ASSERT_NOT_REACHED();
1747                     setConstant(node, jsBoolean(result));
1748                     break;
1749                 }
1750             }
1751 
1752             if (node-&gt;op() == CompareEq &amp;&amp; leftConst.isSymbol() &amp;&amp; rightConst.isSymbol()) {
1753                 setConstant(node, jsBoolean(asSymbol(leftConst) == asSymbol(rightConst)));
1754                 break;
1755             }
1756         }
1757 
1758         if (node-&gt;op() == CompareEq) {
1759             SpeculatedType leftType = forNode(node-&gt;child1()).m_type;
1760             SpeculatedType rightType = forNode(node-&gt;child2()).m_type;
1761             if (!valuesCouldBeEqual(leftType, rightType)) {
1762                 setConstant(node, jsBoolean(false));
1763                 break;
1764             }
1765 
1766             if (leftType == SpecOther)
1767                 std::swap(leftType, rightType);
1768             if (rightType == SpecOther) {
1769                 // Undefined and Null are always equal when compared to eachother.
1770                 if (!(leftType &amp; ~SpecOther)) {
1771                     setConstant(node, jsBoolean(true));
1772                     break;
1773                 }
1774 
1775                 // Any other type compared to Null or Undefined is always false
1776                 // as long as the MasqueradesAsUndefined watchpoint is valid.
1777                 //
1778                 // MasqueradesAsUndefined only matters for SpecObjectOther, other
1779                 // cases are always &quot;false&quot;.
1780                 if (!(leftType &amp; (SpecObjectOther | SpecOther))) {
1781                     setConstant(node, jsBoolean(false));
1782                     break;
1783                 }
1784 
1785                 if (!(leftType &amp; SpecOther) &amp;&amp; m_graph.masqueradesAsUndefinedWatchpointIsStillValid(node-&gt;origin.semantic)) {
1786                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1787                     m_graph.watchpoints().addLazily(globalObject-&gt;masqueradesAsUndefinedWatchpoint());
1788                     setConstant(node, jsBoolean(false));
1789                     break;
1790                 }
1791             }
1792         }
1793 
1794         if (node-&gt;child1() == node-&gt;child2()) {
1795             if (node-&gt;isBinaryUseKind(Int32Use) ||
1796                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1797                 node-&gt;isBinaryUseKind(StringUse) ||
1798                 node-&gt;isBinaryUseKind(BooleanUse) ||
1799                 node-&gt;isBinaryUseKind(SymbolUse) ||
1800                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1801                 node-&gt;isBinaryUseKind(ObjectUse) ||
1802                 node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse) ||
1803                 node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
1804                 switch (node-&gt;op()) {
1805                 case CompareLess:
1806                 case CompareGreater:
1807                     setConstant(node, jsBoolean(false));
1808                     break;
1809                 case CompareLessEq:
1810                 case CompareGreaterEq:
1811                 case CompareEq:
1812                     setConstant(node, jsBoolean(true));
1813                     break;
1814                 default:
1815                     DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1816                     break;
1817                 }
1818                 break;
1819             }
1820         }
1821 
1822         if (isClobbering)
1823             clobberWorld();
1824         setNonCellTypeForNode(node, SpecBoolean);
1825         break;
1826     }
1827 
1828     case CompareStrictEq:
1829     case SameValue: {
1830         Node* leftNode = node-&gt;child1().node();
1831         Node* rightNode = node-&gt;child2().node();
1832         JSValue left = forNode(leftNode).value();
1833         JSValue right = forNode(rightNode).value();
1834         if (left &amp;&amp; right) {
1835             if (left.isString() &amp;&amp; right.isString()) {
1836                 // We need this case because JSValue::strictEqual is otherwise too racy for
1837                 // string comparisons.
1838                 const StringImpl* a = asString(left)-&gt;tryGetValueImpl();
1839                 const StringImpl* b = asString(right)-&gt;tryGetValueImpl();
1840                 if (a &amp;&amp; b) {
1841                     setConstant(node, jsBoolean(WTF::equal(a, b)));
1842                     break;
1843                 }
1844             } else {
1845                 if (node-&gt;op() == CompareStrictEq)
1846                     setConstant(node, jsBoolean(JSValue::strictEqual(nullptr, left, right)));
1847                 else
1848                     setConstant(node, jsBoolean(sameValue(nullptr, left, right)));
1849                 break;
1850             }
1851         }
1852 
1853         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1854             // FIXME: Revisit this condition when introducing BigInt to JSC.
1855             auto isNonStringCellConstant = [] (JSValue value) {
1856                 return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
1857             };
1858 
1859             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
1860                 m_state.setFoundConstants(true);
1861                 setNonCellTypeForNode(node, SpecBoolean);
1862                 break;
1863             }
1864         }
1865 
1866         SpeculatedType leftLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(leftNode).m_type);
1867         SpeculatedType rightLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(rightNode).m_type);
1868         if (!(leftLUB &amp; rightLUB)) {
1869             setConstant(node, jsBoolean(false));
1870             break;
1871         }
1872 
1873         if (node-&gt;child1() == node-&gt;child2()) {
1874             if (node-&gt;isBinaryUseKind(BooleanUse) ||
1875                 node-&gt;isBinaryUseKind(Int32Use) ||
1876                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1877                 node-&gt;isBinaryUseKind(StringUse) ||
1878                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1879                 node-&gt;isBinaryUseKind(SymbolUse) ||
1880                 node-&gt;isBinaryUseKind(ObjectUse) ||
1881                 node-&gt;isBinaryUseKind(MiscUse, UntypedUse) ||
1882                 node-&gt;isBinaryUseKind(UntypedUse, MiscUse) ||
1883                 node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse) ||
1884                 node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse) ||
1885                 node-&gt;isBinaryUseKind(StringUse, UntypedUse) ||
1886                 node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
1887                 setConstant(node, jsBoolean(true));
1888                 break;
1889             }
1890         }
1891 
1892         setNonCellTypeForNode(node, SpecBoolean);
1893         break;
1894     }
1895 
1896     case CompareEqPtr: {
1897         Node* childNode = node-&gt;child1().node();
1898         JSValue childValue = forNode(childNode).value();
1899         if (childValue) {
1900             setConstant(node, jsBoolean(childValue.isCell() &amp;&amp; childValue.asCell() == node-&gt;cellOperand()-&gt;cell()));
1901             break;
1902         }
1903 
1904         setNonCellTypeForNode(node, SpecBoolean);
1905         break;
1906     }
1907 
1908     case StringCharCodeAt:
1909         setNonCellTypeForNode(node, SpecInt32Only);
1910         break;
1911 
1912     case StringFromCharCode:
1913         switch (node-&gt;child1().useKind()) {
1914         case Int32Use:
1915             break;
1916         case UntypedUse:
1917             clobberWorld();
1918             break;
1919         default:
1920             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
1921             break;
1922         }
1923         setTypeForNode(node, SpecString);
1924         break;
1925 
1926     case StringCharAt:
1927         setForNode(node, m_vm.stringStructure.get());
1928         break;
1929 
1930     case GetByVal:
1931     case AtomicsAdd:
1932     case AtomicsAnd:
1933     case AtomicsCompareExchange:
1934     case AtomicsExchange:
1935     case AtomicsLoad:
1936     case AtomicsOr:
1937     case AtomicsStore:
1938     case AtomicsSub:
1939     case AtomicsXor: {
1940         if (node-&gt;op() == GetByVal) {
1941             auto foldGetByValOnConstantProperty = [&amp;] (Edge&amp; arrayEdge, Edge&amp; indexEdge) {
1942                 // FIXME: We can expand this for non x86 environments.
1943                 // https://bugs.webkit.org/show_bug.cgi?id=134641
1944                 if (!isX86())
1945                     return false;
1946 
1947                 AbstractValue&amp; arrayValue = forNode(arrayEdge);
1948 
1949                 // Check the structure set is finite. This means that this constant&#39;s structure is watched and guaranteed the one of this set.
1950                 // When the structure is changed, this code should be invalidated. This is important since the following code relies on the
1951                 // constant object&#39;s is not changed.
1952                 if (!arrayValue.m_structure.isFinite())
1953                     return false;
1954 
1955                 JSValue arrayConstant = arrayValue.value();
1956                 if (!arrayConstant)
1957                     return false;
1958 
1959                 JSObject* array = jsDynamicCast&lt;JSObject*&gt;(m_vm, arrayConstant);
1960                 if (!array)
1961                     return false;
1962 
1963                 JSValue indexConstant = forNode(indexEdge).value();
1964                 if (!indexConstant || !indexConstant.isInt32() || indexConstant.asInt32() &lt; 0)
1965                     return false;
1966                 uint32_t index = indexConstant.asUInt32();
1967 
1968                 // Check that the early StructureID is not nuked, get the butterfly, and check the late StructureID again.
1969                 // And we check the indexing mode of the structure. If the indexing mode is CoW, the butterfly is
1970                 // definitely JSImmutableButterfly.
1971                 StructureID structureIDEarly = array-&gt;structureID();
1972                 if (isNuked(structureIDEarly))
1973                     return false;
1974 
1975                 if (node-&gt;arrayMode().arrayClass() == Array::OriginalCopyOnWriteArray) {
1976 
1977                     WTF::loadLoadFence();
1978                     Butterfly* butterfly = array-&gt;butterfly();
1979 
1980                     WTF::loadLoadFence();
1981                     StructureID structureIDLate = array-&gt;structureID();
1982 
1983                     if (structureIDEarly != structureIDLate)
1984                         return false;
1985 
1986                     Structure* structure = m_vm.getStructure(structureIDLate);
1987                     switch (node-&gt;arrayMode().type()) {
1988                     case Array::Int32:
1989                     case Array::Contiguous:
1990                     case Array::Double:
1991                         if (structure-&gt;indexingMode() != (toIndexingShape(node-&gt;arrayMode().type()) | CopyOnWrite | IsArray))
1992                             return false;
1993                         break;
1994                     default:
1995                         return false;
1996                     }
1997                     ASSERT(isCopyOnWrite(structure-&gt;indexingMode()));
1998 
1999                     JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::fromButterfly(butterfly);
2000                     if (index &lt; immutableButterfly-&gt;length()) {
2001                         JSValue value = immutableButterfly-&gt;get(index);
2002                         ASSERT(value);
2003                         if (value.isCell())
2004                             setConstant(node, *m_graph.freeze(value.asCell()));
2005                         else
2006                             setConstant(node, value);
2007                         return true;
2008                     }
2009 
2010                     if (node-&gt;arrayMode().isOutOfBounds()) {
2011                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2012                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(m_vm);
2013                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_vm);
2014                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
2015                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
2016                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
2017                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
2018                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
2019                             // Note that Array::Double and Array::Int32 return JSValue if array mode is OutOfBounds.
2020                             setConstant(node, jsUndefined());
2021                             return true;
2022                         }
2023                     }
2024                     return false;
2025                 }
2026 
2027                 if (node-&gt;arrayMode().type() == Array::ArrayStorage || node-&gt;arrayMode().type() == Array::SlowPutArrayStorage) {
2028                     JSValue value;
2029                     {
2030                         // ArrayStorage&#39;s Butterfly can be half-broken state.
2031                         auto locker = holdLock(array-&gt;cellLock());
2032 
2033                         WTF::loadLoadFence();
2034                         Butterfly* butterfly = array-&gt;butterfly();
2035 
2036                         WTF::loadLoadFence();
2037                         StructureID structureIDLate = array-&gt;structureID();
2038 
2039                         if (structureIDEarly != structureIDLate)
2040                             return false;
2041 
2042                         Structure* structure = m_vm.getStructure(structureIDLate);
2043                         if (!hasAnyArrayStorage(structure-&gt;indexingMode()))
2044                             return false;
2045 
2046                         if (structure-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
2047                             return false;
2048 
2049                         ArrayStorage* storage = butterfly-&gt;arrayStorage();
2050                         if (index &gt;= storage-&gt;length())
2051                             return false;
2052 
2053                         if (index &lt; storage-&gt;vectorLength())
2054                             return false;
2055 
2056                         SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2057                         if (!map)
2058                             return false;
2059 
2060                         value = map-&gt;getConcurrently(index);
2061                     }
2062                     if (!value)
2063                         return false;
2064 
2065                     if (value.isCell())
2066                         setConstant(node, *m_graph.freeze(value.asCell()));
2067                     else
2068                         setConstant(node, value);
2069                     return true;
2070                 }
2071 
2072                 return false;
2073             };
2074 
2075             bool didFold = false;
2076             switch (node-&gt;arrayMode().type()) {
2077             case Array::Generic:
2078             case Array::Int32:
2079             case Array::Double:
2080             case Array::Contiguous:
2081             case Array::ArrayStorage:
2082             case Array::SlowPutArrayStorage:
2083                 if (foldGetByValOnConstantProperty(m_graph.child(node, 0), m_graph.child(node, 1))) {
2084                     if (!node-&gt;arrayMode().isInBounds())
2085                         didFoldClobberWorld();
2086                     didFold = true;
2087                 }
2088                 break;
2089             default:
2090                 break;
2091             }
2092 
2093             if (didFold)
2094                 break;
2095         }
2096 
2097         if (node-&gt;op() != GetByVal) {
2098             unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2099             Edge storageEdge = m_graph.child(node, 2 + numExtraArgs);
2100             if (!storageEdge)
2101                 clobberWorld();
2102         }
2103         switch (node-&gt;arrayMode().type()) {
2104         case Array::SelectUsingPredictions:
2105         case Array::Unprofiled:
2106         case Array::SelectUsingArguments:
2107             RELEASE_ASSERT_NOT_REACHED();
2108             break;
2109         case Array::ForceExit:
2110             m_state.setIsValid(false);
2111             break;
2112         case Array::Undecided: {
2113             JSValue index = forNode(m_graph.child(node, 1)).value();
2114             if (index &amp;&amp; index.isInt32() &amp;&amp; index.asInt32() &gt;= 0) {
2115                 setConstant(node, jsUndefined());
2116                 break;
2117             }
2118             setNonCellTypeForNode(node, SpecOther);
2119             break;
2120         }
2121         case Array::Generic:
2122             clobberWorld();
2123             makeHeapTopForNode(node);
2124             break;
2125         case Array::String:
2126             if (node-&gt;arrayMode().isOutOfBounds()) {
2127                 // If the watchpoint was still valid we could totally set this to be
2128                 // SpecString | SpecOther. Except that we&#39;d have to be careful. If we
2129                 // tested the watchpoint state here then it could change by the time
2130                 // we got to the backend. So to do this right, we&#39;d have to get the
2131                 // fixup phase to check the watchpoint state and then bake into the
2132                 // GetByVal operation the fact that we&#39;re using a watchpoint, using
2133                 // something like Array::SaneChain (except not quite, because that
2134                 // implies an in-bounds access). None of this feels like it&#39;s worth it,
2135                 // so we&#39;re going with TOP for now. The same thing applies to
2136                 // clobbering the world.
2137                 clobberWorld();
2138                 makeHeapTopForNode(node);
2139             } else
2140                 setForNode(node, m_vm.stringStructure.get());
2141             break;
2142         case Array::DirectArguments:
2143         case Array::ScopedArguments:
2144             if (node-&gt;arrayMode().isOutOfBounds())
2145                 clobberWorld();
2146             makeHeapTopForNode(node);
2147             break;
2148         case Array::Int32:
2149             if (node-&gt;arrayMode().isOutOfBounds()) {
2150                 clobberWorld();
2151                 makeHeapTopForNode(node);
2152             } else
2153                 setNonCellTypeForNode(node, SpecInt32Only);
2154             break;
2155         case Array::Double:
2156             if (node-&gt;arrayMode().isOutOfBounds()) {
2157                 clobberWorld();
2158                 makeHeapTopForNode(node);
2159             } else if (node-&gt;arrayMode().isSaneChain())
2160                 setNonCellTypeForNode(node, SpecBytecodeDouble);
2161             else
2162                 setNonCellTypeForNode(node, SpecDoubleReal);
2163             break;
2164         case Array::Contiguous:
2165         case Array::ArrayStorage:
2166         case Array::SlowPutArrayStorage:
2167             if (node-&gt;arrayMode().isOutOfBounds())
2168                 clobberWorld();
2169             makeHeapTopForNode(node);
2170             break;
2171         case Array::Int8Array:
2172             setNonCellTypeForNode(node, SpecInt32Only);
2173             break;
2174         case Array::Int16Array:
2175             setNonCellTypeForNode(node, SpecInt32Only);
2176             break;
2177         case Array::Int32Array:
2178             setNonCellTypeForNode(node, SpecInt32Only);
2179             break;
2180         case Array::Uint8Array:
2181             setNonCellTypeForNode(node, SpecInt32Only);
2182             break;
2183         case Array::Uint8ClampedArray:
2184             setNonCellTypeForNode(node, SpecInt32Only);
2185             break;
2186         case Array::Uint16Array:
2187             setNonCellTypeForNode(node, SpecInt32Only);
2188             break;
2189         case Array::Uint32Array:
2190             if (node-&gt;shouldSpeculateInt32())
2191                 setNonCellTypeForNode(node, SpecInt32Only);
<a name="41" id="anc41"></a><span class="line-modified">2192             else if (node-&gt;shouldSpeculateInt52())</span>
<span class="line-modified">2193                 setNonCellTypeForNode(node, SpecInt52Any);</span>
2194             else
2195                 setNonCellTypeForNode(node, SpecAnyIntAsDouble);
2196             break;
2197         case Array::Float32Array:
2198             setNonCellTypeForNode(node, SpecFullDouble);
2199             break;
2200         case Array::Float64Array:
2201             setNonCellTypeForNode(node, SpecFullDouble);
2202             break;
2203         default:
2204             RELEASE_ASSERT_NOT_REACHED();
2205             break;
2206         }
2207         break;
2208     }
2209 
2210     case PutByValDirect:
2211     case PutByVal:
2212     case PutByValAlias: {
2213         switch (node-&gt;arrayMode().modeForPut().type()) {
2214         case Array::ForceExit:
2215             m_state.setIsValid(false);
2216             break;
2217         case Array::Generic:
2218             clobberWorld();
2219             break;
2220         case Array::Int32:
2221             if (node-&gt;arrayMode().isOutOfBounds())
2222                 clobberWorld();
2223             break;
2224         case Array::Double:
2225             if (node-&gt;arrayMode().isOutOfBounds())
2226                 clobberWorld();
2227             break;
2228         case Array::Contiguous:
2229         case Array::ArrayStorage:
2230             if (node-&gt;arrayMode().isOutOfBounds())
2231                 clobberWorld();
2232             break;
2233         case Array::SlowPutArrayStorage:
2234             if (node-&gt;arrayMode().mayStoreToHole())
2235                 clobberWorld();
2236             break;
2237         default:
2238             break;
2239         }
2240         break;
2241     }
2242 
2243     case ArrayPush:
2244         clobberWorld();
2245         setNonCellTypeForNode(node, SpecBytecodeNumber);
2246         break;
2247 
2248     case ArraySlice: {
2249         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2250 
2251         // FIXME: We could do better here if we prove that the
2252         // incoming value has only a single structure.
2253         RegisteredStructureSet structureSet;
2254         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithInt32)));
2255         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous)));
2256         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithDouble)));
2257 
2258         setForNode(node, structureSet);
2259         break;
2260     }
2261 
2262     case ArrayIndexOf: {
2263         setNonCellTypeForNode(node, SpecInt32Only);
2264         break;
2265     }
2266 
2267     case ArrayPop:
2268         clobberWorld();
2269         makeHeapTopForNode(node);
2270         break;
2271 
2272     case GetMyArgumentByVal:
2273     case GetMyArgumentByValOutOfBounds: {
2274         JSValue index = forNode(node-&gt;child2()).m_value;
<a name="42" id="anc42"></a><span class="line-modified">2275         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
2276 
2277         if (index &amp;&amp; index.isUInt32()) {
2278             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2279             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2280             // paths as unreachable, or to return undefined. We could implement that eventually.
2281 
2282             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2283             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2284             unsigned argumentIndex;
2285             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2286                 if (inlineCallFrame) {
2287                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {
2288                         setForNode(node, m_state.operand(
2289                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));
2290                         m_state.setFoundConstants(true);
2291                         break;
2292                     }
2293                 } else {
2294                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2295                         setForNode(node, m_state.argument(argumentIndex + 1));
2296                         m_state.setFoundConstants(true);
2297                         break;
2298                     }
2299                 }
2300             }
2301         }
2302 
2303         if (inlineCallFrame) {
2304             // We have a bound on the types even though it&#39;s random access. Take advantage of this.
2305 
2306             AbstractValue result;
2307             for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
2308                 result.merge(
2309                     m_state.operand(
2310                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset));
2311             }
2312 
2313             if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
2314                 result.merge(SpecOther);
2315 
2316             if (result.value())
2317                 m_state.setFoundConstants(true);
2318 
2319             setForNode(node, result);
2320             break;
2321         }
2322 
2323         makeHeapTopForNode(node);
2324         break;
2325     }
2326 
2327     case RegExpExec:
2328     case RegExpExecNonGlobalOrSticky:
2329         if (node-&gt;op() == RegExpExec) {
2330             // Even if we&#39;ve proven known input types as RegExpObject and String,
2331             // accessing lastIndex is effectful if it&#39;s a global regexp.
2332             clobberWorld();
2333         }
2334 
2335         if (JSValue globalObjectValue = forNode(node-&gt;child1()).m_value) {
2336             if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
2337                 if (!globalObject-&gt;isHavingABadTime()) {
2338                     m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2339                     RegisteredStructureSet structureSet;
2340                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));
2341                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayWithGroupsStructure()));
2342                     setForNode(node, structureSet);
2343                     forNode(node).merge(SpecOther);
2344                     break;
2345                 }
2346             }
2347         }
2348         setTypeForNode(node, SpecOther | SpecArray);
2349         break;
2350 
2351     case RegExpTest:
2352         // Even if we&#39;ve proven known input types as RegExpObject and String,
2353         // accessing lastIndex is effectful if it&#39;s a global regexp.
2354         clobberWorld();
2355         setNonCellTypeForNode(node, SpecBoolean);
2356         break;
2357 
2358     case RegExpMatchFast:
2359         ASSERT(node-&gt;child2().useKind() == RegExpObjectUse);
2360         ASSERT(node-&gt;child3().useKind() == StringUse || node-&gt;child3().useKind() == KnownStringUse);
2361         setTypeForNode(node, SpecOther | SpecArray);
2362         break;
2363 
2364     case RegExpMatchFastGlobal:
2365         ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == KnownStringUse);
2366         setTypeForNode(node, SpecOther | SpecArray);
2367         break;
2368 
2369     case StringReplace:
2370     case StringReplaceRegExp:
2371         if (node-&gt;child1().useKind() == StringUse
2372             &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
2373             &amp;&amp; node-&gt;child3().useKind() == StringUse) {
2374             // This doesn&#39;t clobber the world. It just reads and writes regexp state.
2375         } else
2376             clobberWorld();
2377         setForNode(node, m_vm.stringStructure.get());
2378         break;
2379 
2380     case Jump:
2381         break;
2382 
2383     case Branch: {
2384         Node* child = node-&gt;child1().node();
2385         BooleanResult result = booleanResult(node, forNode(child));
2386         if (result == DefinitelyTrue) {
2387             m_state.setBranchDirection(TakeTrue);
2388             break;
2389         }
2390         if (result == DefinitelyFalse) {
2391             m_state.setBranchDirection(TakeFalse);
2392             break;
2393         }
2394         // FIXME: The above handles the trivial cases of sparse conditional
2395         // constant propagation, but we can do better:
2396         // We can specialize the source variable&#39;s value on each direction of
2397         // the branch.
2398         m_state.setBranchDirection(TakeBoth);
2399         break;
2400     }
2401 
2402     case Switch: {
2403         // Nothing to do for now.
2404         // FIXME: Do sparse conditional things.
2405         break;
2406     }
2407 
2408     case EntrySwitch:
2409         break;
2410 
2411     case Return:
2412         m_state.setIsValid(false);
2413         break;
2414 
2415     case Throw:
2416     case ThrowStaticError:
2417     case TailCall:
2418     case DirectTailCall:
2419     case TailCallVarargs:
2420     case TailCallForwardVarargs:
2421         clobberWorld();
2422         m_state.setIsValid(false);
2423         break;
2424 
2425     case ToPrimitive: {
2426         JSValue childConst = forNode(node-&gt;child1()).value();
2427         if (childConst &amp;&amp; childConst.isNumber()) {
2428             didFoldClobberWorld();
2429             setConstant(node, childConst);
2430             break;
2431         }
2432 
2433         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2434 
2435         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
2436             m_state.setFoundConstants(true);
2437             didFoldClobberWorld();
2438             setForNode(node, forNode(node-&gt;child1()));
2439             break;
2440         }
2441 
2442         clobberWorld();
2443 
2444         setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
2445         break;
2446     }
2447 
2448     case ToNumber: {
2449         JSValue childConst = forNode(node-&gt;child1()).value();
2450         if (childConst &amp;&amp; childConst.isNumber()) {
2451             didFoldClobberWorld();
2452             setConstant(node, childConst);
2453             break;
2454         }
2455 
2456         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2457 
2458         if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
2459             m_state.setFoundConstants(true);
2460             didFoldClobberWorld();
2461             setForNode(node, forNode(node-&gt;child1()));
2462             break;
2463         }
2464 
2465         clobberWorld();
2466         setNonCellTypeForNode(node, SpecBytecodeNumber);
2467         break;
2468     }
2469 
2470     case ToString:
2471     case CallStringConstructor: {
2472         switch (node-&gt;child1().useKind()) {
2473         case StringObjectUse:
2474         case StringOrStringObjectUse:
2475         case Int32Use:
2476         case Int52RepUse:
2477         case DoubleRepUse:
2478         case NotCellUse:
2479             break;
2480         case CellUse:
2481         case UntypedUse:
2482             clobberWorld();
2483             break;
2484         default:
2485             RELEASE_ASSERT_NOT_REACHED();
2486             break;
2487         }
2488         setForNode(node, m_vm.stringStructure.get());
2489         break;
2490     }
2491 
2492     case NumberToStringWithRadix: {
2493         JSValue radixValue = forNode(node-&gt;child2()).m_value;
2494         if (radixValue &amp;&amp; radixValue.isInt32()) {
2495             int32_t radix = radixValue.asInt32();
2496             if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
2497                 m_state.setFoundConstants(true);
2498                 didFoldClobberWorld();
2499                 setForNode(node, m_graph.m_vm.stringStructure.get());
2500                 break;
2501             }
2502         }
2503         clobberWorld();
2504         setForNode(node, m_graph.m_vm.stringStructure.get());
2505         break;
2506     }
2507 
2508     case NumberToStringWithValidRadixConstant: {
2509         setForNode(node, m_graph.m_vm.stringStructure.get());
2510         break;
2511     }
2512 
2513     case NewStringObject: {
2514         ASSERT(node-&gt;structure()-&gt;classInfo() == StringObject::info());
2515         setForNode(node, node-&gt;structure());
2516         break;
2517     }
2518 
2519     case NewSymbol: {
2520         setForNode(node, m_vm.symbolStructure.get());
2521         break;
2522     }
2523 
2524     case NewArray:
2525         ASSERT(node-&gt;indexingMode() == node-&gt;indexingType()); // Copy on write arrays should only be created by NewArrayBuffer.
2526         setForNode(node,
2527             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
2528         break;
2529 
2530     case NewArrayWithSpread:
2531         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2532             // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
2533             // with StructureRegisterationPhase we must say we produce an original array
2534             // allocation structure.
2535             setForNode(node,
2536                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
2537         } else {
2538             setForNode(node,
2539                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
2540         }
2541 
2542         break;
2543 
2544     case Spread:
2545         switch (node-&gt;child1()-&gt;op()) {
2546         case PhantomNewArrayBuffer:
2547         case PhantomCreateRest:
2548             break;
2549         default:
2550             if (!m_graph.canDoFastSpread(node, forNode(node-&gt;child1())))
2551                 clobberWorld();
2552             else
2553                 didFoldClobberWorld();
2554             break;
2555         }
2556 
2557         setForNode(node,
2558             m_vm.fixedArrayStructure.get());
2559         break;
2560 
2561     case NewArrayBuffer:
2562         setForNode(node,
2563             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
2564         break;
2565 
2566     case NewArrayWithSize:
2567         setTypeForNode(node, SpecArray);
2568         break;
2569 
2570     case NewTypedArray:
2571         switch (node-&gt;child1().useKind()) {
2572         case Int32Use:
2573             break;
2574         case UntypedUse:
2575             clobberWorld();
2576             break;
2577         default:
2578             RELEASE_ASSERT_NOT_REACHED();
2579             break;
2580         }
2581         setForNode(node,
2582             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2583                 node-&gt;typedArrayType()));
2584         break;
2585 
2586     case NewRegexp:
2587         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2588         break;
2589 
2590     case ToThis: {
2591         AbstractValue&amp; source = forNode(node-&gt;child1());
2592         AbstractValue&amp; destination = forNode(node);
<a name="43" id="anc43"></a><span class="line-modified">2593         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);</span>
2594 
2595         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2596         switch (result) {
2597         case ToThisResult::Identity:
2598             m_state.setFoundConstants(true);
2599             destination = source;
2600             break;
2601         case ToThisResult::Undefined:
2602             setConstant(node, jsUndefined());
2603             break;
2604         case ToThisResult::GlobalThis:
2605             m_state.setFoundConstants(true);
2606             destination.setType(m_graph, SpecObject);
2607             break;
2608         case ToThisResult::Dynamic:
2609             if (strictMode)
2610                 destination.makeHeapTop();
2611             else {
2612                 destination = source;
2613                 destination.merge(SpecObject);
2614             }
2615             break;
2616         }
2617         break;
2618     }
2619 
2620     case CreateThis: {
2621         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2622             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2623                 if (FunctionRareData* rareData = function-&gt;rareData()) {
2624                     if (Structure* structure = rareData-&gt;objectAllocationStructure()) {
2625                         m_graph.freeze(rareData);
2626                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
2627                         m_state.setFoundConstants(true);
2628                         didFoldClobberWorld();
2629                         setForNode(node, structure);
2630                         break;
2631                     }
2632                 }
2633             }
2634         }
2635         clobberWorld();
2636         setTypeForNode(node, SpecFinalObject);
2637         break;
2638     }
2639 
2640     case NewObject:
2641         ASSERT(!!node-&gt;structure().get());
2642         setForNode(node, node-&gt;structure());
2643         break;
2644 
2645     case ObjectCreate: {
2646         if (JSValue base = forNode(node-&gt;child1()).m_value) {
<a name="44" id="anc44"></a><span class="line-modified">2647             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-modified">2648             Structure* structure = nullptr;</span>
<span class="line-added">2649             if (base.isNull())</span>
<span class="line-added">2650                 structure = globalObject-&gt;nullPrototypeObjectStructure();</span>
<span class="line-added">2651             else if (base.isObject())</span>
<span class="line-added">2652                 structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
<span class="line-added">2653 </span>
<span class="line-added">2654             if (structure) {</span>
2655                 m_state.setFoundConstants(true);
2656                 if (node-&gt;child1().useKind() == UntypedUse)
2657                     didFoldClobberWorld();
<a name="45" id="anc45"></a><span class="line-modified">2658                 setForNode(node, structure);</span>
2659                 break;
2660             }
<a name="46" id="anc46"></a>


2661         }
2662         if (node-&gt;child1().useKind() == UntypedUse)
2663             clobberWorld();
2664         setTypeForNode(node, SpecFinalObject);
2665         break;
2666     }
2667 
2668     case ObjectKeys: {
2669         if (node-&gt;child1().useKind() == ObjectUse) {
2670             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2671             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2672                 RegisteredStructure structure = structureSet.onlyStructure();
2673                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2674                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2675                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2676                             m_state.setFoundConstants(true);
2677                             didFoldClobberWorld();
2678                             setTypeForNode(node, SpecArray);
2679                             break;
2680                         }
2681                     }
2682                 }
2683             }
2684         }
2685 
2686         clobberWorld();
2687         setTypeForNode(node, SpecArray);
2688         break;
2689     }
2690 
2691     case ToObject:
2692     case CallObjectConstructor: {
2693         AbstractValue&amp; source = forNode(node-&gt;child1());
2694         AbstractValue&amp; destination = forNode(node);
2695 
2696         if (!(source.m_type &amp; ~SpecObject)) {
2697             m_state.setFoundConstants(true);
2698             if (node-&gt;op() == ToObject)
2699                 didFoldClobberWorld();
2700             destination = source;
2701             break;
2702         }
2703 
2704         if (node-&gt;op() == ToObject)
2705             clobberWorld();
2706         setTypeForNode(node, SpecObject);
2707         break;
2708     }
2709 
2710     case PhantomNewObject:
2711     case PhantomNewFunction:
2712     case PhantomNewGeneratorFunction:
2713     case PhantomNewAsyncGeneratorFunction:
2714     case PhantomNewAsyncFunction:
2715     case PhantomCreateActivation:
2716     case PhantomDirectArguments:
2717     case PhantomClonedArguments:
2718     case PhantomCreateRest:
2719     case PhantomSpread:
2720     case PhantomNewArrayWithSpread:
2721     case PhantomNewArrayBuffer:
2722     case PhantomNewRegexp:
2723     case BottomValue: {
2724         clearForNode(node);
2725         break;
2726     }
2727 
2728     case PutHint:
2729         break;
2730 
2731     case MaterializeNewObject: {
2732         setForNode(node, node-&gt;structureSet());
2733         break;
2734     }
2735 
2736     case PushWithScope:
2737         // We don&#39;t use the more precise withScopeStructure() here because it is a LazyProperty and may not yet be allocated.
2738         setTypeForNode(node, SpecObjectOther);
2739         break;
2740 
2741     case CreateActivation:
2742     case MaterializeCreateActivation:
2743         setForNode(node,
2744             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;activationStructure());
2745         break;
2746 
2747     case CreateDirectArguments:
2748         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
2749         break;
2750 
2751     case CreateScopedArguments:
2752         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure());
2753         break;
2754 
2755     case CreateClonedArguments:
2756         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2757             setTypeForNode(node, SpecObject);
2758             break;
2759         }
2760         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
2761         break;
2762 
2763     case NewGeneratorFunction:
2764         setForNode(node,
2765             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
2766         break;
2767 
2768     case NewAsyncGeneratorFunction:
2769         setForNode(node,
2770             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
2771         break;
2772 
2773     case NewAsyncFunction:
2774         setForNode(node,
2775             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
2776         break;
2777 
2778     case NewFunction: {
2779         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
2780         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
2781         setForNode(node, structure);
2782         break;
2783     }
2784 
2785     case GetCallee:
2786         if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
<a name="47" id="anc47"></a><span class="line-modified">2787             if (JSFunction* function = executable-&gt;singleton().inferredValue()) {</span>
<span class="line-modified">2788                 m_graph.watchpoints().addLazily(executable);</span>


2789                 setConstant(node, *m_graph.freeze(function));
2790                 break;
2791             }
2792         }
<a name="48" id="anc48"></a><span class="line-modified">2793         setTypeForNode(node, SpecFunction | SpecObjectOther);</span>
2794         break;
2795 
2796     case GetArgumentCountIncludingThis:
2797         setTypeForNode(node, SpecInt32Only);
2798         break;
2799 
2800     case SetCallee:
2801     case SetArgumentCountIncludingThis:
2802         break;
2803 
2804     case GetRestLength:
2805         setNonCellTypeForNode(node, SpecInt32Only);
2806         break;
2807 
2808     case GetGetter: {
<a name="49" id="anc49"></a><span class="line-modified">2809         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-modified">2810             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="line-modified">2811             if (getterSetter &amp;&amp; !getterSetter-&gt;isGetterNull()) {</span>

2812                 setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
2813                 break;
2814             }
2815         }
2816 
2817         setTypeForNode(node, SpecObject);
2818         break;
2819     }
2820 
2821     case GetSetter: {
<a name="50" id="anc50"></a><span class="line-modified">2822         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-modified">2823             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);</span>
<span class="line-modified">2824             if (getterSetter &amp;&amp; !getterSetter-&gt;isSetterNull()) {</span>

2825                 setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
2826                 break;
2827             }
2828         }
2829 
2830         setTypeForNode(node, SpecObject);
2831         break;
2832     }
2833 
2834     case GetScope:
2835         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2836             if (JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2837                 setConstant(node, *m_graph.freeze(function-&gt;scope()));
2838                 break;
2839             }
2840         }
2841         setTypeForNode(node, SpecObjectOther);
2842         break;
2843 
2844     case SkipScope: {
<a name="51" id="anc51"></a><span class="line-modified">2845         if (JSValue child = forNode(node-&gt;child1()).value()) {</span>
<span class="line-modified">2846             if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(m_vm, child)) {</span>
<span class="line-modified">2847                 if (JSScope* nextScope = scope-&gt;next()) {</span>
<span class="line-modified">2848                     setConstant(node, *m_graph.freeze(JSValue(nextScope)));</span>
<span class="line-added">2849                     break;</span>
<span class="line-added">2850                 }</span>
<span class="line-added">2851             }</span>
2852         }
2853         setTypeForNode(node, SpecObjectOther);
2854         break;
2855     }
2856 
2857     case GetGlobalObject: {
2858         JSValue child = forNode(node-&gt;child1()).value();
2859         if (child) {
2860             setConstant(node, *m_graph.freeze(JSValue(asObject(child)-&gt;globalObject(m_vm))));
2861             break;
2862         }
2863 
2864         if (forNode(node-&gt;child1()).m_structure.isFinite()) {
2865             JSGlobalObject* globalObject = nullptr;
2866             bool ok = true;
2867             forNode(node-&gt;child1()).m_structure.forEach(
2868                 [&amp;] (RegisteredStructure structure) {
2869                     if (!globalObject)
2870                         globalObject = structure-&gt;globalObject();
2871                     else if (globalObject != structure-&gt;globalObject())
2872                         ok = false;
2873                 });
2874             if (globalObject &amp;&amp; ok) {
2875                 setConstant(node, *m_graph.freeze(JSValue(globalObject)));
2876                 break;
2877             }
2878         }
2879 
2880         setTypeForNode(node, SpecObjectOther);
2881         break;
2882     }
2883 
2884     case GetGlobalThis: {
2885         setTypeForNode(node, SpecObject);
2886         break;
2887     }
2888 
2889     case GetClosureVar:
2890         if (JSValue value = m_graph.tryGetConstantClosureVar(forNode(node-&gt;child1()), node-&gt;scopeOffset())) {
2891             setConstant(node, *m_graph.freeze(value));
2892             break;
2893         }
2894         makeBytecodeTopForNode(node);
2895         break;
2896 
2897     case PutClosureVar:
2898         break;
2899 
2900     case GetRegExpObjectLastIndex:
2901         makeHeapTopForNode(node);
2902         break;
2903 
2904     case SetRegExpObjectLastIndex:
2905     case RecordRegExpCachedResult:
2906         break;
2907 
2908     case GetFromArguments:
2909         makeHeapTopForNode(node);
2910         break;
2911 
2912     case PutToArguments:
2913         break;
2914 
2915     case GetArgument:
2916         makeHeapTopForNode(node);
2917         break;
2918 
2919     case TryGetById:
2920         // FIXME: This should constant fold at least as well as the normal GetById case.
2921         // https://bugs.webkit.org/show_bug.cgi?id=156422
2922         makeHeapTopForNode(node);
2923         break;
2924 
2925     case GetByIdDirect:
2926     case GetByIdDirectFlush:
2927     case GetById:
2928     case GetByIdFlush: {
2929         AbstractValue&amp; value = forNode(node-&gt;child1());
2930         if (value.m_structure.isFinite()
2931             &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
2932             UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
2933             GetByIdStatus status = GetByIdStatus::computeFor(value.m_structure.toStructureSet(), uid);
2934             if (status.isSimple()) {
2935                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
2936                 // something more subtle?
2937                 AbstractValue result;
2938                 for (unsigned i = status.numVariants(); i--;) {
2939                     // This thing won&#39;t give us a variant that involves prototypes. If it did, we&#39;d
2940                     // have more work to do here.
2941                     DFG_ASSERT(m_graph, node, status[i].conditionSet().isEmpty());
2942 
2943                     result.merge(
2944                         m_graph.inferredValueForProperty(
2945                             value, status[i].offset(), m_state.structureClobberState()));
2946                 }
2947 
2948                 m_state.setFoundConstants(true);
2949                 didFoldClobberWorld();
2950                 forNode(node) = result;
2951                 break;
2952             }
2953         }
2954 
2955         clobberWorld();
2956         makeHeapTopForNode(node);
2957         break;
2958     }
2959 
2960     case GetByValWithThis:
2961     case GetByIdWithThis:
2962         clobberWorld();
2963         makeHeapTopForNode(node);
2964         break;
2965 
2966     case GetArrayLength: {
2967         JSArrayBufferView* view = m_graph.tryGetFoldableView(
2968             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
2969         if (view) {
2970             setConstant(node, jsNumber(view-&gt;length()));
2971             break;
2972         }
2973         setNonCellTypeForNode(node, SpecInt32Only);
2974         break;
2975     }
2976 
2977     case GetVectorLength: {
2978         setNonCellTypeForNode(node, SpecInt32Only);
2979         break;
2980     }
2981 
2982     case DeleteById:
2983     case DeleteByVal: {
2984         // FIXME: This could decide if the delete will be successful based on the set of structures that
2985         // we get from our base value. https://bugs.webkit.org/show_bug.cgi?id=156611
2986         clobberWorld();
2987         setNonCellTypeForNode(node, SpecBoolean);
2988         break;
2989     }
2990 
2991     case CheckStructure: {
2992         AbstractValue&amp; value = forNode(node-&gt;child1());
2993 
2994         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
2995 
2996         // It&#39;s interesting that we could have proven that the object has a larger structure set
2997         // that includes the set we&#39;re testing. In that case we could make the structure check
2998         // more efficient. We currently don&#39;t.
2999 
3000         if (value.m_structure.isSubsetOf(set))
3001             m_state.setFoundConstants(true);
3002 
3003         SpeculatedType admittedTypes = SpecNone;
3004         switch (node-&gt;child1().useKind()) {
3005         case CellUse:
3006         case KnownCellUse:
3007             admittedTypes = SpecNone;
3008             break;
3009         case CellOrOtherUse:
3010             admittedTypes = SpecOther;
3011             break;
3012         default:
3013             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
3014             break;
3015         }
3016 
3017         filter(value, set, admittedTypes);
3018         break;
3019     }
3020 
3021     case CheckStructureOrEmpty: {
3022         AbstractValue&amp; value = forNode(node-&gt;child1());
3023 
3024         bool mayBeEmpty = value.m_type &amp; SpecEmpty;
3025         if (!mayBeEmpty)
3026             m_state.setFoundConstants(true);
3027 
3028         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
3029         filter(value, node-&gt;structureSet(), admittedTypes);
3030         break;
3031     }
3032 
3033     case CheckStructureImmediate: {
3034         // FIXME: This currently can only reason about one structure at a time.
3035         // https://bugs.webkit.org/show_bug.cgi?id=136988
3036 
3037         AbstractValue&amp; value = forNode(node-&gt;child1());
3038         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3039 
3040         if (value.value()) {
3041             if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
3042                 if (set.contains(m_graph.registerStructure(structure))) {
3043                     m_state.setFoundConstants(true);
3044                     break;
3045                 }
3046             }
3047             m_state.setIsValid(false);
3048             break;
3049         }
3050 
3051         if (m_phiChildren) {
3052             bool allGood = true;
3053             m_phiChildren-&gt;forAllTransitiveIncomingValues(
3054                 node,
3055                 [&amp;] (Node* incoming) {
3056                     if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_vm)) {
3057                         if (set.contains(m_graph.registerStructure(structure)))
3058                             return;
3059                     }
3060                     allGood = false;
3061                 });
3062             if (allGood) {
3063                 m_state.setFoundConstants(true);
3064                 break;
3065             }
3066         }
3067 
3068         if (RegisteredStructure structure = set.onlyStructure()) {
3069             filterByValue(node-&gt;child1(), *m_graph.freeze(structure.get()));
3070             break;
3071         }
3072 
3073         // Aw shucks, we can&#39;t do anything!
3074         break;
3075     }
3076 
3077     case PutStructure:
3078         if (!forNode(node-&gt;child1()).m_structure.isClear()) {
3079             if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
3080                 didFoldClobberStructures();
3081                 m_state.setFoundConstants(true);
3082             } else {
3083                 observeTransition(
3084                     clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
3085                 forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
3086             }
3087         } else {
3088             // We&#39;re going to exit before we get here, but for the sake of validation, we&#39;ve folded our write to StructureID.
3089             didFoldClobberStructures();
3090         }
3091         break;
3092     case GetButterfly:
3093     case AllocatePropertyStorage:
3094     case ReallocatePropertyStorage:
3095     case NukeStructureAndSetButterfly:
3096         // FIXME: We don&#39;t model the fact that the structureID is nuked, simply because currently
3097         // nobody would currently benefit from having that information. But it&#39;s a bug nonetheless.
3098         if (node-&gt;op() == NukeStructureAndSetButterfly)
3099             didFoldClobberStructures();
3100         clearForNode(node); // The result is not a JS value.
3101         break;
3102     case CheckSubClass: {
3103         JSValue constant = forNode(node-&gt;child1()).value();
3104         if (constant) {
3105             if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
3106                 m_state.setFoundConstants(true);
3107                 ASSERT(constant);
3108                 break;
3109             }
3110         }
3111 
3112         AbstractValue&amp; value = forNode(node-&gt;child1());
3113 
3114         if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
3115             m_state.setFoundConstants(true);
3116 
3117         filterClassInfo(value, node-&gt;classInfo());
3118         break;
3119     }
3120     case CallDOMGetter: {
3121         CallDOMGetterData* callDOMGetterData = node-&gt;callDOMGetterData();
3122         DOMJIT::CallDOMGetterSnippet* snippet = callDOMGetterData-&gt;snippet;
3123         if (!snippet || snippet-&gt;effect.writes)
3124             clobberWorld();
3125         if (callDOMGetterData-&gt;domJIT)
3126             setTypeForNode(node, callDOMGetterData-&gt;domJIT-&gt;resultType());
3127         else
3128             makeBytecodeTopForNode(node);
3129         break;
3130     }
3131     case CallDOM: {
3132         const DOMJIT::Signature* signature = node-&gt;signature();
3133         if (signature-&gt;effect.writes)
3134             clobberWorld();
3135         setTypeForNode(node, signature-&gt;result);
3136         break;
3137     }
3138     case CheckArray: {
3139         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3140             m_state.setFoundConstants(true);
3141             break;
3142         }
3143         switch (node-&gt;arrayMode().type()) {
3144         case Array::String:
3145             filter(node-&gt;child1(), SpecString);
3146             break;
3147         case Array::Int32:
3148         case Array::Double:
3149         case Array::Contiguous:
3150         case Array::Undecided:
3151         case Array::ArrayStorage:
3152         case Array::SlowPutArrayStorage:
3153             break;
3154         case Array::DirectArguments:
3155             filter(node-&gt;child1(), SpecDirectArguments);
3156             break;
3157         case Array::ScopedArguments:
3158             filter(node-&gt;child1(), SpecScopedArguments);
3159             break;
3160         case Array::Int8Array:
3161             filter(node-&gt;child1(), SpecInt8Array);
3162             break;
3163         case Array::Int16Array:
3164             filter(node-&gt;child1(), SpecInt16Array);
3165             break;
3166         case Array::Int32Array:
3167             filter(node-&gt;child1(), SpecInt32Array);
3168             break;
3169         case Array::Uint8Array:
3170             filter(node-&gt;child1(), SpecUint8Array);
3171             break;
3172         case Array::Uint8ClampedArray:
3173             filter(node-&gt;child1(), SpecUint8ClampedArray);
3174             break;
3175         case Array::Uint16Array:
3176             filter(node-&gt;child1(), SpecUint16Array);
3177             break;
3178         case Array::Uint32Array:
3179             filter(node-&gt;child1(), SpecUint32Array);
3180             break;
3181         case Array::Float32Array:
3182             filter(node-&gt;child1(), SpecFloat32Array);
3183             break;
3184         case Array::Float64Array:
3185             filter(node-&gt;child1(), SpecFloat64Array);
3186             break;
3187         case Array::AnyTypedArray:
3188             filter(node-&gt;child1(), SpecTypedArrayView);
3189             break;
3190         default:
3191             RELEASE_ASSERT_NOT_REACHED();
3192             break;
3193         }
3194         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3195         break;
3196     }
3197     case Arrayify: {
3198         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3199             didFoldClobberStructures();
3200             m_state.setFoundConstants(true);
3201             break;
3202         }
3203         ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
3204         clobberStructures();
3205         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3206         break;
3207     }
3208     case ArrayifyToStructure: {
3209         AbstractValue&amp; value = forNode(node-&gt;child1());
3210         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
3211             m_state.setFoundConstants(true);
3212         clobberStructures();
3213 
3214         // We have a bunch of options of how to express the abstract set at this point. Let set S
3215         // be the set of structures that the value had before clobbering and assume that all of
3216         // them are watchable. The new value should be the least expressible upper bound of the
3217         // intersection of &quot;values that currently have structure = node-&gt;structure()&quot; and &quot;values
3218         // that have structure in S plus any structure transition-reachable from S&quot;. Assume that
3219         // node-&gt;structure() is not in S but it is transition-reachable from S. Then we would
3220         // like to say that the result is &quot;values that have structure = node-&gt;structure() until
3221         // we invalidate&quot;, but there is no way to express this using the AbstractValue syntax. So
3222         // we must choose between:
3223         //
3224         // 1) &quot;values that currently have structure = node-&gt;structure()&quot;. This is a valid
3225         //    superset of the value that we really want, and it&#39;s specific enough to satisfy the
3226         //    preconditions of the array access that this is guarding. It&#39;s also specific enough
3227         //    to allow relevant optimizations in the case that we didn&#39;t have a contradiction
3228         //    like in this example. Notice that in the abscence of any contradiction, this result
3229         //    is precise rather than being a conservative LUB.
3230         //
3231         // 2) &quot;values that currently hava structure in S plus any structure transition-reachable
3232         //    from S&quot;. This is also a valid superset of the value that we really want, but it&#39;s
3233         //    not specific enough to satisfy the preconditions of the array access that this is
3234         //    guarding - so playing such shenanigans would preclude us from having assertions on
3235         //    the typing preconditions of any array accesses. This would also not be a desirable
3236         //    answer in the absence of a contradiction.
3237         //
3238         // Note that it&#39;s tempting to simply say that the resulting value is BOTTOM because of
3239         // the contradiction. That would be wrong, since we haven&#39;t hit an invalidation point,
3240         // yet.
3241         forNode(node-&gt;child1()).set(m_graph, node-&gt;structure());
3242         break;
3243     }
3244     case GetIndexedPropertyStorage: {
3245         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3246             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3247         if (view)
3248             m_state.setFoundConstants(true);
3249         clearForNode(node);
3250         break;
3251     }
3252     case ConstantStoragePointer: {
3253         clearForNode(node);
3254         break;
3255     }
3256 
3257     case GetTypedArrayByteOffset: {
3258         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
3259         if (view) {
3260             setConstant(node, jsNumber(view-&gt;byteOffset()));
3261             break;
3262         }
3263         setNonCellTypeForNode(node, SpecInt32Only);
3264         break;
3265     }
3266 
3267     case GetPrototypeOf: {
3268         AbstractValue&amp; value = forNode(node-&gt;child1());
3269         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
3270             bool canFold = !value.m_structure.isClear();
3271             JSValue prototype;
3272             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3273                 auto getPrototypeMethod = structure-&gt;classInfo()-&gt;methodTable.getPrototype;
3274                 MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
3275                 if (getPrototypeMethod != defaultGetPrototype) {
3276                     canFold = false;
3277                     return;
3278                 }
3279 
3280                 if (structure-&gt;hasPolyProto()) {
3281                     canFold = false;
3282                     return;
3283                 }
3284                 if (!prototype)
3285                     prototype = structure-&gt;storedPrototype();
3286                 else if (prototype != structure-&gt;storedPrototype())
3287                     canFold = false;
3288             });
3289 
3290             if (prototype &amp;&amp; canFold) {
3291                 switch (node-&gt;child1().useKind()) {
3292                 case ArrayUse:
3293                 case FunctionUse:
3294                 case FinalObjectUse:
3295                     break;
3296                 default:
3297                     didFoldClobberWorld();
3298                     break;
3299                 }
3300                 setConstant(node, *m_graph.freeze(prototype));
3301                 break;
3302             }
3303         }
3304 
3305         switch (node-&gt;child1().useKind()) {
3306         case ArrayUse:
3307         case FunctionUse:
3308         case FinalObjectUse:
3309             break;
3310         default:
3311             clobberWorld();
3312             break;
3313         }
3314         setTypeForNode(node, SpecObject | SpecOther);
3315         break;
3316     }
3317 
3318     case GetByOffset: {
3319         StorageAccessData&amp; data = node-&gt;storageAccessData();
3320 
3321         // FIXME: The part of this that handles inferred property types relies on AI knowing the structure
3322         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3323         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3324         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3325         // on the type that ByteCodeParser was able to prove.
3326         AbstractValue value = m_graph.inferredValueForProperty(
3327             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3328 
3329         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3330         // because the compilation was already invalidated.
3331         if (value.isClear())
3332             m_state.setIsValid(false);
3333 
3334         setForNode(node, value);
3335         if (value.m_value)
3336             m_state.setFoundConstants(true);
3337         break;
3338     }
3339 
3340     case GetGetterSetterByOffset: {
3341         StorageAccessData&amp; data = node-&gt;storageAccessData();
<a name="52" id="anc52"></a><span class="line-modified">3342         AbstractValue base = forNode(node-&gt;child2());</span>
<span class="line-added">3343         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);</span>
3344         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3345             setConstant(node, *m_graph.freeze(result));
3346             break;
3347         }
3348 
<a name="53" id="anc53"></a><span class="line-modified">3349         if (base.value() &amp;&amp; base.value().isObject()) {</span>
<span class="line-added">3350             setForNode(node, asObject(base.value())-&gt;globalObject()-&gt;getterSetterStructure());</span>
<span class="line-added">3351             break;</span>
<span class="line-added">3352         }</span>
<span class="line-added">3353 </span>
<span class="line-added">3354         setTypeForNode(node, SpecObjectOther);</span>
3355         break;
3356     }
3357 
3358     case MultiGetByOffset: {
3359         // This code will filter the base value in a manner that is possibly different (either more
3360         // or less precise) than the way it would be filtered if this was strength-reduced to a
3361         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3362         // different things about the code, so long as all of them are sound. That even includes
3363         // one guy proving that code should never execute (due to a contradiction) and another guy
3364         // not finding that contradiction. If someone ever proved that there would be a
3365         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3366         // realize it. This is the case here.
3367 
3368         // Ordinarily you have to be careful with calling setFoundConstants()
3369         // because of the effect on compile times, but this node is FTL-only.
3370         m_state.setFoundConstants(true);
3371 
3372         AbstractValue base = forNode(node-&gt;child1());
3373         RegisteredStructureSet baseSet;
3374         AbstractValue result;
3375         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
3376             RegisteredStructureSet set = getCase.set();
3377             set.filter(base);
3378             if (set.isEmpty())
3379                 continue;
3380             baseSet.merge(set);
3381 
3382             switch (getCase.method().kind()) {
3383             case GetByOffsetMethod::Constant: {
3384                 AbstractValue thisResult;
3385                 thisResult.set(
3386                     m_graph,
3387                     *getCase.method().constant(),
3388                     m_state.structureClobberState());
3389                 result.merge(thisResult);
3390                 break;
3391             }
3392 
3393             default: {
3394                 result.makeHeapTop();
3395                 break;
3396             } }
3397         }
3398 
3399         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3400             m_state.setIsValid(false);
3401 
3402         setForNode(node, result);
3403         break;
3404     }
3405 
3406     case PutByOffset: {
3407         break;
3408     }
3409 
3410     case MultiPutByOffset: {
3411         RegisteredStructureSet newSet;
3412         TransitionVector transitions;
3413 
3414         // Ordinarily you have to be careful with calling setFoundConstants()
3415         // because of the effect on compile times, but this node is FTL-only.
3416         m_state.setFoundConstants(true);
3417 
3418         AbstractValue base = forNode(node-&gt;child1());
3419         AbstractValue originalValue = forNode(node-&gt;child2());
3420         AbstractValue resultingValue;
3421 
3422         if (node-&gt;multiPutByOffsetData().writesStructures())
3423             didFoldClobberStructures();
3424 
3425         for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
3426             const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
3427             RegisteredStructureSet thisSet = *m_graph.addStructureSet(variant.oldStructure());
3428             thisSet.filter(base);
3429             if (thisSet.isEmpty())
3430                 continue;
3431 
3432             AbstractValue thisValue = originalValue;
3433             resultingValue.merge(thisValue);
3434 
3435             if (variant.kind() == PutByIdVariant::Transition) {
3436                 RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3437                 if (thisSet.onlyStructure() != newStructure) {
3438                     transitions.append(
3439                         Transition(m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3440                 } // else this is really a replace.
3441                 newSet.add(newStructure);
3442             } else {
3443                 ASSERT(variant.kind() == PutByIdVariant::Replace);
3444                 newSet.merge(thisSet);
3445             }
3446         }
3447 
3448         // We need to order AI executing these effects in the same order as they&#39;re executed
3449         // at runtime. This is critical when you have JS code like `o.f = o;`. We first
3450         // filter types on o, then transition o. Not the other way around. If we got
3451         // this ordering wrong, we could end up with the wrong type representing o.
3452         setForNode(node-&gt;child2(), resultingValue);
3453         if (!!originalValue &amp;&amp; !resultingValue)
3454             m_state.setIsValid(false);
3455 
3456         observeTransitions(clobberLimit, transitions);
3457         if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3458             m_state.setIsValid(false);
3459         break;
3460     }
3461 
3462     case GetExecutable: {
3463         JSValue value = forNode(node-&gt;child1()).value();
3464         if (value) {
3465             JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
3466             if (function) {
3467                 setConstant(node, *m_graph.freeze(function-&gt;executable()));
3468                 break;
3469             }
3470         }
3471         setTypeForNode(node, SpecCellOther);
3472         break;
3473     }
3474 
3475     case CheckCell: {
3476         JSValue value = forNode(node-&gt;child1()).value();
3477         if (value == node-&gt;cellOperand()-&gt;value()) {
3478             m_state.setFoundConstants(true);
3479             ASSERT(value);
3480             break;
3481         }
3482         filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
3483         break;
3484     }
3485 
3486     case AssertNotEmpty:
3487     case CheckNotEmpty: {
3488         AbstractValue&amp; value = forNode(node-&gt;child1());
3489         if (!(value.m_type &amp; SpecEmpty)) {
3490             m_state.setFoundConstants(true);
3491             break;
3492         }
3493 
3494         filter(value, ~SpecEmpty);
3495         break;
3496     }
3497 
3498     case CheckStringIdent: {
3499         AbstractValue&amp; value = forNode(node-&gt;child1());
3500         UniquedStringImpl* uid = node-&gt;uidOperand();
3501         ASSERT(!(value.m_type &amp; ~SpecStringIdent)); // Edge filtering should have already ensured this.
3502 
3503         JSValue childConstant = value.value();
3504         if (childConstant) {
3505             ASSERT(childConstant.isString());
3506             if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {
3507                 m_state.setFoundConstants(true);
3508                 break;
3509             }
3510         }
3511 
3512         filter(value, SpecStringIdent);
3513         break;
3514     }
3515 
3516     case CheckInBounds: {
3517         JSValue left = forNode(node-&gt;child1()).value();
3518         JSValue right = forNode(node-&gt;child2()).value();
3519         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
3520             m_state.setFoundConstants(true);
3521 
3522         // We claim we result in Int32. It&#39;s not really important what our result is (though we
3523         // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
3524         // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
3525         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
3526         // thing to do here. We pick NodeResultJS because it makes converting this to an identity
3527         // easier.
3528         setNonCellTypeForNode(node, SpecInt32Only);
3529         break;
3530     }
3531 
3532     case PutById:
3533     case PutByIdFlush:
3534     case PutByIdDirect: {
3535         AbstractValue&amp; value = forNode(node-&gt;child1());
3536         if (value.m_structure.isFinite()) {
3537             PutByIdStatus status = PutByIdStatus::computeFor(
3538                 m_graph.globalObjectFor(node-&gt;origin.semantic),
3539                 value.m_structure.toStructureSet(),
3540                 m_graph.identifiers()[node-&gt;identifierNumber()],
3541                 node-&gt;op() == PutByIdDirect);
3542 
3543             if (status.isSimple()) {
3544                 RegisteredStructureSet newSet;
3545                 TransitionVector transitions;
3546 
3547                 for (unsigned i = status.numVariants(); i--;) {
3548                     const PutByIdVariant&amp; variant = status[i];
3549                     if (variant.kind() == PutByIdVariant::Transition) {
3550                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3551                         transitions.append(
3552                             Transition(
3553                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3554                         newSet.add(newStructure);
3555                     } else {
3556                         ASSERT(variant.kind() == PutByIdVariant::Replace);
3557                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
3558                     }
3559                 }
3560 
3561                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
3562                     m_state.setFoundConstants(true);
3563 
3564                 didFoldClobberWorld();
3565                 observeTransitions(clobberLimit, transitions);
3566                 if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3567                     m_state.setIsValid(false);
3568                 break;
3569             }
3570         }
3571 
3572         clobberWorld();
3573         break;
3574     }
3575 
3576     case PutByValWithThis:
3577     case PutByIdWithThis:
3578         clobberWorld();
3579         break;
3580 
3581     case PutGetterById:
3582     case PutSetterById:
3583     case PutGetterSetterById:
3584     case PutGetterByVal:
3585     case PutSetterByVal: {
3586         clobberWorld();
3587         break;
3588     }
3589 
3590     case DefineDataProperty:
3591     case DefineAccessorProperty:
3592         clobberWorld();
3593         break;
3594 
3595     case InById: {
3596         // FIXME: We can determine when the property definitely exists based on abstract
3597         // value information.
3598         clobberWorld();
3599         filter(node-&gt;child1(), SpecObject);
3600         setNonCellTypeForNode(node, SpecBoolean);
3601         break;
3602     }
3603 
3604     case InByVal: {
3605         AbstractValue&amp; property = forNode(node-&gt;child2());
3606         if (JSValue constant = property.value()) {
3607             if (constant.isString()) {
3608                 JSString* string = asString(constant);
3609                 const StringImpl* impl = string-&gt;tryGetValueImpl();
<a name="54" id="anc54"></a><span class="line-modified">3610                 if (impl &amp;&amp; impl-&gt;isAtom())</span>
3611                     m_state.setFoundConstants(true);
3612             }
3613         }
3614 
3615         // FIXME: We can determine when the property definitely exists based on abstract
3616         // value information.
3617         clobberWorld();
3618         filter(node-&gt;child1(), SpecObject);
3619         setNonCellTypeForNode(node, SpecBoolean);
3620         break;
3621     }
3622 
3623     case HasOwnProperty: {
3624         clobberWorld();
3625         setNonCellTypeForNode(node, SpecBoolean);
3626         break;
3627     }
3628 
3629     case GetEnumerableLength: {
3630         setNonCellTypeForNode(node, SpecInt32Only);
3631         break;
3632     }
3633     case HasGenericProperty: {
3634         setNonCellTypeForNode(node, SpecBoolean);
3635         clobberWorld();
3636         break;
3637     }
3638     case HasStructureProperty: {
3639         setNonCellTypeForNode(node, SpecBoolean);
3640         clobberWorld();
3641         break;
3642     }
3643     case HasIndexedProperty: {
3644         ArrayMode mode = node-&gt;arrayMode();
3645         switch (mode.type()) {
3646         case Array::Int32:
3647         case Array::Double:
3648         case Array::Contiguous:
3649         case Array::ArrayStorage: {
3650             break;
3651         }
3652         default: {
3653             clobberWorld();
3654             break;
3655         }
3656         }
3657         setNonCellTypeForNode(node, SpecBoolean);
3658         break;
3659     }
3660     case GetDirectPname: {
3661         clobberWorld();
3662         makeHeapTopForNode(node);
3663         break;
3664     }
3665     case GetPropertyEnumerator: {
3666         setTypeForNode(node, SpecCell);
3667         clobberWorld();
3668         break;
3669     }
3670     case GetEnumeratorStructurePname: {
3671         setTypeForNode(node, SpecString | SpecOther);
3672         break;
3673     }
3674     case GetEnumeratorGenericPname: {
3675         setTypeForNode(node, SpecString | SpecOther);
3676         break;
3677     }
3678     case ToIndexString: {
3679         setTypeForNode(node, SpecString);
3680         break;
3681     }
3682 
3683     case GetGlobalVar:
3684         makeHeapTopForNode(node);
3685         break;
3686 
3687     case GetGlobalLexicalVariable:
3688         makeBytecodeTopForNode(node);
3689         break;
3690 
3691     case GetDynamicVar:
3692         clobberWorld();
3693         makeBytecodeTopForNode(node);
3694         break;
3695 
3696     case PutDynamicVar:
3697         clobberWorld();
3698         break;
3699 
3700     case ResolveScope:
3701         clobberWorld();
3702         setTypeForNode(node, SpecObject);
3703         break;
3704 
3705     case ResolveScopeForHoistingFuncDeclInEval:
3706         clobberWorld();
3707         makeBytecodeTopForNode(node);
3708         break;
3709 
3710     case PutGlobalVariable:
3711     case NotifyWrite:
3712         break;
3713 
3714     case OverridesHasInstance:
3715         setNonCellTypeForNode(node, SpecBoolean);
3716         break;
3717 
3718     case InstanceOf:
3719         clobberWorld();
3720         setNonCellTypeForNode(node, SpecBoolean);
3721         break;
3722 
3723     case InstanceOfCustom:
3724         clobberWorld();
3725         setNonCellTypeForNode(node, SpecBoolean);
3726         break;
3727 
3728     case MatchStructure: {
3729         AbstractValue base = forNode(node-&gt;child1());
3730         RegisteredStructureSet baseSet;
3731 
3732         BooleanLattice result = BooleanLattice::Bottom;
3733         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
3734             RegisteredStructure structure = variant.structure;
3735             if (!base.contains(structure)) {
3736                 m_state.setFoundConstants(true);
3737                 continue;
3738             }
3739 
3740             baseSet.add(structure);
3741             result = leastUpperBoundOfBooleanLattices(
3742                 result, variant.result ? BooleanLattice::True : BooleanLattice::False);
3743         }
3744 
3745         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3746             m_state.setIsValid(false);
3747 
3748         switch (result) {
3749         case BooleanLattice::False:
3750             setConstant(node, jsBoolean(false));
3751             break;
3752         case BooleanLattice::True:
3753             setConstant(node, jsBoolean(true));
3754             break;
3755         default:
3756             setNonCellTypeForNode(node, SpecBoolean);
3757             break;
3758         }
3759         break;
3760     }
3761 
3762     case Phi:
3763         RELEASE_ASSERT(m_graph.m_form == SSA);
3764         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
3765         // The state of this node would have already been decided, but it may have become a
3766         // constant, in which case we&#39;d like to know.
3767         if (forNode(node).m_value)
3768             m_state.setFoundConstants(true);
3769         break;
3770 
3771     case Upsilon: {
3772         NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
3773         if (shadow.isStillValid()) {
3774             m_state.createValueForNode(shadow);
3775             setForNode(shadow, forNode(node-&gt;child1()));
3776         }
3777         break;
3778     }
3779 
3780     case Flush:
3781     case PhantomLocal:
3782         break;
3783 
3784     case Call:
3785     case TailCallInlinedCaller:
3786     case Construct:
3787     case CallVarargs:
3788     case CallForwardVarargs:
3789     case TailCallVarargsInlinedCaller:
3790     case ConstructVarargs:
3791     case ConstructForwardVarargs:
3792     case TailCallForwardVarargsInlinedCaller:
3793     case CallEval:
3794     case DirectCall:
3795     case DirectConstruct:
3796     case DirectTailCallInlinedCaller:
3797         clobberWorld();
3798         makeHeapTopForNode(node);
3799         break;
3800 
3801     case ForceOSRExit:
3802     case CheckBadCell:
3803         m_state.setIsValid(false);
3804         break;
3805 
3806     case InvalidationPoint:
3807         m_state.setStructureClobberState(StructuresAreWatched);
3808         m_state.observeInvalidationPoint();
3809         break;
3810 
3811     case CPUIntrinsic:
3812         if (node-&gt;intrinsic() == CPURdtscIntrinsic)
3813             setNonCellTypeForNode(node, SpecInt32Only);
3814         else
3815             setNonCellTypeForNode(node, SpecOther);
3816         break;
3817 
3818     case CheckTraps:
3819     case LogShadowChickenPrologue:
3820     case LogShadowChickenTail:
3821     case ProfileType:
3822     case ProfileControlFlow:
3823     case Phantom:
3824     case CountExecution:
3825     case CheckTierUpInLoop:
3826     case CheckTierUpAtReturn:
3827     case SuperSamplerBegin:
3828     case SuperSamplerEnd:
3829     case CheckTierUpAndOSREnter:
3830     case LoopHint:
3831     case ZombieHint:
3832     case ExitOK:
3833     case FilterCallLinkStatus:
3834     case FilterGetByIdStatus:
3835     case FilterPutByIdStatus:
3836     case FilterInByIdStatus:
3837     case ClearCatchLocals:
3838         break;
3839 
3840     case CheckTypeInfoFlags: {
3841         const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
3842         unsigned bits = node-&gt;typeInfoOperand();
3843         ASSERT(bits);
3844         if (bits == ImplementsDefaultHasInstance) {
3845             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
3846                 m_state.setFoundConstants(true);
3847                 break;
3848             }
3849         }
3850 
3851         if (JSValue value = abstractValue.value()) {
3852             if (value.isCell()) {
3853                 // This works because if we see a cell here, we know it&#39;s fully constructed
3854                 // and we can read its inline type info flags. These flags don&#39;t change over the
3855                 // object&#39;s lifetime.
3856                 if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
3857                     m_state.setFoundConstants(true);
3858                     break;
3859                 }
3860             }
3861         }
3862 
3863         if (abstractValue.m_structure.isFinite()) {
3864             bool ok = true;
3865             abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3866                 ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
3867             });
3868             if (ok) {
3869                 m_state.setFoundConstants(true);
3870                 break;
3871             }
3872         }
3873 
3874         break;
3875     }
3876 
3877     case ParseInt: {
3878         AbstractValue value = forNode(node-&gt;child1());
3879         if (value.m_type &amp;&amp; !(value.m_type &amp; ~SpecInt32Only)) {
3880             JSValue radix;
3881             if (!node-&gt;child2())
3882                 radix = jsNumber(0);
3883             else
3884                 radix = forNode(node-&gt;child2()).m_value;
3885 
3886             if (radix.isNumber()
3887                 &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
3888                 m_state.setFoundConstants(true);
3889                 if (node-&gt;child1().useKind() == UntypedUse)
3890                     didFoldClobberWorld();
3891                 setNonCellTypeForNode(node, SpecInt32Only);
3892                 break;
3893             }
3894         }
3895 
3896         if (node-&gt;child1().useKind() == UntypedUse)
3897             clobberWorld();
3898         setNonCellTypeForNode(node, SpecBytecodeNumber);
3899         break;
3900     }
3901 
3902     case CreateRest:
3903         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
3904             // This means we&#39;re already having a bad time.
3905             clobberWorld();
3906             setTypeForNode(node, SpecArray);
3907             break;
3908         }
3909         setForNode(node,
3910             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure());
3911         break;
3912 
3913     case CheckVarargs:
3914     case Check: {
3915         // Simplify out checks that don&#39;t actually do checking.
3916         m_graph.doToChildren(node, [&amp;] (Edge edge) {
3917             if (!edge)
3918                 return;
3919             if (edge.isProved() || edge.willNotHaveCheck())
3920                 m_state.setFoundConstants(true);
3921         });
3922         break;
3923     }
3924 
3925     case SetFunctionName: {
3926         clobberWorld();
3927         break;
3928     }
3929 
3930     case StoreBarrier:
3931     case FencedStoreBarrier: {
3932         filter(node-&gt;child1(), SpecCell);
3933         break;
3934     }
3935 
3936     case DataViewGetInt: {
3937         DataViewData data = node-&gt;dataViewData();
3938         if (data.byteSize &lt; 4)
3939             setNonCellTypeForNode(node, SpecInt32Only);
3940         else {
3941             ASSERT(data.byteSize == 4);
3942             if (data.isSigned)
3943                 setNonCellTypeForNode(node, SpecInt32Only);
3944             else
<a name="55" id="anc55"></a><span class="line-modified">3945                 setNonCellTypeForNode(node, SpecInt52Any);</span>
3946         }
3947         break;
3948     }
3949 
3950     case DataViewGetFloat: {
3951         setNonCellTypeForNode(node, SpecFullDouble);
3952         break;
3953     }
3954 
3955     case DataViewSet: {
3956         break;
3957     }
3958 
3959     case Unreachable:
3960         // It may be that during a previous run of AI we proved that something was unreachable, but
3961         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
3962         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
3963         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
3964         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
3965         m_state.setIsValid(false);
3966         break;
3967 
3968     case LastNodeType:
3969     case ArithIMul:
3970     case FiatInt52:
3971         DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
3972         break;
3973     }
3974 
3975     return m_state.isValid();
3976 }
3977 
3978 template&lt;typename AbstractStateType&gt;
3979 void AbstractInterpreter&lt;AbstractStateType&gt;::filterICStatus(Node* node)
3980 {
3981     switch (node-&gt;op()) {
3982     case FilterCallLinkStatus:
3983         if (JSValue value = forNode(node-&gt;child1()).m_value)
3984             node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
3985         break;
3986 
3987     case FilterGetByIdStatus: {
3988         AbstractValue&amp; value = forNode(node-&gt;child1());
3989         if (value.m_structure.isFinite())
3990             node-&gt;getByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3991         break;
3992     }
3993 
3994     case FilterInByIdStatus: {
3995         AbstractValue&amp; value = forNode(node-&gt;child1());
3996         if (value.m_structure.isFinite())
3997             node-&gt;inByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3998         break;
3999     }
4000 
4001     case FilterPutByIdStatus: {
4002         AbstractValue&amp; value = forNode(node-&gt;child1());
4003         if (value.m_structure.isFinite())
4004             node-&gt;putByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4005         break;
4006     }
4007 
4008     default:
4009         RELEASE_ASSERT_NOT_REACHED();
4010         break;
4011     }
4012 }
4013 
4014 template&lt;typename AbstractStateType&gt;
4015 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned indexInBlock)
4016 {
4017     return executeEffects(indexInBlock, m_state.block()-&gt;at(indexInBlock));
4018 }
4019 
4020 template&lt;typename AbstractStateType&gt;
4021 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(unsigned indexInBlock)
4022 {
4023     Node* node = m_state.block()-&gt;at(indexInBlock);
4024 
4025     startExecuting();
4026     executeEdges(node);
4027     return executeEffects(indexInBlock, node);
4028 }
4029 
4030 template&lt;typename AbstractStateType&gt;
4031 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(Node* node)
4032 {
4033     startExecuting();
4034     executeEdges(node);
4035     return executeEffects(UINT_MAX, node);
4036 }
4037 
4038 template&lt;typename AbstractStateType&gt;
4039 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberWorld()
4040 {
4041     clobberStructures();
4042 }
4043 
4044 template&lt;typename AbstractStateType&gt;
4045 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberWorld()
4046 {
4047     didFoldClobberStructures();
4048 }
4049 
4050 template&lt;typename AbstractStateType&gt;
4051 template&lt;typename Functor&gt;
4052 void AbstractInterpreter&lt;AbstractStateType&gt;::forAllValues(
4053     unsigned clobberLimit, Functor&amp; functor)
4054 {
4055     if (clobberLimit &gt;= m_state.block()-&gt;size())
4056         clobberLimit = m_state.block()-&gt;size();
4057     else
4058         clobberLimit++;
4059     ASSERT(clobberLimit &lt;= m_state.block()-&gt;size());
4060     for (size_t i = clobberLimit; i--;) {
4061         NodeFlowProjection::forEach(
4062             m_state.block()-&gt;at(i),
4063             [&amp;] (NodeFlowProjection nodeProjection) {
4064                 functor(forNode(nodeProjection));
4065             });
4066     }
4067     if (m_graph.m_form == SSA) {
4068         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4069             if (node.isStillValid())
4070                 functor(forNode(node));
4071         }
4072     }
4073     for (size_t i = m_state.numberOfArguments(); i--;)
4074         functor(m_state.argument(i));
4075     for (size_t i = m_state.numberOfLocals(); i--;)
4076         functor(m_state.local(i));
4077 }
4078 
4079 template&lt;typename AbstractStateType&gt;
4080 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberStructures()
4081 {
4082     m_state.clobberStructures();
4083     m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
4084     m_state.setStructureClobberState(StructuresAreClobbered);
4085 }
4086 
4087 template&lt;typename AbstractStateType&gt;
4088 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberStructures()
4089 {
4090     m_state.mergeClobberState(AbstractInterpreterClobberState::FoldedClobber);
4091 }
4092 
4093 template&lt;typename AbstractStateType&gt;
4094 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
4095     unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
4096 {
<a name="56" id="anc56"></a><span class="line-added">4097     // Stop performing precise structure transition tracking.</span>
<span class="line-added">4098     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="line-added">4099     // If it is too large, we conservatively clobber all the structures.</span>
<span class="line-added">4100     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="line-added">4101         clobberStructures();</span>
<span class="line-added">4102         return;</span>
<span class="line-added">4103     }</span>
<span class="line-added">4104 </span>
4105     AbstractValue::TransitionObserver transitionObserver(from, to);
4106     forAllValues(clobberLimit, transitionObserver);
4107 
4108     ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
4109 
4110     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4111 }
4112 
4113 template&lt;typename AbstractStateType&gt;
4114 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4115     unsigned clobberLimit, const TransitionVector&amp; vector)
4116 {
4117     if (vector.isEmpty())
4118         return;
4119 
<a name="57" id="anc57"></a><span class="line-added">4120     // Stop performing precise structure transition tracking.</span>
<span class="line-added">4121     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.</span>
<span class="line-added">4122     // If it is too large, we conservatively clobber all the structures.</span>
<span class="line-added">4123     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {</span>
<span class="line-added">4124         clobberStructures();</span>
<span class="line-added">4125         return;</span>
<span class="line-added">4126     }</span>
<span class="line-added">4127 </span>
4128     AbstractValue::TransitionsObserver transitionsObserver(vector);
4129     forAllValues(clobberLimit, transitionsObserver);
4130 
4131     if (!ASSERT_DISABLED) {
4132         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4133         for (unsigned i = vector.size(); i--;)
4134             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4135     }
4136 
4137     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4138 }
4139 
4140 template&lt;typename AbstractStateType&gt;
4141 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4142 {
4143     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4144 }
4145 
4146 template&lt;typename AbstractStateType&gt;
4147 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
4148 {
4149     CommaPrinter comma(&quot; &quot;);
4150     HashSet&lt;NodeFlowProjection&gt; seen;
4151     if (m_graph.m_form == SSA) {
4152         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4153             seen.add(node);
4154             AbstractValue&amp; value = forNode(node);
4155             if (value.isClear())
4156                 continue;
4157             out.print(comma, node, &quot;:&quot;, value);
4158         }
4159     }
4160     for (size_t i = 0; i &lt; m_state.block()-&gt;size(); ++i) {
4161         NodeFlowProjection::forEach(
4162             m_state.block()-&gt;at(i), [&amp;] (NodeFlowProjection nodeProjection) {
4163                 seen.add(nodeProjection);
4164                 AbstractValue&amp; value = forNode(nodeProjection);
4165                 if (value.isClear())
4166                     return;
4167                 out.print(comma, nodeProjection, &quot;:&quot;, value);
4168             });
4169     }
4170     if (m_graph.m_form == SSA) {
4171         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtTail) {
4172             if (seen.contains(node))
4173                 continue;
4174             AbstractValue&amp; value = forNode(node);
4175             if (value.isClear())
4176                 continue;
4177             out.print(comma, node, &quot;:&quot;, value);
4178         }
4179     }
4180 }
4181 
4182 template&lt;typename AbstractStateType&gt;
4183 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4184     AbstractValue&amp; value, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes)
4185 {
4186     if (value.filter(m_graph, set, admittedTypes) == FiltrationOK)
4187         return FiltrationOK;
4188     m_state.setIsValid(false);
4189     return Contradiction;
4190 }
4191 
4192 template&lt;typename AbstractStateType&gt;
4193 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
4194     AbstractValue&amp; value, ArrayModes arrayModes)
4195 {
4196     if (value.filterArrayModes(arrayModes) == FiltrationOK)
4197         return FiltrationOK;
4198     m_state.setIsValid(false);
4199     return Contradiction;
4200 }
4201 
4202 template&lt;typename AbstractStateType&gt;
4203 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4204     AbstractValue&amp; value, SpeculatedType type)
4205 {
4206     if (value.filter(type) == FiltrationOK)
4207         return FiltrationOK;
4208     m_state.setIsValid(false);
4209     return Contradiction;
4210 }
4211 
4212 template&lt;typename AbstractStateType&gt;
4213 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterByValue(
4214     AbstractValue&amp; abstractValue, FrozenValue concreteValue)
4215 {
4216     if (abstractValue.filterByValue(concreteValue) == FiltrationOK)
4217         return FiltrationOK;
4218     m_state.setIsValid(false);
4219     return Contradiction;
4220 }
4221 
4222 template&lt;typename AbstractStateType&gt;
4223 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterClassInfo(
4224     AbstractValue&amp; value, const ClassInfo* classInfo)
4225 {
4226     if (value.filterClassInfo(m_graph, classInfo) == FiltrationOK)
4227         return FiltrationOK;
4228     m_state.setIsValid(false);
4229     return Contradiction;
4230 }
4231 
4232 template&lt;typename AbstractStateType&gt;
4233 void AbstractInterpreter&lt;AbstractStateType&gt;::executeDoubleUnaryOpEffects(Node* node, double(*equivalentFunction)(double))
4234 {
4235     JSValue child = forNode(node-&gt;child1()).value();
4236     if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
4237         if (node-&gt;child1().useKind() != DoubleRepUse)
4238             didFoldClobberWorld();
4239         setConstant(node, jsDoubleNumber(equivalentFunction(*number)));
4240         return;
4241     }
4242     SpeculatedType type;
4243     if (node-&gt;child1().useKind() == DoubleRepUse)
4244         type = typeOfDoubleUnaryOp(forNode(node-&gt;child1()).m_type);
4245     else {
4246         clobberWorld();
4247         type = SpecBytecodeNumber;
4248     }
4249     setNonCellTypeForNode(node, type);
4250 }
4251 
4252 } } // namespace JSC::DFG
4253 
4254 #endif // ENABLE(DFG_JIT)
<a name="58" id="anc58"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="58" type="hidden" />
</body>
</html>