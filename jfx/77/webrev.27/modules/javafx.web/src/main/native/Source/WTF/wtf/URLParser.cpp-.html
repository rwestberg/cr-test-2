<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &lt;wtf/URLParser.h&gt;
  28 
  29 #include &lt;array&gt;
  30 #include &lt;mutex&gt;
  31 #include &lt;unicode/uidna.h&gt;
  32 #include &lt;unicode/utf8.h&gt;
  33 #include &lt;unicode/utypes.h&gt;
  34 
  35 namespace WTF {
  36 
  37 #define URL_PARSER_DEBUGGING 0
  38 
  39 #if URL_PARSER_DEBUGGING
  40 #define URL_PARSER_LOG(...) WTFLogAlways(__VA_ARGS__)
  41 #else
  42 #define URL_PARSER_LOG(...)
  43 #endif
  44 
  45 template&lt;typename CharacterType&gt;
  46 class CodePointIterator {
  47 public:
  48     ALWAYS_INLINE CodePointIterator() { }
  49     ALWAYS_INLINE CodePointIterator(const CharacterType* begin, const CharacterType* end)
  50         : m_begin(begin)
  51         , m_end(end)
  52     {
  53     }
  54 
  55     ALWAYS_INLINE CodePointIterator(const CodePointIterator&amp; begin, const CodePointIterator&amp; end)
  56         : CodePointIterator(begin.m_begin, end.m_begin)
  57     {
  58         ASSERT(end.m_begin &gt;= begin.m_begin);
  59     }
  60 
  61     ALWAYS_INLINE UChar32 operator*() const;
  62     ALWAYS_INLINE CodePointIterator&amp; operator++();
  63 
  64     ALWAYS_INLINE bool operator==(const CodePointIterator&amp; other) const
  65     {
  66         return m_begin == other.m_begin
  67             &amp;&amp; m_end == other.m_end;
  68     }
  69     ALWAYS_INLINE bool operator!=(const CodePointIterator&amp; other) const { return !(*this == other); }
  70 
  71     ALWAYS_INLINE CodePointIterator&amp; operator=(const CodePointIterator&amp; other)
  72     {
  73         m_begin = other.m_begin;
  74         m_end = other.m_end;
  75         return *this;
  76     }
  77 
  78     ALWAYS_INLINE bool atEnd() const
  79     {
  80         ASSERT(m_begin &lt;= m_end);
  81         return m_begin &gt;= m_end;
  82     }
  83 
  84     ALWAYS_INLINE size_t codeUnitsSince(const CharacterType* reference) const
  85     {
  86         ASSERT(m_begin &gt;= reference);
  87         return m_begin - reference;
  88     }
  89 
  90     ALWAYS_INLINE size_t codeUnitsSince(const CodePointIterator&amp; other) const
  91     {
  92         return codeUnitsSince(other.m_begin);
  93     }
  94 
  95 private:
  96     const CharacterType* m_begin { nullptr };
  97     const CharacterType* m_end { nullptr };
  98 };
  99 
 100 template&lt;&gt;
 101 ALWAYS_INLINE UChar32 CodePointIterator&lt;LChar&gt;::operator*() const
 102 {
 103     ASSERT(!atEnd());
 104     return *m_begin;
 105 }
 106 
 107 template&lt;&gt;
 108 ALWAYS_INLINE auto CodePointIterator&lt;LChar&gt;::operator++() -&gt; CodePointIterator&amp;
 109 {
 110     m_begin++;
 111     return *this;
 112 }
 113 
 114 template&lt;&gt;
 115 ALWAYS_INLINE UChar32 CodePointIterator&lt;UChar&gt;::operator*() const
 116 {
 117     ASSERT(!atEnd());
 118     UChar32 c;
 119     U16_GET(m_begin, 0, 0, m_end - m_begin, c);
 120     return c;
 121 }
 122 
 123 template&lt;&gt;
 124 ALWAYS_INLINE auto CodePointIterator&lt;UChar&gt;::operator++() -&gt; CodePointIterator&amp;
 125 {
 126     unsigned i = 0;
 127     size_t length = m_end - m_begin;
 128     U16_FWD_1(m_begin, i, length);
 129     m_begin += i;
 130     return *this;
 131 }
 132 
 133 ALWAYS_INLINE static void appendCodePoint(Vector&lt;UChar&gt;&amp; destination, UChar32 codePoint)
 134 {
 135     if (U_IS_BMP(codePoint)) {
 136         destination.append(static_cast&lt;UChar&gt;(codePoint));
 137         return;
 138     }
 139     destination.reserveCapacity(destination.size() + 2);
 140     destination.uncheckedAppend(U16_LEAD(codePoint));
 141     destination.uncheckedAppend(U16_TRAIL(codePoint));
 142 }
 143 
 144 enum URLCharacterClass {
 145     UserInfo = 0x1,
 146     Default = 0x2,
 147     ForbiddenHost = 0x4,
 148     QueryPercent = 0x8,
 149     SlashQuestionOrHash = 0x10,
 150     ValidScheme = 0x20,
 151 };
 152 
 153 static const uint8_t characterClassTable[256] = {
 154     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x0
 155     UserInfo | Default | QueryPercent, // 0x1
 156     UserInfo | Default | QueryPercent, // 0x2
 157     UserInfo | Default | QueryPercent, // 0x3
 158     UserInfo | Default | QueryPercent, // 0x4
 159     UserInfo | Default | QueryPercent, // 0x5
 160     UserInfo | Default | QueryPercent, // 0x6
 161     UserInfo | Default | QueryPercent, // 0x7
 162     UserInfo | Default | QueryPercent, // 0x8
 163     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x9
 164     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xA
 165     UserInfo | Default | QueryPercent, // 0xB
 166     UserInfo | Default | QueryPercent, // 0xC
 167     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xD
 168     UserInfo | Default | QueryPercent, // 0xE
 169     UserInfo | Default | QueryPercent, // 0xF
 170     UserInfo | Default | QueryPercent, // 0x10
 171     UserInfo | Default | QueryPercent, // 0x11
 172     UserInfo | Default | QueryPercent, // 0x12
 173     UserInfo | Default | QueryPercent, // 0x13
 174     UserInfo | Default | QueryPercent, // 0x14
 175     UserInfo | Default | QueryPercent, // 0x15
 176     UserInfo | Default | QueryPercent, // 0x16
 177     UserInfo | Default | QueryPercent, // 0x17
 178     UserInfo | Default | QueryPercent, // 0x18
 179     UserInfo | Default | QueryPercent, // 0x19
 180     UserInfo | Default | QueryPercent, // 0x1A
 181     UserInfo | Default | QueryPercent, // 0x1B
 182     UserInfo | Default | QueryPercent, // 0x1C
 183     UserInfo | Default | QueryPercent, // 0x1D
 184     UserInfo | Default | QueryPercent, // 0x1E
 185     UserInfo | Default | QueryPercent, // 0x1F
 186     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39; &#39;
 187     0, // &#39;!&#39;
 188     UserInfo | Default | QueryPercent, // &#39;&quot;&#39;
 189     UserInfo | Default | QueryPercent | SlashQuestionOrHash | ForbiddenHost, // &#39;#&#39;
 190     0, // &#39;$&#39;
 191     ForbiddenHost, // &#39;%&#39;
 192     0, // &#39;&amp;&#39;
 193     0, // &#39;\&#39;&#39;
 194     0, // &#39;(&#39;
 195     0, // &#39;)&#39;
 196     0, // &#39;*&#39;
 197     ValidScheme, // &#39;+&#39;
 198     0, // &#39;,&#39;
 199     ValidScheme, // &#39;-&#39;
 200     ValidScheme, // &#39;.&#39;
 201     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;/&#39;
 202     ValidScheme, // &#39;0&#39;
 203     ValidScheme, // &#39;1&#39;
 204     ValidScheme, // &#39;2&#39;
 205     ValidScheme, // &#39;3&#39;
 206     ValidScheme, // &#39;4&#39;
 207     ValidScheme, // &#39;5&#39;
 208     ValidScheme, // &#39;6&#39;
 209     ValidScheme, // &#39;7&#39;
 210     ValidScheme, // &#39;8&#39;
 211     ValidScheme, // &#39;9&#39;
 212     UserInfo | ForbiddenHost, // &#39;:&#39;
 213     UserInfo, // &#39;;&#39;
 214     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&lt;&#39;
 215     UserInfo, // &#39;=&#39;
 216     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&gt;&#39;
 217     UserInfo | Default | SlashQuestionOrHash | ForbiddenHost, // &#39;?&#39;
 218     UserInfo | ForbiddenHost, // &#39;@&#39;
 219     ValidScheme, // &#39;A&#39;
 220     ValidScheme, // &#39;B&#39;
 221     ValidScheme, // &#39;C&#39;
 222     ValidScheme, // &#39;D&#39;
 223     ValidScheme, // &#39;E&#39;
 224     ValidScheme, // &#39;F&#39;
 225     ValidScheme, // &#39;G&#39;
 226     ValidScheme, // &#39;H&#39;
 227     ValidScheme, // &#39;I&#39;
 228     ValidScheme, // &#39;J&#39;
 229     ValidScheme, // &#39;K&#39;
 230     ValidScheme, // &#39;L&#39;
 231     ValidScheme, // &#39;M&#39;
 232     ValidScheme, // &#39;N&#39;
 233     ValidScheme, // &#39;O&#39;
 234     ValidScheme, // &#39;P&#39;
 235     ValidScheme, // &#39;Q&#39;
 236     ValidScheme, // &#39;R&#39;
 237     ValidScheme, // &#39;S&#39;
 238     ValidScheme, // &#39;T&#39;
 239     ValidScheme, // &#39;U&#39;
 240     ValidScheme, // &#39;V&#39;
 241     ValidScheme, // &#39;W&#39;
 242     ValidScheme, // &#39;X&#39;
 243     ValidScheme, // &#39;Y&#39;
 244     ValidScheme, // &#39;Z&#39;
 245     UserInfo | ForbiddenHost, // &#39;[&#39;
 246     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;\\&#39;
 247     UserInfo | ForbiddenHost, // &#39;]&#39;
 248     UserInfo, // &#39;^&#39;
 249     0, // &#39;_&#39;
 250     UserInfo | Default, // &#39;`&#39;
 251     ValidScheme, // &#39;a&#39;
 252     ValidScheme, // &#39;b&#39;
 253     ValidScheme, // &#39;c&#39;
 254     ValidScheme, // &#39;d&#39;
 255     ValidScheme, // &#39;e&#39;
 256     ValidScheme, // &#39;f&#39;
 257     ValidScheme, // &#39;g&#39;
 258     ValidScheme, // &#39;h&#39;
 259     ValidScheme, // &#39;i&#39;
 260     ValidScheme, // &#39;j&#39;
 261     ValidScheme, // &#39;k&#39;
 262     ValidScheme, // &#39;l&#39;
 263     ValidScheme, // &#39;m&#39;
 264     ValidScheme, // &#39;n&#39;
 265     ValidScheme, // &#39;o&#39;
 266     ValidScheme, // &#39;p&#39;
 267     ValidScheme, // &#39;q&#39;
 268     ValidScheme, // &#39;r&#39;
 269     ValidScheme, // &#39;s&#39;
 270     ValidScheme, // &#39;t&#39;
 271     ValidScheme, // &#39;u&#39;
 272     ValidScheme, // &#39;v&#39;
 273     ValidScheme, // &#39;w&#39;
 274     ValidScheme, // &#39;x&#39;
 275     ValidScheme, // &#39;y&#39;
 276     ValidScheme, // &#39;z&#39;
 277     UserInfo | Default, // &#39;{&#39;
 278     UserInfo, // &#39;|&#39;
 279     UserInfo | Default, // &#39;}&#39;
 280     0, // &#39;~&#39;
 281     QueryPercent, // 0x7F
 282     QueryPercent, // 0x80
 283     QueryPercent, // 0x81
 284     QueryPercent, // 0x82
 285     QueryPercent, // 0x83
 286     QueryPercent, // 0x84
 287     QueryPercent, // 0x85
 288     QueryPercent, // 0x86
 289     QueryPercent, // 0x87
 290     QueryPercent, // 0x88
 291     QueryPercent, // 0x89
 292     QueryPercent, // 0x8A
 293     QueryPercent, // 0x8B
 294     QueryPercent, // 0x8C
 295     QueryPercent, // 0x8D
 296     QueryPercent, // 0x8E
 297     QueryPercent, // 0x8F
 298     QueryPercent, // 0x90
 299     QueryPercent, // 0x91
 300     QueryPercent, // 0x92
 301     QueryPercent, // 0x93
 302     QueryPercent, // 0x94
 303     QueryPercent, // 0x95
 304     QueryPercent, // 0x96
 305     QueryPercent, // 0x97
 306     QueryPercent, // 0x98
 307     QueryPercent, // 0x99
 308     QueryPercent, // 0x9A
 309     QueryPercent, // 0x9B
 310     QueryPercent, // 0x9C
 311     QueryPercent, // 0x9D
 312     QueryPercent, // 0x9E
 313     QueryPercent, // 0x9F
 314     QueryPercent, // 0xA0
 315     QueryPercent, // 0xA1
 316     QueryPercent, // 0xA2
 317     QueryPercent, // 0xA3
 318     QueryPercent, // 0xA4
 319     QueryPercent, // 0xA5
 320     QueryPercent, // 0xA6
 321     QueryPercent, // 0xA7
 322     QueryPercent, // 0xA8
 323     QueryPercent, // 0xA9
 324     QueryPercent, // 0xAA
 325     QueryPercent, // 0xAB
 326     QueryPercent, // 0xAC
 327     QueryPercent, // 0xAD
 328     QueryPercent, // 0xAE
 329     QueryPercent, // 0xAF
 330     QueryPercent, // 0xB0
 331     QueryPercent, // 0xB1
 332     QueryPercent, // 0xB2
 333     QueryPercent, // 0xB3
 334     QueryPercent, // 0xB4
 335     QueryPercent, // 0xB5
 336     QueryPercent, // 0xB6
 337     QueryPercent, // 0xB7
 338     QueryPercent, // 0xB8
 339     QueryPercent, // 0xB9
 340     QueryPercent, // 0xBA
 341     QueryPercent, // 0xBB
 342     QueryPercent, // 0xBC
 343     QueryPercent, // 0xBD
 344     QueryPercent, // 0xBE
 345     QueryPercent, // 0xBF
 346     QueryPercent, // 0xC0
 347     QueryPercent, // 0xC1
 348     QueryPercent, // 0xC2
 349     QueryPercent, // 0xC3
 350     QueryPercent, // 0xC4
 351     QueryPercent, // 0xC5
 352     QueryPercent, // 0xC6
 353     QueryPercent, // 0xC7
 354     QueryPercent, // 0xC8
 355     QueryPercent, // 0xC9
 356     QueryPercent, // 0xCA
 357     QueryPercent, // 0xCB
 358     QueryPercent, // 0xCC
 359     QueryPercent, // 0xCD
 360     QueryPercent, // 0xCE
 361     QueryPercent, // 0xCF
 362     QueryPercent, // 0xD0
 363     QueryPercent, // 0xD1
 364     QueryPercent, // 0xD2
 365     QueryPercent, // 0xD3
 366     QueryPercent, // 0xD4
 367     QueryPercent, // 0xD5
 368     QueryPercent, // 0xD6
 369     QueryPercent, // 0xD7
 370     QueryPercent, // 0xD8
 371     QueryPercent, // 0xD9
 372     QueryPercent, // 0xDA
 373     QueryPercent, // 0xDB
 374     QueryPercent, // 0xDC
 375     QueryPercent, // 0xDD
 376     QueryPercent, // 0xDE
 377     QueryPercent, // 0xDF
 378     QueryPercent, // 0xE0
 379     QueryPercent, // 0xE1
 380     QueryPercent, // 0xE2
 381     QueryPercent, // 0xE3
 382     QueryPercent, // 0xE4
 383     QueryPercent, // 0xE5
 384     QueryPercent, // 0xE6
 385     QueryPercent, // 0xE7
 386     QueryPercent, // 0xE8
 387     QueryPercent, // 0xE9
 388     QueryPercent, // 0xEA
 389     QueryPercent, // 0xEB
 390     QueryPercent, // 0xEC
 391     QueryPercent, // 0xED
 392     QueryPercent, // 0xEE
 393     QueryPercent, // 0xEF
 394     QueryPercent, // 0xF0
 395     QueryPercent, // 0xF1
 396     QueryPercent, // 0xF2
 397     QueryPercent, // 0xF3
 398     QueryPercent, // 0xF4
 399     QueryPercent, // 0xF5
 400     QueryPercent, // 0xF6
 401     QueryPercent, // 0xF7
 402     QueryPercent, // 0xF8
 403     QueryPercent, // 0xF9
 404     QueryPercent, // 0xFA
 405     QueryPercent, // 0xFB
 406     QueryPercent, // 0xFC
 407     QueryPercent, // 0xFD
 408     QueryPercent, // 0xFE
 409     QueryPercent, // 0xFF
 410 };
 411 
 412 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0Control(CharacterType character) { return character &lt;= 0x1F; }
 413 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0ControlOrSpace(CharacterType character) { return character &lt;= 0x20; }
 414 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isTabOrNewline(CharacterType character) { return character &lt;= 0xD &amp;&amp; character &gt;= 0x9 &amp;&amp; character != 0xB &amp;&amp; character != 0xC; }
 415 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInSimpleEncodeSet(CharacterType character) { return character &gt; 0x7E || isC0Control(character); }
 416 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInDefaultEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; Default; }
 417 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInUserInfoEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; UserInfo; }
 418 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isPercentOrNonASCII(CharacterType character) { return !isASCII(character) || character == &#39;%&#39;; }
 419 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isSlashQuestionOrHash(CharacterType character) { return character &lt;= &#39;\\&#39; &amp;&amp; characterClassTable[character] &amp; SlashQuestionOrHash; }
 420 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isValidSchemeCharacter(CharacterType character) { return character &lt;= &#39;z&#39; &amp;&amp; characterClassTable[character] &amp; ValidScheme; }
 421 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isForbiddenHostCodePoint(CharacterType character) { return character &lt;= &#39;]&#39; &amp;&amp; characterClassTable[character] &amp; ForbiddenHost; }
 422 ALWAYS_INLINE static bool shouldPercentEncodeQueryByte(uint8_t byte, const bool&amp; urlIsSpecial)
 423 {
 424     if (characterClassTable[byte] &amp; QueryPercent)
 425         return true;
 426     if (byte == &#39;\&#39;&#39; &amp;&amp; urlIsSpecial)
 427         return true;
 428     return false;
 429 }
 430 
 431 bool URLParser::isInUserInfoEncodeSet(UChar c)
 432 {
 433     return WTF::isInUserInfoEncodeSet(c);
 434 }
 435 
 436 template&lt;typename CharacterType, URLParser::ReportSyntaxViolation reportSyntaxViolation&gt;
 437 ALWAYS_INLINE void URLParser::advance(CodePointIterator&lt;CharacterType&gt;&amp; iterator, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
 438 {
 439     ++iterator;
 440     while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
 441         if (reportSyntaxViolation == ReportSyntaxViolation::Yes)
 442             syntaxViolation(iteratorForSyntaxViolationPosition);
 443         ++iterator;
 444     }
 445 }
 446 
 447 template&lt;typename CharacterType&gt;
 448 bool URLParser::takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt; iterator)
 449 {
 450     if (iterator.atEnd())
 451         return false;
 452     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 453     if (iterator.atEnd())
 454         return false;
 455     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 456     return iterator.atEnd();
 457 }
 458 
 459 template&lt;typename CharacterType&gt;
 460 ALWAYS_INLINE bool URLParser::isWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt; iterator)
 461 {
 462     if (iterator.atEnd() || !isASCIIAlpha(*iterator))
 463         return false;
 464     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 465     if (iterator.atEnd())
 466         return false;
 467     if (*iterator == &#39;:&#39;)
 468         return true;
 469     if (UNLIKELY(*iterator == &#39;|&#39;))
 470         return true;
 471     return false;
 472 }
 473 
 474 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(UChar32 codePoint)
 475 {
 476     ASSERT(isASCII(codePoint));
 477     if (UNLIKELY(m_didSeeSyntaxViolation))
 478         m_asciiBuffer.append(codePoint);
 479 }
 480 
 481 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(const char* characters, size_t length)
 482 {
 483     if (UNLIKELY(m_didSeeSyntaxViolation))
 484         m_asciiBuffer.append(characters, length);
 485 }
 486 
 487 template&lt;typename CharacterType&gt;
 488 void URLParser::appendWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 489 {
 490     ASSERT(isWindowsDriveLetter(iterator));
 491     appendToASCIIBuffer(*iterator);
 492     advance(iterator);
 493     ASSERT(!iterator.atEnd());
 494     ASSERT(*iterator == &#39;:&#39; || *iterator == &#39;|&#39;);
 495     if (*iterator == &#39;|&#39;)
 496         syntaxViolation(iterator);
 497     appendToASCIIBuffer(&#39;:&#39;);
 498     advance(iterator);
 499 }
 500 
 501 bool URLParser::copyBaseWindowsDriveLetter(const URL&amp; base)
 502 {
 503     if (base.protocolIs(&quot;file&quot;)) {
 504         RELEASE_ASSERT(base.m_hostEnd + base.m_portLength &lt; base.m_string.length());
 505         if (base.m_string.is8Bit()) {
 506             const LChar* begin = base.m_string.characters8();
 507             CodePointIterator&lt;LChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 508             if (isWindowsDriveLetter(c)) {
 509                 appendWindowsDriveLetter(c);
 510                 return true;
 511             }
 512         } else {
 513             const UChar* begin = base.m_string.characters16();
 514             CodePointIterator&lt;UChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 515             if (isWindowsDriveLetter(c)) {
 516                 appendWindowsDriveLetter(c);
 517                 return true;
 518             }
 519         }
 520     }
 521     return false;
 522 }
 523 
 524 template&lt;typename CharacterType&gt;
 525 bool URLParser::shouldCopyFileURL(CodePointIterator&lt;CharacterType&gt; iterator)
 526 {
 527     if (!isWindowsDriveLetter(iterator))
 528         return true;
 529     if (iterator.atEnd())
 530         return false;
 531     advance(iterator);
 532     if (iterator.atEnd())
 533         return true;
 534     advance(iterator);
 535     if (iterator.atEnd())
 536         return true;
 537     return !isSlashQuestionOrHash(*iterator);
 538 }
 539 
 540 static void percentEncodeByte(uint8_t byte, Vector&lt;LChar&gt;&amp; buffer)
 541 {
 542     buffer.append(&#39;%&#39;);
 543     buffer.append(upperNibbleToASCIIHexDigit(byte));
 544     buffer.append(lowerNibbleToASCIIHexDigit(byte));
 545 }
 546 
 547 void URLParser::percentEncodeByte(uint8_t byte)
 548 {
 549     ASSERT(m_didSeeSyntaxViolation);
 550     appendToASCIIBuffer(&#39;%&#39;);
 551     appendToASCIIBuffer(upperNibbleToASCIIHexDigit(byte));
 552     appendToASCIIBuffer(lowerNibbleToASCIIHexDigit(byte));
 553 }
 554 
 555 const char replacementCharacterUTF8PercentEncoded[10] = &quot;%EF%BF%BD&quot;;
 556 const size_t replacementCharacterUTF8PercentEncodedLength = sizeof(replacementCharacterUTF8PercentEncoded) - 1;
 557 
 558 template&lt;bool(*isInCodeSet)(UChar32), typename CharacterType&gt;
 559 ALWAYS_INLINE void URLParser::utf8PercentEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 560 {
 561     ASSERT(!iterator.atEnd());
 562     UChar32 codePoint = *iterator;
 563     if (LIKELY(isASCII(codePoint))) {
 564         if (UNLIKELY(isInCodeSet(codePoint))) {
 565             syntaxViolation(iterator);
 566             percentEncodeByte(codePoint);
 567         } else
 568             appendToASCIIBuffer(codePoint);
 569         return;
 570     }
 571     ASSERT_WITH_MESSAGE(isInCodeSet(codePoint), &quot;isInCodeSet should always return true for non-ASCII characters&quot;);
 572     syntaxViolation(iterator);
 573 
 574     if (!U_IS_UNICODE_CHAR(codePoint)) {
 575         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 576         return;
 577     }
 578 
 579     uint8_t buffer[U8_MAX_LENGTH];
 580     int32_t offset = 0;
 581     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 582     for (int32_t i = 0; i &lt; offset; ++i)
 583         percentEncodeByte(buffer[i]);
 584 }
 585 
 586 template&lt;typename CharacterType&gt;
 587 ALWAYS_INLINE void URLParser::utf8QueryEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 588 {
 589     ASSERT(!iterator.atEnd());
 590     UChar32 codePoint = *iterator;
 591     if (LIKELY(isASCII(codePoint))) {
 592         if (UNLIKELY(shouldPercentEncodeQueryByte(codePoint, m_urlIsSpecial))) {
 593             syntaxViolation(iterator);
 594             percentEncodeByte(codePoint);
 595         } else
 596             appendToASCIIBuffer(codePoint);
 597         return;
 598     }
 599 
 600     syntaxViolation(iterator);
 601 
 602     if (!U_IS_UNICODE_CHAR(codePoint)) {
 603         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 604         return;
 605     }
 606 
 607     uint8_t buffer[U8_MAX_LENGTH];
 608     int32_t offset = 0;
 609     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 610     for (int32_t i = 0; i &lt; offset; ++i) {
 611         auto byte = buffer[i];
 612         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 613             percentEncodeByte(byte);
 614         else
 615             appendToASCIIBuffer(byte);
 616     }
 617 }
 618 
 619 template&lt;typename CharacterType&gt;
 620 void URLParser::encodeNonUTF8Query(const Vector&lt;UChar&gt;&amp; source, const URLTextEncoding&amp; encoding, CodePointIterator&lt;CharacterType&gt; iterator)
 621 {
 622     auto encoded = encoding.encodeForURLParsing(StringView(source.data(), source.size()));
 623     auto* data = encoded.data();
 624     size_t length = encoded.size();
 625 
 626     if (!length == !iterator.atEnd()) {
 627         syntaxViolation(iterator);
 628         return;
 629     }
 630 
 631     size_t i = 0;
 632     for (; i &lt; length; ++i) {
 633         ASSERT(!iterator.atEnd());
 634         uint8_t byte = data[i];
 635         if (UNLIKELY(byte != *iterator)) {
 636             syntaxViolation(iterator);
 637             break;
 638         }
 639         if (UNLIKELY(shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))) {
 640             syntaxViolation(iterator);
 641             break;
 642         }
 643         appendToASCIIBuffer(byte);
 644         ++iterator;
 645     }
 646     while (!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))
 647         ++iterator;
 648     ASSERT((i == length) == iterator.atEnd());
 649     for (; i &lt; length; ++i) {
 650         ASSERT(m_didSeeSyntaxViolation);
 651         uint8_t byte = data[i];
 652         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 653             percentEncodeByte(byte);
 654         else
 655             appendToASCIIBuffer(byte);
 656     }
 657 }
 658 
 659 Optional&lt;uint16_t&gt; URLParser::defaultPortForProtocol(StringView scheme)
 660 {
 661     static const uint16_t ftpPort = 21;
 662     static const uint16_t gopherPort = 70;
 663     static const uint16_t httpPort = 80;
 664     static const uint16_t httpsPort = 443;
 665     static const uint16_t wsPort = 80;
 666     static const uint16_t wssPort = 443;
 667 
 668     auto length = scheme.length();
 669     if (!length)
 670         return WTF::nullopt;
 671     switch (scheme[0]) {
 672     case &#39;w&#39;:
 673         switch (length) {
 674         case 2:
 675             if (scheme[1] == &#39;s&#39;)
 676                 return wsPort;
 677             return WTF::nullopt;
 678         case 3:
 679             if (scheme[1] == &#39;s&#39;
 680                 &amp;&amp; scheme[2] == &#39;s&#39;)
 681                 return wssPort;
 682             return WTF::nullopt;
 683         default:
 684             return false;
 685         }
 686     case &#39;h&#39;:
 687         switch (length) {
 688         case 4:
 689             if (scheme[1] == &#39;t&#39;
 690                 &amp;&amp; scheme[2] == &#39;t&#39;
 691                 &amp;&amp; scheme[3] == &#39;p&#39;)
 692                 return httpPort;
 693             return WTF::nullopt;
 694         case 5:
 695             if (scheme[1] == &#39;t&#39;
 696                 &amp;&amp; scheme[2] == &#39;t&#39;
 697                 &amp;&amp; scheme[3] == &#39;p&#39;
 698                 &amp;&amp; scheme[4] == &#39;s&#39;)
 699                 return httpsPort;
 700             return WTF::nullopt;
 701         default:
 702             return WTF::nullopt;
 703         }
 704     case &#39;g&#39;:
 705         if (length == 6
 706             &amp;&amp; scheme[1] == &#39;o&#39;
 707             &amp;&amp; scheme[2] == &#39;p&#39;
 708             &amp;&amp; scheme[3] == &#39;h&#39;
 709             &amp;&amp; scheme[4] == &#39;e&#39;
 710             &amp;&amp; scheme[5] == &#39;r&#39;)
 711             return gopherPort;
 712         return WTF::nullopt;
 713     case &#39;f&#39;:
 714         if (length == 3
 715             &amp;&amp; scheme[1] == &#39;t&#39;
 716             &amp;&amp; scheme[2] == &#39;p&#39;)
 717             return ftpPort;
 718         return WTF::nullopt;
 719     default:
 720         return WTF::nullopt;
 721     }
 722 }
 723 
 724 enum class Scheme {
 725 #if PLATFORM(JAVA)
 726     JAR,
 727 #endif
 728     WS,
 729     WSS,
 730     File,
 731     FTP,
 732     Gopher,
 733     HTTP,
 734     HTTPS,
 735     NonSpecial
 736 };
 737 
 738 ALWAYS_INLINE static Scheme scheme(StringView scheme)
 739 {
 740     auto length = scheme.length();
 741     if (!length)
 742         return Scheme::NonSpecial;
 743     switch (scheme[0]) {
 744     case &#39;f&#39;:
 745         switch (length) {
 746         case 3:
 747             if (scheme[1] == &#39;t&#39;
 748                 &amp;&amp; scheme[2] == &#39;p&#39;)
 749                 return Scheme::FTP;
 750             return Scheme::NonSpecial;
 751         case 4:
 752             if (scheme[1] == &#39;i&#39;
 753                 &amp;&amp; scheme[2] == &#39;l&#39;
 754                 &amp;&amp; scheme[3] == &#39;e&#39;)
 755                 return Scheme::File;
 756             return Scheme::NonSpecial;
 757         default:
 758             return Scheme::NonSpecial;
 759         }
 760     case &#39;g&#39;:
 761         if (length == 6
 762             &amp;&amp; scheme[1] == &#39;o&#39;
 763             &amp;&amp; scheme[2] == &#39;p&#39;
 764             &amp;&amp; scheme[3] == &#39;h&#39;
 765             &amp;&amp; scheme[4] == &#39;e&#39;
 766             &amp;&amp; scheme[5] == &#39;r&#39;)
 767             return Scheme::Gopher;
 768         return Scheme::NonSpecial;
 769     case &#39;h&#39;:
 770         switch (length) {
 771         case 4:
 772             if (scheme[1] == &#39;t&#39;
 773                 &amp;&amp; scheme[2] == &#39;t&#39;
 774                 &amp;&amp; scheme[3] == &#39;p&#39;)
 775                 return Scheme::HTTP;
 776             return Scheme::NonSpecial;
 777         case 5:
 778             if (scheme[1] == &#39;t&#39;
 779                 &amp;&amp; scheme[2] == &#39;t&#39;
 780                 &amp;&amp; scheme[3] == &#39;p&#39;
 781                 &amp;&amp; scheme[4] == &#39;s&#39;)
 782                 return Scheme::HTTPS;
 783             return Scheme::NonSpecial;
 784         default:
 785             return Scheme::NonSpecial;
 786         }
 787     case &#39;w&#39;:
 788         switch (length) {
 789         case 2:
 790             if (scheme[1] == &#39;s&#39;)
 791                 return Scheme::WS;
 792             return Scheme::NonSpecial;
 793         case 3:
 794             if (scheme[1] == &#39;s&#39;
 795                 &amp;&amp; scheme[2] == &#39;s&#39;)
 796                 return Scheme::WSS;
 797             return Scheme::NonSpecial;
 798         default:
 799             return Scheme::NonSpecial;
 800         }
 801 #if PLATFORM(JAVA)
 802      case &#39;j&#39;:
 803         if (length == 3 &amp;&amp; scheme[1] == &#39;a&#39; &amp;&amp; scheme[2] == &#39;r&#39;)
 804             return Scheme::JAR;
 805         return Scheme::NonSpecial;
 806 #endif
 807     default:
 808         return Scheme::NonSpecial;
 809     }
 810 }
 811 
 812 Optional&lt;String&gt; URLParser::maybeCanonicalizeScheme(const String&amp; scheme)
 813 {
 814     if (scheme.isEmpty())
 815         return WTF::nullopt;
 816 
 817     if (!isASCIIAlpha(scheme[0]))
 818         return WTF::nullopt;
 819 
 820     for (size_t i = 1; i &lt; scheme.length(); ++i) {
 821         if (isASCIIAlphanumeric(scheme[i]) || scheme[i] == &#39;+&#39; || scheme[i] == &#39;-&#39; || scheme[i] == &#39;.&#39;)
 822             continue;
 823         return WTF::nullopt;
 824     }
 825 
 826     return scheme.convertToASCIILowercase();
 827 }
 828 
 829 bool URLParser::isSpecialScheme(const String&amp; schemeArg)
 830 {
 831     return scheme(schemeArg) != Scheme::NonSpecial;
 832 }
 833 
 834 enum class URLParser::URLPart {
 835     SchemeEnd,
 836     UserStart,
 837     UserEnd,
 838     PasswordEnd,
 839     HostEnd,
 840     PortEnd,
 841     PathAfterLastSlash,
 842     PathEnd,
 843     QueryEnd,
 844 };
 845 
 846 size_t URLParser::urlLengthUntilPart(const URL&amp; url, URLPart part)
 847 {
 848     switch (part) {
 849     case URLPart::QueryEnd:
 850         return url.m_queryEnd;
 851     case URLPart::PathEnd:
 852         return url.m_pathEnd;
 853     case URLPart::PathAfterLastSlash:
 854         return url.m_pathAfterLastSlash;
 855     case URLPart::PortEnd:
 856         return url.m_hostEnd + url.m_portLength;
 857     case URLPart::HostEnd:
 858         return url.m_hostEnd;
 859     case URLPart::PasswordEnd:
 860         return url.m_passwordEnd;
 861     case URLPart::UserEnd:
 862         return url.m_userEnd;
 863     case URLPart::UserStart:
 864         return url.m_userStart;
 865     case URLPart::SchemeEnd:
 866         return url.m_schemeEnd;
 867     }
 868     ASSERT_NOT_REACHED();
 869     return 0;
 870 }
 871 
 872 void URLParser::copyASCIIStringUntil(const String&amp; string, size_t length)
 873 {
 874     RELEASE_ASSERT(length &lt;= string.length());
 875     if (string.isNull())
 876         return;
 877     ASSERT(m_asciiBuffer.isEmpty());
 878     if (string.is8Bit())
 879         appendToASCIIBuffer(string.characters8(), length);
 880     else {
 881         const UChar* characters = string.characters16();
 882         for (size_t i = 0; i &lt; length; ++i) {
 883             UChar c = characters[i];
 884             ASSERT_WITH_SECURITY_IMPLICATION(isASCII(c));
 885             appendToASCIIBuffer(c);
 886         }
 887     }
 888 }
 889 
 890 template&lt;typename CharacterType&gt;
 891 void URLParser::copyURLPartsUntil(const URL&amp; base, URLPart part, const CodePointIterator&lt;CharacterType&gt;&amp; iterator, const URLTextEncoding*&amp; nonUTF8QueryEncoding)
 892 {
 893     syntaxViolation(iterator);
 894 
 895     m_asciiBuffer.clear();
 896     copyASCIIStringUntil(base.m_string, urlLengthUntilPart(base, part));
 897     switch (part) {
 898     case URLPart::QueryEnd:
 899         m_url.m_queryEnd = base.m_queryEnd;
 900         FALLTHROUGH;
 901     case URLPart::PathEnd:
 902         m_url.m_pathEnd = base.m_pathEnd;
 903         FALLTHROUGH;
 904     case URLPart::PathAfterLastSlash:
 905         m_url.m_pathAfterLastSlash = base.m_pathAfterLastSlash;
 906         FALLTHROUGH;
 907     case URLPart::PortEnd:
 908         m_url.m_portLength = base.m_portLength;
 909         FALLTHROUGH;
 910     case URLPart::HostEnd:
 911         m_url.m_hostEnd = base.m_hostEnd;
 912         FALLTHROUGH;
 913     case URLPart::PasswordEnd:
 914         m_url.m_passwordEnd = base.m_passwordEnd;
 915         FALLTHROUGH;
 916     case URLPart::UserEnd:
 917         m_url.m_userEnd = base.m_userEnd;
 918         FALLTHROUGH;
 919     case URLPart::UserStart:
 920         m_url.m_userStart = base.m_userStart;
 921         FALLTHROUGH;
 922     case URLPart::SchemeEnd:
 923         m_url.m_isValid = base.m_isValid;
 924         m_url.m_protocolIsInHTTPFamily = base.m_protocolIsInHTTPFamily;
 925         m_url.m_schemeEnd = base.m_schemeEnd;
 926     }
 927     switch (scheme(StringView(m_asciiBuffer.data(), m_url.m_schemeEnd))) {
 928 #if PLATFORM(JAVA)
 929     case Scheme::JAR:
 930         break;
 931 #endif
 932     case Scheme::WS:
 933     case Scheme::WSS:
 934         nonUTF8QueryEncoding = nullptr;
 935         m_urlIsSpecial = true;
 936         return;
 937     case Scheme::File:
 938         m_urlIsFile = true;
 939         FALLTHROUGH;
 940     case Scheme::FTP:
 941     case Scheme::Gopher:
 942     case Scheme::HTTP:
 943     case Scheme::HTTPS:
 944         m_urlIsSpecial = true;
 945         return;
 946     case Scheme::NonSpecial:
 947         m_urlIsSpecial = false;
 948         nonUTF8QueryEncoding = nullptr;
 949         return;
 950     }
 951     ASSERT_NOT_REACHED();
 952 }
 953 
 954 static const char dotASCIICode[2] = {&#39;2&#39;, &#39;e&#39;};
 955 
 956 template&lt;typename CharacterType&gt;
 957 ALWAYS_INLINE bool URLParser::isSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 958 {
 959     if (c.atEnd())
 960         return false;
 961     if (*c == &#39;.&#39;) {
 962         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 963         return c.atEnd() || isSlashQuestionOrHash(*c);
 964     }
 965     if (*c != &#39;%&#39;)
 966         return false;
 967     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 968     if (c.atEnd() || *c != dotASCIICode[0])
 969         return false;
 970     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 971     if (c.atEnd())
 972         return false;
 973     if (toASCIILower(*c) == dotASCIICode[1]) {
 974         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 975         return c.atEnd() || isSlashQuestionOrHash(*c);
 976     }
 977     return false;
 978 }
 979 
 980 template&lt;typename CharacterType&gt;
 981 ALWAYS_INLINE bool URLParser::isDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 982 {
 983     if (c.atEnd())
 984         return false;
 985     if (*c == &#39;.&#39;) {
 986         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 987         return isSingleDotPathSegment(c);
 988     }
 989     if (*c != &#39;%&#39;)
 990         return false;
 991     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 992     if (c.atEnd() || *c != dotASCIICode[0])
 993         return false;
 994     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 995     if (c.atEnd())
 996         return false;
 997     if (toASCIILower(*c) == dotASCIICode[1]) {
 998         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 999         return isSingleDotPathSegment(c);
1000     }
1001     return false;
1002 }
1003 
1004 template&lt;typename CharacterType&gt;
1005 void URLParser::consumeSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
1006 {
1007     ASSERT(isSingleDotPathSegment(c));
1008     if (*c == &#39;.&#39;) {
1009         advance(c);
1010         if (!c.atEnd()) {
1011             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
1012                 advance(c);
1013             else
1014                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
1015         }
1016     } else {
1017         ASSERT(*c == &#39;%&#39;);
1018         advance(c);
1019         ASSERT(*c == dotASCIICode[0]);
1020         advance(c);
1021         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
1022         advance(c);
1023         if (!c.atEnd()) {
1024             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
1025                 advance(c);
1026             else
1027                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
1028         }
1029     }
1030 }
1031 
1032 template&lt;typename CharacterType&gt;
1033 void URLParser::consumeDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
1034 {
1035     ASSERT(isDoubleDotPathSegment(c));
1036     if (*c == &#39;.&#39;)
1037         advance(c);
1038     else {
1039         ASSERT(*c == &#39;%&#39;);
1040         advance(c);
1041         ASSERT(*c == dotASCIICode[0]);
1042         advance(c);
1043         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
1044         advance(c);
1045     }
1046     consumeSingleDotPathSegment(c);
1047 }
1048 
1049 bool URLParser::shouldPopPath(unsigned newPathAfterLastSlash)
1050 {
1051     ASSERT(m_didSeeSyntaxViolation);
1052     if (!m_urlIsFile)
1053         return true;
1054 
1055     ASSERT(m_url.m_pathAfterLastSlash &lt;= m_asciiBuffer.size());
1056     CodePointIterator&lt;LChar&gt; componentToPop(&amp;m_asciiBuffer[newPathAfterLastSlash], &amp;m_asciiBuffer[0] + m_url.m_pathAfterLastSlash);
1057     if (newPathAfterLastSlash == m_url.m_hostEnd + m_url.m_portLength + 1 &amp;&amp; isWindowsDriveLetter(componentToPop))
1058         return false;
1059     return true;
1060 }
1061 
1062 void URLParser::popPath()
1063 {
1064     ASSERT(m_didSeeSyntaxViolation);
1065     if (m_url.m_pathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength + 1) {
1066         auto newPathAfterLastSlash = m_url.m_pathAfterLastSlash - 1;
1067         if (m_asciiBuffer[newPathAfterLastSlash] == &#39;/&#39;)
1068             newPathAfterLastSlash--;
1069         while (newPathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength &amp;&amp; m_asciiBuffer[newPathAfterLastSlash] != &#39;/&#39;)
1070             newPathAfterLastSlash--;
1071         newPathAfterLastSlash++;
1072         if (shouldPopPath(newPathAfterLastSlash))
1073             m_url.m_pathAfterLastSlash = newPathAfterLastSlash;
1074     }
1075     m_asciiBuffer.resize(m_url.m_pathAfterLastSlash);
1076 }
1077 
1078 template&lt;typename CharacterType&gt;
1079 void URLParser::syntaxViolation(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1080 {
1081     if (m_didSeeSyntaxViolation)
1082         return;
1083     m_didSeeSyntaxViolation = true;
1084 
1085     ASSERT(m_asciiBuffer.isEmpty());
1086     size_t codeUnitsToCopy = iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1087     RELEASE_ASSERT(codeUnitsToCopy &lt;= m_inputString.length());
1088     m_asciiBuffer.reserveCapacity(m_inputString.length());
1089     for (size_t i = 0; i &lt; codeUnitsToCopy; ++i) {
1090         ASSERT(isASCII(m_inputString[i]));
1091         m_asciiBuffer.uncheckedAppend(m_inputString[i]);
1092     }
1093 }
1094 
1095 void URLParser::failure()
1096 {
1097     m_url.invalidate();
1098     m_url.m_string = m_inputString;
1099 }
1100 
1101 template&lt;typename CharacterType&gt;
1102 bool URLParser::checkLocalhostCodePoint(CodePointIterator&lt;CharacterType&gt;&amp; iterator, UChar32 codePoint)
1103 {
1104     if (iterator.atEnd() || toASCIILower(*iterator) != codePoint)
1105         return false;
1106     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
1107     return true;
1108 }
1109 
1110 template&lt;typename CharacterType&gt;
1111 bool URLParser::isAtLocalhost(CodePointIterator&lt;CharacterType&gt; iterator)
1112 {
1113     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1114         return false;
1115     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1116         return false;
1117     if (!checkLocalhostCodePoint(iterator, &#39;c&#39;))
1118         return false;
1119     if (!checkLocalhostCodePoint(iterator, &#39;a&#39;))
1120         return false;
1121     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1122         return false;
1123     if (!checkLocalhostCodePoint(iterator, &#39;h&#39;))
1124         return false;
1125     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1126         return false;
1127     if (!checkLocalhostCodePoint(iterator, &#39;s&#39;))
1128         return false;
1129     if (!checkLocalhostCodePoint(iterator, &#39;t&#39;))
1130         return false;
1131     return iterator.atEnd();
1132 }
1133 
1134 bool URLParser::isLocalhost(StringView view)
1135 {
1136     if (view.is8Bit())
1137         return isAtLocalhost(CodePointIterator&lt;LChar&gt;(view.characters8(), view.characters8() + view.length()));
1138     return isAtLocalhost(CodePointIterator&lt;UChar&gt;(view.characters16(), view.characters16() + view.length()));
1139 }
1140 
1141 ALWAYS_INLINE StringView URLParser::parsedDataView(size_t start, size_t length)
1142 {
1143     if (UNLIKELY(m_didSeeSyntaxViolation)) {
1144         ASSERT(start + length &lt;= m_asciiBuffer.size());
1145         return StringView(m_asciiBuffer.data() + start, length);
1146     }
1147     ASSERT(start + length &lt;= m_inputString.length());
1148     return StringView(m_inputString).substring(start, length);
1149 }
1150 
1151 ALWAYS_INLINE UChar URLParser::parsedDataView(size_t position)
1152 {
1153     if (UNLIKELY(m_didSeeSyntaxViolation))
1154         return m_asciiBuffer[position];
1155     return m_inputString[position];
1156 }
1157 
1158 template&lt;typename CharacterType&gt;
1159 ALWAYS_INLINE size_t URLParser::currentPosition(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1160 {
1161     if (UNLIKELY(m_didSeeSyntaxViolation))
1162         return m_asciiBuffer.size();
1163 
1164     return iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1165 }
1166 
1167 URLParser::URLParser(const String&amp; input, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1168     : m_inputString(input)
1169 {
1170     if (input.isNull()) {
1171         if (base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1172             m_url = base;
1173             m_url.removeFragmentIdentifier();
1174         }
1175         return;
1176     }
1177 
1178     if (input.is8Bit()) {
1179         m_inputBegin = input.characters8();
1180         parse(input.characters8(), input.length(), base, nonUTF8QueryEncoding);
1181     } else {
1182         m_inputBegin = input.characters16();
1183         parse(input.characters16(), input.length(), base, nonUTF8QueryEncoding);
1184     }
1185 
1186     ASSERT(!m_url.m_isValid
1187         || m_didSeeSyntaxViolation == (m_url.string() != input)
1188         || (input.isAllSpecialCharacters&lt;isC0ControlOrSpace&gt;()
1189             &amp;&amp; m_url.m_string == base.m_string.left(base.m_queryEnd)));
1190     ASSERT(internalValuesConsistent(m_url));
1191 #if !ASSERT_DISABLED
1192     if (!m_didSeeSyntaxViolation) {
1193         // Force a syntax violation at the beginning to make sure we get the same result.
1194         URLParser parser(makeString(&quot; &quot;, input), base, nonUTF8QueryEncoding);
1195         URL parsed = parser.result();
1196         if (parsed.isValid())
1197             ASSERT(allValuesEqual(parser.result(), m_url));
1198     }
1199 #endif
1200 }
1201 
1202 template&lt;typename CharacterType&gt;
1203 void URLParser::parse(const CharacterType* input, const unsigned length, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1204 {
1205     URL_PARSER_LOG(&quot;Parsing URL &lt;%s&gt; base &lt;%s&gt;&quot;, String(input, length).utf8().data(), base.string().utf8().data());
1206     m_url = { };
1207     ASSERT(m_asciiBuffer.isEmpty());
1208 
1209     Vector&lt;UChar&gt; queryBuffer;
1210 
1211     unsigned endIndex = length;
1212     while (UNLIKELY(endIndex &amp;&amp; isC0ControlOrSpace(input[endIndex - 1]))) {
1213         syntaxViolation(CodePointIterator&lt;CharacterType&gt;(input, input));
1214         endIndex--;
1215     }
1216     CodePointIterator&lt;CharacterType&gt; c(input, input + endIndex);
1217     CodePointIterator&lt;CharacterType&gt; authorityOrHostBegin;
1218     CodePointIterator&lt;CharacterType&gt; queryBegin;
1219     while (UNLIKELY(!c.atEnd() &amp;&amp; isC0ControlOrSpace(*c))) {
1220         syntaxViolation(c);
1221         ++c;
1222     }
1223     auto beginAfterControlAndSpace = c;
1224 
1225     enum class State : uint8_t {
1226         SchemeStart,
1227         Scheme,
1228         NoScheme,
1229         SpecialRelativeOrAuthority,
1230         PathOrAuthority,
1231         Relative,
1232         RelativeSlash,
1233         SpecialAuthoritySlashes,
1234         SpecialAuthorityIgnoreSlashes,
1235         AuthorityOrHost,
1236         Host,
1237         File,
1238         FileSlash,
1239         FileHost,
1240         PathStart,
1241         Path,
1242         CannotBeABaseURLPath,
1243         UTF8Query,
1244         NonUTF8Query,
1245         Fragment,
1246     };
1247 
1248 #define LOG_STATE(x) URL_PARSER_LOG(&quot;State %s, code point %c, parsed data &lt;%s&gt; size %zu&quot;, x, *c, parsedDataView(0, currentPosition(c)).utf8().data(), currentPosition(c))
1249 #define LOG_FINAL_STATE(x) URL_PARSER_LOG(&quot;Final State: %s&quot;, x)
1250 
1251     State state = State::SchemeStart;
1252     while (!c.atEnd()) {
1253         if (UNLIKELY(isTabOrNewline(*c))) {
1254             syntaxViolation(c);
1255             ++c;
1256             continue;
1257         }
1258 
1259         switch (state) {
1260         case State::SchemeStart:
1261             LOG_STATE(&quot;SchemeStart&quot;);
1262             if (isASCIIAlpha(*c)) {
1263                 if (UNLIKELY(isASCIIUpper(*c)))
1264                     syntaxViolation(c);
1265                 appendToASCIIBuffer(toASCIILower(*c));
1266                 advance(c);
1267                 if (c.atEnd()) {
1268                     m_asciiBuffer.clear();
1269                     state = State::NoScheme;
1270                     c = beginAfterControlAndSpace;
1271                     break;
1272                 }
1273                 state = State::Scheme;
1274             } else
1275                 state = State::NoScheme;
1276             break;
1277         case State::Scheme:
1278             LOG_STATE(&quot;Scheme&quot;);
1279             if (isValidSchemeCharacter(*c)) {
1280                 if (UNLIKELY(isASCIIUpper(*c)))
1281                     syntaxViolation(c);
1282                 appendToASCIIBuffer(toASCIILower(*c));
1283             } else if (*c == &#39;:&#39;) {
1284                 unsigned schemeEnd = currentPosition(c);
1285                 if (schemeEnd &gt; URL::maxSchemeLength) {
1286                     failure();
1287                     return;
1288                 }
1289                 m_url.m_schemeEnd = schemeEnd;
1290                 StringView urlScheme = parsedDataView(0, m_url.m_schemeEnd);
1291                 appendToASCIIBuffer(&#39;:&#39;);
1292                 switch (scheme(urlScheme)) {
1293 #if PLATFORM(JAVA)
1294                 // JAR can have complex protocols like &quot;jar:file&quot; or &quot;jar:http://&quot;
1295                 // Just skip the jar: part, rest will be parsed like other
1296                 // scheme.
1297                 case Scheme::JAR:
1298                     ++c;
1299                     break;
1300 #endif
1301                 case Scheme::File:
1302                     m_urlIsSpecial = true;
1303                     m_urlIsFile = true;
1304                     state = State::File;
1305                     ++c;
1306                     break;
1307                 case Scheme::WS:
1308                 case Scheme::WSS:
1309                     nonUTF8QueryEncoding = nullptr;
1310                     m_urlIsSpecial = true;
1311                     if (base.protocolIs(urlScheme))
1312                         state = State::SpecialRelativeOrAuthority;
1313                     else
1314                         state = State::SpecialAuthoritySlashes;
1315                     ++c;
1316                     break;
1317                 case Scheme::HTTP:
1318                 case Scheme::HTTPS:
1319                     m_url.m_protocolIsInHTTPFamily = true;
1320                     FALLTHROUGH;
1321                 case Scheme::FTP:
1322                 case Scheme::Gopher:
1323                     m_urlIsSpecial = true;
1324                     if (base.protocolIs(urlScheme))
1325                         state = State::SpecialRelativeOrAuthority;
1326                     else
1327                         state = State::SpecialAuthoritySlashes;
1328                     ++c;
1329                     break;
1330                 case Scheme::NonSpecial:
1331                     nonUTF8QueryEncoding = nullptr;
1332                     auto maybeSlash = c;
1333                     advance(maybeSlash);
1334                     if (!maybeSlash.atEnd() &amp;&amp; *maybeSlash == &#39;/&#39;) {
1335                         appendToASCIIBuffer(&#39;/&#39;);
1336                         c = maybeSlash;
1337                         state = State::PathOrAuthority;
1338                         ASSERT(*c == &#39;/&#39;);
1339                         ++c;
1340                         m_url.m_userStart = currentPosition(c);
1341                     } else {
1342                         ++c;
1343                         m_url.m_userStart = currentPosition(c);
1344                         m_url.m_userEnd = m_url.m_userStart;
1345                         m_url.m_passwordEnd = m_url.m_userStart;
1346                         m_url.m_hostEnd = m_url.m_userStart;
1347                         m_url.m_portLength = 0;
1348                         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1349                         m_url.m_cannotBeABaseURL = true;
1350                         state = State::CannotBeABaseURLPath;
1351                     }
1352                     break;
1353                 }
1354                 break;
1355             } else {
1356                 m_asciiBuffer.clear();
1357                 state = State::NoScheme;
1358                 c = beginAfterControlAndSpace;
1359                 break;
1360             }
1361             advance(c);
1362             if (c.atEnd()) {
1363                 m_asciiBuffer.clear();
1364                 state = State::NoScheme;
1365                 c = beginAfterControlAndSpace;
1366             }
1367             break;
1368         case State::NoScheme:
1369             LOG_STATE(&quot;NoScheme&quot;);
1370             if (!base.isValid() || (base.m_cannotBeABaseURL &amp;&amp; *c != &#39;#&#39;)) {
1371                 failure();
1372                 return;
1373             }
1374             if (base.m_cannotBeABaseURL &amp;&amp; *c == &#39;#&#39;) {
1375                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1376                 state = State::Fragment;
1377                 appendToASCIIBuffer(&#39;#&#39;);
1378                 ++c;
1379                 break;
1380             }
1381             if (!base.protocolIs(&quot;file&quot;)) {
1382                 state = State::Relative;
1383                 break;
1384             }
1385             copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1386             appendToASCIIBuffer(&#39;:&#39;);
1387             state = State::File;
1388             break;
1389         case State::SpecialRelativeOrAuthority:
1390             LOG_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1391             if (*c == &#39;/&#39;) {
1392                 appendToASCIIBuffer(&#39;/&#39;);
1393                 advance(c);
1394                 if (c.atEnd()) {
1395                     failure();
1396                     return;
1397                 }
1398                 if (*c == &#39;/&#39;) {
1399                     appendToASCIIBuffer(&#39;/&#39;);
1400                     state = State::SpecialAuthorityIgnoreSlashes;
1401                     ++c;
1402                 } else
1403                     state = State::RelativeSlash;
1404             } else
1405                 state = State::Relative;
1406             break;
1407         case State::PathOrAuthority:
1408             LOG_STATE(&quot;PathOrAuthority&quot;);
1409             if (*c == &#39;/&#39;) {
1410                 appendToASCIIBuffer(&#39;/&#39;);
1411                 state = State::AuthorityOrHost;
1412                 advance(c);
1413                 m_url.m_userStart = currentPosition(c);
1414                 authorityOrHostBegin = c;
1415             } else {
1416                 ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1417                 m_url.m_userStart = currentPosition(c) - 1;
1418                 m_url.m_userEnd = m_url.m_userStart;
1419                 m_url.m_passwordEnd = m_url.m_userStart;
1420                 m_url.m_hostEnd = m_url.m_userStart;
1421                 m_url.m_portLength = 0;
1422                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1423                 state = State::Path;
1424             }
1425             break;
1426         case State::Relative:
1427             LOG_STATE(&quot;Relative&quot;);
1428             switch (*c) {
1429             case &#39;/&#39;:
1430             case &#39;\\&#39;:
1431                 state = State::RelativeSlash;
1432                 ++c;
1433                 break;
1434             case &#39;?&#39;:
1435                 copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1436                 appendToASCIIBuffer(&#39;?&#39;);
1437                 ++c;
1438                 if (nonUTF8QueryEncoding) {
1439                     queryBegin = c;
1440                     state = State::NonUTF8Query;
1441                 } else
1442                     state = State::UTF8Query;
1443                 break;
1444             case &#39;#&#39;:
1445                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1446                 appendToASCIIBuffer(&#39;#&#39;);
1447                 state = State::Fragment;
1448                 ++c;
1449                 break;
1450             default:
1451                 copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1452                 if (currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) != &#39;/&#39;) {
1453                     appendToASCIIBuffer(&#39;/&#39;);
1454                     m_url.m_pathAfterLastSlash = currentPosition(c);
1455                 }
1456                 state = State::Path;
1457                 break;
1458             }
1459             break;
1460         case State::RelativeSlash:
1461             LOG_STATE(&quot;RelativeSlash&quot;);
1462             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1463                 ++c;
1464                 copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1465                 appendToASCIIBuffer(&quot;://&quot;, 3);
1466                 if (m_urlIsSpecial)
1467                     state = State::SpecialAuthorityIgnoreSlashes;
1468                 else {
1469                     m_url.m_userStart = currentPosition(c);
1470                     state = State::AuthorityOrHost;
1471                     authorityOrHostBegin = c;
1472                 }
1473             } else {
1474                 copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1475                 appendToASCIIBuffer(&#39;/&#39;);
1476                 m_url.m_pathAfterLastSlash = base.m_hostEnd + base.m_portLength + 1;
1477                 state = State::Path;
1478             }
1479             break;
1480         case State::SpecialAuthoritySlashes:
1481             LOG_STATE(&quot;SpecialAuthoritySlashes&quot;);
1482             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1483                 if (UNLIKELY(*c == &#39;\\&#39;))
1484                     syntaxViolation(c);
1485                 appendToASCIIBuffer(&#39;/&#39;);
1486                 advance(c);
1487                 if (LIKELY(!c.atEnd() &amp;&amp; (*c == &#39;/&#39; || *c == &#39;\\&#39;))) {
1488                     if (UNLIKELY(*c == &#39;\\&#39;))
1489                         syntaxViolation(c);
1490                     ++c;
1491                     appendToASCIIBuffer(&#39;/&#39;);
1492                 } else {
1493                     syntaxViolation(c);
1494                     appendToASCIIBuffer(&#39;/&#39;);
1495                 }
1496             } else {
1497                 syntaxViolation(c);
1498                 appendToASCIIBuffer(&quot;//&quot;, 2);
1499             }
1500             state = State::SpecialAuthorityIgnoreSlashes;
1501             break;
1502         case State::SpecialAuthorityIgnoreSlashes:
1503             LOG_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1504             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1505                 syntaxViolation(c);
1506                 ++c;
1507             } else {
1508                 m_url.m_userStart = currentPosition(c);
1509                 state = State::AuthorityOrHost;
1510                 authorityOrHostBegin = c;
1511             }
1512             break;
1513         case State::AuthorityOrHost:
1514             do {
1515                 LOG_STATE(&quot;AuthorityOrHost&quot;);
1516                 if (*c == &#39;@&#39;) {
1517                     auto lastAt = c;
1518                     auto findLastAt = c;
1519                     while (!findLastAt.atEnd()) {
1520                         URL_PARSER_LOG(&quot;Finding last @: %c&quot;, *findLastAt);
1521                         if (*findLastAt == &#39;@&#39;)
1522                             lastAt = findLastAt;
1523                         bool isSlash = *findLastAt == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *findLastAt == &#39;\\&#39;);
1524                         if (isSlash || *findLastAt == &#39;?&#39; || *findLastAt == &#39;#&#39;)
1525                             break;
1526                         ++findLastAt;
1527                     }
1528                     parseAuthority(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, lastAt));
1529                     c = lastAt;
1530                     advance(c);
1531                     authorityOrHostBegin = c;
1532                     state = State::Host;
1533                     m_hostHasPercentOrNonASCII = false;
1534                     break;
1535                 }
1536                 bool isSlash = *c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;);
1537                 if (isSlash || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1538                     auto iterator = CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c);
1539                     if (iterator.atEnd()) {
1540                         if (m_urlIsSpecial)
1541                             return failure();
1542                         m_url.m_userEnd = currentPosition(c);
1543                         m_url.m_passwordEnd = m_url.m_userEnd;
1544                         m_url.m_hostEnd = m_url.m_userEnd;
1545                         m_url.m_portLength = 0;
1546                         m_url.m_pathAfterLastSlash = m_url.m_userEnd;
1547                     } else {
1548                         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1549                         m_url.m_passwordEnd = m_url.m_userEnd;
1550                         if (!parseHostAndPort(iterator)) {
1551                             failure();
1552                             return;
1553                         }
1554                         if (UNLIKELY(!isSlash)) {
1555                             if (m_urlIsSpecial) {
1556                                 syntaxViolation(c);
1557                                 appendToASCIIBuffer(&#39;/&#39;);
1558                             }
1559                             m_url.m_pathAfterLastSlash = currentPosition(c);
1560                         }
1561                     }
1562                     state = State::Path;
1563                     break;
1564                 }
1565                 if (isPercentOrNonASCII(*c))
1566                     m_hostHasPercentOrNonASCII = true;
1567                 ++c;
1568             } while (!c.atEnd());
1569             break;
1570         case State::Host:
1571             do {
1572                 LOG_STATE(&quot;Host&quot;);
1573                 if (*c == &#39;/&#39; || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1574                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1575                         failure();
1576                         return;
1577                     }
1578                     if (*c == &#39;?&#39; || *c == &#39;#&#39;) {
1579                         syntaxViolation(c);
1580                         appendToASCIIBuffer(&#39;/&#39;);
1581                         m_url.m_pathAfterLastSlash = currentPosition(c);
1582                     }
1583                     state = State::Path;
1584                     break;
1585                 }
1586                 if (isPercentOrNonASCII(*c))
1587                     m_hostHasPercentOrNonASCII = true;
1588                 ++c;
1589             } while (!c.atEnd());
1590             break;
1591         case State::File:
1592             LOG_STATE(&quot;File&quot;);
1593             switch (*c) {
1594             case &#39;\\&#39;:
1595                 syntaxViolation(c);
1596                 FALLTHROUGH;
1597             case &#39;/&#39;:
1598                 appendToASCIIBuffer(&#39;/&#39;);
1599                 state = State::FileSlash;
1600                 ++c;
1601                 break;
1602             case &#39;?&#39;:
1603                 syntaxViolation(c);
1604                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1605                     copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1606                     appendToASCIIBuffer(&#39;?&#39;);
1607                     ++c;
1608                 } else {
1609                     appendToASCIIBuffer(&quot;///?&quot;, 4);
1610                     ++c;
1611                     m_url.m_userStart = currentPosition(c) - 2;
1612                     m_url.m_userEnd = m_url.m_userStart;
1613                     m_url.m_passwordEnd = m_url.m_userStart;
1614                     m_url.m_hostEnd = m_url.m_userStart;
1615                     m_url.m_portLength = 0;
1616                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1617                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1618                 }
1619                 if (nonUTF8QueryEncoding) {
1620                     queryBegin = c;
1621                     state = State::NonUTF8Query;
1622                 } else
1623                     state = State::UTF8Query;
1624                 break;
1625             case &#39;#&#39;:
1626                 syntaxViolation(c);
1627                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1628                     copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1629                     appendToASCIIBuffer(&#39;#&#39;);
1630                 } else {
1631                     appendToASCIIBuffer(&quot;///#&quot;, 4);
1632                     m_url.m_userStart = currentPosition(c) - 2;
1633                     m_url.m_userEnd = m_url.m_userStart;
1634                     m_url.m_passwordEnd = m_url.m_userStart;
1635                     m_url.m_hostEnd = m_url.m_userStart;
1636                     m_url.m_portLength = 0;
1637                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1638                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1639                     m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1640                 }
1641                 state = State::Fragment;
1642                 ++c;
1643                 break;
1644             default:
1645                 syntaxViolation(c);
1646                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;) &amp;&amp; shouldCopyFileURL(c))
1647                     copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1648                 else {
1649                     appendToASCIIBuffer(&quot;///&quot;, 3);
1650                     m_url.m_userStart = currentPosition(c) - 1;
1651                     m_url.m_userEnd = m_url.m_userStart;
1652                     m_url.m_passwordEnd = m_url.m_userStart;
1653                     m_url.m_hostEnd = m_url.m_userStart;
1654                     m_url.m_portLength = 0;
1655                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1656                     if (isWindowsDriveLetter(c))
1657                         appendWindowsDriveLetter(c);
1658                 }
1659                 state = State::Path;
1660                 break;
1661             }
1662             break;
1663         case State::FileSlash:
1664             LOG_STATE(&quot;FileSlash&quot;);
1665             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1666                 if (UNLIKELY(*c == &#39;\\&#39;))
1667                     syntaxViolation(c);
1668                 appendToASCIIBuffer(&#39;/&#39;);
1669                 advance(c);
1670                 m_url.m_userStart = currentPosition(c);
1671                 m_url.m_userEnd = m_url.m_userStart;
1672                 m_url.m_passwordEnd = m_url.m_userStart;
1673                 m_url.m_hostEnd = m_url.m_userStart;
1674                 m_url.m_portLength = 0;
1675                 authorityOrHostBegin = c;
1676                 state = State::FileHost;
1677                 break;
1678             }
1679             syntaxViolation(c);
1680             appendToASCIIBuffer(&quot;//&quot;, 2);
1681             m_url.m_userStart = currentPosition(c) - 1;
1682             m_url.m_userEnd = m_url.m_userStart;
1683             m_url.m_passwordEnd = m_url.m_userStart;
1684             m_url.m_hostEnd = m_url.m_userStart;
1685             m_url.m_portLength = 0;
1686             if (isWindowsDriveLetter(c)) {
1687                 appendWindowsDriveLetter(c);
1688                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1689             } else if (copyBaseWindowsDriveLetter(base)) {
1690                 appendToASCIIBuffer(&#39;/&#39;);
1691                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1692             } else
1693                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1694             state = State::Path;
1695             break;
1696         case State::FileHost:
1697             do {
1698                 LOG_STATE(&quot;FileHost&quot;);
1699                 if (isSlashQuestionOrHash(*c)) {
1700                     bool windowsQuirk = takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
1701                         &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin);
1702                     if (windowsQuirk) {
1703                         syntaxViolation(authorityOrHostBegin);
1704                         appendToASCIIBuffer(&#39;/&#39;);
1705                         appendWindowsDriveLetter(authorityOrHostBegin);
1706                     }
1707                     if (windowsQuirk || authorityOrHostBegin == c) {
1708                         ASSERT(windowsQuirk || parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1709                         if (UNLIKELY(*c == &#39;?&#39;)) {
1710                             syntaxViolation(c);
1711                             appendToASCIIBuffer(&quot;/?&quot;, 2);
1712                             ++c;
1713                             if (nonUTF8QueryEncoding) {
1714                                 queryBegin = c;
1715                                 state = State::NonUTF8Query;
1716                             } else
1717                                 state = State::UTF8Query;
1718                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1719                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1720                             break;
1721                         }
1722                         if (UNLIKELY(*c == &#39;#&#39;)) {
1723                             syntaxViolation(c);
1724                             appendToASCIIBuffer(&quot;/#&quot;, 2);
1725                             ++c;
1726                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1727                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1728                             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1729                             state = State::Fragment;
1730                             break;
1731                         }
1732                         state = State::Path;
1733                         break;
1734                     }
1735                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1736                         failure();
1737                         return;
1738                     }
1739                     if (UNLIKELY(isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd)))) {
1740                         syntaxViolation(c);
1741                         m_asciiBuffer.shrink(m_url.m_passwordEnd);
1742                         m_url.m_hostEnd = currentPosition(c);
1743                         m_url.m_portLength = 0;
1744                     }
1745 
1746                     state = State::PathStart;
1747                     break;
1748                 }
1749                 if (isPercentOrNonASCII(*c))
1750                     m_hostHasPercentOrNonASCII = true;
1751                 ++c;
1752             } while (!c.atEnd());
1753             break;
1754         case State::PathStart:
1755             LOG_STATE(&quot;PathStart&quot;);
1756             if (*c != &#39;/&#39; &amp;&amp; *c != &#39;\\&#39;) {
1757                 syntaxViolation(c);
1758                 appendToASCIIBuffer(&#39;/&#39;);
1759             }
1760             m_url.m_pathAfterLastSlash = currentPosition(c);
1761             state = State::Path;
1762             break;
1763         case State::Path:
1764             LOG_STATE(&quot;Path&quot;);
1765             if (*c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;)) {
1766                 if (UNLIKELY(m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;))
1767                     syntaxViolation(c);
1768                 appendToASCIIBuffer(&#39;/&#39;);
1769                 ++c;
1770                 m_url.m_pathAfterLastSlash = currentPosition(c);
1771                 break;
1772             }
1773             if (UNLIKELY(currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) == &#39;/&#39;)) {
1774                 if (UNLIKELY(isDoubleDotPathSegment(c))) {
1775                     syntaxViolation(c);
1776                     consumeDoubleDotPathSegment(c);
1777                     popPath();
1778                     break;
1779                 }
1780                 if (UNLIKELY(isSingleDotPathSegment(c))) {
1781                     syntaxViolation(c);
1782                     consumeSingleDotPathSegment(c);
1783                     break;
1784                 }
1785             }
1786             if (*c == &#39;?&#39;) {
1787                 m_url.m_pathEnd = currentPosition(c);
1788                 appendToASCIIBuffer(&#39;?&#39;);
1789                 ++c;
1790                 if (nonUTF8QueryEncoding) {
1791                     queryBegin = c;
1792                     state = State::NonUTF8Query;
1793                 } else
1794                     state = State::UTF8Query;
1795                 break;
1796             }
1797             if (*c == &#39;#&#39;) {
1798                 m_url.m_pathEnd = currentPosition(c);
1799                 m_url.m_queryEnd = m_url.m_pathEnd;
1800                 state = State::Fragment;
1801                 break;
1802             }
1803             utf8PercentEncode&lt;isInDefaultEncodeSet&gt;(c);
1804             ++c;
1805             break;
1806         case State::CannotBeABaseURLPath:
1807             LOG_STATE(&quot;CannotBeABaseURLPath&quot;);
1808             if (*c == &#39;?&#39;) {
1809                 m_url.m_pathEnd = currentPosition(c);
1810                 appendToASCIIBuffer(&#39;?&#39;);
1811                 ++c;
1812                 if (nonUTF8QueryEncoding) {
1813                     queryBegin = c;
1814                     state = State::NonUTF8Query;
1815                 } else
1816                     state = State::UTF8Query;
1817             } else if (*c == &#39;#&#39;) {
1818                 m_url.m_pathEnd = currentPosition(c);
1819                 m_url.m_queryEnd = m_url.m_pathEnd;
1820                 state = State::Fragment;
1821             } else if (*c == &#39;/&#39;) {
1822                 appendToASCIIBuffer(&#39;/&#39;);
1823                 ++c;
1824                 m_url.m_pathAfterLastSlash = currentPosition(c);
1825             } else {
1826                 utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1827                 ++c;
1828             }
1829             break;
1830         case State::UTF8Query:
1831             LOG_STATE(&quot;UTF8Query&quot;);
1832             ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
1833             if (*c == &#39;#&#39;) {
1834                 m_url.m_queryEnd = currentPosition(c);
1835                 state = State::Fragment;
1836                 break;
1837             }
1838             ASSERT(!nonUTF8QueryEncoding);
1839             utf8QueryEncode(c);
1840             ++c;
1841             break;
1842         case State::NonUTF8Query:
1843             do {
1844                 LOG_STATE(&quot;NonUTF8Query&quot;);
1845                 ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
1846                 if (*c == &#39;#&#39;) {
1847                     encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
1848                     m_url.m_queryEnd = currentPosition(c);
1849                     state = State::Fragment;
1850                     break;
1851                 }
1852                 appendCodePoint(queryBuffer, *c);
1853                 advance(c, queryBegin);
1854             } while (!c.atEnd());
1855             break;
1856         case State::Fragment:
1857             URL_PARSER_LOG(&quot;State Fragment&quot;);
1858             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1859             ++c;
1860             break;
1861         }
1862     }
1863 
1864     switch (state) {
1865     case State::SchemeStart:
1866         LOG_FINAL_STATE(&quot;SchemeStart&quot;);
1867         if (!currentPosition(c) &amp;&amp; base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1868             m_url = base;
1869             m_url.removeFragmentIdentifier();
1870             return;
1871         }
1872         failure();
1873         return;
1874     case State::Scheme:
1875         LOG_FINAL_STATE(&quot;Scheme&quot;);
1876         failure();
1877         return;
1878     case State::NoScheme:
1879         LOG_FINAL_STATE(&quot;NoScheme&quot;);
1880         RELEASE_ASSERT_NOT_REACHED();
1881     case State::SpecialRelativeOrAuthority:
1882         LOG_FINAL_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1883         copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1884         break;
1885     case State::PathOrAuthority:
1886         LOG_FINAL_STATE(&quot;PathOrAuthority&quot;);
1887         ASSERT(m_url.m_userStart);
1888         ASSERT(m_url.m_userStart == currentPosition(c));
1889         ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1890         m_url.m_userStart--;
1891         m_url.m_userEnd = m_url.m_userStart;
1892         m_url.m_passwordEnd = m_url.m_userStart;
1893         m_url.m_hostEnd = m_url.m_userStart;
1894         m_url.m_portLength = 0;
1895         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1896         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1897         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1898         break;
1899     case State::Relative:
1900         LOG_FINAL_STATE(&quot;Relative&quot;);
1901         RELEASE_ASSERT_NOT_REACHED();
1902     case State::RelativeSlash:
1903         LOG_FINAL_STATE(&quot;RelativeSlash&quot;);
1904         copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1905         appendToASCIIBuffer(&#39;/&#39;);
1906         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
1907         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1908         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1909         break;
1910     case State::SpecialAuthoritySlashes:
1911         LOG_FINAL_STATE(&quot;SpecialAuthoritySlashes&quot;);
1912         m_url.m_userStart = currentPosition(c);
1913         m_url.m_userEnd = m_url.m_userStart;
1914         m_url.m_passwordEnd = m_url.m_userStart;
1915         m_url.m_hostEnd = m_url.m_userStart;
1916         m_url.m_portLength = 0;
1917         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1918         m_url.m_pathEnd = m_url.m_userStart;
1919         m_url.m_queryEnd = m_url.m_userStart;
1920         break;
1921     case State::SpecialAuthorityIgnoreSlashes:
1922         LOG_FINAL_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1923         failure();
1924         return;
1925     case State::AuthorityOrHost:
1926         LOG_FINAL_STATE(&quot;AuthorityOrHost&quot;);
1927         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1928         m_url.m_passwordEnd = m_url.m_userEnd;
1929         if (authorityOrHostBegin.atEnd()) {
1930             m_url.m_userEnd = m_url.m_userStart;
1931             m_url.m_passwordEnd = m_url.m_userStart;
1932             m_url.m_hostEnd = m_url.m_userStart;
1933             m_url.m_portLength = 0;
1934             m_url.m_pathEnd = m_url.m_userStart;
1935         } else if (!parseHostAndPort(authorityOrHostBegin)) {
1936             failure();
1937             return;
1938         } else {
1939             if (m_urlIsSpecial) {
1940                 syntaxViolation(c);
1941                 appendToASCIIBuffer(&#39;/&#39;);
1942                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1943             } else
1944                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1945         }
1946         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1947         m_url.m_queryEnd = m_url.m_pathEnd;
1948         break;
1949     case State::Host:
1950         LOG_FINAL_STATE(&quot;Host&quot;);
1951         if (!parseHostAndPort(authorityOrHostBegin)) {
1952             failure();
1953             return;
1954         }
1955         if (m_urlIsSpecial) {
1956             syntaxViolation(c);
1957             appendToASCIIBuffer(&#39;/&#39;);
1958             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1959         } else
1960             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1961         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1962         m_url.m_queryEnd = m_url.m_pathEnd;
1963         break;
1964     case State::File:
1965         LOG_FINAL_STATE(&quot;File&quot;);
1966         if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1967             copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1968             break;
1969         }
1970         syntaxViolation(c);
1971         appendToASCIIBuffer(&quot;///&quot;, 3);
1972         m_url.m_userStart = currentPosition(c) - 1;
1973         m_url.m_userEnd = m_url.m_userStart;
1974         m_url.m_passwordEnd = m_url.m_userStart;
1975         m_url.m_hostEnd = m_url.m_userStart;
1976         m_url.m_portLength = 0;
1977         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1978         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1979         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1980         break;
1981     case State::FileSlash:
1982         LOG_FINAL_STATE(&quot;FileSlash&quot;);
1983         syntaxViolation(c);
1984         m_url.m_userStart = currentPosition(c) + 1;
1985         appendToASCIIBuffer(&quot;//&quot;, 2);
1986         m_url.m_userEnd = m_url.m_userStart;
1987         m_url.m_passwordEnd = m_url.m_userStart;
1988         m_url.m_hostEnd = m_url.m_userStart;
1989         m_url.m_portLength = 0;
1990         if (copyBaseWindowsDriveLetter(base)) {
1991             appendToASCIIBuffer(&#39;/&#39;);
1992             m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1993         } else
1994             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1995         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1996         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1997         break;
1998     case State::FileHost:
1999         LOG_FINAL_STATE(&quot;FileHost&quot;);
2000         if (takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
2001             &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin)) {
2002             syntaxViolation(authorityOrHostBegin);
2003             appendToASCIIBuffer(&#39;/&#39;);
2004             appendWindowsDriveLetter(authorityOrHostBegin);
2005             m_url.m_pathAfterLastSlash = currentPosition(c);
2006             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2007             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2008             break;
2009         }
2010 
2011         if (authorityOrHostBegin == c) {
2012             syntaxViolation(c);
2013             appendToASCIIBuffer(&#39;/&#39;);
2014             m_url.m_userStart = currentPosition(c) - 1;
2015             m_url.m_userEnd = m_url.m_userStart;
2016             m_url.m_passwordEnd = m_url.m_userStart;
2017             m_url.m_hostEnd = m_url.m_userStart;
2018             m_url.m_portLength = 0;
2019             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
2020             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2021             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2022             break;
2023         }
2024 
2025         if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
2026             failure();
2027             return;
2028         }
2029 
2030         syntaxViolation(c);
2031         if (isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd))) {
2032             m_asciiBuffer.shrink(m_url.m_passwordEnd);
2033             m_url.m_hostEnd = currentPosition(c);
2034             m_url.m_portLength = 0;
2035         }
2036         appendToASCIIBuffer(&#39;/&#39;);
2037         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
2038         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2039         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2040         break;
2041     case State::PathStart:
2042         LOG_FINAL_STATE(&quot;PathStart&quot;);
2043         RELEASE_ASSERT_NOT_REACHED();
2044     case State::Path:
2045         LOG_FINAL_STATE(&quot;Path&quot;);
2046         m_url.m_pathEnd = currentPosition(c);
2047         m_url.m_queryEnd = m_url.m_pathEnd;
2048         break;
2049     case State::CannotBeABaseURLPath:
2050         LOG_FINAL_STATE(&quot;CannotBeABaseURLPath&quot;);
2051         m_url.m_pathEnd = currentPosition(c);
2052         m_url.m_queryEnd = m_url.m_pathEnd;
2053         break;
2054     case State::UTF8Query:
2055         LOG_FINAL_STATE(&quot;UTF8Query&quot;);
2056         ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
2057         m_url.m_queryEnd = currentPosition(c);
2058         break;
2059     case State::NonUTF8Query:
2060         LOG_FINAL_STATE(&quot;NonUTF8Query&quot;);
2061         ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
2062         encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
2063         m_url.m_queryEnd = currentPosition(c);
2064         break;
2065     case State::Fragment:
2066         LOG_FINAL_STATE(&quot;Fragment&quot;);
2067         break;
2068     }
2069 
2070     if (LIKELY(!m_didSeeSyntaxViolation)) {
2071         m_url.m_string = m_inputString;
2072         ASSERT(m_asciiBuffer.isEmpty());
2073     } else
2074         m_url.m_string = String::adopt(WTFMove(m_asciiBuffer));
2075     m_url.m_isValid = true;
2076     URL_PARSER_LOG(&quot;Parsed URL &lt;%s&gt;&quot;, m_url.m_string.utf8().data());
2077 }
2078 
2079 template&lt;typename CharacterType&gt;
2080 void URLParser::parseAuthority(CodePointIterator&lt;CharacterType&gt; iterator)
2081 {
2082     if (UNLIKELY(iterator.atEnd())) {
2083         syntaxViolation(iterator);
2084         m_url.m_userEnd = currentPosition(iterator);
2085         m_url.m_passwordEnd = m_url.m_userEnd;
2086         return;
2087     }
2088     for (; !iterator.atEnd(); advance(iterator)) {
2089         if (*iterator == &#39;:&#39;) {
2090             m_url.m_userEnd = currentPosition(iterator);
2091             auto iteratorAtColon = iterator;
2092             ++iterator;
2093             bool tabOrNewlineAfterColon = false;
2094             while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
2095                 tabOrNewlineAfterColon = true;
2096                 ++iterator;
2097             }
2098             if (UNLIKELY(iterator.atEnd())) {
2099                 syntaxViolation(iteratorAtColon);
2100                 m_url.m_passwordEnd = m_url.m_userEnd;
2101                 if (m_url.m_userEnd &gt; m_url.m_userStart)
2102                     appendToASCIIBuffer(&#39;@&#39;);
2103                 return;
2104             }
2105             if (tabOrNewlineAfterColon)
2106                 syntaxViolation(iteratorAtColon);
2107             appendToASCIIBuffer(&#39;:&#39;);
2108             break;
2109         }
2110         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2111     }
2112     for (; !iterator.atEnd(); advance(iterator))
2113         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2114     m_url.m_passwordEnd = currentPosition(iterator);
2115     if (!m_url.m_userEnd)
2116         m_url.m_userEnd = m_url.m_passwordEnd;
2117     appendToASCIIBuffer(&#39;@&#39;);
2118 }
2119 
2120 template&lt;typename UnsignedIntegerType&gt;
2121 void URLParser::appendNumberToASCIIBuffer(UnsignedIntegerType number)
2122 {
2123     LChar buf[sizeof(UnsignedIntegerType) * 3 + 1];
2124     LChar* end = std::end(buf);
2125     LChar* p = end;
2126     do {
2127         *--p = (number % 10) + &#39;0&#39;;
2128         number /= 10;
2129     } while (number);
2130     appendToASCIIBuffer(p, end - p);
2131 }
2132 
2133 void URLParser::serializeIPv4(IPv4Address address)
2134 {
2135     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 24);
2136     appendToASCIIBuffer(&#39;.&#39;);
2137     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 16);
2138     appendToASCIIBuffer(&#39;.&#39;);
2139     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 8);
2140     appendToASCIIBuffer(&#39;.&#39;);
2141     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address);
2142 }
2143 
2144 static size_t zeroSequenceLength(const std::array&lt;uint16_t, 8&gt;&amp; address, size_t begin)
2145 {
2146     size_t end = begin;
2147     for (; end &lt; 8; end++) {
2148         if (address[end])
2149             break;
2150     }
2151     return end - begin;
2152 }
2153 
2154 static Optional&lt;size_t&gt; findLongestZeroSequence(const std::array&lt;uint16_t, 8&gt;&amp; address)
2155 {
2156     Optional&lt;size_t&gt; longest;
2157     size_t longestLength = 0;
2158     for (size_t i = 0; i &lt; 8; i++) {
2159         size_t length = zeroSequenceLength(address, i);
2160         if (length) {
2161             if (length &gt; 1 &amp;&amp; (!longest || longestLength &lt; length)) {
2162                 longest = i;
2163                 longestLength = length;
2164             }
2165             i += length;
2166         }
2167     }
2168     return longest;
2169 }
2170 
2171 void URLParser::serializeIPv6Piece(uint16_t piece)
2172 {
2173     bool printed = false;
2174     if (auto nibble0 = piece &gt;&gt; 12) {
2175         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble0));
2176         printed = true;
2177     }
2178     auto nibble1 = piece &gt;&gt; 8 &amp; 0xF;
2179     if (printed || nibble1) {
2180         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble1));
2181         printed = true;
2182     }
2183     auto nibble2 = piece &gt;&gt; 4 &amp; 0xF;
2184     if (printed || nibble2)
2185         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble2));
2186     appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(piece &amp; 0xF));
2187 }
2188 
2189 void URLParser::serializeIPv6(URLParser::IPv6Address address)
2190 {
2191     appendToASCIIBuffer(&#39;[&#39;);
2192     auto compressPointer = findLongestZeroSequence(address);
2193     for (size_t piece = 0; piece &lt; 8; piece++) {
2194         if (compressPointer &amp;&amp; compressPointer.value() == piece) {
2195             ASSERT(!address[piece]);
2196             if (piece)
2197                 appendToASCIIBuffer(&#39;:&#39;);
2198             else
2199                 appendToASCIIBuffer(&quot;::&quot;, 2);
2200             while (piece &lt; 8 &amp;&amp; !address[piece])
2201                 piece++;
2202             if (piece == 8)
2203                 break;
2204         }
2205         serializeIPv6Piece(address[piece]);
2206         if (piece &lt; 7)
2207             appendToASCIIBuffer(&#39;:&#39;);
2208     }
2209     appendToASCIIBuffer(&#39;]&#39;);
2210 }
2211 
2212 enum class URLParser::IPv4PieceParsingError {
2213     Failure,
2214     Overflow,
2215 };
2216 
2217 template&lt;typename CharacterType&gt;
2218 Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt; URLParser::parseIPv4Piece(CodePointIterator&lt;CharacterType&gt;&amp; iterator, bool&amp; didSeeSyntaxViolation)
2219 {
2220     enum class State : uint8_t {
2221         UnknownBase,
2222         Decimal,
2223         OctalOrHex,
2224         Octal,
2225         Hex,
2226     };
2227     State state = State::UnknownBase;
2228     Checked&lt;uint32_t, RecordOverflow&gt; value = 0;
2229     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2230         return makeUnexpected(IPv4PieceParsingError::Failure);
2231     while (!iterator.atEnd()) {
2232         if (isTabOrNewline(*iterator)) {
2233             didSeeSyntaxViolation = true;
2234             ++iterator;
2235             continue;
2236         }
2237         if (*iterator == &#39;.&#39;) {
2238             ASSERT(!value.hasOverflowed());
2239             return value.unsafeGet();
2240         }
2241         switch (state) {
2242         case State::UnknownBase:
2243             if (UNLIKELY(*iterator == &#39;0&#39;)) {
2244                 ++iterator;
2245                 state = State::OctalOrHex;
2246                 break;
2247             }
2248             state = State::Decimal;
2249             break;
2250         case State::OctalOrHex:
2251             didSeeSyntaxViolation = true;
2252             if (*iterator == &#39;x&#39; || *iterator == &#39;X&#39;) {
2253                 ++iterator;
2254                 state = State::Hex;
2255                 break;
2256             }
2257             state = State::Octal;
2258             break;
2259         case State::Decimal:
2260             if (!isASCIIDigit(*iterator))
2261                 return makeUnexpected(IPv4PieceParsingError::Failure);
2262             value *= 10;
2263             value += *iterator - &#39;0&#39;;
2264             if (UNLIKELY(value.hasOverflowed()))
2265                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2266             ++iterator;
2267             break;
2268         case State::Octal:
2269             ASSERT(didSeeSyntaxViolation);
2270             if (*iterator &lt; &#39;0&#39; || *iterator &gt; &#39;7&#39;)
2271                 return makeUnexpected(IPv4PieceParsingError::Failure);
2272             value *= 8;
2273             value += *iterator - &#39;0&#39;;
2274             if (UNLIKELY(value.hasOverflowed()))
2275                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2276             ++iterator;
2277             break;
2278         case State::Hex:
2279             ASSERT(didSeeSyntaxViolation);
2280             if (!isASCIIHexDigit(*iterator))
2281                 return makeUnexpected(IPv4PieceParsingError::Failure);
2282             value *= 16;
2283             value += toASCIIHexValue(*iterator);
2284             if (UNLIKELY(value.hasOverflowed()))
2285                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2286             ++iterator;
2287             break;
2288         }
2289     }
2290     ASSERT(!value.hasOverflowed());
2291     return value.unsafeGet();
2292 }
2293 
2294 ALWAYS_INLINE static uint64_t pow256(size_t exponent)
2295 {
2296     RELEASE_ASSERT(exponent &lt;= 4);
2297     uint64_t values[5] = {1, 256, 256 * 256, 256 * 256 * 256, 256ull * 256 * 256 * 256 };
2298     return values[exponent];
2299 }
2300 
2301 enum class URLParser::IPv4ParsingError {
2302     Failure,
2303     NotIPv4,
2304 };
2305 
2306 template&lt;typename CharacterTypeForSyntaxViolation, typename CharacterType&gt;
2307 Expected&lt;URLParser::IPv4Address, URLParser::IPv4ParsingError&gt; URLParser::parseIPv4Host(const CodePointIterator&lt;CharacterTypeForSyntaxViolation&gt;&amp; iteratorForSyntaxViolationPosition, CodePointIterator&lt;CharacterType&gt; iterator)
2308 {
2309     Vector&lt;Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt;, 4&gt; items;
2310     bool didSeeSyntaxViolation = false;
2311     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2312         return makeUnexpected(IPv4ParsingError::NotIPv4);
2313     while (!iterator.atEnd()) {
2314         if (isTabOrNewline(*iterator)) {
2315             didSeeSyntaxViolation = true;
2316             ++iterator;
2317             continue;
2318         }
2319         if (items.size() &gt;= 4)
2320             return makeUnexpected(IPv4ParsingError::NotIPv4);
2321         items.append(parseIPv4Piece(iterator, didSeeSyntaxViolation));
2322         if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;) {
2323             ++iterator;
2324             if (iterator.atEnd())
2325                 syntaxViolation(iteratorForSyntaxViolationPosition);
2326             else if (*iterator == &#39;.&#39;)
2327                 return makeUnexpected(IPv4ParsingError::NotIPv4);
2328         }
2329     }
2330     if (!iterator.atEnd() || !items.size() || items.size() &gt; 4)
2331         return makeUnexpected(IPv4ParsingError::NotIPv4);
2332     for (const auto&amp; item : items) {
2333         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Failure)
2334             return makeUnexpected(IPv4ParsingError::NotIPv4);
2335     }
2336     for (const auto&amp; item : items) {
2337         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Overflow)
2338             return makeUnexpected(IPv4ParsingError::Failure);
2339     }
2340     if (items.size() &gt; 1) {
2341         for (size_t i = 0; i &lt; items.size() - 1; i++) {
2342             if (items[i].value() &gt; 255)
2343                 return makeUnexpected(IPv4ParsingError::Failure);
2344         }
2345     }
2346     if (items[items.size() - 1].value() &gt;= pow256(5 - items.size()))
2347         return makeUnexpected(IPv4ParsingError::Failure);
2348 
2349     if (didSeeSyntaxViolation)
2350         syntaxViolation(iteratorForSyntaxViolationPosition);
2351     for (const auto&amp; item : items) {
2352         if (item.value() &gt; 255)
2353             syntaxViolation(iteratorForSyntaxViolationPosition);
2354     }
2355 
2356     if (UNLIKELY(items.size() != 4))
2357         syntaxViolation(iteratorForSyntaxViolationPosition);
2358 
2359     IPv4Address ipv4 = items.takeLast().value();
2360     for (size_t counter = 0; counter &lt; items.size(); ++counter)
2361         ipv4 += items[counter].value() * pow256(3 - counter);
2362     return ipv4;
2363 }
2364 
2365 template&lt;typename CharacterType&gt;
2366 Optional&lt;uint32_t&gt; URLParser::parseIPv4PieceInsideIPv6(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2367 {
2368     if (iterator.atEnd())
2369         return WTF::nullopt;
2370     uint32_t piece = 0;
2371     bool leadingZeros = false;
2372     size_t digitCount = 0;
2373     while (!iterator.atEnd()) {
2374         if (!isASCIIDigit(*iterator))
2375             return WTF::nullopt;
2376         ++digitCount;
2377         if (!piece &amp;&amp; *iterator == &#39;0&#39;) {
2378             if (leadingZeros)
2379                 return WTF::nullopt;
2380             leadingZeros = true;
2381         }
2382         if (!piece &amp;&amp; *iterator == &#39;0&#39;)
2383             leadingZeros = true;
2384         piece = piece * 10 + *iterator - &#39;0&#39;;
2385         if (piece &gt; 255)
2386             return WTF::nullopt;
2387         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2388         if (iterator.atEnd())
2389             break;
2390         if (*iterator == &#39;.&#39;)
2391             break;
2392     }
2393     if (piece &amp;&amp; leadingZeros)
2394         return WTF::nullopt;
2395     return piece;
2396 }
2397 
2398 template&lt;typename CharacterType&gt;
2399 Optional&lt;URLParser::IPv4Address&gt; URLParser::parseIPv4AddressInsideIPv6(CodePointIterator&lt;CharacterType&gt; iterator)
2400 {
2401     IPv4Address address = 0;
2402     for (size_t i = 0; i &lt; 4; ++i) {
2403         if (Optional&lt;uint32_t&gt; piece = parseIPv4PieceInsideIPv6(iterator))
2404             address = (address &lt;&lt; 8) + piece.value();
2405         else
2406             return WTF::nullopt;
2407         if (i &lt; 3) {
2408             if (iterator.atEnd())
2409                 return WTF::nullopt;
2410             if (*iterator != &#39;.&#39;)
2411                 return WTF::nullopt;
2412             advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2413         } else if (!iterator.atEnd())
2414             return WTF::nullopt;
2415     }
2416     ASSERT(iterator.atEnd());
2417     return address;
2418 }
2419 
2420 template&lt;typename CharacterType&gt;
2421 Optional&lt;URLParser::IPv6Address&gt; URLParser::parseIPv6Host(CodePointIterator&lt;CharacterType&gt; c)
2422 {
2423     ASSERT(*c == &#39;[&#39;);
2424     const auto hostBegin = c;
2425     advance(c, hostBegin);
2426     if (c.atEnd())
2427         return WTF::nullopt;
2428 
2429     IPv6Address address = {{0, 0, 0, 0, 0, 0, 0, 0}};
2430     size_t piecePointer = 0;
2431     Optional&lt;size_t&gt; compressPointer;
2432 
2433     if (*c == &#39;:&#39;) {
2434         advance(c, hostBegin);
2435         if (c.atEnd())
2436             return WTF::nullopt;
2437         if (*c != &#39;:&#39;)
2438             return WTF::nullopt;
2439         advance(c, hostBegin);
2440         ++piecePointer;
2441         compressPointer = piecePointer;
2442     }
2443 
2444     while (!c.atEnd()) {
2445         if (piecePointer == 8)
2446             return WTF::nullopt;
2447         if (*c == &#39;:&#39;) {
2448             if (compressPointer)
2449                 return WTF::nullopt;
2450             advance(c, hostBegin);
2451             ++piecePointer;
2452             compressPointer = piecePointer;
2453             continue;
2454         }
2455         if (piecePointer == 6 || (compressPointer &amp;&amp; piecePointer &lt; 6)) {
2456             if (Optional&lt;IPv4Address&gt; ipv4Address = parseIPv4AddressInsideIPv6(c)) {
2457                 if (compressPointer &amp;&amp; piecePointer == 5)
2458                     return WTF::nullopt;
2459                 syntaxViolation(hostBegin);
2460                 address[piecePointer++] = ipv4Address.value() &gt;&gt; 16;
2461                 address[piecePointer++] = ipv4Address.value() &amp; 0xFFFF;
2462                 c = { };
2463                 break;
2464             }
2465         }
2466         uint16_t value = 0;
2467         size_t length = 0;
2468         bool leadingZeros = false;
2469         for (; length &lt; 4; length++) {
2470             if (c.atEnd())
2471                 break;
2472             if (!isASCIIHexDigit(*c))
2473                 break;
2474             if (isASCIIUpper(*c))
2475                 syntaxViolation(hostBegin);
2476             if (*c == &#39;0&#39; &amp;&amp; !length)
2477                 leadingZeros = true;
2478             value = value * 0x10 + toASCIIHexValue(*c);
2479             advance(c, hostBegin);
2480         }
2481 
2482         if (UNLIKELY((value &amp;&amp; leadingZeros) || (!value &amp;&amp; length &gt; 1)))
2483             syntaxViolation(hostBegin);
2484 
2485         address[piecePointer++] = value;
2486         if (c.atEnd())
2487             break;
2488         if (piecePointer == 8 || *c != &#39;:&#39;)
2489             return WTF::nullopt;
2490         advance(c, hostBegin);
2491     }
2492 
2493     if (!c.atEnd())
2494         return WTF::nullopt;
2495 
2496     if (compressPointer) {
2497         size_t swaps = piecePointer - compressPointer.value();
2498         piecePointer = 7;
2499         while (swaps)
2500             std::swap(address[piecePointer--], address[compressPointer.value() + swaps-- - 1]);
2501     } else if (piecePointer != 8)
2502         return WTF::nullopt;
2503 
2504     Optional&lt;size_t&gt; possibleCompressPointer = findLongestZeroSequence(address);
2505     if (possibleCompressPointer)
2506         possibleCompressPointer.value()++;
2507     if (UNLIKELY(compressPointer != possibleCompressPointer))
2508         syntaxViolation(hostBegin);
2509 
2510     return address;
2511 }
2512 
2513 template&lt;typename CharacterType&gt;
2514 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2515 {
2516     LCharBuffer output;
2517     output.reserveInitialCapacity(length);
2518 
2519     for (size_t i = 0; i &lt; length; ++i) {
2520         uint8_t byte = input[i];
2521         if (byte != &#39;%&#39;)
2522             output.uncheckedAppend(byte);
2523         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2524             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2525                 syntaxViolation(iteratorForSyntaxViolationPosition);
2526                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2527                 i += 2;
2528             } else
2529                 output.uncheckedAppend(byte);
2530         } else
2531             output.uncheckedAppend(byte);
2532     }
2533     return output;
2534 }
2535 
2536 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length)
2537 {
2538     LCharBuffer output;
2539     output.reserveInitialCapacity(length);
2540 
2541     for (size_t i = 0; i &lt; length; ++i) {
2542         uint8_t byte = input[i];
2543         if (byte != &#39;%&#39;)
2544             output.uncheckedAppend(byte);
2545         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2546             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2547                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2548                 i += 2;
2549             } else
2550                 output.uncheckedAppend(byte);
2551         } else
2552             output.uncheckedAppend(byte);
2553     }
2554     return output;
2555 }
2556 
2557 template&lt;typename CharacterType&gt; Optional&lt;URLParser::LCharBuffer&gt; URLParser::domainToASCII(StringImpl&amp; domain, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2558 {
2559     LCharBuffer ascii;
2560     if (domain.isAllASCII()) {
2561         size_t length = domain.length();
2562         if (domain.is8Bit()) {
2563             const LChar* characters = domain.characters8();
2564             ascii.reserveInitialCapacity(length);
2565             for (size_t i = 0; i &lt; length; ++i) {
2566                 if (UNLIKELY(isASCIIUpper(characters[i])))
2567                     syntaxViolation(iteratorForSyntaxViolationPosition);
2568                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2569             }
2570         } else {
2571             const UChar* characters = domain.characters16();
2572             ascii.reserveInitialCapacity(length);
2573             for (size_t i = 0; i &lt; length; ++i) {
2574                 if (UNLIKELY(isASCIIUpper(characters[i])))
2575                     syntaxViolation(iteratorForSyntaxViolationPosition);
2576                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2577             }
2578         }
2579         return ascii;
2580     }
2581 
2582     const size_t maxDomainLength = 64;
2583     UChar hostnameBuffer[maxDomainLength];
2584     UErrorCode error = U_ZERO_ERROR;
2585     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
2586     int32_t numCharactersConverted = uidna_nameToASCII(&amp;internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &amp;processingDetails, &amp;error);
2587     ASSERT(numCharactersConverted &lt;= static_cast&lt;int32_t&gt;(maxDomainLength));
2588 
2589     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
2590         for (int32_t i = 0; i &lt; numCharactersConverted; ++i) {
2591             ASSERT(isASCII(hostnameBuffer[i]));
2592             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
2593         }
2594         ascii.append(hostnameBuffer, numCharactersConverted);
2595         if (domain != StringView(ascii.data(), ascii.size()))
2596             syntaxViolation(iteratorForSyntaxViolationPosition);
2597         return ascii;
2598     }
2599     return WTF::nullopt;
2600 }
2601 
2602 bool URLParser::hasForbiddenHostCodePoint(const URLParser::LCharBuffer&amp; asciiDomain)
2603 {
2604     for (size_t i = 0; i &lt; asciiDomain.size(); ++i) {
2605         if (isForbiddenHostCodePoint(asciiDomain[i]))
2606             return true;
2607     }
2608     return false;
2609 }
2610 
2611 template&lt;typename CharacterType&gt;
2612 bool URLParser::parsePort(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2613 {
2614     ASSERT(*iterator == &#39;:&#39;);
2615     auto colonIterator = iterator;
2616     advance(iterator, colonIterator);
2617     uint32_t port = 0;
2618     if (UNLIKELY(iterator.atEnd())) {
2619         unsigned portLength = currentPosition(colonIterator) - m_url.m_hostEnd;
2620         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2621         m_url.m_portLength = portLength;
2622         syntaxViolation(colonIterator);
2623         return true;
2624     }
2625     size_t digitCount = 0;
2626     bool leadingZeros = false;
2627     for (; !iterator.atEnd(); ++iterator) {
2628         if (UNLIKELY(isTabOrNewline(*iterator))) {
2629             syntaxViolation(colonIterator);
2630             continue;
2631         }
2632         if (isASCIIDigit(*iterator)) {
2633             if (*iterator == &#39;0&#39; &amp;&amp; !digitCount)
2634                 leadingZeros = true;
2635             ++digitCount;
2636             port = port * 10 + *iterator - &#39;0&#39;;
2637             if (port &gt; std::numeric_limits&lt;uint16_t&gt;::max())
2638                 return false;
2639         } else
2640             return false;
2641     }
2642 
2643     if (port &amp;&amp; leadingZeros)
2644         syntaxViolation(colonIterator);
2645 
2646     if (!port &amp;&amp; digitCount &gt; 1)
2647         syntaxViolation(colonIterator);
2648 
2649     ASSERT(port == static_cast&lt;uint16_t&gt;(port));
2650     if (UNLIKELY(defaultPortForProtocol(parsedDataView(0, m_url.m_schemeEnd)) == static_cast&lt;uint16_t&gt;(port)))
2651         syntaxViolation(colonIterator);
2652     else {
2653         appendToASCIIBuffer(&#39;:&#39;);
2654         ASSERT(port &lt;= std::numeric_limits&lt;uint16_t&gt;::max());
2655         appendNumberToASCIIBuffer&lt;uint16_t&gt;(static_cast&lt;uint16_t&gt;(port));
2656     }
2657 
2658     unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2659     RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2660     m_url.m_portLength = portLength;
2661     return true;
2662 }
2663 
2664 template&lt;typename CharacterType&gt;
2665 bool URLParser::parseHostAndPort(CodePointIterator&lt;CharacterType&gt; iterator)
2666 {
2667     if (iterator.atEnd())
2668         return false;
2669     if (*iterator == &#39;:&#39;)
2670         return false;
2671     if (*iterator == &#39;[&#39;) {
2672         auto ipv6End = iterator;
2673         while (!ipv6End.atEnd() &amp;&amp; *ipv6End != &#39;]&#39;)
2674             ++ipv6End;
2675         if (ipv6End.atEnd())
2676             return false;
2677         if (auto address = parseIPv6Host(CodePointIterator&lt;CharacterType&gt;(iterator, ipv6End))) {
2678             serializeIPv6(address.value());
2679             if (!ipv6End.atEnd()) {
2680                 advance(ipv6End);
2681                 if (!ipv6End.atEnd() &amp;&amp; *ipv6End == &#39;:&#39;) {
2682                     m_url.m_hostEnd = currentPosition(ipv6End);
2683                     return parsePort(ipv6End);
2684                 }
2685                 m_url.m_hostEnd = currentPosition(ipv6End);
2686                 m_url.m_portLength = 0;
2687                 return true;
2688             }
2689             m_url.m_hostEnd = currentPosition(ipv6End);
2690             return true;
2691         }
2692         return false;
2693     }
2694 
2695     if (!m_urlIsSpecial) {
2696         for (; !iterator.atEnd(); ++iterator) {
2697             if (UNLIKELY(isTabOrNewline(*iterator))) {
2698                 syntaxViolation(iterator);
2699                 continue;
2700             }
2701             if (*iterator == &#39;:&#39;)
2702                 break;
2703             if (UNLIKELY(isForbiddenHostCodePoint(*iterator) &amp;&amp; *iterator != &#39;%&#39;))
2704                 return false;
2705             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(iterator);
2706         }
2707         m_url.m_hostEnd = currentPosition(iterator);
2708         if (iterator.atEnd()) {
2709             m_url.m_portLength = 0;
2710             return true;
2711         }
2712         return parsePort(iterator);
2713     }
2714 
2715     if (LIKELY(!m_hostHasPercentOrNonASCII)) {
2716         auto hostIterator = iterator;
2717         for (; !iterator.atEnd(); ++iterator) {
2718             if (isTabOrNewline(*iterator))
2719                 continue;
2720             if (*iterator == &#39;:&#39;)
2721                 break;
2722             if (isForbiddenHostCodePoint(*iterator))
2723                 return false;
2724         }
2725         auto address = parseIPv4Host(hostIterator, CodePointIterator&lt;CharacterType&gt;(hostIterator, iterator));
2726         if (address) {
2727             serializeIPv4(address.value());
2728             m_url.m_hostEnd = currentPosition(iterator);
2729             if (iterator.atEnd()) {
2730                 m_url.m_portLength = 0;
2731                 return true;
2732             }
2733             return parsePort(iterator);
2734         }
2735         if (address.error() == IPv4ParsingError::Failure)
2736             return false;
2737         for (; hostIterator != iterator; ++hostIterator) {
2738             if (UNLIKELY(isTabOrNewline(*hostIterator))) {
2739                 syntaxViolation(hostIterator);
2740                 continue;
2741             }
2742             if (UNLIKELY(isASCIIUpper(*hostIterator)))
2743                 syntaxViolation(hostIterator);
2744             appendToASCIIBuffer(toASCIILower(*hostIterator));
2745         }
2746         m_url.m_hostEnd = currentPosition(iterator);
2747         if (!hostIterator.atEnd())
2748             return parsePort(hostIterator);
2749         unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2750         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2751         m_url.m_portLength = portLength;
2752         return true;
2753     }
2754 
2755     const auto hostBegin = iterator;
2756 
2757     LCharBuffer utf8Encoded;
2758     for (; !iterator.atEnd(); ++iterator) {
2759         if (UNLIKELY(isTabOrNewline(*iterator))) {
2760             syntaxViolation(hostBegin);
2761             continue;
2762         }
2763         if (*iterator == &#39;:&#39;)
2764             break;
2765         if (UNLIKELY(!isASCII(*iterator)))
2766             syntaxViolation(hostBegin);
2767 
2768         if (!U_IS_UNICODE_CHAR(*iterator))
2769             return false;
2770         uint8_t buffer[U8_MAX_LENGTH];
2771         int32_t offset = 0;
2772         U8_APPEND_UNSAFE(buffer, offset, *iterator);
2773         utf8Encoded.append(buffer, offset);
2774     }
2775     LCharBuffer percentDecoded = percentDecode(utf8Encoded.data(), utf8Encoded.size(), hostBegin);
2776     String domain = String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2777     if (domain.isNull())
2778         return false;
2779     if (domain != StringView(percentDecoded.data(), percentDecoded.size()))
2780         syntaxViolation(hostBegin);
2781     auto asciiDomain = domainToASCII(*domain.impl(), hostBegin);
2782     if (!asciiDomain || hasForbiddenHostCodePoint(asciiDomain.value()))
2783         return false;
2784     LCharBuffer&amp; asciiDomainValue = asciiDomain.value();
2785     const LChar* asciiDomainCharacters = asciiDomainValue.data();
2786 
2787     auto address = parseIPv4Host(hostBegin, CodePointIterator&lt;LChar&gt;(asciiDomainValue.begin(), asciiDomainValue.end()));
2788     if (address) {
2789         serializeIPv4(address.value());
2790         m_url.m_hostEnd = currentPosition(iterator);
2791         if (iterator.atEnd()) {
2792             m_url.m_portLength = 0;
2793             return true;
2794         }
2795         return parsePort(iterator);
2796     }
2797     if (address.error() == IPv4ParsingError::Failure)
2798         return false;
2799 
2800     appendToASCIIBuffer(asciiDomainCharacters, asciiDomainValue.size());
2801     m_url.m_hostEnd = currentPosition(iterator);
2802     if (!iterator.atEnd())
2803         return parsePort(iterator);
2804     m_url.m_portLength = 0;
2805     return true;
2806 }
2807 
2808 Optional&lt;String&gt; URLParser::formURLDecode(StringView input)
2809 {
2810     auto utf8 = input.utf8(StrictConversion);
2811     if (utf8.isNull())
2812         return WTF::nullopt;
2813     auto percentDecoded = percentDecode(reinterpret_cast&lt;const LChar*&gt;(utf8.data()), utf8.length());
2814     return String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2815 }
2816 
2817 // https://url.spec.whatwg.org/#concept-urlencoded-parser
2818 auto URLParser::parseURLEncodedForm(StringView input) -&gt; URLEncodedForm
2819 {
2820     URLEncodedForm output;
2821     for (StringView bytes : input.split(&#39;&amp;&#39;)) {
2822         auto equalIndex = bytes.find(&#39;=&#39;);
2823         if (equalIndex == notFound) {
2824             auto name = formURLDecode(bytes.toString().replace(&#39;+&#39;, 0x20));
2825             if (name)
2826                 output.append({ name.value(), emptyString() });
2827         } else {
2828             auto name = formURLDecode(bytes.substring(0, equalIndex).toString().replace(&#39;+&#39;, 0x20));
2829             auto value = formURLDecode(bytes.substring(equalIndex + 1).toString().replace(&#39;+&#39;, 0x20));
2830             if (name &amp;&amp; value)
2831                 output.append({ name.value(), value.value() });
2832         }
2833     }
2834     return output;
2835 }
2836 
2837 static void serializeURLEncodedForm(const String&amp; input, Vector&lt;LChar&gt;&amp; output)
2838 {
2839     auto utf8 = input.utf8(StrictConversion);
2840     const char* data = utf8.data();
2841     for (size_t i = 0; i &lt; utf8.length(); ++i) {
2842         const char byte = data[i];
2843         if (byte == 0x20)
2844             output.append(0x2B);
2845         else if (byte == 0x2A
2846             || byte == 0x2D
2847             || byte == 0x2E
2848             || (byte &gt;= 0x30 &amp;&amp; byte &lt;= 0x39)
2849             || (byte &gt;= 0x41 &amp;&amp; byte &lt;= 0x5A)
2850             || byte == 0x5F
2851             || (byte &gt;= 0x61 &amp;&amp; byte &lt;= 0x7A)) // FIXME: Put these in the characterClassTable to avoid branches.
2852             output.append(byte);
2853         else
2854             percentEncodeByte(byte, output);
2855     }
2856 }
2857 
2858 String URLParser::serialize(const URLEncodedForm&amp; tuples)
2859 {
2860     if (tuples.isEmpty())
2861         return { };
2862 
2863     Vector&lt;LChar&gt; output;
2864     for (auto&amp; tuple : tuples) {
2865         if (!output.isEmpty())
2866             output.append(&#39;&amp;&#39;);
2867         serializeURLEncodedForm(tuple.key, output);
2868         output.append(&#39;=&#39;);
2869         serializeURLEncodedForm(tuple.value, output);
2870     }
2871     return String::adopt(WTFMove(output));
2872 }
2873 
2874 const UIDNA&amp; URLParser::internationalDomainNameTranscoder()
2875 {
2876     static UIDNA* encoder;
2877     static std::once_flag onceFlag;
2878     std::call_once(onceFlag, [] {
2879         UErrorCode error = U_ZERO_ERROR;
2880         // Warning: Please contact a WebKitGTK+ developer if changing these flags.
2881         // They should be synced with ephy_uri_decode() in ephy-uri-helpers.c.
2882         encoder = uidna_openUTS46(UIDNA_CHECK_BIDI | UIDNA_CHECK_CONTEXTJ | UIDNA_NONTRANSITIONAL_TO_UNICODE | UIDNA_NONTRANSITIONAL_TO_ASCII, &amp;error);
2883         RELEASE_ASSERT(U_SUCCESS(error));
2884         RELEASE_ASSERT(encoder);
2885     });
2886     return *encoder;
2887 }
2888 
2889 bool URLParser::allValuesEqual(const URL&amp; a, const URL&amp; b)
2890 {
2891     URL_PARSER_LOG(&quot;%d %d %d %d %d %d %d %d %d %d %d %d %s\n%d %d %d %d %d %d %d %d %d %d %d %d %s&quot;,
2892         a.m_isValid,
2893         a.m_cannotBeABaseURL,
2894         a.m_protocolIsInHTTPFamily,
2895         a.m_schemeEnd,
2896         a.m_userStart,
2897         a.m_userEnd,
2898         a.m_passwordEnd,
2899         a.m_hostEnd,
2900         a.m_hostEnd + a.m_portLength,
2901         a.m_pathAfterLastSlash,
2902         a.m_pathEnd,
2903         a.m_queryEnd,
2904         a.m_string.utf8().data(),
2905         b.m_isValid,
2906         b.m_cannotBeABaseURL,
2907         b.m_protocolIsInHTTPFamily,
2908         b.m_schemeEnd,
2909         b.m_userStart,
2910         b.m_userEnd,
2911         b.m_passwordEnd,
2912         b.m_hostEnd,
2913         b.m_hostEnd + b.m_portLength,
2914         b.m_pathAfterLastSlash,
2915         b.m_pathEnd,
2916         b.m_queryEnd,
2917         b.m_string.utf8().data());
2918 
2919     return a.m_string == b.m_string
2920         &amp;&amp; a.m_isValid == b.m_isValid
2921         &amp;&amp; a.m_cannotBeABaseURL == b.m_cannotBeABaseURL
2922         &amp;&amp; a.m_protocolIsInHTTPFamily == b.m_protocolIsInHTTPFamily
2923         &amp;&amp; a.m_schemeEnd == b.m_schemeEnd
2924         &amp;&amp; a.m_userStart == b.m_userStart
2925         &amp;&amp; a.m_userEnd == b.m_userEnd
2926         &amp;&amp; a.m_passwordEnd == b.m_passwordEnd
2927         &amp;&amp; a.m_hostEnd == b.m_hostEnd
2928         &amp;&amp; a.m_portLength == b.m_portLength
2929         &amp;&amp; a.m_pathAfterLastSlash == b.m_pathAfterLastSlash
2930         &amp;&amp; a.m_pathEnd == b.m_pathEnd
2931         &amp;&amp; a.m_queryEnd == b.m_queryEnd;
2932 }
2933 
2934 bool URLParser::internalValuesConsistent(const URL&amp; url)
2935 {
2936     return url.m_schemeEnd &lt;= url.m_userStart
2937         &amp;&amp; url.m_userStart &lt;= url.m_userEnd
2938         &amp;&amp; url.m_userEnd &lt;= url.m_passwordEnd
2939         &amp;&amp; url.m_passwordEnd &lt;= url.m_hostEnd
2940         &amp;&amp; url.m_hostEnd + url.m_portLength &lt;= url.m_pathAfterLastSlash
2941         &amp;&amp; url.m_pathAfterLastSlash &lt;= url.m_pathEnd
2942         &amp;&amp; url.m_pathEnd &lt;= url.m_queryEnd
2943         &amp;&amp; url.m_queryEnd &lt;= url.m_string.length();
2944 }
2945 
2946 } // namespace WTF
    </pre>
  </body>
</html>