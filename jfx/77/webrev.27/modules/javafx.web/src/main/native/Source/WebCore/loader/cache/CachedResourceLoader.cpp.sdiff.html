<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedResource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23     This class provides all functionality needed for loading images, style sheets and html
  24     pages from the web. It has a memory cache for these objects.
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;

  43 #include &quot;ContentSecurityPolicy.h&quot;
  44 #include &quot;CrossOriginAccessControl.h&quot;

  45 #include &quot;DOMWindow.h&quot;
  46 #include &quot;DiagnosticLoggingClient.h&quot;
  47 #include &quot;DiagnosticLoggingKeys.h&quot;
  48 #include &quot;Document.h&quot;
  49 #include &quot;DocumentLoader.h&quot;
  50 #include &quot;Frame.h&quot;
  51 #include &quot;FrameLoader.h&quot;
  52 #include &quot;FrameLoaderClient.h&quot;
  53 #include &quot;HTMLElement.h&quot;
  54 #include &quot;HTMLFrameOwnerElement.h&quot;
  55 #include &quot;HTTPHeaderField.h&quot;
  56 #include &quot;LoaderStrategy.h&quot;
  57 #include &quot;LocalizedStrings.h&quot;
  58 #include &quot;Logging.h&quot;
  59 #include &quot;MemoryCache.h&quot;
  60 #include &quot;Page.h&quot;
  61 #include &quot;PingLoader.h&quot;
  62 #include &quot;PlatformStrategies.h&quot;
  63 #include &quot;RenderElement.h&quot;
  64 #include &quot;ResourceLoadInfo.h&quot;
</pre>
<hr />
<pre>
 102 }
 103 
 104 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 105 {
 106     switch (type) {
 107     case CachedResource::Type::ImageResource:
 108         return new CachedImage(WTFMove(request), sessionID, cookieJar);
 109     case CachedResource::Type::CSSStyleSheet:
 110         return new CachedCSSStyleSheet(WTFMove(request), sessionID, cookieJar);
 111     case CachedResource::Type::Script:
 112         return new CachedScript(WTFMove(request), sessionID, cookieJar);
 113     case CachedResource::Type::SVGDocumentResource:
 114         return new CachedSVGDocument(WTFMove(request), sessionID, cookieJar);
 115 #if ENABLE(SVG_FONTS)
 116     case CachedResource::Type::SVGFontResource:
 117         return new CachedSVGFont(WTFMove(request), sessionID, cookieJar);
 118 #endif
 119     case CachedResource::Type::FontResource:
 120         return new CachedFont(WTFMove(request), sessionID, cookieJar);
 121     case CachedResource::Type::Beacon:

 122     case CachedResource::Type::MediaResource:
 123     case CachedResource::Type::RawResource:
 124     case CachedResource::Type::Icon:
 125     case CachedResource::Type::MainResource:
 126         return new CachedRawResource(WTFMove(request), type, sessionID, cookieJar);
 127 #if ENABLE(XSLT)
 128     case CachedResource::Type::XSLStyleSheet:
 129         return new CachedXSLStyleSheet(WTFMove(request), sessionID, cookieJar);
 130 #endif
 131     case CachedResource::Type::LinkPrefetch:
 132         return new CachedResource(WTFMove(request), CachedResource::Type::LinkPrefetch, sessionID, cookieJar);
 133 #if ENABLE(VIDEO_TRACK)
 134     case CachedResource::Type::TextTrackResource:
 135         return new CachedTextTrack(WTFMove(request), sessionID, cookieJar);
 136 #endif
 137 #if ENABLE(APPLICATION_MANIFEST)
 138     case CachedResource::Type::ApplicationManifest:
 139         return new CachedApplicationManifest(WTFMove(request), sessionID, cookieJar);
 140 #endif
 141     }
</pre>
<hr />
<pre>
 290     // FIXME: Assert request.options().destination is FetchOptions::Destination::{Audio, Video}.
 291     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MediaResource, WTFMove(request)));
 292 }
 293 
 294 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestIcon(CachedResourceRequest&amp;&amp; request)
 295 {
 296     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Icon, WTFMove(request)));
 297 }
 298 
 299 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestRawResource(CachedResourceRequest&amp;&amp; request)
 300 {
 301     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::RawResource, WTFMove(request)));
 302 }
 303 
 304 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestBeaconResource(CachedResourceRequest&amp;&amp; request)
 305 {
 306     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 307     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Beacon, WTFMove(request)));
 308 }
 309 






 310 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp;&amp; request)
 311 {
 312     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MainResource, WTFMove(request)));
 313 }
 314 
 315 #if ENABLE(APPLICATION_MANIFEST)
 316 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedApplicationManifest&gt;&gt; CachedResourceLoader::requestApplicationManifest(CachedResourceRequest&amp;&amp; request)
 317 {
 318     return castCachedResourceTo&lt;CachedApplicationManifest&gt;(requestResource(CachedResource::Type::ApplicationManifest, WTFMove(request)));
 319 }
 320 #endif // ENABLE(APPLICATION_MANIFEST)
 321 
 322 static MixedContentChecker::ContentType contentTypeFromResourceType(CachedResource::Type type)
 323 {
 324     switch (type) {
 325     // https://w3c.github.io/webappsec-mixed-content/#category-optionally-blockable
 326     // Editor&#39;s Draft, 11 February 2016
 327     // 3.1. Optionally-blockable Content
 328     case CachedResource::Type::ImageResource:
 329     case CachedResource::Type::MediaResource:
 330             return MixedContentChecker::ContentType::ActiveCanWarn;
 331 
 332     case CachedResource::Type::CSSStyleSheet:
 333     case CachedResource::Type::Script:
 334     case CachedResource::Type::FontResource:
 335         return MixedContentChecker::ContentType::Active;
 336 
 337 #if ENABLE(SVG_FONTS)
 338     case CachedResource::Type::SVGFontResource:
 339         return MixedContentChecker::ContentType::Active;
 340 #endif
 341 
 342     case CachedResource::Type::Beacon:

 343     case CachedResource::Type::RawResource:
 344     case CachedResource::Type::Icon:
 345     case CachedResource::Type::SVGDocumentResource:
 346         return MixedContentChecker::ContentType::Active;
 347 #if ENABLE(XSLT)
 348     case CachedResource::Type::XSLStyleSheet:
 349         return MixedContentChecker::ContentType::Active;
 350 #endif
 351 
 352     case CachedResource::Type::LinkPrefetch:
 353         return MixedContentChecker::ContentType::Active;
 354 
 355 #if ENABLE(VIDEO_TRACK)
 356     case CachedResource::Type::TextTrackResource:
 357         return MixedContentChecker::ContentType::Active;
 358 #endif
 359 #if ENABLE(APPLICATION_MANIFEST)
 360     case CachedResource::Type::ApplicationManifest:
 361         return MixedContentChecker::ContentType::Active;
 362 #endif
</pre>
<hr />
<pre>
 394     case CachedResource::Type::MediaResource:
 395     case CachedResource::Type::RawResource:
 396     case CachedResource::Type::Icon:
 397     case CachedResource::Type::ImageResource:
 398 #if ENABLE(SVG_FONTS)
 399     case CachedResource::Type::SVGFontResource:
 400 #endif
 401     case CachedResource::Type::FontResource: {
 402         // These resources can corrupt only the frame&#39;s pixels.
 403         if (Frame* frame = this-&gt;frame()) {
 404             if (!frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_document-&gt;securityOrigin(), contentTypeFromResourceType(type), url, MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes))
 405                 return false;
 406             Frame&amp; topFrame = frame-&gt;tree().top();
 407             if (!topFrame.loader().mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), contentTypeFromResourceType(type), url))
 408                 return false;
 409         }
 410         break;
 411     }
 412     case CachedResource::Type::MainResource:
 413     case CachedResource::Type::Beacon:

 414     case CachedResource::Type::LinkPrefetch:
 415         // Prefetch cannot affect the current document.
 416 #if ENABLE(APPLICATION_MANIFEST)
 417     case CachedResource::Type::ApplicationManifest:
 418 #endif
 419         break;
 420     }
 421     return true;
 422 }
 423 
 424 bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const
 425 {
 426     if (options.contentSecurityPolicyImposition == ContentSecurityPolicyImposition::SkipPolicyCheck)
 427         return true;
 428 
 429     ASSERT(m_document);
 430     ASSERT(m_document-&gt;contentSecurityPolicy());
 431 
 432     switch (type) {
 433 #if ENABLE(XSLT)
</pre>
<hr />
<pre>
 445     case CachedResource::Type::Icon:
 446     case CachedResource::Type::ImageResource:
 447         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowImageFromSource(url, redirectResponseReceived))
 448             return false;
 449         break;
 450 #if ENABLE(SVG_FONTS)
 451     case CachedResource::Type::SVGFontResource:
 452 #endif
 453     case CachedResource::Type::FontResource:
 454         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowFontFromSource(url, redirectResponseReceived))
 455             return false;
 456         break;
 457     case CachedResource::Type::MediaResource:
 458 #if ENABLE(VIDEO_TRACK)
 459     case CachedResource::Type::TextTrackResource:
 460 #endif
 461         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowMediaFromSource(url, redirectResponseReceived))
 462             return false;
 463         break;
 464     case CachedResource::Type::Beacon:

 465     case CachedResource::Type::RawResource:
 466         return true;
 467 #if ENABLE(APPLICATION_MANIFEST)
 468     case CachedResource::Type::ApplicationManifest:
 469         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowManifestFromSource(url, redirectResponseReceived))
 470             return false;
 471         break;
 472 #endif
 473     default:
 474         ASSERT_NOT_REACHED();
 475     }
 476 
 477     return true;
 478 }
 479 
 480 static inline bool isSameOriginDataURL(const URL&amp; url, const ResourceLoaderOptions&amp; options)
 481 {
 482     // FIXME: Remove same-origin data URL flag since it was removed from fetch spec (https://github.com/whatwg/fetch/issues/381).
 483     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 484 }
 485 
 486 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 487 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 488 {
 489     auto&amp; options = request.options();
 490 
 491     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 492         if (forPreload == ForPreload::No)
 493             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 494         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 495         return false;
 496     }
 497 
 498     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 499         printAccessDeniedMessage(url);
 500         return false;
 501     }
 502 
<span class="line-modified"> 503     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; options.redirect != FetchOptions::Redirect::Follow) {</span>
 504         ASSERT(type != CachedResource::Type::MainResource);
 505         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 506         return false;
 507     }
 508 
 509     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 510         return false;
 511 
 512     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 513     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 514         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 515             return false;
 516     }
 517 
 518     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 519     // They&#39;ll still get a warning in the console about CSP blocking the load.
 520 
 521     // FIXME: Should we consider whether the request is for preload here?
 522     if (!checkInsecureContent(type, url))
 523         return false;
</pre>
<hr />
<pre>
 560         upgradeInsecureResourceRequestIfNeeded(request, *document);
 561 
 562     // FIXME: We might want to align the checks done here with the ones done in CachedResourceLoader::requestResource, content extensions blocking in particular.
 563 
 564     return canRequestAfterRedirection(type, request.url(), options);
 565 }
 566 
 567 bool CachedResourceLoader::canRequestInContentDispositionAttachmentSandbox(CachedResource::Type type, const URL&amp; url) const
 568 {
 569     Document* document;
 570 
 571     // FIXME: Do we want to expand this to all resource types that the mixed content checker would consider active content?
 572     switch (type) {
 573     case CachedResource::Type::MainResource:
 574         if (auto ownerElement = frame() ? frame()-&gt;ownerElement() : nullptr) {
 575             document = &amp;ownerElement-&gt;document();
 576             break;
 577         }
 578         return true;
 579     case CachedResource::Type::CSSStyleSheet:
<span class="line-modified"> 580         document = m_document;</span>
 581         break;
 582     default:
 583         return true;
 584     }
 585 
 586     if (!document-&gt;shouldEnforceContentDispositionAttachmentSandbox() || document-&gt;securityOrigin().canRequest(url))
 587         return true;
 588 
 589     String message = &quot;Unsafe attempt to load URL &quot; + url.stringCenterEllipsizedToLength() + &quot; from document with Content-Disposition: attachment at URL &quot; + document-&gt;url().stringCenterEllipsizedToLength() + &quot;.&quot;;
 590     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 591     return false;
 592 }
 593 
 594 bool CachedResourceLoader::shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp; request, CachedResource&amp; resource, ResourceError&amp; error)
 595 {
 596     if (!frame() || resource.status() != CachedResource::Cached)
 597         return true;
 598 
 599     ResourceRequest newRequest = ResourceRequest(resource.url());
 600     newRequest.setInitiatorIdentifier(request.resourceRequest().initiatorIdentifier());
</pre>
<hr />
<pre>
 621 #endif
 622 
 623 #if ENABLE(XSLT)
 624     // Load is same-origin, we do not check for CORS.
 625     if (resource.type() == CachedResource::Type::XSLStyleSheet)
 626         return false;
 627 #endif
 628 
 629     // FIXME: We should enable resource reuse for these resource types
 630     switch (resource.type()) {
 631     case CachedResource::Type::SVGDocumentResource:
 632         return false;
 633     case CachedResource::Type::MainResource:
 634         return false;
 635     case CachedResource::Type::LinkPrefetch:
 636         return false;
 637     default:
 638         break;
 639     }
 640 
<span class="line-modified"> 641     if (resource.options().mode != request.options().mode || !originsMatch(request.origin(), resource.origin()))</span>
 642         return true;
 643 
 644     if (resource.options().redirect != request.options().redirect &amp;&amp; resource.hasRedirections())
 645         return true;
 646 
 647     return false;
 648 }
 649 
 650 static inline bool isResourceSuitableForDirectReuse(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 651 {
 652     // FIXME: For being loaded requests, the response tainting may not be correctly computed if the fetch mode is not the same.
 653     // Even if the fetch mode is the same, we are not sure that the resource can be reused (Vary: Origin header for instance).
 654     // We should find a way to improve this.
 655     if (resource.status() != CachedResource::Cached)
 656         return false;
 657 
 658     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 659     // Let&#39;s make sure the memory cache has no such resource.
 660     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 661 
 662     // We could support redirect modes other than Follow in case of a redirected resource.
 663     // This case is rare and is not worth optimizing currently.
 664     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 665         return false;
 666 
 667     // FIXME: Implement reuse of cached raw resources.
 668     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 669         return false;
 670 
<span class="line-modified"> 671     if (resource.type() == CachedResource::Type::Beacon)</span>
 672         return false;
 673 
 674     return true;
 675 }
 676 
 677 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 678 {
 679     if (!isResourceSuitableForDirectReuse(resource, request)) {
 680         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 681         return loadResource(resource.type(), WTFMove(request), cookieJar);
 682     }
 683 
 684     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, cookieJar);
 685     resourceHandle-&gt;loadFrom(resource);
 686     return resourceHandle;
 687 }
 688 
 689 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 690 {
 691     if (!frame || !frame-&gt;page())
</pre>
<hr />
<pre>
 744     case CachedResource::Type::Script:
 745         return FetchOptions::Destination::Script;
 746     case CachedResource::Type::FontResource:
 747 #if ENABLE(SVG_FONTS)
 748     case CachedResource::Type::SVGFontResource:
 749 #endif
 750         return FetchOptions::Destination::Font;
 751 #if ENABLE(XSLT)
 752     case CachedResource::Type::XSLStyleSheet:
 753         return FetchOptions::Destination::Xslt;
 754 #endif
 755 #if ENABLE(VIDEO_TRACK)
 756     case CachedResource::Type::TextTrackResource:
 757         return FetchOptions::Destination::Track;
 758 #endif
 759 #if ENABLE(APPLICATION_MANIFEST)
 760     case CachedResource::Type::ApplicationManifest:
 761         return FetchOptions::Destination::Manifest;
 762 #endif
 763     case CachedResource::Type::Beacon:

 764     case CachedResource::Type::LinkPrefetch:
 765     case CachedResource::Type::RawResource:
 766     case CachedResource::Type::MediaResource:
 767         // The caller is responsible for setting the appropriate destination.
 768         return FetchOptions::Destination::EmptyString;
 769     }
 770     ASSERT_NOT_REACHED();
 771     return FetchOptions::Destination::EmptyString;
 772 }
 773 
 774 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 775 {
 776     request.setDestinationIfNotSet(destinationForType(type));
 777 
 778     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 779     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 780     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
<span class="line-modified"> 781         originalRequest = std::make_unique&lt;ResourceRequest&gt;(request.resourceRequest());</span>
 782         originalRequest-&gt;clearHTTPReferrer();
 783         originalRequest-&gt;clearHTTPOrigin();
 784     }
 785 
 786     if (Document* document = this-&gt;document())
 787         request.upgradeInsecureRequestIfNeeded(*document);
 788 
 789     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 790     URL url = request.resourceRequest().url();
 791 
 792     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 793 
 794     if (!url.isValid()) {
 795         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, frame());
 796         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 797     }
 798 
 799     prepareFetch(type, request);
 800 
 801     // We are passing url as well as request, as request url may contain a fragment identifier.
 802     if (!canRequest(type, url, request, forPreload)) {
 803         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, frame());
 804         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 805     }
 806 
 807 #if ENABLE(CONTENT_EXTENSIONS)
 808     if (frame() &amp;&amp; frame()-&gt;page() &amp;&amp; m_documentLoader) {
 809         const auto&amp; resourceRequest = request.resourceRequest();
 810         auto* page = frame()-&gt;page();
<span class="line-modified"> 811         auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(resourceRequest.url(), toResourceType(type), *m_documentLoader);</span>
<span class="line-modified"> 812         request.applyBlockedStatus(blockedStatus, page);</span>
<span class="line-modified"> 813         if (blockedStatus.blockedLoad) {</span>


 814             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, frame());
 815             if (type == CachedResource::Type::MainResource) {
 816                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
 817                 ASSERT(resource);
 818                 resource-&gt;error(CachedResource::Status::LoadError);
 819                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
<span class="line-modified"> 820                 return WTFMove(resource);</span>
 821             }
 822             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 823         }
<span class="line-modified"> 824         if (blockedStatus.madeHTTPS</span>
 825             &amp;&amp; type == CachedResource::Type::MainResource
 826             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 827             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 828             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 829         }
 830         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 831         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 832     }
 833 #endif
 834 
 835     if (frame() &amp;&amp; m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {
 836         bool sameOriginRequest = false;
 837         auto requestedOrigin = SecurityOrigin::create(url);
 838         if (type == CachedResource::Type::MainResource) {
 839             if (frame()-&gt;isMainFrame())
 840                 sameOriginRequest = true;
 841             else if (auto* topDocument = frame()-&gt;mainFrame().document())
 842                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 843         } else if (document()) {
 844             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 845                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 846         }
<span class="line-modified"> 847         if (sameOriginRequest) {</span>
<span class="line-modified"> 848             for (auto&amp; field : m_documentLoader-&gt;customHeaderFields())</span>
<span class="line-modified"> 849                 request.resourceRequest().setHTTPHeaderField(field.name(), field.value());</span>


 850         }
 851     }
 852 
 853     LoadTiming loadTiming;
 854     loadTiming.markStartTimeAndFetchStart();
 855     InitiatorContext initiatorContext = request.options().initiatorContext;
 856 
 857     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 858         updateHTTPRequestHeaders(type, request);
 859 
 860     auto&amp; memoryCache = MemoryCache::singleton();
 861     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 862         m_documentResources.remove(url.string());
 863 
 864     // See if we can use an existing resource from the cache.
 865     CachedResourceHandle&lt;CachedResource&gt; resource;
 866     if (document())
 867         request.setDomainForCachePartition(*document());
 868 
 869     if (request.allowsCaching())
</pre>
<hr />
<pre>
 939         resource-&gt;load(*this);
 940 
 941         // We don&#39;t support immediate loads, but we do support immediate failure.
 942         if (resource-&gt;errorOccurred()) {
 943             if (resource-&gt;allowsCaching() &amp;&amp; resource-&gt;inCache())
 944                 memoryCache.remove(*resource);
 945 
 946             auto resourceError = resource-&gt;resourceError();
 947             // Synchronous cancellations are likely due to access control.
 948             if (resourceError.isNull() || resourceError.isCancellation())
 949                 return makeUnexpected(ResourceError { String(), 0, url, String(), ResourceError::Type::AccessControl });
 950             return makeUnexpected(resourceError);
 951         }
 952     }
 953 
 954     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; !resource-&gt;resourceRequest().url().protocolIsData())
 955         m_validatedURLs.add(resource-&gt;resourceRequest().url());
 956 
 957     ASSERT(resource-&gt;url() == url.string());
 958     m_documentResources.set(resource-&gt;url(), resource);
<span class="line-modified"> 959     return WTFMove(resource);</span>
 960 }
 961 
 962 void CachedResourceLoader::documentDidFinishLoadEvent()
 963 {
 964     m_validatedURLs.clear();
 965 
 966     // If m_preloads is not empty here, it&#39;s full of link preloads,
 967     // as speculative preloads were cleared at DCL.
 968     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 969         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 970 }
 971 
 972 void CachedResourceLoader::stopUnusedPreloadsTimer()
 973 {
 974     m_unusedPreloadsTimer.stop();
 975 }
 976 
 977 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
 978 {
 979     ASSERT(resource.inCache());
</pre>
<hr />
<pre>
1283             return CachePolicyReload;
1284     }
1285 
1286     switch (frame-&gt;loader().loadType()) {
1287     case FrameLoadType::ReloadFromOrigin:
1288     case FrameLoadType::Reload:
1289         return CachePolicyReload;
1290     case FrameLoadType::Back:
1291     case FrameLoadType::Forward:
1292     case FrameLoadType::IndexedBackForward:
1293         // Do not revalidate cached main resource on back/forward navigation.
1294         return CachePolicyHistoryBuffer;
1295     default:
1296         return CachePolicyVerify;
1297     }
1298 }
1299 
1300 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1301 {
1302     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
<span class="line-modified">1303     RefPtr&lt;Document&gt; protectDocument(m_document);</span>
1304 
1305     ASSERT(shouldPerformPostLoadActions || type == LoadCompletionType::Cancel);
1306 
1307     if (frame())
1308         frame()-&gt;loader().loadDone(type);
1309 
1310     if (shouldPerformPostLoadActions)
1311         performPostLoadActions();
1312 
1313     if (!m_garbageCollectDocumentResourcesTimer.isActive())
1314         m_garbageCollectDocumentResourcesTimer.startOneShot(0_s);
1315 }
1316 
1317 // Garbage collecting m_documentResources is a workaround for the
1318 // CachedResourceHandles on the RHS being strong references. Ideally this
1319 // would be a weak map, however CachedResourceHandles perform additional
1320 // bookkeeping on CachedResources, so instead pseudo-GC them -- when the
1321 // reference count reaches 1, m_documentResources is the only reference, so
1322 // remove it from the map.
1323 void CachedResourceLoader::garbageCollectDocumentResources()
</pre>
<hr />
<pre>
1357         return;
1358 
1359     --m_requestCount;
1360     ASSERT(m_requestCount &gt; -1);
1361 }
1362 
1363 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1364 {
1365     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1366         request.setCharset(m_document-&gt;charset());
1367 
1368     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1369     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1370         auto resourceValue = resource.value();
1371         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1372         if (type == CachedResource::Type::FontResource)
1373             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1374         resourceValue-&gt;increasePreloadCount();
1375 
1376         if (!m_preloads)
<span class="line-modified">1377             m_preloads = std::make_unique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();</span>
1378         m_preloads-&gt;add(resourceValue.get());
1379     }
1380     return resource;
1381 }
1382 
1383 void CachedResourceLoader::warnUnusedPreloads()
1384 {
1385     if (!m_preloads)
1386         return;
1387     for (const auto&amp; resource : *m_preloads) {
1388         if (resource &amp;&amp; resource-&gt;isLinkPreload() &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced &amp;&amp; document()) {
1389             document()-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Warning,
1390                 &quot;The resource &quot; + resource-&gt;url().string() +
1391                 &quot; was preloaded using link preload but not used within a few seconds from the window&#39;s load event. Please make sure it wasn&#39;t preloaded for nothing.&quot;);
1392         }
1393     }
1394 }
1395 
1396 bool CachedResourceLoader::isPreloaded(const String&amp; urlString) const
1397 {
</pre>
<hr />
<pre>
1399 
1400     if (m_preloads) {
1401         for (auto&amp; resource : *m_preloads) {
1402             if (resource-&gt;url() == url)
1403                 return true;
1404         }
1405     }
1406     return false;
1407 }
1408 
1409 void CachedResourceLoader::clearPreloads(ClearPreloadsMode mode)
1410 {
1411     if (!m_preloads)
1412         return;
1413 
1414     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; remainingLinkPreloads;
1415     for (auto* resource : *m_preloads) {
1416         ASSERT(resource);
1417         if (mode == ClearPreloadsMode::ClearSpeculativePreloads &amp;&amp; resource-&gt;isLinkPreload()) {
1418             if (!remainingLinkPreloads)
<span class="line-modified">1419                 remainingLinkPreloads = std::make_unique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();</span>
1420             remainingLinkPreloads-&gt;add(resource);
1421             continue;
1422         }
1423         resource-&gt;decreasePreloadCount();
1424         bool deleted = resource-&gt;deleteIfPossible();
1425         if (!deleted &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced)
1426             MemoryCache::singleton().remove(*resource);
1427     }
1428     m_preloads = WTFMove(remainingLinkPreloads);
1429 }
1430 
1431 const ResourceLoaderOptions&amp; CachedResourceLoader::defaultCachedResourceOptions()
1432 {
1433     static NeverDestroyed&lt;ResourceLoaderOptions&gt; options(
1434         SendCallbackPolicy::SendCallbacks,
1435         ContentSniffingPolicy::SniffContent,
1436         DataBufferingPolicy::BufferData,
1437         StoredCredentialsPolicy::Use,
1438         ClientCredentialPolicy::MayAskClientForCredentials,
1439         FetchOptions::Credentials::Include,
</pre>
</td>
<td>
<hr />
<pre>
  23     This class provides all functionality needed for loading images, style sheets and html
  24     pages from the web. It has a memory cache for these objects.
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
<span class="line-added">  43 #include &quot;ContentRuleListResults.h&quot;</span>
  44 #include &quot;ContentSecurityPolicy.h&quot;
  45 #include &quot;CrossOriginAccessControl.h&quot;
<span class="line-added">  46 #include &quot;CustomHeaderFields.h&quot;</span>
  47 #include &quot;DOMWindow.h&quot;
  48 #include &quot;DiagnosticLoggingClient.h&quot;
  49 #include &quot;DiagnosticLoggingKeys.h&quot;
  50 #include &quot;Document.h&quot;
  51 #include &quot;DocumentLoader.h&quot;
  52 #include &quot;Frame.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameLoaderClient.h&quot;
  55 #include &quot;HTMLElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderField.h&quot;
  58 #include &quot;LoaderStrategy.h&quot;
  59 #include &quot;LocalizedStrings.h&quot;
  60 #include &quot;Logging.h&quot;
  61 #include &quot;MemoryCache.h&quot;
  62 #include &quot;Page.h&quot;
  63 #include &quot;PingLoader.h&quot;
  64 #include &quot;PlatformStrategies.h&quot;
  65 #include &quot;RenderElement.h&quot;
  66 #include &quot;ResourceLoadInfo.h&quot;
</pre>
<hr />
<pre>
 104 }
 105 
 106 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 107 {
 108     switch (type) {
 109     case CachedResource::Type::ImageResource:
 110         return new CachedImage(WTFMove(request), sessionID, cookieJar);
 111     case CachedResource::Type::CSSStyleSheet:
 112         return new CachedCSSStyleSheet(WTFMove(request), sessionID, cookieJar);
 113     case CachedResource::Type::Script:
 114         return new CachedScript(WTFMove(request), sessionID, cookieJar);
 115     case CachedResource::Type::SVGDocumentResource:
 116         return new CachedSVGDocument(WTFMove(request), sessionID, cookieJar);
 117 #if ENABLE(SVG_FONTS)
 118     case CachedResource::Type::SVGFontResource:
 119         return new CachedSVGFont(WTFMove(request), sessionID, cookieJar);
 120 #endif
 121     case CachedResource::Type::FontResource:
 122         return new CachedFont(WTFMove(request), sessionID, cookieJar);
 123     case CachedResource::Type::Beacon:
<span class="line-added"> 124     case CachedResource::Type::Ping:</span>
 125     case CachedResource::Type::MediaResource:
 126     case CachedResource::Type::RawResource:
 127     case CachedResource::Type::Icon:
 128     case CachedResource::Type::MainResource:
 129         return new CachedRawResource(WTFMove(request), type, sessionID, cookieJar);
 130 #if ENABLE(XSLT)
 131     case CachedResource::Type::XSLStyleSheet:
 132         return new CachedXSLStyleSheet(WTFMove(request), sessionID, cookieJar);
 133 #endif
 134     case CachedResource::Type::LinkPrefetch:
 135         return new CachedResource(WTFMove(request), CachedResource::Type::LinkPrefetch, sessionID, cookieJar);
 136 #if ENABLE(VIDEO_TRACK)
 137     case CachedResource::Type::TextTrackResource:
 138         return new CachedTextTrack(WTFMove(request), sessionID, cookieJar);
 139 #endif
 140 #if ENABLE(APPLICATION_MANIFEST)
 141     case CachedResource::Type::ApplicationManifest:
 142         return new CachedApplicationManifest(WTFMove(request), sessionID, cookieJar);
 143 #endif
 144     }
</pre>
<hr />
<pre>
 293     // FIXME: Assert request.options().destination is FetchOptions::Destination::{Audio, Video}.
 294     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MediaResource, WTFMove(request)));
 295 }
 296 
 297 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestIcon(CachedResourceRequest&amp;&amp; request)
 298 {
 299     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Icon, WTFMove(request)));
 300 }
 301 
 302 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestRawResource(CachedResourceRequest&amp;&amp; request)
 303 {
 304     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::RawResource, WTFMove(request)));
 305 }
 306 
 307 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestBeaconResource(CachedResourceRequest&amp;&amp; request)
 308 {
 309     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 310     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Beacon, WTFMove(request)));
 311 }
 312 
<span class="line-added"> 313 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestPingResource(CachedResourceRequest&amp;&amp; request)</span>
<span class="line-added"> 314 {</span>
<span class="line-added"> 315     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);</span>
<span class="line-added"> 316     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Ping, WTFMove(request)));</span>
<span class="line-added"> 317 }</span>
<span class="line-added"> 318 </span>
 319 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp;&amp; request)
 320 {
 321     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MainResource, WTFMove(request)));
 322 }
 323 
 324 #if ENABLE(APPLICATION_MANIFEST)
 325 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedApplicationManifest&gt;&gt; CachedResourceLoader::requestApplicationManifest(CachedResourceRequest&amp;&amp; request)
 326 {
 327     return castCachedResourceTo&lt;CachedApplicationManifest&gt;(requestResource(CachedResource::Type::ApplicationManifest, WTFMove(request)));
 328 }
 329 #endif // ENABLE(APPLICATION_MANIFEST)
 330 
 331 static MixedContentChecker::ContentType contentTypeFromResourceType(CachedResource::Type type)
 332 {
 333     switch (type) {
 334     // https://w3c.github.io/webappsec-mixed-content/#category-optionally-blockable
 335     // Editor&#39;s Draft, 11 February 2016
 336     // 3.1. Optionally-blockable Content
 337     case CachedResource::Type::ImageResource:
 338     case CachedResource::Type::MediaResource:
 339             return MixedContentChecker::ContentType::ActiveCanWarn;
 340 
 341     case CachedResource::Type::CSSStyleSheet:
 342     case CachedResource::Type::Script:
 343     case CachedResource::Type::FontResource:
 344         return MixedContentChecker::ContentType::Active;
 345 
 346 #if ENABLE(SVG_FONTS)
 347     case CachedResource::Type::SVGFontResource:
 348         return MixedContentChecker::ContentType::Active;
 349 #endif
 350 
 351     case CachedResource::Type::Beacon:
<span class="line-added"> 352     case CachedResource::Type::Ping:</span>
 353     case CachedResource::Type::RawResource:
 354     case CachedResource::Type::Icon:
 355     case CachedResource::Type::SVGDocumentResource:
 356         return MixedContentChecker::ContentType::Active;
 357 #if ENABLE(XSLT)
 358     case CachedResource::Type::XSLStyleSheet:
 359         return MixedContentChecker::ContentType::Active;
 360 #endif
 361 
 362     case CachedResource::Type::LinkPrefetch:
 363         return MixedContentChecker::ContentType::Active;
 364 
 365 #if ENABLE(VIDEO_TRACK)
 366     case CachedResource::Type::TextTrackResource:
 367         return MixedContentChecker::ContentType::Active;
 368 #endif
 369 #if ENABLE(APPLICATION_MANIFEST)
 370     case CachedResource::Type::ApplicationManifest:
 371         return MixedContentChecker::ContentType::Active;
 372 #endif
</pre>
<hr />
<pre>
 404     case CachedResource::Type::MediaResource:
 405     case CachedResource::Type::RawResource:
 406     case CachedResource::Type::Icon:
 407     case CachedResource::Type::ImageResource:
 408 #if ENABLE(SVG_FONTS)
 409     case CachedResource::Type::SVGFontResource:
 410 #endif
 411     case CachedResource::Type::FontResource: {
 412         // These resources can corrupt only the frame&#39;s pixels.
 413         if (Frame* frame = this-&gt;frame()) {
 414             if (!frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_document-&gt;securityOrigin(), contentTypeFromResourceType(type), url, MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes))
 415                 return false;
 416             Frame&amp; topFrame = frame-&gt;tree().top();
 417             if (!topFrame.loader().mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), contentTypeFromResourceType(type), url))
 418                 return false;
 419         }
 420         break;
 421     }
 422     case CachedResource::Type::MainResource:
 423     case CachedResource::Type::Beacon:
<span class="line-added"> 424     case CachedResource::Type::Ping:</span>
 425     case CachedResource::Type::LinkPrefetch:
 426         // Prefetch cannot affect the current document.
 427 #if ENABLE(APPLICATION_MANIFEST)
 428     case CachedResource::Type::ApplicationManifest:
 429 #endif
 430         break;
 431     }
 432     return true;
 433 }
 434 
 435 bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const
 436 {
 437     if (options.contentSecurityPolicyImposition == ContentSecurityPolicyImposition::SkipPolicyCheck)
 438         return true;
 439 
 440     ASSERT(m_document);
 441     ASSERT(m_document-&gt;contentSecurityPolicy());
 442 
 443     switch (type) {
 444 #if ENABLE(XSLT)
</pre>
<hr />
<pre>
 456     case CachedResource::Type::Icon:
 457     case CachedResource::Type::ImageResource:
 458         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowImageFromSource(url, redirectResponseReceived))
 459             return false;
 460         break;
 461 #if ENABLE(SVG_FONTS)
 462     case CachedResource::Type::SVGFontResource:
 463 #endif
 464     case CachedResource::Type::FontResource:
 465         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowFontFromSource(url, redirectResponseReceived))
 466             return false;
 467         break;
 468     case CachedResource::Type::MediaResource:
 469 #if ENABLE(VIDEO_TRACK)
 470     case CachedResource::Type::TextTrackResource:
 471 #endif
 472         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowMediaFromSource(url, redirectResponseReceived))
 473             return false;
 474         break;
 475     case CachedResource::Type::Beacon:
<span class="line-added"> 476     case CachedResource::Type::Ping:</span>
 477     case CachedResource::Type::RawResource:
 478         return true;
 479 #if ENABLE(APPLICATION_MANIFEST)
 480     case CachedResource::Type::ApplicationManifest:
 481         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowManifestFromSource(url, redirectResponseReceived))
 482             return false;
 483         break;
 484 #endif
 485     default:
 486         ASSERT_NOT_REACHED();
 487     }
 488 
 489     return true;
 490 }
 491 
 492 static inline bool isSameOriginDataURL(const URL&amp; url, const ResourceLoaderOptions&amp; options)
 493 {
 494     // FIXME: Remove same-origin data URL flag since it was removed from fetch spec (https://github.com/whatwg/fetch/issues/381).
 495     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 496 }
 497 
 498 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 499 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 500 {
 501     auto&amp; options = request.options();
 502 
 503     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 504         if (forPreload == ForPreload::No)
 505             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 506         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 507         return false;
 508     }
 509 
 510     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 511         printAccessDeniedMessage(url);
 512         return false;
 513     }
 514 
<span class="line-modified"> 515     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; options.redirect != FetchOptions::Redirect::Follow &amp;&amp; type != CachedResource::Type::Ping) {</span>
 516         ASSERT(type != CachedResource::Type::MainResource);
 517         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 518         return false;
 519     }
 520 
 521     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 522         return false;
 523 
 524     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 525     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 526         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 527             return false;
 528     }
 529 
 530     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 531     // They&#39;ll still get a warning in the console about CSP blocking the load.
 532 
 533     // FIXME: Should we consider whether the request is for preload here?
 534     if (!checkInsecureContent(type, url))
 535         return false;
</pre>
<hr />
<pre>
 572         upgradeInsecureResourceRequestIfNeeded(request, *document);
 573 
 574     // FIXME: We might want to align the checks done here with the ones done in CachedResourceLoader::requestResource, content extensions blocking in particular.
 575 
 576     return canRequestAfterRedirection(type, request.url(), options);
 577 }
 578 
 579 bool CachedResourceLoader::canRequestInContentDispositionAttachmentSandbox(CachedResource::Type type, const URL&amp; url) const
 580 {
 581     Document* document;
 582 
 583     // FIXME: Do we want to expand this to all resource types that the mixed content checker would consider active content?
 584     switch (type) {
 585     case CachedResource::Type::MainResource:
 586         if (auto ownerElement = frame() ? frame()-&gt;ownerElement() : nullptr) {
 587             document = &amp;ownerElement-&gt;document();
 588             break;
 589         }
 590         return true;
 591     case CachedResource::Type::CSSStyleSheet:
<span class="line-modified"> 592         document = m_document.get();</span>
 593         break;
 594     default:
 595         return true;
 596     }
 597 
 598     if (!document-&gt;shouldEnforceContentDispositionAttachmentSandbox() || document-&gt;securityOrigin().canRequest(url))
 599         return true;
 600 
 601     String message = &quot;Unsafe attempt to load URL &quot; + url.stringCenterEllipsizedToLength() + &quot; from document with Content-Disposition: attachment at URL &quot; + document-&gt;url().stringCenterEllipsizedToLength() + &quot;.&quot;;
 602     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 603     return false;
 604 }
 605 
 606 bool CachedResourceLoader::shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp; request, CachedResource&amp; resource, ResourceError&amp; error)
 607 {
 608     if (!frame() || resource.status() != CachedResource::Cached)
 609         return true;
 610 
 611     ResourceRequest newRequest = ResourceRequest(resource.url());
 612     newRequest.setInitiatorIdentifier(request.resourceRequest().initiatorIdentifier());
</pre>
<hr />
<pre>
 633 #endif
 634 
 635 #if ENABLE(XSLT)
 636     // Load is same-origin, we do not check for CORS.
 637     if (resource.type() == CachedResource::Type::XSLStyleSheet)
 638         return false;
 639 #endif
 640 
 641     // FIXME: We should enable resource reuse for these resource types
 642     switch (resource.type()) {
 643     case CachedResource::Type::SVGDocumentResource:
 644         return false;
 645     case CachedResource::Type::MainResource:
 646         return false;
 647     case CachedResource::Type::LinkPrefetch:
 648         return false;
 649     default:
 650         break;
 651     }
 652 
<span class="line-modified"> 653     if (resource.options().mode != request.options().mode || !serializedOriginsMatch(request.origin(), resource.origin()))</span>
 654         return true;
 655 
 656     if (resource.options().redirect != request.options().redirect &amp;&amp; resource.hasRedirections())
 657         return true;
 658 
 659     return false;
 660 }
 661 
 662 static inline bool isResourceSuitableForDirectReuse(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 663 {
 664     // FIXME: For being loaded requests, the response tainting may not be correctly computed if the fetch mode is not the same.
 665     // Even if the fetch mode is the same, we are not sure that the resource can be reused (Vary: Origin header for instance).
 666     // We should find a way to improve this.
 667     if (resource.status() != CachedResource::Cached)
 668         return false;
 669 
 670     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 671     // Let&#39;s make sure the memory cache has no such resource.
 672     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 673 
 674     // We could support redirect modes other than Follow in case of a redirected resource.
 675     // This case is rare and is not worth optimizing currently.
 676     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 677         return false;
 678 
 679     // FIXME: Implement reuse of cached raw resources.
 680     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 681         return false;
 682 
<span class="line-modified"> 683     if (resource.type() == CachedResource::Type::Beacon || resource.type() == CachedResource::Type::Ping)</span>
 684         return false;
 685 
 686     return true;
 687 }
 688 
 689 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 690 {
 691     if (!isResourceSuitableForDirectReuse(resource, request)) {
 692         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 693         return loadResource(resource.type(), WTFMove(request), cookieJar);
 694     }
 695 
 696     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, cookieJar);
 697     resourceHandle-&gt;loadFrom(resource);
 698     return resourceHandle;
 699 }
 700 
 701 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 702 {
 703     if (!frame || !frame-&gt;page())
</pre>
<hr />
<pre>
 756     case CachedResource::Type::Script:
 757         return FetchOptions::Destination::Script;
 758     case CachedResource::Type::FontResource:
 759 #if ENABLE(SVG_FONTS)
 760     case CachedResource::Type::SVGFontResource:
 761 #endif
 762         return FetchOptions::Destination::Font;
 763 #if ENABLE(XSLT)
 764     case CachedResource::Type::XSLStyleSheet:
 765         return FetchOptions::Destination::Xslt;
 766 #endif
 767 #if ENABLE(VIDEO_TRACK)
 768     case CachedResource::Type::TextTrackResource:
 769         return FetchOptions::Destination::Track;
 770 #endif
 771 #if ENABLE(APPLICATION_MANIFEST)
 772     case CachedResource::Type::ApplicationManifest:
 773         return FetchOptions::Destination::Manifest;
 774 #endif
 775     case CachedResource::Type::Beacon:
<span class="line-added"> 776     case CachedResource::Type::Ping:</span>
 777     case CachedResource::Type::LinkPrefetch:
 778     case CachedResource::Type::RawResource:
 779     case CachedResource::Type::MediaResource:
 780         // The caller is responsible for setting the appropriate destination.
 781         return FetchOptions::Destination::EmptyString;
 782     }
 783     ASSERT_NOT_REACHED();
 784     return FetchOptions::Destination::EmptyString;
 785 }
 786 
 787 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 788 {
 789     request.setDestinationIfNotSet(destinationForType(type));
 790 
 791     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 792     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 793     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
<span class="line-modified"> 794         originalRequest = makeUnique&lt;ResourceRequest&gt;(request.resourceRequest());</span>
 795         originalRequest-&gt;clearHTTPReferrer();
 796         originalRequest-&gt;clearHTTPOrigin();
 797     }
 798 
 799     if (Document* document = this-&gt;document())
 800         request.upgradeInsecureRequestIfNeeded(*document);
 801 
 802     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 803     URL url = request.resourceRequest().url();
 804 
 805     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 806 
 807     if (!url.isValid()) {
 808         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, frame());
 809         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 810     }
 811 
 812     prepareFetch(type, request);
 813 
 814     // We are passing url as well as request, as request url may contain a fragment identifier.
 815     if (!canRequest(type, url, request, forPreload)) {
 816         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, frame());
 817         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 818     }
 819 
 820 #if ENABLE(CONTENT_EXTENSIONS)
 821     if (frame() &amp;&amp; frame()-&gt;page() &amp;&amp; m_documentLoader) {
 822         const auto&amp; resourceRequest = request.resourceRequest();
 823         auto* page = frame()-&gt;page();
<span class="line-modified"> 824         auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(resourceRequest.url(), ContentExtensions::toResourceType(type), *m_documentLoader);</span>
<span class="line-modified"> 825         bool blockedLoad = results.summary.blockedLoad;</span>
<span class="line-modified"> 826         bool madeHTTPS = results.summary.madeHTTPS;</span>
<span class="line-added"> 827         request.applyResults(WTFMove(results), page);</span>
<span class="line-added"> 828         if (blockedLoad) {</span>
 829             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, frame());
 830             if (type == CachedResource::Type::MainResource) {
 831                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
 832                 ASSERT(resource);
 833                 resource-&gt;error(CachedResource::Status::LoadError);
 834                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
<span class="line-modified"> 835                 return resource;</span>
 836             }
 837             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 838         }
<span class="line-modified"> 839         if (madeHTTPS</span>
 840             &amp;&amp; type == CachedResource::Type::MainResource
 841             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 842             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 843             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 844         }
 845         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 846         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 847     }
 848 #endif
 849 
 850     if (frame() &amp;&amp; m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {
 851         bool sameOriginRequest = false;
 852         auto requestedOrigin = SecurityOrigin::create(url);
 853         if (type == CachedResource::Type::MainResource) {
 854             if (frame()-&gt;isMainFrame())
 855                 sameOriginRequest = true;
 856             else if (auto* topDocument = frame()-&gt;mainFrame().document())
 857                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 858         } else if (document()) {
 859             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 860                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 861         }
<span class="line-modified"> 862         for (auto&amp; fields : m_documentLoader-&gt;customHeaderFields()) {</span>
<span class="line-modified"> 863             if (sameOriginRequest || fields.thirdPartyDomainsMatch(url)) {</span>
<span class="line-modified"> 864                 for (auto&amp; field : fields.fields)</span>
<span class="line-added"> 865                     request.resourceRequest().setHTTPHeaderField(field.name(), field.value());</span>
<span class="line-added"> 866             }</span>
 867         }
 868     }
 869 
 870     LoadTiming loadTiming;
 871     loadTiming.markStartTimeAndFetchStart();
 872     InitiatorContext initiatorContext = request.options().initiatorContext;
 873 
 874     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 875         updateHTTPRequestHeaders(type, request);
 876 
 877     auto&amp; memoryCache = MemoryCache::singleton();
 878     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 879         m_documentResources.remove(url.string());
 880 
 881     // See if we can use an existing resource from the cache.
 882     CachedResourceHandle&lt;CachedResource&gt; resource;
 883     if (document())
 884         request.setDomainForCachePartition(*document());
 885 
 886     if (request.allowsCaching())
</pre>
<hr />
<pre>
 956         resource-&gt;load(*this);
 957 
 958         // We don&#39;t support immediate loads, but we do support immediate failure.
 959         if (resource-&gt;errorOccurred()) {
 960             if (resource-&gt;allowsCaching() &amp;&amp; resource-&gt;inCache())
 961                 memoryCache.remove(*resource);
 962 
 963             auto resourceError = resource-&gt;resourceError();
 964             // Synchronous cancellations are likely due to access control.
 965             if (resourceError.isNull() || resourceError.isCancellation())
 966                 return makeUnexpected(ResourceError { String(), 0, url, String(), ResourceError::Type::AccessControl });
 967             return makeUnexpected(resourceError);
 968         }
 969     }
 970 
 971     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; !resource-&gt;resourceRequest().url().protocolIsData())
 972         m_validatedURLs.add(resource-&gt;resourceRequest().url());
 973 
 974     ASSERT(resource-&gt;url() == url.string());
 975     m_documentResources.set(resource-&gt;url(), resource);
<span class="line-modified"> 976     return resource;</span>
 977 }
 978 
 979 void CachedResourceLoader::documentDidFinishLoadEvent()
 980 {
 981     m_validatedURLs.clear();
 982 
 983     // If m_preloads is not empty here, it&#39;s full of link preloads,
 984     // as speculative preloads were cleared at DCL.
 985     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 986         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 987 }
 988 
 989 void CachedResourceLoader::stopUnusedPreloadsTimer()
 990 {
 991     m_unusedPreloadsTimer.stop();
 992 }
 993 
 994 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
 995 {
 996     ASSERT(resource.inCache());
</pre>
<hr />
<pre>
1300             return CachePolicyReload;
1301     }
1302 
1303     switch (frame-&gt;loader().loadType()) {
1304     case FrameLoadType::ReloadFromOrigin:
1305     case FrameLoadType::Reload:
1306         return CachePolicyReload;
1307     case FrameLoadType::Back:
1308     case FrameLoadType::Forward:
1309     case FrameLoadType::IndexedBackForward:
1310         // Do not revalidate cached main resource on back/forward navigation.
1311         return CachePolicyHistoryBuffer;
1312     default:
1313         return CachePolicyVerify;
1314     }
1315 }
1316 
1317 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1318 {
1319     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
<span class="line-modified">1320     RefPtr&lt;Document&gt; protectDocument(m_document.get());</span>
1321 
1322     ASSERT(shouldPerformPostLoadActions || type == LoadCompletionType::Cancel);
1323 
1324     if (frame())
1325         frame()-&gt;loader().loadDone(type);
1326 
1327     if (shouldPerformPostLoadActions)
1328         performPostLoadActions();
1329 
1330     if (!m_garbageCollectDocumentResourcesTimer.isActive())
1331         m_garbageCollectDocumentResourcesTimer.startOneShot(0_s);
1332 }
1333 
1334 // Garbage collecting m_documentResources is a workaround for the
1335 // CachedResourceHandles on the RHS being strong references. Ideally this
1336 // would be a weak map, however CachedResourceHandles perform additional
1337 // bookkeeping on CachedResources, so instead pseudo-GC them -- when the
1338 // reference count reaches 1, m_documentResources is the only reference, so
1339 // remove it from the map.
1340 void CachedResourceLoader::garbageCollectDocumentResources()
</pre>
<hr />
<pre>
1374         return;
1375 
1376     --m_requestCount;
1377     ASSERT(m_requestCount &gt; -1);
1378 }
1379 
1380 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1381 {
1382     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1383         request.setCharset(m_document-&gt;charset());
1384 
1385     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1386     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1387         auto resourceValue = resource.value();
1388         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1389         if (type == CachedResource::Type::FontResource)
1390             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1391         resourceValue-&gt;increasePreloadCount();
1392 
1393         if (!m_preloads)
<span class="line-modified">1394             m_preloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();</span>
1395         m_preloads-&gt;add(resourceValue.get());
1396     }
1397     return resource;
1398 }
1399 
1400 void CachedResourceLoader::warnUnusedPreloads()
1401 {
1402     if (!m_preloads)
1403         return;
1404     for (const auto&amp; resource : *m_preloads) {
1405         if (resource &amp;&amp; resource-&gt;isLinkPreload() &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced &amp;&amp; document()) {
1406             document()-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Warning,
1407                 &quot;The resource &quot; + resource-&gt;url().string() +
1408                 &quot; was preloaded using link preload but not used within a few seconds from the window&#39;s load event. Please make sure it wasn&#39;t preloaded for nothing.&quot;);
1409         }
1410     }
1411 }
1412 
1413 bool CachedResourceLoader::isPreloaded(const String&amp; urlString) const
1414 {
</pre>
<hr />
<pre>
1416 
1417     if (m_preloads) {
1418         for (auto&amp; resource : *m_preloads) {
1419             if (resource-&gt;url() == url)
1420                 return true;
1421         }
1422     }
1423     return false;
1424 }
1425 
1426 void CachedResourceLoader::clearPreloads(ClearPreloadsMode mode)
1427 {
1428     if (!m_preloads)
1429         return;
1430 
1431     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; remainingLinkPreloads;
1432     for (auto* resource : *m_preloads) {
1433         ASSERT(resource);
1434         if (mode == ClearPreloadsMode::ClearSpeculativePreloads &amp;&amp; resource-&gt;isLinkPreload()) {
1435             if (!remainingLinkPreloads)
<span class="line-modified">1436                 remainingLinkPreloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();</span>
1437             remainingLinkPreloads-&gt;add(resource);
1438             continue;
1439         }
1440         resource-&gt;decreasePreloadCount();
1441         bool deleted = resource-&gt;deleteIfPossible();
1442         if (!deleted &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced)
1443             MemoryCache::singleton().remove(*resource);
1444     }
1445     m_preloads = WTFMove(remainingLinkPreloads);
1446 }
1447 
1448 const ResourceLoaderOptions&amp; CachedResourceLoader::defaultCachedResourceOptions()
1449 {
1450     static NeverDestroyed&lt;ResourceLoaderOptions&gt; options(
1451         SendCallbackPolicy::SendCallbacks,
1452         ContentSniffingPolicy::SniffContent,
1453         DataBufferingPolicy::BufferData,
1454         StoredCredentialsPolicy::Use,
1455         ClientCredentialPolicy::MayAskClientForCredentials,
1456         FetchOptions::Credentials::Include,
</pre>
</td>
</tr>
</table>
<center><a href="CachedResource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>